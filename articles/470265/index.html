<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üí¢ üë®‚Äçüë®‚Äçüë¶‚Äçüë¶ ‚ò£Ô∏è C ++ abreviatura hoja de trucos y m√°s. Parte 1: C ++ ü¶í ü•£ ‚è≥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Una vez fui entrevistado para el puesto de desarrollador de C ++ en una oficina decente e incluso conocida. Ya ten√≠a algo de experiencia, incluso en e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C ++ abreviatura hoja de trucos y m√°s. Parte 1: C ++</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/470265/">  Una vez fui entrevistado para el puesto de desarrollador de C ++ en una oficina decente e incluso conocida.  Ya ten√≠a algo de experiencia, incluso en ese momento me llamaron desarrollador l√≠der de mi empleador.  Pero cuando me preguntaron si sab√≠a cosas como DRY, KISS, YAGNI, NIH, tuve que responder "No" una y otra vez. <br><br>  Fall√© miserablemente, por supuesto.  Pero luego las abreviaturas anteriores fueron buscadas en Google y recordadas.  Mientras le√≠a art√≠culos y libros tem√°ticos, me preparaba para entrevistas y solo hablaba con colegas, aprend√≠ m√°s cosas nuevas, las olvid√©, busqu√© en Google nuevamente y entend√≠.  Hace un par de meses, uno de mis colegas mencion√≥ casualmente en el chat de trabajo de IIFE en el contexto de C ++.  Como ese abuelo en una broma, casi me caigo de la estufa y nuevamente me met√≠ en Google. <br><br><img src="https://habrastorage.org/webt/i7/7u/fc/i77ufc8-ui3-rtrvpu-421lmpfq.png"><br><a name="habracut"></a><br>  Fue entonces cuando decid√≠ componer (principalmente para m√≠) una hoja de trucos para abreviaturas que son √∫tiles para que un desarrollador de C ++ conozca.  Esto no significa que se apliquen solo a C ++, o que sean conceptos generales de C ++ (puede escribir vol√∫menes sobre expresiones idiom√°ticas).  No, estos son solo conceptos que realmente encontr√© en el trabajo y las entrevistas, generalmente expresados ‚Äã‚Äãen forma de abreviaturas.  Bueno, me perd√≠ cosas absolutamente triviales como LIFO, FIFO, CRUD, OOP, GCC y MSVC. <br><br>  Sin embargo, las abreviaturas aparecieron decentemente, por lo que divid√≠ la hoja de trucos en 2 partes: fuertemente caracter√≠stica de C ++ y m√°s com√∫n.  Cuando era apropiado, agrup√© los conceptos, de lo contrario simplemente los enumer√© alfab√©ticamente.  En general, no tiene mucho sentido en su orden. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Cosas b√°sicas:</a> <br>  ‚Ä¢ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ODR</a> <br>  ‚Ä¢ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">POD</a> <br>  ‚Ä¢ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">POF</a> <br>  ‚Ä¢ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PIMPL</a> <br>  ‚Ä¢ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RAII</a> <br>  ‚Ä¢ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RTTI</a> <br>  ‚Ä¢ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">STL</a> <br>  ‚Ä¢ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">UB</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Sutilezas del lenguaje:</a> <br>  ‚Ä¢ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ADL</a> <br>  ‚Ä¢ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CRTP</a> <br>  ‚Ä¢ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CTAD</a> <br>  ‚Ä¢ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">EBO</a> <br>  ‚Ä¢ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">IIFE</a> <br>  ‚Ä¢ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">NVI</a> <br>  ‚Ä¢ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RVO y NRVO</a> <br>  ‚Ä¢ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SFINAE</a> <br>  ‚Ä¢ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SBO, SOO, SSO</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><b>ACTUALIZACI√ìN</b></a> <br>  ‚Ä¢ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CV</a> <br>  ‚Ä¢ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">LTO</a> <br>  ‚Ä¢ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PCH</a> <br>  ‚Ä¢ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PGO</a> <br>  ‚Ä¢ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SEH / VEH</a> <br>  ‚Ä¢ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">TMP</a> <br>  ‚Ä¢ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">VLA</a> <br><br><h2>  Cosas basicas <a name="Basics"></a></h2><br><h3>  ODR <a name="ODR"></a></h3><br>  <i>Regla de una definici√≥n.</i>  <i>La regla de una definici√≥n.</i>  Simplificado significa lo siguiente: <br><br><ul><li>  Dentro de una sola unidad de traducci√≥n, cada variable, funci√≥n, clase, etc., no puede tener m√°s de una definici√≥n.  Hay tantos anuncios como sea posible (excepto transferencias sin un tipo base dado, que simplemente no se pueden declarar sin definir), pero no m√°s de una definici√≥n.  Menos posible si la entidad no se utiliza. </li><li>  En todo el programa, cada funci√≥n y variable no en l√≠nea utilizada debe tener exactamente una definici√≥n.  Cada funci√≥n y variable en l√≠nea utilizada debe tener una definici√≥n en cada unidad de traducci√≥n. </li><li>  Algunas entidades, por ejemplo, clases, funciones en l√≠nea y una variable, plantillas, enumeraciones, etc., pueden tener varias definiciones en un programa (pero no m√°s de una en una unidad de traducci√≥n).  En realidad, esto sucede cuando el mismo encabezado que contiene una clase completamente implementada, por ejemplo, est√° conectado a varios archivos .cpp.  Pero estas definiciones deber√≠an coincidir (simplifico enormemente, pero la esencia es esta).  De lo contrario, ser√° <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">UB</a> . </li></ul><br>  El compilador detectar√° f√°cilmente una violaci√≥n de <i>ODR</i> dentro de una unidad de traducci√≥n.  Pero no podr√° hacer nada si se viola la regla a escala de programa, aunque solo sea porque el compilador procesa una unidad de traducci√≥n a la vez. <br><br>  El vinculador puede encontrar muchas m√°s violaciones, pero, estrictamente hablando, no est√° obligado a hacer esto (porque, seg√∫n el Est√°ndar, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">UB est√°</a> aqu√≠) y puede pasar por alto algo.  Adem√°s, el proceso de b√∫squeda de violaciones de <i>ODR</i> en la etapa de vinculaci√≥n tiene una complejidad cuadr√°tica, y el ensamblaje del c√≥digo C ++ no es tan r√°pido. <br><br>  Como resultado, la responsabilidad principal del cumplimiento de esta regla (especialmente a nivel de programa) es el propio desarrollador.  Y s√≠, solo las entidades con un enlace externo pueden violar la <i>ODR</i> a escala de programa;  los del interior (es decir, definidos en espacios de nombres an√≥nimos) no participan en este carnaval. <br><br>  Leer m√°s: una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">vez (ingl√©s)</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">dos (ingl√©s)</a> <br><br><h3>  Vaina <a name="POD"></a></h3><br>  <i>Datos antiguos simples.</i>  <i>Estructura de datos simple.</i>  La definici√≥n m√°s simple: esta es una estructura tal que puede, como es, en forma binaria enviar / recibir desde la biblioteca C.  O, que es lo mismo, copie correctamente con <code>memcpy</code> simple. <br><br>  De est√°ndar a est√°ndar, la definici√≥n completa ha cambiado en detalle.  El √∫ltimo C ++ 17 <i>POD</i> actualmente define c√≥mo <br><br><ul><li>  tipo escalar </li><li>  o una clase / estructura / uni√≥n que: <br>  - hay una clase trivial <br>  - hay una clase con un dispositivo est√°ndar <br>  - no contiene campos no est√°ticos <i>POD</i> <br></li><li>  o una variedad de estos tipos </li></ul><br>  Clase trivial: <br><br><ul><li>  tiene al menos uno no eliminado: <br>  - constructor predeterminado <br>  - constructor de copia <br>  - constructor en movimiento <br>  - operador de asignaci√≥n de copia <br>  - operador de asignaci√≥n de movimiento <br></li><li>  Todos los constructores predeterminados que copian y mueven constructores y operadores de asignaci√≥n son triviales (simplificados, generados por el compilador) o remotos </li><li>  tiene un destructor no remoto trivial </li><li>  Todos los tipos base y todos los campos de los tipos de clase tienen destructores triviales </li><li>  sin m√©todos virtuales (incluido el destructor) </li><li>  sin tipos de base virtual </li></ul><br>  Clase con un dispositivo est√°ndar (clase de dise√±o est√°ndar): <br><br><ul><li>  sin m√©todos virtuales </li><li>  sin tipos de base virtual </li><li>  sin campos de enlace no est√°ticos </li><li>  Todos los campos no est√°ticos tienen el mismo modificador de acceso (p√∫blico / protegido / privado) </li><li>  todos los campos no est√°ticos y las clases base tambi√©n son tipos con un dispositivo est√°ndar </li><li>  Todos los campos no est√°ticos de la clase en s√≠ y todos sus antepasados ‚Äã‚Äãse declaran en una sola clase (es decir, en la clase misma o en uno de los antepasados) </li><li>  No hereda el mismo tipo dos veces, es decir, es imposible hacer esto: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> :</span></span> A {}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> :</span></span> A{}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">D</span></span></span><span class="hljs-class"> :</span></span> B, C {};</code> </pre> </li><li>  el tipo del primer campo no est√°tico o, si es una matriz, el tipo de su elemento no debe coincidir con ninguno de los tipos b√°sicos (debido al <i>EBO</i> obligatorio en este caso) </li></ul><br>  Sin embargo, en C ++ 20 ya no habr√° el concepto de tipo <i>POD</i> , solo permanecer√° el tipo trivial y el tipo con el dispositivo est√°ndar. <br><br>  Leer m√°s: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">uno (ruso)</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">dos (ingl√©s)</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tres (ingl√©s)</a> <br><br><h3>  POF <a name="POF"></a></h3><br>  <i>Funci√≥n antigua simple.</i>  <i>Una funci√≥n simple de estilo C.</i> Mencionada en el Est√°ndar anterior a C ++ 14 inclusive solo en el contexto de los manejadores de se√±al.  Los requisitos para ello son: <br><br><ul><li>  usa solo cosas comunes a C y C ++ (es decir, sin excepciones y <code>try-catch</code> , por ejemplo) </li><li>  no causa directa o indirectamente funciones que no sean <i>POF</i> , con la excepci√≥n de operaciones at√≥micas sin bloques ( <code>std::atomic_init</code> , <code>std::atomic_fetch_add</code> , etc.) </li></ul><br>  El Est√°ndar solo permite que tales funciones, que tambi√©n tienen un enlace C ( <code>extern "C"</code> ), se usen como manejadores de se√±al.  El soporte para otras funciones depende del compilador. <br><br>  En C ++ 17, el concepto de <i>POF</i> desaparece, en lugar de aparecer una evaluaci√≥n segura de se√±al.  En tales c√°lculos est√°n prohibidos: <br><br><ul><li>  llamadas a todas las funciones de la biblioteca est√°ndar, excepto at√≥mica, sin bloqueo </li><li>  <code>new</code> y <code>delete</code> llamadas </li><li>  usando <code>dynamic_cast</code> </li><li>  llamar a la entidad <code>thread_local</code> </li><li>  cualquier trabajo con excepciones </li><li>  inicializaci√≥n de una variable est√°tica local </li><li>  esperando que se complete la inicializaci√≥n de la variable est√°tica </li></ul><br>  Si el manejador de se√±al hace algo de lo anterior, el Est√°ndar promete <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">UB</a> . <br><br>  Leer m√°s: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tiempo (ingl√©s)</a> <br><br><h3>  PIMPL <a name="PIMPL"></a></h3><br>  <i>Puntero a la implementaci√≥n.</i>  <i>Puntero a la implementaci√≥n.</i>  El modismo cl√°sico en C ++, tambi√©n conocido como puntero d, puntero opaco, firewall de compilaci√≥n.  Consiste en el hecho de que todos los m√©todos privados, campos y otros detalles de implementaci√≥n de una determinada clase se asignan a una clase separada, y solo los m√©todos p√∫blicos (es decir, una interfaz) y un puntero a una instancia de esta nueva clase separada permanecen en la clase original.  Por ejemplo: <br><br><div class="spoiler">  <b class="spoiler_title">foo.hpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Foo(); ~Foo(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doThis</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doThat</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Impl</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;Impl&gt; pImpl_; };</code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">foo.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"foo.hpp"</span></span></span><span class="hljs-meta"> class Foo::Impl { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// implementation }; Foo::Foo() : pImpl_(std::make_unique&lt;Impl&gt;()) {} Foo::~Foo() = default; void Foo::doThis() { pImpl_-&gt;doThis(); } int Foo::doThat() { return pImpl_-&gt;doThat(); }</span></span></span></span></code> </pre> <br></div></div><br>  Por qu√© es esto necesario, es decir, ventajas: <br><br><ul><li>  Encapsulaci√≥n: los usuarios de la clase a trav√©s de la conexi√≥n de encabezado obtienen solo lo que necesitan: una interfaz p√∫blica.  Si los detalles de implementaci√≥n cambian, no es necesario volver a compilar el c√≥digo del cliente (ver <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ABI</a> ). </li><li>  Tiempo de compilaci√≥n: dado que el encabezado p√∫blico no sabe nada sobre la implementaci√≥n, no incluye los muchos encabezados que necesita.  En consecuencia, se reduce el n√∫mero de encabezados conectados impl√≠citamente en el c√≥digo del cliente.  La b√∫squeda de nombres y la resoluci√≥n de sobrecargas tambi√©n se simplifica, porque el encabezado p√∫blico no contiene miembros privados (aunque son privados, participan en estos procesos). </li></ul><br>  Precio, es decir, desventajas: <br><br><ul><li>  M√°s al menos una referencia de puntero y m√°s una llamada de funci√≥n al acceder a m√©todos p√∫blicos. </li><li>  El tama√±o de la clase de memoria necesaria aumenta con el tama√±o del puntero. </li><li>  Parte de esta memoria (probablemente m√°s grande) se asigna en el mont√≥n, lo que tambi√©n afecta negativamente el rendimiento. </li><li>  La constancia l√≥gica se puede violar f√°cilmente.  Por ejemplo, dicho c√≥digo compila: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Foo::doThis() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { pImpl_-&gt;doThis(); <span class="hljs-comment"><span class="hljs-comment">// cosnt method pImpl_-&gt;doSmthElse(); // non-const method }</span></span></code> </pre> </li></ul><br>  Algunas de estas deficiencias son removibles, pero el precio complica a√∫n m√°s el c√≥digo e introduce niveles adicionales de abstracci√≥n (ver <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">FTSE</a> ). <br><br>  Leer m√°s: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">uno (ruso)</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">dos (ruso)</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tres (ingl√©s)</a> <br><br><h3>  RAII <a name="RAII"></a></h3><br>  <i>La adquisici√≥n de recursos es la inicializaci√≥n.</i>  <i>Capturar un recurso es la inicializaci√≥n.</i>  El significado de este idioma es que la retenci√≥n de un determinado recurso dura toda la vida del objeto correspondiente.  La captura del recurso ocurre en el momento de la creaci√≥n / inicializaci√≥n del objeto, la liberaci√≥n, en el momento de la destrucci√≥n / finalizaci√≥n del mismo objeto. <br><br>  Curiosamente (principalmente para programadores de C ++), este idioma tambi√©n se usa en otros lenguajes, incluso aquellos con un recolector de basura.  En Java es <code>try--</code> , en Python la instrucci√≥n <code>with</code> , en C # la directiva <code>using</code> , en Go the <code>defer</code> .  Pero es en C ++ con su vida de objetos absolutamente predecible que <i>RAII</i> encaja especialmente org√°nicamente. <br><br>  En C ++, un recurso generalmente se captura en el constructor y se libera en el destructor.  Por ejemplo, los punteros inteligentes controlan la memoria de esta manera, las secuencias de archivos administran los archivos, mutex bloquea los mutexes.  Lo bueno es que no importa c√≥mo se salga el bloque (alcance), es normal a trav√©s de cualquiera de los puntos de salida, o se lanz√≥ una excepci√≥n, el objeto de control de recursos creado en este bloque se destruir√° y el recurso se liberar√°.  Es decir  Adem√°s de encapsular <i>RAII</i> en C ++, tambi√©n ayuda a garantizar la seguridad en el sentido de excepciones. <br><br>  Limitaciones, donde sin ellas.  Los destructores en C ++ no devuelven valores y categ√≥ricamente no deber√≠an arrojar excepciones.  En consecuencia, si la liberaci√≥n del recurso va acompa√±ada de uno u otro, ser√° necesario implementar una l√≥gica adicional en el destructor del objeto de control. <br><br>  Leer m√°s: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">una vez (ruso)</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">dos (ingl√©s)</a> <br><br><h3>  RTTI <a name="RTTI"></a></h3><br>  <i>Informaci√≥n de tipo de tiempo de ejecuci√≥n.</i>  <i>Identificaci√≥n de tipo en tiempo de ejecuci√≥n.</i>  Este es un mecanismo para obtener informaci√≥n sobre el tipo de un objeto o expresi√≥n en tiempo de ejecuci√≥n.  Existe en otros lenguajes, pero en C ++ se usa para: <br><br><ul><li> <code>dynamic_cast</code> </li> <li>  <code>typeid</code> y <code>type_info</code> </li><li>  capturar excepci√≥n </li></ul><br>  Una limitaci√≥n importante: <i>RTTI</i> utiliza una tabla de funciones virtuales y, por lo tanto, solo funciona para tipos polim√≥rficos (un destructor virtual es suficiente).  Una explicaci√≥n importante: <code>dynamic_cast</code> y <code>typeid</code> no siempre usan <i>RTTI</i> , y por lo tanto funcionan para tipos no polim√≥rficos.  Por ejemplo, para emitir din√°micamente un enlace a un descendiente a un enlace a un antepasado, <i>RTTI</i> no <i>es</i> necesario; toda la informaci√≥n est√° disponible en tiempo de compilaci√≥n. <br><br>  <i>RTTI</i> no <i>es</i> gratuito, aunque sea un poco, pero afecta negativamente el rendimiento y el tama√±o de la memoria consumida (de ah√≠ el consejo frecuente de no utilizar <code>dynamic_cast</code> debido a su lentitud).  Por lo tanto, los compiladores, como regla, le permiten deshabilitar <i>RTTI</i> .  GCC y MSVC prometen que esto no afectar√° la correcci√≥n de las excepciones de captura. <br><br>  Leer m√°s: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">una vez (ruso)</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">dos (ingl√©s)</a> <br><br><h3>  STL <a name="STL"></a></h3><br>  <i>Biblioteca de plantillas est√°ndar.</i>  <i>Biblioteca de plantillas est√°ndar.</i>  Parte de la biblioteca est√°ndar de C ++ que proporciona contenedores gen√©ricos, iteradores, algoritmos y funciones auxiliares. <br><br>  A pesar de su nombre conocido, <i>STL</i> nunca se ha llamado as√≠ en el Est√°ndar.  De las secciones de la Norma, el <i>STL</i> se puede atribuir claramente a la biblioteca de Contenedores, la biblioteca de Iteradores, la biblioteca de Algoritmo, y parcialmente a la biblioteca de Servicios generales. <br><br>  En las descripciones de trabajo, a menudo puede encontrar 2 requisitos separados: conocimiento de C ++ y familiaridad con <i>STL</i> .  Nunca entend√≠ esto, porque <i>STL</i> es una parte integral del lenguaje desde el primer Est√°ndar de 1998. <br><br>  Leer m√°s: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">una vez (ruso)</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">dos (ingl√©s)</a> <br><br><h3>  UB <a name="UB"></a></h3><br>  <i>Comportamiento indefinido.</i>  <i>Comportamiento indefinido.</i>  Este comportamiento es en aquellos casos de error para los cuales el Est√°ndar no tiene requisitos.  Muchos de estos se enumeran expl√≠citamente en el Est√°ndar como conducentes a <i>UB</i> .  Estos incluyen, por ejemplo: <br><br><ul><li>  violaci√≥n de los l√≠mites de una matriz o contenedor <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">STL</a> </li><li>  uso de variable no inicializada </li><li>  desreferenciar un puntero nulo </li><li>  desbordamiento de entero firmado </li></ul><br>  El resultado de <i>UB</i> depende de todo en una fila, tanto en la versi√≥n del compilador como en el clima en Marte.  Adem√°s, este resultado puede ser cualquier cosa: un error de compilaci√≥n, una ejecuci√≥n correcta y un bloqueo.  El comportamiento indefinido es malo, es necesario deshacerse de √©l. <br><br>  El comportamiento indefinido, por otro lado, no debe confundirse con el <i>comportamiento no especificado</i> .  El comportamiento no especificado es el comportamiento correcto del programa correcto, pero que, con el permiso del Est√°ndar, depende del compilador.  Y el compilador no est√° obligado a documentarlo.  Por ejemplo, este es el orden en que se eval√∫an los argumentos de una funci√≥n o los detalles de implementaci√≥n de <code>std::map</code> . <br><br>  Bueno, aqu√≠ puede recordar el comportamiento definido por la implementaci√≥n.  De no especificado difiere en la disponibilidad de documentaci√≥n.  Ejemplo: el compilador es libre de hacer que el tipo <code>std::size_t</code> cualquier tama√±o, pero debe indicar cu√°l. <br><br>  Leer m√°s: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">uno (ruso)</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">dos (ruso)</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tres (ingl√©s)</a> <br><br><h2>  Las sutilezas de la lengua <a name="Cobwebs"></a></h2><br><h3>  ADL <a name="ADL"></a></h3><br>  <i>B√∫squeda dependiente de argumentos.</i>  <i>B√∫squeda dependiente de argumentos.</i>  √âl es la b√∫squeda de Koenig, en honor de Andrew Koenig.  Este es un conjunto de reglas para resolver nombres de funciones no calificadas (es decir, nombres sin el operador <code>::</code> :), adem√°s de la resoluci√≥n de nombres habitual.  En pocas palabras: el nombre de una funci√≥n se busca en espacios de nombres relacionados con sus argumentos (este es el espacio que contiene el tipo del argumento, el tipo en s√≠ mismo, si es una clase, todos sus antepasados, etc.). <br><br><div class="spoiler">  <b class="spoiler_title">Ejemplo m√°s simple</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; namespace N { struct S {}; void f(S) { std::cout &lt;&lt; "f(S)" &lt;&lt; std::endl; }; } int main() { N::S s; f(s); }</span></span></span></span></code> </pre> <br>  La funci√≥n <code>f</code> encuentra en el espacio de nombres <code>N</code> solo porque su argumento pertenece a este espacio. <br></div></div><br>  Incluso el trivial <code>std::cout &lt;&lt; "Hello World!\n"</code> usa <i>ADL</i> , <code>std::basic_stream::operator&lt;&lt;</code> no <code>std::basic_stream::operator&lt;&lt;</code> sobrecargado para <code>const char*</code> .  Pero el primer argumento de esta declaraci√≥n es <code>std::basic_stream</code> , y el compilador busca y encuentra una sobrecarga adecuada en el <code>std</code> . <br><br>  Algunos detalles: <i>ADL</i> no <i>es</i> aplicable si una b√∫squeda regular encontr√≥ una declaraci√≥n de un miembro de la clase, o una declaraci√≥n de funci√≥n en el bloque actual sin usar el <code>using</code> , o una declaraci√≥n de una funci√≥n ni una plantilla de funci√≥n.  O si el nombre de la funci√≥n se indica entre par√©ntesis (el ejemplo anterior no se compila con <code>(f)(s)</code> ; tendr√° que escribir <code>(N::f)(s);</code> ). <br><br>  A veces, <i>ADL lo</i> obliga a usar nombres de funciones totalmente calificados donde parecer√≠a innecesario. <br><br><div class="spoiler">  <b class="spoiler_title">Por ejemplo, este c√≥digo no compila</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> N1 { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">S</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(S)</span></span></span><span class="hljs-function"> </span></span>{}; } <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> N2 { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(N1::S)</span></span></span><span class="hljs-function"> </span></span>{}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(N1::S s)</span></span></span><span class="hljs-function"> </span></span>{ foo(s); } }</code> </pre> <br></div></div><br>  Leer m√°s: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">uno (ingl√©s)</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">dos (ingl√©s)</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tres (ingl√©s)</a> <br><br><h3>  CRTP <a name="CRTP"></a></h3><br>  <i>Patr√≥n de plantilla curiosamente recurrente.</i>  <i>Extra√±o patr√≥n recursivo.</i>  La esencia de la plantilla es la siguiente: <br><br><ul><li>  alguna clase hereda de la clase de plantilla </li><li>  la clase descendiente se usa como par√°metro de plantilla de su clase base </li></ul><br>  Es m√°s f√°cil dar un ejemplo: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Derived</span></span></span><span class="hljs-class"> :</span></span> Base&lt;Derived&gt; {};</code> </pre> <br>  <i>CRTP</i> es un excelente ejemplo de polimorfismo est√°tico.  La clase base proporciona una interfaz; las clases derivadas proporcionan una implementaci√≥n.  Pero a diferencia del polimorfismo ordinario, no hay gastos generales para crear y usar una tabla de funciones virtuales. <br><br><div class="spoiler">  <b class="spoiler_title">Ejemplo</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">action</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;T*&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)-&gt;actionImpl(); } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Derived</span></span></span><span class="hljs-class"> :</span></span> Base&lt;Derived&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">actionImpl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ ... } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Arg</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">staticPolymorphicHandler</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Arg</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">arg</span></span></span><span class="hljs-class">) {</span></span> arg.action(); }</code> </pre> <br>  Cuando se usa correctamente, <code>T</code> siempre <code>T</code> un descendiente de <code>Base</code> , por lo que <code>static_cast</code> es suficiente para <code>static_cast</code> .  S√≠, en este caso, la clase base conoce la interfaz descendiente. <br></div></div><br>  Otra √°rea com√∫n de uso para <i>CRTP</i> es la extensi√≥n (o estrechamiento) de la funcionalidad de las clases heredadas (algo llamado mixin en algunos idiomas).  Quiz√°s los ejemplos m√°s famosos: <br><br><ul><li> <code>struct Derived : singleton&lt;Derived&gt; { ‚Ä¶ }</code> </li> <li> <code>struct Derived : private boost::noncopyable&lt;Derived&gt; { ‚Ä¶ }</code> </li> <li> <code>struct Derived : std::enable_shared_from_this&lt;Derived&gt; { ‚Ä¶ }</code> </li> <li>  <code>struct Derived : counter&lt;Derived&gt; { ‚Ä¶ }</code> - cuenta el n√∫mero de objetos creados y / o existentes </li></ul><br>  Desventajas, o m√°s bien, momentos que requieren atenci√≥n: <br><br><ul><li>  No existe una clase base com√∫n, no puede crear una colecci√≥n de descendientes diferentes y acceder a ellos mediante un puntero al tipo base.  Pero si lo desea, puede heredar Base del tipo polim√≥rfico habitual. </li><li>  Hay una oportunidad adicional para tirar el pie por descuido: <br><br><div class="spoiler">  <b class="spoiler_title">Ejemplo</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Derived1</span></span></span><span class="hljs-class"> :</span></span> Base&lt;Derived1&gt; {}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Derived2</span></span></span><span class="hljs-class"> :</span></span> Base&lt;Derived1&gt; {};</code> </pre> <br>  Pero puedes agregar protecci√≥n: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: Base() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> T;</code> </pre> </div></div></li><li>  Porque  Como todos los m√©todos no son virtuales, los m√©todos del descendiente ocultan los m√©todos de la clase base con los mismos nombres.  Por lo tanto, es mejor llamarlos de manera diferente. </li><li>  En general, los descendientes tienen m√©todos p√∫blicos que no deben usarse en ning√∫n otro lugar, excepto en la clase base.  Esto no es bueno, pero se corrige mediante un nivel adicional de abstracci√≥n (ver <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">FTSE</a> ). </li></ul><br><br>  Leer m√°s: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">una vez (ruso)</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">dos (ingl√©s)</a> <br><br><h3>  CTAD <a name="CTAD"></a></h3><br>  <i>Deducci√≥n de argumento de plantilla de clase.</i>  <i>Inferir autom√°ticamente el tipo del par√°metro de plantilla de clase.</i>  Esta es una nueva caracter√≠stica de C ++ 17.  Anteriormente, solo se mostraban autom√°ticamente los tipos de variables ( <code>auto</code> ) y los par√°metros de la plantilla de funci√≥n, por lo que <code>std::make_tuple</code> funciones auxiliares como <code>std::make_pair</code> , <code>std::make_tuple</code> , etc. Ahora, en su mayor parte, no son necesarios, porque el compilador capaz de mostrar autom√°ticamente los par√°metros de las plantillas de clase: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair p{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2.0</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// -&gt; std::pair&lt;int, double&gt; auto lck = std::lock_guard{mtx}; // -&gt; std::lock_guard&lt;std::mutex&gt;</span></span></code> </pre> <br>  <i>CTAD</i> es una nueva oportunidad, a√∫n <i>necesita</i> evolucionar y evolucionar (C ++ 20 ya promete mejoras).  Mientras tanto, las restricciones son las siguientes: <br><br><ul><li><div class="spoiler">  <b class="spoiler_title">La inferencia parcial de los tipos de par√°metros no es compatible.</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt; p{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>}; <span class="hljs-comment"><span class="hljs-comment">//  std::tuple&lt;&gt; t{1, 2, 3}; // </span></span></code> </pre></div></div></li><li><div class="spoiler">  <b class="spoiler_title">Alias ‚Äã‚Äãde plantilla no admitidos</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">U</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">using</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyPair</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:pair&lt;T, U&gt;; MyPair p{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// </span></span></code> </pre> </div></div></li><li><div class="spoiler">  <b class="spoiler_title">Los constructores disponibles solo en especializaciones de plantillas no son compatibles.</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Wrapper</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Wrapper</span></span></span><span class="hljs-class">&lt;int&gt; {</span></span> Wrapper(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) {}; }; Wrapper w{<span class="hljs-number"><span class="hljs-number">5</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// </span></span></code> </pre> </div></div></li><li><div class="spoiler">  <b class="spoiler_title">Las plantillas anidadas no son compatibles</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">U</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class"> {</span></span> Bar(T, U) {}; }; }; Foo::Bar x{ <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2.0</span></span> }; <span class="hljs-comment"><span class="hljs-comment">//  Foo&lt;int&gt;::Bar x{1, 2.0}; // OK</span></span></code> </pre> </div></div></li><li><div class="spoiler">  <b class="spoiler_title">Obviamente, CTAD no funcionar√° si el tipo del par√°metro de plantilla no est√° relacionado con los argumentos del constructor.</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Collection</span></span></span><span class="hljs-class"> {</span></span> Collection(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> size) {}; }; Collection c{<span class="hljs-number"><span class="hljs-number">5</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// </span></span></code> </pre> </div></div></li></ul><br>  En algunos casos, ayudar√°n las reglas de inferencia expl√≠citas que deben declararse en el mismo bloque que la plantilla de clase. <br><br><div class="spoiler">  <b class="spoiler_title">Ejemplo</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Collection</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">It</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Collection</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">It</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">from</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">It</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">to</span></span></span><span class="hljs-class">) {</span></span>}; }; Collection c{v.begin(), v.end()}; <span class="hljs-comment"><span class="hljs-comment">//  template &lt;class It&gt; Collection(It, It)-&gt;Collection&lt;typename std::iterator_traits&lt;It&gt;::value_type&gt;; Collection c{v.begin(), v.end()}; //  OK</span></span></code> </pre> </div></div><br><br>  Leer m√°s: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">una vez (ruso)</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">dos (ingl√©s)</a> <br><br><h3>  EBO <a name="EBO"></a></h3><br>  <i>Optimizaci√≥n de base vac√≠a.</i>  <i>Optimizaci√≥n de una clase base vac√≠a.</i>  Tambi√©n se llama Optimizaci√≥n de clase base vac√≠a (EBCO). <br><br>  Como sabes, en C ++, el tama√±o de un objeto de cualquier clase no puede ser cero.  De lo contrario, toda la aritm√©tica de los punteros se romper√°, porque en una direcci√≥n ser√° posible marcar tantos objetos diferentes como desee.  Por lo tanto, incluso los objetos de clases vac√≠as (es decir, clases sin un solo campo no est√°tico) tienen un tama√±o distinto de cero, que depende del compilador y el sistema operativo y, por lo general, es igual a 1. <br><br>  Por lo tanto, la memoria se desperdicia en vano en todos los objetos de clases vac√≠as.  Pero no los objetos de sus descendientes, porque en este caso el Est√°ndar hace una excepci√≥n expl√≠citamente.  Se permite al compilador no asignar memoria para una clase base vac√≠a y, por lo tanto, guardar no solo 1 byte de la clase vac√≠a, sino los 4 (dependiendo de la plataforma), ya que tambi√©n hay alineaci√≥n. <br><br><div class="spoiler">  <b class="spoiler_title">Ejemplo</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Empty</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> :</span></span> Empty { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; }; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(Empty) &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-comment"><span class="hljs-comment">// 1 std::cout &lt;&lt; sizeof(Foo) &lt;&lt; std::endl; // 4 std::cout &lt;&lt; sizeof(int) &lt;&lt; std::endl; // 4</span></span></code> </pre> </div></div><br>  Pero <i>como</i> no se pueden colocar diferentes objetos del mismo tipo en la misma direcci√≥n, el <i>EBO</i> no funcionar√° si: <br><br><ul><li><div class="spoiler">  <b class="spoiler_title">Una clase vac√≠a se encuentra dos veces entre los antepasados.</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Empty</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Empty2</span></span></span><span class="hljs-class"> :</span></span> Empty {}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> :</span></span> Empty, Empty2 { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; }; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(Empty) &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-comment"><span class="hljs-comment">// 1 std::cout &lt;&lt; sizeof(Empty2) &lt;&lt; std::endl; // 1 std::cout &lt;&lt; sizeof(Foo) &lt;&lt; std::endl; // 8</span></span></code> </pre> </div></div></li><li><div class="spoiler">  <b class="spoiler_title">El primer campo no est√°tico es un objeto de la misma clase vac√≠a o su descendiente.</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Empty</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> :</span></span> Empty { Empty e; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; }; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(Empty) &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-comment"><span class="hljs-comment">// 1 std::cout &lt;&lt; sizeof(Foo) &lt;&lt; std::endl; // 8</span></span></code> </pre> </div></div></li></ul><br>  En los casos en que los objetos de las clases vac√≠as son campos no est√°ticos, no se proporcionan optimizaciones (por ahora, el atributo <code>[[no_unique_address]]</code> aparecer√° en C ++ 20).  Pero gastar 4 bytes (o cu√°nto necesita el compilador) para cada uno de estos campos es una pena, por lo que puede "colapsar" los objetos de las clases vac√≠as con el primer campo no est√°tico no vac√≠o por su cuenta. <br><br><div class="spoiler">  <b class="spoiler_title">Ejemplo</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Empty1</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Empty2</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Member</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Empty</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EmptyOptimization</span></span></span><span class="hljs-class"> :</span></span> Empty ... { Member member; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> {</span></span> EmptyOptimization&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, Empty1, Empty2&gt; data; };</code> </pre> <br>  Es extra√±o, pero en este caso, el tama√±o de Foo es diferente para diferentes compiladores, para MSVC 2019 es 8, para GCC 8.3.0 es 4. Pero en cualquier caso, aumentar el n√∫mero de clases vac√≠as no afecta el tama√±o de <code>Foo</code> . </div></div><br>  Leer m√°s: una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">vez (ingl√©s)</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">dos (ingl√©s)</a> <br><br><h3>  IIFE <a name="IIFE"></a></h3><br>  <i>Expresi√≥n de funci√≥n invocada inmediatamente.</i>  <i>Expresi√≥n funcional llamada de inmediato.</i>  En general, este es un idioma en JavaScript, de donde Jason Turner lo tom√≥ prestado junto con el nombre.  De hecho, solo est√° creando e inmediatamente llamando a una lambda: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> myVar = [&amp;] { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (condition1()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> computeSomeComplexStuff(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> condition2() ? computeSonethingElse() : DEFAULT_VALUE; } ();</code> </pre> <br>  ¬øPor qu√© es esto necesario?  Bueno, por ejemplo, como en el c√≥digo anterior para inicializar una constante por el resultado de un c√°lculo no trivial y no obstruir el alcance con variables y funciones innecesarias. <br><br>  Leer m√°s: una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">vez (ingl√©s)</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">dos (ingl√©s)</a> <br><br><h3>  NVI <a name="NVI"></a></h3><br>  <i>Interfaz no virtual.</i>  <i>Interfaz no virtual.</i>  Seg√∫n este modismo, una interfaz de clase abierta no debe contener funciones virtuales.  Todas las funciones virtuales se hacen privadas (m√°xima protecci√≥n) y se llaman dentro de abierto no virtual. <br><br><div class="spoiler">  <b class="spoiler_title">Ejemplo</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~Base() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// check precondition fooImpl(); // check postconditions } private: virtual void fooImpl() = 0; }; class Derived : public Base { private: void fooImpl() override { } };</span></span></code> </pre> </div></div><br>  ¬øPor qu√© es esto necesario? <br><br><ul><li>  Cada funci√≥n virtual abierta hace 2 cosas: define la interfaz p√∫blica de la clase y participa en la anulaci√≥n del comportamiento en las clases descendientes.  El uso de <i>NVI</i> elimina tales funciones con una doble carga: la interfaz est√° definida por algunas funciones, el cambio de comportamiento por otras.  Puede cambiar ambos independientemente uno del otro. </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si hay algunos requisitos generales para todas las opciones para implementar una funci√≥n virtual (comprobaciones previas y posteriores, captura de mutex, etc.), entonces es muy conveniente recopilarlas en un solo lugar (ver </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SECO</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), en la clase base, y evitar que los herederos se anulen. Este comportamiento.</font></font> Es decir<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Resulta un caso especial del m√©todo de plantilla de patr√≥n. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La tarifa por usar </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NVI</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es una cierta expansi√≥n del c√≥digo, una posible disminuci√≥n en el rendimiento (debido a una llamada de m√©todo adicional) y una mayor susceptibilidad al problema de una clase base fr√°gil (ver </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FBC</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Leer m√°s: una </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vez (ingl√©s)</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dos (ingl√©s)</font></font></a> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> RVO y NRVO </font></font><a name="RVO"></a></h3><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Nombre) Optimizaci√≥n del valor de retorno. </font><font style="vertical-align: inherit;">Optimizando el valor de retorno (nombrado). </font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este es un caso especial de elisi√≥n de copia permitida por el Est√°ndar: el compilador puede omitir copias innecesarias de objetos temporales, incluso si sus constructores y destructores tienen efectos secundarios obvios. </font><font style="vertical-align: inherit;">Dicha optimizaci√≥n es permisible cuando la funci√≥n devuelve un objeto por valor (los otros dos casos permitidos de copia de elisi√≥n son el lanzamiento y la captura de excepciones).</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ejemplo</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Foo </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Foo(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> f = bar(); }</code> </pre> </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sin </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RVO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , aqu√≠ se crear√≠a un objeto temporal </font></font><code>Foo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en la funci√≥n </font></font><code>bar</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, luego a trav√©s del constructor de copias </font><font style="vertical-align: inherit;">se crear√≠a </font><font style="vertical-align: inherit;">otro objeto temporal en la funci√≥n </font></font><code>main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(para obtener el resultado </font></font><code>bar</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), y solo entonces se crear√≠a el objeto </font></font><code>f</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y se le asignar√≠a el valor del segundo objeto temporal. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RVO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> se deshace de todas estas copias y asignaciones, y la funci√≥n </font></font><code>bar</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">crea directamente </font></font><code>f</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sucede as√≠: una funci√≥n </font></font><code>main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">asigna un espacio para un objeto en su marco de pila </font></font><code>f</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Una funci√≥n </font></font><code>bar</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(que ya funciona en su marco) obtiene acceso a esta memoria asignada en el marco anterior y crea all√≠ el objeto deseado. </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NRVO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es diferente de</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RVO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> realiza la misma optimizaci√≥n, pero no cuando se crea el objeto en la expresi√≥n </font></font><code>return</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, sino cuando se devuelve el objeto creado previamente en la funci√≥n.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ejemplo</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Foo </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Foo result; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A pesar de la diferencia aparentemente peque√±a, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NRVO es</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mucho m√°s dif√≠cil de implementar y, por lo tanto, no funciona en muchos casos. </font><font style="vertical-align: inherit;">Por ejemplo, si una funci√≥n devuelve un objeto global o uno de sus argumentos, o si una funci√≥n tiene varios puntos de salida y se devuelven diferentes objetos a trav√©s de ellos, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NRVO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> no se aplicar√°.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NRVO no funciona aqu√≠</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Foo </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> condition)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (condition) { Foo f1; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f1; } Foo f2; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f2; }</code> </pre> </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Casi todos los compiladores han apoyado durante mucho tiempo a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RVO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . El grado de soporte para </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NRVO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> puede variar de un compilador a otro y de una versi√≥n a otra. </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RVO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NRVO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> son solo optimizaciones. Y aunque no se llama la copia del constructor y el operador de asignaci√≥n, deber√≠an estar en la clase del objeto. Las reglas han cambiado un poco en C ++ 17: ahora </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RVO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> no se considera copia de elisi√≥n, se ha convertido en obligatorio, y el constructor correspondiente y el operador de asignaci√≥n no son necesarios. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nota: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(N) RVO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en t√©rminos constantes es un tema resbaladizo. Hasta C ++ 14 inclusive, no se dijo nada al respecto, C ++ 17 requiere </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RVO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en tales expresiones, y el pr√≥ximo C ++ 20 - proh√≠be.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Algunas palabras sobre la conexi√≥n con la sem√°ntica del desplazamiento. </font><font style="vertical-align: inherit;">En primer lugar, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(N) RVO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es a√∫n m√°s efectivo, porque </font><font style="vertical-align: inherit;">no es necesario llamar al constructor y destructor de movimientos. </font><font style="vertical-align: inherit;">En segundo lugar, si en lugar </font></font><code>result</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de regresar de la misma funci√≥n </font></font><code>std::move(result)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> garantiza que </font><i><font style="vertical-align: inherit;">NRVO</font></i><font style="vertical-align: inherit;"> no funcionar√°. </font><font style="vertical-align: inherit;">Parafraseando Est√°ndar: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RVO se</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> aplica a prvalue, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NRVO se aplica</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> a lvalue, a </font></font><code>std::move(result)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es xvalue. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Leer m√°s: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uno (ingl√©s)</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dos (ingl√©s)</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tres (ingl√©s)</font></font></a> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> SFINAE </font></font><a name="SFINAE"></a></h3><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La falla de sustituci√≥n no es un error. </font><font style="vertical-align: inherit;">La sustituci√≥n fallida no es un error. </font></font></i> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SFINAE</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es una caracter√≠stica del proceso de </font><i><font style="vertical-align: inherit;">creaci√≥n</font></i><font style="vertical-align: inherit;"> de instancias de plantillas (funciones y clases) en C ++. </font><font style="vertical-align: inherit;">La conclusi√≥n es que si una determinada plantilla no puede ser instanciada, esto no se considera un error si hay otras opciones. </font><font style="vertical-align: inherit;">Por ejemplo, un algoritmo simplificado para elegir la sobrecarga de funciones m√°s adecuada funciona as√≠:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se resuelve el nombre de la funci√≥n: el compilador busca todas las funciones con el nombre dado en todos los espacios de nombres considerados (ver </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ADL</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ).</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Se descartan las funciones inapropiadas: no se trata del n√∫mero de argumentos, no es necesaria la conversi√≥n de los tipos de argumentos, no fue posible derivar tipos para la plantilla de funciones, etc. </font></font></li><li>          (viable functions),          .           ‚Äî     . </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entonces </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SFINAE</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ocurre en el segundo paso: si la sobrecarga se obtiene al crear una instancia de la plantilla de funci√≥n, pero el compilador no pudo inferir los tipos de firma de la funci√≥n, entonces esta sobrecarga no se considera un error, sino que se descarta silenciosamente (incluso sin advertencia). </font><font style="vertical-align: inherit;">Y de manera similar para las clases. </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SFINAE</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> puede usarse para muchas cosas, por ejemplo, para contar la longitud de una lista de inicializaci√≥n o para contar bits en un n√∫mero. </font><font style="vertical-align: inherit;">Pero la mayor√≠a de las veces, con su ayuda, la reflexi√≥n se emula como m√≠nimo, es decir, se determina si la clase tiene un m√©todo con una firma determinada.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ejemplo</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;type_traits&gt; #include &lt;utility&gt; template &lt;class, class = void&gt; struct HasToString : std::false_type {}; //    ,      //   -    ,  //     ‚Äî  ,    ,   template &lt;class T&gt; struct HasToString&lt;T, std::void_t&lt;decltype(&amp;T::toString)&gt;&gt; : std::is_same&lt;std::string, decltype(std::declval&lt;T&gt;().toString())&gt; {}; struct Foo { std::string toString() { return {}; } }; int main() { std::cout &lt;&lt; HasToString&lt;Foo&gt;::value &lt;&lt; std::endl; // 1 std::cout &lt;&lt; HasToString&lt;int&gt;::value &lt;&lt; std::endl; // 0 }</span></span></span></span></code> </pre> </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lo que apareci√≥ en C ++ 17 </font></font><code>static if</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">puede en algunos casos reemplazar a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SFINAE</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , y los conceptos esperados en C ++ 20 casi lo har√°n innecesario. </font><font style="vertical-align: inherit;">A ver </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Leer m√°s: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uno (ruso)</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dos (ingl√©s)</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tres (ingl√©s)</font></font></a> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> SBO, SOO, SSO </font></font><a name="SBO"></a></h3><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B√∫fer peque√±o / Objeto / Optimizaci√≥n de cadena. </font><font style="vertical-align: inherit;">Optimizaci√≥n de peque√±os buffers / objetos / l√≠neas. </font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A veces, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SSO se usa</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en el sentido de la optimizaci√≥n de tama√±o peque√±o, pero muy raramente, por lo que suponemos que </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SSO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> se trata de cadenas. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SBO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SOO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> son simplemente sin√≥nimos, y </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SSO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es el caso especial m√°s famoso. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Todas las estructuras de datos que usan memoria din√°mica ciertamente tambi√©n ocupan un lugar en la pila. </font><font style="vertical-align: inherit;">Al menos para almacenar un puntero a un grupo. </font><font style="vertical-align: inherit;">Y la esencia de estas optimizaciones no es solicitar memoria del mont√≥n para objetos relativamente peque√±os (lo cual es relativamente costoso), sino colocarlos en el espacio de pila ya asignado. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por ejemplo, std :: string podr√≠a implementarse as√≠:</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ejemplo</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* begin_; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> size_; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> capacity_; };</code> </pre> </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> El tama√±o de esta clase, obtengo 24 bytes (depende del compilador y la plataforma). </font></font> Es decir<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No se pueden colocar cadenas de m√°s de 24 caracteres en la pila. </font><font style="vertical-align: inherit;">En realidad, no hasta las 24, por supuesto, ya que es necesario distinguir de alguna manera entre la colocaci√≥n en la pila y en el mont√≥n. </font><font style="vertical-align: inherit;">Pero aqu√≠ est√° la forma m√°s simple para l√≠neas cortas de hasta 8 caracteres (el mismo tama√±o - 24 bytes):</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ejemplo</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> Buffer { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* begin_; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> local_[<span class="hljs-number"><span class="hljs-number">8</span></span>]; }; Buffer buffer_; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> _size; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> _capacity; };</code> </pre> </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adem√°s de la falta de asignaciones en el mont√≥n, existe otra ventaja: un alto grado de localidad de datos. </font><font style="vertical-align: inherit;">Una matriz o vector de tales objetos optimizados realmente ocupar√° solo una pieza continua de memoria. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Casi todas las implementaciones </font></font><code>std::string</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">usan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SSO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y al menos algunas implementaciones </font></font><code>std::function</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Pero </font></font><code>std::vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nunca se optimiza de esta manera, ya que el est√°ndar requiere que </font></font><code>std::swap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para dos vectores no cause copia o asignaci√≥n de sus elementos, y que todos los iteradores v√°lidos sigan siendo v√°lidos. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SBO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> no permitir√° cumplir estos requisitos (porque </font></font><code>std::string</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no lo son). </font><font style="vertical-align: inherit;">Pero </font></font><code>boost::container::small_vector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, como puede suponer, usa </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SBO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Leer m√°s: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tiempo (ingl√©s)</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ,</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dos</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> UDPATE </font></font><a name="Update"></a></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gracias a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PyerK</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> por esta lista adicional de abreviaturas.</font></font><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CV </font></font><a name="CV"></a></h3><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Calificadores como const y vol√°tiles. </font></font></i> <code>const</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">significa que el objeto / variable no se puede modificar, un intento de hacerlo resultar√° en un error en el momento de la compilaci√≥n o en </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UB</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en el tiempo de ejecuci√≥n. </font></font><code>volatile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">significa que el objeto / variable puede cambiar independientemente de las acciones del programa (por ejemplo, algunos rellenos de microcontroladores escriben algo en la memoria) y el compilador no debe optimizar el acceso al mismo. </font><font style="vertical-align: inherit;">El acceso a un </font></font><code>volatile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">objeto no a trav√©s de un </font></font><code>volatile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enlace o puntero tambi√©n da como resultado </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UB</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Leer m√°s: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uno (ruso)</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dos (ingl√©s)</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tres (ruso)</font></font></a> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> LTO </font></font><a name="LTO"></a></h3><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Optimizaci√≥n del tiempo de enlace. </font><font style="vertical-align: inherit;">Optimizaci√≥n de enlaces. </font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como su nombre lo indica, esta optimizaci√≥n ocurre durante el enlace, es decir, despu√©s de la compilaci√≥n. </font><font style="vertical-align: inherit;">El enlazador puede hacer algo que el compilador no se atrevi√≥ a hacer: hacer que algunas funciones est√©n en l√≠nea, desechar el c√≥digo y los datos no utilizados. </font><font style="vertical-align: inherit;">Aumenta el tiempo de enlace, por supuesto. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Leer m√°s: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tiempo (ingl√©s)</font></font></a> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PCH </font></font><a name="PCH"></a></h3><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Encabezados precompilados. </font><font style="vertical-align: inherit;">Encabezados precompilados. </font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A menudo se usan, pero rara vez los archivos de encabezado modificados se compilan una vez y se guardan en el formato interno del compilador. </font><font style="vertical-align: inherit;">Por lo tanto, volver a armar el proyecto llevar√° menos tiempo, a veces mucho menos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Leer m√°s: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tiempo (rus.)</font></font></a> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pgo </font></font><a name="PGO"></a></h3><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Optimizaci√≥n guiada por perfil. </font><font style="vertical-align: inherit;">Optimizaci√≥n basada en resultados de perfiles. </font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este es un m√©todo de optimizaci√≥n del programa, pero no a trav√©s del an√°lisis de c√≥digo est√°tico, sino a trav√©s del lanzamiento de programas de prueba y la recopilaci√≥n de estad√≠sticas reales. </font><font style="vertical-align: inherit;">Por ejemplo, la ramificaci√≥n y la llamada a funciones virtuales de esta manera se pueden optimizar. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Leer m√°s: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tiempo (rus.)</font></font></a> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Seh / veh </font></font><a name="SEH"></a></h3><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Manejo de excepciones estructuradas / vectorizadas. </font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esta es una extensi√≥n MSVC para manejo de excepciones y errores. </font><font style="vertical-align: inherit;">A diferencia norma </font></font><code>try-catch</code> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SEH</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> utiliza sus propias palabras clave: </font></font><code>__try</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>__except</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>__finally</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, las capturas y los mangos no se lanzan excepciones expl√≠citamente, y tales cosas como el acceso a un desbordamiento de pila de memoria no v√°lida debido a la recursividad infinita, llamar a una funci√≥n virtual pura, etc ... </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VEH</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> No detecta todos los errores expl√≠citamente, pero crea una cadena global de controladores de errores. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Leer m√°s: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tiempo (ingl√©s)</font></font></a> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tmp </font></font><a name="TMP"></a></h3><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Metaprogramaci√≥n de plantillas. </font><font style="vertical-align: inherit;">Metaprogramaci√≥n de plantilla. </font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La metaprogramaci√≥n es cuando un programa crea otro como resultado de su trabajo. </font><font style="vertical-align: inherit;">Las plantillas en C ++ implementan dicha metaprogramaci√≥n. </font><font style="vertical-align: inherit;">El compilador de plantillas genera el n√∫mero requerido de clases o funciones. </font><font style="vertical-align: inherit;">Se sabe que </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TMP</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en C ++ es Turing completo, es decir, cualquier funci√≥n se puede implementar en √©l. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Leer m√°s: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tiempo (rus.)</font></font></a> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vla </font></font><a name="VLA"></a></h3><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Matrices de longitud variable. </font><font style="vertical-align: inherit;">Matrices de longitud variable.</font></font></i>  Es decir<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> matrices cuya longitud es desconocida en el momento de la compilaci√≥n: </font></font><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>[n]; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El est√°ndar C ++ no permite esto. </font><font style="vertical-align: inherit;">Lo cual es algo extra√±o, ya que existen en C puro desde el est√°ndar C99. </font><font style="vertical-align: inherit;">Y son compatibles con algunos compiladores de C ++ como una extensi√≥n. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Leer m√°s: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tiempo (rus.)</font></font></a> <br><br><h2>  PS </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si me perd√≠ algo o me equivoqu√© en alguna parte, escriba los comentarios. </font><font style="vertical-align: inherit;">Solo recuerde, por favor, que aqu√≠ solo se enumeran las abreviaturas directamente relacionadas con C ++. </font><font style="vertical-align: inherit;">Para otros, pero no menos √∫til, habr√° una publicaci√≥n separada. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Segunda parte</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/470265/">https://habr.com/ru/post/470265/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../470241/index.html">Historial de inicio: c√≥mo desarrollar una idea paso a paso, ingresar a un mercado inexistente y alcanzar la expansi√≥n internacional</a></li>
<li><a href="../470247/index.html">RESHI.RU: un robot resuelve y explica problemas de texto escolar en matem√°ticas</a></li>
<li><a href="../470251/index.html">C√≥mo hice una aplicaci√≥n de escritorio en Flutter (+ bonus)</a></li>
<li><a href="../470255/index.html">Optimizaci√≥n de la cartera de bonos con ALGLIB</a></li>
<li><a href="../470257/index.html">Capa alrededor de ImmutableList en Java</a></li>
<li><a href="../470267/index.html">Monitoreo de temperatura certificado</a></li>
<li><a href="../470269/index.html">ReactOS 0.4.12: Âçé‰∏∫ Ôºå ‰Ω† ËÆ§‰∏∫ Ëøô‰∏™ ÊÄé‰πà Ê†∑Ôºü</a></li>
<li><a href="../470271/index.html">F # 6: Tuplas</a></li>
<li><a href="../470273/index.html">F # 7: Registros</a></li>
<li><a href="../470275/index.html">F # 8: Uniones discriminadas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>