<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏼‍🌾 🧠 🖖 Mit Webpack das Traumbündel sammeln 👎🏽 🧑🏽‍🤝‍🧑🏻 👉</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="JS-Anwendungen, Websites und andere Ressourcen werden immer komplexer und Build-Tools sind die Realität der Webentwicklung. Bundler helfen beim Packen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mit Webpack das Traumbündel sammeln</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/433324/">  JS-Anwendungen, Websites und andere Ressourcen werden immer komplexer und Build-Tools sind die Realität der Webentwicklung.  Bundler helfen beim Packen, Kompilieren und Organisieren von Bibliotheken.  Eines der leistungsstarken und flexiblen Open Source-Tools, das perfekt zum Erstellen der Clientanwendung angepasst werden kann, ist Webpack. <br><br>  Maxim Sosnov ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">crazymax11</a> ) - Frontend Lead in N1.RU führte Webpack in mehrere große Projekte ein, die zuvor einen eigenen Build hatten, und trug mehrere Projekte dazu bei.  Maxim weiß, wie man mit Webpack ein Traumpaket erstellt, es schnell erledigt und so konfiguriert, dass die Konfiguration sauber, unterstützt und modular bleibt. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/4ClK_0fxsVM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Die Interpretation unterscheidet sich vom Bericht - es handelt sich um eine stark verbesserte Version der Proflinks.  Während des gesamten Transkripts sind Ostereier auf Artikeln, Plugins, Minifiers, Optionen, Transpilern und Beweisen der Wörter des Sprechers verteilt, auf die Links einfach nicht in eine Rede gesetzt werden können.  Wenn du alles sammelst, öffnet sich das Bonuslevel in Webpack :-) <br><a name="habracut"></a><br><h2>  Webpack-Integration in ein typisches Projekt </h2><br>  Normalerweise ist die Implementierungsprozedur wie folgt: Der Entwickler liest irgendwo einen Artikel über Webpack, beschließt, eine Verbindung herzustellen, beginnt mit dem Erstellen, funktioniert irgendwie, alles beginnt und für einige Zeit funktioniert die Webpack-Konfiguration - für sechs Monate, ein Jahr, zwei.  Vor Ort ist alles in Ordnung - Sonne, Regenbogen und Schmetterlinge.  Und dann kommen echte Benutzer: <br><br>  <em>- Von Mobilgeräten wird Ihre Site nicht geladen.</em> <em><br></em>  <em>- Bei uns funktioniert alles.</em>  <em>Vor Ort ist alles in Ordnung!</em> <br><br>  Für den Fall, dass der Entwickler alles profiliert und feststellt, dass das <strong>Bundle</strong> für mobile Geräte <strong>7 MB wiegt und das Laden 30 Sekunden dauert</strong> .  Dies passt zu niemandem und der Entwickler beginnt zu suchen, wie das Problem gelöst werden kann - er kann einen Loader anschließen oder ein magisches Plug-In finden, das alle Probleme löst.  Wie durch ein Wunder befindet sich ein solches Plugin.  Unser Entwickler geht zur Webpack-Konfiguration und versucht zu installieren, aber die Codezeile stört: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (process.env.NODE_ENV === <span class="hljs-string"><span class="hljs-string">'production'</span></span>) { config.module.rules[<span class="hljs-number"><span class="hljs-number">7</span></span>].options.magic = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  Die Zeile wird wie folgt übersetzt: "Wenn die Konfiguration für die Produktion zusammengestellt wird, nehmen Sie die siebte Regel und setzen Sie dort die Option <code>magic = true</code> ."  Der Entwickler weiß nicht, was er damit anfangen soll und wie er es lösen soll.  Dies ist eine Situation, in der Sie ein Bündel Träume brauchen. <br><br><h2>  Wie sammle ich ein Bündel Träume? </h2><br>  Definieren wir zunächst, was es ist.  Erstens hat das Traumbündel zwei Hauptmerkmale: <br><br><ul><li>  <strong>Es wiegt ein wenig</strong> .  Je weniger Gewicht - desto schneller erhält der Benutzer eine funktionierende Anwendung.  Sie möchten nicht, dass Ihre Site 15 Sekunden lang geöffnet wird. </li><li>  Der Benutzer <strong>lädt nur das herunter, was</strong> heruntergeladen werden muss, um die aktuelle Seite der Site anzuzeigen, und kein Byte mehr! </li></ul><br>  Um die Größe des Bundles zu verringern, müssen Sie zunächst dessen Größe bewerten. <br><br><h3>  Bundle-Größe bewerten </h3><br>  Die beliebteste Lösung ist das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">WebpackBundleAnalyzer-</a> Plugin.  Es sammelt Statistiken zur Anwendungserstellung und rendert eine interaktive Seite, auf der Sie die Position und das Gewicht jedes Moduls sehen können. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/27a/803/6b9/27a8036b994a09b7371c567b6df6cd82.png" alt="Bild"><br><br>  Wenn dies nicht ausreicht, können Sie mit einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">anderen Plugin</a> ein <strong>Abhängigkeitsdiagramm</strong> erstellen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7c3/900/24a/7c390024a9d902ca99e3d00c0d8081b3.png" alt="Bild"><br><br>  Oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ein Kreisdiagramm</a> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/350/14a/ec4/35014aec45623d06972bca310b3f8edf.png" alt="Bild"><br><br>  Wenn dies nicht ausreicht und Sie Webpack an Vermarkter verkaufen möchten, können Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ein ganzes Universum aufbauen,</a> in dem jeder Punkt ein Modul ist, wie ein Stern im Universum. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/45b/a6e/2d2/45ba6e2d2daff144c69df2a43e8ef53a.png" alt="Bild"><br><br>  Es gibt viele Tools, die die Größe des Bundles bewerten und überwachen.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">In der Webpack-Konfiguration</a> gibt es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eine Option, die die Assembly zum</a> Absturz <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bringt</a> , wenn das Bundle beispielsweise zu viel wiegt.  Es gibt ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Duplikat-Paket-Prüfer-Webpack-Plugin-Plugin</a> , das Sie daran hindert, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ein</a> Bundle zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erstellen</a> , wenn Sie 2 npm-Pakete verschiedener Versionen haben, z. B. Lodash 4.15 und Lodash 4.14. <br><br><h3>  So reduzieren Sie das Bundle </h3><br><ul><li>  Am naheliegendsten ist es, <strong>UglifyJS</strong> so <strong>anzuschließen</strong> , dass JavaScript minimiert wird. </li><li>  Verwenden Sie <strong>spezielle Loader und Plugins</strong> , die eine bestimmte Ressource komprimieren und optimieren.  Zum Beispiel <strong>css-nano</strong> für css oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SVGO</a> , das SVG optimiert. </li><li>  Komprimieren Sie alle Dateien über <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gzip / brotli-Plugins</a> direkt in Webpack. </li><li>  Andere Werkzeuge. </li></ul><br>  Jetzt werden wir verstehen, wie man überschüssiges Material aus dem Bündel wirft. <br><br><h3>  Wirf den Überschuss weg </h3><br>  Betrachten Sie dies in einem beliebten Beispiel mit <strong>moment.js</strong> : <code>import moment from 'moment'</code> .  Wenn Sie eine leere Anwendung nehmen, moment.js und <strong>ReactDOM</strong> importieren und dann über <strong>WebpackBundleAnalyzer übergeben</strong> , wird das folgende Bild <strong>angezeigt</strong> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/105/e0f/833/105e0f8334a83c529077c693fda3d3de.png" alt="Bild"><br><br>  Es stellt sich heraus, dass Sie, wenn Sie einem Datum einen Tag, eine Stunde zu einem Datum hinzufügen oder einfach den Link "in 15 Minuten" mit moment.js setzen möchten, ganze <strong>230 KB Code verbinden</strong> !  Warum passiert das und wie wird es gelöst? <br><br><h4>  Gebietsschema wird gerade geladen </h4><br>  In moment.js gibt es eine Funktion, die die Gebietsschemas festlegt: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setLocale</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">locale</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> localePath = <span class="hljs-string"><span class="hljs-string">'locale/'</span></span> + locale + <span class="hljs-string"><span class="hljs-string">'.js'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._currentLocale = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(localePath); }</code> </pre><br>  Aus dem Code ist ersichtlich, dass das Gebietsschema entlang des dynamischen Pfads geladen wird, d. H.  in Laufzeit berechnet.  Webpack agiert intelligent und versucht sicherzustellen, dass Ihr Bundle während der Codeausführung nicht abstürzt: Es findet alle möglichen Gebietsschemas im Projekt und bündelt sie.  Daher wiegt die Anwendung so viel. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a03/4cc/b3f/a034ccb3fc36dd03b916b0bc28acb057.png" alt="Bild"><br><br>  Die Lösung ist sehr einfach: Wir nehmen ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Standard-Plugin</a> aus Webpack und sagen dazu: "Wenn Sie sehen, dass jemand viele Gebietsschemas herunterladen möchte, weil er nicht bestimmen kann, welches, nehmen Sie einfach das russische!" <br><br><img src="https://habrastorage.org/getpro/habr/post_images/587/fe6/e38/587fe6e38333e8b482fed615e3c00ee1.png" alt="Bild"><br><br>  Webpack akzeptiert nur Russisch und WebpackBundleAnalyzer zeigt 54 KB an, was bereits 200 KB einfacher ist. <br><br><h3>  Eliminierung des toten Codes </h3><br>  Die nächste Optimierung, die uns interessiert, ist die <strong>Beseitigung von totem Code</strong> .  Betrachten Sie den folgenden Code. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> cond = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cond) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; someFunction(<span class="hljs-number"><span class="hljs-number">42</span></span>);</code> </pre><br>  Die meisten Zeilen aus diesem Code werden im endgültigen Bundle nicht benötigt - der Block mit der Bedingung wird nicht ausgeführt, die Funktion auch nach der Rückgabe.  Alles, was Sie verlassen müssen, ist die <code>return true</code> .  Genau das ist die Beseitigung von totem Code: Das Build-Tool erkennt Code, der nicht ausgeführt werden kann, und schneidet ihn.  Es gibt eine nette Funktion, mit der UglifyJS dies tun kann. <br><br>  Fahren wir nun mit der fortgeschritteneren <strong>Methode zur</strong> Beseitigung von totem Code fort - der <strong>Baumschüttelmethode</strong> . <br><br><h3>  Baum zittern </h3><br>  <strong>Angenommen</strong> , wir haben eine Anwendung, die <strong>Lodash verwendet</strong> .  Ich bezweifle stark, dass jemand das ganze Lodash benutzt.  Höchstwahrscheinlich werden verschiedene Funktionen wie <strong>get</strong> , <strong>IsEmpty</strong> , <strong>unionBy</strong> oder dergleichen <strong>ausgenutzt</strong> . <br><br>  Wenn wir Tree Shaking durchführen, möchten wir, dass Webpack die unnötigen Module „schüttelt“ und wegwirft, und wir haben nur die erforderlichen.  Das ist Baumschütteln. <br><br><h4>  So funktioniert das Baumschütteln in Webpack </h4><br>  Angenommen, Sie haben einen Code wie diesen: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { a } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./a.js'</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(a);</code> </pre><br>  Der Code ist sehr einfach: Importieren Sie aus einem Modul die Variable a und geben Sie sie aus.  In diesem Modul gibt es jedoch zwei Variablen: <strong>a</strong> und <strong>b</strong> .  Wir brauchen die Variable <b>b nicht</b> und wollen sie entfernen. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b = <span class="hljs-number"><span class="hljs-number">4</span></span></code> </pre><br>  Wenn Webpack eintrifft, konvertiert es den Importcode in Folgendes: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> d = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(d[<span class="hljs-string"><span class="hljs-string">"a"</span></span>]);</code> </pre><br>  Unser <code>import</code> wurde <code>require</code> , aber <code>console.log</code> nicht geändert. <br><br>  Die Webpack-Abhängigkeit wird in den folgenden Code konvertiert: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports[<span class="hljs-string"><span class="hljs-string">"a«] = a; /* unused harmony export b */ var b = 4;</span></span></code> </pre><br><br>  Webpack hat den Export der Variablen <b>a verlassen</b> und den Export der Variablen <b>b entfernt</b> , aber die Variable selbst verlassen und sie mit einem speziellen Kommentar markiert.  Im konvertierten Code wird die Variable <b>b</b> nicht verwendet, und UglifyJS kann sie löschen. <br><br><blockquote>  Das Schütteln des Webpack-Baums funktioniert nur, wenn Sie eine Art Code-Minifier wie UglifyJS oder <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">babel-minify haben</a></b> . </blockquote><br>  Betrachten wir interessantere Fälle - wenn das Baumschütteln nicht funktioniert. <br><br><h4>  Wenn Baumschütteln nicht funktioniert </h4><br>  Fall Nr. 1. Sie schreiben den Code: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports.a = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports.b = <span class="hljs-number"><span class="hljs-number">4</span></span>;</code> </pre><br>  Führen Sie den Code über Webpack aus, und er bleibt unverändert.  Dies liegt daran, dass der Bundler das Tree-Shaking nur organisiert, wenn Sie ES6-Module verwenden.  Wenn Sie CommonJS-Module verwenden, funktioniert das Tree-Shaking nicht. <br><br>  Fall Nr. 2. Sie schreiben Code mit ES6-Modulen und benannten Exporte. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b = <span class="hljs-number"><span class="hljs-number">4</span></span></code> </pre><br>  Wenn Ihr Code Babel durchläuft und Sie die Moduloption nicht <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">auf false gesetzt haben</a> , bringt Babel Ihre Module zu CommonJS, und Webpack kann Tree Shaking erneut nicht ausführen, da es nur mit ES6-Modulen funktioniert. <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports.a = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports.b = <span class="hljs-number"><span class="hljs-number">4</span></span>;</code> </pre><br>  Dementsprechend müssen wir sicher sein, dass niemand in unserem Montageplan ES6-Module überträgt. <br><br>  Fall Nr. 3. Angenommen, wir haben eine so nutzlose Klasse, die nichts tut: <code>export class ShakeMe {}</code> .  Außerdem verwenden wir es immer noch nicht.  Wenn Webpack importiert und exportiert wird, verwandelt Babel die Klasse in eine Funktion, und der Bundler stellt fest, dass die Funktion nicht verwendet wird: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/* unused harmony e[port b */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ShakeMe = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShakeMe</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ babelHelpers.classCallCheck(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, ShakeMe); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ShakeMe; }();</code> </pre><br>  Es scheint, dass alles in Ordnung sein sollte, aber wenn wir genauer hinschauen, werden wir sehen, dass es in dieser Funktion eine globale Variable <code>babelHelpers</code> , von der eine Funktion aufgerufen wird.  Dies ist ein <b>Nebeneffekt</b> : UglifyJS sieht, dass eine globale Funktion aufgerufen wird, und schneidet den Code nicht, da befürchtet wird, dass etwas kaputt geht. <br><br>  Wenn Sie Klassen schreiben und sie durch Babel laufen lassen, werden sie nie geschnitten.  Wie ist das behoben?  Es gibt einen standardisierten Hack - fügen Sie vor der Funktion einen Kommentar <code>/*#__PURE__*/</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/* unused harmony export b */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ShakeMe = <span class="hljs-comment"><span class="hljs-comment">/*#__PURE__*/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShakeMe</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ babelHelpers.classCallCheck(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, ShakeMe); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ShakeMe; }();</code> </pre><br>  Dann wird UglifyJS an das Wort glauben, dass die nächste Funktion rein ist.  Glücklicherweise macht <b><a href="">Babel 7</a></b> dies jetzt und in Babel 6 wurde bisher nichts entfernt. <br><br><blockquote>  Regel: Wenn Sie irgendwo eine Nebenwirkung haben, wird UglifyJS nichts tun. </blockquote><br>  Zusammenfassend: <br><br><ul><li>  <b>Das Schütteln von Bäumen funktioniert für die meisten Bibliotheken ab npm nicht</b> , da sie alle von CommonJS stammen und vom alten Babel erstellt wurden. </li><li>  Höchstwahrscheinlich <b>funktioniert das</b> Baumschütteln <b>für diejenigen Bibliotheken, die bereits darauf vorbereitet sind</b> , z. B. Lodash-es, Date-fns und Ihren Code oder Ihre Bibliotheken, angemessen. </li><li>  UglifyJS ist an der Montage beteiligt. </li><li>  Gebrauchte ES6-Module. </li><li>  Keine Nebenwirkungen. </li></ul><br>  Wir haben herausgefunden, wie Sie das Gewicht des Bundles reduzieren können, und jetzt lernen wir, nur die erforderlichen Funktionen zu laden. <br><br><h3>  Wir laden nur die notwendigen Funktionen </h3><br>  Wir teilen diesen Teil in zwei Teile.  Im ersten Teil wird <b>nur der Code geladen, den der Benutzer benötigt</b> : Wenn der Benutzer die Hauptseite Ihrer Website besucht, lädt er die persönlichen Kontoseiten nicht.  Im zweiten <b>Fall führen Änderungen im Code zu einem möglichst geringen Nachladen von Ressourcen</b> . <br><br><h4>  Wir laden nur den notwendigen Code </h4><br>  Betrachten Sie die Struktur einer imaginären Anwendung.  Es hat: <br><br><ul><li>  Einstiegspunkt - APP. </li><li>  Drei Seiten: Home, Suche und Karte. </li></ul><br><img src="https://habrastorage.org/getpro/habr/post_images/872/142/14e/87214214e5fc6514a1a72cb20f6be4b2.png" alt="Bild"><br><br>  Das erste Problem, das wir lösen möchten, ist die <b>Ausgabe eines gemeinsamen Codes</b> .  Bezeichnen wir den roten Code als gemeinsamen Code für alle Seiten, den grünen Kreis für die Hauptseite und die Suchseite.  Die übrigen Zahlen sind nicht besonders wichtig. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/854/ec8/80f/854ec880feff7813d267ca834209db71.png" alt="Bild"><br><br>  Wenn der Benutzer von der Hauptseite zur Suche kommt, lädt er die Box und den Kreis ein zweites Mal neu, obwohl er sie bereits hat.  Im Idealfall möchten wir so etwas sehen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b75/290/36d/b7529036de4cf6923a279666d00ca297.png" alt="Bild"><br><br>  Es ist gut, dass Webpack 4 bereits ein integriertes Plugin hat, das dies für uns <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erledigt</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SplitChunksPlugin</a> .  Das Plugin entfernt den Anwendungscode oder den Knotenmodulcode, der von mehreren Blöcken in einem separaten Block verwendet wird, wobei sichergestellt wird, dass der Block mit dem allgemeinen Code mehr als 30 KB groß ist. Um die Seite zu laden, müssen Sie nicht mehr als 5 Blöcke herunterladen.  Die Strategie ist optimal: Das Laden zu kleiner Chunks ist nicht rentabel, und das Laden zu vieler Chunks ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=http://engineering.khanacademy.org/posts/js-packaging-">lang und nicht so effizient</a> wie das Herunterladen weniger Chunks, selbst auf http2.  Um dieses Verhalten in 2 oder 3 Versionen von Webpack zu wiederholen, musste ich 20 bis 30 Zeilen mit undokumentierten Funktionen schreiben.  Jetzt wird dies in einer Zeile gelöst. <br><br><h4>  CSS zum Mitnehmen </h4><br>  Es wäre großartig, wenn wir das CSS für jeden Block noch in einer separaten Datei herausnehmen würden.  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hierfür</a></b> gibt es eine fertige Lösung - das <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mini-Css-Extract-Plugin</a></b> .  Das Plugin erschien nur in Webpack 4, und davor gab es keine adäquaten Lösungen für eine solche Aufgabe - nur Hacks, Schmerzen und Schussbeine.  Das Plugin <b>entfernt CSS aus asynchronen Chunks</b> und wurde <b>speziell für diese Aufgabe erstellt</b> , die es perfekt ausführt. <br><br><h4>  Minimal mögliches erneutes Laden von Ressourcen </h4><br>  Wir werden herausfinden, wie Sie sicherstellen können, dass der Benutzer beim Freigeben eines neuen Werbeblocks auf der Hauptseite <b>den kleinstmöglichen Teil des Codes neu lädt</b> . <br><br>  Wenn wir eine Versionierung hätten, wäre alles in Ordnung.  Hier haben wir die Hauptseite von Version N und nach der Veröffentlichung des Promo-Blocks - Version N + 1.  Webpack bietet einen ähnlichen Mechanismus sofort mit Hashing.  Nachdem Webpack alle Assets gesammelt hat, in diesem Fall app.js, berechnet es seinen Inhalts-Hash und fügt ihn dem Dateinamen hinzu, um app. [Hash] .js zu erhalten.  Dies ist die <b>Versionierung, die</b> wir brauchen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fd1/3f2/1a9/fd13f21a9daeddd3a1af9083b8134257.png" alt="Bild"><br><br>  Lassen Sie uns überprüfen, wie es funktioniert.  Aktivieren Sie die Hashes, nehmen Sie Änderungen auf der Hauptseite vor und prüfen Sie, ob sich der Code der Hauptseite wirklich geändert hat. Wir werden feststellen, dass sich zwei Dateien geändert haben: main und app.js. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2a2/bc0/b44/2a2bc0b447b7baf927ac729e28ace633.png" alt="Bild"><br><br>  Warum ist das passiert, weil es unlogisch ist?  Um zu verstehen, warum, <b>werfen wir</b> einen <b>Blick auf app.js.</b>  Es besteht aus drei Teilen: <br><br><ul><li>  Anwendungscode </li><li>  Webpack-Laufzeit; </li><li>  Links zu asynchronen Chunks. </li></ul><br>  Wenn wir den Code in main ändern, ändern sich Inhalt und Hash, was bedeutet, dass sich der <b>Link</b> dazu auch in der App ändert.  Die App selbst ändert sich ebenfalls und muss neu gestartet werden.  Die Lösung für dieses Problem besteht darin <b>,</b> app.js in zwei Blöcke aufzuteilen: Anwendungscode und Webpack-Laufzeit sowie Links zu asynchronen Blöcken.  Webpack 4 erledigt alles für uns mit einer <b>runtimeChunk-</b> Option, die sehr wenig wiegt - weniger als 2 KB in gzip.  Ein Neustart für den Benutzer ist praktisch wertlos.  RuntimeChunk wird mit nur einer Option aktiviert: <br><br><pre> <code class="javascript hljs">optimization: { <span class="hljs-attr"><span class="hljs-attr">runtimeChunk</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }</code> </pre><br>  In Webpack 3 und 2 würden wir 5-6 Zeilen anstelle von einer schreiben.  Dies ist nicht viel mehr, aber immer noch eine zusätzliche Unannehmlichkeit. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6e4/125/5d8/6e41255d837ac2a5c4bb8a6e9b74f686.png" alt="Bild"><br><br>  Alles ist großartig, wir haben gelernt, Links und Laufzeit zu erstellen!  Schreiben wir ein neues Modul in main, geben es frei und - op!  - Jetzt wird im Allgemeinen alles neu gestartet. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cc7/8f6/a5f/cc78f6a5f6ffcd8b2da956d5463fefc8.png" alt="Bild"><br><br>  Warum so?  Mal sehen, wie Module im Webpack funktionieren. <br><br><h4>  Webpack-Module </h4><br>  Angenommen, es gibt Code, in dem Sie die Module <b>a</b> , <b>b</b> , <b>d</b> und <b>e</b> hinzufügen: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'a'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> b <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'b'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> d <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'d'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> e <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'e'</span></span>;</code> </pre><br>  Webpack konvertiert Importe nach Bedarf: <b>a</b> , <b>b</b> , <b>d</b> und <b>e werden</b> durch erfordern (0), erfordern (1), erfordern (2) und erfordern (3) ersetzt. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> d = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> e = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>);</code> </pre><br>  Stellen Sie sich ein Bild vor, das sehr häufig vorkommt: Sie schreiben ein neues Modul c <code>import c from 'c';</code>  und füge es irgendwo in der Mitte ein: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'a'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> b <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'b'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> c <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'c'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> d <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'d'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> e <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'e'</span></span>;</code> </pre><br>  Wenn Webpack alles verarbeitet, konvertiert es den Import des neuen Moduls in require (2): <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> c = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> d = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> e = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-number"><span class="hljs-number">4</span></span>);</code> </pre><br>  Die Module <b>d</b> und <b>e</b> , die 2 und 3 waren, erhalten die Nummern 3 und 4 - die neue ID.  Daraus folgt eine einfache Schlussfolgerung: Die Verwendung von Seriennummern als ID ist etwas albern, aber Webpack tut es. <br><br><blockquote>  Verwenden Sie keine Seriennummer als eindeutige ID </blockquote><br>  Um das Problem zu beheben, gibt es eine integrierte Webpack-Lösung - <b>HashedModuleIdsPlugin</b> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> webpack.HashedModuleIdsPlugin({ <span class="hljs-attr"><span class="hljs-attr">hashFunction</span></span>: <span class="hljs-string"><span class="hljs-string">'md4′, hashDigest:'</span></span>base64′, <span class="hljs-attr"><span class="hljs-attr">hashDigestLength</span></span>: <span class="hljs-number"><span class="hljs-number">4</span></span>, }),</code> </pre><br>  Dieses Plugin verwendet 4 Zeichen <b>md4-Hash</b> anstelle der digitalen ID vom absoluten Pfad zur Datei.  Damit wird unser Bedarf in folgende umgewandelt: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'YmRl'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'N2Fl'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> c = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'OWE4′); var d = require('</span></span>NWQz<span class="hljs-string"><span class="hljs-string">'); var e = require('</span></span>YWVj<span class="hljs-string"><span class="hljs-string">');</span></span></code> </pre><br>  Anstelle von Zahlen erschienen Buchstaben.  Natürlich gibt es ein verstecktes Problem - dies ist eine <b>Kollision von Hashes</b> .  Wir sind einmal darauf gestoßen und können Ihnen raten, 8 statt 4 Zeichen zu verwenden. Nachdem Sie die Hashes richtig konfiguriert haben, funktioniert alles so, wie wir es ursprünglich wollten. <br><br>  Wir wissen jetzt, wie man Traumbündel sammelt. <br><br><ul><li>  <b>Minimieren</b> . </li><li>  <b>Verwenden Sie die Codeaufteilung</b> . </li><li>  <b>Hashes einrichten</b> . </li></ul><br>  Wir haben das Sammeln gelernt und jetzt werden wir an der Geschwindigkeit arbeiten. <br><br><h2>  Wie kann man <b>schnell</b> ein Traumbündel zusammenstellen? </h2><br>  In unserer N1.RU besteht die größte Anwendung aus 10.000 Modulen und ohne Optimierungen dauert es 28 Minuten.  Wir konnten die Montage auf zwei Minuten beschleunigen!  Wie haben wir das gemacht?  Es gibt drei Möglichkeiten, um Berechnungen zu beschleunigen, und alle drei gelten für Webpack. <br><br><h3>  Baugruppenparallelisierung </h3><br>  Als erstes haben wir <b>die Montage parallelisiert</b> .  Dafür haben wir: <br><br><ul><li>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">HappyPackPlugin</a></b> , das Ihre Lader in andere Lader einwickelt und alle Berechnungen, die in separate Prozesse verpackt sind, übernimmt.  Dies ermöglicht beispielsweise die Parallelisierung von Babel und Node-Sass. </li><li>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fadenlader</a></b> .  Funktioniert ungefähr genauso wie HappyPackPlugin, verwendet nur keine Prozesse, sondern einen Thread-Pool.  Das Wechseln zu einem separaten Thread ist eine kostspielige Operation. Gehen Sie vorsichtig damit um und nur dann, wenn Sie ressourcenintensive und schwere Operationen wie babel oder node-sass abschließen möchten.  Zum Laden von json ist beispielsweise keine Parallelisierung erforderlich, da diese schnell geladen wird. </li><li>  Die Plugins und Loader, die Sie höchstwahrscheinlich verwenden, verfügen bereits über <b>integrierte Parallelisierungstools</b> - Sie müssen nur schauen.  Diese Option befindet sich beispielsweise in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">UglifyJS</a> . </li></ul><br><h3>  Caching-Build-Ergebnisse </h3><br>  <b>Das Zwischenspeichern von Assembly-Ergebnissen</b> ist der effizienteste Weg, um die Webpack-Assembly zu beschleunigen. <br><br>  Die erste Lösung ist der <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Cache-Loader</a></b> .  Dies ist ein Loader, der in eine Loaderkette gerät und das Ergebnis des Erstellens einer bestimmten Datei für eine bestimmte Loaderkette im Dateisystem speichert.  Wenn sich diese Datei beim nächsten Zusammenbau des Bundles im Dateisystem befindet und bereits mit dieser Kette verarbeitet wurde, übernimmt der Cache-Loader die Ergebnisse und ruft nicht die dahinter liegenden Loader auf, z. B. Babel-Loader oder Node-Sass. <br><br>  Die Grafik zeigt die Montagezeit.  Blauer Balken - 100% Bauzeit, ohne Cache-Loader und damit - 7% langsamer.  Dies liegt daran, dass der Cache-Loader zusätzliche Zeit damit verbringt, Caches im Dateisystem zu sparen.  Bereits bei der zweiten Montage haben wir einen spürbaren Gewinn erzielt - die Montage war zweimal schneller. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6bc/e73/210/6bce732104fda8263464528d91d1a8a1.png" alt="Bild"><br><br>  Die zweite Lösung ist <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">anspruchsvoller</a></b> - <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">HardSourcePlugin</a></b> .  Der Hauptunterschied: Cache-Loader ist nur ein Loader, der nur in einer Kette von Loadern mit Code oder Dateien ausgeführt werden kann. HardSourcePlugin hat fast vollständigen Zugriff auf das Webpack-Ökosystem, kann mit anderen Plugins und Loadern betrieben werden und erweitert das Ökosystem für das Caching ein wenig.  Die obige Grafik zeigt, dass sich die Erstellungszeit beim ersten Start um 37% erhöhte, beim zweiten Start mit allen Caches jedoch um das Fünffache. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cb6/acf/d36/cb6acfd36adbaaadffd68af19889f960.png" alt="Bild"><br><br>  Das Beste daran ist, dass Sie beide Lösungen zusammen verwenden können, was wir bei N1.RU tun.  Seien Sie vorsichtig, da es Probleme mit Caches gibt, auf die ich später noch eingehen werde. <br><br>  Die Plugins / Loader, die Sie bereits verwenden, verfügen möglicherweise über <b>integrierte Caching-Mechanismen</b> .  Zum Beispiel hat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Babel-Loader ein</a> sehr effizientes Caching-System, das jedoch aus irgendeinem Grund standardmäßig deaktiviert ist.  Die gleiche Funktionalität ist in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">awesome-typeScript-loader</a> .  Das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">UglifyJS-</a> Plugin verfügt auch über Caching, was hervorragend funktioniert.  Er hat uns um einige Minuten beschleunigt. <br><br>  Und jetzt die Probleme. <br><br><h4>  Caching-Probleme </h4><br><ul><li>  Der Cache wird möglicherweise <b>nicht korrekt überprüft</b> . </li><li>  Angewandte Lösungen <b>funktionieren</b> möglicherweise <b>nicht mit verbundenen Plugins, Loadern, Ihrem Code oder untereinander</b> .  In dieser Hinsicht ist der Cache-Loader eine einfache und problemlose Lösung.  Bei HardSourcePlugin müssen Sie jedoch vorsichtiger sein. </li><li>  <b>Es ist schwer zu debütieren, wenn alles kaputt ist</b> .  Wenn das Caching nicht richtig funktioniert und ein unverständlicher Fehler auftritt, ist es sehr schwierig, das Problem herauszufinden. </li></ul><br><h3>  Wie kann man bei der Produktion sparen? </h3><br>  Die letzte Möglichkeit, einen Prozess zu beschleunigen, besteht darin, keinen Teil des Prozesses auszuführen.  Lassen Sie uns darüber nachdenken, wie Sie bei der Produktion sparen können.  Was können wir nicht tun?  Die Antwort ist kurz - <b>wir können nichts tun</b> !  Wir haben kein Recht, etwas in der Produktion abzulehnen, aber wir können viel in der <b>Entwicklung</b> sparen. <br><br>  Was Sie sparen sollten: <br><br><ul><li>  <b>Sammeln Sie die Quellkarte</b> erst, wenn wir sie brauchen. </li><li>  <b>Verwenden Sie Style-Loader</b> anstelle eines coolen Schemas mit CSS-Entfernung und -Verarbeitung über CSS-Loader.  Der Style-Loader selbst ist sehr schnell, da er die CSS-Zeile in eine Funktion schiebt, die diese Zeile in das Style-Tag einfügt. </li><li>  <b>Sie können in der Browserliste nur den Browser belassen, den Sie speziell verwenden - höchstwahrscheinlich ist dies das letzte Chrom</b> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dies wird sich stark beschleunigen</a> . </li><li>  Geben Sie die <b>Optimierung von Ressourcen vollständig auf</b> : von UglifyJS, css-nano, gzip / brotli. </li></ul><br><blockquote>  Build-Beschleunigung ist Parallelisierung, Caching und Ablehnung von Berechnungen.  Wenn Sie diese drei einfachen Schritte ausführen, können Sie sehr stark beschleunigen. </blockquote><br><h2>  Wie konfiguriere ich das Webpack? </h2><br>  Wir haben herausgefunden, wie man ein Traumbündel zusammenbaut und wie man es schnell zusammenbaut, und jetzt werden wir herausfinden, wie man Webpack so konfiguriert, dass wir uns nicht jedes Mal ins Bein schießen, wenn Sie die Konfiguration ändern. <br><br><h3>  Konfigurationsentwicklung im Projekt </h3><br>  Ein typischer Webpack-Konfigurationspfad in einem Projekt beginnt mit einer <b>einfachen</b> Konfiguration.  Zuerst fügen Sie einfach Webpack, Babel-Loader, Sass-Loader ein und alles ist gut.  Dann werden unerwartet einige <b>Bedingungen in process.env angezeigt</b> , und Sie fügen die Bedingungen ein.  Eins, zwei, drei, immer mehr, bis eine Bedingung mit einer "magischen" Option hinzugefügt wird.  Sie verstehen, dass bereits alles ziemlich schlecht ist, und es ist besser, nur <b>die Konfigurationen</b> für <b>Entwickler</b> und Produktion zu <b>duplizieren</b> und zweimal Korrekturen vorzunehmen.  Alles wird klarer.  Wenn Sie einen Gedanken hatten: "Stimmt hier etwas nicht?", Dann ist der einzige funktionierende Rat <b>, die Konfiguration in Ordnung zu halten</b> .  Ich werde Ihnen sagen, wie wir es machen. <br><br><h3>  Halten Sie die Konfiguration in Ordnung </h3><br>  Wir verwenden das <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Webpack-Merge-</a></b> Paket.  Dies ist ein npm-Paket, das erstellt wurde, um mehrere Konfigurationen zu einer zu kombinieren.  Wenn Sie mit der Standard-Zusammenführungsstrategie nicht vertraut sind, können Sie sie anpassen. <br><br><h3>     </h3><br>    4  : <br><br><ul><li> Loaders. </li><li> Plugins. </li><li> Presets. </li><li> Parts. </li></ul><br>    . <br><br><h4> Plugin/Loader </h4><br>  ,        ,       API,  ,      . <br><br>  Es sieht ungefähr so ​​aus: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** *  JSdoc * @param {Object} options * @see    */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createPlugin</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">options</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Plugin(options); };</code> </pre><br>  ,   ,   ,   .    ,       url-loader  : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** * url-loader    file-loader.        * * @example * -   some-image.png.     url-loader,  url-loader    * 1.    ,  url-loader    base64  * 2. , url-loader    outputPath + name     ,     . *    some-image.png,     outputPath/images/some-image.12345678hash.png,  url-loader  * publicPath/images/some-image.12345678hash.png * * @param {string} prefix    * @param {number} limit    ,    * @return {Object} loader   * @see https://www.npmjs.com/package/url-loader */</span></span></code> </pre><br>     ,   ,  , ,    ,   ,     .  ,  ,   ,  ,   url-loader.    : <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">urlLoader</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">prefix = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'assets'</span></span></span></span><span class="hljs-function"><span class="hljs-params">, limit = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">100</span></span></span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">loader</span></span>: <span class="hljs-string"><span class="hljs-string">'url-loader'</span></span>, <span class="hljs-attr"><span class="hljs-attr">options</span></span>: { limit, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${prefix}</span></span></span><span class="hljs-string">/[name].[hash].[ext]`</span></span> } }; };</code> </pre><br>         .    ,   Loader         . <br><br><h4> Preset </h4><br>    webpack.     ,      ,    ,   webpack,    .    —  ,  ,    scss-: <br><br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">test</span></span>: <span class="hljs-regexp"><span class="hljs-regexp">/\.scss$/</span></span>, <span class="hljs-attr"><span class="hljs-attr">use</span></span>: [cssLoader, postCssLoader, scssLoader] }</code> </pre><br>     . <br><br><h4> Part </h4><br>  —  ,      .        ,       ,   .  ,       : <br><br><pre> <code class="javascript hljs">entry: { <span class="hljs-attr"><span class="hljs-attr">app</span></span>: <span class="hljs-string"><span class="hljs-string">'./src/Frontend/app.js'</span></span> }, <span class="hljs-attr"><span class="hljs-attr">output</span></span>: { <span class="hljs-attr"><span class="hljs-attr">publicPath</span></span>: <span class="hljs-string"><span class="hljs-string">'/static/cabinet/app/'</span></span>, <span class="hljs-attr"><span class="hljs-attr">path</span></span>: path.resolve(<span class="hljs-string"><span class="hljs-string">'www/static/app'</span></span>) },</code> </pre><br>     : <br><br><ul><li> <b> </b> ,   ,   , json,     , , splitChunks. </li><li> <b>  dev</b> ,  ,    js/css     </li><li> <b>Part</b> ,   output, publicPath, entry-point    , ,    source map. </li></ul><br><img src="https://habrastorage.org/getpro/habr/post_images/7ee/20f/fa6/7ee20ffa6f453c35f11d92e3583d8caf.png" alt="Bild"><br><br> <b>Webpack-merge</b>     .          ,     .  webpack-merge     3-7 ,    Babel-loader,            .    ,   . <br><br><h3>   </h3><br>  Zusammenfassend. <b>  </b> ,    . <b> </b> ,   webpack       —     . <b>  </b> ,  . <br><br>   ,    ! <br><br><blockquote>   —     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Frontend Conf</a> . ,    —  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> ,           ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Frontend Conf ++</a>  . <br><br>    -      ?    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FrontenConf ++</a> ,   27  28   . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a>  27 ,   15          .     — ! </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de433324/">https://habr.com/ru/post/de433324/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de433308/index.html">Übertragen der PBX-Konfiguration an den 3CX PBX Express-Dienst</a></li>
<li><a href="../de433316/index.html">Design Digest: Onboarding, Feedback, Suche nach Ideen und Entscheidungsfindung</a></li>
<li><a href="../de433318/index.html">garbage.collect ()</a></li>
<li><a href="../de433320/index.html">Rasterlayout als Basis moderner Layouts</a></li>
<li><a href="../de433322/index.html">JSON API - wir arbeiten gemäß der Spezifikation</a></li>
<li><a href="../de433326/index.html">Codequalität</a></li>
<li><a href="../de433328/index.html">Besser einen Tag verlieren</a></li>
<li><a href="../de433330/index.html">Lösen Sie japanische Kreuzworträtsel mit SAT Solver</a></li>
<li><a href="../de433332/index.html">Python-Unterstützung in Azure-Funktionen</a></li>
<li><a href="../de433334/index.html">XAML Behaviors for WPF ist jetzt Open Source</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>