<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üê¶ üõ≥Ô∏è üîã Tarantool kubernetes Betreiber ü•• üêΩ ‚òÑÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kubernetes ist bereits zu einem De-facto-Standard f√ºr die Ausf√ºhrung zustandsloser Anwendungen geworden, vor allem, weil dadurch die Markteinf√ºhrungsz...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tarantool kubernetes Betreiber</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/472428/"><img src="https://habrastorage.org/getpro/habr/post_images/550/d23/612/550d23612db44d65216aff9caf75403a.jpg"><br><br>  Kubernetes ist bereits zu einem De-facto-Standard f√ºr die Ausf√ºhrung zustandsloser Anwendungen geworden, vor allem, weil dadurch die Markteinf√ºhrungszeit f√ºr neue Funktionen verk√ºrzt werden kann.  Das Starten von Stateful-Anwendungen wie Datenbanken oder Stateful-Microservices ist immer noch eine komplexe Aufgabe, aber Unternehmen m√ºssen sich der Konkurrenz stellen und eine hohe Bereitstellungsrate aufrechterhalten.  Sie schaffen also eine Nachfrage nach solchen L√∂sungen. <br><br>  Wir m√∂chten unsere L√∂sung f√ºr den Start von Stateful <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tarantool Cartridge-</a> Clustern <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vorstellen</a> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tarantool Kubernetes Operator</a> , mehr unter dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Strich</a> . <br><a name="habracut"></a><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Anstelle von tausend Worten</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Was der Bediener tats√§chlich tut</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ein wenig √ºber die Details</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wie der Bediener arbeitet</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Was der Operator erstellt</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zusammenfassung</a> <br></li></ol><br>  Tarantool ist ein Open-Source-DBMS und ein Anwendungsserver in einem.  Als Datenbank weist sie viele einzigartige Merkmale auf: hohe Effizienz der Hardwareauslastung, flexibles Datenschema, Unterst√ºtzung f√ºr In-Memory- und Festplattenspeicher sowie die M√∂glichkeit der Erweiterung mithilfe der Lua-Sprache.  Als Anwendungsserver k√∂nnen Sie den Anwendungscode mit minimaler Antwortzeit und maximalem Durchsatz so nah wie m√∂glich an die Daten verschieben.  Dar√ºber hinaus verf√ºgt Tarantool √ºber ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">umfangreiches √ñkosystem,</a> das gebrauchsfertige Module zur L√∂sung von Anwendungsproblemen bietet: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sharding</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Warteschlange</a> , Module f√ºr die einfache Entwicklung ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Cartridge</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Luatest</a> ), L√∂sungen f√ºr den Betrieb ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Metrics</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ansible</a> ), um nur einige zu nennen. <br><br>  Trotz aller Vorz√ºge sind die Funktionen einer einzelnen Tarantool-Instanz immer begrenzt.  Sie m√ºssten Dutzende und Hunderte von Instanzen erstellen, um Terabyte an Daten zu speichern und Millionen von Anforderungen zu verarbeiten, was bereits ein verteiltes System mit all seinen typischen Problemen impliziert.  Um sie zu l√∂sen, haben wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tarantool Cartridge</a> , ein Framework, das alle m√∂glichen Schwierigkeiten beim Schreiben verteilter Anwendungen verbirgt.  Entwickler k√∂nnen sich auf den Gesch√§ftswert der Anwendung konzentrieren.  Cartridge bietet einen robusten Satz von Komponenten f√ºr die automatische Cluster-Orchestrierung, die automatische Datenverteilung, die WebUI f√ºr den Betrieb und Entwicklertools. <br><br>  Bei Tarantool geht es nicht nur um Technologien, sondern auch um ein Team von Ingenieuren, die an der Entwicklung schl√ºsselfertiger Unternehmenssysteme, sofort einsatzbereiter L√∂sungen und der Unterst√ºtzung von Open-Source-Komponenten arbeiten. <br><br>  Weltweit lassen sich alle unsere Aufgaben in zwei Bereiche unterteilen: die Entwicklung neuer Systeme und die Verbesserung bestehender L√∂sungen.  Zum Beispiel gibt es eine umfangreiche Datenbank von einem bekannten Anbieter.  Um es f√ºr das Lesen zu skalieren, wird ein Tarantool-basierter, eventuell konsistenter Cache dahinter platziert.  Oder umgekehrt: Um das Schreiben zu skalieren, wird Tarantool in der Hot / Cold-Konfiguration installiert: W√§hrend die Daten "abk√ºhlen", werden sie in den K√ºhlspeicher und gleichzeitig in die Analysewarteschlange gestellt.  Oder es wird eine Light-Version eines vorhandenen Systems geschrieben (funktionale Sicherung), um die "hei√üen" Daten mithilfe der Datenreplikation vom Hauptsystem zu sichern.  Weitere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Informationen finden Sie in den Konferenzberichten zu T + 2019</a> . <br><br>  Alle diese Systeme haben eines gemeinsam: Sie sind etwas schwierig zu bedienen.  Nun, es gibt viele aufregende Dinge: schnell einen Cluster von √ºber 100 Instanzen zu erstellen, die in 3 Rechenzentren gesichert werden;  Aktualisieren der Anwendung, in der Daten ohne Ausfallzeiten oder Wartungsprobleme gespeichert werden;  ein Backup und eine Wiederherstellung zu erstellen, um sich auf einen m√∂glichen Unfall oder menschliche Fehler vorzubereiten;  um ein Failover versteckter Komponenten sicherzustellen;  Konfigurationsmanagement organisieren ... <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die Tarantool-Kassette</a> , die buchst√§blich gerade in Open Source ver√∂ffentlicht wurde, vereinfacht die Entwicklung verteilter Systeme erheblich: Sie unterst√ºtzt das Clustering von Komponenten, die Diensterkennung, das Konfigurationsmanagement, die Erkennung von Instanzfehlern und das automatische Failover, das Management der Replikationstopologie und das Sharding von Komponenten. <br>  Es w√§re gro√üartig, wenn wir all dies so schnell wie m√∂glich betreiben k√∂nnten.  Kubernetes macht es m√∂glich, aber ein spezialisierter Bediener w√ºrde das Leben noch komfortabler machen. <br><br>  Heute stellen wir die Alpha-Version von Tarantool Kubernetes Operator vor. <br><br><a name="1"></a><h2>  Anstelle von tausend Worten </h2><br>  Wir haben ein kleines Beispiel basierend auf Tarantool Cartridge vorbereitet und werden damit arbeiten.  Es ist eine einfache Anwendung, die als verteilter Schl√ºsselwertspeicher mit HTTP-Schnittstelle bezeichnet wird.  Nach dem Start haben wir Folgendes: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c24/235/2c7/c242352c708a0e0dfa8fc0896bbb986d.png"><br><br>  Wo <br><br><ul><li>  Router sind Teil des Clusters, der f√ºr das Akzeptieren und Verarbeiten eingehender HTTP-Anforderungen verantwortlich ist. <br></li><li>  Speicher sind Teil des Clusters, der f√ºr das Speichern und Verarbeiten von Daten verantwortlich ist.  Es werden sofort drei Shards installiert, von denen jeder einen Master und eine Replik hat. <br></li></ul><br>  Um den eingehenden HTTP-Verkehr auf den Routern auszugleichen, wird ein Kubernetes Ingress verwendet.  Die Daten werden im Speicher auf der Ebene von Tarantool selbst mithilfe der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vshard-Komponente verteilt</a> . <br><br>  Wir brauchen Kubernetes 1.14+, aber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Minikube</a> wird es tun.  Es ist auch sch√∂n, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kubectl</a> zu haben.  Erstellen Sie zum Starten des Operators ein ServiceAccount, eine Rolle und eine Rollenbindung: <br><br><pre><code class="plaintext hljs">$ kubectl create -f https://raw.githubusercontent.com/tarantool/tarantool-operator/0.0.1/deploy/service_account.yaml $ kubectl create -f https://raw.githubusercontent.com/tarantool/tarantool-operator/0.0.1/deploy/role.yaml $ kubectl create -f https://raw.githubusercontent.com/tarantool/tarantool-operator/0.0.1/deploy/role_binding.yaml</code> </pre> <br>  Tarantool Operator erweitert die Kubernetes-API mit ihren Ressourcendefinitionen. Erstellen wir sie also: <br><br><pre> <code class="plaintext hljs">$ kubectl create -f https://raw.githubusercontent.com/tarantool/tarantool-operator/0.0.1/deploy/crds/tarantool_v1alpha1_cluster_crd.yaml $ kubectl create -f https://raw.githubusercontent.com/tarantool/tarantool-operator/0.0.1/deploy/crds/tarantool_v1alpha1_role_crd.yaml $ kubectl create -f https://raw.githubusercontent.com/tarantool/tarantool-operator/0.0.1/deploy/crds/tarantool_v1alpha1_replicasettemplate_crd.yaml</code> </pre> <br>  Alles ist bereit, um den Bediener zu starten. <br><br><pre> <code class="plaintext hljs">$ kubectl create -f https://raw.githubusercontent.com/tarantool/tarantool-operator/0.0.1/deploy/operator.yaml</code> </pre> <br>  Wir warten auf den Start des Bedieners und k√∂nnen dann mit dem Starten der Anwendung fortfahren: <br><br><pre> <code class="plaintext hljs">$ kubectl create -f https://raw.githubusercontent.com/tarantool/tarantool-operator/0.0.1/examples/kv/deployment.yaml</code> </pre> <br>  Ein Ingress wird auf der Web-Benutzeroberfl√§che in der YAML-Datei mit dem Beispiel deklariert.  Es ist in <code>cluster_ip/admin/cluster</code> verf√ºgbar.  Wenn mindestens ein Ingress Pod bereit ist und ausgef√ºhrt wird, k√∂nnen Sie dort beobachten, wie neue Instanzen zum Cluster hinzugef√ºgt werden und wie sich seine Topologie √§ndert. <br>  Wir warten auf die Verwendung des Clusters: <br><br><pre> <code class="plaintext hljs">$ kubectl describe clusters.tarantool.io examples-kv-cluster</code> </pre> <br>  Wir warten auf folgenden Clusterstatus: <br><br><pre> <code class="plaintext hljs">‚Ä¶ Status: State: Ready ‚Ä¶</code> </pre> <br>  Das ist alles und die Anwendung ist einsatzbereit! <br><br>  Ben√∂tigen Sie mehr Speicherplatz?  Dann f√ºgen wir einige Scherben hinzu: <br><br><pre> <code class="plaintext hljs">$ kubectl scale roles.tarantool.io storage --replicas=3</code> </pre> <br>  Wenn Shards die Last nicht verarbeiten k√∂nnen, erh√∂hen wir die Anzahl der Instanzen im Shard, indem wir die Replikatsatzvorlage bearbeiten: <br><br><pre> <code class="plaintext hljs">$ kubectl edit replicasettemplates.tarantool.io storage-template</code> </pre> <br>  Setzen wir den Wert <code>.spec.replicas</code> auf zwei, um die Anzahl der Instanzen in jedem Replikatsatz auf zwei zu erh√∂hen. <br><br>  Wenn ein Cluster nicht mehr ben√∂tigt wird, l√∂schen Sie ihn einfach zusammen mit allen Ressourcen: <br><br><pre> <code class="plaintext hljs">$ kubectl delete clusters.tarantool.io examples-kv-cluster</code> </pre> <br>  Ist etwas schief gelaufen?  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erstellen Sie ein Ticket</a> , und wir werden schnell daran arbeiten. <br><br><a name="2"></a><h2>  Was der Bediener tats√§chlich tut </h2><br>  Beim Starten und Betreiben des Tarantool Cartridge-Clusters werden bestimmte Aktionen in einer bestimmten Reihenfolge zu einem bestimmten Zeitpunkt ausgef√ºhrt. <br><br>  Der Cluster selbst wird haupts√§chlich √ºber die Admin-API verwaltet: GraphQL √ºber HTTP.  Sie k√∂nnen zweifellos eine Stufe tiefer gehen und Befehle direkt √ºber die Konsole erteilen, aber dies kommt nicht sehr oft vor. <br>  So startet der Cluster beispielsweise: <br><br><ol><li>  Wir stellen die erforderliche Anzahl von Tarantool-Instanzen bereit, z. B. mit systemd. </li><li>  Dann verbinden wir die Instanzen zu einer Mitgliedschaft: <br><br><pre> <code class="plaintext hljs">mutation { probe_instance: probe_server(uri: "storage:3301") }</code> </pre> </li><li>  Anschlie√üend weisen wir den Instanzen die Rollen zu und geben die IDs der Instanz und des Replikatsatzes an.  Zu diesem Zweck wird die GraphQL-API verwendet: <br><br><pre> <code class="plaintext hljs">mutation { join_server( uri:"storage:3301", instance_uuid: "cccccccc-cccc-4000-b000-000000000001", replicaset_uuid: "cccccccc-0000-4000-b000-000000000000", roles: ["storage"], timeout: 5 ) }</code> </pre> </li><li>  Schlie√ülich booten wir die Komponente, die f√ºr das Sharding verantwortlich ist, mithilfe der API: <br><br><pre> <code class="plaintext hljs">mutation { bootstrap_vshard cluster { failover(enabled:true) } }</code> </pre> </li></ol><br>  Einfach, oder? <br><br>  Bei der Clustererweiterung ist alles interessanter.  Die Rolle "Router" aus dem Beispiel l√§sst sich leicht skalieren: Erstellen Sie weitere Instanzen, verbinden Sie sie mit einem vorhandenen Cluster, und fertig!  Die Rolle der Speicher ist etwas schwieriger.  Der Speicher ist gespalten. Wenn Sie also Instanzen hinzuf√ºgen oder entfernen, m√ºssen Sie die Daten neu ausgleichen, indem Sie sie zu / von den neuen / gel√∂schten Instanzen verschieben.  Andernfalls w√ºrden entweder unterlastete Instanzen oder Daten verloren gehen.  Was ist, wenn es nicht nur einen, sondern ein Dutzend Cluster mit unterschiedlichen Topologien gibt? <br><br>  Im Allgemeinen ist dies alles, was Tarantool Operator erledigt.  Der Benutzer beschreibt den erforderlichen Status des Tarantool-Cartridge-Clusters und √ºbersetzt ihn in eine Reihe von Aktionen, die auf die K8-Ressourcen angewendet werden, sowie in bestimmte Aufrufe der Tarantool-Cluster-Administrator-API in einer bestimmten Reihenfolge zu einem bestimmten Zeitpunkt.  Es wird auch versucht, alle Details vor dem Benutzer zu verbergen. <br><br><a name="3"></a><h2>  Ein wenig √ºber die Details </h2><br>  Bei der Arbeit mit der Tarantool Cartridge-Clusteradministrator-API sind sowohl die Reihenfolge der Anrufe als auch ihr Ziel von entscheidender Bedeutung.  Warum ist das so? <br><br>  Tarantool Cartridge enth√§lt den Topologiespeicher, die Service Discovery-Komponente und die Konfigurationskomponente.  Jede Instanz des Clusters speichert eine Kopie der Topologie und Konfiguration in einer YAML-Datei. <br><br><pre> <code class="plaintext hljs">servers: d8a9ce19-a880-5757-9ae0-6a0959525842: uri: storage-2-0.examples-kv-cluster:3301 replicaset_uuid: 8cf044f2-cae0-519b-8d08-00a2f1173fcb 497762e2-02a1-583e-8f51-5610375ebae9: uri: storage-0-0.examples-kv-cluster:3301 replicaset_uuid: 05e42b64-fa81-59e6-beb2-95d84c22a435 ‚Ä¶ vshard: bucket_count: 30000 ...</code> </pre> <br>  Aktualisierungen werden konsistent mithilfe des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zwei-Phasen-</a> Festschreibungsmechanismus angewendet.  F√ºr ein erfolgreiches Update ist ein Quorum von 100% erforderlich: Jede Instanz muss antworten.  Andernfalls rollt es zur√ºck.  Was bedeutet das f√ºr den Betrieb?  In Bezug auf die Zuverl√§ssigkeit sollten alle Anforderungen an die Administrator-API, die den Clusterstatus √§ndern, an eine einzelne Instanz oder den Leader gesendet werden, da sonst die Gefahr besteht, dass unterschiedliche Konfigurationen f√ºr unterschiedliche Instanzen vorliegen.  Tarantool Cartridge wei√ü (noch nicht) nicht, wie man eine F√ºhrungswahl durchf√ºhrt, aber Tarantool Operator kann und f√ºr Sie ist dies nur eine lustige Tatsache, da der Operator alles tut. <br><br>  Jede Instanz sollte auch eine feste Identit√§t haben, d. H. Eine Menge von <code>instance_uuid</code> und <code>replicaset_uuid</code> sowie <code>advertise_uri</code> .  Wenn pl√∂tzlich ein Speicher neu gestartet wird und sich einer dieser Parameter √§ndert, besteht die Gefahr, dass das Quorum verletzt wird, und der Bediener ist daf√ºr verantwortlich. <br><br><a name="4"></a><h2>  Wie der Bediener arbeitet </h2><br>  Der Zweck des Bedieners besteht darin, das System in den benutzerdefinierten Zustand zu versetzen und das System in diesem Zustand zu halten, bis neue Anweisungen gegeben werden.  Damit der Bediener arbeiten kann, ben√∂tigt er: <br><br><ol><li>  Die Beschreibung des Systemstatus. </li><li>  Der Code, der das System in diesen Zustand bringen w√ºrde. </li><li>  Ein Mechanismus zum Integrieren dieses Codes in k8s (zum Beispiel zum Empfangen von Status√§nderungsbenachrichtigungen). </li></ol><br>  Der Tarantool Cartridge-Cluster wird in k8s unter Verwendung einer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">benutzerdefinierten Ressourcendefinition (CRD) beschrieben</a> .  Der Betreiber w√ºrde drei benutzerdefinierte Ressourcen ben√∂tigen, die unter der Gruppe tarantool.io/v1alpha zusammengefasst sind: <br><br><ul><li>  Cluster ist eine Ressource der obersten Ebene, die einem einzelnen Tarantool Cartridge-Cluster entspricht. </li><li>  Rolle ist eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Benutzerrolle</a> in Bezug auf Tarantool Cartridge. </li><li>  Replicaset Template ist eine Vorlage zum Erstellen von StatefulSets (ich werde Ihnen etwas sp√§ter erkl√§ren, warum sie StatefulSets sind; nicht zu verwechseln mit K8s ReplicaSet). </li></ul><br>  Alle diese Ressourcen spiegeln direkt das Tarantool Cartridge-Cluster-Beschreibungsmodell wider.  Ein gemeinsames W√∂rterbuch erleichtert die Kommunikation mit den Entwicklern und das Verst√§ndnis dessen, was sie in der Produktion sehen m√∂chten. <br><br>  Der Code, der das System in den angegebenen Zustand bringt, ist der Controller in Bezug auf K8s.  Im Fall von Tarantool Operator gibt es mehrere Controller: <br><br><ul><li>  Der Cluster Controller ist f√ºr die Interaktion mit dem Tarantool Cartridge-Cluster verantwortlich.  Es verbindet Instanzen mit dem Cluster und trennt Instanzen vom Cluster. </li><li>  Der Rollencontroller ist der Benutzerrollencontroller, der f√ºr die Erstellung von StatefulSets aus der Vorlage und die Verwaltung der vordefinierten Anzahl verantwortlich ist. </li></ul><br>  Wie ist ein Controller?  Es ist eine Reihe von Codes, die die Welt um sich herum allm√§hlich in Ordnung bringen.  Ein Cluster-Controller w√ºrde schematisch wie folgt aussehen: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/048/fbd/e9c/048fbde9c799c900b74df1669d3d760e.png"><br><br>  Ein Einstiegspunkt ist ein Test, um festzustellen, ob f√ºr ein Ereignis eine entsprechende Clusterressource vorhanden ist.  Existiert es?  "Nein" bedeutet beenden.  "Ja" bedeutet, zum n√§chsten Block √ºberzugehen und die Benutzerrollen zu √ºbernehmen.  Wenn das Eigentum an einer Rolle √ºbernommen wird, wird sie beendet und beim zweiten Mal ausgef√ºhrt.  Es geht weiter und weiter, bis es das Eigentum an allen Rollen √ºbernimmt.  Wenn das Eigentum √ºbernommen wurde, ist es Zeit, zum n√§chsten Betriebsblock √ºberzugehen.  Und der Prozess geht bis zum letzten Block weiter.  Danach k√∂nnen wir davon ausgehen, dass sich das gesteuerte System im definierten Zustand befindet. <br><br>  Im Allgemeinen ist alles ganz einfach.  Es ist jedoch wichtig, die Erfolgskriterien f√ºr das Bestehen jeder Stufe zu bestimmen.  Beispielsweise wird die Cluster-Join-Operation nicht als erfolgreich angesehen, wenn sie den hypothetischen Erfolg = true zur√ºckgibt, sondern wenn ein Fehler wie "bereits verbunden" zur√ºckgegeben wird. <br><br>  Und der letzte Teil dieses Mechanismus ist die Integration des Controllers in K8s.  Aus der Vogelperspektive besteht der gesamte K8 aus einer Reihe von Controllern, die Ereignisse generieren und darauf reagieren.  Diese Ereignisse sind in Warteschlangen organisiert, die wir abonnieren k√∂nnen.  Es w√ºrde schematisch aussehen wie: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/51f/aac/8cd/51faac8cdbbc04ec81b0f383313369df.jpg"><br><br>  Der Benutzer ruft <code>kubectl create -f tarantool_cluster.yaml</code> und die entsprechende <code>kubectl create -f tarantool_cluster.yaml</code> wird erstellt.  Der Cluster-Controller wird √ºber die Erstellung der Cluster-Ressourcen benachrichtigt.  Als erstes wird versucht, alle Rollenressourcen zu finden, die Teil dieses Clusters sein sollten.  Wenn dies der Fall ist, wird der Cluster als Eigent√ºmer f√ºr die Rolle zugewiesen und die Rollenressource aktualisiert.  Der Rollencontroller erh√§lt eine Benachrichtigung √ºber die Rollenaktualisierung, versteht, dass die Ressource ihren Eigent√ºmer hat, und beginnt mit der Erstellung von StatefulSets.  So funktioniert es: Das erste Ereignis l√∂st das zweite aus, das zweite Ereignis l√∂st das dritte aus und so weiter, bis eines von ihnen stoppt.  Sie k√∂nnen auch alle 5 Sekunden einen Zeitausl√∂ser einstellen. <br><br>  So ist der Operator organisiert: Wir erstellen eine benutzerdefinierte Ressource und schreiben den Code, der auf die Ereignisse im Zusammenhang mit den Ressourcen reagiert. <br><br><a name="5"></a><h2>  Was der Operator erstellt </h2><br>  Die Bedieneraktionen f√ºhren letztendlich zur Erstellung von K8-Pods und -Containern.  In dem auf K8s bereitgestellten Tarantool Cartridge-Cluster sind alle Pods mit StatefulSets verbunden. <br><br>  Warum StatefulSet?  Wie bereits erw√§hnt, beh√§lt jede Tarantool-Cluster-Instanz eine Kopie der Cluster-Topologie und -Konfiguration bei.  Und hin und wieder verf√ºgt ein Anwendungsserver √ºber Speicherplatz, der beispielsweise f√ºr Warteschlangen oder Referenzdaten reserviert ist, und dies ist bereits ein vollst√§ndiger Status.  StatefulSet garantiert auch, dass die Pod-Identit√§ten erhalten bleiben. Dies ist wichtig, wenn Instanzen geclustert werden: Instanzen sollten feste Identit√§ten haben, da sonst das Quorum beim Neustart verloren gehen kann. <br><br>  Wenn alle Clusterressourcen bereit und im gew√ºnschten Zustand sind, spiegeln sie die folgende Hierarchie wider: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/51f/aac/8cd/51faac8cdbbc04ec81b0f383313369df.jpg"><br><br>  Die Pfeile geben die inhaberabh√§ngige Beziehung zwischen Ressourcen an.  Der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Garbage Collector</a> muss beispielsweise nach dem Entfernen des Clusters bereinigt werden. <br><br>  Zus√§tzlich zu StatefulSets erstellt Tarantool Operator einen Headless-Service f√ºr die Leader-Wahl, und die Instanzen kommunizieren √ºber diesen Service miteinander. <br><br>  Tarantool Operator basiert auf dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Operator Framework</a> , und der Operatorcode ist in Golang geschrieben, daher gibt es hier nichts Besonderes. <br><br><a name="6"></a><h2>  Zusammenfassung </h2><br>  Das ist so ziemlich alles.  Wir warten auf Ihr Feedback und Ihre Tickets.  Wir k√∂nnen nicht ohne sie auskommen - es ist schlie√ülich die Alpha-Version.  Was kommt als n√§chstes?  Der n√§chste Schritt ist viel Polieren: <br><br><ul><li>  Einheit, E2E-Tests; <br></li><li>  Chaos Monkey Tests; <br></li><li>  Stresstests; <br></li><li>  sichern / wiederherstellen; <br></li><li>  externer Topologieanbieter. <br></li></ul><br>  Jedes dieser Themen ist f√ºr sich genommen umfassend und verdient einen eigenen Artikel. Warten Sie also bitte auf Aktualisierungen! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de472428/">https://habr.com/ru/post/de472428/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de472416/index.html">ZeroNights Hackquest 2019 Ergebnisse und Zuschreibungen</a></li>
<li><a href="../de472418/index.html">So behalten Sie die Rechte zur benutzerdefinierten Entwicklung</a></li>
<li><a href="../de472420/index.html">Dank des verz√∂gerten Versprechens wird die Benutzeroberfl√§che reaktionsschneller</a></li>
<li><a href="../de472422/index.html">Sber X RamblerFront & Meet Up</a></li>
<li><a href="../de472426/index.html">Sicherheitswoche 43: Das geheime Leben der IoT Hanipots</a></li>
<li><a href="../de472430/index.html">Wie wir die Komponentenbasis f√ºr ein Smart Home ausgew√§hlt haben: √ºber Sensoren und eine Steuerung</a></li>
<li><a href="../de472432/index.html">Python 3.8: Was ist neu und wie wird es verwendet?</a></li>
<li><a href="../de472434/index.html">Aktualisieren Sie Ihre Releases</a></li>
<li><a href="../de472438/index.html">Verwendung von Proxys in der Informationssicherheit: 6 praktische Anwendungsf√§lle</a></li>
<li><a href="../de472440/index.html">Ein Tag bei Joker 2019</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>