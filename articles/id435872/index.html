<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏻‍🔧 🕰️ 🙅🏻 Bahasa pemrograman zig 🏮 🏸 👨‍👨‍👧‍👧</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Komentar pertama pada artikel yang indah Visi Subjektif Bahasa Pemrograman Ideal ternyata menjadi referensi ke bahasa pemrograman Zig . Tentu saja, me...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bahasa pemrograman zig</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435872/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/pq/fm/db/pqfmdbfclpie1tmlpudotsmvlbw.jpeg"></div><br>  Komentar pertama pada artikel yang indah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Visi Subjektif Bahasa Pemrograman Ideal</a> ternyata menjadi referensi ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bahasa pemrograman Zig</a> .  Tentu saja, menjadi menarik jenis bahasa apa yang mengklaim sebagai ceruk C ++, D dan Rust.  Saya melihat - bahasanya tampak cantik dan agak menarik.  Sintaks seperti si, pendekatan orisinal untuk penanganan kesalahan, coroutine bawaan.  Artikel ini adalah ikhtisar singkat dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi resmi yang</a> diselingi dengan pemikiran dan kesan mereka sendiri dari menjalankan contoh kode. <br><a name="habracut"></a><br><h2>  Memulai </h2><br>  Instalasi kompiler cukup sederhana, untuk Windows - cukup unzip paket distribusi ke beberapa folder.  Kami membuat file teks hello.zig di folder yang sama, masukkan kode dari dokumentasi di sana dan simpan.  Perakitan dilakukan dengan perintah <br><br><pre><code class="plaintext hljs">zig build-exe hello.zig</code> </pre> <br>  setelah itu hello.exe muncul di direktori yang sama. <br><br>  Selain perakitan, mode pengujian unit tersedia, untuk ini, blok uji digunakan dalam kode, dan perakitan dan peluncuran tes dilakukan oleh perintah <br><br><pre> <code class="plaintext hljs">zig test hello.zig</code> </pre> <br><h3>  Keanehan pertama </h3><br>  Kompiler tidak mendukung jeda baris Windows (\ r \ n).  Tentu saja, fakta bahwa line break di setiap sistem (Win, Nix, Mac) adalah beberapa dari mereka sendiri adalah keliaran dan peninggalan masa lalu.  Tetapi tidak ada yang harus dilakukan, jadi pilih saja, misalnya, di Notepad ++ format yang Anda inginkan untuk kompiler. <br><br>  Keanehan kedua yang saya alami secara tidak sengaja - tab tidak didukung dalam kode!  Hanya spasi.  Tapi itu terjadi :) <br><br>  Namun, ini ditulis dengan jujur ​​dalam dokumentasi - kebenaran sudah ada di akhir. <br><br><h3>  Komentar </h3><br>  Keanehan lain adalah Zig tidak mendukung komentar multi-baris.  Saya ingat bahwa semuanya dilakukan dengan benar dalam turbo pascal kuno - komentar multi-baris bersarang didukung.  Rupanya, sejak itu tidak ada pengembang bahasa yang menguasai hal sederhana ini :) <br><br>  Tetapi ada komentar dokumenter.  Mulai dengan ///.  Harus di tempat-tempat tertentu - di depan objek yang sesuai (variabel, fungsi, kelas ...).  Jika mereka berada di tempat lain - kesalahan kompilasi.  Tidak buruk. <br><br><h3>  Deklarasi variabel </h3><br>  Dilakukan dengan gaya modis sekarang (dan secara ideologis benar), ketika kata kunci (const atau var) ditulis terlebih dahulu, kemudian namanya, kemudian secara opsional jenisnya, dan kemudian nilai awal.  Yaitu  inferensi tipe otomatis tersedia.  Variabel harus diinisialisasi - jika Anda tidak menentukan nilai awal, akan ada kesalahan kompilasi.  Namun, nilai undefined khusus disediakan, yang dapat secara eksplisit digunakan untuk menentukan variabel yang tidak diinisialisasi. <br><br><pre> <code class="plaintext hljs">var i:i32 = undefined;</code> </pre> <br><h3>  Output konsol </h3><br>  Untuk percobaan, kita perlu output ke konsol - dalam semua contoh, ini adalah metode yang digunakan.  Di bidang plug-in <br><br><pre> <code class="plaintext hljs">const warn = std.debug.warn;</code> </pre> <br>  dan kodenya ditulis seperti ini: <br><br><pre> <code class="plaintext hljs">warn("{}\n{}\n", false, "hi");</code> </pre> <br>  Kompiler memiliki beberapa bug, yang dengan jujur ​​dilaporkan ketika mencoba untuk mengeluarkan bilangan bulat atau angka floating-point dengan cara ini: <br><blockquote>  error: compiler bug: integer dan float literals dalam fungsi var args harus dicor.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github.com/ziglang/zig/issues/557</a> </blockquote><h2>  Tipe data </h2><br><h3>  Tipe primitif </h3><br>  Nama tipe rupanya diambil dari Rust (i8, u8, ... i128, u128), ada juga tipe khusus untuk kompatibilitas biner C, 4 tipe tipe floating-point (f16, f32, f64, f128).  Ada tipe bool.  Ada jenis nol panjang batal dan noreturn khusus, yang akan saya bahas nanti. <br><br>  Anda juga bisa membuat tipe integer dengan panjang berapa pun dalam bit dari 1 hingga 65535. Nama tipe dimulai dengan huruf i atau u, dan kemudian panjang dalam bit ditulis. <br><br><pre> <code class="plaintext hljs">//  ! var j:i65535 = 0x0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF;</code> </pre> <br>  Namun, saya tidak bisa mendapatkan nilai ini ke konsol - kesalahan terjadi pada LLVM selama proses kompilasi. <br><br>  Secara umum, ini adalah solusi yang menarik, meskipun ambigu (IMHO: mendukung literal angka yang persis panjang pada tingkat kompiler adalah benar, tetapi jenis penamaan dengan cara ini tidak terlalu baik, lebih baik melakukannya dengan jujur ​​melalui tipe templat).  Dan mengapa batas 65535?  Perpustakaan seperti GMP tampaknya tidak memaksakan pembatasan seperti itu? <br><br><h3>  Literal string </h3><br>  Ini adalah array karakter (tanpa akhir nol di akhir).  Untuk literal dengan nol penghentian, awalan 'c' digunakan. <br><br><pre> <code class="plaintext hljs">const normal_bytes = "hello"; const null_terminated_bytes = c"hello";</code> </pre> <br>  Seperti kebanyakan bahasa, Zig mendukung urutan pelarian standar dan menyisipkan karakter Unicode melalui kode mereka (\ uNNNN, \ UNNNNNNN di mana N adalah digit heksadesimal). <br>  Literal multi-garis dibentuk menggunakan dua garis miring terbalik pada awal setiap baris.  Tidak ada tanda kutip diperlukan.  Artinya, beberapa upaya untuk membuat string mentah, tetapi IMHO tidak berhasil - keuntungan dari string mentah adalah Anda dapat menyisipkan bagian teks apa pun dari mana pun dalam kode - dan idealnya tidak mengubah apa pun, tetapi di sini Anda harus menambahkan \\ pada awal setiap baris. <br><br><pre> <code class="plaintext hljs">const multiline = \\#include &lt;stdio.h&gt; \\ \\int main(int argc, char **argv) { \\ printf("hello world\n"); \\ return 0; \\} ;</code> </pre> <br><h3>  Literal integer </h3><br>  Semuanya dalam bahasa si-like.  Saya sangat senang bahwa untuk literal literal, awalan 0o digunakan, dan bukan hanya nol, seperti dalam C.  Literal biner dengan awalan 0b juga didukung.  Literal titik-mengambang dapat berbentuk heksadesimal (seperti yang dilakukan pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ekstensi GCC</a> ). <br><br><h3>  Operasi </h3><br>  Tentu saja, ada operasi aritmatika standar, logis dan bitwise C.  Operasi singkat didukung (+ = dll.).  Alih-alih &amp;&amp; dan ||  kata kunci dan dan atau digunakan.  Hal yang menarik adalah bahwa operasi dengan semantik sampul yang dijamin juga didukung.  Mereka terlihat seperti ini: <br><br><pre> <code class="plaintext hljs">a +% b a +%= b</code> </pre> <br>  Dalam kasus ini, operasi aritmatika biasa tidak menjamin luapan dan hasilnya selama luapan dianggap tidak terdefinisi (dan kesalahan kompilasi dihasilkan untuk konstanta).  IMHO ini agak aneh, tetapi tampaknya itu dibuat dari beberapa pertimbangan kompatibilitas dengan semantik bahasa C. <br><br><h3>  Array </h3><br>  Literal array terlihat seperti ini: <br><br><pre> <code class="plaintext hljs">const msg = []u8{ 'h', 'e', 'l', 'l', 'o' }; const arr = []i32{ 1, 2, 3, 4 };</code> </pre> <br>  String adalah array karakter, seperti dalam C.  Indeksasi klasik dengan tanda kurung.  Operasi penambahan (penggabungan) dan multiplikasi array disediakan.  Ini adalah hal yang sangat menarik, dan jika semuanya jelas dengan penggabungan, maka penggandaan - saya terus menunggu sampai seseorang mengimplementasikan ini, dan sekarang saya menunggu :) Di Assembler (!) Ada operasi dup seperti yang memungkinkan Anda untuk menghasilkan data duplikat.  Sekarang di Zig: <br><br><pre> <code class="plaintext hljs">const one = []i32{ 1, 2, 3, 4 }; const two = []i32{ 5, 6, 7, 8 }; const c = one ++ two; // { 1,2,3,4,5,6,7,8 } const pattern = "ab" ** 3; // "ababab"</code> </pre> <br><h3>  Pointer </h3><br>  Sintaksnya mirip dengan C. <br><br><pre> <code class="plaintext hljs">var x: i32 = 1234; //  const x_ptr = &amp;x; //  </code> </pre> <br>  Untuk dereferencing (mengambil nilai dengan pointer), operasi postfix yang tidak biasa digunakan: <br><br><pre> <code class="plaintext hljs">x_ptr.* == 5678; x_ptr.* += 1;</code> </pre> <br>  Tipe pointer secara eksplisit diatur dengan menetapkan tanda bintang di depan nama tipe <br><br><pre> <code class="plaintext hljs">const x_ptr : *i32 = &amp;x;</code> </pre> <br><h3>  Irisan (irisan) </h3><br>  Struktur data yang dibangun ke dalam bahasa yang memungkinkan Anda untuk referensi array atau bagian dari itu.  Berisi pointer ke elemen pertama dan jumlah elemen.  Ini terlihat seperti ini: <br><br><pre> <code class="plaintext hljs">var array = []i32{ 1, 2, 3, 4 }; const slice = array[0..array.len];</code> </pre> <br>  Tampaknya diambil dari Go, tidak yakin.  Dan saya juga tidak yakin apakah itu layak disematkan dalam bahasa, sementara implementasi dalam bahasa OOP seperti itu sangat mendasar. <br><br><h3>  Struktur </h3><br>  Cara yang menarik untuk mendeklarasikan struktur: konstanta dideklarasikan, tipe yang secara otomatis ditampilkan sebagai "tipe" (tipe), dan itu yang digunakan sebagai nama struktur.  Dan struktur itu sendiri (struct) adalah "tanpa nama." <br><br><pre> <code class="plaintext hljs">const Point = struct { x: f32, y: f32, };</code> </pre> <br>  Tidak mungkin untuk menentukan nama dengan cara yang biasa dalam bahasa seperti C, namun, kompilator menampilkan nama tipe sesuai dengan aturan tertentu - khususnya, dalam kasus yang dipertimbangkan di atas, itu akan bertepatan dengan nama konstanta "type". <br><br>  Secara umum, bahasa tidak menjamin urutan bidang dan perataannya dalam memori.  Jika jaminan diperlukan, maka struktur "paket" harus digunakan. <br><br><pre> <code class="plaintext hljs">const Point2 = packed struct { x: f32, y: f32, };</code> </pre> <br>  Inisialisasi - dengan gaya desainer Sishny: <br><br><pre> <code class="plaintext hljs">const p = Point { .x = 0.12, .y = 0.34, };</code> </pre> <br>  Struktur mungkin memiliki metode.  Namun, menempatkan metode dalam struktur hanya menggunakan struktur sebagai namespace;  tidak seperti C ++, tidak ada implisit parameter ini dilewatkan. <br><br><h3>  Transfer </h3><br>  Secara umum, sama seperti di C / C ++.  Ada beberapa cara built-in yang nyaman untuk mengakses meta-informasi, misalnya, jumlah bidang dan namanya, diimplementasikan oleh makro sintaks yang dibangun ke dalam bahasa (yang disebut fungsi builtin dalam dokumentasi). <br><br>  Untuk "kompatibilitas biner dengan C" beberapa enum eksternal disediakan. <br><br>  Untuk menunjukkan jenis yang harus mendasari pencacahan, konstruksi bentuk <br><br><pre> <code class="plaintext hljs">packed enum(u8)</code> </pre> <br>  di mana u8 adalah tipe dasar. <br>  Enum dapat memiliki metode yang mirip dengan struktur (yaitu menggunakan nama enumerasi sebagai namespace). <br><br><h3>  Serikat pekerja </h3><br>  Seperti yang saya pahami, penyatuan dalam Zig adalah tipe-aljabar, yaitu  berisi bidang tag tersembunyi yang menentukan bidang serikat mana yang "aktif".  "Aktivasi" dari bidang lain dilakukan dengan penugasan ulang keseluruhan dari seluruh asosiasi.  Contoh dokumentasi <br><br><pre> <code class="plaintext hljs">const assert = @import("std").debug.assert; const mem = @import("std").mem; const Payload = union { Int: i64, Float: f64, Bool: bool, }; test "simple union" { var payload = Payload {.Int = 1234}; // payload.Float = 12.34; // !    assert(payload.Int == 1234); //       payload = Payload {.Float = 12.34}; assert(payload.Float == 12.34); }</code> </pre> <br>  Serikat pekerja juga dapat secara eksplisit menggunakan enumerasi untuk tag. <br><br><pre> <code class="plaintext hljs">// Unions can be given an enum tag type: const ComplexTypeTag = enum { Ok, NotOk }; const ComplexType = union(ComplexTypeTag) { Ok: u8, NotOk: void, };</code> </pre> <br>  Serikat pekerja, seperti enumerasi dan struktur, juga dapat menyediakan ruang nama mereka sendiri untuk metode. <br><br><h3>  Jenis opsional </h3><br>  Zig memiliki dukungan opsional bawaan.  Tanda tanya ditambahkan sebelum nama jenis: <br><br><pre> <code class="plaintext hljs">const normal_int: i32 = 1234; // normal integer const optional_int: ?i32 = 5678; // optional integer</code> </pre> <br>  Menariknya, Zig menerapkan satu hal tentang kemungkinan yang saya duga, tetapi tidak yakin apakah itu benar atau tidak.  Pointer dibuat kompatibel dengan opsi tanpa menambahkan bidang tersembunyi tambahan ("tag"), yang menyimpan tanda validitas nilai;  dan null digunakan sebagai nilai yang tidak valid.  Dengan demikian, tipe referensi yang diwakili dalam Zig oleh pointer bahkan tidak memerlukan memori tambahan untuk "opsional".  Pada saat yang sama, menetapkan nilai nol ke pointer reguler dilarang. <br><br><h3>  Jenis Kesalahan </h3><br>  Mereka mirip dengan tipe opsional, tetapi bukannya tag Boolean ("benar-benar tidak valid"), elemen enumerasi yang sesuai dengan kode kesalahan digunakan.  Sintaksnya mirip dengan opsi, tanda seru ditambahkan alih-alih tanda tanya.  Jadi, tipe-tipe ini dapat digunakan, misalnya, untuk kembali dari fungsi: baik objek-hasil dari operasi yang berhasil dari fungsi dikembalikan, atau kesalahan dengan kode yang sesuai dikembalikan.  Jenis kesalahan adalah bagian penting dari sistem penanganan kesalahan bahasa Zig, untuk lebih jelasnya lihat bagian Penanganan Kesalahan. <br><br><h3>  Ketik batal </h3><br>  Variabel seperti void dan operasi dengan mereka dimungkinkan di Zig <br><br><pre> <code class="plaintext hljs">var x: void = {}; var y: void = {}; x = y;</code> </pre> <br>  tidak ada kode yang dihasilkan untuk operasi tersebut;  tipe ini sangat berguna untuk metaprogramming. <br><br>  Ada juga tipe c_void untuk kompatibilitas C. <br><br><h2>  Kontrol Operator dan Fungsi </h2><br>  Ini termasuk: blok, saklar, sementara, untuk, jika, jika tidak, istirahat, terus  Untuk mengelompokkan kode, tanda kurung keriting standar digunakan.  Hanya blok, seperti dalam C / C ++, digunakan untuk membatasi ruang lingkup variabel.  Blok dapat dianggap sebagai ekspresi.  Tidak ada kebersamaan dalam bahasa tersebut, tetapi ada label yang dapat digunakan dengan pernyataan break dan continue.  Secara default, operator ini bekerja dengan loop, namun, jika sebuah blok memiliki label, maka Anda dapat menggunakannya. <br><br><pre> <code class="plaintext hljs">var y: i32 = 123; const x = blk: { y += 1; break :blk y; //   blk   y };</code> </pre> <br>  Pernyataan sakelar berbeda dari operator dalam hal ia tidak memiliki “kesalahan”, yaitu  hanya satu kondisi (kasing) yang dieksekusi dan sakelar keluar.  Sintaksnya lebih ringkas: alih-alih case, panah "=&gt;" digunakan.  Switch juga dapat dianggap sebagai ekspresi. <br><br>  Pernyataan while dan if pada umumnya sama dengan semua bahasa mirip-C.  Pernyataan for lebih seperti foreach.  Semuanya dapat dianggap sebagai ekspresi.  Dari fitur-fitur baru, sementara dan untuk, serta jika, dapat memiliki blok lain yang dijalankan jika tidak ada iterasi loop. <br><br>  Dan inilah saatnya untuk berbicara tentang satu fitur umum untuk sakelar, sementara, yang dalam beberapa hal dipinjam dari konsep foreach loop - variabel "menangkap".  Ini terlihat seperti ini: <br><br><pre> <code class="plaintext hljs">while (eventuallyNullSequence()) |value| { sum1 += value; } if (opt_arg) |value| { assert(value == 0); } for (items[0..1]) |value| { sum += value; }</code> </pre><br>  Di sini, argumen while adalah "sumber" data tertentu, yang dapat opsional, untuk, array atau irisan, dan variabel yang terletak di antara dua garis vertikal berisi nilai "diperluas" - yaitu,  elemen saat ini dari array atau slice (atau pointer ke sana), nilai internal dari tipe opsional (atau pointer ke sana). <br><br><h3>  Tunda dan sesuaikan pernyataan </h3><br>  Pernyataan eksekusi yang ditangguhkan dipinjam dari Go.  Cara kerjanya sama - argumen operator ini dieksekusi ketika meninggalkan ruang lingkup di mana operator digunakan.  Selain itu, operator errdefer disediakan, yang dipicu jika jenis kesalahan dengan kode kesalahan aktif dikembalikan dari fungsi.  Ini adalah bagian dari sistem penanganan kesalahan Zig asli. <br><br><h3>  Operator yang tidak terjangkau </h3><br>  Unsur pemrograman kontrak.  Kata kunci khusus, yang diletakkan di tempat manajemen tidak boleh datang dalam keadaan apa pun.  Jika tiba di sana, maka dalam mode Debug dan ReleaseSafe, panik dihasilkan, dan dalam ReleaseFast optimizer mengeluarkan cabang-cabang ini sepenuhnya. <br><br><h3>  noreturn </h3><br>  Secara teknis, ini adalah tipe yang kompatibel dalam ekspresi dengan tipe lainnya.  Ini dimungkinkan karena kenyataan bahwa objek jenis ini tidak akan pernah kembali.  Karena operator adalah ekspresi dalam Zig, tipe khusus diperlukan untuk ekspresi yang tidak akan pernah dievaluasi.  Ini terjadi ketika sisi kanan ekspresi secara irrevocably mentransfer kontrol ke suatu tempat di luar.  Untuk pernyataan seperti itu rusak, lanjutkan, kembali, loop yang tak terhingga, dan fungsi yang tak pernah kembali kontrol.  Sebagai perbandingan, panggilan ke fungsi biasa (kontrol kembali) bukan operator noreturn, karena meskipun kontrol ditransfer ke luar, itu akan dikembalikan ke titik panggilan cepat atau lambat. <br><br>  Dengan demikian, ekspresi berikut menjadi mungkin: <br><br><pre> <code class="plaintext hljs">fn foo(condition: bool, b: u32) void { const a = if (condition) b else return; @panic("do something with a"); }</code> </pre> <br>  Variabel a mendapatkan nilai yang dikembalikan oleh pernyataan if / else.  Untuk ini, bagian-bagian (baik jika dan yang lain) harus mengembalikan ekspresi dengan tipe yang sama.  Bagian if mengembalikan bool, bagian lain adalah tipe noreturn, yang secara teknis kompatibel dengan tipe apa pun, sebagai hasilnya, kode dikompilasi tanpa kesalahan. <br><br><h3>  Fungsi </h3><br>  Sintaksnya klasik untuk bahasa jenis ini: <br><br><pre> <code class="plaintext hljs">fn add(a: i8, b: i8) i8 { return a + b; }</code> </pre> <br>  Secara umum, fungsinya terlihat cukup standar.  Sejauh ini saya belum melihat tanda-tanda fungsi kelas satu, tetapi kenalan saya dengan bahasa ini sangat dangkal, saya bisa saja salah.  Meskipun mungkin ini belum dilakukan. <br><br>  Fitur lain yang menarik adalah bahwa di Zig, mengabaikan nilai yang dikembalikan hanya dapat dilakukan secara eksplisit menggunakan garis bawah _ <br><br><pre> <code class="plaintext hljs"> _ = foo();</code> </pre> <br>  Ada refleksi yang memungkinkan Anda mendapatkan berbagai informasi tentang fungsi tersebut <br><br><pre> <code class="plaintext hljs">const assert = @import("std").debug.assert; test "fn reflection" { assert(@typeOf(assert).ReturnType == void); //    assert(@typeOf(assert).is_var_args == false); //    }</code> </pre> <br><h2>  Eksekusi kode pada waktu kompilasi </h2><br>  Zig menyediakan fitur yang kuat - mengeksekusi kode yang ditulis dalam zig pada waktu kompilasi.  Agar kode dapat dieksekusi pada waktu kompilasi, cukup bungkus dalam blok dengan kata kunci comptime.  Fungsi yang sama dapat dipanggil baik pada waktu kompilasi maupun pada saat run, yang memungkinkan Anda untuk menulis kode universal.  Tentu saja, ada beberapa batasan terkait dengan konteks kode yang berbeda.  Misalnya, dalam dokumentasi dalam banyak contoh, waktu kompilasi digunakan untuk memeriksa waktu kompilasi: <br><br><pre> <code class="plaintext hljs">// array literal const message = []u8{ 'h', 'e', 'l', 'l', 'o' }; // get the size of an array comptime { assert(message.len == 5); }</code> </pre> <br>  Tapi tentu saja kekuatan operator ini jauh dari diungkapkan sepenuhnya di sini.  Jadi, dalam deskripsi bahasa, contoh klasik dari penggunaan efektif sintaksis makro diberikan - implementasi fungsi yang mirip dengan printf, tetapi mem-parsing format string dan melakukan semua pengecekan tipe argumen yang diperlukan pada tahap kompilasi. <br><br>  Juga, kata waktu kompilasi digunakan untuk menunjukkan parameter fungsi waktu kompilasi, yang mirip dengan fungsi templat C ++. <br><br><pre> <code class="plaintext hljs">   fn max(comptime T: type, a: T, b: T) T { return if (a &gt; b) a else b; }</code> </pre> <br><h2>  Menangani kesalahan </h2><br>  Zig menemukan sistem penanganan kesalahan asli yang tidak seperti bahasa lain.  Ini bisa disebut "pengecualian eksplisit" (dalam bahasa ini, explicitness umumnya adalah salah satu idiom).  Ini juga terlihat seperti kode pengembalian Go, tetapi kerjanya berbeda. <br><br>  Sistem pemrosesan kesalahan Zig didasarkan pada penghitungan khusus untuk mengimplementasikan kode kesalahan khusus (kesalahan) dan dibangun berdasarkan “tipe kesalahan” (jumlah-jenis aljabar, menggabungkan tipe fungsi yang dikembalikan dan kode kesalahan). <br><br>  Penghitungan kesalahan dideklarasikan dengan cara yang sama seperti penghitungan biasa: <br><br><pre> <code class="plaintext hljs">const FileOpenError = error { AccessDenied, OutOfMemory, FileNotFound, }; const AllocationError = error { OutOfMemory, };</code> </pre> <br>  Namun, semua kode kesalahan menerima nilai lebih besar dari nol;  juga, jika Anda mendeklarasikan kode dengan nama yang sama dalam dua enumerasi, ia akan menerima nilai yang sama.  Namun, konversi implisit antara enumerasi kesalahan yang berbeda dilarang. <br><br>  Kata kunci anyerror berarti enumerasi yang mencakup semua kode kesalahan. <br><br>  Seperti jenis opsional, bahasa mendukung pembuatan jenis kesalahan menggunakan sintaksis khusus.  Tipe! U64 adalah bentuk disingkat dari anyerror! U64, yang pada gilirannya berarti penyatuan (opsi), yang meliputi tipe u64 dan ketik anyerror (seperti yang saya pahami, kode 0 dicadangkan untuk menunjukkan tidak adanya kesalahan dan validitas bidang data, sisa kode adalah sebenarnya kode kesalahan). <br><br>  Kata kunci tangkapan memungkinkan Anda menangkap kesalahan dan mengubahnya menjadi nilai default: <br><br><pre> <code class="plaintext hljs">const number = parseU64(str, 10) catch 13;</code> </pre> <br>  Jadi, jika kesalahan terjadi pada fungsi parseU64 mengembalikan tipe! U64, maka catch akan "mencegat" dan mengembalikan nilai default 13. <br><br>  Kata kunci percobaan memungkinkan Anda untuk "meneruskan" kesalahan ke tingkat atas (yaitu, ke tingkat fungsi panggilan).  Lihat kode <br><br><pre> <code class="plaintext hljs">fn doAThing(str: []u8) !void { const number = try parseU64(str, 10); // ... }</code> </pre> <br>  setara dengan ini: <br><br><pre> <code class="plaintext hljs">fn doAThing(str: []u8) !void { const number = parseU64(str, 10) catch |err| return err; // ... }</code> </pre> <br>  Berikut ini terjadi: parseU64 dipanggil, jika kesalahan dikembalikan dari itu - dicegat oleh pernyataan tangkapan, di mana kode kesalahan diekstraksi menggunakan sintaks "capture", ditempatkan dalam variabel err, yang dikembalikan via! Batal ke fungsi pemanggilan. <br><br>  Operator Errdefer yang dijelaskan sebelumnya juga mengacu pada penanganan kesalahan.  Kode argumen errdefer dijalankan hanya jika fungsi mengembalikan kesalahan. <br><br>  Beberapa kemungkinan lainnya.  Menggunakan ||  Anda dapat menggabungkan set kesalahan <br><br><pre> <code class="plaintext hljs">const A = error{ NotDir, PathNotFound, }; const B = error{ OutOfMemory, PathNotFound, }; const C = A || B;</code> </pre> <br>  Zig juga menyediakan fitur seperti penelusuran kesalahan.  Ini adalah sesuatu yang mirip dengan jejak tumpukan, tetapi berisi informasi terperinci tentang kesalahan apa yang terjadi dan bagaimana ia menyebar di sepanjang rantai coba dari tempat kejadian ke fungsi utama program. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dengan demikian, sistem penanganan kesalahan di Zig adalah solusi yang sangat asli, yang tidak terlihat seperti pengecualian di C ++ atau kode pengembalian di Go. </font><font style="vertical-align: inherit;">Kita dapat mengatakan bahwa solusi semacam itu memiliki harga tertentu - tambahan 4 byte, yang harus dikembalikan bersama dengan setiap nilai yang dikembalikan; </font><font style="vertical-align: inherit;">keuntungan yang jelas adalah visibilitas absolut dan transparansi. </font><font style="vertical-align: inherit;">Tidak seperti C ++, di sini fungsinya tidak dapat membuang pengecualian yang tidak diketahui dari suatu tempat di kedalaman rantai panggilan. </font><font style="vertical-align: inherit;">Semua fungsi yang dikembalikan - ia mengembalikan secara eksplisit dan hanya secara eksplisit.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Coroutine </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zig memiliki coroutine bawaan. </font><font style="vertical-align: inherit;">Ini adalah fungsi yang dibuat dengan kata kunci async, dengan bantuan fungsi pengalokasi dan deallocator ditransfer (seperti yang saya pahami, untuk tumpukan tambahan).</font></font><br><br><pre> <code class="plaintext hljs">test "create a coroutine and cancel it" { const p = try async&lt;std.debug.global_allocator&gt; simpleAsyncFn(); comptime assert(@typeOf(p) == promise-&gt;void); cancel p; assert(x == 2); } async&lt;*std.mem.Allocator&gt; fn simpleAsyncFn() void { x += 1; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">async mengembalikan objek khusus bertipe janji-&gt; T (di mana T adalah tipe pengembalian fungsi). Dengan menggunakan objek ini, Anda dapat mengontrol coroutine. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Level terendah termasuk kata kunci yang ditangguhkan, dilanjutkan, dan dibatalkan. Menggunakan penangguhan, eksekusi coroutine dihentikan sementara dan diteruskan ke program panggilan. Sintaks dari blok suspend dimungkinkan, semua yang ada di dalam blok dieksekusi sampai coroutine benar-benar ditangguhkan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">resume mengambil argumen tipe janji-&gt; T dan melanjutkan mengeksekusi coroutine dari tempat itu ditangguhkan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">membatalkan membebaskan memori coroutine. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gambar ini menunjukkan transfer kontrol antara program utama (dalam bentuk tes) dan coroutine. Semuanya cukup sederhana:</font></font><br><br><img src="https://habrastorage.org/webt/yi/em/dv/yiemdv3ujvm-rodjnohawjtld68.png" alt="gambar"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fitur kedua (level yang lebih tinggi) adalah penggunaan menunggu. </font><font style="vertical-align: inherit;">Ini adalah satu-satunya hal yang, terus terang, saya tidak mengerti (sayangnya, dokumentasi masih sangat langka). </font><font style="vertical-align: inherit;">Berikut adalah diagram transfer kontrol aktual dari contoh yang sedikit dimodifikasi dari dokumentasi, mungkin ini akan menjelaskan sesuatu kepada Anda:</font></font><br><br><img src="https://habrastorage.org/webt/yo/gu/uq/yoguuqayvhwyxtrhcni-rjn-w7g.png" alt="gambar"><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fungsi bawaan </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fungsi bawaan - seperangkat fungsi yang cukup besar yang dibangun ke dalam bahasa dan tidak memerlukan koneksi modul apa pun. Mungkin lebih tepat untuk menyebut beberapa dari mereka "makro sintaksis bawaan", karena kemampuan banyak yang jauh melampaui fungsi. builtin menyediakan akses ke alat refleksi (sizeOf, tagName, TagType, typeInfo, typeName, typeOf), dengan modul bantuannya (impor) terhubung. Lainnya lebih seperti C / C ++ built-in klasik - mereka menerapkan konversi tipe tingkat rendah, berbagai operasi seperti sqrt, popCount, slhExact, dll. Sangat mungkin bahwa daftar fungsi-fungsi bawaan akan berubah ketika bahasa berkembang.</font></font><br><br><h3>  Kesimpulannya </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sangat menyenangkan bahwa proyek seperti itu muncul dan berkembang. </font><font style="vertical-align: inherit;">Meskipun bahasa C nyaman, ringkas dan akrab bagi banyak orang, itu masih ketinggalan zaman dan karena alasan arsitektur tidak dapat mendukung banyak konsep pemrograman modern. </font><font style="vertical-align: inherit;">C ++ sedang berkembang, tetapi dirancang ulang secara obyektif, menjadi semakin sulit dengan setiap versi baru, dan untuk alasan arsitektur yang sama dan karena kebutuhan untuk kompatibilitas ke belakang, tidak ada yang dapat dilakukan tentang hal itu. </font><font style="vertical-align: inherit;">Karat memang menarik, tetapi dengan ambang masuk yang sangat tinggi, yang tidak selalu bisa dibenarkan. </font><font style="vertical-align: inherit;">D adalah upaya yang baik, tetapi ada beberapa kelemahan kecil, tampaknya bahasa awalnya dibuat lebih mungkin di bawah pengaruh Jawa, dan fitur-fitur berikutnya entah bagaimana entah bagaimana diperkenalkan sebagaimana mestinya. </font><font style="vertical-align: inherit;">Jelas, Zig adalah upaya lain. </font><font style="vertical-align: inherit;">Bahasanya menarik, dan menarik untuk melihat apa yang keluar dari situ.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id435872/">https://habr.com/ru/post/id435872/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id435862/index.html">Hall of Fame Elektronik Konsumen: Kisah Gadget Terbaik 50 Tahun Terakhir, Bagian 4</a></li>
<li><a href="../id435864/index.html">Memetakan permintaan untuk Netty</a></li>
<li><a href="../id435866/index.html">Rilis IT: platform baru untuk meluncurkan produk dan layanan sebagai bagian dari festival SXSW 2019</a></li>
<li><a href="../id435868/index.html">Slush 2018. Hari Pratinjau</a></li>
<li><a href="../id435870/index.html">Orkestra Cybernetic. Docker Container Orchestration dengan .NET Core Applications in the Cloud</a></li>
<li><a href="../id435876/index.html">Pengaturan Firefox Browser Terperinci</a></li>
<li><a href="../id435878/index.html">Amatir di opensource - pelajaran yang didapat dalam 3 tahun</a></li>
<li><a href="../id435880/index.html">Mengubah skema tabel PostgreSQL tanpa kunci panjang. Kuliah Yandex</a></li>
<li><a href="../id435882/index.html">Ulasan Xiaomi Mi Box S dan perbandingan kecil dengan Mi Box 3</a></li>
<li><a href="../id435884/index.html">Pencarian logam dan ... jaringan saraf</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>