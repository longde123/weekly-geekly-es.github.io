<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔉 🛌🏼 🕴️ PostgreSQL-1中的MVCC。 隔离度 🛳️ 😟 💋</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="哈Ha！ 在本文中，我开始了有关PostgreSQL内部结构的一系列系列（或一系列系列？总之，这个想法太夸张了）。 

 该材料将基于Pavel pluzanov和我正在创建的管理培训课程 （俄语）。 并非每个人都喜欢看视频（我绝对不喜欢），并且即使有评论也无法阅读幻灯片。 

 不幸的是，目前唯一...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>PostgreSQL-1中的MVCC。 隔离度</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/467437/"> 哈Ha！ 在本文中，我开始了有关PostgreSQL内部结构的一系列系列（或一系列系列？总之，这个想法太夸张了）。 <br><br> 该材料将基于Pavel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">pluzanov</a>和我正在创建的管理<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">培训课程</a> （俄语）。 并非每个人都喜欢看视频（我绝对不喜欢），并且即使有评论也无法阅读幻灯片。 <br><br><blockquote> 不幸的是，目前唯一可用的英语课程是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PostgreSQL 11 2天简介</a> 。 <br></blockquote><br> 当然，文章与课程内容将不会完全相同。 我将只谈论一切的组织方式，省略了政府本身，但是我将尝试更详细，更彻底地做到这一点。 而且我相信这样的知识对应用程序开发人员和管理员一样有用。 <br><br> 我将针对那些已经具有使用PostgreSQL经验并且至少总体上了解什么的人。 对于初学者来说，文字太难了。 例如，我不会对如何安装PostgreSQL和运行psql一言不发。 <br><br> 各个版本之间的问题并没有太大的区别，但是我将使用当前的第11个原始PostgreSQL。 <br><br> 第一个系列处理与隔离和多版本并发相关的问题，该系列的计划如下： <br><br><ol><li> 标准和PostgreSQL理解的隔离（本文）。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">叉子，文件，页面</a> -在物理级别发生了什么。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">行版本</a> ，虚拟事务和子事务。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">数据快照</a>和行版本的可见性； 事件范围。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">页内真空和HOT更新</a> 。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">正常真空</a> 。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">自动抽真空</a> 。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">交易ID环绕和冻结</a> 。 </li></ol><br> 出发吧！ <br><br><blockquote> 在开始之前，我要感谢Elena Indrupskaya将文章翻译成英文。 <br></blockquote><br><a name="habracut"></a><br><h1> 什么是隔离，为何如此重要？ </h1><br> 可能每个人至少都知道事务的存在，遇到过缩写ACID，并且听说过隔离级别。 但是我们仍然碰巧认为这与理论有关，在实践中没有必要。 因此，我将花一些时间来解释为什么这确实很重要。 <br><br> 如果应用程序从数据库中获取了不正确的数据，或者应用程序将错误的数据写入了数据库，则您不太可能感到高兴。 <br><br> 但是什么是“正确”数据？ 众所周知，可以在数据库级别创建<em>完整性约束</em> ，例如NOT NULL或UNIQUE。 如果数据始终满足完整性约束（之所以如此，因为DBMS保证了），则它们是不可或缺的。 <br><br>  <em>正确</em>且<em>不可分割</em>的同一件事吗？ 不完全是 并非所有约束都可以在数据库级别上指定。 一些约束过于复杂，例如，一次覆盖多个表。 即使通常可以在数据库中定义约束，但由于某种原因，它也没有定义，但这并不意味着可以违反该约束。 <br><br> 因此， <em>正确性</em>比<em>完整性</em>要强，但是我们并不确切知道这意味着什么。 我们只不过承认正确性的“黄金标准”是一种应用程序，正如我们希望的那样，它是<em>正确</em>编写的，绝不会出错。 在任何情况下，如果应用程序没有违反完整性，而是违反了正确性，则DBMS不会知道它，也不会“红手”捕获该应用程序。 <br><br> 此外，我们将使用术语<em>一致性</em>来指代正确性。 <br><br> 但是，让我们假设应用程序仅执行正确的运算符序列。 如果应用程序正确无误，DBMS的作用是什么？ <br><br> 首先，事实证明，正确的运算符序列可以暂时破坏数据一致性，这很正常，这很奇怪。 一个朴实却清晰的例子是将资金从一个帐户转移到另一个帐户。 一致性规则听起来可能像这样： <em>转账永远不会更改帐户上的总金额</em> （此规则在SQL中很难指定为完整性约束，因此它存在于应用程序级别，并且对DBMS不可见）。 转帐包括两个操作：第一个操作减少一个帐户上的资金，第二个操作-增加另一个帐户上的资金。 第一个操作破坏数据一致性，而第二个操作恢复数据一致性。 <br><br><blockquote> 一个好的练习是在完整性约束级别上实施上述规则。 <br></blockquote><br> 如果执行第一个操作而第二个不执行怎么办？ 实际上，事不宜迟：在第二次操作期间，可能会发生电力故障，服务器崩溃，被零除的情况-无论如何。 很明显，一致性将被破坏，并且这是不允许的。 通常，可以在应用程序级别解决此类问题，但需要付出大量努力； 但是，幸运的是，这不是必需的：这是由DBMS完成的。 但是，为此，DBMS必须知道这两个操作是不可分割的整体。 也就是说， <em>交易</em> 。 <br><br> 事实证明，这很有趣：因为DBMS知道操作构成了一个事务，所以它通过确保事务是原子的来帮助保持一致性，而这样做却不了解特定的一致性规则。 <br><br> 但是还有第二点，更微妙的一点。 一旦几个同时发生的事务（分别绝对正确）出现在系统中，它们可能无法正常协同工作。 这是因为操作顺序混合了：您不能假定一个事务的所有操作都先执行，然后又执行另一个事务的所有操作。 <br><br> 关于同时性的说明。 实际上，事务可以在具有多核处理器，磁盘阵列等的系统上同时运行。 但是，在分时共享模式下，按顺序执行命令的服务器也具有相同的推理：在某些时钟周期内，一个事务被执行，而在接下来的某些周期内，另一个事务被执行。 有时，术语“ <em>并发</em>执行”用于概括。 <br><br> 正确的事务无法正常工作的情况称为并发执行<em>异常</em> 。 <br><br> 举一个简单的例子：如果一个应用程序想要从数据库中获取正确的数据，它至少不能看到其他未提交事务的变化。 否则，您不仅可以获取不一致的数据，还可以查看数据库中从未存在过的内容（如果取消了事务）。 这种异常称为<em>脏读</em> 。 <br><br> 还有其他更复杂的异常，我们将在稍后处理。 <br><br> 当然，避免并发执行是不可能的：否则，我们可以谈谈什么样的性能？ 但是您不能使用不正确的数据。 <br><br>  DBMS再次解救。 您可以使事务<em>像</em>顺序执行<em>一样</em> ， <em>好像</em>一个接一个地执行。 换句话说-彼此<em>隔离</em> 。 实际上，DBMS可以混合执行各种操作，但要确保并发执行的结果与某些可能的顺序执行的结果相同。 这样可以消除任何可能的异常情况。 <br><br> 因此，我们得出了以下定义： <br><br><blockquote> 事务是由应用程序执行的一组操作，这些操作将数据库从一个正确的状态转移到另一个正确的状态（一致性），前提是事务已完成（原子性）并且不受其他事务的干扰（隔离）。 <br></blockquote><br> 此定义将首字母缩写ACID的前三个字母组合在一起。 它们之间的关系如此密切，以至于没有一个人就没有一个考虑是没有意义的。 实际上，也难以分离字母D（耐久性）。 确实，当系统崩溃时，它仍具有未提交事务的更改，您需要使用这些操作来恢复数据一致性。 <br><br> 一切都会好起来的，但是实现完全隔离是一项技术难题，需要降低系统吞吐量。 因此，实际上，经常（不是总是，但几乎总是）使用弱隔离，这可以防止某些但不是全部异常。 这意味着确保数据正确性的一部分工作落在应用程序上。 因此，了解系统中使用的隔离级别，提供哪些保证，不提供什么以及在这种情况下如何编写正确的代码非常重要。 <br><br><h1>  SQL标准中的隔离级别和异常 </h1><br>  SQL标准很早就描述了四个隔离级别。 通过列出在该级别同时执行事务时允许或不允许的异常来定义这些级别。 因此，要谈论这些级别，有必要了解异常。 <br><br> 我强调，在这一部分中，我们谈论的是标准，即关于一种理论的理论，该实践基于显着的基础，但是与此同时，实践却明显不同。 因此，这里的所有示例都是推测性的。 他们将在客户帐户上使用相同的操作：这是相当有示范性的，尽管诚然，这与现实中银行操作的组织方式无关。 <br><br><h2> 损失更新 </h2><br> 让我们从<em>丢失更新</em>开始。 当两个事务读取表的同一行，然后一个事务更新该行，然后第二个事务也更新同一行而不考虑第一个事务所做的更改时，就会发生此异常。 <br><br> 例如，两次交易将使同一帐户上的金额增加100英镑（₽是俄罗斯卢布的货币符号）。 第一个事务读取当前值（₽1000），然后第二个事务读取相同的值。 第一笔交易增加金额（这等于1100英镑），并写入该值。 第二笔交易的行为方式相同：它获得₽1100并写入此值。 结果，客户损失了100英镑。 <br><br> 该标准不允许在任何隔离级别丢失更新。 <br><br><h2> 脏读和未提交读 </h2><br>  <em>脏读</em>是我们已经熟悉的内容。 当一个事务读取另一个事务尚未提交的更改时，就会发生此异常。 <br><br> 例如，第一笔交易将所有资金从客户的帐户转移到另一个帐户，但不提交更改。 另一笔交易读取了帐户余额，得到₽0，并拒绝向客户提取现金，尽管第一笔交易中止并还原了其更改，因此数据库中从未存在0的值。 <br><br> 该标准允许在“读未提交”级别进行脏读。 <br><br><h2> 不可重复读取和已提交读取 </h2><br> 当事务两次读取同一行，并且在两次读取之间，第二个事务修改（或删除）该行并提交更改时，将发生<em>不可重复的读取</em>异常。 然后，第一笔交易将获得不同的结果。 <br><br> 例如，让一致性规则<em>禁止客户帐户上出现负数</em> 。 第一笔交易将使帐户中的金额减少100英镑。 它检查当前值，得到₽1000，并确定有可能减小。 同时，第二笔交易将帐户上的金额减少为零并提交更改。 如果第一笔交易现在重新检查了金额，则将获得₽0（但已决定减少该金额，并且帐户“变成红色”）。 <br><br> 该标准允许不可重复的读取处于“读取未提交”和“读取已提交”级别。 但是Read Committed不允许脏读。 <br><br><h2> 幻像读取和可重复读取 </h2><br> 当事务两次按相同条件读取一组行时，就会发生<em>幻像读取</em> ，并且在两次读取之间，第二个事务会添加满足该条件的行（并提交更改）。 然后，第一个事务将获得不同的行集。 <br><br> 例如，让一致性规则<em>阻止客户拥有三个以上的帐户</em> 。 第一笔交易将开设一个新帐户，检查当前帐户数（例如2），并确定可以开设。 同时，第二笔交易还将为客户开设一个新帐户并提交更改。 现在，如果第一笔交易重新检查了该数字，它将得到3（但它已经在开设另一个帐户，并且客户似乎拥有4个）。 <br><br> 该标准允许幻像读取处于“未提交读取”，“已提交读取”和“可重复读取”级别。 但是，在“可重复读取”级别上不允许进行不可重复读取。 <br><br><h2> 没有异常和可序列化 </h2><br> 该标准定义了另一个级别-Serializable-不允许任何异常。 这与禁止丢失更新以及脏的，不可重复的或幻像的读取不同。 <br><br> 事实是，已知异常比标准中列出的要多得多，并且未知数量也未知。 <br><br> 可序列化级别必须<em>绝对</em>防止<em>所有</em>异常。 这意味着在此级别上，应用程序开发人员无需考虑并发执行。 如果事务执行正确的操作符序列（分别工作），则同时执行这些事务时，数据也将保持一致。 <br><br><h2> 汇总表 </h2><br> 现在我们可以提供一个众所周知的表。 但是为了清楚起见，此处添加了标准中缺少的最后一列。 <br><div class="scrollable-table"><table><tbody><tr><th></th><th> 遗失的变更 </th><th> 脏读 </th><th> 不可重复读 </th><th> 幻影阅读 </th><th> 其他异常 </th></tr><tr><th> 读未提交 </th><th>  -- </th><th> 是的 </th><th> 是的 </th><th> 是的 </th><th> 是的 </th></tr><tr><th> 阅读已提交 </th><th>  -- </th><th>  -- </th><th> 是的 </th><th> 是的 </th><th> 是的 </th></tr><tr><th> 可重复读 </th><th>  -- </th><th>  -- </th><th>  -- </th><th> 是的 </th><th> 是的 </th></tr><tr><th> 可序列化 </th><th>  -- </th><th>  -- </th><th>  -- </th><th>  -- </th><th>  -- </th></tr></tbody></table></div><br><h2> 为什么正是这些异常？ </h2><br> 为什么标准仅列出许多可能的异常中的几个，为什么它们正是这些异常？ <br><br> 似乎没有人知道这一点。 但是这里的做法显然比理论要先进，因此有可能当时（SQL：92标准）还没有想到其他异常。 <br><br> 另外，假定隔离必须建立在锁上。 广泛使用的<em>两阶段锁定协议</em> （2PL）背后的思想是，在执行过程中，事务将锁定正在使用的行，并在完成时释放锁定。 相当简化，一个事务获取的锁越多，它与其他事务的隔离性就越好。 但是系统的性能也会受到更大的影响，因为交易不是一起工作，而是开始排队等待相同的行。 <br><br> 我的感觉是，这只是所需的锁数，这说明了标准的隔离级别之间的差异。 <br><br> 如果事务锁定了要修改的行，使其不能进行更新，而不能进行读取，则将获得“读取未提交”级别：不允许丢失丢失的更改，但是可以读取未提交的数据。 <br><br> 如果事务锁定了要读取和更新的行，则将获得“读取已提交”级别：您无法读取未提交的数据，但是当您再次访问该行时，您可以获得一个不同的值（不可重复读取）。 <br><br> 如果事务锁定了要读取和修改的行以及读取和更新的行，我们将获得“可重复读取”级别：重新读取该行将返回相同的值。 <br><br> 但是Serializable有一个问题：您不能锁定不存在的行。 因此，幻象读取仍然是可能的：另一个事务可以添加（但不能删除）满足先前执行的查询条件的行，并且该行将包含在重新选择中。 <br><br> 因此，要实现Serializable级，普通的锁是不够的-您需要锁定条件（谓词）而不是行。 因此，这种锁称为<em>谓词</em> 。 它们是在1976年提出的，但是它们的实际适用性受到相当简单的条件的限制，对于这些条件，很明显如何将两个不同的谓词结合在一起。 据我所知，到目前为止，此类锁从未在任何系统中实现。 <br><br><h1>  PostgreSQL中的隔离级别 </h1><br> 随着时间的流逝，基于锁定的事务管理协议已被快照隔离协议（SI）取代。 其想法是，每个事务在某个时间点都使用数据的一致快照，并且只有那些更改会在创建快照之前提交到快照中。 <br><br> 这种隔离会自动防止脏读。 正式地，您可以在PostgreSQL中指定Read Uncommitted级别，但是它的工作方式与Read Committed完全相同。 因此，进一步，我们将不再谈论“读取未提交”级别。 <br><br>  PostgreSQL实现了该协议的<em>多版本</em>变体。 多版本并发的想法是，同一行的多个版本可以在DBMS中共存。 这使您可以使用现有版本构建数据快照，并使用最少的锁。 实际上，只有对同一行的后续更改才被锁定。 所有其他操作是同时执行的：写事务永远不会锁定只读事务，而只读事务永远不会锁定任何事物。 <br><br> 通过使用数据快照，PostgreSQL中的隔离比标准要求的严格：“可重复读取”级别不仅不允许不可重复的读取，还不允许幻像读取（尽管它不提供完全隔离）。 并且这在不损失效率的情况下实现。 <br><div class="scrollable-table"><table><tbody><tr><th></th><th> 遗失的变更 </th><th> 脏读 </th><th> 不可重复读 </th><th> 幻影阅读 </th><th> 其他异常 </th></tr><tr><th> 读未提交 </th><th>  -- </th><th>  -- </th><th> 是的 </th><th> 是的 </th><th> 是的 </th></tr><tr><th> 阅读已提交 </th><th>  -- </th><th>  -- </th><th> 是的 </th><th> 是的 </th><th> 是的 </th></tr><tr><th> 可重复读 </th><th>  -- </th><th>  -- </th><th>  -- </th><th>  -- </th><th> 是的 </th></tr><tr><th> 可序列化 </th><th>  -- </th><th>  -- </th><th>  -- </th><th>  -- </th><th>  -- </th></tr></tbody></table></div><br> 在下一篇文章中，我们将讨论如何在后台“实现”多版本并发，现在，我们将以用户的眼光详细地研究这三个级别中的每个级别（如您所知，最有趣的是隐藏在“其他异常背后”）。 ”）。 为此，我们创建一个帐户表。 爱丽丝和鲍勃各有1000英镑，但鲍勃有两个已开设的帐户： <br><br><pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> accounts( id <span class="hljs-type"><span class="hljs-type">integer</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PRIMARY KEY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GENERATED</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DEFAULT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IDENTITY</span></span>, number <span class="hljs-type"><span class="hljs-type">text</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UNIQUE</span></span>, client <span class="hljs-type"><span class="hljs-type">text</span></span>, amount <span class="hljs-type"><span class="hljs-type">numeric</span></span> ); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'1001'</span></span>, <span class="hljs-string"><span class="hljs-string">'alice'</span></span>, <span class="hljs-number"><span class="hljs-number">1000.00</span></span>), (<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'2001'</span></span>, <span class="hljs-string"><span class="hljs-string">'bob'</span></span>, <span class="hljs-number"><span class="hljs-number">100.00</span></span>), (<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">'2002'</span></span>, <span class="hljs-string"><span class="hljs-string">'bob'</span></span>, <span class="hljs-number"><span class="hljs-number">900.00</span></span>);</code> </pre> <br><h2> 阅读已提交 </h2><br><h3> 没有脏读 </h3><br> 很容易确保无法读取脏数据。 我们开始交易。 默认情况下，它将使用Read Committed隔离级别： <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SHOW</span></span> transaction_isolation;</code> </pre><pre> <code class="plaintext hljs"> transaction_isolation ----------------------- read committed (1 row)</code> </pre><br> 更准确地说，默认级别由参数设置，如有必要，可以更改： <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SHOW</span></span> default_transaction_isolation;</code> </pre><pre> <code class="plaintext hljs"> default_transaction_isolation ------------------------------- read committed (1 row)</code> </pre><br> 因此，在未结交易中，我们从帐户中提取资金，但不提交更改。 交易会看到自己的变化： <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">200</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'alice'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+-------- 1 | 1001 | alice | 800.00 (1 row)</code> </pre><br> 在第二个会话中，我们将启动另一个具有相同“读取已提交”级别的事务。 为了区分事务，第二个事务的命令将缩进并用条形标记。 <br><br> 为了重复上述命令（这很有用），您需要打开两个终端并在每个终端中运行psql。 在第一个终端中，您可以输入一个事务的命令，而在第二个终端中，可以输入另一个事务的命令。 <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'alice'</span></span>;</code> </pre><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+--------- | 1 | 1001 | alice | 1000.00 | (1 row)</code> </pre><br> 如预期的那样，另一个事务不会看到未提交的更改，因为不允许脏读。 <br><br><h3> 不可重复读 </h3><br> 现在，让第一个事务提交更改，第二个事务重新执行相同的查询。 <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'alice'</span></span>;</code> </pre><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+-------- | 1 | 1001 | alice | 800.00 | (1 row)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br> 该查询已经获取了新数据-这是<em>不可重复的读取</em>异常，在“读取已提交”级别允许。 <br><br>  <em>实际结论</em> ：在事务中，您不能基于前一个操作员读取的数据来做出决策，因为在执行这些操作员之间可能会发生变化。 这是一个示例，其变化在应用程序代码中经常发生，因此被认为是经典的反模式： <br><br><pre> <code class="pgsql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> amount <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>) &gt;= <span class="hljs-number"><span class="hljs-number">1000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">1000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span>;</code> </pre><br> 在检查和更新之间的这段时间内，其他交易可以以任何方式更改帐户的状态，因此这种“检查”可以确保一切。 可以方便地想象一个交易的操作者之间的其他任何交易的其他操作者可以“楔入”，例如，如下所示： <br><br><pre> <code class="pgsql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> amount <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>) &gt;= <span class="hljs-number"><span class="hljs-number">1000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-comment"><span class="hljs-comment">----- | UPDATE accounts SET amount = amount - 200 WHERE id = 1; | COMMIT; ----- UPDATE accounts SET amount = amount - 1000 WHERE id = 1; END IF;</span></span></code> </pre><br> 如果一切都可以通过重新布置运算符来破坏，则代码编写错误。 并且不要欺骗自己，这种巧合不会发生-当然会发生。 <br><br> 但是如何正确编写代码？ 选项通常如下： <br><br><ul><li> 不写代码。 <br> 这不是在开玩笑。 例如，在这种情况下，检查很容易变成完整性约束： <br> <code>ALTER TABLE accounts ADD CHECK amount &gt;= 0;</code> <br> 现在无需检查：只需执行该操作，并在必要时处理如果尝试违反完整性的情况将发生的异常。 <br></li><li> 使用单个SQL语句。 <br> 出现一致性问题是因为在操作员之间的时间间隔内，另一个事务可以完成，这将更改可见数据。 而且，如果只有一名操作员，则没有时间间隔。 <br>  PostgreSQL具有足够的技术来用一条SQL语句解决复杂的问题。 让我们注意一下通用表表达式（CTE），在其余表中，您可以使用INSERT / UPDATE / DELETE语句，以及INSERT ON CONFLICT语句，该语句实现了“插入，但如果该行已经存在，在一份声明中进行更新。 <br></li><li> 自定义锁。 <br> 最后的方法是在所有必需的行（SELECT FOR UPDATE）上甚至在整个表（LOCK TABLE）上手动设置排他锁。 这始终有效，但是却抵消了多版本并发的好处：某些操作将顺序执行，而不是并发执行。 <br></li></ul><br><h3> 读不一致 </h3><br> 在进入下一个隔离级别之前，您必须承认它并不像听起来那样简单。  PostgreSQL的实现允许其他不受标准规范的鲜为人知的异常。 <br><br> 假设第一笔交易开始将资金从一个鲍勃的帐户转移到另一个帐户： <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><br> 同时，另一笔交易计算了Bob的余额，并且该计算在所有Bob的帐户中循环执行。 实际上，交易是从第一个帐户开始的（显然，看到的是先前的状态）： <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> amount <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><pre> <code class="plaintext hljs">| amount | -------- | 100.00 | (1 row)</code> </pre><br> 此时，第一个事务成功完成： <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br> 另一个读取第二个帐户的状态（并且已经看到新值）： <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> amount <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>;</code> </pre><pre> <code class="plaintext hljs">| amount | --------- | 1000.00 | (1 row)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br> 因此，第二笔交易的总金额为data1100，即数据不正确。 这是<em>不一致的读取</em>异常。 <br><br> 在保持“读取已提交”级别时如何避免这种异常？ 当然，请使用一个运算符。 例如： <br><br><pre> <code class="pgsql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> sum(amount) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><br><br> 到现在为止，我断言数据可见性只能在操作员之间改变，但这是如此明显吗？ 而且，如果查询花费很长时间，它是否可以看到处于一种状态的数据的一部分和处于另一种状态的数据的一部分？ <br><br> 让我们检查一下。 一种方便的方法是通过调用pg_sleep函数将强制延迟插入到运算符中。 其参数以秒为单位指定延迟时间。 <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> amount, pg_sleep(<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><br> 执行此运算符后，我们将在另一笔交易中将资金转回： <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br> 结果表明，操作员以执行操作员开始时的状态查看数据。 这无疑是正确的。 <br><br><pre> <code class="plaintext hljs"> amount | pg_sleep ---------+---------- 0.00 | 1000.00 | (2 rows)</code> </pre><br> 但这也不是那么简单。  PostgreSQL允许您定义函数，并且函数具有<em>波动类别</em>的概念。 如果在查询中调用了VOLATILE函数，并且在该函数中执行了另一个查询，则该函数内部的查询将看到与主查询中的数据不一致的数据。 <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> get_amount(id <span class="hljs-type"><span class="hljs-type">integer</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-type"><span class="hljs-type">numeric</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">SELECT</span></span></span><span class="pgsql"> amount </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">FROM</span></span></span><span class="pgsql"> accounts a </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHERE</span></span></span><span class="pgsql"> a.id = get_amount.id; $$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span> <span class="hljs-keyword"><span class="hljs-keyword">VOLATILE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LANGUAGE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> get_amount(id), pg_sleep(<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br> 在这种情况下，我们得到的数据不正确-损失了£100： <br><br><pre> <code class="plaintext hljs"> get_amount | pg_sleep ------------+---------- 100.00 | 800.00 | (2 rows)</code> </pre><br> 我强调指出，只有在“读已提交”隔离级别和VOLATILE函数中，这种效果才可能实现。 问题在于，默认情况下，恰好使用了此隔离级别和此波动类别。 不要掉入陷阱！ <br><br><h3> 读取不一致以换取丢失的更改 </h3><br> 在更新过程中，尽管以某种出乎意料的方式，我们也可能在单个运算符中读取不一致的内容。 <br><br> 让我们看看当两个事务试图修改同一行时会发生什么。 现在鲍勃在两个帐户上有1000英镑： <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+-------- 2 | 2001 | bob | 200.00 3 | 2002 | bob | 800.00 (2 rows)</code> </pre><br> 我们开始进行交易以减少Bob的余额： <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>;</code> </pre><br> 同时，在另一笔交易中，所有客户帐户的总余额等于或大于1,000英镑，产生利息： <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount * <span class="hljs-number"><span class="hljs-number">1.01</span></span> | <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> ( | <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> client | <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts | <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> client | <span class="hljs-keyword"><span class="hljs-keyword">HAVING</span></span> sum(amount) &gt;= <span class="hljs-number"><span class="hljs-number">1000</span></span> | );</code> </pre><br>  UPDATE运算符的执行包括两个部分。 首先，实际上是执行SELECT，它选择要更新的符合适当条件的行。 因为第一笔交易中的更改未提交，所以第二笔交易看不到它，因此该更改不会影响应计利息行的选择。 好了，鲍勃的帐户满足条件，一旦执行更新，他的余额应增加10英镑。 <br><br> 执行的第二阶段是逐一更新所选行。 在这里，第二个事务被迫“挂起”，因为id = 3的行已被第一个事务锁定。 <br><br> 同时，第一个事务提交更改： <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br> 结果将是什么？ <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+---------- 2 | 2001 | bob | 202.0000 3 | 2002 | bob | 707.0000 (2 rows)</code> </pre><br> 好吧，一方面，UPDATE命令应该看不到第二个事务的更改。 但是，另一方面，它不应丢失在第二笔交易中提交的更改。 <br><br> 释放锁定后，UPDATE将重新读取它尝试更新的行（但仅此行）。 结果，鲍勃根据900英镑的金额累计了9英镑。 但是如果鲍勃有900英镑，那么他的帐户根本就不会出现在选择中。 <br><br> 因此，事务获取了不正确的数据：某些行在某个时间点可见，而另一些在另一时间点可见。 我们不再丢失丢失的更新，而是再次得到<em>不一致的读取</em>异常。 <br><br><blockquote> 细心的读者会注意到，在应用程序的一些帮助下，即使在“已提交读”级别，也可能会丢失更新。 例如： <br><br><pre> <code class="pgsql hljs"> x := (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> amount <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = x + <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br> 该数据库不应该受到指责：它获得两个SQL语句，并且对x + 100的值与帐户金额有某种关系这一事实一无所知。 避免以这种方式编写代码。 <br></blockquote><br><h2> 可重复读 </h2><br><h3> 缺少不可重复和幻像读取 </h3><br> 隔离级别的确切名称假定读取是可重复的。 让我们检查一下，同时确保没有幻像读取。 为此，在第一笔交易中，我们将Bob的帐户还原为以前的状态，并为Charlie创建一个新帐户： <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = <span class="hljs-number"><span class="hljs-number">200.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = <span class="hljs-number"><span class="hljs-number">800.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">'3001'</span></span>, <span class="hljs-string"><span class="hljs-string">'charlie'</span></span>, <span class="hljs-number"><span class="hljs-number">100.00</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> id;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+---------+-------- 1 | 1001 | alice | 800.00 2 | 2001 | bob | 200.00 3 | 2002 | bob | 800.00 4 | 3001 | charlie | 100.00 (4 rows)</code> </pre><br> 在第二个会话中，我们通过在BEGIN命令中指定可重复读级别来启动事务（第一个事务的级别是非必需的）。 <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> id;</code> </pre><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+---------- | 1 | 1001 | alice | 800.00 | 2 | 2001 | bob | 202.0000 | 3 | 2002 | bob | 707.0000 | (3 rows)</code> </pre><br> 现在，第一个事务提交更改，第二个事务重新执行相同的查询。 <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> id;</code> </pre><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+---------- | 1 | 1001 | alice | 800.00 | 2 | 2001 | bob | 202.0000 | 3 | 2002 | bob | 707.0000 | (3 rows)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br> 第二个事务仍然看到与开始时完全相同的数据：看不到现有行或新行的任何更改。 <br><br> 在此级别上，您可以避免担心两个操作员之间可能会发生变化的事情。 <br><br><h3> 序列化错误以换取丢失的更改 </h3><br> 前面我们已经讨论过，当两个事务在“读取提交”级别上更新同一行时，可能会发生读取不一致的异常。 这是因为正在等待的事务重新读取了锁定的行，因此在与其他行相同的时间点看不到它。 <br><br> 在“可重复读取”级别，不允许出现此异常，但是如果发生此异常，则无法进行任何操作-因此事务会因序列化错误而终止。 让我们通过重复产生应计利息的相同场景来检查它： <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+-------- 2 | 2001 | bob | 200.00 3 | 2002 | bob | 800.00 (2 rows)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">100.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>;&lt;span/&gt; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount * <span class="hljs-number"><span class="hljs-number">1.01</span></span>&lt;span/&gt; | <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> (&lt;span/&gt; | <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> client&lt;span/&gt; | <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts&lt;span/&gt; | <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> client&lt;span/&gt; | <span class="hljs-keyword"><span class="hljs-keyword">HAVING</span></span> sum(amount) &gt;= <span class="hljs-number"><span class="hljs-number">1000</span></span>&lt;span/&gt; | );&lt;span/&gt;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="plaintext hljs">| ERROR: could not serialize access due to concurrent update</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span>;</code> </pre><br> 数据保持一致： <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+-------- 2 | 2001 | bob | 200.00 3 | 2002 | bob | 700.00 (2 rows)</code> </pre><br> 即使一行的任何其他竞争性更改没有发生，即使连续更改任何其他竞争性更改，也会发生相同的错误。 <br><br>  <em>实际结论</em> ：如果您的应用程序对写入事务使用“可重复读取”隔离级别，则它必须准备好重复因序列化错误而终止的事务。 对于只读事务，此结果是不可能的。 <br><br><h3> 写不一致 </h3><br> 因此，在PostgreSQL中，在“可重复读取”隔离级别上，可以防止标准中描述的所有异常。 但并非所有异常都一般。 事实证明，仍然存在<em>两种</em>可能的异常情况。  （这不仅适用于PostgreSQL，而且适用于快照隔离的其他实现。） <br><br> 这些异常中的第一个是<em>写入不一致</em> 。 <br><br> 让以下一致性规则成立： <em>如果该客户所有帐户上的总金额保持非负数，则允许该客户帐户上的负金额</em> 。 <br><br> 第一笔交易在鲍勃的帐户上获得的金额为900英镑。 <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> sum(amount) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> sum -------- 900.00 (1 row)</code> </pre><br> 第二笔交易获得相同的金额。 <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> sum(amount) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs">| sum | -------- | 900.00 | (1 row)</code> </pre><br> 第一笔交易正确地认为，其中一个帐户的金额可以减少600英镑。 <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">600.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><br> 第二笔交易得出相同的结论。 但这减少了另一个帐户： <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">600.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+--------- 2 | 2001 | bob | -400.00 3 | 2002 | bob | 100.00 (2 rows)</code> </pre><br> 尽管每笔交易都能正常运作，但我们设法使Bob的余额变成了红色。 <br><br><h3> 只读事务异常 </h3><br> 这是在“可重复读取”级别可能出现的第二个异常，也是最后一个异常。 为了演示它，您将需要三个事务，其中两个将更改数据，而第三个将仅读取它。 <br><br> 但是首先让我们恢复Bob的帐户状态： <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = <span class="hljs-number"><span class="hljs-number">900.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+-------- 3 | 2002 | bob | 100.00 2 | 2001 | bob | 900.00 (2 rows)</code> </pre><br> 在第一笔交易中，对所有Bob帐户上可用金额的利息产生。 利息记入他的帐户之一： <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; <span class="hljs-comment"><span class="hljs-comment">-- 1 =&gt; UPDATE accounts SET amount = amount + ( SELECT sum(amount) FROM accounts WHERE client = 'bob' ) * 0.01 WHERE id = 2;</span></span></code> </pre><br> 然后，另一笔交易从另一个鲍勃的帐户中提取了资金并进行了更改： <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; <span class="hljs-comment"><span class="hljs-comment">-- 2 | =&gt; UPDATE accounts SET amount = amount - 100.00 WHERE id = 3; | =&gt; COMMIT;</span></span></code> </pre><br> 如果第一笔交易在此时提交，则不会发生异常：我们可以假设第一笔交易先执行，然后再执行第二笔交易（但反之则不然，因为在此之前，第一笔交易的帐户状态为id = 3）帐户已被第二次交易更改）。 <br><br> 但是，想象一下，第三点（只读）交易在此时开始，它读取不受前两个交易影响的某些帐户的状态： <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; <span class="hljs-comment"><span class="hljs-comment">-- 3 | =&gt; SELECT * FROM accounts WHERE client = 'alice';</span></span></code> </pre><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+-------- | 1 | 1001 | alice | 800.00 | (1 row)</code> </pre><br> 并且只有在第一笔交易完成后： <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br> 第三笔交易现在应该看到什么状态？ <br><br><pre> <code class="pgsql hljs">| <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><br> 一旦开始，第三个事务可以看到第二个事务（已经提交）的更改，但是看不到第一个（尚未提交）的更改。 另一方面，我们已经在上面确定了第二笔交易应考虑在第一笔交易之后开始。 无论第三笔交易看到什么状态都将不一致-这只是只读交易的异常。 但在“可重复读取”级别，则允许： <br><br><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+-------- | 2 | 2001 | bob | 900.00 | 3 | 2002 | bob | 0.00 | (2 rows)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><h2> 可序列化 </h2><br> 可序列化级别可防止所有可能的异常。 实际上，可序列化是建立在快照隔离之上的。 可重复读取不会发生的那些异常（例如脏读，不可重复读取或幻像读取）也不会在可序列化级别上发生。 并且检测到那些发生的异常（不一致的写入和只读事务异常），并且事务中止-发生熟悉的序列化错误： <em>无法序列化访问</em> 。 <br><br><h3> 写不一致 </h3><br> 为了说明这一点，让我们以不一致的写入异常重复该场景： <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SERIALIZABLE</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> sum(amount) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> sum ---------- 910.0000 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SERIALIZABLE</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> sum(amount) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs">| sum | ---------- | 910.0000 | (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">600.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">600.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><pre> <code class="plaintext hljs">ERROR: could not serialize access due to read/write dependencies among transactions DETAIL: Reason code: Canceled on identification as a pivot, during commit attempt. HINT: The transaction might succeed if retried.</code> </pre><br> 就像在“可重复读取”级别上一样，使用“可序列化”隔离级别的应用程序必须重复以序列化错误终止的事务，因为错误消息会提示我们。 <br><br> 我们可以简化编程，但是这样做的代价是强制终止部分交易，并且需要重复执行。 当然，问题是这个分数有多大。 如果只有那些终止的事务与其他事务不兼容地重叠，那就太好了。 但是，由于您必须跟踪每一行的操作，因此这种实现不可避免地会占用大量资源并且效率低下。 <br><br> 实际上，PostgreSQL的实现允许错误的否定：一些绝对“不幸”的绝对正常的事务也将中止。 稍后我们将看到，这取决于许多因素，例如适当索引的可用性或可用的RAM数量。 此外，还有其他一些（相当严格的）实现限制，例如，“可序列化”级别的查询将不适用于副本，并且它们将不使用并行执行计划。 尽管改进实施的工作仍在继续，但是现有的限制使这种隔离级别的吸引力降低了。 <br><blockquote> 并行计划最早会在PostgreSQL 12（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">patch</a> ）中出现。 并且对副本的查询可以在PostgreSQL 13（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">另一个补丁</a> ）中开始工作。 <br></blockquote><br><h3> 只读事务异常 </h3><br> 为了使只读事务不会导致异常并且不会遭受异常的困扰，PostgreSQL提供了一种有趣的技术：可以锁定这种事务，直到其执行安全为止。 只有通过行更新才能锁定SELECT运算符时，这是唯一的情况。 看起来是这样的： <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = <span class="hljs-number"><span class="hljs-number">900.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = <span class="hljs-number"><span class="hljs-number">100.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> id;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+-------- 2 | 2001 | bob | 900.00 3 | 2002 | bob | 100.00 (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SERIALIZABLE</span></span>; <span class="hljs-comment"><span class="hljs-comment">-- 1 =&gt; UPDATE accounts SET amount = amount + ( SELECT sum(amount) FROM accounts WHERE client = 'bob' ) * 0.01 WHERE id = 2;</span></span></code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SERIALIZABLE</span></span>; <span class="hljs-comment"><span class="hljs-comment">-- 2 | =&gt; UPDATE accounts SET amount = amount - 100.00 WHERE id = 3; | =&gt; COMMIT;</span></span></code> </pre><br> 第三个事务被显式声明为READ ONLY和DEFERRABLE： <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SERIALIZABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ONLY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DEFERRABLE</span></span>; <span class="hljs-comment"><span class="hljs-comment">-- 3 | =&gt; SELECT * FROM accounts WHERE client = 'alice';</span></span></code> </pre><br> 尝试执行查询时，事务将被锁定，因为否则会导致异常。 <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br> 并且只有在提交第一个事务之后，第三个事务才继续执行： <br><br><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+-------- | 1 | 1001 | alice | 800.00 | (1 row)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+---------- | 2 | 2001 | bob | 910.0000 | 3 | 2002 | bob | 0.00 | (2 rows)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br> 另一个重要说明：如果使用了可序列化隔离，则应用程序中的所有事务都必须使用此级别。 您不能将已提交读（或可重复读）事务与可序列化混在一起。 也就是说，您<em>可以</em>混合使用，但随后Serializable的行为将类似于Repeatable Read，而没有任何警告。 我们将在稍后讨论实现时，讨论为什么会发生这种情况。 <br><br> 因此，如果您决定使用Serializble，则最好全局设置默认级别（尽管这当然不会阻止您明确指定不正确的级别）： <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> default_transaction_isolation = <span class="hljs-string"><span class="hljs-string">'serializable'</span></span>;</code> </pre><br><blockquote> 您可以在Boris Novikov的“数据库技术基础” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">一书</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">讲座中</a>找到有关交易，一致性和异常问题的更加严格的介绍（仅在Russion中可用）。 <br></blockquote><br><h1> 使用什么隔离级别？ </h1><br> 在PostgreSQL中，默认情况下使用Read Committed隔离级别，并且可能在绝大多数应用程序中使用该级别。 此默认设置很方便，因为在此级别上，只有在失败的情况下才可能中止事务，但不能用作防止不一致的手段。 换句话说，不会发生序列化错误。 <br><br> 硬币的另一面是大量可能的异常，上面已经详细讨论过。 软件工程师必须始终牢记它们并编写代码，以免它们出现。 如果无法在单个SQL语句中编写必要的操作，则必须诉诸显式锁定。 最麻烦的是，代码很难测试与获取不一致的数据相关的错误，并且错误本身可能以不可预测和不可重现的方式发生，因此难以修复。 <br><br> 可重复读取隔离级别消除了一些不一致的问题，但是可惜的是，并非全部。 因此，您不仅必须记住剩余的异常情况，还必须修改应用程序以使其正确处理序列化错误。 当然很不方便。 但是对于只读事务，此级别可以完美地补充“已提交读”操作，并且非常方便，例如，用于构建使用多个SQL查询的报表。 <br><br> 最后，可序列化级别使您完全不必担心不一致，这极大地简化了编码。 该应用程序唯一需要的是在发生序列化错误时能够重复任何事务。 但是中止事务的比例，额外的开销以及无法并行化查询会显着降低系统吞吐量。 还要注意，可序列化级别不适用于副本，并且不能与其他隔离级别混合。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">继续阅读</a> 。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN467437/">https://habr.com/ru/post/zh-CN467437/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN467423/index.html">Xamarin.Forms-在应用程序中方便使用图标字体</a></li>
<li><a href="../zh-CN467425/index.html">STEM强化学习方法</a></li>
<li><a href="../zh-CN467427/index.html">BudgetTracker-另一个用于个人理财的开源工具</a></li>
<li><a href="../zh-CN467429/index.html">Habrastatistics：浏览网站上访问量最高和访问量最少的部分</a></li>
<li><a href="../zh-CN467435/index.html">我们通过电子邮件或电报发送Veeam代理Linux的报告</a></li>
<li><a href="../zh-CN467439/index.html">为什么黑胶唱片会回来，流媒体服务与此相关？</a></li>
<li><a href="../zh-CN467443/index.html">多媒体中心“ Kodi”和Yocto项目</a></li>
<li><a href="../zh-CN467445/index.html">无法安装的Windows更新列表</a></li>
<li><a href="../zh-CN467449/index.html">具有内置保护的漏洞检测和对智能卡和加密处理器的黑客攻击的抵抗性评估</a></li>
<li><a href="../zh-CN467453/index.html">使用行星超级计算机解决42号问题</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>