<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👶🏻 📌 💇🏿 作业系统。 另一面的概述 🎳 ♎️ 👁‍🗨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在2018年的新版本unity中 ，他们终于正式添加了新的Entity组件系统（简称ECS） ，该系统使您只能使用其数据，而不是通常使用对象的组件。 

 附加的任务系统使您可以使用并行计算功能来提高代码的性能。 

 这两个新系统（ ECS和作业系统 ）一起提供了更高级别的数据处理。 

 具体来...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>作业系统。 另一面的概述</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/420829/"> 在2018年的新版本<b>unity中</b> ，他们终于正式添加了新的<b>Entity组件系统（</b>简称<b>ECS）</b> ，该系统使您只能使用其数据，而不是通常使用对象的组件。 <br><br> 附加的任务系统使您可以使用并行计算功能来提高代码的性能。 <br><a name="habracut"></a><br> 这两个新系统（ <b>ECS</b>和<b>作业系统</b> ）一起提供了更高级别的数据处理。 <br><br> 具体来说，在本文中，我将不会分析整个<b>ECS</b>系统，该系统目前可以作为一个单独的可单独下载的工具集使用，但是将仅考虑任务系统以及如何在<b>ECS</b>软件包外部使用它。 <br><br><h3> 新系统 </h3><br> 最初， <b>Unity</b>以前可能使用过多线程计算，但是所有这些都必须由开发人员自己创建，以解决自己的问题并解决陷阱。 如果以前必须直接处理诸如创建线程，关闭线程，池，同步之类的事情，那么现在所有这些工作都落在了引擎的肩膀上，开发人员本人只需要创建任务并完成任务即可。 <br><br><h3> 任务 </h3><br> 要在新系统中执行任何计算，必须使用作为由计算方法和数据组成的对象的任务。 <br><br> 与<b>ECS</b>系统中的任何其他数据一样， <b>作业系统中的</b>任务也表示为继承三个接口之一的结构。 <br><br><h4> 工友 </h4><br> 最简单的任务接口包含一个<b>Execute</b>方法，该方法不接受参数形式的任何内容，也不返回任何内容。 <br><br> 任务本身如下所示： <br><br><div class="spoiler">  <b class="spoiler_title">工友</b> <div class="spoiler_text"><pre><code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct JobStruct : IJob { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute() {} }</code> </pre> <br></div></div><br> 在<b>Execute</b>方法中，您可以执行必要的计算。 <br><br><h4>  IJobParallelFor </h4><br> 另一个具有相同<b>Execute</b>方法的接口，该接口已经接受了数字参数<b>index</b> 。 <br><br><div class="spoiler">  <b class="spoiler_title">IJobParallelFor</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct JobStruct : IJobParallelFor { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute(int index) {} }</code> </pre> <br></div></div><br> 与<b>IJob</b>接口不同，此<b>IJobParallelFor</b>接口提供了多次执行任务的功能，不仅可以执行，还可以将执行分成若干块，这些块将在线程之间分配。 <br><br>  <i>不清楚</i>  <i>不用担心，我会告诉您更多。</i> <br><br><h4>  IJobParallelForTransform </h4><br> 顾名思义，最后一个特殊接口旨在与对象的这些转换配合使用。 它还包含<b>Execute</b>方法，以及数字参数<b>索引</b>和<b>TransformAccess</b>参数，在此位置<b>变换</b>的位置，大小和旋转。 <br><br><div class="spoiler">  <b class="spoiler_title">IJobParallelForTransform</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct JobStruct : IJobParallelForTransform { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute(int index, TransformAccess transform) {} }</code> </pre> <br></div></div><br> 由于您不能直接在任务中使用<b>统一</b>对象，因此该接口只能将转换数据作为单独的<b>TransformAccess</b>结构进行处理。 <br><br> 完成后，现在您知道如何创建任务结构了，您可以继续练习。 <br><br><h3> 任务完成 </h3><br> 让我们创建一个继承自<b>IJob</b>接口的简单任务并完成它。 为此，我们需要任何简单的<b>MonoBehaviour</b>脚本和任务本身的结构。 <br><br><div class="spoiler">  <b class="spoiler_title">测试工作</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestJob</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MonoBehaviour</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Start() {} }</code> </pre> <br></div></div><br> 现在，将此脚本放在场景中的某个对象上。 在下面的同一脚本（ <b>TestJob</b> ）中，我们将编写任务的结构，并且不要忘记导入必要的库。 <br><br><div class="spoiler">  <b class="spoiler_title">简单的工作</b> <div class="spoiler_text"><pre> <code class="actionscript hljs">using Unity.Jobs; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct SimpleJob : IJob { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute() { Debug.Log(<span class="hljs-string"><span class="hljs-string">"Hello parallel world!"</span></span>); } }</code> </pre> <br></div></div><br> 例如，在<b>Execute</b>方法中，将简单的行打印到控制台。 <br><br> 现在，我们继续执行<b>TestJob</b>脚本的<b>Start</b>方法，在该方法中，我们将创建任务的一个实例，然后执行它。 <br><br><div class="spoiler">  <b class="spoiler_title">测试工作</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestJob</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MonoBehaviour</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Start() { SimpleJob job = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleJob(); job.Schedule().Complete(); } }</code> </pre> <br></div></div><br> 如果您按照示例进行了所有操作，那么在开始游戏后，您将收到一条简单的消息，如图所示。 <br><br><img src="https://lh6.googleusercontent.com/QQeMBMeZy0HVw0r_D5Q_cH4k6Zzt-HAC6uev1O4pR--mOh96C2TQvw5DTH1X3ZPE7LORJ4wdV5kyKjGiJzVWLFm-HBi8HzSP4-DlbrYa65eRV1RF672uwsLsZvrCKtF5CdaGJ5tj" alt="图片"><br><br> 发生的情况：调用<b>Schedule</b>方法后，调度程序将任务放在句柄中，现在可以通过调用<b>Complete</b>方法来完成任务。 <br><br> 这是仅将文本打印到控制台的任务示例。 为了使任务执行任何并行计算，必须将其填充数据。 <br><br><h3> 任务中的数据 </h3><br> 与在<b>ECS</b>系统中一样，在任务中无法访问<b>统一</b>对象，因此无法将<b>GameObject</b>放入任务并在其中更改其名称。 您所要做的就是将一些单独的对象参数传输到任务，更改这些参数，然后在完成任务后，将这些更改应用回该对象。 <br><br> 任务本身中的数据有几个限制：首先，它必须是结构，其次， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">不能</a>是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">可转换的</a>数据类型，也就是说，您不能将相同的<b>布尔值</b>或<b>字符串</b>传递给任务。 <br><br><div class="spoiler">  <b class="spoiler_title">简单的工作</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct SimpleJob : IJob { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> float a, b; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute() { float result = a + b; Debug.Log(result); } }</code> </pre> <br></div></div><br> 主要条件是：未封装在容器中的数据只能在任务内部访问！ <br><br><h3> 货柜 </h3><br> 使用多线程计算时，需要以某种方式在线程之间交换数据。 为了能够将数据传输到其中并在任务系统中读取它们，出于这些目的，有一些容器。 这些容器以普通结构的形式表示，我以网桥的原理工作，通过该网桥在流之间同步基本数据。 <br><br> 有几种类型的容器： <br>  <b>NativeArray</b> 。 最简单和最常用的容器类型是具有固定大小的简单数组。 <br>  <b>NativeSlice</b> 。 另一个容器-从翻译中可以明显看出，一个数组旨在将NativeArray切成碎片。 <br><br> 这是不连接<b>ECS</b>系统可用的两个主要容器。 在更高级的版本中，还有更多类型的容器。 <br><br>  <b>NativeList</b> 。 它是常规数据列表。 <br>  <b>NativeHashMap</b> 。 具有键和值的字典的类似物。 <br>  <b>NativeMultiHashMap</b> 。 相同的<b>NativeHashMap</b> ，一个键下只有几个值。 <br>  <b>NativeQueue</b> 数据队列列表。 <br><br> 由于我们无需连接<b>ECS</b>系统即可工作，因此只有<b>NativeArray</b>和<b>NativeSlice</b>可供<b>我们使用</b> 。 <br><br> 在进行实际操作之前，有必要分析最重要的一点-实例的创建。 <br><br><h3> 创建容器 </h3><br> 如前所述，这些容器代表了一个桥梁，线程之间的数据在该桥梁上同步。 任务系统在开始工作之前打开此桥，在完成工作后关闭它。 打开过程称为“ <i>分配</i> ”（ <b>Allocation</b> ）或<i>“内存分配”</i> ，关闭过程称为“ <i>资源释放</i> ”（ <b>Dispose</b> ）。 <br><br> 分配决定了任务可以使用容器中数据的时间-换句话说，桥接器将打开多长时间。 <br><br> 为了更好地理解这两个过程，让我们看一下下面的图片。 <br><br><img src="https://lh4.googleusercontent.com/6yL2x_ynGZj1C1ukkQlfDZuYKzlvJ4ceAYU9Zyb40xwDzuASeUNB__Od067_3xZkYANEOPl84JoKLyqTPn4hrvQNogbksb7akoQvcWjDLg2yyUJY9eF37uj7TO0YkOL3cQyMsXPu" alt="图片"><br><br> 下半部分显示了主线程（ <b>Main thread</b> ）的生命周期，它是根据帧数计算的；在第一帧中，我们创建了另一个并行线程（ <b>New thread）</b> ，该<b>线程</b>存在一定数量的帧，然后安全地关闭。 <br> 在同一<b>新线程中，</b>带有容器<b>的</b>任务到达。 <br><br> 现在看图片的顶部。 <br><br><img src="https://lh5.googleusercontent.com/1IZ_CMZhX4JfBWBLEuAijf1st_6e7p96EncPomR_jLNhQVbJDvS_o_-gf1emw3glwEGt8y3xXARp4xJJ9qu0WjYTH4asrblwul2rHa_SqQiLzrTTOoDJ5DlomcPBP8qkfCI3w9R8" alt="图片"><br><br> 白色条<b>分配</b>显示容器的寿命。 在第一个框架中，将<i>分配</i>容器-打开桥，直到此刻该容器不存在为止，在完成任务中的所有计算之后，该容器将释放内存，而在第9帧中，该桥被关闭。 <br><br> 同样在该条带（ <b>分配</b> ）上有时间段（ <b>Temp</b> ， <b>TempJob</b>和<b>Presistent</b> ），每个时间段都显示了容器的估计寿命。 <br><br> 为什么需要这些细分！ 事实是，按持续时间执行任务可能会有所不同，我们可以使用创建时所用的相同方法直接执行任务，如果执行起来很复杂，则可以延长任务执行时间，这些片段显示了任务可以使用数据的紧急程度和持续时间在容器中。 <br><br>  <i>如果仍然不清楚，我将通过一个示例分析每种分配类型。</i> <br><br> 现在我们继续进行创建容器的实际操作，为此，请返回<b>TestJob</b>脚本的<b>Start</b>方法，并创建<b>NativeArray</b>容器的新实例，不要忘记连接必要的库。 <br><br><h3> 温度 </h3><br><div class="spoiler">  <b class="spoiler_title">测试工作</b> <div class="spoiler_text"><pre> <code class="actionscript hljs">using Unity.Jobs; using Unity.Collections; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestJob</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MonoBehaviour</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Start() { NativeArray&lt;int&gt; array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;int&gt;(<span class="hljs-number"><span class="hljs-number">10</span></span>, Allocator.Temp); } }</code> </pre> <br></div></div><br> 要创建一个新的容器实例，必须在其构造函数中指定分配的大小和类型。 由于仅在<b>Start</b>方法中执行任务，因此本示例使用<b>Temp</b>类型。 <br><br> 现在，在<b>SimpleJob</b>任务的结构中初始化完全相同的数组变量。 <br><br><div class="spoiler">  <b class="spoiler_title">简单的工作</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct SimpleJob : IJob { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> NativeArray&lt;int&gt; array; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute() {} }</code> </pre> <br></div></div><br> 做完了 现在，您可以创建任务本身，并将数组实例传递给它。 <br><br><div class="spoiler">  <b class="spoiler_title">开始</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Start() { NativeArray&lt;int&gt; array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;int&gt;(<span class="hljs-number"><span class="hljs-number">10</span></span>, Allocator.Temp); SimpleJob job = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleJob(); job.array = array; }</code> </pre> <br></div></div><br> 要这次运行任务，我们将使用其<b>JobHandle</b>句柄通过调用相同的<b>Schedule</b>方法来获取它。 <br><br><div class="spoiler">  <b class="spoiler_title">开始</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Start() { NativeArray&lt;int&gt; array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;int&gt;(<span class="hljs-number"><span class="hljs-number">10</span></span>, Allocator.Temp); SimpleJob job = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleJob(); job.array = array; JobHandle handle = job.Schedule(); }</code> </pre> <br></div></div><br> 现在，您可以在她的句柄上调用<b>Complete</b>方法，并检查任务是否完成以在控制台中显示文本。 <br><br><div class="spoiler">  <b class="spoiler_title">开始</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Start() { NativeArray&lt;int&gt; array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;int&gt;(<span class="hljs-number"><span class="hljs-number">10</span></span>, Allocator.Temp); SimpleJob job = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleJob(); job.array = array; JobHandle handle = job.Schedule(); handle.Complete(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (handle.IsCompleted) print(<span class="hljs-string"><span class="hljs-string">" "</span></span>); }</code> </pre> <br></div></div><br> 如果您以这种形式运行任务，那么在开始游戏后，您将收到一条红色错误消息，提示您在任务完成后没有从资源中释放数组容器。 <br><br> 这样的东西。 <br><br><img src="https://lh3.googleusercontent.com/EewKhLiPm0_qidpB0-YnlUfbTcIlzOhPw_OXgJqcmm-m9MpAaq96PHSc-FlN7GNArl9JkThBUZEGM9YFIHR5BkkMRUBwTAM6awQAEYGOw45i31irFlXtkT7peTOmjFfoEq_ASONA" alt="图片"><br><br> 为避免这种情况，请在完成任务后在容器上调用<b>Dispose</b>方法。 <br><br><div class="spoiler">  <b class="spoiler_title">开始</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Start() { NativeArray&lt;int&gt; array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;int&gt;(<span class="hljs-number"><span class="hljs-number">10</span></span>, Allocator.Temp); SimpleJob job = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleJob(); job.array = array; JobHandle handle = job.Schedule(); handle.Complete(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (handle.IsCompleted) print(<span class="hljs-string"><span class="hljs-string">"Complete"</span></span>); array.Dispose(); }</code> </pre> <br></div></div><br> 然后，您可以安全地重新启动它。 <br> 但是任务什么都不做！  -然后添加一些操作。 <br><br><div class="spoiler">  <b class="spoiler_title">简单的工作</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct SimpleJob : IJob { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> NativeArray&lt;int&gt; array; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute() { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; array.Length; i++) { array[i] = i * i; } } }</code> </pre> <br></div></div><br> 在<b>Execute</b>方法中，我将自己乘以数组每个元素的索引，然后将其写回到数组<b>数组，</b>以<b>Start</b>方法将结果打印到控制台。 <br><br><div class="spoiler">  <b class="spoiler_title">开始</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Start() { NativeArray&lt;int&gt; array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;int&gt;(<span class="hljs-number"><span class="hljs-number">10</span></span>, Allocator.Temp); SimpleJob job = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleJob(); job.array = array; JobHandle handle = job.Schedule(); handle.Complete(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (handle.IsCompleted) print(job.array[job.array.Length - <span class="hljs-number"><span class="hljs-number">1</span></span>]); array.Dispose(); }</code> </pre> <br></div></div><br><blockquote> 如果我们将数组的最后一个元素打印为平方，那么在控制台中将得到什么结果？ </blockquote><br> 这是创建容器，将其放入任务并对其执行操作的方式。 <br><br> 这是使用<b>Temp</b>分配类型的示例，这意味着在一帧之内完成一项任务。 当您需要在不加载主线程的情况下快速执行计算时，这种类型是最好的选择，但是如果任务太复杂或如果它们太多，则需要小心，可能会产生下垂现象，在这种情况下最好使用<b>TempJob</b>类型<b>，</b>我将在后面进行分析。 <br><br><h3> 临时工作 </h3><br> 在此示例中，我将略微<b>修改SimpleJob</b>任务<b>的</b>结构，并从另一个<b>IJobParallelFor</b>接口继承它。 <br><br><div class="spoiler">  <b class="spoiler_title">简单的工作</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct SimpleJob : IJobParallelFor { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> NativeArray&lt;Vector2&gt; array; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute(int index) {} }</code> </pre> <br></div></div><br> 此外，由于任务的运行时间超过一帧，因此我们将以协程形式提供不同的<b>Awake</b>和<b>Start</b>方法来执行和收集任务的结果。 为此，请<b>稍微</b>更改<b>TestJob</b>类的外观。 <br><br><div class="spoiler">  <b class="spoiler_title">测试工作</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestJob</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MonoBehaviour</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> NativeArray&lt;Vector2&gt; array; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> JobHandle handle; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Awake() {} IEnumerator Start() {} }</code> </pre> <br></div></div><br> 在<b>Awake</b>方法中，我们将创建一个任务和一个向量容器，在<b>Start</b>方法中，将输出接收到的数据并释放资源。 <br><br><div class="spoiler">  <b class="spoiler_title">醒着</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Awake() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Vector2&gt;(<span class="hljs-number"><span class="hljs-number">100</span></span>, Allocator.TempJob); SimpleJob job = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleJob(); job.array = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.array; }</code> </pre> <br></div></div><br> 再次在这里，使用分配类型<b>TempJob</b>创建一个<b>数组</b>容器，此后，我们创建任务并通过稍作更改调用<b>Schedule</b>方法来获取其句柄。 <br><br><div class="spoiler">  <b class="spoiler_title">醒着</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Awake() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Vector2&gt;(<span class="hljs-number"><span class="hljs-number">100</span></span>, Allocator.TempJob); SimpleJob job = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleJob(); job.array = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.array; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handle = job.Schedule(<span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>) }</code> </pre> <br></div></div><br>  <b>Schedule</b>方法中的第一个参数指示任务将被执行多少次，这与array <b>array</b>的大小相同。 <br> 第二个参数指示要共享任务的块数。 <br><br>  <i>还有什么其他块？</i> <br> 以前，为了完成一项任务，一个线程简单地称为<b>Execute</b>方法一次，现在必须调用此方法100次，因此调度程序将这100次重复操作分成多个块，在每个线程之间分配该块以便不加载任何单独的线程。 在该示例中，一百次重复将分为5个块，每个块20个重复，也就是说，调度程序大概会将这5个块分配到5个线程中，其中每个线程将调用<b>Execute</b>方法20次。 当然，在实践中，调度程序不会那样做，这完全取决于系统的工作量，因此，所有100次重复都可能在一个线程中发生。 <br><br> 现在，您可以在任务句柄上调用<b>Complete</b>方法。 <br><br><div class="spoiler">  <b class="spoiler_title">醒着</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Awake() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Vector2&gt;(<span class="hljs-number"><span class="hljs-number">100</span></span>, Allocator.TempJob); SimpleJob job = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleJob(); job.array = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.array; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handle = job.Schedule(<span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handle.Complete(); }</code> </pre> <br></div></div><br> 在<b>启动</b>协程中，我们将检查任务的执行情况，然后清理容器。 <br><br><div class="spoiler">  <b class="spoiler_title">开始</b> <div class="spoiler_text"><pre> <code class="actionscript hljs">IEnumerator Start() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handle.isCompleted == <span class="hljs-literal"><span class="hljs-literal">false</span></span>){ yield <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WaitForEndOfFrame(); } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.array.Dispose(); }</code> </pre> <br></div></div><br> 现在，让我们继续执行任务本身中的操作。 <br><br><div class="spoiler">  <b class="spoiler_title">简单的工作</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct SimpleJob : IJobParallelFor { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> NativeArray&lt;Vector2&gt; array; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute(int index) { float x = index; float y = index; Vector2 vector = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(x * x, y * y / (y * <span class="hljs-number"><span class="hljs-number">2</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.array[index] = vector; } }</code> </pre> <br></div></div><br> 在<b>Start</b>方法中完成任务之后，在控制台中显示数组的所有元素。 <br><br><div class="spoiler">  <b class="spoiler_title">开始</b> <div class="spoiler_text"><pre> <code class="actionscript hljs">IEnumerator Start() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handle.IsCompleted == <span class="hljs-literal"><span class="hljs-literal">false</span></span>){ yield <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WaitForEndOfFrame(); } foreach(Vector2 vector <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.array) { print(vector); } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.array.Dispose(); }</code> </pre> <br></div></div><br> 完成后，您可以运行并查看结果。 <br><br> 要了解<b>IJob</b>和<b>IJobParallelFor</b>之间的<b>区别</b> ， <b>请看</b>下面的图片。 <br> 例如，在<b>IJob中，</b>您<b>可以</b>使用一个简单的<b>for</b>循环多次执行计算，但是在任何情况下，线程在整个任务过程中只能调用一次<b>Execute</b>方法，这是使一个人连续执行数百个相同动作的方法。 <br><br><img src="https://lh3.googleusercontent.com/qUadSqRojz1W8kiqtm-xgi-TYeJ9IlVh38o0MrG0mTWnU3j0qTjtTOWa8pkPc0kjPQcTKoqOJtNl6E4Olb5MKCNgUhrsAXGujN0flm_YVoFfEVS9kCCjFOucANAw74Kjq2W_Zzho" alt="图片"><br><br>  <b>IJobParallelFor</b>提供的功能不仅可以在一个线程中多次执行一个任务，而且还可以在其他线程之间分配这些重复。 <br><br><img src="https://lh5.googleusercontent.com/-5ggH4tUKWvhz6I8UUi2eGzqY_B_QqA1PA_298vp89xg4v2yC3wn3N9D8TlVOMwWuDM593H_Aw9WZOU-_esyT7vyL4MM17bZaevfiOiYSEUb0I1oT2Fi3cXbBtoc9SuMYIhVnMc7" alt="图片"><br><br> 通常，分配类型<b>TempJob</b>非常适合在几帧上执行的大多数任务。 <br><br> 但是，即使在完成任务后仍需要存储数据，又怎么办？如果收到结果后就不需要立即销毁数据，该怎么办。 为此，有必要使用<b>Persistent</b>分配类型，这意味着在“ <i>必要时”</i>释放资源<i>。</i>  。 <br><br><h3> 持久的 </h3><br>  <b>让我们</b>回到<b>TestJob</b>类并对其进行更改。 现在，我们将在<b>OnEnable</b>方法中创建任务，在<b>Update</b>方法中检查它们的执行，并在<b>OnDisable</b>方法中清理资源。 <br> 在示例中，我们将使用<b>Update</b>方法移动对象，为了计算轨迹，我们将使用两个向量容器<b>-inputArray</b> （将在其中放置当前位置）和<b>outputArray（</b>从中接收结果）。 <br><br><div class="spoiler">  <b class="spoiler_title">测试工作</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestJob</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MonoBehaviour</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> NativeArray&lt;Vector2&gt; inputArray; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> NativeArray&lt;Vector2&gt; outputArray; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> JobHandle handle; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnEnable() {} <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Update() {} <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnDisable() {} }</code> </pre> <br></div></div><br>  <b>我们还将</b>通过从<b>IJob</b>接口继承它来执行一次来稍微<b>修改SimpleJob</b>任务<b>的</b>结构。 <br><br><div class="spoiler">  <b class="spoiler_title">简单的工作</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct SimpleJob : IJob { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute() {} }</code> </pre> <br></div></div><br> 在任务本身中，我们还将背叛两个向量容器，一个位置向量和一个数值增量，这会将对象移动到目标。 <br><br><div class="spoiler">  <b class="spoiler_title">简单的工作</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct SimpleJob : IJob { [ReadOnly] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> NativeArray&lt;Vector2&gt; inputArray; [WriteOnly] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> NativeArray&lt;Vector2&gt; outputArray; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2 position; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> float delta; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute() {} }</code> </pre> <br></div></div><br>  <b>ReadOnly</b>和<b>WriteOnly</b>属性显示与容器内数据关联的操作的流限制。  <b>ReadOnly</b>仅提供流以从容器读取数据，相反， <b>WriteOnly</b>属性允许流仅将数据写入容器。 如果您需要使用一个容器一次执行这两项操作，则根本不需要使用属性来标记它。 <br><br> 让我们<b>继续</b>进行<b>TestJob</b>类的<b>OnEnable</b>方法，在该方法中初始化容器。 <br><br><div class="spoiler">  <b class="spoiler_title">启用</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnEnable() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.inputArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Vector2&gt;(<span class="hljs-number"><span class="hljs-number">1</span></span>, Allocator.Persistent); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.outputArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Vector2&gt;(<span class="hljs-number"><span class="hljs-number">1</span></span>, Allocator.Persistent); }</code> </pre> <br></div></div><br> 容器的尺寸将是单一的，因为仅需要一次发送和接收参数。 分配类型将为<b>Persistent</b> 。 <br> 在<b>OnDisable</b>方法中， <b>我们</b>将释放容器的资源。 <br><br><div class="spoiler">  <b class="spoiler_title">禁用</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnDisable() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.inputArray.Dispose(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.outputArray.Dispose(); }</code> </pre> <br></div></div><br> 让我们创建一个单独的<b>CreateJob</b>方法，在其中创建带有其句柄的任务，然后在其中填充数据。 <br><br><div class="spoiler">  <b class="spoiler_title">创建工作</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CreateJob() { SimpleJob job = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleJob(); job.delta = Time.deltaTime; Vector2 position = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.transform.position; job.position = position; Vector2 newPosition = position + Vector2.right; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.inputArray[<span class="hljs-number"><span class="hljs-number">0</span></span>] = newPosition; job.inputArray = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.inputArray; job.outputArray = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.outputArray; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handle = job.Schedule(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handle.Complete(); }</code> </pre> <br></div></div><br>  <i>实际上，这里实际上并不需要<b>输入数组</b> ，因为可以将方向向量仅传递给任务，但是我认为最好理解为什么根本需要这些<b>ReadOnly</b>和<b>WriteOnly</b>属性。</i> <br><br> 在<b>Update</b>方法中，我们将检查任务是否完成，然后将获得的结果应用于对象转换并再次运行。 <br><br><div class="spoiler">  <b class="spoiler_title">更新资料</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Update() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handle.IsCompleted) { Vector2 newPosition = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.outputArray[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.transform.position = newPosition; CreateJob(); } }</code> </pre> <br></div></div><br> 在开始之前，我们将稍微调整<b>OnEnable</b>方法，以便在初始化容器之后立即创建任务。 <br><br><div class="spoiler">  <b class="spoiler_title">启用</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnEnable() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.inputArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Vector2&gt;(<span class="hljs-number"><span class="hljs-number">1</span></span>, Allocator.Persistent); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.outputArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Vector2&gt;(<span class="hljs-number"><span class="hljs-number">1</span></span>, Allocator.Persistent); CreateJob(); }</code> </pre> <br></div></div><br> 完成后，现在您可以转到任务本身，并在<b>Execute</b>方法中执行必要的计算。 <br><br><div class="spoiler">  <b class="spoiler_title">执行</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute() { Vector2 newPosition = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.inputArray[<span class="hljs-number"><span class="hljs-number">0</span></span>]; newPosition = Vector2.Lerp(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.position, newPosition, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.delta); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.outputArray[<span class="hljs-number"><span class="hljs-number">0</span></span>] = newPosition; }</code> </pre> <br></div></div><br> 要查看工作结果，可以将<b>TestJob</b>脚本放在某个对象上并运行游戏。 <br><br> 例如，我的精灵仅逐渐向右移动。 <br><br><div class="spoiler">  <b class="spoiler_title">动画制作</b> <div class="spoiler_text"><img src="https://lh3.googleusercontent.com/YCf68msYSI0w6ARjOAeAWsPPhpPOrXC-3jWTfqtlnu1pS1xa9m6FCjTD3DdvcvWi5KSEh_-q6X2yUf62j1FOgSU6d0plX603FOQiydF-yLRQFvbd2YBY-mp8I5p5V4cQH9t7SKPR" alt="图片"><br></div></div><br> 通常， <b>持久性</b>分配类型非常适合可重用的容器，这些容器不需要每次都销毁和重新创建。 <br><br>  <i>那用什么类型的！</i> <br>  <b>Temp</b>类型最适合用于快速执行计算，但是如果任务太复杂和太大，则会出现松弛。 <br>  <b>TempJob</b>类型非常适合处理<b>统一</b>对象，因此您可以更改对象的参数并将其应用，例如，在下一帧中。 <br> 当速度对您而言并不重要时，可以使用<b>Persistent</b>类型，但是您只需要不断地从侧面计算某种数据，例如，通过网络处理数据或AI的工作。 <br><br><div class="spoiler">  <b class="spoiler_title">无效且无</b> <div class="spoiler_text">  <i>还有两种分配类型<b>Invalid</b>和<b>None</b> ，但是调试它们需要更多类型，并且不参与工作。</i> <br></div></div><br><br><h3> 作业手柄 </h3><br> 另外，值得分析任务句柄的功能，因为除了检查任务执行过程之外，这个小句柄仍可以通过依赖关系创建整个任务网络（尽管我更喜欢将它们称为队列）。 <br><br> 例如，如果您需要按一定顺序执行两个任务，那么您只需要将一个任务的句柄附加到另一个任务的句柄即可。 <br><br> 看起来像这样。 <br><br><img src="https://lh3.googleusercontent.com/K62BSMljveR8lED8wCuCUCuLN6zyNlXS8RQybQuztrT_FMalHHSP7oMGIDf6xUcjXAMqRG3njvHIJ4FPL_tU1uSZr5XQDmCOPyM_YJye2i_z58lIPAkflcia511L2ILI72In61aT" alt="图片"><br><br> 每个单独的句柄最初都包含其自己的任务，但是当组合在一起时，我们将获得一个包含两个任务的新句柄。 <br><br><div class="spoiler">  <b class="spoiler_title">开始</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Start() { Job jobA = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Job(); JobHandle handleA = jobA.Schedule(); Job jobB = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Job(); JobHandle handleB = jobB.Schedule(); JobHandle result = JobHandle.CombineDependecies(handleA, handleB); result.Complete(); }</code> </pre> <br></div></div><br> 大概吧 <br><br><div class="spoiler">  <b class="spoiler_title">开始</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Start() { JobHandle handle; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>; i++) { Job job = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Job(); handle = job.Schedule(handle); } handle.Complete(); }</code> </pre> <br></div></div><br> 保存执行序列，并且在确信上一个任务之前，调度程序将不会启动下一个任务，但是请务必记住IsCompleted <b>句柄</b>属性将等待其中的所有任务完成。 <br><br><h2> 结论 </h2><br><h3> 货柜 </h3><br><ol><li> 处理容器中的数据时，请不要忘记它们是结构，因此容器中数据的任何覆盖都不会更改它们，而是会再次创建它。 </li><li>  <i>如果设置分配类型Temp并在任务完成后不清除资源，该怎么办？</i> 错误。 </li><li>  <i>我可以创建自己的容器吗？</i> 可能在这里详细描述<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">了</a>创建自定义容器<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的</a>过程，但是最好再三思：这是否值得，也许会有足够的普通容器！ </li></ol><br><h4> 安全！ </h4><br> <i> .</i> <br><br>       ( <b>Random</b>  ),        .           ,             —         . <br><br> <i>   ?</i> <br><br>          ,        ,      .       <b>ECS,</b>          ,       ,      —    .      10      —        ,            —  ,           . <br><br>                     ,  <b>Job System</b>      .                      ,  <b>ECS</b>     .       <b>WebGL</b>     ,    <b>Job System</b>     ,      ,    . <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://www.google.com/url%3Fq%3D">   </a> <cut></cut></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN420829/">https://habr.com/ru/post/zh-CN420829/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN420815/index.html">“解码数字世界”是如何爆炸的：DotNext 2018 Piter的十大报道</a></li>
<li><a href="../zh-CN420819/index.html">用于机器学习和数据科学的十大Python工具</a></li>
<li><a href="../zh-CN420821/index.html">规则10：编程和写作为1</a></li>
<li><a href="../zh-CN420825/index.html">今天将是OpenAI和Dota 2专业人士之间的首次较量（获胜者）。 我们了解机器人的工作原理</a></li>
<li><a href="../zh-CN420827/index.html">使用Java EE + WildFly10 + JPA（Hibernate）+ Postgresql + EJB + IntelliJ IDEA创建一个简单的Maven项目</a></li>
<li><a href="../zh-CN420831/index.html">Cookie发行设备“ Cook 3000”</a></li>
<li><a href="../zh-CN420833/index.html">主要的应用获利错误[以及解决方法]</a></li>
<li><a href="../zh-CN420837/index.html">使用SNIA方法测试NVMe设备的软件RAID阵列</a></li>
<li><a href="../zh-CN420841/index.html">院前修复程序或“嘿招摇！ 我的错误在哪里？”</a></li>
<li><a href="../zh-CN420843/index.html">9月7日，叶卡捷琳堡-.NET开发人员会议</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>