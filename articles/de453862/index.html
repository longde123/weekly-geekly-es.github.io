<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßôüèª üí¥ üçë Warum sollten Sie Pathlib verwenden üë©‚Äçüíº üñäÔ∏è ‚ñ∂Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vom √úbersetzer: Hallo Habr! Ich pr√§sentiere Ihnen die √úbersetzung des Artikels Warum Sie Pathlib verwenden sollten und seine Fortsetzung: Nein, Pathli...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Warum sollten Sie Pathlib verwenden</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/453862/"><p>  <em>Vom √úbersetzer: Hallo Habr!</em>  <em>Ich pr√§sentiere Ihnen die √úbersetzung des Artikels <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Warum Sie Pathlib verwenden sollten</a> und seine Fortsetzung: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nein, Pathlib ist wirklich gro√üartig</a> .</em>  <em>Neue Python-Funktionen wie asyncio, der Operator: = und die optionale Eingabe werden jetzt besonders ber√ºcksichtigt.</em>  <em>Gleichzeitig ist das Risiko f√ºr ein Radar nicht so bedeutend (obwohl :: eine ernsthafte Innovation als Sprache bezeichnet, die sich nicht als ernsthafte Innovation herausstellt), sondern sehr n√ºtzliche Innovationen in einer Sprache.</em>  <em>Insbesondere bei einer Reihe von Artikeln, die einem Thema gewidmet waren, fand ich sie nicht (mit Ausnahme eines Absatzes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> ), weshalb ich mich entschied, die Situation zu korrigieren.</em> </p><br><p> Als ich vor einigen Jahren das damals neue <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pathlib-</a> Modul entdeckte, entschied ich aus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">tiefstem</a> Kopf, dass es sich nur um eine etwas umst√§ndliche objektorientierte Version des <code>os.path</code> Moduls handelt.  Ich habe mich geirrt  <code>pathlib</code> ist wirklich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wunderbar</a> ! </p><br><p>  In diesem Artikel werde ich versuchen, mich in <code>pathlib</code> zu <code>pathlib</code> .  Ich hoffe, dieser Artikel <strong><code>pathlib</code></strong> Sie dazu <strong>, <code>pathlib</code> in jeder Situation</strong> zu <strong>verwenden, in <code>pathlib</code></strong> Sie <strong>mit Dateien in Python arbeiten</strong> . </p><a name="habracut"></a><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1.</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>os.path</code> umst√§ndlich</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>os</code> √ºberladen</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>   glob</code></a> </li> <li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>pathlib</code> macht einfache dinge noch einfacher</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pfadobjekte machen Ihren Code offensichtlicher</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>    pathlib</code> ?</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>    pathlib</code> ?</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2. Antworten auf Fragen.</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code> os.path</code> und <code>pathlib</code> , um ehrlich zu sein</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sie m√ºssen sich nicht um die Normalisierung der Pfade k√ºmmern.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code> ,     ,    pathlib</code> !</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aber meine Lieblingsbibliothek hat Path besser als der Standard!</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>  pathlib.Path</code> und <code>str</code> mischen sich nicht, oder?</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>pathlib</code> zu langsam</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verbesserung der Lesbarkeit</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>   pathlib.Path</code></a> </li> </ul></li></ul><br><h2 id="chast-1">  Teil 1. </h2><br><h3 id="ospath-neuklyuzh">  <code>os.path</code> umst√§ndlich </h3><br><p>  Das Modul <code>os.path</code> immer das, was wir f√ºr Python-Pfade verwendet haben.  Im Prinzip gibt es alles, was Sie brauchen, aber oft sieht es nicht zu elegant aus. </p><br><p>  Soll ich es so importieren? </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os.path BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__))) TEMPLATES_DIR = os.path.join(BASE_DIR, <span class="hljs-string"><span class="hljs-string">'templates'</span></span>)</code> </pre> <br><p>  Oder so? </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> os.path <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> abspath, dirname, join BASE_DIR = dirname(dirname(abspath(__file__))) TEMPLATES_DIR = join(BASE_DIR, <span class="hljs-string"><span class="hljs-string">'templates'</span></span>)</code> </pre> <br><p>  Vielleicht hat die <code>join</code> Funktion einen zu allgemeinen Namen, und wir sollten so etwas tun: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> os.path <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> abspath, dirname, join <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> joinpath BASE_DIR = dirname(dirname(abspath(__file__))) TEMPLATES_DIR = joinpath(BASE_DIR, <span class="hljs-string"><span class="hljs-string">'templates'</span></span>)</code> </pre> <br><p>  Alle oben genannten Optionen scheinen mir nicht allzu bequem zu sein.  Wir √ºbergeben Zeichenfolgen an Funktionen, die Zeichenfolgen zur√ºckgeben, die wir an die n√§chsten Funktionen √ºbergeben, die mit Zeichenfolgen arbeiten.  Es ist einfach so passiert, dass sie alle Pfade enthalten, aber sie sind immer noch nur Linien. </p><br><p>  Die Verwendung von Zeichenfolgen f√ºr die Eingabe und Ausgabe in <code>os.path</code> Funktionen <code>os.path</code> sehr unpraktisch, da Sie den Code von innen nach au√üen lesen m√ºssen.  Ich m√∂chte diese Aufrufe von verschachtelt in sequentiell konvertieren.  Das k√∂nnen Sie mit <code>pathlib</code> tun! </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path BASE_DIR = Path(__file__).resolve().parent.parent TEMPLATES_DIR = BASE_DIR.joinpath(<span class="hljs-string"><span class="hljs-string">'templates'</span></span>)</code> </pre> <br><p>  Das Modul <code>os.path</code> erfordert verschachtelte Funktionsaufrufe. Mit <code>pathlib</code> <strong>k√∂nnen wir jedoch Ketten aufeinanderfolgender Aufrufe von Methoden und Attributen der <code>Path</code> Klasse</strong> mit einem entsprechenden Ergebnis <strong>erstellen</strong> . </p><br><p>  Ich wei√ü, was Sie denken: Stoppen Sie, diese <code>Path</code> sind nicht die gleichen wie zuvor, wir arbeiten nicht mehr auf Pfadlinien!  Wir werden sp√§ter auf dieses Thema zur√ºckkommen (Hinweis: In fast jeder Situation sind diese beiden Ans√§tze austauschbar). </p><br><h3 id="os-peregruzhen">  <code>os</code> √ºberladen </h3><br><p>  Das klassische <code>os.path</code> Modul wurde f√ºr die Arbeit mit Pfaden entwickelt.  Nachdem Sie <em>jedoch etwas</em> mit dem Pfad <em>tun</em> m√∂chten (z. B. ein Verzeichnis erstellen), m√ºssen Sie auf ein anderes Modul zugreifen, h√§ufig <code>os</code> . </p><br><p>  <code>os</code> enth√§lt eine Reihe von Dienstprogrammen f√ºr die Arbeit mit Dateien und Verzeichnissen: <code>mkdir</code> , <code>getcwd</code> , <code>chmod</code> , <code>stat</code> , <code>remove</code> , <code>getcwd</code> , <code>rmdir</code> .  Auch <code>chdir</code> , <code>link</code> , <code>walk</code> , <code>listdir</code> , <code>makedirs</code> , <code>renames</code> , <code>removedirs</code> , <code>unlink</code> , <code>symlink</code> .  Und eine ganze Reihe von <code>getenv</code> , die <code>putenv</code> nichts mit Dateisystemen zu <code>getenv</code> : <code>fork</code> , <code>getenv</code> , <code>putenv</code> , <code>getlogin</code> , <code>getlogin</code> , <code>system</code> , ... Ein paar Dutzend weitere Dinge, die ich hier nicht erw√§hnen werde. </p><br><p>  <strong>Das <code>os</code> ist f√ºr eine Vielzahl von Aufgaben konzipiert.</strong>  <strong>Dies ist eine solche Box mit allem, was mit dem Betriebssystem zu tun hat.</strong>  Es gibt viele n√ºtzliche Funktionen in <code>os</code> , aber die Navigation ist nicht immer einfach: Oft m√ºssen Sie sich ein wenig mit dem Modul befassen, bevor Sie das finden, was Sie ben√∂tigen. </p><br><p>  <code>pathlib</code> √ºbertr√§gt die meisten Dateisystemfunktionen auf <code>pathlib</code> . </p><br><p>  Hier ist der Code, der das <code>src/__pypackages__</code> und unsere <code>.editorconfig</code> Datei in <code>src/.editorconfig</code> : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os.path os.makedirs(os.path.join(<span class="hljs-string"><span class="hljs-string">'src'</span></span>, <span class="hljs-string"><span class="hljs-string">'__pypackages__'</span></span>), exist_ok=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) os.rename(<span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>, os.path.join(<span class="hljs-string"><span class="hljs-string">'src'</span></span>, <span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>))</code> </pre> <br><p>  Hier ist √§hnlicher Code mit <code>Path</code> </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path Path(<span class="hljs-string"><span class="hljs-string">'src/__pypackages__'</span></span>).mkdir(parents=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, exist_ok=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) Path(<span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>).rename(<span class="hljs-string"><span class="hljs-string">'src/.editorconfig'</span></span>)</code> </pre> <br><p>  Beachten Sie, dass das zweite Codebeispiel viel einfacher zu lesen ist, da es von links nach rechts organisiert ist - dies alles dank der Methodenketten. </p><br><h3 id="ne-zabyvayte-pro-glob">  <code>glob</code> nicht vergessen </h3><br><p>  Nicht nur <code>os</code> und <code>os.path</code> enthalten Methoden, die sich auf das Dateisystem beziehen.  Erw√§hnenswert ist auch <code>glob</code> , der nicht als nutzlos bezeichnet werden kann. </p><br><p>  Wir k√∂nnen die Funktion <code>glob.glob</code> verwenden, um nach Dateien nach einem bestimmten Muster zu suchen: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> glob <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> glob top_level_csv_files = glob(<span class="hljs-string"><span class="hljs-string">'*.csv'</span></span>) all_csv_files = glob(<span class="hljs-string"><span class="hljs-string">'**/*.csv'</span></span>, recursive=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>)</code> </pre> <br><p>  Das <code>pathlib</code> Modul bietet auch √§hnliche Methoden: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path top_level_csv_files = Path.cwd().glob(<span class="hljs-string"><span class="hljs-string">'*.csv'</span></span>) all_csv_files = Path.cwd().rglob(<span class="hljs-string"><span class="hljs-string">'*.csv'</span></span>)</code> </pre> <br><p>  Nach dem Wechsel zum <code>pathlib</code> Modul <strong>verschwindet</strong> die <strong>Notwendigkeit f√ºr das <code>glob</code> vollst√§ndig</strong> : Alles, was Sie ben√∂tigen, ist bereits ein integraler Bestandteil von <code>Path</code> Objekten </p><br><h3 id="pathlib-delaet-prostye-veschi-esche-prosche">  <code>pathlib</code> macht einfache dinge noch einfacher </h3><br><p>  <code>pathlib</code> vereinfacht viele schwierige Situationen, <strong>macht</strong> aber auch <strong>einige einfache Codefragmente noch einfacher</strong> . </p><br><p>  M√∂chten Sie den gesamten Text in einer oder mehreren Dateien lesen? </p><br><p>  Sie k√∂nnen die Datei √∂ffnen, den Inhalt lesen und die Datei mit dem <code>with</code> Block schlie√üen: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> glob <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> glob file_contents = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> filename <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> glob(<span class="hljs-string"><span class="hljs-string">'**/*.py'</span></span>, recursive=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(filename) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> python_file: file_contents.append(python_file.read())</code> </pre> <br><p>  Sie k√∂nnen auch die Methode <code>read_text</code> f√ºr <code>read_text</code> verwenden und Listen generieren, um dasselbe Ergebnis in einem Ausdruck zu erhalten: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path file_contents = [ path.read_text() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> path <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Path.cwd().rglob(<span class="hljs-string"><span class="hljs-string">'*.py'</span></span>) ]</code> </pre> <br><p>  Aber was ist, wenn Sie in eine Datei schreiben m√ºssen? </p><br><p>  So sieht es mit <code>open</code> : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(<span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> config: config.write(<span class="hljs-string"><span class="hljs-string">'# config goes here'</span></span>)</code> </pre> <br><p>  Oder Sie k√∂nnen die Methode <code>write_text</code> verwenden: </p><br><pre> <code class="python hljs">Path(<span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>).write_text(<span class="hljs-string"><span class="hljs-string">'# config goes here'</span></span>)</code> </pre> <br><p>  Wenn Sie <code>open</code> aus irgendeinem Grund entweder als Kontextmanager oder f√ºr pers√∂nliche Einstellungen verwenden m√ºssen, bietet <code>Path</code> die <code>open</code> Methode als Alternative: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path path = Path(<span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> path.open(mode=<span class="hljs-string"><span class="hljs-string">'wt'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> config: config.write(<span class="hljs-string"><span class="hljs-string">'# config goes here'</span></span>)</code> </pre> <br><p>  Ab Python 3.6 k√∂nnen Sie Ihren <code>Path</code> direkt zum <code>open</code> : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path path = Path(<span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(path, mode=<span class="hljs-string"><span class="hljs-string">'wt'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> config: config.write(<span class="hljs-string"><span class="hljs-string">'# config goes here'</span></span>)</code> </pre> <br><h3 id="obekty-path-delayut-vash-kod-ochevidnee">  Pfadobjekte machen Ihren Code offensichtlicher </h3><br><p>  Was zeigen die folgenden Variablen an?  Was bedeuten ihre Bedeutungen? </p><br><pre> <code class="python hljs">person = <span class="hljs-string"><span class="hljs-string">'{"name": "Trey Hunner", "location": "San Diego"}'</span></span> pycon_2019 = <span class="hljs-string"><span class="hljs-string">"2019-05-01"</span></span> home_directory = <span class="hljs-string"><span class="hljs-string">'/home/trey'</span></span></code> </pre> <br><p>  Jede Variable zeigt auf eine Linie.  Aber jeder von ihnen hat unterschiedliche Bedeutungen: Der erste ist JSON, der zweite ist das Datum und der dritte ist der Dateipfad. </p><br><p>  Diese Darstellung von Objekten ist etwas n√ºtzlicher: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> datetime <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> date <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path person = {<span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Trey Hunner"</span></span>, <span class="hljs-string"><span class="hljs-string">"location"</span></span>: <span class="hljs-string"><span class="hljs-string">"San Diego"</span></span>} pycon_2019 = date(<span class="hljs-number"><span class="hljs-number">2019</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) home_directory = Path(<span class="hljs-string"><span class="hljs-string">'/home/trey'</span></span>)</code> </pre> <br><p>  JSON-Objekte k√∂nnen in ein W√∂rterbuch deserialisiert werden, Datumsangaben k√∂nnen nativ mit <code>datetime.date</code> werden und <strong>Dateipfadobjekte k√∂nnen als <code>Path</code></strong> </p><br><p>  Durch die Verwendung von <code>Path</code> wird Ihr Code expliziter.  Wenn Sie mit Datumsangaben arbeiten m√∂chten, verwenden Sie <code>date</code> .  Wenn Sie mit Dateipfaden arbeiten m√∂chten, verwenden Sie <code>Path</code> . </p><br><p>  Ich bin kein sehr gro√üer Unterst√ºtzer von OOP.  Klassen f√ºgen eine zus√§tzliche Abstraktionsebene hinzu, und Abstraktionen erschweren manchmal das System, anstatt es zu vereinfachen.  Gleichzeitig glaube ich, dass <code>pathlib.Path</code> eine <strong>n√ºtzliche Abstraktion ist</strong> .  Ziemlich schnell wird es eine akzeptierte Entscheidung. </p><br><p>  Dank <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PEP 519</a> werden <code>Path</code> zum Standard f√ºr die Arbeit mit Pfaden.  Zum Zeitpunkt von Python 3.6 <code>shutil</code> <code>os.path</code> <code>os</code> , <code>shutil</code> und <code>os.path</code> ordnungsgem√§√ü mit diesen Objekten.  <strong>Sie k√∂nnen <code>pathlib</code> zu <code>pathlib</code> wechseln, transparent f√ºr Ihre Codebasis!</strong> </p><br><h3 id="chego-ne-hvataet-v-pathlib">  Was fehlt in <code>pathlib</code> ? </h3><br><p>  <code>pathlib</code> cool, aber nicht umfassend.  Es gibt definitiv <strong>mehrere M√∂glichkeiten, die ich in das Modul aufnehmen m√∂chte</strong> . </p><br><p>  Das erste, was mir in den Sinn kommt, ist das Fehlen von <code>shutil</code> , die <code>shutil</code> .  Obwohl Sie <code>Path</code> als <code>shutil</code> Parameter zum Kopieren / L√∂schen / Verschieben von Dateien und Verzeichnissen √ºbergeben k√∂nnen, k√∂nnen Sie sie nicht als Methoden f√ºr <code>Path</code> Objekte aufrufen. </p><br><p>  Um Dateien zu kopieren, m√ºssen Sie Folgendes tun: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> shutil <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> copyfile source = Path(<span class="hljs-string"><span class="hljs-string">'old_file.txt'</span></span>) destination = Path(<span class="hljs-string"><span class="hljs-string">'new_file.txt'</span></span>) copyfile(source, destination)</code> </pre> <br><p>  Es gibt auch kein Analogon zur <code>os.chdir</code> Methode.  Dies bedeutet, dass Sie es importieren m√ºssen, wenn Sie das aktuelle Verzeichnis √§ndern m√ºssen: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> chdir parent = Path(<span class="hljs-string"><span class="hljs-string">'..'</span></span>) chdir(parent)</code> </pre> <br><p>  Es gibt auch kein √Ñquivalent zur Funktion <code>os.walk</code> .  Obwohl Sie Ihre eigene Funktion im Geiste eines <code>walk</code> ohne allzu gro√üe Schwierigkeiten schreiben k√∂nnen. </p><br><p>  Ich hoffe, dass eines Tages <code>pathlib.Path</code> Objekte Methoden f√ºr einige der genannten Operationen enthalten werden.  Aber selbst in diesem Szenario <strong>finde ich es viel einfacher, <code>pathlib</code> mit etwas anderem zu verwenden, als <code>os.path</code> und alles andere</strong> . </p><br><h3 id="vsegda-li-nuzhno-ispolzovat-pathlib">  Ist es immer notwendig, <code>pathlib</code> zu verwenden? </h3><br><p>  Ab Python 3.6 <strong>funktionieren Pfade fast √ºberall dort, wo Sie Zeichenfolgen verwenden</strong> .  Daher sehe ich keinen Grund <em>,</em> <code>pathlib</code> <em>nicht zu</em> verwenden, wenn Sie Python 3.6 und h√∂her verwenden. </p><br><p>  Wenn Sie eine fr√ºhere Version von Python 3 verwenden, k√∂nnen Sie das <code>Path</code> Objekt jederzeit in einen <code>str</code> Aufruf <code>str</code> , um eine Zeichenfolge <code>str</code> , wenn Sie in das Land der Zeilen zur√ºckkehren m√ºssen.  Das ist nicht zu elegant, aber es funktioniert: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> chdir <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path chdir(Path(<span class="hljs-string"><span class="hljs-string">'/home/trey'</span></span>)) <span class="hljs-comment"><span class="hljs-comment">#   Python 3.6+ chdir(str(Path('/home/trey'))) #     </span></span></code> </pre> <br><h2 id="chast-2-otvety-na-voprosy">  Teil 2. Antworten auf Fragen. </h2><br><p>  Nachdem der erste Teil ver√∂ffentlicht worden war, hatten einige Leute einige Fragen.  Jemand sagte, ich <code>pathlib</code> <code>os.path</code> und <code>pathlib</code> unehrlich verglichen.  Einige sagten, dass die Verwendung von <code>os.path</code> in der Python-Community so tief verwurzelt <code>os.path</code> , dass das Wechseln zu einer neuen Bibliothek sehr lange dauern wird.  Ich habe auch einige Fragen zur Leistung gesehen. </p><br><p>  In diesem Teil m√∂chte ich diese Themen kommentieren.  Dies kann sowohl als <code>pathlib</code> Schutz als auch als Liebesbrief an <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PEP 519 angesehen werden</a> . </p><br><h3 id="sravnenie-ospath-i-pathlib-po-chestnomu">  Vergleichen Sie <code>os.path</code> und <code>pathlib</code> , um ehrlich zu sein </h3><br><p>  Im letzten Teil habe ich die folgenden zwei Codefragmente verglichen: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os.path os.makedirs(os.path.join(<span class="hljs-string"><span class="hljs-string">'src'</span></span>, <span class="hljs-string"><span class="hljs-string">'__pypackages__'</span></span>), exist_ok=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) os.rename(<span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>, os.path.join(<span class="hljs-string"><span class="hljs-string">'src'</span></span>, <span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>))</code> </pre> <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path Path(<span class="hljs-string"><span class="hljs-string">'src/__pypackages__'</span></span>).mkdir(parents=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, exist_ok=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) Path(<span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>).rename(<span class="hljs-string"><span class="hljs-string">'src/.editorconfig'</span></span>)</code> </pre> <br><p>  Dies scheint ein unfairer Vergleich zu sein, da die Verwendung von <code>os.path.join</code> im ersten Beispiel sicherstellt, dass auf allen Plattformen die richtigen Trennzeichen verwendet werden, was ich im zweiten Beispiel nicht getan habe.  Tats√§chlich ist alles in Ordnung, da <strong>Path Pfadtrennzeichen automatisch normalisiert</strong> </p><br><p>  Wir k√∂nnen dies beweisen, indem wir das <code>Path</code> Objekt unter Windows in eine Zeichenfolge konvertieren: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>str(Path(<span class="hljs-string"><span class="hljs-string">'src/__pypackages__'</span></span>)) <span class="hljs-string"><span class="hljs-string">'src\\__pypackages__'</span></span></code> </pre> <br><p>  Es macht keinen Unterschied, ob wir die <code>joinpath</code> Methode, das <code>'/'</code> in der <code>joinpath</code> , den <code>/</code> -Operator (eine weitere nette Funktion von <code>Path</code> ) verwenden oder einzelne Argumente an den Path-Konstruktor √ºbergeben. Wir erhalten das gleiche Ergebnis: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>Path(<span class="hljs-string"><span class="hljs-string">'src'</span></span>, <span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>) WindowsPath(<span class="hljs-string"><span class="hljs-string">'src/.editorconfig'</span></span>) &gt;&gt;&gt; Path(<span class="hljs-string"><span class="hljs-string">'src'</span></span>) / <span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span> WindowsPath(<span class="hljs-string"><span class="hljs-string">'src/.editorconfig'</span></span>) &gt;&gt;&gt; Path(<span class="hljs-string"><span class="hljs-string">'src'</span></span>).joinpath(<span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>) WindowsPath(<span class="hljs-string"><span class="hljs-string">'src/.editorconfig'</span></span>) &gt;&gt;&gt; Path(<span class="hljs-string"><span class="hljs-string">'src/.editorconfig'</span></span>) WindowsPath(<span class="hljs-string"><span class="hljs-string">'src/.editorconfig'</span></span>)</code> </pre> <br><p>  Das letzte Beispiel verursachte einige Verwirrung bei Leuten, die <code>pathlib</code> , <code>pathlib</code> nicht klug genug, um <code>/</code> durch <code>\</code> in der <code>pathlib</code> zu ersetzen.  Zum Gl√ºck ist alles in Ordnung! </p><br><p>  Mit <code>Path</code> m√ºssen Sie sich nicht mehr um die Richtung der Schr√§gstriche k√ºmmern: Definieren Sie alle Ihre Pfade mit <code>/</code> , und das Ergebnis ist f√ºr jede Plattform vorhersehbar. </p><br><h3 id="vy-ne-dolzhny-bespokoitsya-o-normalizacii-putey">  Sie m√ºssen sich nicht um die Normalisierung der Pfade k√ºmmern. </h3><br><p>  Wenn Sie Linux oder Mac ausf√ºhren, ist es sehr einfach, Ihrem Code versehentlich Fehler hinzuzuf√ºgen, die nur Windows-Benutzer betreffen.  Wenn Sie die Verwendung von <code>os.path.join</code> und \ oder <code>os.path.normcase</code> zum Konvertieren von Schr√§gstrichen in f√ºr die aktuelle Plattform geeignete Schr√§gstriche nicht genau √ºberwachen, k√∂nnen <strong>Sie Code schreiben, der unter Windows nicht ordnungsgem√§√ü funktioniert</strong> . </p><br><p>  Hier ist ein Beispiel f√ºr einen Windows-spezifischen Fehler: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os.path directory = <span class="hljs-string"><span class="hljs-string">'.'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> sys.argv[<span class="hljs-number"><span class="hljs-number">1</span></span>:] <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> sys.argv[<span class="hljs-number"><span class="hljs-number">1</span></span>] new_file = os.path.join(directory, <span class="hljs-string"><span class="hljs-string">'new_package/__init__.py'</span></span>)</code> </pre> <br><p>  Dar√ºber hinaus funktioniert ein solcher Code √ºberall korrekt: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path directory = <span class="hljs-string"><span class="hljs-string">'.'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> sys.argv[<span class="hljs-number"><span class="hljs-number">1</span></span>:] <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> sys.argv[<span class="hljs-number"><span class="hljs-number">1</span></span>] new_file = Path(directory, <span class="hljs-string"><span class="hljs-string">'new_package/__init__.py'</span></span>)</code> </pre> <br><p>  Zuvor war der Programmierer f√ºr die Verkettung und Normalisierung von Pfaden verantwortlich, genau wie in Python 2 war der Programmierer f√ºr die Entscheidung verantwortlich, wo Unicode anstelle von Bytes verwendet werden soll.  Dies ist nicht mehr Ihre Aufgabe - <code>Path</code> l√∂st alle diese Probleme f√ºr Sie. </p><br><p>  Ich verwende kein Windows und habe keinen Windows-Computer.  Aber sehr viele Leute, die meinen Code verwenden, werden sehr wahrscheinlich Windows verwenden, und ich m√∂chte, dass alles f√ºr sie richtig funktioniert. </p><br><p>  <strong>Wenn die M√∂glichkeit besteht, dass Ihr Code unter Windows ausgef√ºhrt wird, sollten Sie ernsthaft in Betracht ziehen, auf <code>pathlib</code> .</strong> </p><br><p>  <strong>Machen Sie sich keine Sorgen um die Normalisierung</strong> : Verwenden Sie <code>Path</code> trotzdem, wenn es um Dateipfade geht. </p><br><h3 id="zvuchit-klassno-no-u-menya-storonnyaya-biblioteka-kotoraya-ne-ispolzuet-pathlib">  Klingt cool, aber ich habe eine Drittanbieter-Bibliothek, die kein <code>pathlib</code> ! </h3><br><p>  Sie haben eine gro√üe Codebasis, die mit Zeichenfolgen als Pfaden arbeitet.  Warum zu <code>pathlib</code> wechseln, wenn das bedeutet, dass alles neu geschrieben werden muss? </p><br><p>  Stellen wir uns vor, Sie haben folgende Funktion: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os.path <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_editorconfig</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dir_path)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""Create .editorconfig file in given directory and return filename."""</span></span> filename = os.path.join(dir_path, <span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> os.path.exists(filename): os.makedirs(dir_path, exist_ok=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) open(filename, mode=<span class="hljs-string"><span class="hljs-string">'wt'</span></span>).write(<span class="hljs-string"><span class="hljs-string">''</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> filename</code> </pre> <br><p>  Die Funktion nimmt ein Verzeichnis und erstellt dort eine <code>.editorconfig</code> Datei, <code>.editorconfig</code> so: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os.path &gt;&gt;&gt; make_editorconfig(os.path.join(<span class="hljs-string"><span class="hljs-string">'src'</span></span>, <span class="hljs-string"><span class="hljs-string">'my_package'</span></span>)) <span class="hljs-string"><span class="hljs-string">'src/my_package/.editorconfig'</span></span></code> </pre> <br><p>  Wenn Sie die Zeilen durch <code>Path</code> ersetzen, funktioniert auch alles: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path &gt;&gt;&gt; make_editorconfig(Path(<span class="hljs-string"><span class="hljs-string">'src/my_package'</span></span>)) <span class="hljs-string"><span class="hljs-string">'src/my_package/.editorconfig'</span></span></code> </pre> <br><p>  Aber wie? </p><br><p>  <code>os.path.join</code> akzeptiert <code>os.path.join</code> (seit Python 3.6).  Gleiches gilt f√ºr <code>os.makedirs</code> . <br>  Tats√§chlich akzeptiert die integrierte <code>open</code> Funktion <code>Path</code> , <code>shutil</code> akzeptiert <code>Path</code> und alles in der Standardbibliothek, das zum Akzeptieren von Strings verwendet wird, sollte jetzt sowohl mit <code>Path</code> als auch mit Strings funktionieren. </p><br><p>  Wir sollten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PEP 519 daf√ºr</a> danken, das die abstrakte Klasse <code>os.PathLike</code> und ank√ºndigte, dass alle integrierten Dienstprogramme f√ºr die Arbeit mit Dateipfaden jetzt sowohl mit Zeichenfolgen als auch mit <code>Path</code> funktionieren sollten. </p><br><h3 id="no-v-moey-lyubimoy-biblioteke-est-path-luchshe-standartnogo">  Aber meine Lieblingsbibliothek hat Path, besser als der Standard! </h3><br><p>  M√∂glicherweise verwenden Sie bereits eine Bibliothek eines Drittanbieters, die die <code>Path</code> bereitstellt, die sich von der Standardbibliothek unterscheidet.  Vielleicht magst du sie mehr. </p><br><p>  Zum Beispiel enthalten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">django-environ</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">path.py</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">plumbum</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">visidata jeweils</a> ihre eigenen <code>Path</code> Objekte.  Einige dieser Bibliotheken sind √§lter als <code>pathlib</code> und haben beschlossen, von <code>str</code> zu erben, damit sie an Funktionen √ºbergeben werden k√∂nnen, die Strings als Pfade erwarten.  Dank PEP 519 ist die Integration von Bibliotheken von Drittanbietern in Ihren Code einfacher und ohne die Notwendigkeit einer Vererbung von <code>str</code> . </p><br><p>  Stellen wir uns vor, Sie m√∂chten <code>pathlib</code> nicht verwenden, da <code>Path</code> unver√§nderliche Objekte sind und Sie ihren Status wirklich wirklich √§ndern m√∂chten.  Mit PEP 519 k√∂nnen Sie Ihre beste ver√§nderbare Version von <code>Path</code> erstellen.  Implementieren Sie dazu einfach die Methode <code>__fspath__</code> </p><br><p>  Jede selbstgeschriebene Implementierung von <code>Path</code> kann jetzt nativ mit in Python integrierten Funktionen arbeiten, die Dateipfade erwarten.  <strong>Auch wenn Sie <code>pathlib</code> nicht m√∂gen, ist die Tatsache, dass es existiert, ein gro√ües Plus f√ºr Bibliotheken von Drittanbietern mit eigenem <code>Path</code></strong> </p><br><h3 id="no-ved-pathlibpath-i-str-ne-smeshivayutsya-pravda">  Aber <code>pathlib.Path</code> und <code>str</code> mischen sich nicht, oder? </h3><br><p>  Sie denken wahrscheinlich: Das ist nat√ºrlich alles gro√üartig, aber wird dieser Ansatz mit manchmal Zeilen und manchmal Pfaden meinem Code etwas Komplexit√§t verleihen? </p><br><p>  Die Antwort auf diese Frage lautet bis zu einem gewissen Grad ja.  Dieses Problem hat jedoch eine ziemlich einfache Problemumgehung. </p><br><p>  PEP 519 hat neben <code>PathLike</code> noch einige weitere Dinge <code>PathLike</code> : Erstens k√∂nnen Sie <code>PathLike</code> in eine Zeichenfolge konvertieren, und zweitens k√∂nnen Sie <code>PathLike</code> in einen <code>Path</code> <code>PathLike</code> . </p><br><p>  Nehmen wir zwei Objekte - einen String und einen <code>Path</code> (oder was auch immer mit der <strong>fspath-</strong> Methode): </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os.path p1 = os.path.join(<span class="hljs-string"><span class="hljs-string">'src'</span></span>, <span class="hljs-string"><span class="hljs-string">'my_package'</span></span>) p2 = Path(<span class="hljs-string"><span class="hljs-string">'src/my_package'</span></span>)</code> </pre> <br><p>  Die Funktion <code>os.fspath</code> normalisiert beide Objekte und <code>os.fspath</code> sie in Zeichenfolgen um: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> fspath &gt;&gt;&gt; fspath(p1), fspath(p2) (<span class="hljs-string"><span class="hljs-string">'src/my_package'</span></span>, <span class="hljs-string"><span class="hljs-string">'src/my_package'</span></span>)</code> </pre> <br><p>  In diesem Fall kann <code>Path</code> beide Objekte in einen Konstruktor aufnehmen und in <code>Path</code> konvertieren: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>Path(p1), Path(p2) (PosixPath(<span class="hljs-string"><span class="hljs-string">'src/my_package'</span></span>), PosixPath(<span class="hljs-string"><span class="hljs-string">'src/my_package'</span></span>))</code> </pre> <br><p>  Dies bedeutet, dass Sie das Ergebnis von <code>make_editorconfig</code> bei <code>make_editorconfig</code> wieder in <code>Path</code> konvertieren k√∂nnen: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path &gt;&gt;&gt; Path(make_editorconfig(Path(<span class="hljs-string"><span class="hljs-string">'src/my_package'</span></span>))) PosixPath(<span class="hljs-string"><span class="hljs-string">'src/my_package/.editorconfig'</span></span>)</code> </pre> <br><p>  Die beste L√∂sung w√§re nat√ºrlich, <code>make_editorconfig</code> mit <code>pathlib</code> neu zu schreiben. </p><br><h3 id="pathlib-slishkom-medlennyy">  <code>pathlib</code> zu langsam </h3><br><p>  Ich habe mehrmals √ºber <code>pathlib</code> Leistung von <code>pathlib</code> .  Es ist wahr - <code>pathlib</code> kann langsam sein.  Das Erstellen von Tausenden von <code>Path</code> kann das Programmverhalten erheblich beeinflussen. </p><br><p>  Ich habe beschlossen, die Leistung von <code>pathlib</code> und <code>os.path</code> auf meinem Computer mit zwei verschiedenen Programmen zu messen, die nach allen <code>.py</code> Dateien im aktuellen Verzeichnis suchen </p><br><p>  Hier ist die Version von <code>os.walk</code> : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> getcwd, walk extension = <span class="hljs-string"><span class="hljs-string">'.py'</span></span> count = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> root, directories, filenames <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> walk(getcwd()): <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> filename <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> filenames: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> filename.endswith(extension): count += <span class="hljs-number"><span class="hljs-number">1</span></span> print(<span class="hljs-string"><span class="hljs-string">f"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{count}</span></span></span><span class="hljs-string"> Python files found"</span></span>)</code> </pre> <br><p>  Und hier ist die Version mit <code>Path.rglob</code> : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path extension = <span class="hljs-string"><span class="hljs-string">'.py'</span></span> count = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> filename <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Path.cwd().rglob(<span class="hljs-string"><span class="hljs-string">f'*</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{extension}</span></span></span><span class="hljs-string">'</span></span>): count += <span class="hljs-number"><span class="hljs-number">1</span></span> print(<span class="hljs-string"><span class="hljs-string">f"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{count}</span></span></span><span class="hljs-string"> Python files found"</span></span>)</code> </pre> <br><p>  Das Testen der Leistung von Programmen, die mit dem Dateisystem arbeiten, ist eine schwierige Aufgabe, da sich die Betriebszeit erheblich √§ndern kann.  Ich habe beschlossen, jedes Skript zehnmal auszuf√ºhren und die besten Ergebnisse f√ºr jedes Programm zu vergleichen. </p><br><p>  Beide Programme haben 97507 Dateien in dem Verzeichnis gefunden, in dem ich sie ausgef√ºhrt habe.  Der erste arbeitete in 1,914 Sekunden, der zweite in 3,430 Sekunden. </p><br><p>  Wenn ich den Parameter <code>extension=''</code> setze, finden diese Programme ungef√§hr 600.000 Dateien, und der Unterschied nimmt zu.  Das erste Programm arbeitete in 1,888 Sekunden und das zweite in 7,485 Sekunden. </p><br><p>  Daher ist <code>pathlib</code> f√ºr Dateien mit der Erweiterung <code>.py</code> etwa <strong>doppelt so</strong> langsam und beim <code>pathlib</code> in meinem Home-Verzeichnis <strong>viermal langsamer</strong> .  Die relative Leistungsl√ºcke zwischen <code>pathlib</code> und <code>pathlib</code> ist <code>pathlib</code> . </p><br><p>  In meinem Fall √§ndert sich diese Geschwindigkeit nicht viel.  Ich habe alle Dateien in meinem Verzeichnis durchsucht und 6 Sekunden verloren.  Wenn ich die Aufgabe h√§tte, 10 Millionen Dateien zu verarbeiten, w√ºrde ich sie h√∂chstwahrscheinlich neu schreiben.  Aber w√§hrend es keine solche Notwendigkeit gibt, k√∂nnen Sie warten. </p><br><p>  Wenn Sie einen hei√üen Code haben und <code>pathlib</code> den Betrieb offensichtlich negativ beeinflusst, ist es nichts Falsches, ihn durch eine Alternative zu ersetzen.  <strong>Sie sollten den Code nicht optimieren, was kein Engpass ist</strong> - dies ist eine zus√§tzliche Zeitverschwendung, die normalerweise auch zu schlecht lesbarem Code ohne viel Auspuff f√ºhrt. </p><br><h3 id="uluchshenie-chitaemosti">  Verbesserung der Lesbarkeit </h3><br><p>  Ich m√∂chte diesen Gedankenstrom mit einigen Refactoring-Beispielen unter Verwendung von <code>pathlib</code> .  Ich habe ein paar kleine Beispiele f√ºr Code genommen, der mit Dateien funktioniert, und sie mit <code>pathlib</code> arbeiten <code>pathlib</code> .  Ich werde den gr√∂√üten Teil des Codes ohne Kommentar zu Ihrem Gericht hinterlassen - entscheiden Sie, welche Version Ihnen am besten gef√§llt. </p><br><p>  Hier ist die Funktion <code>make_editorconfig</code> , die wir zuvor gesehen haben: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os.path <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_editorconfig</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dir_path)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""Create .editorconfig file in given directory and return filename."""</span></span> filename = os.path.join(dir_path, <span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> os.path.exists(filename): os.makedirs(dir_path, exist_ok=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) open(filename, mode=<span class="hljs-string"><span class="hljs-string">'wt'</span></span>).write(<span class="hljs-string"><span class="hljs-string">''</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> filename</code> </pre> <br><p>  Und hier ist die in <code>pathlib</code> umgeschriebene <code>pathlib</code> : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_editorconfig</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dir_path)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""Create .editorconfig file in given directory and return filepath."""</span></span> path = Path(dir_path, <span class="hljs-string"><span class="hljs-string">'.editorconfig'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> path.exists(): path.parent.mkdir(exist_ok=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, parent=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) path.touch() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> path</code> </pre> <br><p>  Hier ist ein Konsolenprogramm, das eine Zeile mit einem Verzeichnis erstellt und den Inhalt einer <code>.gitignore</code> Datei <code>.gitignore</code> , falls vorhanden: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os.path <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys directory = sys.argv[<span class="hljs-number"><span class="hljs-number">1</span></span>] ignore_filename = os.path.join(directory, <span class="hljs-string"><span class="hljs-string">'.gitignore'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> os.path.isfile(ignore_filename): <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(ignore_filename, mode=<span class="hljs-string"><span class="hljs-string">'rt'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ignore_file: print(ignore_file.read(), end=<span class="hljs-string"><span class="hljs-string">''</span></span>)</code> </pre> <br><p>  Gleiches gilt f√ºr <code>pathlib</code> : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys directory = Path(sys.argv[<span class="hljs-number"><span class="hljs-number">1</span></span>]) ignore_path = directory / <span class="hljs-string"><span class="hljs-string">'.gitignore'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ignore_path.is_file(): print(ignore_path.read_text(), end=<span class="hljs-string"><span class="hljs-string">''</span></span>)</code> </pre> <br><p>  Hier ist ein Programm, das alle doppelten Dateien im aktuellen Ordner und in den Unterordnern druckt: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> collections <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> defaultdict <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> hashlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> md5 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> getcwd, walk <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os.path <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">find_files</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(filepath)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> root, directories, filenames <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> walk(filepath): <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> filename <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> filenames: <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> os.path.join(root, filename) file_hashes = defaultdict(list) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> path <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> find_files(getcwd()): <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(path, mode=<span class="hljs-string"><span class="hljs-string">'rb'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> my_file: file_hash = md5(my_file.read()).hexdigest() file_hashes[file_hash].append(path) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> paths <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> file_hashes.values(): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(paths) &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>: print(<span class="hljs-string"><span class="hljs-string">"Duplicate files found:"</span></span>) print(*paths, sep=<span class="hljs-string"><span class="hljs-string">'\n'</span></span>)</code> </pre> <br><p>  Gleiches gilt f√ºr c <code>pathlib</code> : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> collections <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> defaultdict <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> hashlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> md5 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">find_files</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(filepath)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> path <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Path(filepath).rglob(<span class="hljs-string"><span class="hljs-string">'*'</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> path.is_file(): <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> path file_hashes = defaultdict(list) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> path <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> find_files(Path.cwd()): file_hash = md5(path.read_bytes()).hexdigest() file_hashes[file_hash].append(path) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> paths <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> file_hashes.values(): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(paths) &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>: print(<span class="hljs-string"><span class="hljs-string">"Duplicate files found:"</span></span>) print(*paths, sep=<span class="hljs-string"><span class="hljs-string">'\n'</span></span>)</code> </pre><br><p>  , , -,     .       <code>pathlib</code> . </p><br><h3 id="nachnite-ispolzovat-obekty-pathlibpath">    <code>pathlib.Path</code> </h3><br><p>  . </p><br><p>  <code>/</code>   <code>pathlib.Path</code>         .   ,    <strong>      </strong> . </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>path1 = Path(<span class="hljs-string"><span class="hljs-string">'dir'</span></span>, <span class="hljs-string"><span class="hljs-string">'file'</span></span>) &gt;&gt;&gt; path2 = Path(<span class="hljs-string"><span class="hljs-string">'dir'</span></span>) / <span class="hljs-string"><span class="hljs-string">'file'</span></span> &gt;&gt;&gt; path3 = Path(<span class="hljs-string"><span class="hljs-string">'dir/file'</span></span>) &gt;&gt;&gt; path3 WindowsPath(<span class="hljs-string"><span class="hljs-string">'dir/file'</span></span>) &gt;&gt;&gt; path1 == path2 == path3 <span class="hljs-keyword"><span class="hljs-keyword">True</span></span></code> </pre> <br><p>   Python  (. <code>open</code> )   <code>Path</code> ,  ,  <strong>   <code>pathlib</code> ,        !</strong> </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> shutil <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> move <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rename_and_redirect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(old_filename, new_filename)</span></span></span><span class="hljs-function">:</span></span> move(old, new) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(old, mode=<span class="hljs-string"><span class="hljs-string">'wt'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f: f.write(<span class="hljs-string"><span class="hljs-string">f'This file has moved to </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{new}</span></span></span><span class="hljs-string">'</span></span>)</code> </pre> <br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path &gt;&gt;&gt; old, new = Path(<span class="hljs-string"><span class="hljs-string">'old.txt'</span></span>), Path(<span class="hljs-string"><span class="hljs-string">'new.txt'</span></span>) &gt;&gt;&gt; rename_and_redirect(old, new) &gt;&gt;&gt; old.read_text() <span class="hljs-string"><span class="hljs-string">'This file has moved to new.txt'</span></span></code> </pre> <br><p>      <code>pathlib</code> ,     ,    <code>PathLike</code> .  ,   <strong>      ,       ,   PEP 519</strong> . </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> plumbum <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path &gt;&gt;&gt; my_path = Path(<span class="hljs-string"><span class="hljs-string">'old.txt'</span></span>) &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(my_path) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f: ... print(f.read()) ... This file has moved to new.txt</code> </pre> <br><p>   <code>pathlib</code>    ,      (  ,    ),    <strong>         ,   </strong> . </p><br><p>  , <code>pathlib</code>     .       Python     : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pathlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Path gitignore = Path(<span class="hljs-string"><span class="hljs-string">'.gitignore'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> gitignore.is_file(): print(gitignore.read_text(), end=<span class="hljs-string"><span class="hljs-string">''</span></span>)</code> </pre> <br><p>  <code>pathlib</code> ‚Äî .    ! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de453862/">https://habr.com/ru/post/de453862/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de453846/index.html">Die Zusammenfassung der Ereignisse f√ºr HR-Fachkr√§fte im Bereich IT f√ºr Juni 2019</a></li>
<li><a href="../de453848/index.html">AlphaFold: Verwenden von KI f√ºr wissenschaftliche Entdeckungen</a></li>
<li><a href="../de453850/index.html">Chinesisches Sozialkreditsystem - Ist der Teufel so schrecklich?</a></li>
<li><a href="../de453852/index.html">Microbiota. Wie man sich um Darmbakterien k√ºmmert</a></li>
<li><a href="../de453860/index.html">AMD stellte seine neuen kundenspezifischen 7-nm-Prozessoren Ryzen der dritten Generation vor</a></li>
<li><a href="../de453864/index.html">Das Verwenden einer Maus und einer Tastatur auf Konsolen ist Betrug?</a></li>
<li><a href="../de453866/index.html">API-Anfrage mit React Hooks, HOC oder Render Prop</a></li>
<li><a href="../de453868/index.html">Ber√ºhren Sie den Mini-Schalter mit Glasscheibe am nRF52832</a></li>
<li><a href="../de453870/index.html">Wir schreiben Reverse socks5 Proxy auf Powershell. Teil 1</a></li>
<li><a href="../de453872/index.html">Wiederherstellen von Fotos mithilfe neuronaler Netze</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>