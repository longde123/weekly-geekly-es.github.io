<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§∞üèæ üè® üë®üèΩ‚Äç‚úàÔ∏è RESTinio √© um servidor HTTP ass√≠ncrono. Um exemplo simples da pr√°tica: retornando uma grande quantidade de dados em resposta üñ≤Ô∏è üëéüèª ü§æüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recentemente, trabalhei em um aplicativo que deveria controlar a velocidade de suas conex√µes de sa√≠da. Por exemplo, ao conectar-se a um URL, o aplicat...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>RESTinio √© um servidor HTTP ass√≠ncrono. Um exemplo simples da pr√°tica: retornando uma grande quantidade de dados em resposta</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/462349/"><p><img src="https://habrastorage.org/webt/a6/kc/zt/a6kcztqtbqzp5shvd5wcz-8zzl0.jpeg"></p><br><p>  Recentemente, trabalhei em um aplicativo que deveria controlar a velocidade de suas conex√µes de sa√≠da.  Por exemplo, ao conectar-se a um URL, o aplicativo deve se limitar a, digamos, 200KiB / s.  E conectando-se a outro URL - apenas 30KiB / s. </p><br><p>  O ponto mais interessante aqui foi testar essas mesmas limita√ß√µes.  Eu precisava de um servidor HTTP que desse tr√°fego a uma determinada velocidade, por exemplo, 512KiB / s.  Ent√£o eu pude ver se o aplicativo realmente suporta a velocidade de 200KiB / s ou se ele quebra em velocidades mais altas. </p><br><p>  Mas onde conseguir um servidor HTTP? </p><br><p>  Como tenho algo a ver com o servidor HTTP <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">RESTinio</a> incorporado em aplicativos C ++, n√£o consegui nada melhor do que jogar rapidamente um simples servidor de teste HTTP no meu joelho, que pode enviar um longo fluxo de dados de sa√≠da para o cliente. </p><br><p>  Sobre como seria simples e gostaria de dizer no artigo.  Ao mesmo tempo, descubra nos coment√°rios se isso √© realmente simples ou se estou me enganando.  Em princ√≠pio, este artigo pode ser considerado uma continua√ß√£o do artigo anterior sobre o RESTinio chamado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">"RESTinio √© um servidor HTTP ass√≠ncrono. Ass√≠ncrono"</a> .  Portanto, se algu√©m estiver interessado em ler sobre a aplica√ß√£o real, embora n√£o muito s√©ria do RESTinio, voc√™ ser√° bem-vindo ao gato. </p><a name="habracut"></a><br><h1 id="obschaya-ideya">  Ideia geral </h1><br><p>  A id√©ia geral do servidor de teste mencionado acima √© muito simples: quando o cliente se conecta ao servidor e executa uma solicita√ß√£o HTTP GET, √© ativado um timer que √© executado uma vez por segundo.  Quando o timer √© acionado, o pr√≥ximo bloco de dados de um determinado tamanho √© enviado ao cliente. </p><br><h2 id="no-vse-neskolko-slozhnee">  Mas tudo √© um pouco mais complicado </h2><br><p>  Se o cliente ler os dados em uma taxa mais lenta do que o servidor envia, apenas enviar N kilobytes uma vez por segundo n√£o √© uma boa ideia.  Como os dados come√ßar√£o a se acumular no soquete e isso n√£o levar√° a nada de bom. </p><br><p>  Portanto, ao enviar dados, √© aconselh√°vel controlar a prontid√£o do soquete para gravar no lado do servidor HTTP.  Enquanto o soquete estiver pronto (ou seja, muitos dados ainda n√£o foram acumulados), voc√™ poder√° enviar uma nova parte.  Mas se n√£o estiver pronto, √© necess√°rio aguardar at√© que o soquete entre em um estado de prontid√£o para a grava√ß√£o. </p><br><p>  Parece razo√°vel, mas as opera√ß√µes de E / S est√£o ocultas nos grupos do RESTinio ... Como descobrir se a pr√≥xima parte dos dados pode ser gravada ou n√£o? </p><br><p>  Voc√™ pode sair dessa situa√ß√£o se usar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">notificadores p√≥s-grava√ß√£o</a> , que est√£o no RESTinio.  Por exemplo, podemos escrever isso: </p><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">request_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(restinio::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">request_handle_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> req)</span></span></span><span class="hljs-function"> </span></span>{ req-&gt;create_response() <span class="hljs-comment"><span class="hljs-comment">//   . ... //   . .done([](const auto &amp; ec) { ... //         . }); }</span></span></code> </pre> <br><p>  O lambda passado para o m√©todo <code>done()</code> ser√° chamado quando o RESTinio concluir a grava√ß√£o dos dados de sa√≠da.  Portanto, se o soquete n√£o estiver pronto para grava√ß√£o por algum tempo, o lambda n√£o ser√° chamado imediatamente, mas depois que o soquete chegar ao seu estado adequado e aceitar todos os dados de sa√≠da. </p><br><p>  Com o uso de notificadores p√≥s-grava√ß√£o, a l√≥gica do servidor de teste ser√° a seguinte: </p><br><ul><li>  envie o pr√≥ximo lote de dados, calcule o tempo em que precisar√≠amos enviar o pr√≥ximo lote no curso normal dos eventos; </li><li>  penduramos depois de escrever o notificador na pr√≥xima por√ß√£o de dados; </li><li>  quando a notifica√ß√£o de p√≥s-grava√ß√£o √© chamada, verificamos se o pr√≥ximo lote chegou.  Se isso acontecer, inicie imediatamente o envio da pr√≥xima parte.  Caso contr√°rio, acione o cron√¥metro. </li></ul><br><p>  Como resultado, acontece que, assim que a grava√ß√£o come√ßar a desacelerar, o envio de novos dados ser√° pausado.  E continue quando o soquete estiver pronto para aceitar novos dados de sa√≠da. </p><br><h2 id="i-esche-nemnogo-slozhnogo-chunked_output">  E um pouco mais complicado: chunked_output </h2><br><p>  O RESTinio suporta <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tr√™s maneiras de gerar uma resposta a uma solicita√ß√£o HTTP</a> .  O m√©todo mais simples, usado por padr√£o, n√£o √© adequado neste caso, porque  Preciso de um fluxo quase intermin√°vel de dados enviados.  E esse fluxo, √© claro, n√£o pode ser <code>set_body</code> para uma √∫nica chamada para o m√©todo <code>set_body</code> . </p><br><p>  Portanto, o servidor de teste descrito usa o chamado  <em>chunked_output</em> .  I.e.  ao criar uma resposta, indico ao RESTinio que a resposta ser√° formada em partes.  Ent√£o, periodicamente, chamo os m√©todos <code>append_chunk</code> para adicionar a pr√≥xima parte √† resposta e <code>flush</code> para escrever as partes acumuladas no soquete. </p><br><h1 id="a-davayte-uzhe-posmotrim-v-kod">  E vamos olhar para o c√≥digo! </h1><br><p>  Talvez seja suficiente que as palavras de abertura sejam suficientes e esteja na hora de seguir para o pr√≥prio c√≥digo, que pode ser encontrado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">neste reposit√≥rio</a> .  Vamos come√ßar com a fun√ß√£o <code>request_processor</code> , chamada para processar cada solicita√ß√£o HTTP v√°lida.  Ao mesmo tempo, vamos nos aprofundar nas fun√ß√µes que s√£o chamadas de <code>request_processor</code> .  Bem, veremos como exatamente o <code>request_processor</code> √© mapeado para uma ou outra solicita√ß√£o HTTP recebida. </p><br><h2 id="funkciya-request_processor-i-eyo-podruchnye">  Fun√ß√£o Request_processor e seus auxiliares </h2><br><p>  A fun√ß√£o <code>request_processor</code> √© chamada para processar as solicita√ß√µes HTTP GET que eu preciso.  √â passado como argumentos: </p><br><ul><li>  Asio-shny io_context no qual todo o trabalho √© realizado (ser√° necess√°rio, por exemplo, para temporizadores de armar); </li><li>  o tamanho de uma parte da resposta.  I.e.  se eu precisar fornecer um fluxo de sa√≠da a uma taxa de 512KiB / s, o valor 512KiB ser√° passado como esse par√¢metro; </li><li>  n√∫mero de pe√ßas em resposta.  Caso o fluxo tenha um comprimento limitado.  Por exemplo, se voc√™ deseja fornecer um fluxo a uma taxa de 512 KiB / s por 5 minutos, o valor 300 ser√° passado como esse par√¢metro (60 blocos por minuto por 5 minutos); </li><li>  Bem, a pr√≥pria solicita√ß√£o de entrada para processamento. </li></ul><br><p>  Dentro de <code>request_processor</code> , um objeto √© criado com informa√ß√µes sobre a solicita√ß√£o e seus par√¢metros de processamento, ap√≥s o qual esse mesmo processamento come√ßa: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">request_processor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( asio_ns::io_context &amp; ctx, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> chunk_size, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> count, restinio::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">request_handle_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> req)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> data = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt;response_data&gt;( ctx, chunk_size, req-&gt;create_response&lt;<span class="hljs-keyword"><span class="hljs-keyword">output_t</span></span>&gt;(), count); data-&gt;response_ .append_header(restinio::http_field::server, <span class="hljs-string"><span class="hljs-string">"RESTinio"</span></span>) .append_header_date_field() .append_header( restinio::http_field::content_type, <span class="hljs-string"><span class="hljs-string">"text/plain; charset=utf-8"</span></span>) .flush(); send_next_portion(data); }</code> </pre> <br><p>  O tipo <code>response_data</code> , contendo todos os par√¢metros relacionados √† solicita√ß√£o, tem a seguinte apar√™ncia: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">response_data</span></span></span><span class="hljs-class"> {</span></span> asio_ns::io_context &amp; io_ctx_; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> chunk_size_; <span class="hljs-keyword"><span class="hljs-keyword">response_t</span></span> response_; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> counter_; response_data( asio_ns::io_context &amp; io_ctx, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> chunk_size, <span class="hljs-keyword"><span class="hljs-keyword">response_t</span></span> response, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> counter) : io_ctx_{io_ctx} , chunk_size_{chunk_size} , response_{<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(response)} , counter_{counter} {} };</code> </pre> <br><p>  Deve-se observar aqui que uma das raz√µes para a apar√™ncia da estrutura <code>response_data</code> √© que um objeto do tipo <code>restinio::response_builder_t&lt;restinio::chunked_output_t&gt;</code> (ou seja, esse tipo est√° oculto por tr√°s do apelido curto <code>response_t</code> ) √© um tipo m√≥vel, mas n√£o um tipo copi√°vel (por analogias com <code>std::unique_ptr</code> ).  Portanto, esse objeto n√£o pode ser capturado apenas em uma fun√ß√£o lambda, que se <code>std::function</code> na <code>std::function</code> .  Mas se voc√™ colocar o objeto de resposta em uma inst√¢ncia criada dinamicamente de <code>response_data</code> , o ponteiro inteligente para a inst√¢ncia <code>reponse_data</code> j√° <code>reponse_data</code> ser capturado nas fun√ß√µes lambda sem problemas e salve esse lambda na <code>std::function</code> . </p><br><h3 id="funkciya-send_next_portion">  Fun√ß√£o Send_next_portion </h3><br><p>  A fun√ß√£o <code>send_next_portion</code> chamada sempre que √© necess√°rio enviar a pr√≥xima parte da resposta ao cliente.  Nada de complicado acontece nele, ent√£o parece bastante simples e conciso: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send_next_portion</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(response_data_shptr data)</span></span></span><span class="hljs-function"> </span></span>{ data-&gt;response_.append_chunk(make_buffer(data-&gt;chunk_size_)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-number"><span class="hljs-number">1u</span></span> == data-&gt;counter_) { data-&gt;response_.flush(); data-&gt;response_.done(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { data-&gt;counter_ -= <span class="hljs-number"><span class="hljs-number">1u</span></span>; data-&gt;response_.flush(make_done_handler(data)); } }</code> </pre> <br><p>  I.e.  envie a pr√≥xima parte.  E, se essa parte foi a √∫ltima, conclu√≠mos o processamento da solicita√ß√£o.  E, se n√£o o √∫ltimo, um <code>flush</code> √© enviado ao m√©todo <code>flush</code> , que √© criado, talvez, pela fun√ß√£o mais complexa deste exemplo. </p><br><h3 id="funkciya-make_done_handler">  Fun√ß√£o make_done_handler </h3><br><p>  A fun√ß√£o <code>make_done_handler</code> respons√°vel por criar um lambda que ser√° passado para o RESTinio como um notificador p√≥s-grava√ß√£o.  Este notificador deve verificar se a grava√ß√£o da pr√≥xima parte da resposta foi conclu√≠da com √™xito.  Se sim, voc√™ precisa descobrir se a pr√≥xima parte deve ser enviada imediatamente (ou seja, houve "freios" no soquete e a taxa de envio n√£o pode ser mantida) ou ap√≥s uma pausa.  Se voc√™ precisar de uma pausa, ela ser√° fornecida atrav√©s de um temporizador de armar. </p><br><p>  Em geral, a√ß√µes simples, mas no c√≥digo, voc√™ obt√©m o lambda dentro do lambda, o que pode confundir pessoas que n√£o est√£o acostumadas ao C ++ "moderno".  O que n√£o √© t√£o poucos anos para ser chamado de moderno;) </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_done_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(response_data_shptr data)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> next_timepoint = steady_clock::now() + <span class="hljs-number"><span class="hljs-number">1</span></span>s; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [=](<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp; ec) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!ec) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> now = steady_clock::now(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(now &lt; next_timepoint) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> timer = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt;asio_ns::steady_timer&gt;(data-&gt;io_ctx_); timer-&gt;expires_after(next_timepoint - now); timer-&gt;async_wait([timer, data](<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp; ec) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!ec) send_next_portion(data); }); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> data-&gt;io_ctx_.post([data] { send_next_portion(data); }); } }; }</code> </pre> <br><p>  Na minha opini√£o, a principal dificuldade desse c√≥digo decorre das peculiaridades da cria√ß√£o e pelot√£o de temporizadores no Asio.  Na minha opini√£o, acontece de alguma maneira muito detalhado.  Mas realmente existe.  Mas voc√™ n√£o precisa atrair nenhuma biblioteca adicional. </p><br><h2 id="podklyuchenie-express-like-routera">  Conectando um roteador do tipo expresso </h2><br><p>  O <code>request_processor</code> , <code>send_next_portion</code> e <code>make_done_handler</code> mostrados acima, <code>send_next_portion</code> <code>make_done_handler</code> a primeira vers√£o do meu servidor de teste, escrita literalmente em 15 ou 20 minutos. </p><br><p>  Por√©m, ap√≥s alguns dias de uso desse servidor de teste, houve uma s√©ria desvantagem: sempre retornava o fluxo de resposta na mesma velocidade.  Compilado a uma velocidade de 512 KiB / s - fornece todos os 512 KiB / s.  Recompilado a uma velocidade de 20KiB / s - dar√° a todos 20KiB / s e nada mais.  O que foi inconveniente, porque  tornou-se necess√°rio poder receber respostas de diferentes "espessuras". </p><br><p>  Ent√£o surgiu a ideia: e se a velocidade de retorno for solicitada diretamente no URL?  Por exemplo, eles fizeram uma solicita√ß√£o ao <code>localhost:8080/</code> e receberam uma resposta em uma velocidade predeterminada.  E se voc√™ fez uma solicita√ß√£o ao <code>localhost:8080/128K</code> , eles come√ßaram a receber uma resposta a uma velocidade de 128KiB / s. </p><br><p>  Depois, o pensamento foi ainda mais longe: na URL, voc√™ tamb√©m pode especificar o n√∫mero de partes individuais na resposta.  I.e.  solicita√ß√£o <code>localhost:8080/128K/3000</code> produzir√° um fluxo de 3000 partes a uma velocidade de 128KiB / s. </p><br><p>  N√£o tem problema  O RESTinio tem a capacidade de usar um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">roteador de consulta feito sob a influ√™ncia do ExpressJS</a> .  Como resultado, havia uma fun√ß√£o para descrever manipuladores para solicita√ß√µes HTTP recebidas: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_router</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(asio_ns::io_context &amp; ctx)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> router = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_unique&lt;<span class="hljs-keyword"><span class="hljs-keyword">router_t</span></span>&gt;(); router-&gt;http_get(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, [&amp;ctx](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> req, <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>) { request_processor(ctx, <span class="hljs-number"><span class="hljs-number">100u</span></span>*<span class="hljs-number"><span class="hljs-number">1024u</span></span>, <span class="hljs-number"><span class="hljs-number">10000u</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(req)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> restinio::request_accepted(); }); router-&gt;http_get( <span class="hljs-string"><span class="hljs-string">R"(/:value(\d+):multiplier([MmKkBb]?))"</span></span>, [&amp;ctx](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> req, <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> params) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> chunk_size = extract_chunk_size(params); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-number"><span class="hljs-number">0u</span></span> != chunk_size) { request_processor(ctx, chunk_size, <span class="hljs-number"><span class="hljs-number">10000u</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(req)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> restinio::request_accepted(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> restinio::request_rejected(); }); router-&gt;http_get( <span class="hljs-string"><span class="hljs-string">R"(/:value(\d+):multiplier([MmKkBb]?)/:count(\d+))"</span></span>, [&amp;ctx](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> req, <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> params) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> chunk_size = extract_chunk_size(params); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> count = restinio::cast_to&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>&gt;(params[<span class="hljs-string"><span class="hljs-string">"count"</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-number"><span class="hljs-number">0u</span></span> != chunk_size &amp;&amp; <span class="hljs-number"><span class="hljs-number">0u</span></span> != count) { request_processor(ctx, chunk_size, count, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(req)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> restinio::request_accepted(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> restinio::request_rejected(); }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> router; }</code> </pre> <br><p>  Aqui, os manipuladores de solicita√ß√£o HTTP GET s√£o formados para tr√™s tipos de URLs: </p><br><ul><li>  no formato <code>http://localhost/</code> ; </li><li>  no formato <code>http://localhost/&lt;speed&gt;[&lt;U&gt;]/</code> ; </li><li>  no formato <code>http://localhost/&lt;speed&gt;[&lt;U&gt;]/&lt;count&gt;/</code> </li></ul><br><p>  Onde <code>speed</code> √© um n√∫mero que define a velocidade e <code>U</code> √© um multiplicador opcional que indica em quais unidades a velocidade est√° definida.  Ent√£o <code>128</code> ou <code>128b</code> significa uma velocidade de 128 bytes por segundo.  E <code>128k</code> s√£o 128 kilobytes por segundo. </p><br><p>  Cada URL tem sua pr√≥pria fun√ß√£o lambda, que entende os par√¢metros recebidos; se tudo estiver bem, chama a fun√ß√£o <code>request_processor</code> mostrada acima. </p><br><p>  A fun√ß√£o auxiliar <code>extract_chunk_size</code> seguinte: </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> extract_chunk_size(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> restinio::router::<span class="hljs-keyword"><span class="hljs-keyword">route_params_t</span></span> &amp; params) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> multiplier = [](<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> sv) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sv.empty() || <span class="hljs-string"><span class="hljs-string">"B"</span></span> == sv || <span class="hljs-string"><span class="hljs-string">"b"</span></span> == sv) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1u</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-string"><span class="hljs-string">"K"</span></span> == sv || <span class="hljs-string"><span class="hljs-string">"k"</span></span> == sv) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1024u</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1024u</span></span>*<span class="hljs-number"><span class="hljs-number">1024u</span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> restinio::cast_to&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>&gt;(params[<span class="hljs-string"><span class="hljs-string">"value"</span></span>]) * multiplier(params[<span class="hljs-string"><span class="hljs-string">"multiplier"</span></span>]); }</code> </pre> <br><p>  Aqui, o C ++ lambda √© usado para emular fun√ß√µes locais de outras linguagens de programa√ß√£o. </p><br><h2 id="funkciya-main">  Fun√ß√£o principal </h2><br><p>  Resta ver como tudo isso √© executado na fun√ß√£o principal: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">router_t</span></span> = restinio::router::<span class="hljs-keyword"><span class="hljs-keyword">express_router_t</span></span>&lt;&gt;; ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">traits_t</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> restinio::<span class="hljs-keyword"><span class="hljs-keyword">default_single_thread_traits_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">logger_t</span></span> = restinio::<span class="hljs-keyword"><span class="hljs-keyword">single_threaded_ostream_logger_t</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">request_handler_t</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">router_t</span></span>; }; asio_ns::io_context io_ctx; restinio::run( io_ctx, restinio::on_this_thread&lt;<span class="hljs-keyword"><span class="hljs-keyword">traits_t</span></span>&gt;() .port(<span class="hljs-number"><span class="hljs-number">8080</span></span>) .address(<span class="hljs-string"><span class="hljs-string">"localhost"</span></span>) .write_http_response_timelimit(<span class="hljs-number"><span class="hljs-number">60</span></span>s) .request_handler(make_router(io_ctx))); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><p>  O que est√° acontecendo aqui: </p><br><ol><li>  Como n√£o preciso de um roteador comum comum de solicita√ß√µes (que n√£o pode fazer nada e coloca todo o trabalho sobre o ombro do programador), defino novas propriedades para o meu servidor HTTP.  Para fazer isso, pego as propriedades padr√£o de um servidor HTTP de thread √∫nico (digite <code>restinio::default_single_thread_traits_t</code> ) e indico que uma inst√¢ncia de roteador expresso ser√° usada como manipulador de solicita√ß√µes.  Ao mesmo tempo, para controlar o que est√° acontecendo l√° dentro, indico que o servidor HTTP usa um logger real (por padr√£o, <code>null_logger_t</code> usado e n√£o registra nada). </li><li>  Como eu preciso ativar os temporizadores dentro dos notificadores p√≥s-grava√ß√£o, preciso de uma inst√¢ncia io_context com a qual eu possa trabalhar.  Portanto, eu mesmo o crio.  Isso me d√° a oportunidade de passar um link para o meu io_context na fun√ß√£o <code>make_router</code> . </li><li>  Resta apenas iniciar o servidor HTTP em uma vers√£o de thread √∫nico no io_context que eu criei anteriormente.  A fun√ß√£o <code>restinio::run</code> retornar√° o controle somente quando o servidor HTTP concluir seu trabalho. </li></ol><br><h1 id="zaklyuchenie">  Conclus√£o </h1><br><p>  O artigo n√£o mostrou o c√≥digo completo do meu servidor de teste, apenas seus pontos principais.  O c√≥digo completo, que √© um pouco maior devido a typedefs adicionais e fun√ß√µes auxiliares, √© um pouco mais aut√™ntico.  Voc√™ pode v√™-lo <a href="">aqui</a> .  No momento da reda√ß√£o deste artigo, s√£o 185 linhas, incluindo linhas em branco e coment√°rios.  Bem, essas 185 linhas s√£o escritas em algumas abordagens com uma dura√ß√£o total de pouco mais de uma hora. </p><br><p>  Gostei desse resultado e a tarefa foi interessante.  Em termos pr√°ticos, a ferramenta auxiliar de que eu precisava foi rapidamente obtida.  E em termos do desenvolvimento do RESTinio, alguns pensamentos apareceram. </p><br><p>  Em geral, se algu√©m n√£o tentou o RESTinio, convido voc√™ a tentar.  O projeto em si vive no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GitHub</a> .  Voc√™ pode fazer uma pergunta ou expressar suas sugest√µes no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">grupo</a> do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Google</a> ou aqui nos coment√°rios. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt462349/">https://habr.com/ru/post/pt462349/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt462333/index.html">Criando um chatbot de conversa√ß√£o simples em python</a></li>
<li><a href="../pt462335/index.html">N√£o leia, releia</a></li>
<li><a href="../pt462337/index.html">Estat√≠sticas do site e seu pequeno reposit√≥rio</a></li>
<li><a href="../pt462339/index.html">Como o treinamento manual est√° relacionado aos padr√µes internos da Amazon e como isso afetou a vis√£o de mundo da empresa?</a></li>
<li><a href="../pt462347/index.html">Os primeiros dez dias entre uma coruja e um madrugador: sono, dieta, dieta e exerc√≠cio</a></li>
<li><a href="../pt462353/index.html">Perguntas freq√ºentes sobre seguran√ßa do protocolo LoRaWAN</a></li>
<li><a href="../pt462355/index.html">Programa√ß√£o JavaScript ass√≠ncrona (retorno de chamada, promessa, RxJs)</a></li>
<li><a href="../pt462357/index.html">Primeiro prot√≥tipo: Unikernels como um est√°gio na evolu√ß√£o do Linux</a></li>
<li><a href="../pt462359/index.html">Dat - que protocolo √© e quem o utiliza</a></li>
<li><a href="../pt462365/index.html">Limita√ß√µes do Machine Learning</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>