<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßë‚Äçü§ù‚Äçüßë üëØ üßëüèø‚Äçü§ù‚Äçüßëüèª Anota√ß√µes em tempo de compila√ß√£o usando @Implement como exemplo ü§∑üèº ü¶ó üë©üèæ‚Äçü§ù‚Äçüë©üèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Todos n√≥s gostamos de detectar erros no est√°gio de compila√ß√£o, em vez de exce√ß√µes de tempo de execu√ß√£o. A maneira mais f√°cil de corrigi-los √© que o pr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Anota√ß√µes em tempo de compila√ß√£o usando @Implement como exemplo</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/414715/"><img src="https://habrastorage.org/webt/zq/9v/1a/zq9v1afhchg4c2ft1koorkjfcss.png"><br><br>  Todos n√≥s gostamos de detectar erros no est√°gio de compila√ß√£o, em vez de exce√ß√µes de tempo de execu√ß√£o.  A maneira mais f√°cil de corrigi-los √© que o pr√≥prio compilador mostra todos os locais que precisam ser corrigidos.  Embora a maioria dos problemas s√≥ possa ser detectada quando o programa for iniciado, ainda estamos tentando fazer isso o mais r√°pido poss√≠vel. <a name="habracut"></a>  Em blocos de inicializa√ß√£o de classes, em construtores de objetos, na primeira chamada de um m√©todo, etc.  E, √†s vezes, temos sorte e, mesmo na fase de compila√ß√£o, sabemos o suficiente para verificar se h√° erros no programa. <br><br>  Neste artigo, quero compartilhar a experi√™ncia de escrever um desses testes.  Mais precisamente, criando uma anota√ß√£o que pode gerar erros, como o compilador.  A julgar pelo fato de n√£o haver tanta informa√ß√£o sobre esse t√≥pico no RuNet, as situa√ß√µes felizes descritas acima n√£o s√£o frequentes. <br><br>  Descreverei o algoritmo geral de verifica√ß√£o, bem como todas as etapas e nuances pelas quais passei tempo e c√©lulas nervosas. <br><br><h3>  Declara√ß√£o do problema </h3><br>  Nesta se√ß√£o, darei um exemplo do uso desta anota√ß√£o.  Se voc√™ j√° sabe o que deseja fazer, pode ignor√°-lo com seguran√ßa.  Estou certo de que isso n√£o afetar√° a integridade da apresenta√ß√£o. <br><br>  Agora falaremos mais sobre como melhorar a legibilidade do c√≥digo do que sobre como corrigir bugs.  Um exemplo, pode-se dizer, da vida, ou melhor, do meu projeto de hobby. <br><br>  Suponha que exista uma classe UnitManager, que, de fato, √© uma cole√ß√£o de unidades.  Possui m√©todos para adicionar, excluir, obter uma unidade etc.  Ao adicionar uma nova unidade, o gerente atribui um ID a ela.  A gera√ß√£o de id √© delegada √† classe RotateCounter, que retorna um n√∫mero no intervalo especificado.  E h√° um pequeno problema, o RotateCounter n√£o pode saber se o ID selecionado est√° livre.  De acordo com o princ√≠pio da invers√£o de depend√™ncia, voc√™ pode criar uma interface, no meu caso, √© RotateCounter.IClient, que possui um √∫nico m√©todo isValueFree (), que recebe id e retorna true se id estiver livre.  E o UnitManager implementa essa interface, cria uma inst√¢ncia do RotateCounter e a transmite a si mesma como cliente. <br><br>  Eu fiz exatamente isso.  Mas, depois de abrir a fonte do UnitManager alguns dias depois de escrever, entrei em um estupor f√°cil depois de ver o m√©todo isValueFree (), que realmente n√£o se encaixava na l√≥gica do UnitManager.  Seria muito mais simples se fosse poss√≠vel especificar qual interface implementa esse m√©todo.  Por exemplo, em C #, de onde vim para Java, uma implementa√ß√£o expl√≠cita da interface ajuda a lidar com esse problema.  Nesse caso, primeiro, voc√™ pode chamar o m√©todo apenas com uma convers√£o expl√≠cita na interface.  Em segundo lugar, e mais importante nesse caso, o nome da interface (e sem o modificador de acesso) √© indicado explicitamente na assinatura do m√©todo, por exemplo: <br><br><pre><code class="cs hljs">IClient.isValueFree(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) { }</code> </pre> <br>  Uma solu√ß√£o √© adicionar uma anota√ß√£o com o nome da interface que implementa esse m√©todo.  Algo como <code>@Override</code> , apenas com uma interface.  Concordo, voc√™ pode usar uma classe interna an√¥nima.  Nesse caso, assim como em C #, o m√©todo n√£o pode ser chamado apenas no objeto e voc√™ pode ver imediatamente qual interface ele implementa.  Por√©m, isso aumentar√° a quantidade de c√≥digo, portanto, degradar√° a legibilidade.  Sim, e voc√™ precisa obt√™-lo de alguma forma da classe - criar um getter ou um campo p√∫blico (afinal, tamb√©m n√£o h√° sobrecarga de instru√ß√µes de convers√£o no Java).  N√£o √© uma op√ß√£o ruim, mas eu n√£o gosto. <br><br>  Inicialmente, pensei que em Java, como em C #, as anota√ß√µes s√£o classes completas e podem ser herdadas delas.  Nesse caso, voc√™ s√≥ precisa criar uma anota√ß√£o que herda de <code>@Override</code> .  Mas n√£o era assim, e tive que mergulhar no mundo surpreendente e assustador dos cheques na fase de compila√ß√£o. <br><br><div class="spoiler">  <b class="spoiler_title">C√≥digo de exemplo do UnitManager</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Unit</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UnitManager</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RotateCounter</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IClient</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Unit[] units; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> RotateCounter idGenerator; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UnitManager</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> </span></span>{ units = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Unit[size]; idGenerator = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RotateCounter(<span class="hljs-number"><span class="hljs-number">0</span></span>, size, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addUnit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Unit unit)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id = idGenerator.findFree(); units[id] = unit; } <span class="hljs-meta"><span class="hljs-meta">@Implement</span></span>(RotateCounter.IClient.class) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isValueFree</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> units[value] == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">removeUnit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id)</span></span></span><span class="hljs-function"> </span></span>{ units[id] = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RotateCounter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> IClient client; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> next; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> minValue; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maxValue; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RotateCounter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> minValue, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> maxValue, IClient client)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.client = client; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.minValue = minValue; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.maxValue = maxValue; next = minValue; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">incrementAndGet</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> current = next; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (next &gt;= maxValue) { next = minValue; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> current; } next++; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> current; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">range</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> maxValue - minValue + <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findFree</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> range = range(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> trysCounter = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++trysCounter &gt; range) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalStateException(<span class="hljs-string"><span class="hljs-string">"No free values."</span></span>); } id = incrementAndGet(); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!client.isValueFree(id)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> id; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IClient</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isValueFree</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span></span>; } }</code> </pre></div></div><br><h3>  Pouco de teoria </h3><br>  Farei uma reserva imediatamente, todos os m√©todos acima s√£o inst√¢ncias; portanto, por uma quest√£o de brevidade, indicarei os nomes dos m√©todos com o nome do tipo e sem par√¢metros: <code>&lt;_&gt;.&lt;_&gt;()</code> . <br><br>  O processamento de elementos no est√°gio de compila√ß√£o envolve classes especiais de processador.  Estas s√£o classes que herdam da <code>javax.annotation.processing.AbstractProcessor</code> (voc√™ pode simplesmente implementar a interface <code>javax.annotation.processing.Processor</code> ).  Voc√™ pode ler mais sobre processadores <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> .  O m√©todo mais importante √© o processo.  Na qual podemos obter uma lista de todos os elementos anotados e realizar as verifica√ß√µes necess√°rias. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment env)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; }</code> </pre> <br>  No come√ßo, sinceramente ing√™nuo, pensei que trabalhar com tipos na fase de compila√ß√£o √© realizado em termos de reflex√£o, mas ... n√£o.  Tudo √© baseado em elementos l√°. <br><br>  <b>Elemento</b> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">javax.lang.model.element.Element</a> ) - a interface principal para trabalhar com a maioria dos elementos estruturais da linguagem.  Um elemento possui descendentes que determinam com mais precis√£o as propriedades de um elemento espec√≠fico (para detalhes, veja <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> ): <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> ds.magic.example.implement; <span class="hljs-comment"><span class="hljs-comment">// PackageElement public class Unit // TypeElement { private int id; // VariableElement public void setId(int id) { // ExecutableElement this.id = id; } }</span></span></code> </pre> <br>  <b>TypeMirror</b> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">javax.lang.model.type.TypeMirror</a> ) √© algo como Classe &lt;?&gt; Retornada pelo m√©todo getClass ().  Por exemplo, eles podem ser comparados para descobrir se os tipos de elementos correspondem.  Voc√™ pode obt√™-lo usando o <code>Element.asType()</code> .  Esse tipo tamb√©m retorna algumas opera√ß√µes de tipo, como <code>TypeElement.getSuperclass()</code> ou <code>TypeElement.getInterfaces()</code> . <br><br>  <b>Tipos</b> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">javax.lang.model.util.Types</a> ) - aconselho que voc√™ d√™ uma olhada mais de perto nesta classe.  Voc√™ pode encontrar muitas coisas interessantes l√°.  Em ess√™ncia, este √© um conjunto de utilit√°rios para trabalhar com tipos.  Por exemplo, permite recuperar um TypeElement de um TypeMirror. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> TypeElement </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">asTypeElement</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TypeMirror typeMirror)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (TypeElement)processingEnv.getTypeUtils().asElement(typeMirror); }</code> </pre> <br>  <b>TypeKind</b> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">javax.lang.model.type.TypeKind</a> ) - uma enumera√ß√£o que permite esclarecer informa√ß√µes de tipo, verificar se o tipo √© uma matriz (ARRAY), um tipo personalizado (DECLARED), uma vari√°vel de tipo (TYPEVAR) etc.  Voc√™ pode obt√™-lo atrav√©s do <code>TypeMirror.getKind()</code> <br><br>  <b>ElementKind</b> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">javax.lang.model.element.ElementKind</a> ) - enumera√ß√£o, permite esclarecer informa√ß√µes sobre o elemento, verificar se o elemento √© um pacote (PACKAGE), classe (CLASS), m√©todo (METHOD), interface (INTERFACE) etc. <br><br>  <b>Nome</b> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">javax.lang.model.element.Name</a> ) - a interface para trabalhar com o nome do elemento pode ser obtida atrav√©s de <code>Element.getSimpleName()</code> . <br><br>  Basicamente, esses tipos foram suficientes para eu escrever um algoritmo de verifica√ß√£o. <br><br>  Eu quero observar outro recurso interessante.  As implementa√ß√µes das interfaces Element no Eclipse est√£o nos pacotes org.eclipse ..., por exemplo, os elementos que representam os m√©todos s√£o do tipo <code>org.eclipse.jdt.internal.compiler.apt.model.ExecutableElementImpl</code> .  Isso me deu a ideia de que essas interfaces s√£o implementadas por cada IDE de forma independente. <br><br><h3>  Algoritmo de valida√ß√£o </h3><br>  Primeiro, voc√™ precisa criar a anota√ß√£o em si.  Muito j√° foi escrito sobre o assunto (por exemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> ), por isso n√£o vou me deter sobre isso em detalhes.  S√≥ posso dizer que, para o nosso exemplo, precisamos adicionar duas anota√ß√µes <code>@Target</code> e <code>@Retention</code> .  O primeiro indica que nossa anota√ß√£o s√≥ pode ser aplicada ao m√©todo e o segundo que a anota√ß√£o existir√° apenas no c√≥digo-fonte. <br><br>  As anota√ß√µes devem ser especificadas em qual interface implementa o m√©todo anotado (o m√©todo ao qual a anota√ß√£o √© aplicada).  Isso pode ser feito de duas maneiras: especifique o nome completo da interface com uma string, por exemplo, <code>@Implement("com.ds.IInterface")</code> ou passe a classe da interface diretamente: <code>@Implement(IInterface.class)</code> .  A segunda maneira √© claramente melhor.  Nesse caso, o compilador monitorar√° o nome correto da interface.  A prop√≥sito, se voc√™ chamar esse membro <b>value (),</b> ao adicionar anota√ß√µes ao m√©todo, n√£o ser√° necess√°rio especificar explicitamente o nome desse par√¢metro. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Target</span></span>({ElementType.METHOD}) <span class="hljs-meta"><span class="hljs-meta">@Retention</span></span>(RetentionPolicy.SOURCE) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-meta"><span class="hljs-meta">@interface</span></span> Implement { Class&lt;?&gt; value(); }</code> </pre> <br>  Ent√£o a divers√£o come√ßa - a cria√ß√£o do processador.  No m√©todo de processo, obtemos uma lista de todos os elementos anotados.  Em seguida, obtemos a anota√ß√£o em si e seu significado - a interface especificada.  Em geral, a estrutura da classe do processador √© assim: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@SupportedAnnotationTypes</span></span>({<span class="hljs-string"><span class="hljs-string">"ds.magic.annotations.compileTime.Implement"</span></span>}) <span class="hljs-meta"><span class="hljs-meta">@SupportedSourceVersion</span></span>(SourceVersion.RELEASE_8) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ImplementProcessor</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractProcessor</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Types typeUtils; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ProcessingEnvironment procEnv)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.init(procEnv); typeUtils = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.processingEnv.getTypeUtils(); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Set&lt;? extends TypeElement&gt; annos, RoundEnvironment env)</span></span></span><span class="hljs-function"> </span></span>{ Set&lt;? extends Element&gt; annotatedElements = env.getElementsAnnotatedWith(Implement.class); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(Element annotated : annotatedElements) { Implement annotation = annotatedElement.getAnnotation(Implement.class); TypeMirror interfaceMirror = getValueMirror(annotation); TypeElement interfaceType = asTypeElement(interfaceMirror); <span class="hljs-comment"><span class="hljs-comment">//... } return false; } private TypeElement asTypeElement(TypeMirror typeMirror) { return (TypeElement)typeUtils.asElement(typeMirror); } }</span></span></code> </pre> <br>  Quero observar que voc√™ n√£o pode apenas obter e obter anota√ß√µes de valor assim.  Quando voc√™ tenta chamar <code>annotation.value()</code> , uma <b>MirroredTypeException</b> ser√° lan√ßada, mas a partir dela voc√™ pode obter um TypeMirror.  Este m√©todo de trapa√ßa, bem como o recebimento correto do valor, encontrei <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> : <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> TypeMirror </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getValueMirror</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Implement annotation)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { annotation.value(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(MirroredTypeException e) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> e.getTypeMirror(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; }</code> </pre> <br>  A verifica√ß√£o em si consiste em tr√™s partes, se pelo menos uma delas falhar, √© necess√°rio exibir uma mensagem de erro e prosseguir para a pr√≥xima anota√ß√£o.  A prop√≥sito, voc√™ pode exibir uma mensagem de erro usando o seguinte m√©todo: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String message, Element annotatedElement)</span></span></span><span class="hljs-function"> </span></span>{ Messager messager = processingEnv.getMessager(); messager.printMessage(Kind.ERROR, message, annotatedElement); }</code> </pre> <br>  A primeira etapa √© verificar se as anota√ß√µes de valor s√£o uma interface.  Tudo √© simples aqui: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (interfaceType.getKind() != ElementKind.INTERFACE) { String name = Implement.class.getSimpleName(); printError(<span class="hljs-string"><span class="hljs-string">"Value of @"</span></span> + name + <span class="hljs-string"><span class="hljs-string">" must be an interface"</span></span>, annotated); <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br>  Em seguida, voc√™ precisa verificar se a classe na qual o m√©todo anotado est√° localizado realmente implementa a interface especificada.  No come√ßo, eu tolamente implementei esse teste com as m√£os.  Mas, usando um bom conselho, examinei <b>Types</b> e encontrei o m√©todo <code>Types.isSubtype()</code> l√°, que verificar√° toda a √°rvore de heran√ßa e retornar√° true se a interface especificada estiver l√°.  Importante, ele pode trabalhar com tipos gen√©ricos, ao contr√°rio da primeira op√ß√£o. <br><br><pre> <code class="java hljs">TypeElement enclosingType = (TypeElement)annotatedElement.getEnclosingElement(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!typeUtils.isSubtype(enclosingType.asType(), interfaceMirror)) { Name className = enclosingType.getSimpleName(); Name interfaceName = interfaceType.getSimpleName(); printError(className + <span class="hljs-string"><span class="hljs-string">" must implemet "</span></span> + interfaceName, annotated); <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br>  Por fim, voc√™ precisa garantir que a interface tenha um m√©todo com a mesma assinatura que a anotada.  Gostaria de usar o m√©todo <code>Types.isSubsignature()</code> , mas, infelizmente, n√£o funcionar√° corretamente se o m√©todo tiver par√¢metros de tipo.  Ent√£o arrega√ßamos as mangas e escrevemos todos os cheques com as m√£os.  E n√≥s temos tr√™s deles novamente.  Bem, mais precisamente, a assinatura do m√©todo consiste em tr√™s partes: o nome do m√©todo, o tipo do valor de retorno e a lista de par√¢metros.  Voc√™ precisa seguir todos os m√©todos da interface e encontrar o que passou nas tr√™s verifica√ß√µes.  Seria bom n√£o esquecer que o m√©todo pode ser herdado de outra interface e executar recursivamente as mesmas verifica√ß√µes para as interfaces subjacentes. <br><br>  A chamada deve ser feita no final do loop no m√©todo de processo, assim: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!haveMethod(interfaceType, (ExecutableElement)annotatedElement)) { Name name = interfaceType.getSimpleName(); printError(name + <span class="hljs-string"><span class="hljs-string">" don't have \""</span></span> + annotated + <span class="hljs-string"><span class="hljs-string">"\" method"</span></span>, annotated); <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br>  E o pr√≥prio m√©todo haveMethod () se parece com isso: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">haveMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TypeElement interfaceType, ExecutableElement method)</span></span></span><span class="hljs-function"> </span></span>{ Name methodName = method.getSimpleName(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Element interfaceElement : interfaceType.getEnclosedElements()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (interfaceElement <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> ExecutableElement) { ExecutableElement interfaceMethod = (ExecutableElement)interfaceElement; <span class="hljs-comment"><span class="hljs-comment">// Is names match? if (!interfaceMethod.getSimpleName().equals(methodName)) { continue; } // Is return types match (ignore type variable)? TypeMirror returnType = method.getReturnType(); TypeMirror interfaceReturnType = method.getReturnType(); if (!isTypeVariable(interfaceReturnType) &amp;&amp; !returnType.equals(interfaceReturnType)) { continue; } // Is parameters match? if (!isParametersEquals(method.getParameters(), interfaceMethod.getParameters())) { continue; } return true; } } // Recursive search for (TypeMirror baseMirror : interfaceType.getInterfaces()) { TypeElement base = asTypeElement(baseMirror); if (haveMethod(base, method)) { return true; } } return false; } private boolean isParametersEquals(List&lt;? extends VariableElement&gt; methodParameters, List&lt;? extends VariableElement&gt; interfaceParameters) { if (methodParameters.size() != interfaceParameters.size()) { return false; } for (int i = 0; i &lt; methodParameters.size(); i++) { TypeMirror interfaceParameterMirror = interfaceParameters.get(i).asType(); if (isTypeVariable(interfaceParameterMirror)) { continue; } if (!methodParameters.get(i).asType().equals(interfaceParameterMirror)) { return false; } } return true; } private boolean isTypeVariable(TypeMirror type) { return type.getKind() == TypeKind.TYPEVAR; }</span></span></code> </pre> <br>  V√™ o problema?  N√£o?  E ela est√° l√°.  O fato √© que n√£o consegui encontrar uma maneira de obter os par√¢metros de tipo reais para interfaces gen√©ricas.  Por exemplo, eu tenho uma classe que implementa a interface <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Predicate</a> : <br><pre> <code class="java hljs">MyPredicate implements Predicate&amp;ltString&amp;gt { <span class="hljs-meta"><span class="hljs-meta">@Implement</span></span>(Predicate.class) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String t)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } }</code> </pre> <br>  Ao analisar o m√©todo na classe, o tipo do par√¢metro √© <code>String</code> e, na interface, √© <code>T</code> , e todas as tentativas de obter <code>String</code> vez dele n√£o levaram a nada.  No final, n√£o tive nada melhor do que simplesmente ignorar os par√¢metros de tipo.  A verifica√ß√£o ser√° aprovada com quaisquer par√¢metros de tipo reais, mesmo que n√£o correspondam.  Felizmente, o compilador lan√ßar√° um erro se o m√©todo n√£o tiver implementa√ß√£o padr√£o e n√£o for implementado na classe base.  Mas ainda assim, se algu√©m souber como contornar isso, ficarei extremamente grato pela dica. <br><br><h3>  Conecte-se ao Eclipse </h3><br>  Pessoalmente, amo Eclipce e, na minha pr√°tica, usei apenas isso.  Portanto, descreverei como conectar o processador a este IDE.  Para que o Eclipse veja o processador, √© necess√°rio compact√°-lo em um .JAR separado, no qual a anota√ß√£o tamb√©m ser√°.  Nesse caso, voc√™ precisa criar a pasta <b>META-INF / services</b> no projeto e criar o arquivo <b>javax.annotation.processing.Processor l√°</b> e indicar o nome completo da classe do processador: <code>ds.magic.annotations.compileTime.ImplementProcessor</code> , no meu caso.  Por via das d√∫vidas, darei uma captura de tela, mas quando nada funcionou para mim, quase comecei a pecar na estrutura do projeto. <br><br><img src="https://habrastorage.org/webt/bp/oo/ev/bpooev7zwn5msgfm6pyyhupedwi.png" alt="imagem"><br><br>  Em seguida, colete .JAR e conecte-o ao seu projeto, primeiro como uma biblioteca comum, para que a anota√ß√£o fique vis√≠vel no c√≥digo.  Em seguida, conectamos o processador ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui est√°</a> mais detalhado).  Para fazer isso, abra as <b>propriedades</b> do <b>projeto</b> e selecione: <br><br><ol><li>  Compilador Java -&gt; Processamento de anota√ß√£o e marque a caixa "Ativar processamento de anota√ß√£o". </li><li>  Compilador Java -&gt; Processamento de anota√ß√µes -&gt; Caminho da f√°brica marque a caixa de sele√ß√£o "Ativar configura√ß√µes espec√≠ficas do projeto".  Em seguida, clique em Adicionar JARs ... e selecione o arquivo JAR criado anteriormente. </li><li>  Concorda em reconstruir o projeto. </li></ol><br><h3>  Sum√°rio </h3><br>  Todos juntos e no projeto Eclipse podem ser vistos no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GitHub</a> .  No momento da escrita, existem apenas duas classes, se a anota√ß√£o puder ser chamada assim: Implement.java e ImplementProcessor.java.  Eu acho que voc√™ j√° adivinhou o prop√≥sito deles. <br><br>  Talvez essa anota√ß√£o possa parecer in√∫til para alguns.  Talvez seja.  Mas, pessoalmente, eu mesmo o uso em vez do <code>@Override</code> , quando os nomes dos m√©todos n√£o se encaixam bem no objetivo da classe.  E at√© agora, n√£o tenho vontade de me livrar dela.  Em geral, fiz uma anota√ß√£o para mim, e o objetivo do artigo era mostrar qual rake estava atacando.  Espero ter conseguido.  Obrigado pela aten√ß√£o. <br><br>  PS.  Agradecemos aos usu√°rios do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">ohotNik_alex</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">Comdiv</a> por sua ajuda na corre√ß√£o de bugs. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt414715/">https://habr.com/ru/post/pt414715/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt414705/index.html">Obras-primas da constru√ß√£o do alto-falante global: monitore o caminho inovador da Audio, de tecido a materiais met√°licos e compostos</a></li>
<li><a href="../pt414707/index.html">An√°lise de blockchain, ou por que o mixer quebrou?</a></li>
<li><a href="../pt414709/index.html">Le√µes do deserto e introspec√ß√£o</a></li>
<li><a href="../pt414711/index.html">O aplicativo de futebol espanhol La Liga transformou seus usu√°rios em golpistas involunt√°rios</a></li>
<li><a href="../pt414713/index.html">Semana de coment√°rios cruzados</a></li>
<li><a href="../pt414717/index.html">2018 4K TV: recomenda√ß√µes para a melhor escolha</a></li>
<li><a href="../pt414719/index.html">Quatro rodas √© bom, duas s√£o melhores</a></li>
<li><a href="../pt414723/index.html">Concurso de Programa√ß√£o: Com√©rcio</a></li>
<li><a href="../pt414725/index.html">Mudan√ßa frontal: por que bater uma corrente de pr√≥tons em uma parede de concreto com cinco metros de espessura</a></li>
<li><a href="../pt414727/index.html">A lei de criptomoedas ser√° lan√ßada em breve na R√∫ssia: o que mudar√° para os participantes do mercado</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>