<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧑‍🤝‍🧑 👯 🧑🏿‍🤝‍🧑🏻 Anotações em tempo de compilação usando @Implement como exemplo 🤷🏼 🦗 👩🏾‍🤝‍👩🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Todos nós gostamos de detectar erros no estágio de compilação, em vez de exceções de tempo de execução. A maneira mais fácil de corrigi-los é que o pr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Anotações em tempo de compilação usando @Implement como exemplo</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/414715/"><img src="https://habrastorage.org/webt/zq/9v/1a/zq9v1afhchg4c2ft1koorkjfcss.png"><br><br>  Todos nós gostamos de detectar erros no estágio de compilação, em vez de exceções de tempo de execução.  A maneira mais fácil de corrigi-los é que o próprio compilador mostra todos os locais que precisam ser corrigidos.  Embora a maioria dos problemas só possa ser detectada quando o programa for iniciado, ainda estamos tentando fazer isso o mais rápido possível. <a name="habracut"></a>  Em blocos de inicialização de classes, em construtores de objetos, na primeira chamada de um método, etc.  E, às vezes, temos sorte e, mesmo na fase de compilação, sabemos o suficiente para verificar se há erros no programa. <br><br>  Neste artigo, quero compartilhar a experiência de escrever um desses testes.  Mais precisamente, criando uma anotação que pode gerar erros, como o compilador.  A julgar pelo fato de não haver tanta informação sobre esse tópico no RuNet, as situações felizes descritas acima não são frequentes. <br><br>  Descreverei o algoritmo geral de verificação, bem como todas as etapas e nuances pelas quais passei tempo e células nervosas. <br><br><h3>  Declaração do problema </h3><br>  Nesta seção, darei um exemplo do uso desta anotação.  Se você já sabe o que deseja fazer, pode ignorá-lo com segurança.  Estou certo de que isso não afetará a integridade da apresentação. <br><br>  Agora falaremos mais sobre como melhorar a legibilidade do código do que sobre como corrigir bugs.  Um exemplo, pode-se dizer, da vida, ou melhor, do meu projeto de hobby. <br><br>  Suponha que exista uma classe UnitManager, que, de fato, é uma coleção de unidades.  Possui métodos para adicionar, excluir, obter uma unidade etc.  Ao adicionar uma nova unidade, o gerente atribui um ID a ela.  A geração de id é delegada à classe RotateCounter, que retorna um número no intervalo especificado.  E há um pequeno problema, o RotateCounter não pode saber se o ID selecionado está livre.  De acordo com o princípio da inversão de dependência, você pode criar uma interface, no meu caso, é RotateCounter.IClient, que possui um único método isValueFree (), que recebe id e retorna true se id estiver livre.  E o UnitManager implementa essa interface, cria uma instância do RotateCounter e a transmite a si mesma como cliente. <br><br>  Eu fiz exatamente isso.  Mas, depois de abrir a fonte do UnitManager alguns dias depois de escrever, entrei em um estupor fácil depois de ver o método isValueFree (), que realmente não se encaixava na lógica do UnitManager.  Seria muito mais simples se fosse possível especificar qual interface implementa esse método.  Por exemplo, em C #, de onde vim para Java, uma implementação explícita da interface ajuda a lidar com esse problema.  Nesse caso, primeiro, você pode chamar o método apenas com uma conversão explícita na interface.  Em segundo lugar, e mais importante nesse caso, o nome da interface (e sem o modificador de acesso) é indicado explicitamente na assinatura do método, por exemplo: <br><br><pre><code class="cs hljs">IClient.isValueFree(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) { }</code> </pre> <br>  Uma solução é adicionar uma anotação com o nome da interface que implementa esse método.  Algo como <code>@Override</code> , apenas com uma interface.  Concordo, você pode usar uma classe interna anônima.  Nesse caso, assim como em C #, o método não pode ser chamado apenas no objeto e você pode ver imediatamente qual interface ele implementa.  Porém, isso aumentará a quantidade de código, portanto, degradará a legibilidade.  Sim, e você precisa obtê-lo de alguma forma da classe - criar um getter ou um campo público (afinal, também não há sobrecarga de instruções de conversão no Java).  Não é uma opção ruim, mas eu não gosto. <br><br>  Inicialmente, pensei que em Java, como em C #, as anotações são classes completas e podem ser herdadas delas.  Nesse caso, você só precisa criar uma anotação que herda de <code>@Override</code> .  Mas não era assim, e tive que mergulhar no mundo surpreendente e assustador dos cheques na fase de compilação. <br><br><div class="spoiler">  <b class="spoiler_title">Código de exemplo do UnitManager</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Unit</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UnitManager</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RotateCounter</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IClient</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Unit[] units; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> RotateCounter idGenerator; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UnitManager</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> </span></span>{ units = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Unit[size]; idGenerator = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RotateCounter(<span class="hljs-number"><span class="hljs-number">0</span></span>, size, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addUnit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Unit unit)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id = idGenerator.findFree(); units[id] = unit; } <span class="hljs-meta"><span class="hljs-meta">@Implement</span></span>(RotateCounter.IClient.class) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isValueFree</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> units[value] == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">removeUnit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id)</span></span></span><span class="hljs-function"> </span></span>{ units[id] = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RotateCounter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> IClient client; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> next; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> minValue; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maxValue; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RotateCounter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> minValue, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> maxValue, IClient client)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.client = client; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.minValue = minValue; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.maxValue = maxValue; next = minValue; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">incrementAndGet</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> current = next; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (next &gt;= maxValue) { next = minValue; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> current; } next++; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> current; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">range</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> maxValue - minValue + <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findFree</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> range = range(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> trysCounter = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++trysCounter &gt; range) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalStateException(<span class="hljs-string"><span class="hljs-string">"No free values."</span></span>); } id = incrementAndGet(); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!client.isValueFree(id)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> id; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IClient</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isValueFree</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span></span>; } }</code> </pre></div></div><br><h3>  Pouco de teoria </h3><br>  Farei uma reserva imediatamente, todos os métodos acima são instâncias; portanto, por uma questão de brevidade, indicarei os nomes dos métodos com o nome do tipo e sem parâmetros: <code>&lt;_&gt;.&lt;_&gt;()</code> . <br><br>  O processamento de elementos no estágio de compilação envolve classes especiais de processador.  Estas são classes que herdam da <code>javax.annotation.processing.AbstractProcessor</code> (você pode simplesmente implementar a interface <code>javax.annotation.processing.Processor</code> ).  Você pode ler mais sobre processadores <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> .  O método mais importante é o processo.  Na qual podemos obter uma lista de todos os elementos anotados e realizar as verificações necessárias. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment env)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; }</code> </pre> <br>  No começo, sinceramente ingênuo, pensei que trabalhar com tipos na fase de compilação é realizado em termos de reflexão, mas ... não.  Tudo é baseado em elementos lá. <br><br>  <b>Elemento</b> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">javax.lang.model.element.Element</a> ) - a interface principal para trabalhar com a maioria dos elementos estruturais da linguagem.  Um elemento possui descendentes que determinam com mais precisão as propriedades de um elemento específico (para detalhes, veja <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> ): <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> ds.magic.example.implement; <span class="hljs-comment"><span class="hljs-comment">// PackageElement public class Unit // TypeElement { private int id; // VariableElement public void setId(int id) { // ExecutableElement this.id = id; } }</span></span></code> </pre> <br>  <b>TypeMirror</b> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">javax.lang.model.type.TypeMirror</a> ) é algo como Classe &lt;?&gt; Retornada pelo método getClass ().  Por exemplo, eles podem ser comparados para descobrir se os tipos de elementos correspondem.  Você pode obtê-lo usando o <code>Element.asType()</code> .  Esse tipo também retorna algumas operações de tipo, como <code>TypeElement.getSuperclass()</code> ou <code>TypeElement.getInterfaces()</code> . <br><br>  <b>Tipos</b> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">javax.lang.model.util.Types</a> ) - aconselho que você dê uma olhada mais de perto nesta classe.  Você pode encontrar muitas coisas interessantes lá.  Em essência, este é um conjunto de utilitários para trabalhar com tipos.  Por exemplo, permite recuperar um TypeElement de um TypeMirror. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> TypeElement </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">asTypeElement</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TypeMirror typeMirror)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (TypeElement)processingEnv.getTypeUtils().asElement(typeMirror); }</code> </pre> <br>  <b>TypeKind</b> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">javax.lang.model.type.TypeKind</a> ) - uma enumeração que permite esclarecer informações de tipo, verificar se o tipo é uma matriz (ARRAY), um tipo personalizado (DECLARED), uma variável de tipo (TYPEVAR) etc.  Você pode obtê-lo através do <code>TypeMirror.getKind()</code> <br><br>  <b>ElementKind</b> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">javax.lang.model.element.ElementKind</a> ) - enumeração, permite esclarecer informações sobre o elemento, verificar se o elemento é um pacote (PACKAGE), classe (CLASS), método (METHOD), interface (INTERFACE) etc. <br><br>  <b>Nome</b> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">javax.lang.model.element.Name</a> ) - a interface para trabalhar com o nome do elemento pode ser obtida através de <code>Element.getSimpleName()</code> . <br><br>  Basicamente, esses tipos foram suficientes para eu escrever um algoritmo de verificação. <br><br>  Eu quero observar outro recurso interessante.  As implementações das interfaces Element no Eclipse estão nos pacotes org.eclipse ..., por exemplo, os elementos que representam os métodos são do tipo <code>org.eclipse.jdt.internal.compiler.apt.model.ExecutableElementImpl</code> .  Isso me deu a ideia de que essas interfaces são implementadas por cada IDE de forma independente. <br><br><h3>  Algoritmo de validação </h3><br>  Primeiro, você precisa criar a anotação em si.  Muito já foi escrito sobre o assunto (por exemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> ), por isso não vou me deter sobre isso em detalhes.  Só posso dizer que, para o nosso exemplo, precisamos adicionar duas anotações <code>@Target</code> e <code>@Retention</code> .  O primeiro indica que nossa anotação só pode ser aplicada ao método e o segundo que a anotação existirá apenas no código-fonte. <br><br>  As anotações devem ser especificadas em qual interface implementa o método anotado (o método ao qual a anotação é aplicada).  Isso pode ser feito de duas maneiras: especifique o nome completo da interface com uma string, por exemplo, <code>@Implement("com.ds.IInterface")</code> ou passe a classe da interface diretamente: <code>@Implement(IInterface.class)</code> .  A segunda maneira é claramente melhor.  Nesse caso, o compilador monitorará o nome correto da interface.  A propósito, se você chamar esse membro <b>value (),</b> ao adicionar anotações ao método, não será necessário especificar explicitamente o nome desse parâmetro. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Target</span></span>({ElementType.METHOD}) <span class="hljs-meta"><span class="hljs-meta">@Retention</span></span>(RetentionPolicy.SOURCE) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-meta"><span class="hljs-meta">@interface</span></span> Implement { Class&lt;?&gt; value(); }</code> </pre> <br>  Então a diversão começa - a criação do processador.  No método de processo, obtemos uma lista de todos os elementos anotados.  Em seguida, obtemos a anotação em si e seu significado - a interface especificada.  Em geral, a estrutura da classe do processador é assim: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@SupportedAnnotationTypes</span></span>({<span class="hljs-string"><span class="hljs-string">"ds.magic.annotations.compileTime.Implement"</span></span>}) <span class="hljs-meta"><span class="hljs-meta">@SupportedSourceVersion</span></span>(SourceVersion.RELEASE_8) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ImplementProcessor</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractProcessor</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Types typeUtils; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ProcessingEnvironment procEnv)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.init(procEnv); typeUtils = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.processingEnv.getTypeUtils(); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Set&lt;? extends TypeElement&gt; annos, RoundEnvironment env)</span></span></span><span class="hljs-function"> </span></span>{ Set&lt;? extends Element&gt; annotatedElements = env.getElementsAnnotatedWith(Implement.class); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(Element annotated : annotatedElements) { Implement annotation = annotatedElement.getAnnotation(Implement.class); TypeMirror interfaceMirror = getValueMirror(annotation); TypeElement interfaceType = asTypeElement(interfaceMirror); <span class="hljs-comment"><span class="hljs-comment">//... } return false; } private TypeElement asTypeElement(TypeMirror typeMirror) { return (TypeElement)typeUtils.asElement(typeMirror); } }</span></span></code> </pre> <br>  Quero observar que você não pode apenas obter e obter anotações de valor assim.  Quando você tenta chamar <code>annotation.value()</code> , uma <b>MirroredTypeException</b> será lançada, mas a partir dela você pode obter um TypeMirror.  Este método de trapaça, bem como o recebimento correto do valor, encontrei <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> : <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> TypeMirror </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getValueMirror</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Implement annotation)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { annotation.value(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(MirroredTypeException e) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> e.getTypeMirror(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; }</code> </pre> <br>  A verificação em si consiste em três partes, se pelo menos uma delas falhar, é necessário exibir uma mensagem de erro e prosseguir para a próxima anotação.  A propósito, você pode exibir uma mensagem de erro usando o seguinte método: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String message, Element annotatedElement)</span></span></span><span class="hljs-function"> </span></span>{ Messager messager = processingEnv.getMessager(); messager.printMessage(Kind.ERROR, message, annotatedElement); }</code> </pre> <br>  A primeira etapa é verificar se as anotações de valor são uma interface.  Tudo é simples aqui: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (interfaceType.getKind() != ElementKind.INTERFACE) { String name = Implement.class.getSimpleName(); printError(<span class="hljs-string"><span class="hljs-string">"Value of @"</span></span> + name + <span class="hljs-string"><span class="hljs-string">" must be an interface"</span></span>, annotated); <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br>  Em seguida, você precisa verificar se a classe na qual o método anotado está localizado realmente implementa a interface especificada.  No começo, eu tolamente implementei esse teste com as mãos.  Mas, usando um bom conselho, examinei <b>Types</b> e encontrei o método <code>Types.isSubtype()</code> lá, que verificará toda a árvore de herança e retornará true se a interface especificada estiver lá.  Importante, ele pode trabalhar com tipos genéricos, ao contrário da primeira opção. <br><br><pre> <code class="java hljs">TypeElement enclosingType = (TypeElement)annotatedElement.getEnclosingElement(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!typeUtils.isSubtype(enclosingType.asType(), interfaceMirror)) { Name className = enclosingType.getSimpleName(); Name interfaceName = interfaceType.getSimpleName(); printError(className + <span class="hljs-string"><span class="hljs-string">" must implemet "</span></span> + interfaceName, annotated); <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br>  Por fim, você precisa garantir que a interface tenha um método com a mesma assinatura que a anotada.  Gostaria de usar o método <code>Types.isSubsignature()</code> , mas, infelizmente, não funcionará corretamente se o método tiver parâmetros de tipo.  Então arregaçamos as mangas e escrevemos todos os cheques com as mãos.  E nós temos três deles novamente.  Bem, mais precisamente, a assinatura do método consiste em três partes: o nome do método, o tipo do valor de retorno e a lista de parâmetros.  Você precisa seguir todos os métodos da interface e encontrar o que passou nas três verificações.  Seria bom não esquecer que o método pode ser herdado de outra interface e executar recursivamente as mesmas verificações para as interfaces subjacentes. <br><br>  A chamada deve ser feita no final do loop no método de processo, assim: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!haveMethod(interfaceType, (ExecutableElement)annotatedElement)) { Name name = interfaceType.getSimpleName(); printError(name + <span class="hljs-string"><span class="hljs-string">" don't have \""</span></span> + annotated + <span class="hljs-string"><span class="hljs-string">"\" method"</span></span>, annotated); <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br>  E o próprio método haveMethod () se parece com isso: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">haveMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TypeElement interfaceType, ExecutableElement method)</span></span></span><span class="hljs-function"> </span></span>{ Name methodName = method.getSimpleName(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Element interfaceElement : interfaceType.getEnclosedElements()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (interfaceElement <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> ExecutableElement) { ExecutableElement interfaceMethod = (ExecutableElement)interfaceElement; <span class="hljs-comment"><span class="hljs-comment">// Is names match? if (!interfaceMethod.getSimpleName().equals(methodName)) { continue; } // Is return types match (ignore type variable)? TypeMirror returnType = method.getReturnType(); TypeMirror interfaceReturnType = method.getReturnType(); if (!isTypeVariable(interfaceReturnType) &amp;&amp; !returnType.equals(interfaceReturnType)) { continue; } // Is parameters match? if (!isParametersEquals(method.getParameters(), interfaceMethod.getParameters())) { continue; } return true; } } // Recursive search for (TypeMirror baseMirror : interfaceType.getInterfaces()) { TypeElement base = asTypeElement(baseMirror); if (haveMethod(base, method)) { return true; } } return false; } private boolean isParametersEquals(List&lt;? extends VariableElement&gt; methodParameters, List&lt;? extends VariableElement&gt; interfaceParameters) { if (methodParameters.size() != interfaceParameters.size()) { return false; } for (int i = 0; i &lt; methodParameters.size(); i++) { TypeMirror interfaceParameterMirror = interfaceParameters.get(i).asType(); if (isTypeVariable(interfaceParameterMirror)) { continue; } if (!methodParameters.get(i).asType().equals(interfaceParameterMirror)) { return false; } } return true; } private boolean isTypeVariable(TypeMirror type) { return type.getKind() == TypeKind.TYPEVAR; }</span></span></code> </pre> <br>  Vê o problema?  Não?  E ela está lá.  O fato é que não consegui encontrar uma maneira de obter os parâmetros de tipo reais para interfaces genéricas.  Por exemplo, eu tenho uma classe que implementa a interface <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Predicate</a> : <br><pre> <code class="java hljs">MyPredicate implements Predicate&amp;ltString&amp;gt { <span class="hljs-meta"><span class="hljs-meta">@Implement</span></span>(Predicate.class) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String t)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } }</code> </pre> <br>  Ao analisar o método na classe, o tipo do parâmetro é <code>String</code> e, na interface, é <code>T</code> , e todas as tentativas de obter <code>String</code> vez dele não levaram a nada.  No final, não tive nada melhor do que simplesmente ignorar os parâmetros de tipo.  A verificação será aprovada com quaisquer parâmetros de tipo reais, mesmo que não correspondam.  Felizmente, o compilador lançará um erro se o método não tiver implementação padrão e não for implementado na classe base.  Mas ainda assim, se alguém souber como contornar isso, ficarei extremamente grato pela dica. <br><br><h3>  Conecte-se ao Eclipse </h3><br>  Pessoalmente, amo Eclipce e, na minha prática, usei apenas isso.  Portanto, descreverei como conectar o processador a este IDE.  Para que o Eclipse veja o processador, é necessário compactá-lo em um .JAR separado, no qual a anotação também será.  Nesse caso, você precisa criar a pasta <b>META-INF / services</b> no projeto e criar o arquivo <b>javax.annotation.processing.Processor lá</b> e indicar o nome completo da classe do processador: <code>ds.magic.annotations.compileTime.ImplementProcessor</code> , no meu caso.  Por via das dúvidas, darei uma captura de tela, mas quando nada funcionou para mim, quase comecei a pecar na estrutura do projeto. <br><br><img src="https://habrastorage.org/webt/bp/oo/ev/bpooev7zwn5msgfm6pyyhupedwi.png" alt="imagem"><br><br>  Em seguida, colete .JAR e conecte-o ao seu projeto, primeiro como uma biblioteca comum, para que a anotação fique visível no código.  Em seguida, conectamos o processador ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui está</a> mais detalhado).  Para fazer isso, abra as <b>propriedades</b> do <b>projeto</b> e selecione: <br><br><ol><li>  Compilador Java -&gt; Processamento de anotação e marque a caixa "Ativar processamento de anotação". </li><li>  Compilador Java -&gt; Processamento de anotações -&gt; Caminho da fábrica marque a caixa de seleção "Ativar configurações específicas do projeto".  Em seguida, clique em Adicionar JARs ... e selecione o arquivo JAR criado anteriormente. </li><li>  Concorda em reconstruir o projeto. </li></ol><br><h3>  Sumário </h3><br>  Todos juntos e no projeto Eclipse podem ser vistos no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GitHub</a> .  No momento da escrita, existem apenas duas classes, se a anotação puder ser chamada assim: Implement.java e ImplementProcessor.java.  Eu acho que você já adivinhou o propósito deles. <br><br>  Talvez essa anotação possa parecer inútil para alguns.  Talvez seja.  Mas, pessoalmente, eu mesmo o uso em vez do <code>@Override</code> , quando os nomes dos métodos não se encaixam bem no objetivo da classe.  E até agora, não tenho vontade de me livrar dela.  Em geral, fiz uma anotação para mim, e o objetivo do artigo era mostrar qual rake estava atacando.  Espero ter conseguido.  Obrigado pela atenção. <br><br>  PS.  Agradecemos aos usuários do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">ohotNik_alex</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">Comdiv</a> por sua ajuda na correção de bugs. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt414715/">https://habr.com/ru/post/pt414715/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt414705/index.html">Obras-primas da construção do alto-falante global: monitore o caminho inovador da Audio, de tecido a materiais metálicos e compostos</a></li>
<li><a href="../pt414707/index.html">Análise de blockchain, ou por que o mixer quebrou?</a></li>
<li><a href="../pt414709/index.html">Leões do deserto e introspecção</a></li>
<li><a href="../pt414711/index.html">O aplicativo de futebol espanhol La Liga transformou seus usuários em golpistas involuntários</a></li>
<li><a href="../pt414713/index.html">Semana de comentários cruzados</a></li>
<li><a href="../pt414717/index.html">2018 4K TV: recomendações para a melhor escolha</a></li>
<li><a href="../pt414719/index.html">Quatro rodas é bom, duas são melhores</a></li>
<li><a href="../pt414723/index.html">Concurso de Programação: Comércio</a></li>
<li><a href="../pt414725/index.html">Mudança frontal: por que bater uma corrente de prótons em uma parede de concreto com cinco metros de espessura</a></li>
<li><a href="../pt414727/index.html">A lei de criptomoedas será lançada em breve na Rússia: o que mudará para os participantes do mercado</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>