<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👁‍🗨 🆘 👄 Fünf Studenten und drei verteilte Schlüsselwertspeicher 🧑🏼 😐 🗽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Oder wie wir die Client-C ++ - Bibliothek für ZooKeeper, etcd und Consul KV geschrieben haben 
 In der Welt der verteilten Systeme gibt es eine Reihe ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Fünf Studenten und drei verteilte Schlüsselwertspeicher</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/458832/"><h2>  Oder wie wir die Client-C ++ - Bibliothek für ZooKeeper, etcd und Consul KV geschrieben haben </h2><br>  In der Welt der verteilten Systeme gibt es eine Reihe typischer Aufgaben: Speichern von Informationen über die Zusammensetzung des Clusters, Verwalten der Konfiguration von Knoten, Erkennen fehlerhafter Knoten, Auswählen eines Leiters <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">und andere</a> .  Um diese Probleme zu lösen, wurden spezielle verteilte Systeme geschaffen - Koordinierungsdienste.  Jetzt werden wir uns für drei davon interessieren: ZooKeeper, etcd und Consul.  Von allen umfangreichen Funktionen von Consul werden wir uns auf Consul KV konzentrieren. <br><br><img src="https://habrastorage.org/webt/j2/ut/gh/j2utghbsb8egpxnz1ct4k3dqtbk.jpeg"><br><br>  Tatsächlich sind alle diese Systeme fehlertolerante linearisierte Schlüsselwertspeicher.  Obwohl ihre Datenmodelle signifikante Unterschiede aufweisen, die wir später diskutieren werden, ermöglichen sie uns, dieselben praktischen Probleme zu lösen.  Offensichtlich ist jede Anwendung, die den Koordinierungsdienst verwendet, an eine von ihnen gebunden, was dazu führen kann, dass mehrere Systeme unterstützt werden müssen, die dieselben Aufgaben in einem Rechenzentrum für verschiedene Anwendungen lösen. <br><br>  Die Idee zur Lösung dieses Problems entstand in einer australischen Beratungsagentur, und wir, ein kleines Team von Studenten, mussten sie umsetzen, worüber ich Ihnen erzählen werde. <br><a name="habracut"></a><br>  Wir konnten eine Bibliothek erstellen, die eine gemeinsame Schnittstelle für die Arbeit mit ZooKeeper, etcd und Consul KV bietet.  Die Bibliothek ist in C ++ geschrieben, es ist jedoch geplant, sie in andere Sprachen zu portieren. <br><br><h3>  Datenmodelle </h3><br>  Um eine gemeinsame Schnittstelle für drei verschiedene Systeme zu entwickeln, müssen Sie verstehen, was sie gemeinsam haben und wie sie sich unterscheiden.  Lass es uns richtig machen. <br><br>  <b>Tierpfleger</b> <br><br><img src="https://habrastorage.org/webt/dv/7g/bu/dv7gbu5u-rvvg91d7qukhgfs1xg.png"><br><br>  Schlüssel sind in einem Baum organisiert und werden als Knoten (znodes) bezeichnet.  Dementsprechend können Sie für die Website eine Liste seiner Kinder erhalten.  Die Vorgänge zum Erstellen von znode (create) und zum Ändern des Werts (setData) sind getrennt: Nur vorhandene Schlüssel können Werte lesen und ändern.  Uhren können an Vorgänge angehängt werden, bei denen die Existenz eines Knotens überprüft, ein Wert gelesen und untergeordnete Elemente abgerufen werden.  Watch ist ein einmaliger Auslöser, der ausgelöst wird, wenn sich die Version der entsprechenden Daten auf dem Server ändert.  Ephemere Knoten werden verwendet, um Fehler zu erkennen.  Sie sind an die Sitzung des Clients angehängt, der sie erstellt hat.  Wenn ein Client eine Sitzung schließt oder ZooKeeper nicht mehr über seine Existenz informiert, werden diese Knoten automatisch gelöscht.  Es werden einfache Transaktionen unterstützt - eine Reihe von Vorgängen, die entweder alle erfolgreich sind oder fehlschlagen, wenn mindestens einer davon nicht möglich ist. <br><br>  <b>etcd</b> <br><br><img src="https://habrastorage.org/webt/at/hg/me/athgmezjwbafkvetueuq7ytewdc.png"><br><br>  Die Entwickler dieses Systems waren eindeutig von ZooKeeper inspiriert und haben daher alles anders gemacht.  Die Schlüsselhierarchie ist nicht hier, aber sie bilden eine lexikographisch geordnete Menge.  Sie können alle Schlüssel abrufen oder löschen, die zu einem bestimmten Bereich gehören.  Eine solche Struktur mag seltsam erscheinen, ist aber tatsächlich sehr ausdrucksstark, und die hierarchische Sichtweise durch sie lässt sich leicht emulieren. <br><br>  Es gibt keine Standard-Vergleichs- und Set-Operation in etcd, aber es gibt etwas Besseres - Transaktionen.  Natürlich sind sie in allen drei Systemen vorhanden, aber in etcd sind Transaktionen besonders gut.  Sie bestehen aus drei Blöcken: Prüfung, Erfolg, Misserfolg.  Der erste Block enthält eine Reihe von Bedingungen, die zweite und dritte Operation.  Eine Transaktion wird atomar ausgeführt.  Wenn alle Bedingungen erfüllt sind, wird der Erfolgsblock ausgeführt, andernfalls - Fehler.  In API-Version 3.3 können Erfolgs- und Fehlerblöcke verschachtelte Transaktionen enthalten.  Das heißt, es ist möglich, bedingte Konstruktionen einer nahezu willkürlichen Verschachtelungsebene atomar auszuführen.  Weitere Informationen zu den vorhandenen Überprüfungen und Vorgängen finden Sie in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> . <br><br>  Auch hier gibt es Uhren, die jedoch etwas komplexer und wiederverwendbarer sind.  Das heißt, nachdem Sie watch auf einer Reihe von Tasten installiert haben, erhalten Sie alle Updates in diesem Bereich, bis Sie die Uhr abbrechen, und nicht nur die erste.  In etcd entsprechen Leases ZooKeeper-Client-Sitzungen. <br><br>  <b>Konsul KV</b> <br><br>  Es gibt auch keine strenge hierarchische Struktur, aber Consul kann das Erscheinungsbild erstellen, das es gibt: Sie können alle Schlüssel mit dem angegebenen Präfix empfangen und löschen, dh mit dem "Teilbaum" des Schlüssels arbeiten.  Solche Abfragen werden als rekursiv bezeichnet.  Darüber hinaus kann Consul nur Schlüssel auswählen, die nicht das angegebene Zeichen nach dem Präfix enthalten, was dem Empfang sofortiger „Kinder“ entspricht.  Es ist jedoch zu beachten, dass dies genau das Erscheinungsbild einer hierarchischen Struktur ist: Es ist durchaus möglich, einen Schlüssel zu erstellen, wenn sein übergeordnetes Element nicht vorhanden ist, oder einen Schlüssel mit untergeordneten Schlüsseln zu löschen, während die untergeordneten Elemente weiterhin im System gespeichert werden. <br><br><img src="https://habrastorage.org/webt/qq/mb/8t/qqmb8tupgbnod_6jm6andrhelrs.png"><br>  Anstelle von Uhren werden in Consul HTTP-Anforderungen blockiert.  Im Wesentlichen handelt es sich hierbei um gewöhnliche Aufrufe der Datenlesemethode, für die zusammen mit anderen Parametern die letzte bekannte Version der Daten angegeben wird.  Wenn die aktuelle Version der entsprechenden Daten auf dem Server größer als die angegebene ist, wird die Antwort sofort zurückgegeben, andernfalls, wenn sich der Wert ändert.  Es gibt hier auch Sitzungen, die jederzeit an Schlüssel angehängt werden können.  Es ist erwähnenswert, dass es im Gegensatz zu etcd und ZooKeeper, wo das Löschen von Sitzungen zum Entfernen verwandter Schlüssel führt, einen Modus gibt, in dem die Sitzung einfach von diesen getrennt wird.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Transaktionen</a> sind verfügbar, ohne Verzweigung, aber mit allen Arten von Prüfungen. <br><br><h3>  Bring alles zusammen </h3><br>  Das strengste Datenmodell ist ZooKeeper.  In etcd verfügbare Expressive Range-Anforderungen können weder in ZooKeeper noch in Consul effizient emuliert werden.  Beim Versuch, das Beste aus allen Diensten herauszuholen, haben wir eine Schnittstelle erhalten, die fast der ZooKeeper-Schnittstelle entspricht, mit den folgenden wesentlichen Ausnahmen: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sequenz-, Container- und TTL-Knoten werden</a> nicht unterstützt </li><li>  ACLs werden nicht unterstützt </li><li>  Die set-Methode erstellt einen Schlüssel, wenn dieser nicht vorhanden war (in ZK gibt setData in diesem Fall einen Fehler zurück). </li><li>  set- und cas-Methoden sind getrennt (in ZK sind sie im Wesentlichen dasselbe) </li><li>  Die Löschmethode löscht den Scheitelpunkt zusammen mit dem Teilbaum (in ZK gibt delete einen Fehler zurück, wenn der Scheitelpunkt untergeordnete Elemente hat). </li><li>  Für jeden Schlüssel gibt es nur eine Version - die Version des Werts (in ZK <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gibt es drei davon</a> ) </li></ul><br>  Die Ablehnung von sequentiellen Knoten beruht auf der Tatsache, dass in etcd und Consul keine integrierte Unterstützung für sie vorhanden ist und dass sie zusätzlich zur resultierenden Bibliotheksschnittstelle vom Benutzer einfach implementiert werden können. <br><br>  Um dasselbe Verhalten beim Entfernen des obersten ZooKeeper zu implementieren, muss für jeden Schlüssel ein separater untergeordneter Zähler in etcd und Consul verwaltet werden.  Da wir versucht haben, das Speichern von Metainformationen zu vermeiden, wurde beschlossen, den gesamten Teilbaum zu löschen. <br><br><h3>  Feinheiten der Umsetzung </h3><br>  Lassen Sie uns einige Aspekte der Implementierung der Bibliotheksschnittstelle in verschiedenen Systemen genauer betrachten. <br><br>  <b>Hierarchie in etcd</b> <br><br>  Die Aufrechterhaltung einer hierarchischen Ansicht in etcd war eine der interessantesten Aufgaben.  Bereichsanforderungen erleichtern das Abrufen einer Liste von Schlüsseln mit einem bestimmten Präfix.  Wenn Sie beispielsweise alles möchten, was mit <code>"/foo"</code> beginnt, fordern Sie den Bereich <code>["/foo", "/fop")</code> .  Dies würde jedoch den gesamten Teilbaum des Schlüssels zurückgeben, was möglicherweise nicht akzeptabel ist, wenn der Teilbaum groß ist.  Zunächst wollten wir den <a href="">in zetcd implementierten Schlüsselkonvertierungsmechanismus verwenden</a> .  Dabei wird am Anfang des Schlüssels ein Byte hinzugefügt, das der Tiefe des Knotens im Baum entspricht.  Ich werde ein Beispiel geben. <br><br><pre> <code class="plaintext hljs">"/foo" -&gt; "\u01/foo" "/foo/bar" -&gt; "\u02/foo/bar"</code> </pre> <br>  Dann können Sie alle unmittelbaren <code>["\u02/foo/", "\u02/foo0")</code> Taste <code>"/foo"</code> <code>["\u02/foo/", "\u02/foo0")</code> indem Sie den Bereich <code>["\u02/foo/", "\u02/foo0")</code> .  Ja, in ASCII folgt <code>"/"</code> <code>"0"</code> unmittelbar auf <code>"/"</code> . <br><br>  Aber wie löscht man dann einen Scheitelpunkt?  Es stellt sich heraus, dass Sie alle Bereiche der Form <code>["\uXX/foo/", "\uXX/foo0")</code> für XX von 01 bis FF <code>["\uXX/foo/", "\uXX/foo0")</code> .  Und dann stießen wir auf ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Limit für die Anzahl der Vorgänge</a> innerhalb einer einzelnen Transaktion. <br><br>  Als Ergebnis wurde ein einfaches Schlüsselkonvertierungssystem erfunden, das es ermöglichte, sowohl das Entfernen des Schlüssels als auch den Empfang einer Liste von Kindern effektiv zu implementieren.  Es reicht aus, vor dem letzten Token ein spezielles Symbol hinzuzufügen.  Zum Beispiel: <br><br><pre> <code class="plaintext hljs">"/very" -&gt; "/\u00very" "/very/long" -&gt; "/very/\u00long" "/very/long/path" -&gt; "/very/long/\u00path"</code> </pre> <br>  <code>"/\u00very"</code> dann die Taste <code>"/very"</code> löschen, werden <code>"/\u00very"</code> und der Bereich <code>["/very/", "/very0")</code> , und alle <code>["/very/", "/very0")</code> , Schlüssel aus dem Bereich <code>["/very/\u00", "/very/\u01")</code> . <br><br>  <b>Entfernen eines Schlüssels in ZooKeeper</b> <br><br>  Wie bereits erwähnt, können Sie in ZooKeeper einen Knoten nicht löschen, wenn er untergeordnete Knoten hat.  Wir wollen den Schlüssel zusammen mit dem Teilbaum löschen.  Wie man ist  Wir machen es optimistisch.  Zuerst durchlaufen wir den Teilbaum rekursiv und erhalten die untergeordneten Elemente jedes Scheitelpunkts in einer separaten Abfrage.  Dann erstellen wir eine Transaktion, die versucht, alle Knoten des Teilbaums in der richtigen Reihenfolge zu löschen.  Natürlich können zwischen dem Lesen und Löschen eines Teilbaums Änderungen auftreten.  In diesem Fall schlägt die Transaktion fehl.  Darüber hinaus kann sich der Teilbaum während des Lesevorgangs ändern.  Eine Abfrage für die untergeordneten Knoten des nächsten Knotens kann einen Fehler zurückgeben, wenn beispielsweise dieser Scheitelpunkt bereits gelöscht wurde.  In beiden Fällen wiederholen wir den gesamten Vorgang erneut. <br><br>  Dieser Ansatz macht das Löschen eines Schlüssels sehr unwirksam, wenn er untergeordnete Elemente hat, und noch mehr, wenn die Anwendung weiterhin mit dem Teilbaum arbeitet und Schlüssel löscht und erstellt.  Dies ermöglichte es uns jedoch, die Implementierung anderer Methoden in etcd und Consul nicht zu erschweren. <br><br>  <b>in ZooKeeper eingestellt</b> <br><br>  In ZooKeeper gibt es separate Methoden, die mit der Baumstruktur (create, delete, getChildren) und mit Daten in Knoten (setData, getData) arbeiten. Darüber hinaus haben alle Methoden strenge Voraussetzungen: create gibt einen Fehler zurück, wenn der Knoten bereits erstellt, gelöscht oder setData - falls noch nicht vorhanden.  Wir brauchten die set-Methode, die aufgerufen werden kann, ohne über den Schlüssel nachzudenken. <br><br>  Eine Möglichkeit besteht darin, einen optimistischen Ansatz wie beim Löschen anzuwenden.  Überprüfen Sie, ob der Knoten vorhanden ist.  Wenn vorhanden, rufen Sie setData auf, andernfalls erstellen Sie.  Wenn die letzte Methode einen Fehler zurückgegeben hat, wiederholen Sie den Vorgang erneut.  Das erste, was zu beachten ist, ist die Sinnlosigkeit der Existenzprüfung.  Sie können create sofort aufrufen.  Ein erfolgreicher Abschluss bedeutet, dass der Knoten nicht vorhanden war und erstellt wurde.  Andernfalls gibt create den entsprechenden Fehler zurück, wonach setData aufgerufen werden muss.  Natürlich kann zwischen den Aufrufen der Scheitelpunkt durch einen konkurrierenden Aufruf entfernt werden, und setData gibt auch einen Fehler zurück.  In diesem Fall können Sie alles noch einmal wiederholen, aber lohnt es sich? <br><br>  Wenn beide Methoden einen Fehler zurückgegeben haben, wissen wir mit Sicherheit, dass eine konkurrierende Löschung stattgefunden hat.  Stellen Sie sich vor, diese Löschung erfolgte nach dem Aufruf von set.  Unabhängig davon, welchen Wert wir zu ermitteln versuchen, wird er bereits gelöscht.  Sie können also davon ausgehen, dass das Set erfolgreich war, auch wenn tatsächlich nichts geschrieben wurde. <br><br><h3>  Weitere technische Details </h3><br>  In diesem Abschnitt schweifen wir von verteilten Systemen ab und sprechen über das Codieren. <br>  Eine der Hauptanforderungen des Kunden war plattformübergreifend: Unter Linux, MacOS und Windows muss mindestens einer der Dienste unterstützt werden.  Anfangs haben wir die Entwicklung nur unter Linux durchgeführt, und in anderen Systemen haben wir später mit dem Testen begonnen.  Dies verursachte viele Probleme, für die es einige Zeit völlig unklar war, wie man vorgehen sollte.  Daher werden jetzt alle drei Koordinierungsdienste unter Linux und MacOS und nur Consul KV unter Windows unterstützt. <br><br>  Von Anfang an haben wir versucht, vorgefertigte Bibliotheken für den Zugriff auf Dienste zu verwenden.  Im Fall von ZooKeeper fiel die Wahl auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ZooKeeper C ++</a> , das am Ende unter Windows nicht kompiliert werden konnte.  Dies ist jedoch nicht überraschend: Die Bibliothek ist nur unter Linux positioniert.  Für Consul war <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ppconsul</a> die einzige Option.  Ich musste Unterstützung für <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sitzungen</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Transaktionen</a> hinzufügen.  Für etcd wurde nie eine vollwertige Bibliothek gefunden, die die neueste Version des Protokolls unterstützt. Daher haben wir nur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einen grpc-Client generiert</a> . <br><br>  Inspiriert von der asynchronen Schnittstelle der ZooKeeper C ++ - Bibliothek haben wir uns entschlossen, auch die asynchrone Schnittstelle zu implementieren.  In ZooKeeper C ++ werden hierfür Future / Promise-Primitive verwendet.  In STL sind sie leider sehr bescheiden implementiert.  Beispielsweise gibt es keine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">then-Methode</a> , die die übergebene Funktion auf das zukünftige Ergebnis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">anwendet</a> , sobald es verfügbar ist.  In unserem Fall ist eine solche Methode erforderlich, um das Ergebnis in das Format unserer Bibliothek zu konvertieren.  Um dieses Problem zu umgehen, mussten wir unseren einfachen Thread-Pool implementieren, da wir auf Kundenwunsch keine umfangreichen Bibliotheken von Drittanbietern wie Boost verwenden konnten. <br><br>  Unsere Implementierung von funktioniert dann wie folgt.  Beim Aufruf wird ein zusätzliches Versprechen / zukünftiges Paar erstellt.  Die neue Zukunft wird zurückgegeben, und die übertragene wird zusammen mit der entsprechenden Funktion und einem zusätzlichen Versprechen in die Warteschlange gestellt.  Ein Thread aus dem Pool wählt mehrere Futures aus der Warteschlange aus und fragt sie mit wait_for ab.  Wenn das Ergebnis verfügbar ist, wird die entsprechende Funktion aufgerufen und ihr Rückgabewert an Versprechen übergeben. <br><br>  Wir haben denselben Thread-Pool verwendet, um Anforderungen an etcd und Consul auszuführen.  Dies bedeutet, dass mehrere verschiedene Threads mit den zugrunde liegenden Bibliotheken arbeiten können.  ppconsul ist nicht threadsicher, daher sind Aufrufe durch Sperren durch Sperren geschützt. <br>  Sie können mit grpc aus mehreren Threads arbeiten, aber es gibt Feinheiten.  Etcd-Uhren werden über grpc-Streams implementiert.  Dies sind bidirektionale Kanäle für bestimmte Arten von Nachrichten.  Die Bibliothek erstellt einen einzelnen Stream für alle Uhren und einen einzelnen Stream, der eingehende Nachrichten verarbeitet.  Daher verbietet grpc das Streamen paralleler Aufnahmen.  Dies bedeutet, dass Sie beim Initialisieren oder Löschen der Uhr warten müssen, bis das Senden der vorherigen Anforderung abgeschlossen ist, bevor Sie die nächste senden.  Wir verwenden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bedingte Variablen</a> für die Synchronisation. <br><br><h3>  Zusammenfassung </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Überzeugen Sie sich</a> selbst: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">liboffkv</a> . <br><br>  Unser Team: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Raed Romanov</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ivan Glushenkov</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dmitry Kamaldinov</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Victor Krapivensky</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vitaly Ivanin</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de458832/">https://habr.com/ru/post/de458832/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de458818/index.html">Prominente Zeitgenossen</a></li>
<li><a href="../de458820/index.html">Über die Implementierung des berühmten Genres auf der Minecraft-Plattform</a></li>
<li><a href="../de458826/index.html">Wie man alte Artikel aussortiert, damit sie im Bio-Bereich stark wachsen: + 104% des Verkehrs für sechs Monate</a></li>
<li><a href="../de458828/index.html">Warum, warum und wann ValueTask verwendet werden soll</a></li>
<li><a href="../de458830/index.html">Dell Technologies-Webinare: Alle Details unseres Tutorials</a></li>
<li><a href="../de458834/index.html">Seite der Persönlichkeit von Paul Allen, von der nicht so viele Menschen wussten, wie ich möchte</a></li>
<li><a href="../de458836/index.html">Borsch Index. Ein systematischer Ansatz zur Bewertung, zum Vergleich und zur Bestimmung des Preis-Leistungs-Verhältnisses</a></li>
<li><a href="../de458840/index.html">Wie wir die Great Chinese Firewall durchbohrt haben (Teil 2)</a></li>
<li><a href="../de458842/index.html">Geduld und Arbeit werden den gesamten Text extrahieren</a></li>
<li><a href="../de458844/index.html">Silozerstörung durch VeriSM ™ -Anpassungsansatz</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>