<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕘 👨🏾‍🤝‍👨🏻 🐁 Inspirationsquellen bei der Entwicklung für UDB ⬅️ 👨🏿‍🍳 👨🏽‍🎤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nun, wir wissen bereits alles, was Sie zum Programmieren von UDB benötigen. Aber es ist eine Sache zu wissen und eine ganz andere, in der Lage zu sein...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Inspirationsquellen bei der Entwicklung für UDB</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/449960/">  Nun, wir wissen bereits alles, was Sie zum Programmieren von UDB benötigen.  Aber es ist eine Sache zu wissen und eine ganz andere, in der Lage zu sein.  Deshalb werden wir heute diskutieren, wo und wie wir uns inspirieren lassen können, um unsere eigenen Fähigkeiten zu verbessern und Erfahrungen zu sammeln.  Wie aus der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Übersetzung der Dokumentation hervorgeht</a> , gibt es trockenes Wissen, das nicht immer an die reale Praxis gebunden ist (ich habe in einer ziemlich langen Notiz darauf hingewiesen, bis zur letzten Übersetzung bis heute).  Tatsächlich zeigt die Statistik der Artikelansichten, dass immer weniger Menschen Übersetzungen lesen.  Es gab sogar einen Vorschlag, diesen Zyklus als uninteressant zu unterbrechen, aber es blieben nur zwei Teile übrig, weshalb am Ende einfach beschlossen wurde, das Tempo ihrer Vorbereitung zu verkürzen.  Im Allgemeinen ist die Dokumentation für den Controller eine notwendige Sache, aber nicht autark.  Wo sonst kann man sich inspirieren lassen? <br><br><img src="https://habrastorage.org/webt/9n/wy/nb/9nwynby6myz8p5ecl1k5f8l8gwq.jpeg"><br><br>  Zunächst kann ich das hervorragende Dokument <b>AN82156 Entwerfen von PSoC Creator-Komponenten mit UDB-Datenpfaden empfehlen</b> .  Darin finden Sie typische Lösungen sowie mehrere Standardprojekte.  Darüber hinaus wird die Entwicklung zu Beginn des Dokuments mit dem UDB-Editor und gegen Ende mit dem Datapath Config Tool ausgeführt, dh das Dokument deckt alle Aspekte der Entwicklung ab.  Wenn ich jedoch den Preis eines einzelnen PSoC-Chips betrachte, würde ich sagen, dass der Controller stark überbewertet ist, wenn er nur die in diesem Dokument beschriebenen Probleme lösen kann.  PWMs und serielle Standardanschlüsse können ohne PSoC ausgeführt werden.  Glücklicherweise ist das Spektrum der PSoC-Aufgaben viel breiter.  Nachdem wir AN82156 gelesen haben, suchen wir nach anderen Inspirationsquellen. <br><a name="habracut"></a><br>  Die nächste nützliche Quelle sind die Beispiele, die mit PSoC Creator geliefert werden.  Ich habe sie bereits in einem Hinweis auf einen der Teile der Übersetzung der Unternehmensdokumentation erwähnt (siehe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> ).  Sie werden ungefähr hier gespeichert (die Festplatte kann abweichen): <br><br>  E: \ Programme (x86) \ Cypress \ PSoC Creator \ 4.2 \ PSoC Creator \ psoc \ content \ CyComponentLibrary. <br><br>  Sie sollten nach * .v-Dateien suchen, dh nach Verilog-Texten oder * .vhd, da die Syntax der VHDL-Sprache etwas ausführlicher beschrieben werden muss. In dieser Sprache finden Sie manchmal interessante Nuancen, die den Augen des Programmierers bei Verilog verborgen bleiben.  Das Problem ist, dass dies keine Beispiele sind, sondern vorgefertigte Lösungen.  Das ist wunderbar, sie sind perfekt getestet, aber wir, einfache Programmierer, haben mit den Cypress-Programmierern unterschiedliche Ziele.  Unsere Aufgabe ist es, in kurzer Zeit etwas Hilfreiches zu tun. Danach beginnen wir, es in unseren Projekten zu verwenden, für die wir die meiste Zeit aufwenden werden.  Es sollte idealerweise die uns heute zugewiesenen Aufgaben lösen, und wenn wir morgen denselben Code in ein anderes Projekt einfügen möchten, in dem alles etwas anders sein wird, werden wir es morgen in dieser Situation beenden.  Für Cypress-Entwickler ist die Komponente das Endprodukt, sodass sie die meiste Zeit damit verbringen können.  Und sie müssen für alles sorgen.  Als ich mir diese Texte ansah, war ich traurig.  Sie sind zu komplex für jemanden, der gerade angefangen hat, nach Inspirationsquellen für seine ersten Entwicklungen zu suchen.  Aber als Referenz sind diese Texte durchaus geeignet.  Es gibt viele wertvolle Designs, die benötigt werden, um Ihre eigenen Dinge zu erstellen. <br><br>  Auch gibt es sehr interessante Ecken.  Zum Beispiel gibt es, jetzt sage ich im Stil von "Butteröl", Modelle für die Modellierung (vor langer Zeit hat mich ein strenger Lehrer davon abgehalten, Simulationen auf andere Weise als "Modellieren" zu übersetzen).  Sie finden sie im Katalog. <br>  E: \ Programme (x86) \ Cypress \ PSoC Creator \ 4.2 \ PSoC Creator \ warp \ lib \ sim. <br><br>  Das interessanteste Verzeichnis für den Programmierer auf Verilogue ist: <br><br>  E: \ Programme (x86) \ Cypress \ PSoC Creator \ 4.2 \ PSoC Creator \ warp \ lib \ sim \ presynth \ vlg. <br><br>  Die Beschreibung der Komponenten in der Dokumentation ist gut.  Hier werden jedoch Verhaltensmodelle für alle Standardkomponenten beschrieben.  Manchmal ist dies besser als die Dokumentation (die in einer schweren Sprache verfasst ist und einige wesentliche Details weggelassen werden).  Wenn das Verhalten dieser oder jener Komponente nicht klar ist, sollten Sie versuchen, es genau zu verstehen, indem Sie Dateien aus diesem Verzeichnis anzeigen.  Zuerst habe ich versucht, auf Google zu suchen, aber sehr oft habe ich in den gefundenen Foren nur Argumente und keine Einzelheiten getroffen.  Hier sind genau die Einzelheiten. <br><br>  Trotzdem ist das Nachschlagewerk wunderbar, aber wo kann man nach einem Lehrbuch suchen, woraus kann man lernen?  Ehrlich gesagt gibt es nichts Besonderes.  Es gibt nicht viele gute fertige Beispiele für den UDB-Editor.  Ich hatte großes Glück, dass ich, als ich mich plötzlich entschied, RGB-LEDs zu spielen, unter dem UDB-Editor auf ein schönes Beispiel stieß (darüber schrieb ich in dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel</a> , der den gesamten Zyklus startete).  Wenn Sie jedoch viel mit einer Suchmaschine arbeiten, gibt es immer noch Beispiele für das Datapath-Konfigurationstool. Deshalb habe ich den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vorherigen Artikel erstellt,</a> damit jeder versteht, wie dieses Tool verwendet wird.  Und hier befindet sich eine wunderbare Seite, auf der viele Beispiele gesammelt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">werden</a> . <br><br>  Auf dieser Seite finden Sie Entwicklungen von Drittentwicklern, die jedoch von Cypress überprüft wurden.  Das ist genau das, was wir brauchen: Wir sind auch Entwickler von Drittanbietern, aber wir möchten aus etwas lernen, das genau verifiziert ist.  Schauen wir uns ein Beispiel an, in dem ich diese Seite gefunden habe - einen Hardware-Rechner mit Quadratwurzel.  Endbenutzer nehmen es in den Signalverarbeitungspfad auf und werfen eine Komponente auf die Schaltung.  In diesem Beispiel werden wir trainieren, um einen ähnlichen Code zu analysieren, und dann kann jeder unabhängig schwimmen.  Das erforderliche Beispiel kann also über den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Link</a> heruntergeladen werden. <br><br>  Wir untersuchen es.  Es gibt Beispiele (die jeder unabhängig betrachten wird) und Bibliotheken im Verzeichnis \ CJCU_SquareRoot \ Library \ CJCU_SquareRoot.cylib. <br><br>  Für jeden Typ (Ganzzahl oder Festpunkt) und für jedes Bit gibt es eine Lösung.  Dies sollte beachtet werden.  Vielseitigkeit ist gut, wenn Sie im UDB-Editor entwickeln, aber wie Sie sehen, werden Menschen bei der Entwicklung mit dem Datenpfad-Bearbeitungstool wie folgt gequält.  Haben Sie keine Angst, wenn Sie es nicht universell machen können (aber wenn es besser funktioniert). <br><br>  Auf der obersten Ebene (Schaltung) werde ich nicht aufhören, wir studieren nicht mit PSoC, sondern mit UDB.  Schauen wir uns eine Option mittlerer Komplexität an - 16 Bit, aber ganzzahlig.  Es befindet sich im Verzeichnis CJCU_B_Isqrt16_v1_0. <br><br>  Als erstes müssen Sie das Übergangsdiagramm der Firmware erweitern.  Ohne sie werden wir nicht einmal erraten, welche Art von Quadratwurzel-Algorithmus angewendet wurde, da Google eine Auswahl mehrerer grundlegend unterschiedlicher Algorithmen anbietet. <br><br><img src="https://habrastorage.org/webt/ms/xz/la/msxzlahct34myy-jo6ynzdbyph0.png"><br><br>  Bisher ist nichts klar, aber es ist vorhersehbar.  Müssen weitere Informationen hinzufügen.  Wir betrachten die Zustandscodierung.  Es fällt auf, dass sie nicht im üblichen inkrementellen Binärcode codiert sind. <br><br><img src="https://habrastorage.org/webt/le/ef/ni/leefnikfyhpm0bskxxmyhigc_rk.png"><br><br>  Ich habe diesen Ansatz bereits in meinen Artikeln erwähnt, konnte ihn jedoch in bestimmten Beispielen nie verwenden.  Ich möchte Sie daran erinnern, dass die dynamische Konfiguration der RAM ALU nur drei Adresseneingänge hat.  Das heißt, ALU kann eine von acht Operationen ausführen.  Wenn der Automat mehr Zustände hat, wird die Regel "Jeder Zustand hat seine eigene Operation" unmöglich.  Daher werden Zustände ausgewählt, in denen die Operationen für die ALU identisch sind, sie haben drei Bits, die an die RAM-Adresse der dynamischen Konfiguration geliefert werden (normalerweise niederwertige), sie werden auf die gleiche Weise codiert und der Rest auf verschiedene Arten.  Wie man einen solchen Solitaire addiert, ist bereits ein Entwicklerproblem.  Die Entwickler des untersuchten Codes haben genau wie oben gezeigt gefaltet. <br><br>  Fügen Sie diese Informationen zum Diagramm hinzu und färben Sie die Zustände, die dieselbe Funktion in ALU ausführen, in ähnlichen Farben. <br><br><img src="https://habrastorage.org/webt/bs/ur/an/bsuran7bbednztvwwhqllpvsxkq.png"><br><br>  Es wurden noch keine Muster manifestiert, aber wir öffnen das Diagramm weiterhin.  Wir öffnen das Datapath Edit Tool und studieren bereits die darin enthaltene Logik. <br><br>  Bitte beachten Sie, dass zwei Datenpfadblöcke in einer Kette verbunden sind.  Wenn wir etwas Eigenes tun, benötigen wir möglicherweise auch Folgendes (das Datenpfad-Bearbeitungstool kann jedoch Blöcke erstellen, die bereits in einer Kette verknüpft sind, sodass dies nicht beängstigend ist): <br><br><img src="https://habrastorage.org/webt/ww/zy/kp/wwzykp0zjtuvioq7edfl3wgy28w.png"><br><br>  Beim Lesen (und Ausfüllen) des ALU entsprechenden Diagramms öffnen wir immer ein Dokument mit der folgenden Abbildung: <br><br><img src="https://habrastorage.org/webt/kr/nm/5p/krnm5p5sov_is3aijsvjepxgyz4.png"><br><br>  Die Entwickler dieses Beispiels haben sich um uns gekümmert und die Kommentarfelder ausgefüllt.  Jetzt können wir sie verwenden, um zu verstehen, wofür konfiguriert ist.  Gleichzeitig stellen wir für uns selbst fest, dass das Schreiben von Kommentaren immer nützlich ist, sowohl für diejenigen, die den Code begleiten, als auch für uns, wenn wir in sechs Monaten alles darüber vergessen werden. <br><br>  Wir betrachten den X000-Code, der den Zuständen 0 und 12 entspricht: <br><br><img src="https://habrastorage.org/webt/-f/r3/5_/-fr35_p9nmenndof7gn_k1-iv2a.png"><br><br>  Aus dem Kommentar geht bereits hervor, was dort passiert (der Inhalt von Register D0 wird in Register A0 und der Inhalt von D1 in Register A1 kopiert. Da wir dies wissen, trainieren wir unsere Intuition für die Zukunft und finden einen ähnlichen Eintrag in den Einstellungsfeldern: <br><br><img src="https://habrastorage.org/webt/6t/nw/jf/6tnwjfjm-ngl_oavbq6gpw29zwy.png"><br><br>  Dort sehen wir, dass die ALU im <b>PASS-</b> Modus arbeitet, das Schieberegister ist ebenfalls <b>PASS</b> , so dass keine anderen Aktionen wirklich ausgeführt werden. <br><br>  Unterwegs schauen wir uns den Text in Verilog an und sehen, wo der Wert der Register D0 und D1 gleich ist: <br><br><img src="https://habrastorage.org/webt/gv/md/9i/gvmd9i8bc7xc738wf8ozl0fypag.png"><br><br>  Falls gewünscht, können Sie dasselbe im Datenpfad-Konfigurationstool anzeigen, indem Sie Ansicht-&gt; Anfangsregisterwerte wählen: <br><br><img src="https://habrastorage.org/webt/hf/2r/i4/hf2ri4nlc3s_npqmpgn0z_l0sbe.png"><br><br><img src="https://habrastorage.org/webt/dl/aw/xi/dlawxi9bjazna2eofwjtslnbriq.png"><br><br>  Für die Anzeige ist es bequemer, Verilog-Code direkt zu analysieren und eine eigene Version zu erstellen. Arbeiten Sie den Editor ab, um die Syntax nicht zu berücksichtigen. <br><br>  In ähnlicher Weise analysieren wir (zunächst in den Kommentaren) alle anderen Funktionen von ALU: <br><br><img src="https://habrastorage.org/webt/d6/_5/wz/d6_5wzhqokkcgmeiaxskrmeklfc.png"><br><br>  Wir wiederholen den Übergangsgraphen des Automaten unter Berücksichtigung neuer Erkenntnisse: <br><br><img src="https://habrastorage.org/webt/a9/oc/6b/a9oc6b90oehe5lrmrmb1rhpzcv8.png"><br><br>  Es zeichnet sich bereits etwas ab, aber bisher kann ich keinen der von Google in dieser Grafik gefundenen Algorithmen mit Sicherheit festlegen.  Über einige kann man eher zuversichtlich sagen, dass es nicht sie sind, aber selbst für die Glaubwürdigen kann ich immer noch keine sichere Antwort geben, dass sie es sind.  Verwirrt die aktive Verwendung der Register FIFO F0 und F1.  Im Allgemeinen in der Datei <br><br>  \ CJCU_SquareRoot \ Library \ CJCU_SquareRoot.cylib \ CJCU_Isqrt_v1_0 \ API \ CJCU_Isqrt.c <br><br>  Es ist ersichtlich, dass F1 verwendet wird, um das Argument zu übergeben und das Ergebnis zurückzugeben: <br><br><img src="https://habrastorage.org/webt/p3/1_/qj/p31_qjeah1fw3va8adkfc3t7zqk.png"><br><br><div class="spoiler">  <b class="spoiler_title">Gleicher Text:</b> <div class="spoiler_text"><pre><code class="plaintext hljs">void `$INSTANCE_NAME`_ComputeIsqrtAsync(uint`$regWidth` square) { /* Set up FIFOs, start the computation. */ CY_SET_REG`$dpWidth`(`$INSTANCE_NAME`_F1, square); CY_SET_REG8(`$INSTANCE_NAME`_CTL, 0x01); } … uint`$resultWidth` `$INSTANCE_NAME`_ReadIsqrtAsync() { /* Read back result. */ return CY_GET_REG`$dpWidth`(`$INSTANCE_NAME`_F1); }</code> </pre> <br></div></div><br>  Aber ein Argument und ein Ergebnis.  Und warum gibt es im Laufe der Arbeit so viele Anrufe beim FIFO?  Und was hat FIFO0 damit zu tun?  Schneiden Sie mich in Stücke, aber es scheint, dass die Autoren den Modus ausnutzten, der bei Übersetzungen der Dokumentation auftrat, als dieser Block anstelle eines vollwertigen FIFO als ein einziges Register fungierte.  Angenommen, die Autoren haben beschlossen, den Registersatz zu erweitern.  Wenn ja, dann ist ihre Methodik für uns in unserer praktischen Arbeit nützlich. Lassen Sie uns die Details untersuchen.  In der Dokumentation werden verschiedene Ansätze für die Arbeit mit FIFO beschrieben.  Sie können - so können Sie - so, aber Sie können - irgendwie.  Und keine Einzelheiten.  Wir haben wieder die Möglichkeit, uns über die besten internationalen Praktiken zu informieren.  Was machen Autoren mit FIFO? <br><br>  Erstens sind dies die Signalzuweisungen: <br><br><pre> <code class="plaintext hljs"> wire f0_load = (state == B_SQRT_STATE_1 || state == B_SQRT_STATE_4); wire f1_load = (state == B_SQRT_STATE_1 || state == B_SQRT_STATE_3 || state == B_SQRT_STATE_9 || state == B_SQRT_STATE_11); wire fifo_dyn = (state == B_SQRT_STATE_0 || state == B_SQRT_STATE_12);</code> </pre><br>  Zweitens ist hier eine Verbindung zu Datapath: <br><br><pre> <code class="plaintext hljs"> /* input */ .f0_load(f0_load), /* input */ .f1_load(f1_load), /* input */ .d0_load(1'b0), /* input */ .d1_load(fifo_dyn),</code> </pre><br>  Aus der Beschreibung der Steuerung geht nicht besonders hervor, was dies alles bedeutet.  Aber aus Application Note habe ich herausgefunden, dass diese Einstellung für alles verantwortlich ist: <br><br><img src="https://habrastorage.org/webt/uo/gz/re/uogzrechxp9befe1esnivuooth8.png"><br><br>  Gerade wegen dieser Einstellung kann dieser Block übrigens nicht mit dem UDB-Editor beschrieben werden.  Wenn sich diese Steuerbits im <b>EIN-</b> Zustand befinden, kann FIFO an verschiedenen Quellen und Empfängern arbeiten.  Wenn <b>Dx_LOAD</b> gleich eins ist, tauscht <b>Fx</b> mit dem Systembus aus, wenn Null, dann mit dem hier ausgewählten Register: <br><br><img src="https://habrastorage.org/webt/jj/dx/aq/jjdxaqvh9gr1jdfpbv_axilhfac.png"><br><br>  Es stellt sich heraus, dass F0 in den Zuständen 12 und 0 immer mit dem Register A0 und F1 mit dem Systembus (um das Ergebnis hochzuladen und das Argument zu laden), in anderen Zuständen - mit A1 austauscht. <br>  Ferner haben wir aus dem Verilog-Code herausgefunden, dass in F0 die Daten in den Zuständen 1 und 4 und in F1 - in den Zuständen 1, 3, 9, 11 geladen werden. <br><br>  Fügen Sie das erworbene Wissen zum Diagramm hinzu.  Um Verwirrung während der Abfolge der Operationen zu vermeiden, war es auch an der Zeit, die Zuweisungsmarke „a la UDB Editor“ durch Verilogovs Pfeile zu ersetzen, um hervorzuheben, dass die Quelle der Wert des Signals ist, das es vor dem Betreten des Blocks hatte. <br><br><img src="https://habrastorage.org/webt/ct/xx/hl/ctxxhlmqgxywkwpnvhcneksxnyc.png"><br><br>  Aus Sicht der Analyse des Algorithmus ist bereits alles klar.  Vor uns liegt eine Modifikation eines solchen Algorithmus: <br><br><pre> <code class="plaintext hljs">uint32_t SquareRoot(uint32_t a_nInput) { uint32_t op = a_nInput; uint32_t res = 0; uint32_t one = 1uL &lt;&lt; 30; // The second-to-top bit is set: use 1u &lt;&lt; 14 for uint16_t type; use 1uL&lt;&lt;30 for uint32_t type // "one" starts at the highest power of four &lt;= than the argument. while (one &gt; op) { one &gt;&gt;= 2; } while (one != 0) { if (op &gt;= res + one) { op -= res + one; res += one &lt;&lt; 1; } res &gt;&gt;= 1; one &gt;&gt;= 2; } return res; }</code> </pre><br>  Nur in Bezug auf unser System wird es eher so aussehen: <br><br><pre> <code class="plaintext hljs">uint32_t SquareRoot(uint32_t a_nInput) { uint32_t op = a_nInput; uint32_t res = 0; uint32_t one = 1uL &lt;&lt; 14; // The second-to-top bit is set while (one != 0) { if (op &gt;= res + one) { op -= res + one; res += one &lt;&lt; 1; } res &gt;&gt;= 1; one &gt;&gt;= 2; } return res; }</code> </pre><br>  Die Zustände 4 und 10 codieren die Zeichenfolge explizit: <br><br><pre> <code class="plaintext hljs"> res &gt;&gt;= 1;</code> </pre><br>  für verschiedene Branchen. <br><br>  Die Zeile lautet: <br><br><pre> <code class="plaintext hljs"> one &gt;&gt;= 2;</code> </pre><br>  Es wird explizit entweder durch ein Paar von Zuständen 6 und 7 oder durch ein Paar von Zuständen 9 und 7 codiert. Im Moment möchte ich ausrufen: „Nun, die Erfinder sind dieselben Autoren!“, aber sehr bald wird klar, warum es bei zwei Zweigen eine solche Schwierigkeit gibt (im C-Code gibt es einen Zweig und Problemumgehung). <br><br>  Zustand 2 codiert einen bedingten Zweig.  Zustand 7 codiert eine Schleifenanweisung.  Die Vergleichsoperation in Schritt 2 ist sehr teuer.  Im Allgemeinen enthält das Register A0 in den meisten Schritten die Variable Eins.  In Schritt 1 wird jedoch die Variable Eins auf F0 entladen, und stattdessen wird der Wert <b>res + eins</b> geladen. In Schritt 2 wird die Subtraktion zum Vergleich durchgeführt, und in den Schritten 3 und 8 wird der Wert <b>Eins</b> wiederhergestellt.  Warum in Schritt 4 A0 erneut nach F0 kopiert wird, habe ich nicht verstanden.  Vielleicht ist das eine Art Rudiment. <br><br>  Es bleibt herauszufinden, wer <b>res</b> und wer <b>op ist</b> .  Wir wissen, dass die Bedingung op und res + one vergleicht.  In Zustand 1 werden A0 ( <b>eins</b> ) und A1 hinzugefügt.  Da ist also A1 <b>res</b> .  Es stellt sich heraus, dass in Zustand 11 A1 auch <b>res ist</b> , und er ist es, der in F1 gelangt, der dem Ausgang der Funktion zugeführt wird.  F1 in Zustand 1 ist eindeutig <b>op</b> .  Ich schlage vor, die Farbdifferenzierung der <s>Hosen der</s> Variablen einzuführen.  Wir bezeichnen <b>res</b> als rot, <b>op</b> als grün und <b>eins</b> als braun (nicht ganz kontrastiert, aber die anderen Farben sind noch weniger kontrastiert). <br><br><img src="https://habrastorage.org/webt/xl/hs/ns/xlhsnsgsbuqn2s5kdqtv7xh4tac.png"><br><br>  Tatsächlich wird die ganze Wahrheit offenbart.  Wir sehen, wie sich A1 zum Vergleich und für Berechnungen vorübergehend von F1 ändert, wie derselbe Unterschied sowohl zum Vergleich (tatsächlich zur Erzeugung von Bit C) als auch zur Teilnahme an der Formel verwendet wird.  Wir sehen sogar, warum der leere Raum (Bypass) im C-Algorithmus durch einen langen Zweig des Übergangsgraphen des Automaten codiert wird (in diesem Zweig werden die Register identisch mit dem Austausch ausgetauscht, der im Hauptcodezweig stattfindet).  Wir sehen alles. <br><br>  Die einzige Frage, die mich immer wieder quält, ist, wie die Autoren FIFO in den Einzelbyte-Modus geschaltet haben.  In der Dokumentation heißt es, dass Sie dazu die CLR-Bits im Auxiliary Control-Register in eine Einheit heben müssen, aber ich sehe nicht, dass die API über solche Datensätze verfügt.  Vielleicht wird jemand dies verstehen und in die Kommentare schreiben. <br><br>  Nun, und etwas Eigenes zu entwickeln - in umgekehrter Reihenfolge mit den erworbenen Fähigkeiten. <br><br><h3>  Fazit </h3><br>  Um die Fähigkeiten zur Entwicklung von „Firmware“ auf Basis von UDB zu entwickeln, ist es nützlich, nicht nur die Dokumentation zu lesen, sondern sich auch von den Designs anderer inspirieren zu lassen.  Der mit dem PSoC Creator gelieferte Code kann als Referenz hilfreich sein. Die im Compiler enthaltenen Verhaltensmodelle helfen Ihnen dabei, besser zu verstehen, was in der Dokumentation gemeint war.  Der Artikel enthält auch einen Link zu einer Reihe von Beispielen von Drittherstellern und zeigt, wie eines dieser Beispiele analysiert wird. <br><br>  In diesem Zusammenhang kann der Zyklus von Copyright-Artikeln zur Arbeit mit UDB als abgeschlossen betrachtet werden.  Ich würde mich freuen, wenn er jemandem helfen würde, Wissen zu erlangen, das in der Praxis nützlich ist.  Es liegen einige Übersetzungen der Dokumentation vor uns, aber Statistiken zeigen, dass fast niemand sie liest.  Sie sind sauber geplant, um das Thema nicht auf den Punkt zu bringen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de449960/">https://habr.com/ru/post/de449960/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de449946/index.html">1C Developer Tales: admin</a></li>
<li><a href="../de449948/index.html">JavaScript: 7 nützliche Kleinigkeiten</a></li>
<li><a href="../de449952/index.html">Konfigurieren der kontinuierlichen Lieferung auf gitlab.com</a></li>
<li><a href="../de449954/index.html">Installieren Sie Zimbra Open-Source Edition unter CentOS 7</a></li>
<li><a href="../de449956/index.html">AI @ MIPT: Big Data für mathematische Modelle des menschlichen Genoms</a></li>
<li><a href="../de449962/index.html">4G SmartMotion Industrierouter</a></li>
<li><a href="../de449964/index.html">Probefahrt nanoCAD SPDS Baustelle 8. Teil 2</a></li>
<li><a href="../de449966/index.html">Tabellen in Figma. Datenrasterdesign nach einer Komponente</a></li>
<li><a href="../de449968/index.html">Redmadrobot diskutiert AppsConf 2019: Video</a></li>
<li><a href="../de449970/index.html">Poste unter der schwarzen Flagge oder Da ich deinen Videokurs nicht auf den Tracker gesetzt habe</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>