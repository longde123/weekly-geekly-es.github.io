<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤣 🧗🏻 ☘️ Temporizador - Inicio 🙆🏾 🏊 🤜🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Todo comenzó con él. Esta fue mi primera compra en Aliexpress para la primera automatización en el país: quería hacer un autowatering en el invernader...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Temporizador - Inicio</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/422435/"><img src="https://habrastorage.org/webt/yz/s9/r3/yzs9r3pd5_c6uacf0cvy0wbl9r8.jpeg" align="left">  Todo comenzó con él.  Esta fue mi primera compra en Aliexpress para la primera automatización en el país: quería hacer un autowatering en el invernadero.  El temporizador llegó en una caja arrugada, con una tapa protectora rota, pero funcionaba.  Hizo un gran trabajo regando pepinos durante toda la temporada de verano, fue retirado y escondido en un lugar cálido y seco durante el invierno.  Pero la próxima temporada estaba esperando una sorpresa desagradable: el temporizador comenzó a colgar, dejó de responder a los botones de control y abrió el agua.  Al principio pequé con baterías baratas y las reemplacé con la marca Duracell.  Pensé que el problema era el poder y las corrientes de entrada.  No sirvió de nada.  Luego saqué un soldador y solde todo lo que pude en él, incluso agregué algunos condensadores faltantes.  Pero tercamente continuó colgando.  Desafortunadamente, el producto no es muy fácil de mantener, ya que utilicé una caída de microcircuito de circuito abierto y, aparentemente, algo se desmontó precisamente debajo del compuesto con el microcircuito.  De alguna manera, la temporada había terminado con un temporizador tan tambaleante, y comencé a pensar con qué debería reemplazarlo. <br><a name="habracut"></a><br>  Lo primero que pensé fue tomar un módulo Arduino Mini, un módulo de reloj, un indicador, y de alguna manera meterlo todo en el caso de un temporizador roto y usar su motor y válvula de bola nativos.  Pero de alguna manera no fue realmente allí, consumiría claramente más que el relleno original (lo que significa que puede olvidarse de las baterías en el estuche) y era aburrido y no escalable: quería regar no solo el invernadero, sino solo un temporizador roto. <br><br>  Y luego, en Ali, me encontré con una válvula de bola motorizada normal.  Aquí hay un hombre tan guapo: <br><br><img src="https://habrastorage.org/webt/zu/md/c5/zumdc50whupl9mloczorxcmo6sg.jpeg"><br><br>  Sí, cuesta un dinero decente, pero no daba miedo conectarlo con un suministro de agua de verano y dejarlo desatendido durante una semana.  En general, es bastante sólido, aunque con una caja de engranajes de plástico, ahora un par de grifos funcionan en mi suministro principal de agua, donde la presión es de 5 atm. <br><br>  La idea era simple.  Un pañuelo con el módulo WiFi ESP8266 estaba esperando en el cajón de la mesa.  Se decidió abandonar el ahorro de energía en favor de una batería de automóvil usada, que, según los cálculos, debería haber sido suficiente durante al menos un mes de vida útil de la batería. Para no perder el momento de descarga de la batería, el circuito proporcionó un divisor a través del cual el ESP8266 ADC incorporado midió continuamente el voltaje de suministro .  El módulo DS3231 con batería debería haber servido como un reloj en el circuito, y un pañuelo por m / s MP1584EN debería haber reducido el voltaje de 12V a 3.3V. <br><br>  Aquí hay un diagrama de bloques prototipo: <br><br><img src="https://habrastorage.org/webt/qr/23/j6/qr23j6rhqqseg_haa2kevuaglqc.png"><br><div class="spoiler">  <b class="spoiler_title">Y aquí hay una foto de su implementación.</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/ux/80/-p/ux80-pghlpqxovrie-igtxbpuee.jpeg"><br><br>  <i>implementación un poco desmontada: el módulo DC-DC entró en la grúa, el módulo del reloj en la parte posterior de la placa de pruebas</i> <br></div></div><br>  El control del motor de la grúa se realizó aquí simplemente: qué transistores se encontraron en el cajón de la mesa, se instalaron.  En realidad, un motor puede controlarse, por ejemplo, a través de m / s ULN2003 conectando varios canales en paralelo con transistores de efecto de campo con control lógico o en general a través de un módulo de relé con optoaislamiento.  Solo es necesario tener en cuenta que el motor, con una corriente de funcionamiento de aproximadamente 70 mA, tiene una corriente de entrada (y corriente en el momento del bloqueo de rotación) del orden de 300-350 mA. <br><br>  Se escribiría un boceto rápido en Arduino con una interfaz web simple: <br><br><img src="https://habrastorage.org/webt/vq/1u/rc/vq1urcw-ttzsjbbvcm7nbcxcuky.jpeg"><br><br>  Y el prototipo estaba en servicio de prueba.  Reenvié la interfaz web de la grúa a través del enrutador y el dispositivo estaba constantemente disponible en línea. <br><br>  Y los pensamientos continuaron.  Un prototipo es bueno, pero quiero varios de estos toques y hacerlo todo en la placa no es una opción.  La grúa ha sido abierta.  Y quedó claro que hay mucho espacio dentro debajo de una cubierta sellada e incluso hay lugares de fijación: <br><br><img src="https://habrastorage.org/webt/rt/tc/3f/rttc3f_0uzhnlpjql2vp4ds-nvm.jpeg"><br><br>  En ese grifo que se utilizó en el prototipo, debajo de la cubierta había una pequeña placa de circuito con un relé, que proporcionaba lógica de control.  Y en la foto hay una grúa con índice CR05.  No hay lógica o placa de circuito en estos grifos.  Los cables de control del motor y los cables del interruptor de límite simplemente se retiran.  Y necesita controlar tales grúas cambiando la polaridad del voltaje en el motor.  Al mismo tiempo, es muy recomendable controlar los momentos finales de cierre / apertura en los puntos finales del TC, recordamos que la corriente en estos momentos ya es de 300-350 mA. <br><br>  El diagrama de bloques comenzó a aparecer así: <br><br><img src="https://habrastorage.org/webt/ae/a1/uv/aea1uvc0g09wxdkdyxoioq8t8z8.png"><br><br>  Ahora tomamos la pinza, una hoja de papel en nuestras manos y comenzamos a tomar medidas, dibujamos el contorno de la placa de circuito impreso e intentamos colocar los componentes en ella.  Se abandonó una batería CR2032 grande y se usó una pequeña CR1220 (o 1225).  Durante mucho tiempo, se seleccionó un chip de puente H para controlar el motor.  La elección parece ser grande, pero muchos de estos microcircuitos no pueden funcionar con un voltaje de suministro de 12V, o usan transistores bipolares con una caída de voltaje muy grande, o el caso no tiene éxito.  Al principio, el chip TB6612 no me llamó la atención durante mucho tiempo, y luego pareció muy redundante e inconveniente para soldar.  Pero al final me centré en ella: es asequible y económico para Ali.  El puente H está construido sobre transistores de efecto de campo y puede operar con voltajes de hasta 15 voltios.  El módulo convertidor DC-DC (MP1584EN) fue dejado por el módulo; resultó ser simplemente más barato en detalles y fue fácil de soldar.  Lo principal, para la confiabilidad, es reemplazar la resistencia de sintonización en ella por una constante (27kOhm, dará un voltaje de salida de 3.4V). El microcircuito del reloj podría usarse en una caja más compacta, pero había una advertencia: iba a pedir todos los componentes para Ali y existía el riesgo de obtener circuitos falsos o rotos.  Por lo tanto, en la etapa inicial, se planeó comprar todos los microcircuitos como parte de los módulos terminados y soldar a la placa desarrollada.  Y en los módulos, el reloj solo estaba en el caso SO16.  De hecho, solo un microcircuito de reloj resultó defectuoso o falso: su frecuencia de cuarzo fue de 32727 con 32768 kHz configurados. <br><br>  Después de todo el trabajo preparatorio, tomamos KiKad, googleamos un poco en busca de asientos faltantes, dibujamos algunos componentes nosotros mismos y comenzamos a criar el tablero: <br><br><img src="https://habrastorage.org/webt/vj/zf/cy/vjzfcyt6qukg3sj5mev5xhkzcem.jpeg"><br><br>  Lo comprobamos imprimiendo en una escala de 1: 1.  Adjuntamos piezas y módulos y, si todos coinciden, preparamos archivos Gerber para producción y los enviamos a EasyEda.  Después de 3 semanas, obtenemos 10 lindos pañuelos y los recogemos. <br><br><img src="https://habrastorage.org/webt/ui/jn/hs/uijnhsbq8zqklcjm1n-pjhpax-c.jpeg"><br>  <i>Quedan 5 en la foto, el resto todo funciona</i> <br><br><img src="https://habrastorage.org/webt/dn/8c/nx/dn8cnx12fhixuzkxywboqkqfmou.jpeg"><br>  <i>Montaje del módulo</i> <br><br>  Los agujeros para los sujetadores, por supuesto, no coincidieron un poco, algunos de los asientos no resultaron como quisieran, pero en general el producto, después del ensamblaje y el firmware, funcionó de inmediato.  Se compraron colas de potencia herméticas en Ali, pasaron por un sello de presión estándar en el edificio y el temporizador de la grúa WiFi obtuvo su aspecto de fábrica: <br><br><img src="https://habrastorage.org/webt/kz/rn/zy/kzrnzyqalg_t_jsrrrjegdvc98q.jpeg"><br><br>  Aquí hay un par de grúas en servicio de combate en el país: <br><br><div class="spoiler">  <b class="spoiler_title">en la publicación</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/da/sx/ds/dasxds16utudu8su6efnv46dixy.jpeg"><br></div></div><br>  Pero entonces el pensamiento continuó de nuevo.  Quería más automatización en el país, y el módulo resultó ser bastante compacto y universal.  A través del puente H puede controlar fácilmente un relé convencional.  Para la automatización del bricolaje, muchos toman Sonoff, pero resulta que yo mismo no puedo hacerlo peor. <br><br>  Y aquí comienza la transformación de un simple toque de Wi-Fi en lo que se <b>llama SHAPEsp</b> , abreviatura de <b>S</b> mart <b>H</b> ome <b>A</b> utomation <b>P</b> latform basada en <b>Esp</b> 8266.  Según lo planeado, este debería convertirse en un módulo universal económico para la automatización del hogar.  Y todo esto debe ser confiable y verse como un producto terminado después del ensamblaje en un estuche asequible. <br><br>  Sorprendentemente, resultó que en el caso chino con Aliexpress en 2DIN, la unidad está bien, el cuerpo en el cuerpo, el popular convertidor AC / DC 220V / 12V HiLink (bueno, o su clon), el relé y el conector de alimentación, y por supuesto mi módulo ligeramente convertido con ESP8266, reloj y puente en H. <br><br><div class="spoiler">  <b class="spoiler_title">Hazlo una vez</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/bp/wm/xk/bpwmxkb9rxu-mxso9_fbiz9wc4q.jpeg"><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Hacer dos</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/ok/jd/d-/okjdd-orz-ecgzujbub-j-p2hzc.jpeg"><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Hacer tres</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/_i/ip/jm/_iipjmuknwsvpqelavmsrxrj3t0.jpeg"><br>  <i>El módulo se puede instalar tanto en el cuerpo de la grúa como en la carcasa del bastidor DIN</i> <br></div></div><br>  Y obtenemos: <br><br><img src="https://habrastorage.org/webt/ht/2x/ui/ht2xuiatsx_ckjmyit2ihczozh4.jpeg"><br><br>  Ligeramente cambiado la forma del módulo.  Le agregué conectores de borde para que pudiera mantenerse en pie en el paquete 2DIN.  Coloqué LED indicadores en el extremo superior del tablero, que son visibles a la luz en una caja de plástico.  Bueno, extendí la placa de medios para el relé y la fuente de alimentación.  Para hacerlo más barato, todo esto se envió a producción con una placa: <br><br><img src="https://habrastorage.org/webt/un/5j/z2/un5jz2k4nzvoo1g4bhkhdyik7bq.jpeg"><br><br>  Reuní dos de estos prototipos y los puse en la cabaña para controlar la inclusión de convectores para las llegadas de invierno: <br><br><div class="spoiler">  <b class="spoiler_title">En otro post</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/2t/yo/po/2tyopox-lcaqrqdd6yb3j8fqb3i.jpeg"><br>  <i>Uno de los módulos en el panel, junto a un par de contactores que incluyen convectores.</i> <br></div></div><br>  Pero luego decidió mejorarlo aún más y hacerlo más universal.  Para un firmware más confiable y conveniente, coloqué el esquema de firmware de NodeMcu en el módulo.  Dedució todos los pines posibles y agregó almohadillas de contacto para la conveniencia de conectar diferentes sensores.  Todos los pasadores de borde se colocan en incrementos de 2,54 mm, de modo que el módulo se puede insertar en la placa de pruebas.  Naturalmente probé la conexión del termómetro ds1820, el sensor combinado BME280 y el sensor de humedad en el comparador.  Resultó que, además de un temporizador simple con un relé o una grúa, puede construir fácilmente una estación meteorológica o, por ejemplo, un sistema aquastop.  Bueno, todo tipo de otros sistemas de notificación y control ... <br><br>  Llevado, dibujó un modelo de su módulo para Fritzing.  Para que pueda evaluar y rotar las diversas opciones de aplicación virtualmente: <br><br><img src="https://habrastorage.org/webt/ob/rs/qm/obrsqm8tbnl6mknximfdzp7ossc.png"><br><br>  Un enlace al modelo de GitHub se encuentra al final del artículo. <br><br>  Bueno, entonces comienza la parte más difícil: soporte de software para el módulo.  Inicialmente, probé y probé todo con mi boceto Arduino bastante simple.  HTML simple, un poco de script Java, varias formas simples de transmitir datos, solo la funcionalidad de un temporizador y algunos sensores que necesito.  Pero rápidamente se hizo evidente que no sería tan fácil dominar todo y todo en el mundo moderno de IoT y la construcción inteligente de viviendas.  Y también solo pereza (aquí hay una sonrisa sonriente).  Y a veces no quiero reinventar la rueda. <br><br>  Por lo tanto, se decidió ver qué hay de firmware listo para usar en el que puede agregar soporte para su módulo.  Como punto de partida, se tomaron firmwares alternativos para los productos de Sonoff: Sonoff-Tasmota, ESPurna, ESPEasy.  La búsqueda puede encontrar revisiones comparativas de estos firmware. <br><br>  Por ejemplo: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://lobradov.github.io/FOSS-Firmware-comparison-overview/</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><br></a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://lobradov.github.io/FOSS-Firmware-comparison-developers/</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><br></a> <br>  En realidad, de alguna manera revisé el código fuente en los repositorios de estos firmware con mi ojo, me di cuenta de que la forma más fácil para mí sería agregar mi módulo al firmware ESPurna.  El código del firmware estaba estructurado de manera bastante razonable e inicialmente asumió la adición de nuevos módulos y funciones.  En el firmware estaba la funcionalidad del temporizador que necesitaba, el Sheduler independiente.  Además, se puede decir de fábrica, simplemente describiendo mi configuración con un simple relé en el archivo hardware.h, obtuve una versión funcional del firmware del relé WiFi. <br><br>  Sin embargo, mi módulo tenía una funcionalidad más rica y compleja.  Y se decidió contribuir al firmware.  Por un lado, es bastante simple: escribimos funcionalidad y hacemos una solicitud de extracción, pero en realidad es un proceso aburrido y largo con un resultado no siempre positivo o rápido.  Estos son los costos del hecho de que la funcionalidad propuesta en general solo la necesitamos yo y mi placa desconocida. <br><br>  Empecé con el apoyo del reloj.  En el firmware ESPurna, todo funcionaba a través de NTP y la biblioteca Time para arduino; bueno, históricamente, necesita saber la hora, pero los productos Sonoff no tienen un reloj autónomo y se supone que siempre tienen acceso a Internet.  Para admitir el reloj RTC, escribí un módulo simple que, si lo desea, reemplazó la función de proveedor de tiempo de NTP puro a NTP + RTC.  El principio era simple: si la sincronización NTP no está disponible, intentamos leer la hora del reloj RTC local.  Cuando aparece el acceso a los servidores NTP, restauramos la sincronización y, si lo desea, sincronizamos el reloj local.  Entonces el reloj de mi módulo entró en funcionamiento.  La solicitud de extracción se aceptó con bastante rapidez, pero se envió a una rama espurna-rtc separada. <br><br>  La siguiente fue una solicitud de extracción trivial.  Dado que mido el voltaje de suministro al convertidor DC-DC para rastrear la descarga de la batería, necesitaba monitorear no el voltaje de suministro del módulo ESP8266, sino algo definido por el usuario.  Lo que diseñé como una solicitud de extracción "agrega soporte para monitoreo VCC personalizado".  Pero esta solicitud de alguna manera quedó suspendida en el aire ... y el deseo de contribuir de alguna manera disminuyó. <br><br>  Además, se hizo evidente que agregar su módulo a la lista de dispositivos terminados compatibles no será tan fácil: tiene muchas configuraciones diferentes posibles.  Por lo tanto, se decidió simplemente desarrollar su bifurcación de firmware.  Y si es posible y desea mantener la sincronización, haga solicitudes de extracción u ofrezca una selección de cereza en el repositorio de firmware principal. <br><br>  Después de tal decisión, todo se volvió más simple.  En el firmware, el sistema de control de relé fue reescrito parcialmente.  Se le agregó el modo de control H-bridge y se hizo más conveniente en términos de agregar modos de operación de relé personalizados. <br><br>  Un estudio posterior del código de firmware mostró que no es posible refactorizarlo.  El estilo de escribir y usar recursos en algunos lugares es muy cruel para un microcontrolador (aunque es bastante inteligente de 32 bits).  Por ejemplo, el sistema para emitir mensajes de depuración devoró la pila con gran velocidad, pero al mismo tiempo, solo para no soltar todo el sistema, se bloqueó cuando el tamaño de la pila llegó a ser inferior a 10kB.  Reescribí el código en mi hilo un poco para que ahora todos los mensajes de depuración y las indicaciones en la consola se muestren por completo. <br><br>  Bueno, por el momento, se ha agregado un subsistema de cálculo al firmware <br>  Amaneceres / atardeceres y un SunriseSensor virtual, para que pueda construir un relé astronómico simple desde el módulo SHAPEsp.  Será necesario tener coraje y comprometerse con el repositorio principal.  Creo que esta es una funcionalidad útil. <br><br>  Aquí hay una historia de la transformación de ideas de bricolaje de un prototipo a un producto casi terminado.  Quizás un producto en demanda.  Lo más sorprendente es que aún no he probado ningún sistema doméstico inteligente: todos los módulos funcionan para mí de manera completamente autónoma y son accesibles a través de interfaces web en Internet.  Y una vez comprada, la placa de PC OrangePi se encuentra en un cajón y está esperando en las alas para convertirse en un controlador de casa inteligente. <br><br>  Lista de enlaces: <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Fritzing model y cómo me reúno, creo que habrá un diseño de circuito y módulo en Kikad</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Prueba simple de firmware para el módulo</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Horquilla de firmware ESPurna con soporte de módulo</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El repositorio principal de firmware ESPurna</a> <br></li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es422435/">https://habr.com/ru/post/es422435/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es422425/index.html">Una descripción general de los métodos de posprocesamiento para modelos impresos en 3D FDM</a></li>
<li><a href="../es422427/index.html">Dagaz: fuera de la niebla</a></li>
<li><a href="../es422429/index.html">Aceleramos el proceso de desarrollo de proyectos complejos. Sin caos y nervios</a></li>
<li><a href="../es422431/index.html">Hadas japonesas muestran gatillo maestro-esclavo en nuevo manga en electrónica digital</a></li>
<li><a href="../es422433/index.html">Paneles solares y carreteras de asfalto. Simbiosis de tecnología</a></li>
<li><a href="../es422437/index.html">Juegos de experiencia del usuario y velocidad del sitio web y de la aplicación</a></li>
<li><a href="../es422439/index.html">La pelea con Yandex: cómo pasé más de un año para llevar el sitio a la cima</a></li>
<li><a href="../es422441/index.html">Encontré una fórmula para una transición indolora a .Net Core</a></li>
<li><a href="../es422443/index.html">Temporizador preciso Corona SDK</a></li>
<li><a href="../es422445/index.html">Implementación de BottomAppBar. Parte 3: Comportamiento para Android</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>