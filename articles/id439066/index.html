<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏽‍🤝‍👨🏻 🤫 👵🏽 Sistem operasi pada Rust. Memori Halaman: Tingkat Lanjut 🔺 ➖ 👨🏼‍🍳</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Artikel ini menjelaskan bagaimana kernel sistem operasi dapat mengakses frame memori fisik. Kami akan mempelajari fungsi untuk mengubah alamat virtual...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sistem operasi pada Rust. Memori Halaman: Tingkat Lanjut</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/439066/">  Artikel ini menjelaskan bagaimana kernel sistem operasi dapat mengakses frame memori fisik.  Kami akan mempelajari fungsi untuk mengubah alamat virtual menjadi alamat fisik.  Kami juga akan mencari cara membuat pemetaan baru di tabel halaman. <br><br>  Blog ini diposting di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GitHub</a> .  Jika Anda memiliki pertanyaan atau masalah, buka tiket terkait di sana.  Semua sumber untuk artikel ada di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br><h1>  Pendahuluan </h1><br>  Dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel terakhir,</a> kami belajar tentang prinsip-prinsip memori paging dan bagaimana tabel halaman empat tingkat pada x86_64 bekerja.  Kami juga menemukan bahwa loader sudah mengatur hierarki tabel halaman untuk kernel kami, jadi kernel tersebut berjalan pada alamat virtual.  Ini meningkatkan keamanan, tetapi muncul masalah: bagaimana cara mengakses alamat fisik nyata yang disimpan dalam entri tabel halaman atau <code>CR3</code> ? <br><a name="habracut"></a><br>  Di bagian pertama artikel, kita akan membahas masalah dan berbagai pendekatan untuk menyelesaikannya.  Kemudian kami menerapkan fungsi yang menyelinap melalui hierarki tabel halaman untuk mengubah alamat virtual menjadi yang fisik.  Akhirnya, pelajari cara membuat pemetaan baru dalam tabel halaman dan menemukan bingkai memori yang tidak digunakan untuk membuat tabel baru. <br><br><h2>  Pembaruan Ketergantungan </h2><br>  Untuk bekerja, Anda perlu <code>x86_64</code> versi 0.4.0 atau yang lebih baru.  Perbarui ketergantungan dalam <code>Cargo.toml</code> kami: <br><br><pre> <code class="rust hljs">[dependencies] x86_64 = <span class="hljs-string"><span class="hljs-string">"0.4.0"</span></span> # or later</code> </pre> <br><h1>  Akses ke tabel halaman </h1><br>  Mengakses tabel halaman dari kernel tidak semudah kelihatannya.  Untuk memahami masalah ini, lihat hierarki tabel empat tingkat dari artikel sebelumnya: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9c8/5e8/a14/9c85e8a145a9078cfcfd92e204f69a5b.svg"></div><br><br>  Yang penting adalah bahwa setiap entri halaman menyimpan alamat <i>fisik</i> dari tabel berikut.  Ini menghindari terjemahan dari alamat-alamat ini, yang mengurangi kinerja dan dengan mudah mengarah ke loop tanpa akhir. <br><br>  Masalahnya adalah kita tidak dapat secara langsung mengakses alamat fisik dari kernel, karena ia juga bekerja pada alamat virtual.  Sebagai contoh, ketika kita pergi ke alamat <code>4 KiB</code> , kita mendapatkan akses ke alamat <i>virtual</i> <code>4 KiB</code> , dan bukan ke alamat <i>fisik di</i> mana tabel halaman tingkat 4 disimpan.  Jika kita ingin mengakses alamat fisik <code>4 KiB</code> , maka kita perlu menggunakan beberapa alamat virtual, yang diterjemahkan ke dalamnya. <br><br>  Oleh karena itu, untuk mengakses frame dari tabel halaman, Anda perlu memetakan beberapa halaman virtual ke frame ini.  Ada berbagai cara untuk membuat pemetaan seperti itu. <br><br>  1. Solusi sederhana adalah <b>tampilan identik dari semua tabel halaman</b> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8f3/813/916/8f3813916cd0a5b5174c8d14dabedb7a.svg"></div><br><br>  Dalam contoh ini, kita melihat tampilan bingkai yang identik.  Alamat fisik tabel halaman pada saat yang sama adalah alamat virtual yang valid, sehingga kita dapat dengan mudah mengakses tabel halaman dari semua level, dimulai dengan register CR3. <br><br>  Namun, pendekatan ini mengacaukan ruang alamat virtual dan membuatnya sulit untuk menemukan area memori bebas yang bersebelahan.  Katakanlah kita ingin membuat area memori virtual 1000 KiB pada gambar di atas, misalnya, untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menampilkan file dalam memori</a> .  Kami tidak dapat memulai dengan wilayah <code>28  KiB</code> , karena terletak pada halaman yang sudah diduduki pada <code>1004  KiB</code> .  Oleh karena itu, Anda harus melihat lebih jauh hingga kami menemukan fragmen besar yang cocok, misalnya, dengan <code>1008  KiB</code> .  Ada masalah fragmentasi yang sama seperti pada memori tersegmentasi. <br><br>  Selain itu, pembuatan tabel halaman baru jauh lebih rumit, karena kita perlu menemukan bingkai fisik yang halaman yang sesuai belum digunakan.  Misalnya, untuk file kami, kami memesan area seluas 1000 KiB memori <i>virtual</i> , mulai dari alamat <code>1008  KiB</code> .  Sekarang kita tidak dapat lagi menggunakan bingkai apa pun dengan alamat fisik antara <code>1000  KiB</code> dan <code>2008  KiB</code> , karena tidak dapat ditampilkan secara identik. <br><br>  2. Pilihan lain adalah untuk <b>menyiarkan tabel halaman hanya sementara</b> ketika Anda perlu mengaksesnya.  Untuk perbandingan sementara, tampilan identik hanya dari tabel level pertama diperlukan: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/84e/177/978/84e177978079c02224d4032fa02f053b.png"></div><br><br>  Dalam gambar ini, tabel level 1 mengelola 2 MiB pertama dari ruang alamat virtual.  Hal ini dimungkinkan karena akses dilakukan dari register CR3 melalui entri nol pada tabel level 4, 3 dan 2. Catatan dengan indeks <b>8</b> menerjemahkan halaman virtual pada <code>32 KiB</code> menjadi kerangka fisik pada <code>32 KiB</code> , dengan demikian mengidentifikasi tabel level 1 itu sendiri. Pada gambar ini ditunjukkan oleh panah horizontal. <br><br>  Dengan menulis ke tabel level 1 yang dipetakan secara identik, kernel kami dapat membuat hingga 511 perbandingan waktu (512 dikurangi catatan yang diperlukan untuk pemetaan identitas).  Dalam contoh di atas, kernel cocok dengan catatan nol dari tabel level 1 dengan frame pada <code>24 KiB</code> .  Ini menciptakan pemetaan sementara dari halaman virtual pada <code>0 KiB</code> ke bingkai fisik tabel level halaman 2 yang ditunjukkan oleh panah bertitik.  Sekarang kernel dapat mengakses tabel level 2 dengan menulis ke halaman yang dimulai pada <code>0 KiB</code> . <br><br>  Dengan demikian, akses ke bingkai tabel halaman yang sewenang-wenang dengan pemetaan sementara terdiri dari tindakan berikut: <br><br><ul><li>  Temukan entri gratis di tabel level 1 yang ditampilkan secara identik. <br></li><li>  Petakan entri ini ke bingkai fisik tabel halaman yang ingin kita akses. <br></li><li>  Akses bingkai ini melalui halaman virtual yang terkait dengan entri. <br></li><li>  Atur rekaman kembali ke yang tidak digunakan, sehingga menghapus pemetaan sementara. </li></ul><br>  Dengan pendekatan ini, ruang alamat virtual tetap bersih, karena 512 halaman virtual yang sama terus digunakan.  Kerugiannya adalah beberapa ketidaknyamanan, terutama karena perbandingan baru mungkin memerlukan perubahan beberapa tingkat tabel, yaitu, kita perlu mengulangi proses yang dijelaskan beberapa kali. <br><br>  3. Meskipun kedua pendekatan di atas bekerja, ada metode ketiga: <b>tabel halaman rekursif</b> .  Ini menggabungkan keuntungan dari kedua pendekatan: itu terus-menerus membandingkan semua frame dari tabel halaman, tanpa memerlukan perbandingan sementara, dan juga menjaga halaman yang berdekatan berdampingan, menghindari fragmentasi ruang alamat virtual.  Ini adalah metode yang akan kita gunakan. <br><br><h2>  Tabel Halaman Rekursif </h2><br>  Idenya adalah untuk menerjemahkan beberapa catatan dari tabel tingkat keempat ke dalamnya.  Dengan demikian, kami benar-benar memesan bagian dari ruang alamat virtual dan memetakan semua frame tabel saat ini dan masa depan ke ruang ini. <br><br>  Mari kita lihat contoh untuk memahami bagaimana semua ini bekerja: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/779/ee6/d9b/779ee6d9bf771dec8e6d22c0440e503d.png"></div><br><br>  Satu-satunya perbedaan dari contoh di awal artikel adalah catatan tambahan dengan indeks <code>511</code> di tabel level 4, yang dipetakan ke bingkai fisik <code>4 KiB</code> , yang terletak di tabel ini sendiri. <br><br>  Saat CPU mencatat, ini tidak merujuk ke tabel level 3, tetapi lagi-lagi merujuk ke tabel level 4. Ini mirip dengan fungsi rekursif yang memanggil dirinya sendiri.  Adalah penting bahwa prosesor mengasumsikan bahwa setiap record di tabel level 4 menunjuk ke tabel level 3, jadi sekarang ia memperlakukan tabel level 4 sebagai tabel level 3. Ini berfungsi karena tabel semua level di x86_64 memiliki struktur yang sama. <br><br>  Dengan mengikuti rekaman rekursif satu atau lebih kali sebelum memulai konversi yang sebenarnya, kita dapat secara efektif mengurangi jumlah level yang dilalui prosesor.  Sebagai contoh, jika kita mengikuti catatan rekursif sekali, dan kemudian pergi ke tabel level 3, prosesor berpikir bahwa tabel level 3 adalah tabel level 2. Selanjutnya, dia menganggap tabel level 2 sebagai tabel level 1, dan tabel level 1 dipetakan bingkai dalam memori fisik.  Ini berarti bahwa kita sekarang dapat membaca dan menulis ke tabel level 1 halaman karena prosesor berpikir ini adalah bingkai yang dipetakan.  Gambar di bawah ini menunjukkan lima langkah terjemahan ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bda/ac7/191/bdaac719103c574c655efa3604d0b842.png"></div><br><br>  Demikian pula, kita dapat mengikuti entri rekursif dua kali sebelum memulai konversi untuk mengurangi jumlah level yang diteruskan menjadi dua: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7f4/b9a/c47/7f4b9ac47fce9552dead4e551b804256.png"></div><br><br>  Mari kita menjalani prosedur ini langkah demi langkah.  Pertama, CPU mengikuti entri rekursif di tabel level 4 dan berpikir bahwa ia telah mencapai tabel level 3. Kemudian ia mengikuti catatan rekursif lagi dan berpikir bahwa ia telah mencapai level 2. Tetapi pada kenyataannya itu masih di level 4. Kemudian CPU pergi ke alamat baru. dan masuk ke tabel level 3, tetapi berpikir itu sudah ada di tabel level 1. Akhirnya, pada titik entri berikutnya di tabel level 2, prosesor berpikir telah mengakses frame memori fisik.  Ini memungkinkan kita untuk membaca dan menulis ke tabel level 2. <br><br>  Tabel level 3 dan 4 juga dapat diakses. Untuk mengakses tabel level 3 kita mengikuti catatan rekursif tiga kali: prosesor berpikir bahwa itu sudah ada di tabel level 1, dan pada langkah berikutnya kita mencapai level 3, yang CPU anggap sebagai bingkai yang dipetakan.  Untuk mengakses tabel level 4 itu sendiri, kita cukup mengikuti catatan rekursif empat kali sampai prosesor memproses tabel level 4 itu sendiri sebagai bingkai yang dipetakan (berwarna biru pada gambar di bawah). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/487/a82/92c/487a8292cf8fe673f1914f5f198c0956.png"></div><br><br>  Konsep ini sulit dipahami pada awalnya, tetapi dalam praktiknya ia bekerja dengan cukup baik. <br><br><h4>  Perhitungan Alamat </h4><br>  Jadi, kita dapat mengakses tabel dari semua level dengan mengikuti rekaman rekursif satu atau lebih kali.  Karena indeks dalam tabel empat level diturunkan langsung dari alamat virtual, alamat virtual khusus harus dibuat untuk metode ini.  Seperti yang kita ingat, indeks tabel halaman diekstraksi dari alamat sebagai berikut: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c44/33c/8f9/c4433c8f99b6fcb54d4b79983ca35dbc.svg"></div><br><br>  Misalkan kita ingin mengakses tabel level 1 yang menampilkan halaman tertentu.  Seperti yang kita pelajari di atas, Anda harus melalui catatan rekursif sekali, dan kemudian melalui indeks level 4, 3 dan 2.  Untuk melakukan ini, kami memindahkan semua blok alamat satu blok ke kanan dan mengatur indeks catatan rekursif ke tempat indeks awal level 4: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/62a/d82/b54/62ad82b54b233a37e40b964953a16bf8.svg"></div><br><br>  Untuk mengakses tabel level 2 halaman ini, kami memindahkan semua blok indeks dua blok ke kanan dan mengatur indeks rekursif ke tempat kedua blok sumber: level 4 dan level 3: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d9/ae5/7c8/1d9ae57c8c68a0b239e5b37397a4d0f7.svg"></div><br><br>  Untuk mengakses tabel level 3, kami melakukan hal yang sama, kami hanya menggeser ke kanan sudah tiga blok alamat. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4b8/6ee/c9f/4b86eec9fd1df3445718ed8246fd4473.svg"></div><br><br>  Akhirnya, untuk mengakses tabel level 4, pindahkan semuanya empat blok ke kanan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/36b/6b0/29b/36b6b029b31578b143ff1e7605e358fb.svg"></div><br><br>  Sekarang Anda dapat menghitung alamat virtual untuk tabel halaman dari keempat level.  Kita bahkan dapat menghitung alamat yang secara tepat menunjuk ke entri tabel halaman tertentu dengan mengalikan indeksnya dengan 8, ukuran entri tabel halaman. <br><br>  Tabel di bawah ini menunjukkan struktur alamat untuk mengakses berbagai jenis bingkai: <br><br><table><thead><tr><th>  Alamat virtual untuk </th><th>  Struktur alamat ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">oktal</a> ) </th></tr></thead><tbody><tr><td>  Halaman </td><td> <code>0o_SSSSSS_AAA_BBB_CCC_DDD_EEEE</code> </td> </tr><tr><td>  Entri di tabel level 1 </td><td> <code>0o_SSSSSS_RRR_AAA_BBB_CCC_DDDD</code> </td> </tr><tr><td>  Entri dalam tabel level 2 </td><td> <code>0o_SSSSSS_RRR_RRR_AAA_BBB_CCCC</code> </td> </tr><tr><td>  Entri dalam tabel level 3 </td><td> <code>0o_SSSSSS_RRR_RRR_RRR_AAA_BBBB</code> </td> </tr><tr><td>  Entri di tabel level 4 </td><td> <code>0o_SSSSSS_RRR_RRR_RRR_RRR_AAAA</code> </td> </tr></tbody></table><br>  Di sini <code></code> adalah indeks level 4, <code></code> adalah level 3, <code></code> adalah level 2, dan <code>DDD</code> adalah indeks level 1 untuk frame yang ditampilkan, <code>EEEE</code> adalah offset-nya.  <code>RRR</code> adalah indeks dari catatan rekursif.  Indeks (tiga digit) dikonversi menjadi offset (empat digit) dengan mengalikannya dengan 8 (ukuran entri tabel halaman).  Dengan offset ini, alamat yang dihasilkan langsung menunjuk ke entri tabel halaman yang sesuai. <br><br>  <code>SSSS</code> adalah bit ekspansi dari digit yang ditandatangani, yaitu, semuanya adalah salinan dari bit 47. Ini adalah persyaratan khusus untuk alamat yang valid dalam arsitektur x86_64, yang kami bahas dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel sebelumnya</a> . <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Alamatnya oktal</a> , karena setiap karakter oktal mewakili tiga bit, yang memungkinkan Anda untuk memisahkan indeks tabel 9-bit pada level yang berbeda.  Ini tidak mungkin dalam sistem heksadesimal, di mana setiap karakter mewakili empat bit. <br><br><h2>  Implementasi </h2><br>  Setelah semua teori ini, kita akhirnya bisa melanjutkan implementasi.  Dengan mudah, loader tidak hanya menghasilkan tabel halaman, tetapi juga tampilan rekursif pada catatan terakhir tabel level 4. Loader melakukan ini karena jika tidak akan ada masalah ayam atau telur: kita perlu mengakses tabel level 4 untuk membuat peta rekursif tetapi kami tidak dapat mengaksesnya tanpa tampilan apa pun. <br><br>  Kami sudah menggunakan pemetaan rekursif ini di akhir artikel sebelumnya untuk mengakses tabel level 4 melalui alamat hard-code <code>0xffff_ffff_ffff_f000</code> .  Jika kita mengonversi alamat ini menjadi oktal dan membandingkannya dengan tabel di atas, kita akan melihat bahwa alamat tersebut persis sesuai dengan struktur catatan di tabel level 4 dengan <code>RRR</code> = <code>0o777</code> , <code>AAAA</code> = <code>0</code> dan bit ekstensi tanda <code>1</code> : <br><br><pre>  struktur: 0o_SSSSSS_RRR_RRR_RRR_RRR_AAAA
 alamat: 0o_177777_777_777_777_777_0000 </pre><br>  Berkat pengetahuan tabel rekursif, sekarang kita dapat membuat alamat virtual untuk mengakses semua tabel aktif.  Dan buatlah fungsi siaran. <br><br><h3>  Terjemahan Alamat </h3><br>  Sebagai langkah pertama, buat fungsi yang mengubah alamat virtual menjadi alamat fisik, melewati hierarki tabel halaman: <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/lib.rs pub mod memory;</span></span></code> </pre> <br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs use x86_64::PhysAddr; use x86_64::structures::paging::PageTable; /// Returns the physical address for the given virtual address, or `None` if the /// virtual address is not mapped. pub fn translate_addr(addr: usize) -&gt; Option&lt;PhysAddr&gt; { // introduce variables for the recursive index and the sign extension bits // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> Don't hardcode these values let r = 0o777; // recursive index let sign = 0o177777 &lt;&lt; 48; // sign extension // retrieve the page table indices of the address that we want to translate let l4_idx = (addr &gt;&gt; 39) &amp; 0o777; // level 4 index let l3_idx = (addr &gt;&gt; 30) &amp; 0o777; // level 3 index let l2_idx = (addr &gt;&gt; 21) &amp; 0o777; // level 2 index let l1_idx = (addr &gt;&gt; 12) &amp; 0o777; // level 1 index let page_offset = addr &amp; 0o7777; // calculate the table addresses let level_4_table_addr = sign | (r &lt;&lt; 39) | (r &lt;&lt; 30) | (r &lt;&lt; 21) | (r &lt;&lt; 12); let level_3_table_addr = sign | (r &lt;&lt; 39) | (r &lt;&lt; 30) | (r &lt;&lt; 21) | (l4_idx &lt;&lt; 12); let level_2_table_addr = sign | (r &lt;&lt; 39) | (r &lt;&lt; 30) | (l4_idx &lt;&lt; 21) | (l3_idx &lt;&lt; 12); let level_1_table_addr = sign | (r &lt;&lt; 39) | (l4_idx &lt;&lt; 30) | (l3_idx &lt;&lt; 21) | (l2_idx &lt;&lt; 12); // check that level 4 entry is mapped let level_4_table = unsafe { &amp;*(level_4_table_addr as *const PageTable) }; if level_4_table[l4_idx].addr().is_null() { return None; } // check that level 3 entry is mapped let level_3_table = unsafe { &amp;*(level_3_table_addr as *const PageTable) }; if level_3_table[l3_idx].addr().is_null() { return None; } // check that level 2 entry is mapped let level_2_table = unsafe { &amp;*(level_2_table_addr as *const PageTable) }; if level_2_table[l2_idx].addr().is_null() { return None; } // check that level 1 entry is mapped and retrieve physical address from it let level_1_table = unsafe { &amp;*(level_1_table_addr as *const PageTable) }; let phys_addr = level_1_table[l1_idx].addr(); if phys_addr.is_null() { return None; } Some(phys_addr + page_offset) }</span></span></code> </pre> <br>  Pertama, kami memperkenalkan variabel untuk indeks rekursif (511 = <code>0o777</code> ) dan bit ekstensi tanda (masing-masing adalah 1).  Kemudian kami menghitung indeks tabel halaman dan offset melalui operasi bitwise, seperti yang ditunjukkan dalam ilustrasi: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c44/33c/8f9/c4433c8f99b6fcb54d4b79983ca35dbc.svg"></div><br><br>  Langkah selanjutnya adalah menghitung alamat virtual dari empat tabel halaman, seperti yang dijelaskan pada bagian sebelumnya.  Selanjutnya, dalam fungsinya, kami mengonversi masing-masing alamat ini ke tautan <code>PageTable</code> .  Ini adalah operasi yang tidak aman karena kompiler tidak dapat mengetahui bahwa alamat ini valid. <br><br>  Setelah menghitung alamat, kami menggunakan operator pengindeksan untuk melihat catatan di tabel level 4. Jika catatan ini nol, maka tidak ada tabel level 3 untuk catatan level 4. Ini berarti bahwa <code>addr</code> tidak dipetakan ke memori fisik apa pun.  Jadi kami mengembalikan <code>None</code> .  Kalau tidak, kita tahu bahwa tabel level 3 ada.  Kemudian kami ulangi prosedurnya, seperti pada tingkat sebelumnya. <br><br>  Setelah memeriksa tiga halaman dari level yang lebih tinggi, kita akhirnya bisa membaca catatan dari tabel level 1, yang memberi tahu kita kerangka fisik yang dengannya peta dipetakan.  Sebagai langkah terakhir, tambahkan offset halaman ke dalamnya - dan kembalikan alamatnya. <br><br>  Jika kami tahu pasti bahwa alamat itu dipetakan, kami dapat langsung mengakses tabel level 1 tanpa melihat halaman-halaman dari level yang lebih tinggi.  Tetapi karena kita tidak mengetahuinya, pertama-tama kita perlu memeriksa apakah tabel level 1 ada, jika tidak fungsi kita akan mengembalikan kesalahan kegagalan halaman untuk alamat yang tidak cocok. <br><br><h4>  Coba </h4><br>  Mari kita coba menggunakan fungsi terjemahan untuk alamat virtual di fungsi <code>_start</code> kami: <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] #[no_mangle] pub extern "C" fn _start() -&gt; ! { […] // initialize GDT, IDT, PICS use blog_os::memory::translate_addr; // the identity-mapped vga buffer page println!("0xb8000 -&gt; {:?}", translate_addr(0xb8000)); // some code page println!("0x20010a -&gt; {:?}", translate_addr(0x20010a)); // some stack page println!("0x57ac001ffe48 -&gt; {:?}", translate_addr(0x57ac001ffe48)); println!("It did not crash!"); blog_os::hlt_loop(); }</span></span></code> </pre> <br><br>  Setelah memulai, kami melihat hasil berikut: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1bd/e62/054/1bde620549428279e6c1f1647d88a062.png"></div><br><br>  Seperti yang diharapkan, alamat 0xb8000 yang terkait dengan pengenal diterjemahkan ke alamat fisik yang sama.  Halaman kode dan halaman stack dikonversi ke beberapa alamat fisik yang berubah-ubah, yang tergantung pada bagaimana loader membuat pemetaan awal untuk kernel kami. <br><br><h4> <code> RecursivePageTable</code> </h4> <br>  x86_64 menyediakan jenis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>RecursivePageTable</code></a> yang mengimplementasikan abstraksi aman untuk berbagai operasi tabel halaman.  Dengan menggunakan tipe ini, Anda dapat mengimplementasikan fungsi <code>translate_addr</code> secara lebih ringkas: <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs use x86_64::structures::paging::{Mapper, Page, PageTable, RecursivePageTable}; use x86_64::{VirtAddr, PhysAddr}; /// Creates a RecursivePageTable instance from the level 4 address. /// /// This function is unsafe because it can break memory safety if an invalid /// address is passed. pub unsafe fn init(level_4_table_addr: usize) -&gt; RecursivePageTable&lt;'static&gt; { let level_4_table_ptr = level_4_table_addr as *mut PageTable; let level_4_table = &amp;mut *level_4_table_ptr; RecursivePageTable::new(level_4_table).unwrap() } /// Returns the physical address for the given virtual address, or `None` if /// the virtual address is not mapped. pub fn translate_addr(addr: u64, recursive_page_table: &amp;RecursivePageTable) -&gt; Option&lt;PhysAddr&gt; { let addr = VirtAddr::new(addr); let page: Page = Page::containing_address(addr); // perform the translation let frame = recursive_page_table.translate_page(page); frame.map(|frame| frame.start_address() + u64::from(addr.page_offset())) }</span></span></code> </pre> <br>  Jenis <code>RecursivePageTable</code> sepenuhnya merangkum merangkak tabel halaman tidak aman, sehingga kode <code>unsafe</code> dalam fungsi <code>translate_addr</code> tidak lagi diperlukan.  Fungsi <code>init</code> tetap tidak aman karena harus menjamin kebenaran <code>level_4_table_addr</code> diteruskan. <br><br>  Fungsi <code>_start</code> kami harus diperbarui untuk masuk kembali fungsi sebagai berikut: <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] #[no_mangle] pub extern "C" fn _start() -&gt; ! { […] // initialize GDT, IDT, PICS use blog_os::memory::{self, translate_addr}; const LEVEL_4_TABLE_ADDR: usize = 0o_177777_777_777_777_777_0000; let recursive_page_table = unsafe { memory::init(LEVEL_4_TABLE_ADDR) }; // the identity-mapped vga buffer page println!("0xb8000 -&gt; {:?}", translate_addr(0xb8000, &amp;recursive_page_table)); // some code page println!("0x20010a -&gt; {:?}", translate_addr(0x20010a, &amp;recursive_page_table)); // some stack page println!("0x57ac001ffe48 -&gt; {:?}", translate_addr(0x57ac001ffe48, &amp;recursive_page_table)); println!("It did not crash!"); blog_os::hlt_loop(); }</span></span></code> </pre> <br>  Sekarang, alih-alih meneruskan <code>LEVEL_4_TABLE_ADDR</code> untuk <code>translate_addr</code> dan mengakses tabel halaman melalui pointer mentah yang tidak aman, kami meneruskan referensi ke tipe <code>RecursivePageTable</code> .  Dengan demikian, kami sekarang memiliki abstraksi yang aman dan semantik kepemilikan yang jelas.  Ini memastikan bahwa kami tidak akan dapat secara tidak sengaja mengubah tabel halaman dalam akses bersama, karena mengubahnya memerlukan kepemilikan eksklusif <code>RecursivePageTable</code> . <br><br>  Fungsi ini memberikan hasil yang sama dengan fungsi terjemahan asli yang ditulis secara manual. <br><br><h4>  Membuat fitur yang tidak aman lebih aman </h4><br> <code>memory::init</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">adalah fungsi yang tidak aman: memerlukan blok untuk memanggilnya </font></font><code>unsafe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, karena penelepon harus menjamin bahwa persyaratan tertentu dipenuhi. Dalam kasus kami, persyaratannya adalah bahwa alamat yang ditransmisikan secara tepat dipetakan ke kerangka fisik dari tabel halaman level 4. </font><font style="vertical-align: inherit;">Seluruh tubuh dari fungsi yang tidak aman ditempatkan </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">di blok </font></font><code>unsafe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sehingga semua jenis operasi dilakukan tanpa membuat blok tambahan </font></font><code>unsafe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Karena itu, kita tidak perlu blok yang tidak aman untuk dereferencing </font></font><code>level_4_table_ptr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span></span>(level_4_table_addr: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) -&gt; RecursivePageTable&lt;<span class="hljs-symbol"><span class="hljs-symbol">'static</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> level_4_table_ptr = level_4_table_addr <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> PageTable; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> level_4_table = &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> *level_4_table_ptr; <span class="hljs-comment"><span class="hljs-comment">// &lt;- this operation is unsafe RecursivePageTable::new(level_4_table).unwrap() }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Masalahnya adalah kita tidak segera melihat bagian mana yang tidak aman. </font><font style="vertical-align: inherit;">Misalnya, tanpa melihat </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">definisi suatu fungsi,</font></font></a> <code>RecursivePageTable::new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kita tidak dapat mengatakan apakah itu aman atau tidak. </font><font style="vertical-align: inherit;">Jadi sangat mudah untuk secara tidak sengaja melewatkan beberapa kode yang tidak aman. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk menghindari masalah ini, Anda dapat menambahkan fungsi bawaan yang aman:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs pub unsafe fn init(level_4_table_addr: usize) -&gt; RecursivePageTable&lt;'static&gt; { /// Rust currently treats the whole body of unsafe functions as an unsafe /// block, which makes it difficult to see which operations are unsafe. To /// limit the scope of unsafe we use a safe inner function. fn init_inner(level_4_table_addr: usize) -&gt; RecursivePageTable&lt;'static&gt; { let level_4_table_ptr = level_4_table_addr as *mut PageTable; let level_4_table = unsafe { &amp;mut *level_4_table_ptr }; RecursivePageTable::new(level_4_table).unwrap() } init_inner(level_4_table_addr) }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang blok </font></font><code>unsafe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diperlukan lagi untuk dereferencing </font></font><code>level_4_table_ptr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dan kami segera melihat bahwa ini adalah satu-satunya operasi yang tidak aman. </font><font style="vertical-align: inherit;">Rust saat ini memiliki </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RFC</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> terbuka </font><font style="vertical-align: inherit;">untuk mengubah properti yang gagal fungsi tidak aman ini.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Buat pemetaan baru </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saat kami membaca tabel halaman dan membuat fungsi konversi, langkah selanjutnya adalah membuat pemetaan baru dalam hierarki tabel halaman. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kompleksitas operasi ini tergantung pada halaman virtual yang ingin kami tampilkan. Dalam kasus paling sederhana, tabel halaman level 1 sudah ada untuk halaman ini, dan kita hanya perlu membuat satu entri. Dalam kasus yang paling sulit, halaman tersebut berada di area memori yang level 3-nya belum ada, jadi pertama-tama Anda perlu membuat tabel baru level 3, level 2 dan level 1.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mari kita mulai dengan case sederhana ketika Anda tidak perlu membuat tabel baru. Pemuat dimuat ke megabyte pertama ruang alamat virtual, jadi kami tahu bahwa untuk wilayah ini ada tabel level 1. yang valid. Sebagai contoh kami, kami dapat memilih halaman yang tidak digunakan di area memori ini, misalnya, halaman di alamat </font></font><code>0x1000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Kami menggunakan </font></font><code>0xb8000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bingkai buffer teks VGA </font><font style="vertical-align: inherit;">sebagai bingkai yang diinginkan </font><font style="vertical-align: inherit;">. Sangat mudah untuk memeriksa cara kerja terjemahan alamat kami. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami mengimplementasikannya dalam fungsi baru </font></font><code>create_maping</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dalam modul </font></font><code>memory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs use x86_64::structures::paging::{FrameAllocator, PhysFrame, Size4KiB}; pub fn create_example_mapping( recursive_page_table: &amp;mut RecursivePageTable, frame_allocator: &amp;mut impl FrameAllocator&lt;Size4KiB&gt;, ) { use x86_64::structures::paging::PageTableFlags as Flags; let page: Page = Page::containing_address(VirtAddr::new(0x1000)); let frame = PhysFrame::containing_address(PhysAddr::new(0xb8000)); let flags = Flags::PRESENT | Flags::WRITABLE; let map_to_result = unsafe { recursive_page_table.map_to(page, frame, flags, frame_allocator) }; map_to_result.expect("map_to failed").flush(); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fungsi menerima referensi yang bisa berubah ke </font></font><code>RecursivePageTable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(itu akan mengubahnya) dan </font></font><code>FrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, yang dijelaskan di bawah ini. Kemudian menerapkan fungsi </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>map_to</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dalam baki </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>Mapper</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk memetakan halaman di alamat </font></font><code>0x1000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dengan bingkai fisik di alamat </font></font><code>0xb8000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Fungsi ini tidak aman, karena dimungkinkan untuk melanggar keamanan memori dengan argumen yang tidak valid. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selain argumen </font></font><code>page</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>frame</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, fungsi </font></font><code>map_to</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">membutuhkan dua argumen lagi. Argumen ketiga adalah set bendera untuk tabel halaman. Kami menetapkan bendera yang </font></font><code>PRESENT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diperlukan untuk semua entri yang valid dan bendera </font></font><code>WRITABLE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk kemampuan menulis. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Argumen keempat haruslah beberapa struktur yang mengimplementasikan sifat tersebut </font></font><code>FrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Argumen ini diperlukan oleh metode.</font></font><code>map_to</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">karena membuat tabel halaman baru mungkin memerlukan bingkai yang tidak digunakan. Implementasi membutuhkan sifat argumen </font></font><code>Size4KiB</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, seperti jenis </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>Page</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>PhysFrame</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">universal yang</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> untuk sifat tersebut </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>PageSize</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, bekerja dengan standar 4 halaman KIB dan dengan halaman yang sangat besar 2 MiB / 1 GiB. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fungsi ini </font></font><code>map_to</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mungkin gagal, jadi itu kembali </font></font><code>Result</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Karena ini hanyalah contoh kode yang seharusnya tidak dapat diandalkan, kami cukup menggunakannya </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>expect</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dengan panik ketika terjadi kesalahan. Jika berhasil, fungsi mengembalikan jenis </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>MapperFlush</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang menyediakan cara mudah untuk menghapus halaman yang baru-baru ini cocok dari metode buffer terjemahan terjemahan (TLB) </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>flush</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Seperti</font></font><code>Result</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, jenisnya menggunakan atribut </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>#[must_use]</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan mengeluarkan peringatan jika kita secara tidak sengaja lupa untuk menerapkannya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena kita tahu bahwa alamat </font></font><code>0x1000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">itu tidak memerlukan tabel halaman baru, itu </font></font><code>FrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">selalu dapat kembali </font></font><code>None</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Untuk menguji fungsi, buat ini </font></font><code>EmptyFrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs /// A FrameAllocator that always returns `None`. pub struct EmptyFrameAllocator; impl FrameAllocator&lt;Size4KiB&gt; for EmptyFrameAllocator { fn allocate_frame(&amp;mut self) -&gt; Option&lt;PhysFrame&gt; { None } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Jika metode 'kesalahan </font></font><code>allocate_frame</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bukan anggota sifat </font></font><code>FrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">' </font><font style="vertical-align: inherit;">muncul </font><font style="vertical-align: inherit;">, Anda perlu meningkatkan </font></font><code>x86_64</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ke versi 0.4.0.) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang kita dapat menguji fungsi terjemahan baru:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] #[no_mangle] pub extern "C" fn _start() -&gt; ! { […] // initialize GDT, IDT, PICS use blog_os::memory::{create_example_mapping, EmptyFrameAllocator}; const LEVEL_4_TABLE_ADDR: usize = 0o_177777_777_777_777_777_0000; let mut recursive_page_table = unsafe { memory::init(LEVEL_4_TABLE_ADDR) }; create_example_mapping(&amp;mut recursive_page_table, &amp;mut EmptyFrameAllocator); unsafe { (0x1900 as *mut u64).write_volatile(0xf021f077f065f04e)}; println!("It did not crash!"); blog_os::hlt_loop(); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pertama, kami membuat pemetaan untuk halaman di alamat </font></font><code>0x1000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, memanggil fungsi </font></font><code>create_example_mapping</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dengan tautan yang dapat diubah ke instance </font></font><code>RecursivePageTable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ini menerjemahkan halaman </font></font><code>0x1000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menjadi buffer teks VGA, jadi kita akan melihat beberapa hasil di layar. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lalu kami menulis nilai di halaman ini </font></font><code>0xf021f077f065f04e</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, yang sesuai dengan baris </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Baru!" </font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pada latar belakang putih. </font><font style="vertical-align: inherit;">Hanya saja, tidak perlu menuliskan nilai ini segera ke atas halaman </font></font><code>0x1000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, karena baris teratas akan bergerak berikutnya dari layar </font></font><code>println</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dan menuliskannya di offset </font></font><code>0x900</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang terletak kira-kira di tengah layar. </font><font style="vertical-align: inherit;">Seperti yang kita ketahui dari artikel </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Mode Teks VGA"</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , menulis ke buffer VGA harus volatile, jadi kami menggunakan metode ini </font></font><code>write_volatile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ketika kami menjalankannya di QEMU, kami melihat ini: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ef9/1bc/672/ef91bc672e33cbec8847b77028b7624e.png"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tulisan di layar. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kode berfungsi karena sudah ada tabel level 1 untuk menampilkan halaman </font></font><code>0x1000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Jika kami mencoba menerjemahkan halaman yang tabelnya belum ada, fungsinya </font></font><code>map_to</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">akan menghasilkan kesalahan, karena ia akan mencoba memilih bingkai dari untuk membuat tabel halaman baru </font></font><code>EmptyFrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Kami akan melihat ini jika kami mencoba menerjemahkan halaman </font></font><code>0xdeadbeaf000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">alih-alih </font></font><code>0x1000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs pub fn create_example_mapping(…) { […] let page: Page = Page::containing_address(VirtAddr::new(0xdeadbeaf000)); […] } // in src/main.rs #[no_mangle] pub extern "C" fn _start() -&gt; ! { […] unsafe { (0xdeadbeaf900 as *mut u64).write_volatile(0xf021f077f065f04e)}; […] }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Saat memulai, panik dimulai dengan pesan kesalahan berikut: </font></font><br><br><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> panik di 'map_to gagal: FrameAllocationFailed', /.../result.rs:999haps </font></font></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk menampilkan halaman yang belum memiliki tabel level 1 halaman, Anda harus membuat yang benar </font></font><code>FrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Tapi bagaimana Anda tahu frame mana yang gratis dan berapa banyak memori fisik yang tersedia?</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Informasi boot </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Komputer yang berbeda memiliki jumlah memori fisik yang berbeda dan area yang berbeda disediakan oleh perangkat seperti VGA berbeda. Hanya firmware BIOS atau UEFI yang tahu persis area memori mana yang dapat digunakan dan mana yang dicadangkan. Kedua standar firmware menyediakan fungsi untuk mendapatkan kartu alokasi memori, tetapi hanya dapat dipanggil pada awal pengunduhan. Karena itu, bootloader kami telah meminta informasi ini (dan lainnya) dari BIOS. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk meneruskan informasi ke kernel OS, loader sebagai argumen saat memanggil fungsi </font></font><code>_start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memberikan tautan ke struktur informasi boot. Tambahkan argumen ini ke fungsi kami:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs use bootloader::bootinfo::BootInfo; #[cfg(not(test))] #[no_mangle] pub extern "C" fn _start(boot_info: &amp;'static BootInfo) -&gt; ! { // new argument […] }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Struktur ini </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>BootInfo</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">masih difinalisasi, jadi jangan kaget ketika crash ketika memutakhirkan ke versi bootloader masa depan yang </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tidak kompatibel dengan semver</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Dia saat ini memiliki tiga bidang </font></font><code>p4_table_addr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>memory_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>package</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bidang ini </font></font><code>p4_table_addr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">berisi alamat virtual rekursif dari tabel halaman level 4. Berkat ini, Anda tidak perlu mendaftarkan alamat tersebut dengan keras </font></font><code>0o_177777_777_777_777_777_0000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bidang </font></font><code>memory_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ini paling menarik, karena berisi daftar semua area memori dan jenisnya (tidak digunakan, dicadangkan, atau yang lain).</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Field </font></font><code>package</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">adalah fungsi saat ini untuk mengaitkan data tambahan dengan loader. </font><font style="vertical-align: inherit;">Implementasinya belum selesai, jadi kita bisa mengabaikannya untuk saat ini.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sebelum menggunakan bidang </font></font><code>memory_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk membuat yang benar </font></font><code>FrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, kami ingin menjamin jenis argumen yang benar </font></font><code>boot_info</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Makro </font></font><code>entry_point</code> </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena </font></font><code>_start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ini disebut secara eksternal, tanda tangan dari fungsi tidak dicentang. </font><font style="vertical-align: inherit;">Ini berarti bahwa argumen arbitrer tidak akan menyebabkan kesalahan kompilasi, tetapi dapat menyebabkan crash atau perilaku runtime yang tidak ditentukan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk memverifikasi tanda tangan, kotak </font></font><code>bootloader</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk mendefinisikan fungsi Karat sebagai titik masuk menggunakan makro </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>entry_point</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dengan tipe yang divalidasi. </font><font style="vertical-align: inherit;">Kami menulis ulang fungsi kami untuk makro ini:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs use bootloader::{bootinfo::BootInfo, entry_point}; entry_point!(kernel_main); #[cfg(not(test))] fn kernel_main(boot_info: &amp;'static BootInfo) -&gt; ! { […] // initialize GDT, IDT, PICS let mut recursive_page_table = unsafe { memory::init(boot_info.p4_table_addr as usize) }; […] // create and test example mapping println!("It did not crash!"); blog_os::hlt_loop(); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk titik masuk, Anda tidak perlu lagi menggunakan </font></font><code>extern "C"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">atau </font></font><code>no_mangle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, karena makro menetapkan titik masuk nyata tingkat rendah </font></font><code>_start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Fungsi </font></font><code>kernel_main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sekarang </font><font style="vertical-align: inherit;">telah </font><font style="vertical-align: inherit;">menjadi fungsi Rust yang benar-benar normal, sehingga kita dapat memilih nama arbitrer untuk itu. </font><font style="vertical-align: inherit;">Penting bahwa itu sudah diketik, sehingga kesalahan kompilasi terjadi jika Anda mengubah tanda tangan fungsi, misalnya, dengan menambahkan argumen atau mengubah tipenya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perhatikan bahwa sekarang kami mengirim ke </font></font><code>memory::init</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">alamat hard-coded, tetapi </font></font><code>boot_info.p4_table_addr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dengan demikian, kode ini akan berfungsi bahkan jika versi bootloader mendatang memilih entri lain di tabel tabel level 4 halaman untuk tampilan rekursif.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pemilihan Bingkai </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang, berkat informasi dari BIOS, kami memiliki akses ke kartu alokasi memori, sehingga Anda dapat membuat distributor bingkai normal. </font><font style="vertical-align: inherit;">Mari kita mulai dengan kerangka umum:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs pub struct BootInfoFrameAllocator&lt;I&gt; where I: Iterator&lt;Item = PhysFrame&gt; { frames: I, } impl&lt;I&gt; FrameAllocator&lt;Size4KiB&gt; for BootInfoFrameAllocator&lt;I&gt; where I: Iterator&lt;Item = PhysFrame&gt; { fn allocate_frame(&amp;mut self) -&gt; Option&lt;PhysFrame&gt; { self.frames.next() } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bidang ini </font></font><code>frames</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diinisialisasi oleh </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">iterator</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bingkai </font><font style="vertical-align: inherit;">sewenang-wenang </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ini memungkinkan Anda untuk mendelegasikan panggilan </font></font><code>alloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ke metode </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Iterator :: next</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inisialisasi </font></font><code>BootInfoFrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">terjadi pada fungsi baru </font></font><code>init_frame_allocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs use bootloader::bootinfo::{MemoryMap, MemoryRegionType}; /// Create a FrameAllocator from the passed memory map pub fn init_frame_allocator( memory_map: &amp;'static MemoryMap, ) -&gt; BootInfoFrameAllocator&lt;impl Iterator&lt;Item = PhysFrame&gt;&gt; { // get usable regions from memory map let regions = memory_map .iter() .filter(|r| r.region_type == MemoryRegionType::Usable); // map each region to its address range let addr_ranges = regions.map(|r| r.range.start_addr()..r.range.end_addr()); // transform to an iterator of frame start addresses let frame_addresses = addr_ranges.flat_map(|r| r.into_iter().step_by(4096)); // create `PhysFrame` types from the start addresses let frames = frame_addresses.map(|addr| { PhysFrame::containing_address(PhysAddr::new(addr)) }); BootInfoFrameAllocator { frames } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fungsi ini, menggunakan kombinator, mengubah peta alokasi memori asli menjadi iterator dari frame fisik yang digunakan: </font></font><br><br><ul><li>    <code>iter</code>        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>MemoryRegion</code></a> .    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>filter</code></a> ,      .          ,  ,    (,   )     ,    <code>InUse</code>  .  ,    ,      - . <br></li><li>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>map</code></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> range</a> Rust          . <br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Langkah ketiga adalah yang paling sulit: kami mengubah setiap rentang menjadi iterator menggunakan metode </font></font><code>into_iter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dan kemudian memilih setiap alamat ke-4096 </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>step_by</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Karena ukuran halaman adalah 4096 byte (4 KiB), kami mendapatkan alamat awal setiap frame. </font><font style="vertical-align: inherit;">Laman pemuat meluruskan semua area memori yang digunakan, jadi kami tidak memerlukan kode pelurusan atau pembulatan. </font><font style="vertical-align: inherit;">Mengganti </font></font><code>map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dengan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>flat_map</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, kita </font></font><code>Iterator&lt;Item = u64&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">malah </font><font style="vertical-align: inherit;">mendapatkan </font></font><code>Iterator&lt;Item = Iterator&lt;Item = u64&gt;&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada tahap akhir, kami akan mengonversi alamat mulai menjadi tipe </font></font><code>PhysFrame</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk membangun yang diperlukan </font></font><code>Iterator&lt;Item = PhysFrame&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Kemudian gunakan iterator ini untuk membuat dan mengembalikan yang baru </font></font><code>BootInfoFrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang kita dapat mengubah fungsi kita </font></font><code>kernel_main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sehingga melewati instance </font></font><code>BootInfoFrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sebagai gantinya </font></font><code>EmptyFrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] fn kernel_main(boot_info: &amp;'static BootInfo) -&gt; ! { […] // initialize GDT, IDT, PICS use x86_64::structures::paging::{PageTable, RecursivePageTable}; let mut recursive_page_table = unsafe { memory::init(boot_info.p4_table_addr as usize) }; // new let mut frame_allocator = memory::init_frame_allocator(&amp;boot_info.memory_map); blog_os::memory::create_mapping(&amp;mut recursive_page_table, &amp;mut frame_allocator); unsafe { (0xdeadbeaf900 as *mut u64).write_volatile(0xf021f077f065f04e)}; println!("It did not crash!"); blog_os::hlt_loop(); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang terjemahan alamat berhasil - dan kita kembali melihat pesan hitam putih </font><i><font style="vertical-align: inherit;">“Baru!”</font></i><font style="vertical-align: inherit;"> Di layar</font></font><i><font style="vertical-align: inherit;"></font></i>  .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di belakang layar, metode ini </font></font><code>map_to</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">membuat tabel halaman yang hilang sebagai berikut:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mengekstrak bingkai yang tidak digunakan dari </font></font><code>frame_allocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cocok dengan entri tabel tingkat atas dengan bingkai ini. </font><font style="vertical-align: inherit;">Bingkai sekarang dapat diakses melalui tabel halaman rekursif.</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nol bingkai untuk membuat tabel halaman baru yang kosong. </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pergi ke tabel level berikutnya. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meskipun fungsi kami </font></font><code>create_maping</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hanyalah sebuah contoh, kami sekarang dapat membuat pemetaan baru untuk halaman sewenang-wenang. </font><font style="vertical-align: inherit;">Ini sangat berguna ketika mengalokasikan memori dan mengimplementasikan multithreading di artikel mendatang.</font></font><br><br><h1>  Ringkasan </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam artikel ini, Anda belajar cara menggunakan tabel rekursif level 4 untuk menerjemahkan semua frame ke alamat virtual yang dapat dihitung. </font><font style="vertical-align: inherit;">Kami menggunakan metode ini untuk mengimplementasikan fungsi terjemahan alamat dan membuat pemetaan baru dalam tabel halaman. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami melihat bahwa membuat pemetaan baru membutuhkan bingkai yang tidak digunakan untuk tabel baru. </font><font style="vertical-align: inherit;">Frame distributor seperti itu dapat diimplementasikan berdasarkan informasi dari BIOS yang diberikan oleh bootloader ke kernel kami.</font></font><br><br><h1>  Apa selanjutnya </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada artikel selanjutnya, kita akan membuat area memori heap untuk kernel kita, yang akan memungkinkan kita untuk </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mengalokasikan memori</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan menggunakan berbagai </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jenis koleksi</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id439066/">https://habr.com/ru/post/id439066/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id439050/index.html">Pelatihan Cisco 200-125 CCNA v3.0. Cisco Certified Network Specialist (CCNA). Hari 2. Model OSI dan TCP-IP</a></li>
<li><a href="../id439056/index.html">Integrasi Merek Semen</a></li>
<li><a href="../id439060/index.html">7 jenis pelanggan</a></li>
<li><a href="../id439062/index.html">Anisoprint Composer: Pencetakan 3D Kekuatan Tinggi</a></li>
<li><a href="../id439064/index.html">Kesalahan grid yang khas (Bootstrap Grid), atau mengapa perancang dan perancang tata letak tidak saling memahami</a></li>
<li><a href="../id439068/index.html">Kampanye spam “Love You” dialihkan ke Jepang</a></li>
<li><a href="../id439070/index.html">China akan meninggalkan sistem AI anti-korupsi Zero Trust karena efisiensinya yang tinggi</a></li>
<li><a href="../id439072/index.html">Manifes Pengembang Smart Home: 15 prinsip</a></li>
<li><a href="../id439076/index.html">Di mana aplikasi menunggu kode berbahaya yang tidak dikenal?</a></li>
<li><a href="../id439078/index.html">Perm programmer perm ditahan karena membuat aplikasi mobile melalui mana pedofil bertindak</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>