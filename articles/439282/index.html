<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👉🏽 🏥 👐 Efectos de filtrado SVG. Parte 1. Filtros SVG 101 🐝 ⚡️ 🆒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La serie de artículos propuesta, " Efectos de filtrado SVG " , de Sara Soueidan, un desarrollador independiente de interfaz UI / UX y autor de muchos ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Efectos de filtrado SVG. Parte 1. Filtros SVG 101</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/439282/"><p>  La serie de artículos propuesta, " <strong>Efectos de filtrado SVG</strong> " <strong>,</strong> de Sara Soueidan, un desarrollador independiente de interfaz UI / UX y autor de muchos artículos técnicos con sede en Líbano, se centra en el trabajo de los filtros SVG y consta de los siguientes artículos: </p><br><h1 id="effekty-filtracii-svg">  Efectos de filtrado SVG </h1><br><ol><li>  Efectos de los filtros SVG.  Parte 1. Filtros SVG 101. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Efectos de los filtros SVG.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 2. Contornee el texto usando feMorfología</a> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Efectos de filtrado SVG.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 3. El efecto de la posterización de la imagen usando feComponentTransfer</a> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Efectos de filtrado SVG.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 4. Imágenes a dos colores con <strong>feComponentTransfer</strong></a> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Efectos de filtrado SVG.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 5. Hacer coincidir el texto con la textura de la superficie con <strong>feDisplacementMap</strong></a> </li></ol><br><hr><br><p>  Este es el primer artículo de una serie sobre filtros SVG.  Esta guía lo ayudará a comprender qué es y le mostrará cómo usarlos para crear sus propios efectos visuales. </p><br><p><img src="https://habrastorage.org/webt/_8/ka/is/_8kaisnavnh_qmr3tvdsxofq0ii.png"></p><a name="habracut"></a><br><p>  <strong>CSS</strong> actualmente nos proporciona una forma de aplicar efectos de color a las imágenes, como la saturación, el brillo y el contraste, entre otros efectos, utilizando la propiedad de <strong>filtro</strong> y las funciones que la acompañan. </p><br><p>  Ahora tenemos 11 funciones de filtro en CSS que realizan una serie de efectos, desde desenfoque hasta cambio de contraste y saturación de color, y mucho más.  Para obtener más información sobre esto, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">consulte la referencia de CSS</a> . </p><br><p>  Aunque potentes y muy convenientes, los filtros CSS también son muy limitados.  Los efectos que podemos crear con ellos a menudo son aplicables a las imágenes y se limitan a la manipulación del color y al desenfoque simple.  Por lo tanto, para crear efectos más potentes que podamos aplicar a una gama más amplia de elementos, necesitamos una gama más amplia de funciones.  Estas características están disponibles hoy y han estado disponibles durante más de diez años en SVG.  En este artículo, que es el primero de una serie sobre filtros SVG, aprenderá acerca de las funciones de los filtros SVG, conocidos como "primitivos", y cómo usarlos. </p><br><p>  Los filtros CSS se importan de SVG.  Son versiones bastante bien optimizadas de un subconjunto de los efectos de filtrado introducidos en SVG y existentes en la especificación SVG durante muchos años. </p><br><p>  SVG tiene más efectos de filtrado que CSS, y las versiones de SVG son más potentes y realizan efectos mucho más complejos que sus accesos directos CSS.  Por ejemplo, actualmente puede desenfocar un elemento utilizando la función de filtro CSS <strong>blur ()</strong> .  La aplicación del efecto de desenfoque con esta función creará un desenfoque gaussiano uniforme del elemento al que se aplica.  La siguiente figura muestra el resultado de aplicar 6px blur a una imagen en CSS: </p><br><p><img src="https://habrastorage.org/webt/b0/qa/fy/b0qafyst_uc08euvuxzilp13-wi.png" alt="Efecto de aplicar la función ** blur () ** - desenfoque gaussiano"><br>  <em>Fig_1.</em>  <em>El efecto de aplicar la función CSS <strong>blur ()</strong> es desenfoque gaussiano.</em> </p><br><p>  La función de <strong>desenfoque ()</strong> crea un efecto de desenfoque que se aplica uniformemente en ambas direcciones (X e Y) en la imagen.  Pero esta función es simplemente una reducción simplificada y limitada de la primitiva del filtro de desenfoque disponible en SVG, que nos permite desenfocar la imagen de manera uniforme o aplicar un efecto de desenfoque unidireccional a lo largo de los ejes X o Y. </p><br><p><img src="https://habrastorage.org/webt/e5/gp/rr/e5gprr6riymt0ede8sxusumcyfk.png" alt="El efecto de aplicar la función SVG ** desenfoque () ** por separado a lo largo de los ejes"><br>  <em>Fig_2.</em>  <em>El efecto de aplicar la función SVG <strong>blur () por</strong> separado a lo largo de los ejes.</em> </p><br><p>  Los filtros SVG pueden aplicarse tanto a elementos HTML como a elementos SVG.  El efecto de filtrado SVG se puede aplicar a un elemento HTML en CSS utilizando la función de filtro url ().  Por ejemplo, si tiene un efecto de filtro con el identificador <strong>myAwesomeEffect</strong> definido en SVG (hablaremos sobre la definición de efectos de filtro en SVG en un futuro próximo), puede aplicar este efecto a un elemento HTML o imagen como esta: </p><br><pre><code class="plaintext hljs">.el { filter: url(#myAwesomeEffect); }</code> </pre> <br><p>  Lo mejor de todo, como verá en esta serie de artículos, los filtros SVG son capaces de crear efectos de nivel de Photoshop en un navegador utilizando unas pocas líneas de código.  Espero que esta serie ayude a disipar el halo de secretismo y desate parte del potencial de los filtros SVG, lo que lo inspirará a usarlos en sus propios proyectos. </p><br><p>  Pero, ¿qué pasa con el soporte del navegador, preguntas? </p><br><h2 id="podderzhka-brauzerami">  Soporte del navegador </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">La compatibilidad del navegador para la</a> mayoría de los filtros SVG es impresionante.  Sin embargo, el método de aplicar el efecto puede diferir en algunos navegadores dependiendo de su compatibilidad con primitivas de filtro individuales utilizadas en el efecto de filtrado SVG, así como de posibles errores del navegador.  El soporte del navegador también puede diferir cuando se aplica un filtro SVG a elementos SVG o elementos HTML. </p><br><p>  Le recomendaría que considere los efectos de filtrado como una extensión: casi siempre puede aplicar un efecto como una mejora además de una experiencia completamente útil sin un filtro.  Mucha gente sabe que apoyo el enfoque progresivo para crear IU siempre que sea posible.  Por lo tanto, no nos preocuparemos demasiado por el soporte del navegador en esta serie de artículos. </p><br><p>  Finalmente, aunque la compatibilidad con los filtros SVG es generalmente buena, tenga en cuenta que algunos de los efectos que discutiremos más adelante pueden considerarse experimentales.  Indicaré cualquier problema o error importante, si lo hacen y cuándo lo harán. </p><br><p>  Entonces, ¿cómo definir y crear un efecto de filtrado en SVG? </p><br><h2 id="element--filter">  Elemento &lt;Filter&gt; </h2><br><p>  Al igual que los gradientes lineales, las máscaras, los patrones y otros efectos gráficos en SVG, los filtros tienen un elemento especializado convenientemente denominado: <strong>&lt;filtro&gt;</strong> . </p><br><p>  Nunca se muestra directamente, pero se usa solo como un objeto al que se puede hacer referencia usando el atributo de <strong>filtro</strong> en SVG o la función <strong>url ()</strong> en CSS.  Los elementos que no se muestran sin una referencia explícita generalmente se definen como plantillas dentro de elementos <strong>&lt;defs&gt;</strong> en SVG.  Pero SVG <strong>&lt;filter&gt;</strong> no necesita estar envuelto en un elemento <strong>defs</strong> .  Ya sea que <strong>ajuste</strong> el filtro en un elemento <strong>defs</strong> o no, no se mostrará de todos modos. </p><br><p>  La razón de esto es que el <strong>filtro requiere que se procese la imagen original</strong> .  Y si no define explícitamente esta imagen de origen llamando al filtro, el filtro no tendrá nada que representar y, por lo tanto, no funcionará. </p><br><p>  Un ejemplo de código muy simple y mínimo que define un filtro SVG y lo aplica a la imagen original en SVG se verá así: </p><br><pre> <code class="plaintext hljs">&lt;svg width="600" height="450" viewBox="0 0 600 450"&gt; &lt;filter id="myFilter"&gt; &lt;!-- filter effects go in here --&gt; &lt;/filter&gt; &lt;image xlink:href="..." width="100%" height="100%" x="0" y="0" filter="url(#myFilter)"&gt;&lt;/image&gt; &lt;/svg&gt;</code> </pre> <br><p>  El filtro en el ejemplo de código anterior no hace nada en este momento, ya que está vacío.  Para crear un efecto de filtro, debe definir una serie de una o más operaciones de filtrado que creen este efecto dentro del filtro.  En otras palabras, el elemento <strong>&lt;filter&gt;</strong> es un contenedor para una serie de operaciones de filtrado que juntas crean un efecto de filtro.  Estas operaciones de filtrado en SVG se denominan " <strong>primitivas de filtro</strong> ". </p><br><h2 id="primitivy-filtra">  Filtrar primitivas </h2><br><p>  Por lo tanto, en SVG, cada elemento <strong>&lt;filter&gt;</strong> contiene un conjunto de primitivas de filtro como elementos secundarios.  Cada primitiva de filtro realiza una operación gráfica elemental en una o varias entradas, creando un resultado gráfico. </p><br><p>  Las primitivas de filtro se nombran convenientemente después de las operaciones gráficas que realizan.  Por ejemplo, una primitiva que aplica el efecto Desenfoque gaussiano a una fuente gráfica se llama <strong>feGaussianBlur</strong> .  Todas las primitivas tienen el mismo prefijo: fe, abreviatura de " <em>efecto de filtro</em> ".  Una vez más, los nombres en SVG son convenientes para elegir comprender qué es este elemento o qué hace. </p><br><p>  El siguiente fragmento de código muestra cómo se verá un filtro simple si aplica un desenfoque gaussiano de 5 píxeles a la imagen: </p><br><pre> <code class="plaintext hljs">&lt;svg width="600" height="450" viewBox="0 0 600 450"&gt; &lt;filter id="myFilter"&gt; &lt;feGaussianBlur stDeviation="5"&gt;&lt;/feGaussianBlur&gt; &lt;/filter&gt; &lt;image xlink:href="..." width="100%" height="100%" x="0" y="0" filter="url(#myFilter)"&gt;&lt;/image&gt; &lt;/svg&gt;</code> </pre> <br><p>  Actualmente, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la</a> especificación de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><strong>filtro SVG</strong></a> define 17 primitivas de filtro que son capaces de crear efectos gráficos extremadamente potentes, que incluyen, entre otros, generación de ruido y textura, efectos de iluminación, manipulación de color (canal a canal) y mucho más. </p><br><p>  La primitiva de filtro funciona al aceptar una fuente gráfica para la entrada y salida a otra.  Y la salida de un efecto de filtro se puede usar como entrada para otro.  Esto es muy importante y muy efectivo, porque con casi innumerables combinaciones de efectos de filtrado, puede crear casi innumerables efectos gráficos. </p><br><p>  Cada primitiva de filtro puede aceptar una o dos entradas y generar un solo resultado.  La entrada de la primitiva de filtro se define en el atributo in.  El resultado de la operación se define en el atributo de <strong>resultado</strong> .  Si el efecto de filtro requiere una segunda entrada, entonces se especifica en el atributo <strong>in2</strong> .  El resultado de la operación se puede usar como entrada para cualquier otra operación, pero si la entrada de la operación no se especifica en el atributo in, entonces el resultado de la operación anterior se usa automáticamente como entrada.  Si no especifica el <strong>resultado de la</strong> primitiva, su resultado se usará automáticamente como entrada para la próxima primitiva.  Esto se aclarará cuando comencemos a estudiar ejemplos de código. </p><br><p>  La primitiva de filtro puede usar otros tipos de datos como entrada, los más importantes son: </p><br><ul><li>  <strong>SourceGraphic</strong> : elemento al que se aplica todo el filtro;  por ejemplo, una imagen o una pieza de texto. </li><li>  <strong>SourceAlpha</strong> : Esto es lo mismo que <strong>SourceGraphic</strong> , excepto que este gráfico contiene solo el canal alfa del elemento.  Por ejemplo, para una imagen JPEG, este es un rectángulo negro del tamaño de la imagen en sí. </li></ul><br><p>  Encontrará que a veces desea utilizar la fuente de gráficos como entrada, y a veces solo su canal alfa.  Los ejemplos que cubriremos en este y en los artículos siguientes proporcionarán una comprensión clara de cuándo y qué usar. </p><br><p>  Este fragmento de código es un ejemplo de cómo se vería un filtro con un paquete de primitivas de filtro como elementos secundarios.  No te preocupes por los primitivos y lo que hacen.  En este punto, solo preste atención a cómo se definen y usan las entradas y salidas de ciertas primitivas.  Agregué algunos comentarios para ayudar. </p><br><pre> <code class="plaintext hljs">&lt;svg width="600" height="400" viewBox="0 0 850 650"&gt; &lt;filter id="filter"&gt; &lt;feOffset in="SourceAlpha" dx="20" dy="20"&gt;&lt;/feOffset&gt; &lt;!-- since the previous filter did not have a result defined and this following one does not have the input set, the result of the above primitive is automatically used as input to the following filter --&gt; &lt;feGaussianBlur stdDeviation="10" result="DROP"&gt;&lt;/feGaussianBlur&gt; &lt;!-- setting/defining the result names in all caps is a good way to make them more distinguishable and the overall code more readable --&gt; &lt;feFlood flood-color="#000" result="COLOR"&gt;&lt;/feFlood&gt; &lt;!-- This primitive is using the outputs of the previous two primitives as input, and outputting a new effect --&gt; &lt;feComposite in="DROP" in2="COLOR" operator="in" result="SHADOW1"&gt;&lt;/feComposite&gt; &lt;feComponentTransfer in="SHADOW1" result="SHADOW"&gt; &lt;feFuncA type="table" tableValues="0 0.5"&gt;&lt;/feFuncA&gt; &lt;/feComponentTransfer&gt; &lt;!-- You can use ANY two results as inputs to any primitive, regardless of their order in the DOM.--&gt; &lt;feMerge&gt; &lt;feMergeNode in="SHADOW"&gt;&lt;/feMergeNode&gt; &lt;feMergeNode in="SourceGraphic"&gt;&lt;/feMergeNode&gt; &lt;/feMerge&gt; &lt;/filter&gt; &lt;image xlink:href="..." x="0" y="0" width="100%" height="100%" filter="url(#filter)"&gt;&lt;/image&gt; &lt;/svg&gt;</code> </pre> <br><p>  Ahora, el último concepto que quiero explicar brevemente antes de pasar a nuestro primer ejemplo de filtro es el concepto de <strong>Región de filtro</strong> . </p><br><h2 id="oblast-filtracii">  Área de filtración </h2><br><p>  Un conjunto de operaciones de filtrado requiere un área para procesar, un área en la que se pueden aplicar.  Por ejemplo, puede tener un SVG complejo con muchos elementos, y desea aplicar el efecto de filtrado solo a un área específica o a uno o un grupo de elementos dentro del mismo SVG. </p><br><p>  En SVG, los elementos tienen "regiones" cuyos límites están definidos por los bordes del rectángulo que limita el elemento.  Un cuadro delimitador (también abreviado como "bbox") es el rectángulo más pequeño alrededor de un elemento.  Por ejemplo, en la siguiente figura, para un fragmento de texto, dicho rectángulo se resalta en rosa. </p><br><p><img src="https://habrastorage.org/webt/hu/uy/i1/huuyi1kr0i8ldvfpggxgwpdi6sm.png" alt="El rectángulo envolvente más pequeño alrededor de un fragmento de texto."><br>  <em>Fig_3.</em>  <em>El rectángulo envolvente más pequeño alrededor de un fragmento de texto.</em> </p><br><p>  Tenga en cuenta que este rectángulo puede contener algunos espacios verticales más, ya que la altura de la línea de texto se tiene en cuenta al calcular la altura del rectángulo delimitador. </p><br><p>  Por defecto, el área del filtro de elementos es el marco del elemento que lo bordea.  Por lo tanto, si aplica un efecto de filtro a nuestro fragmento de texto, el efecto se limitará a este rectángulo y cualquier resultado de filtrado que esté fuera de él se cortará.  Aunque esto es razonable, no es muy práctico, ya que muchos filtros afectarán a algunos píxeles fuera del cuadro delimitador, y de forma predeterminada, estos píxeles finalmente se cortarán. </p><br><p>  Por ejemplo, si aplica un efecto de desenfoque a nuestro fragmento de texto, puede ver que se recorta a lo largo de los bordes izquierdo y derecho del rectángulo que limita el texto: </p><br><p><img src="https://habrastorage.org/webt/ll/ih/e4/llihe4hbwx94zl3xk-w9zmcmmkq.png" alt="El efecto de desenfoque aplicado al texto se recorta en los lados derecho e izquierdo del rectángulo que delimita el texto."><br>  <em>Fig_4.</em>  <em>El efecto de desenfoque aplicado al texto se recorta en los lados derecho e izquierdo del rectángulo que delimita el texto.</em> </p><br><p>  Entonces, ¿cómo evitamos esto?  La respuesta es: expandiendo el área del filtro.  Podemos expandir el alcance al que se aplica el filtro cambiando los atributos <strong>x</strong> , <strong>y</strong> , <strong>ancho</strong> y <strong>alto</strong> del elemento &lt;filter&gt;. </p><br><p>  De acuerdo con la especificación, </p><br><blockquote>  A menudo es necesario proporcionar campos en el área del filtro, ya que el efecto del filtro puede afectar algunos bits fuera del cuadro delimitador para un objeto dado.  Para hacer esto, puede dar valores negativos en porcentaje a las propiedades <strong>X</strong> e <strong>Y</strong> , y valores superiores al 100% a las propiedades <strong>ancho</strong> y <strong>alto</strong> . </blockquote><p>  De forma predeterminada, los filtros tienen áreas que se extienden el 10% del ancho y la altura del cuadro delimitador en las cuatro direcciones.  En otras palabras, los valores predeterminados para los atributos <strong>x</strong> , <strong>y</strong> , <strong>ancho</strong> y <strong>alto</strong> son: </p><br><pre> <code class="plaintext hljs">&lt;filter x="-10%" y="-10%" width="120%" height="120%" filterUnits="objectBoundingBox"&gt; &lt;!-- filter operations here --&gt; &lt;/filter&gt;</code> </pre> <br><p>  Si no incluye estos atributos en el elemento <strong>&lt;filter&gt;</strong> , se utilizarán los valores predeterminados.  También puede anularlos para expandir o reducir el área según sea necesario. </p><br><p>  Tenga en cuenta que las unidades utilizadas en los atributos <strong>x</strong> , <strong>y</strong> , <strong>ancho</strong> y <strong>alto</strong> dependen del <strong>valor de</strong> atributo <strong>filterUnits que se</strong> utilice.  Define el sistema de coordenadas de los atributos <strong>x</strong> , <strong>y</strong> , <strong>ancho</strong> y <strong>alto</strong> y puede tomar uno de dos valores: </p><br><ul><li>  <strong>objectBoundingBox</strong> .  Este es el valor predeterminado.  Cuando <strong>filterUnits</strong> se establece en <strong>objectBoundingBox</strong> , los valores de atributo <strong>x</strong> , <strong>y</strong> , <strong>ancho</strong> y <strong>alto</strong> son porcentajes o fracciones del tamaño del cuadro delimitador del elemento.  También significa que puede usar valores fraccionarios en lugar de porcentajes si lo prefiere. </li><li>  <strong>userSpaceOnUse</strong> Cuando <strong>filterUnits</strong> se establece en <strong>userSpaceOnUse</strong> , las coordenadas de los atributos x, y, ancho y alto son relativas al sistema de coordenadas actual utilizado por el usuario.  En otras palabras, esto es relativo al sistema de coordenadas actual utilizado en SVG, que usa píxeles como unidades de medida y, como regla, relativo al tamaño del SVG en sí mismo, suponiendo que los valores de <strong>viewBox</strong> corresponden a los valores del sistema de coordenadas original. </li></ul><br><blockquote>  Todo lo que necesita saber sobre los sistemas de coordenadas en SVG se puede encontrar en este artículo, que escribí hace varios años. </blockquote><br><pre> <code class="plaintext hljs">&lt;!-- Using objectBoundingBox units --&gt; &lt;filter id="filter" x="5%" y="5%" width="100%" height="100%"&gt; &lt;!-- Using userSpaceOnUse units --&gt; &lt;filter id="filter" filterUnits="userSpaceOnUse" x="5px" y="5px" width="500px" height="350px"&gt;</code> </pre> <br><h3 id="bystryy-sovet-vizualizaciya-tekuschey-oblasti-filtra-s-pomoschyu-feflood">  Consejo rápido: visualizar el área de filtro actual con feFlood </h3><br><p>  Si alguna vez necesita ver los límites de un área de filtro, puede visualizarlo llenándolo con un poco de color.  Convenientemente, hay un filtro primitivo llamado <strong>feFlood</strong> , cuyo único propósito es precisamente este: llenar el área del filtro actual con el color especificado en el atributo de <strong>color de inundación</strong> . </p><br><p>  Entonces, si asumimos que tenemos un texto, cuyo área de filtro queremos ver, entonces el código puede verse así: </p><br><pre> <code class="plaintext hljs">&lt;svg width="600px" height="400px" viewBox="0 0 600 400"&gt; &lt;filter id="flooder" x="0" y="0" width="100%" height="100%"&gt; &lt;feFlood flood-color="#EB0066" flood-opacity=".9"&gt;&lt;/feFlood&gt; &lt;/filter&gt; &lt;text dx="100" dy="200" font-size="150" font-weight="bold" filter="url(#flooder)"&gt;Effect!&lt;/text&gt; &lt;/svg&gt;</code> </pre> <br><p>  Como puede ver en el fragmento de código anterior, la primitiva <strong>feFlood</strong> también acepta el atributo de <strong>opacidad de inundación</strong> , que se puede usar para crear transparencia para la capa de relleno de color. </p><br><p>  El fragmento anterior llena el área del filtro con rosa.  Pero aquí está la cosa: cuando llena el área con color, literalmente la llena con color, lo que significa que el color cubrirá todo en el área del filtro, incluidos los elementos y efectos que creó anteriormente, así como el texto en sí.  Después de todo, ese es el concepto de relleno, ¿verdad? </p><br><p><img src="https://habrastorage.org/webt/aj/pc/qc/ajpcqctctaikdiirvjexjeuh6yg.png" alt="Antes y después de llenar el área de texto del filtro con color"><br>  <em>Fig_5.</em>  <em>Antes y después de llenar el área de texto del filtro con color.</em> </p><br><p>  Para cambiar esto, debemos mover la capa de color a continuación y mostrar la capa de texto original en la parte superior. </p><br><p>  Si tiene varias capas de contexto que deben mostrarse una encima de otra en el filtro SVG, puede usar la primitiva de filtro <strong>&lt;feMerge&gt;</strong> .  Como su nombre lo indica, la primitiva <strong>feMerge se</strong> usa para combinar capas de elementos o efectos juntos. </p><br><p>  La primitiva <strong>no tiene un atributo in.</strong>  <strong>Para fusionar las capas dentro de <strong>&lt;feMerge&gt;</strong> , se <strong>usan</strong> dos o más <strong>&lt;feMergeNode&gt;</strong> , cada uno de los cuales tiene su propio atributo, que representa la capa que queremos agregar.</strong> <br></p><p>  La colocación de la capa (o "nodo") depende del orden de la fuente <strong>&lt;feMergeNode&gt;</strong> : el primer <strong>&lt;feMergeNode&gt; se</strong> muestra "detrás" o "debajo" del segundo.  El último <strong>&lt;feMergeNode&gt;</strong> representa la capa superior.  Y así sucesivamente. </p><br><p>  Entonces, en nuestro ejemplo con texto, el relleno de color es una capa, y la fuente de texto (fuente de gráficos) es una capa diferente, y queremos colocar el texto encima del relleno de color.  Nuestro código se verá así: </p><br><pre> <code class="plaintext hljs">&lt;svg width="600px" height="400px" viewBox="0 0 600 400"&gt; &lt;filter id="flooder"&gt; &lt;feFlood flood-color="#EB0066" flood-opacity=".9" result="FLOOD"&gt;&lt;/feFlood&gt; &lt;feMerge&gt; &lt;feMergeNode in="FLOOD" /&gt; &lt;feMergeNode in="SourceGraphic" /&gt; &lt;/feMerge&gt; &lt;/filter&gt; &lt;text dx="100" dy="200" font-size="150" font-weight="bold" filter="url(#flooder)"&gt;Effect!&lt;/text&gt; &lt;/svg&gt;</code> </pre> <br><p>  Observe cómo nombré el resultado de <strong>feFlood</strong> en el atributo de <strong>resultado</strong> , para poder usar este nombre en la capa <strong>&lt;feMergeNode&gt;</strong> como entrada.  Como queremos mostrar el texto de origen sobre el color de la secuencia, hacemos referencia a este texto usando <strong>SourceGraphic</strong> .  La siguiente demostración muestra el resultado: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://codepen.io/SaraSoueidan/embed/preview/dJddbK" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2 id="primenenie-teni-k-izobrazheniyu">  Aplicar una sombra a una imagen </h2><br><p>  Permítanme comenzar con una breve advertencia: es mejor que cree una sombra simple utilizando la función de filtrado CSS <strong>drop-shadow ()</strong> .  La ruta del filtro SVG es mucho más detallada.  Después de todo, como mencionamos anteriormente, las funciones de filtro CSS son atajos convenientes.  Pero todavía quiero considerar este ejemplo como un simple punto de entrada a efectos de filtro más complejos, que cubriremos en futuros artículos. </p><br><p>  Entonces, ¿cómo se crea la sombra? </p><br><p>  Una sombra suele ser una capa gris claro detrás o debajo de un elemento que tiene la misma forma (o forma) que el elemento mismo.  En otras palabras, puede considerar esto como una copia gris borrosa del elemento. </p><br><p>  Al crear filtros SVG, debe razonar por etapas.  ¿Qué pasos son necesarios para lograr este o aquel efecto?  Para una sombra, se puede crear una copia gris borrosa de un elemento al desenfocar una copia negra del elemento y luego colorear esta copia negra, es decir  hazla gris.  Luego, esta copia gris borrosa recién creada se coloca detrás del elemento original y se desplaza ligeramente en ambas direcciones. </p><br><p>  Entonces, <strong>comenzaremos obteniendo una copia en negro de nuestro elemento y difuminándolo</strong> .  Se puede crear una copia en negro utilizando el canal alfa del elemento, utilizando <strong>SourceAlpha</strong> como entrada de filtro. </p><br><p>  La primitiva <strong>feGaussianBlur</strong> se usará para aplicar el desenfoque gaussiano a esta capa de SourceAlpha.  La cantidad de desenfoque requerida se establece en el atributo <strong>stdDeviation</strong> (abreviatura de Desviación estándar).  Si establece un valor del atributo <strong>stdDeviation</strong> , este valor se usará para aplicar un desenfoque uniforme de los datos de entrada.  También puede especificar dos valores numéricos, luego el primero se usará para desenfocar el elemento en dirección horizontal y el segundo para desenfoque vertical.  Para la sombra, necesitamos aplicar un desenfoque uniforme, por lo que nuestro código comenzará con esto: </p><br><pre> <code class="plaintext hljs">&lt;svg width="600" height="400" viewBox="0 0 850 650"&gt; &lt;filter id="drop-shadow"&gt; &lt;-- Grab a blakc copy of the source image and blur it by 10 --&gt; &lt;feGaussianBlur in="SourceAlpha" stdDeviation="10" result="DROP"&gt;&lt;/feGaussianBlur&gt; &lt;/filter&gt; &lt;image xlink:href="..." x="0" y="0" width="100%" height="100%" filter="url(#drop-shadow)"&gt;&lt;/image&gt; &lt;/svg&gt;</code> </pre> <br><p>  El fragmento de código anterior conduce al siguiente efecto, donde solo se muestra actualmente el canal alfa borroso de la imagen: </p><br><p><img src="https://habrastorage.org/webt/zd/e9/ye/zde9ye5ycftyjmi_cru94ty3jde.png" alt="Imagen de copia negra creada con desenfoque (sombra)"><br>  <em>Fig_6.</em>  <em>Se creó una copia negra de la imagen con desenfoque (sombra).</em> </p><br><p>  Luego queremos <strong>cambiar el color de la sombra y hacerla gris</strong> .  Haremos esto aplicando un relleno de color al área del filtro y luego combinaremos esta capa de relleno de color con la capa de sombra que creamos. </p><br><p>  La alineación es la conexión de un elemento gráfico con un fondo borroso.  El fondo borroso es el contenido detrás del elemento con el que se alinea el elemento.  En nuestro filtro, el color de relleno es la capa superior, y la sombra borrosa es su fondo, porque se encuentra detrás de ella.  Consideraremos la primitiva <strong>feComposite con</strong> más detalle en los siguientes artículos, por lo que si no está familiarizado con la composición y cómo funciona, le recomiendo que lea un <strong>artículo detallado</strong> sobre este tema en mi blog. </p><br><p>  La primitiva <strong>feComposite</strong> tiene un atributo de <strong>operador</strong> , que se utiliza para indicar qué operación compuesta queremos usar. </p><br><p>  Usando el operador <strong>compuesto</strong> , la capa de relleno de color se "recortará", y solo se mostrará la región de color que coincida con nuestra capa de sombra.  Ambas capas se mezclarán donde se cruzan, es decir,  el color gris se usará para colorear nuestra sombra negra. </p><br><p>  <strong>feComposite</strong>      ,    <strong>in</strong>  <strong>in2</strong> .   —    ,   —   .    ,    <strong>operator</strong> ,      : </p><br><pre> <code class="plaintext hljs">&lt;svg width="600" height="400" viewBox="0 0 850 650"&gt; &lt;filter id="drop-shadow"&gt; &lt;feGaussianBlur in="SourceAlpha" stdDeviation="10" result="DROP"&gt;&lt;/feGaussianBlur&gt; &lt;feFlood flood-color="#bbb" result="COLOR"&gt;&lt;/feFlood&gt; &lt;feComposite in="COLOR" in2="DROP" operator="in" result="SHADOW"&gt;&lt;/feComposite&gt; &lt;/filter&gt; &lt;image xlink:href="..." x="0" y="0" width="100%" height="100%" filter="url(#drop-shadow)"&gt;&lt;/image&gt; &lt;/svg&gt;</code> </pre> <br><p>  ,   <strong>feGaussianBlur</strong>   <strong>feFlood</strong>       .     : </p><br><p><img src="https://habrastorage.org/webt/_c/c7/an/_cc7an_zj43v7gv4jka--6mpnpi.png" alt="Ahora la sombra es gris"><br> <em>_7.   .</em> </p><br><p>  ,        ,       / .          .     ,      ,       ,          . </p><br><p>     SVG   <strong>feOffset</strong> .    <strong>in</strong>  <strong>result</strong>      : <strong>dx</strong>  <strong>dy</strong> ,   ,         X  Y . </p><br><p>   ,       ,  <strong>feMerge</strong> ,  ,           —  <strong>mergeNode</strong>       ,    <strong>mergeNode</strong>    ,  <strong>SourceGraphic</strong>    .     : </p><br><pre> <code class="plaintext hljs">&lt;svg width="600" height="400" viewBox="0 0 850 650"&gt; &lt;filter id="drop-shadow"&gt; &lt;!-- Get the source alpha and blur it; we'll name the result "DROP" --&gt; &lt;feGaussianBlur in="SourceAlpha" stdDeviation="10" result="DROP"&gt;&lt;/feGaussianBlur&gt; &lt;!-- flood the region with a ligh grey color; we'll name this layer "COLOR" --&gt; &lt;feFlood flood-color="#bbb" result="COLOR"&gt;&lt;/feFlood&gt; &lt;!-- Composite the DROP and COLOR layers together to colorize the shadow. The result is named "SHADOW" --&gt; &lt;feComposite in="COLOR" in2="DROP" operator="in" result="SHADOW"&gt;&lt;/feComposite&gt; &lt;!-- Move the SHADOW layer 20 pixels down and to the right. The new layer is now called "DROPSHADOW" --&gt; &lt;feOffset in="SHADOW" dx="20" dy="20" result="DROPSHADOW"&gt;&lt;/feOffset&gt; &lt;!-- Layer the DROPSHADOW and the Source Image, ensuring the image is positioned on top (remember: MergeNode order matters) --&gt; &lt;feMerge&gt; &lt;feMergeNode in="DROPSHADOW"&gt;&lt;/feMergeNode&gt; &lt;feMergeNode in="SourceGraphic"&gt;&lt;/feMergeNode&gt; &lt;/feMerge&gt; &lt;/filter&gt; &lt;!-- Apply the filter to the source image in the `filter` attribute --&gt; &lt;image xlink:href="..." x="0" y="0" width="100%" height="100%" filter="url(#drop-shadow)"&gt;&lt;/image&gt; &lt;/svg&gt;</code> </pre> <br><p>      : </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://codepen.io/SaraSoueidan/embed/preview/qpoqwQ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>         SVG,   SVG.  ,        . </p><br><h2 id="est-drugoy-sposob">   … </h2><br><p>  ,     .  ,         ,    ,      ,    , , . </p><br><p>     ,     ,  <strong>feFlood</strong> ,  ,  , ,      .    ,    .    ,    ,     , ,  - ,  , ,    . </p><br><p>         <strong>feColorMatrix</strong> ,  <strong>feComponentTransfer</strong> .   <strong>feComponentTransfer</strong>       ,    <strong>feColorMatrix</strong> ,     . </p><br><p>  <strong>feColorMatrix</strong>   .         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Una Kravet</a> ,        . </p><br><p>  ,        R(), G(), B()  A()              -.  ,       .     : </p><br><pre> <code class="plaintext hljs">&lt;filter id="myFilter"&gt; &lt;feColorMatrix type="matrix" values="R 0 0 0 0 0 G 0 0 0 0 0 B 0 0 0 0 0 A 0 "/&gt; &lt;/feColorMatrix&gt; &lt;/filter&gt;</code> </pre> <br><p>      ,      . </p><br><p>        ,     ,     RGB,     -   : </p><br><pre> <code class="plaintext hljs">&lt;filter id="filter"&gt; &lt;!-- Get the source alpha and blur it, --&gt; &lt;feGaussianBlur in="SourceAlpha" stdDeviation="10" result="DROP"&gt;&lt;/feGaussianBlur&gt; &lt;!-- offset the drop shadow --&gt; &lt;feOffset in="SHADOW" dx="20" dy="20" result="DROPSHADOW"&gt;&lt;/feOffset&gt; &lt;!-- make the shadow translucent by reducing the alpha channel value to 0.3 --&gt; &lt;feColorMatrix type="matrix" in="DROPSHADOW" result="FINALSHADOW" values="1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0.3 0"&gt; &lt;/feColorMatrix&gt; &lt;!-- Merge the shadow and the source image --&gt; &lt;feMerge&gt; &lt;feMergeNode in="FINALHADOW"&gt;&lt;/feMergeNode&gt; &lt;feMergeNode in="SourceGraphic"&gt;&lt;/feMergeNode&gt; &lt;/feMerge&gt; &lt;/filter&gt;</code> </pre> <br><p>     : </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://codepen.io/SaraSoueidan/embed/preview/opEZee" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2 id="zaklyuchenie">  Conclusión </h2><br><p>                   .         ,    .         ,         .  ,       ,   ,   ,   ,    .       ,       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a> .   ,     ,  ,         .             . </p><br><p> ,     SVG-      ,            .  Quédate con nosotros </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/439282/">https://habr.com/ru/post/439282/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../439268/index.html">Cómo funcionan juntos la impresión VR, AR y 3D: experiencia de concepto VR</a></li>
<li><a href="../439270/index.html">Un ejemplo de análisis de código C ++ usando libclang en Python</a></li>
<li><a href="../439272/index.html">Cuaderno Jupyter en Netflix</a></li>
<li><a href="../439278/index.html">ACS de mi LCD: seguridad con dos tornillos</a></li>
<li><a href="../439280/index.html">Trautonio: la ola alemana en la historia de los sintetizadores</a></li>
<li><a href="../439286/index.html">Sobre el análisis estático con toda honestidad</a></li>
<li><a href="../439288/index.html">SciPy, optimización</a></li>
<li><a href="../439290/index.html">Acelere la compilación en Xcode en Swift</a></li>
<li><a href="../439294/index.html">Revisión de la traducción "Si el software se crea con dinero público, el código debe estar abierto"</a></li>
<li><a href="../439296/index.html">Matrícula soviética y complejidad de Kolmogorov</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>