<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏻 🔸 👩🏽‍💼 所有程序员都需要了解的现代C ++功能 👨🏽‍🎨 😷 📙</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="该材料的作者（我们今天将其翻译发表）说，与几年前相比，现代形式的C ++有了很大的改善。 当然，这些变化不是立即发生的。 例如，在过去，C ++缺乏活力。 要找到一个可以说他对这种语言有温柔感情的人并不容易。 当负责标准化语言的人决定让位给创新时，一切都改变了。 在2011年，C ++成为一种动态语...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>所有程序员都需要了解的现代C ++功能</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/451870/"> 该材料的作者（我们今天将其翻译发表）说，与几年前相比，现代形式的C ++有了很大的改善。 当然，这些变化不是立即发生的。 例如，在过去，C ++缺乏活力。 要找到一个可以说他对这种语言有温柔感情的人并不容易。 当负责标准化语言的人决定让位给创新时，一切都改变了。 在2011年，C ++成为一种动态语言，这种语言不断发展并引起程序员更多积极的情绪。 <br><br> 不要以为语言变得简单了。 如果不是最复杂的话，它仍然可以被称为最复杂的广泛使用的编程语言之一。 但是现代的C ++比以前更加友好了。 <br><br><img src="https://habrastorage.org/webt/qk/ii/cx/qkiicxclyr6agfsxlcplndrkpd8.jpeg"><br><br> 今天，我们将讨论该语言的一些新功能（从C ++ 11开始，顺便说一句，它已经存在8年了），这对任何程序员来说都是有用的。 <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">自动关键字</font> </h2><br> 自从<code>auto</code>关键字出现在C ++ 11中以来，程序员的生活变得更加轻松。 由于有了这个关键字，编译器可以在编译时输出变量类型，这使我们不必总是自己指定类型。 事实证明，这非常方便，例如，在必须使用<code>map&lt;string,vector&lt;pair&lt;int,int&gt;&gt;&gt;</code>类的数据类型的情况下。 使用<code>auto</code>关键字时，需要考虑一些事项。 考虑一个例子： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> an_int = <span class="hljs-number"><span class="hljs-number">26</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    ,     - int auto a_bool = false; //   bool auto a_float = 26.04; //   float auto ptr = &amp;a_float; //       auto data; // #1     ?    - .</span></span></code> </pre> <br> 请注意本示例中的最后一行，其注释标记为<code>#1</code> （以下，以类似的方式，我们将标记示例之后将解析的行）。 此行中没有初始化程序，您不能执行此操作。 此行上的代码使编译器无法知道相应变量的类型。 <br><br> 最初，C ++中的<code>auto</code>关键字非常有限。 然后，在该语言的最新版本中，会<code>auto</code>添加功能。 这是另一个示例： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">merge</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">auto</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">auto</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b)</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">//            auto! {   std::vector&lt;int&gt; c = do_something(a, b);   return c; } std::vector&lt;int&gt; a = { ... }; // #1 -  std::vector&lt;int&gt; b = { ... }; // #2  -  auto c = merge(a,b); //      </span></span></span></span></code> </pre> <br> 第<code>#1</code>行和<code>#2</code>行使用大括号应用变量初始化-C ++ 11中的另一个新功能。 <br><br> 请记住，使用<code>auto</code>关键字时，编译器必须具有某种方式来推断变量的类型。 <br><br> 现在，一个有趣的问题。 如果您使用像<code>auto a = {1, 2, 3}</code>这样的设计会怎样？ 这是什么 向量，还是导致编译错误？ <br><br> 实际上，C ++ 11中出现了<code>std::initializer_list&lt;type&gt;</code>形式的构造。 带括号的初始化值列表将使用<code>auto</code>关键字视为容器。 <br><br> 最后，如前所述，如果您必须处理复杂的数据结构，则编译器的类型推断可能非常有用。 这是一个例子： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">populate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">auto</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;data)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    !   data.insert({"a",{1,4}});   data.insert({"b",{3,1}});   data.insert({"c",{2,3}}); } auto merge(auto data, auto upcoming_data) { //         auto result = data;   for(auto it: upcoming_data) {       result.insert(it);   }   return result; } int main() {   std::map&lt;std::string, std::pair&lt;int,int&gt;&gt; data;   populate(data);   std::map&lt;std::string, std::pair&lt;int,int&gt;&gt; upcoming_data;   upcoming_data.insert({"d",{5,3}});   auto final_data = merge(data,upcoming_data);   for(auto itr: final_data) {       auto [v1, v2] = itr.second; // #1               std::cout &lt;&lt; itr.first &lt;&lt; " " &lt;&lt; v1 &lt;&lt; " " &lt;&lt; v2 &lt;&lt; std:endl;   }   return 0; }</span></span></code> </pre> <br> 看一下<code>#1</code>线。 表达式<code>auto [v1,v2] = itr.second</code>表示C ++ 17的新功能。这是声明变量时的所谓分解。 在该语言的早期版本中，必须分别提取每个值。 由于这种机制，执行此类操作变得更加方便。 <br><br> 此外，如果您需要使用链接来处理数据，只需在此构造中添加一个字符，然后将其转换为以下形式就足够了： <code>auto &amp;[v1,v2] = itr.second</code> 。 <br><br><h2>  <font color="#3AC1EF">Lambda表达式</font> </h2><br>  C ++ 11引入了对lambda表达式的支持。 它们类似于JavaScript中的匿名函数，可以与没有名称的函数对象进行比较。 它们根据描述捕获各种范围的变量，为此使用了紧凑的句法结构。 此外，可以将它们分配给变量。 <br><br> 对于需要在代码中执行一些小操作但又不想为此编写单独函数的情况，Lambda表达式是非常有用的工具。 使用它们的另一个常见示例是创建用于比较值的函数。 例如： <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt; data = {{<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>}, {<span class="hljs-number"><span class="hljs-number">7</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>}, {<span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>}}; <span class="hljs-comment"><span class="hljs-comment">//        std::sort(begin(data), end(data), [](auto a, auto b) { //   - auto!   return a.second &lt; b.second; });</span></span></code> </pre> <br> 在这个简短的示例中，您会发现很多有趣的东西。 <br><br> 首先，请注意使用大括号使用变量初始化有多方便。 接下来，我们可以看到标准构造<code>begin()</code>和<code>end()</code> ，它们也出现在C ++ 11中。然后是lambda函数，该函数用作比较数​​据的机制。 该函数的参数使用<code>auto</code>关键字声明，此功能出现在C ++ 14中。以前，该关键字不能用于描述函数的参数。 <br><br> 现在注意，lambda表达式以方括号- <code>[]</code>开头。 这就是所谓的变量掩码。 它确定表达式的范围，即，它允许您控制lambda表达式与局部变量和对象的关系。 <br><br> 这是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">该</a>库中专门介绍现代C ++功能的摘录： <br><br><ul><li>  <code>[]</code> -表达式不捕获任何内容。 这意味着在lambda表达式中，不可能使用它外部作用域中的局部变量。 表达式中只能使用参数。 </li><li>  <code>[=]</code> -表达式捕获局部对象的值（即局部变量，参数）。 这意味着它们可以使用，但不能修改。 </li><li>  <code>[&amp;]</code> -表达式捕获对本地对象的引用。 可以修改它们，如以下示例所示。 </li><li>  <code>[this]</code> -表达式捕获<code>this</code>指针的值。 </li><li>  <code>[a, &amp;b]</code> -表达式捕获对象<code>a</code>的值和对对象<code>b</code>的引用。 </li></ul><br> 结果，如果需要在lambda函数内部将数据转换为其他格式，则可以使用上述机制。 考虑一个例子： <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; data = {<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> factor = <span class="hljs-number"><span class="hljs-number">7</span></span>; for_each(begin(data), end(data), [&amp;factor](<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> &amp;val) { <span class="hljs-comment"><span class="hljs-comment">//    factor     val = val * factor;   factor--; // #1   - ,  -    factor   }); for(int val: data) {   std::cout &lt;&lt; val &lt;&lt; ' '; // 14 24 20 4 3 6 9 }</span></span></code> </pre> <br> 在这里，如果通过值访问了<code>factor</code>变量（然后使用变量mask <code>[factor]</code>来描述lambda表达式），则在<code>#1</code>行中， <code>factor</code>值无法更改-仅仅是因为我们无权访问执行这样的操作。 在此示例中，我们有权采取此类行动。 在这种情况下，重要的是不要滥用访问变量通过引用提供的功能。 <br><br> 另外，请注意， <code>val</code>也可以通过引用来访问。 这样可以确保lambda函数中发生的数据更改会影响<code>vector</code> 。 <br><br><h2>  <font color="#3AC1EF">if和switch构造内部的变量初始化表达式</font> </h2><br> 在发现它之后，我真的很喜欢C ++ 17创新。 考虑一个例子： <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; input = {<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> it = input.find(<span class="hljs-number"><span class="hljs-number">7</span></span>); it==input.end()){ <span class="hljs-comment"><span class="hljs-comment">//   - ,  -    std::cout &lt;&lt; 7 &lt;&lt; " not found" &lt;&lt; std:endl; } else {   //    else      it   std::cout &lt;&lt; 7 &lt;&lt; " is there!" &lt;&lt; std::endl; }</span></span></code> </pre> <br> 事实证明，现在可以在一个<code>if</code>或<code>switch</code>块中初始化变量并与它们的使用进行比较。 这有助于编写准确的代码。 这是所考虑结构的示意图： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( init-statement(x); condition(x)) {   <span class="hljs-comment"><span class="hljs-comment">//    } else {   //     x   //    }</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">使用constexpr执行编译时计算</font> </h2><br>  <code>constexpr</code>为我们提供了巨大的机会。 假设我们需要某种表达式，但是用相应的变量将其值初始化后，其值不会改变。 可以预先计算这样的表达式并将其用作宏。 或者，在C ++ 11中可能使用<code>constexpr</code> 。 <br><br> 程序员努力使程序执行期间执行的计算量最小化。 结果，如果可以在编译过程中执行某些操作，从而在程序执行过程中减轻了系统负担，那么这将对程序在执行过程中的行为产生良好的影响。 这是一个例子： <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; constexpr long long fact(long long n) { //       constexpr return n == 1 ? 1 : (fact(n-1) * n); } int main() { const long long bigval = fact(20); std::cout&lt;&lt;bigval&lt;&lt;std::endl; }</span></span></span></span></code> </pre> <br> 这是使用<code>constexpr</code>的非常常见的示例。 <br><br> 由于我们将计算阶乘的函数声明为<code>constexpr</code> ，因此编译器可以在程序编译时预先计算<code>fact(20)</code>值。 结果，编译后，字符串<code>const long long bigval = fact(20);</code> 可以用<code>const long long bigval = 2432902008176640000;</code>  。 <br><br> 请注意，传递给函数的参数由常量表示。 这是使用通过<code>constexpr</code>声明的函数的重要功能。 传递给它们的参数还必须使用<code>constexpr</code>或<code>const</code>关键字声明。 否则，此类函数的行为将与普通函数类似，也就是说，在编译期间，它们的值将不会预先计算。 <br><br> 也可以使用<code>constexpr</code>声明变量。 如您所料，在这种情况下，必须在编译时计算这些变量的值。 如果无法完成，将显示编译错误消息。 <br><br> 有趣的是，后来在C ++ 17中，出现了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">constexpr-if</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">constexpr-lambda</a>构造。 <br><br><h2>  <font color="#3AC1EF">元组数据结构</font> </h2><br> 像<code>pair</code>数据结构一样， <code>tuple</code>数据结构（元组）是固定大小的不同类型的值的集合。 这是一个例子： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> user_info = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_tuple(<span class="hljs-string"><span class="hljs-string">"M"</span></span>, <span class="hljs-string"><span class="hljs-string">"Chowdhury"</span></span>, <span class="hljs-number"><span class="hljs-number">25</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  auto     //    std::get&lt;0&gt;(user_info); std::get&lt;1&gt;(user_info); std::get&lt;2&gt;(user_info); //  C++ 11     tie std::string first_name, last_name, age; std::tie(first_name, last_name, age) = user_info; //  C++ 17, ,       auto [first_name, last_name, age] = user_info;</span></span></code> </pre> <br> 有时候，代替<code>tuple</code>数据结构，使用<code>std::array</code>更方便。 此数据结构类似于C语言中使用的简单数组，并具有C ++标准库中的其他功能。 该数据结构出现在C ++ 11中。 <br><br><h2>  <font color="#3AC1EF">自动推断类模板参数的类型</font> </h2><br> 此功能的名称看起来很长很复杂，但实际上，这里没有什么复杂的。 这里的主要思想是，在C ++ 17中，还对标准类模板执行模板参数类型的输出。 以前，仅功能模板支持此功能。 结果，事实证明他们曾经这样写： <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; user = {<span class="hljs-string"><span class="hljs-string">"M"</span></span>, <span class="hljs-number"><span class="hljs-number">25</span></span>};</code> </pre> <br> 随着C ++ 17的发布，现在可以用以下结构代替该结构： <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair user = {<span class="hljs-string"><span class="hljs-string">"M"</span></span>, <span class="hljs-number"><span class="hljs-number">25</span></span>};</code> </pre> <br> 类型推断是隐式完成的。 对于元组，此机制更加方便使用。 即，在我不得不编写以下代码之前： <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; user (<span class="hljs-string"><span class="hljs-string">"M"</span></span>, <span class="hljs-string"><span class="hljs-string">"Chy"</span></span>, <span class="hljs-number"><span class="hljs-number">25</span></span>);</code> </pre> <br> 现在，同一件事看起来像这样： <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-function">tuple </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">user2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"M"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"Chy"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">25</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>;</code> </pre> <br> 值得注意的是，对于那些不太熟悉C ++模板的人来说，这些功能似乎不值得关注。 <br><br><h2>  <font color="#3AC1EF">智能指针</font> </h2><br> 在C ++中使用指针可能是一场噩梦。 由于语言给程序员带来了自由，所以正如他们所说的那样，有时候对他来说很难做到“不让自己陷入困境”。 在许多情况下，指针正在推动程序员的这种“努力”。 <br><br> 幸运的是，C ++ 11引入了智能指针，它比常规指针方便得多。 它们通过尽可能释放资源来帮助程序员避免内存泄漏。 另外，它们为异常提供了安全保证。 <br><br><h2>  <font color="#3AC1EF">总结</font> </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这是一个</a>很好的存储库，我们相信，那些遵循C ++创新的人会很感兴趣。 这种语言不断出现新的事物。 在这里，我们仅涉及该语言的一些现代功能。 实际上，有很多。 我们可能仍在谈论它们。 <br><br>  <b>亲爱的读者们！</b> 您发现哪些现代C ++功能最有趣和有用？ <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN451870/">https://habr.com/ru/post/zh-CN451870/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN451858/index.html">在Spring中制作一个基于缓存的简单断路器</a></li>
<li><a href="../zh-CN451860/index.html">数学家发现乘数的完美方法</a></li>
<li><a href="../zh-CN451862/index.html">乔·迪普里姆（Joe Diprim）的《音乐闪电》：自学成才的工程师制作特斯拉线圈进行娱乐和赚钱</a></li>
<li><a href="../zh-CN451864/index.html">在Windows OS中检测到EternalBlue级别的严重RCE漏洞</a></li>
<li><a href="../zh-CN451866/index.html">选择网络中最近的节点</a></li>
<li><a href="../zh-CN451872/index.html">Python是寻找喜欢旅行的人的廉价航班的助手</a></li>
<li><a href="../zh-CN451874/index.html">Google的热门SEO趋势</a></li>
<li><a href="../zh-CN451876/index.html">法兰克福数据中心：Telehouse数据中心</a></li>
<li><a href="../zh-CN451878/index.html">将立体声视频实时流传输到VR眼镜（Oculus Go）</a></li>
<li><a href="../zh-CN451880/index.html">DevPRO'19：从Wrike展位观看</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>