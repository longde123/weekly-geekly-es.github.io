<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üï§ üë≤ üåÅ "Cuando el reloj marca las doce". O una guirnalda en el navegador üßôüèº üèØ üé¥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Supongamos que tenemos varios monitores. Y quer√≠amos usar estos monitores como guirnalda. Por ejemplo, haz que parpadeen al mismo tiempo. O tal vez ca...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>"Cuando el reloj marca las doce". O una guirnalda en el navegador</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/482168/">  Supongamos que tenemos varios monitores.  Y quer√≠amos usar estos monitores como guirnalda.  Por ejemplo, haz que parpadeen al mismo tiempo.  O tal vez cambie sincr√≥nicamente el color de acuerdo con alg√∫n tipo de algoritmo inteligente.  Y qu√© pasa si lo haces en un navegador, entonces puedes conectar tel√©fonos inteligentes y tabletas a esto.  Todo eso est√° a la mano. <br><br><img src="https://habrastorage.org/webt/yo/1c/a8/yo1ca85ahnnxg_5crc1hh84n9ng.jpeg"><br><br>  Y, como estamos usando un navegador, tambi√©n puede agregar dise√±o de sonido.  Despu√©s de todo, si es lo suficientemente preciso como para sincronizar los dispositivos a tiempo, puede reproducir sonidos en cada uno como si un sistema multicanal sonara. <br><br><hr>  <i>Lo que se puede encontrar al sincronizar Web Audio y relojes de juego dentro de una aplicaci√≥n javascript;</i>  <i>cu√°ntas "horas" diferentes hay en javasctipt (¬°tres!) y por qu√© se necesitan todas, as√≠ como una <a href="http://habr.snowtime.fun/" rel="nofollow">aplicaci√≥n</a> preparada para node.js debajo del gato.</i> <a name="habracut"></a><hr><br><h2>  Mira el reloj </h2><br>  Para cualquier guirnalda en l√≠nea condicional, se requiere una sincronizaci√≥n precisa del reloj.  Despu√©s de todo, puede ignorar cualquier retraso de red (incluso intermitente).  Es suficiente proporcionar a los comandos de control una marca de tiempo y generar estos comandos un poco "hacia el futuro".  En los clientes, se almacenar√°n en el b√∫fer y luego se ejecutar√°n sincr√≥nicamente y a tiempo. <br><br>  O incluso puede ir m√°s all√°: tome el viejo algoritmo aleatorio determinista y use una semilla com√∫n (emitida por el servidor una vez, cuando est√© conectada) en todos los dispositivos.  Si usa dicha semilla <i>junto</i> con el tiempo exacto, puede determinar completamente el comportamiento del algoritmo en todos los dispositivos.  Imag√≠nese: de hecho, no necesita una red o un servidor para cambiar el estado de forma √∫nica y sincr√≥nica.  La semilla ya contiene la totalidad (condicionalmente infinita) "grabaci√≥n de video" de acciones por adelantado.  Lo principal es la hora exacta. <br><br><img src="https://habrastorage.org/webt/kd/tx/tt/kdtxttvwqoqkb69jvoov077o8vs.gif"><br><hr>  <i>Cada m√©todo tiene sus l√≠mites de aplicabilidad.</i>  <i>Con la entrada instant√°nea del usuario, por supuesto, no hay nada que hacer, queda transmitirlo "tal cual".</i>  <i>Pero todo lo que se puede calcular es calcular.</i>  <i>En mi implementaci√≥n, utilizo los tres enfoques, dependiendo de la situaci√≥n.</i> <hr><br><h2>  Subjetivo "al mismo tiempo" </h2><br>  Idealmente, todo deber√≠a sonar "al mismo tiempo": no se necesita m√°s de ¬± 10 ms de discrepancia para el peor par entre los dispositivos combinados.  No puede contar con esa precisi√≥n desde la hora del sistema, y ‚Äã‚Äãlos m√©todos est√°ndar para sincronizar la hora utilizando el protocolo NTP no est√°n disponibles en el navegador.  Por lo tanto, manejaremos nuestro servidor de sincronizaci√≥n.  El principio es simple: el casco "pings" y aceptar "pongs" con la marca de tiempo del servidor.  Si hace esto muchas veces seguidas, puede nivelar estad√≠sticamente el error y obtener el tiempo de retraso promedio. <br><br><div class="spoiler">  <b class="spoiler_title">C√≥digo: calcular la hora del servidor en el cliente</b> <div class="spoiler_text"><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> pingClientTime = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">// performace.now() time when ping started let pongClientTime = 3; // performace.now() time when pong received let pongServerTime = 20; // server timstamp in pong answer let clientServerRawOffset = pongServerTime - pongClientTime; let pingPongOffset = pongClientTime - pingClientTime; // roundtrip let estimatedPingOffset = pingPongOffset / 2; // one-way let offset = clientServerRawOffset + estimatedPingOffset; console.log(estimatedPingOffset) // 1 console.log(offset); // 18 let sharedServerTime = performace.now() + offset;</span></span></code> </pre> <br></div></div><br><br>  Los sockets web y las soluciones basadas en √©l son los m√°s adecuados porque no requieren tiempo para crear una conexi√≥n TCP y puede "comunicarse" con ellos en ambas direcciones.  No UDP o ICMP, por supuesto, pero incomparablemente m√°s r√°pido que una conexi√≥n en fr√≠o normal que utiliza la API HTTP.  Por lo tanto, socket.io.  Todo es muy f√°cil all√≠: <br><br><div class="spoiler">  <b class="spoiler_title">C√≥digo: implementaci√≥n socket.io</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// server socket.on('ping', (pongCallback) =&gt; { let pongServerTime = performace.now(); pongCallback(pongServerTime); }); //client const binSize = 100; let clientServerCalculatedOffset; function ping() { socket.emit('ping', pongCallback); const pingClientTime = performace.now(); function pongCallback(pongServerTime) { const pongClientTime = performace.now(); const clientServerRawOffset = pongServerTime - pongClientTime; const pingPongOffset = pongClientTime - pingClientTime; // roundtrip const estimatedPingOffset = pingPongOffset / 2; // one-way const offset = clientServerRawOffset + estimatedPingOffset; offsets.unshift(offset); offsets.splice(binSize); let offsetSum = 0; offsets.forEach((offset) =&gt; { offsetSum += offset; }); clientServerCalculatedOffset = offsetSum / offset.length(); } }</span></span></code> </pre> <br>  <i>Ser√≠a bueno, en lugar de calcular el promedio, calcular la mediana; esto mejorar√° la precisi√≥n con una conexi√≥n inestable.</i>  <i>La elecci√≥n de los m√©todos de filtrado depende del lector.</i>  <i>Deliberadamente simplifico el c√≥digo aqu√≠ a favor de los esquemas.</i>  <i>Mi soluci√≥n completa se puede encontrar en el repositorio.</i> <br></div></div><br><br><h2>  performance.now () </h2><br>  Perm√≠tame recordarle que el objeto de <code>performance</code> es una API que proporciona acceso a un temporizador de alta resoluci√≥n.  Compara: <br><br><ul><li>  <b><code>Date.now()</code></b> devuelve el n√∫mero de milisegundos desde el 1 de enero de 1970, y lo hace en forma <b>entera</b> .  Es decir, el error solo del redondeo es 0.5 ms en promedio.  Por ejemplo, en una operaci√≥n de resta <code>ab</code> puede "perder" sin √©xito hasta 2 ms.  Adem√°s, hist√≥rica y conceptualmente, el medidor de tiempo en s√≠ mismo no garantiza una alta precisi√≥n y est√° afilado para trabajar con una escala de tiempo m√°s grande. </li><li>  <b><code>performance.now()</code></b> devuelve el n√∫mero de milisegundos <a href="https://developer.mozilla.org/en-US/docs/Web/API/DOMHighResTimeStamp" rel="nofollow">desde que se abri√≥ la p√°gina web</a> . <br>  Esta es una API relativamente reciente, "afilada" espec√≠ficamente para la medici√≥n precisa de intervalos de tiempo.  Devuelve <b>un valor de punto flotante</b> , te√≥ricamente dando un nivel de precisi√≥n cercano a las capacidades del sistema operativo en s√≠. <br></li></ul><br><br>  Creo que esta informaci√≥n es conocida por casi todos los desarrolladores de JavaScript.  Pero no todos saben eso ... <br><br><h2>  Espectro </h2><br>  Debido al sensacional ataque de sincronizaci√≥n de Specter en 2018, todo llega al punto de que el temporizador de alta resoluci√≥n se endurecer√° artificialmente si no hay otra soluci√≥n al problema de vulnerabilidad.  Firefox, comenzando con la versi√≥n 60, redondea el valor de este temporizador a un milisegundo, y Edge, a√∫n peor. <br><br>  Esto es lo que dice <a href="https://developer.mozilla.org/en-US/docs/Web/API/Performance/now" rel="nofollow">MDN</a> : <br><br><blockquote>  La marca de tiempo no es en realidad de alta resoluci√≥n.  Para mitigar las amenazas de seguridad como Spectre, los navegadores actualmente redondean los resultados en diversos grados.  (Firefox comenz√≥ a redondearse a 1 milisegundo en Firefox 60). Algunos navegadores tambi√©n pueden aleatorizar ligeramente la marca de tiempo.  La precisi√≥n puede mejorar nuevamente en futuras versiones;  Los desarrolladores de navegadores a√∫n est√°n investigando estos ataques de tiempo y la mejor manera de mitigarlos. </blockquote><br>  Ejecutemos la prueba y echemos un vistazo a los gr√°ficos.  Este es el resultado de la prueba en un intervalo de 10 ms: <br><br><div class="spoiler">  <b class="spoiler_title">C√≥digo de prueba: medici√≥n del tiempo en un ciclo</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">measureTimesLoop</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">length</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> d = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(length); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> p = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(length); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; length; i++) { d[i] = <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now(); p[i] = performance.now(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { d, p } }</code> </pre> <br></div></div><br><img src="https://habrastorage.org/webt/lt/rr/xo/ltrrxo5m-cfdsf7kpwy_vm0d4nu.png" align="left"> <code>Date.now()</code> <br> <img src="https://habrastorage.org/webt/hp/h-/w3/hph-w3yafyxorpopqiksdnd6j5g.png" align="left"> <code>performance.now()</code> <br> <br><h3>  Borde </h3><br><img src="https://habrastorage.org/webt/g2/t2/bs/g2t2bssr-dhq8cbyb95-pwjxclw.png"><br><div class="spoiler">  <b class="spoiler_title">estad√≠sticas</b> <div class="spoiler_text">  Versi√≥n del navegador: 44.17763.771.0 <br><br><h3>  Date.now () </h3>  intervalo promedio: 1.0538336052202284 ms <br>  desviaci√≥n del intervalo promedio, RMS: 0.7547819181245603 ms <br>  mediana del intervalo: 1 ms <br><br><h3>  performance.now () </h3>  intervalo promedio: 1.567100970873786 ms <br>  desviaci√≥n del intervalo promedio, RMS: 0.6748006785171455 ms <br>  mediana del intervalo: 1.5015000000003056 ms <br></div></div><br><br><h3>  Firefox </h3><br><img src="https://habrastorage.org/webt/7y/6b/a_/7y6ba_0b_lgehjq2yko_60ip4am.png"><br><div class="spoiler">  <b class="spoiler_title">estad√≠sticas</b> <div class="spoiler_text">  Versi√≥n del navegador: 71.0 <br><br><h3>  Date.now () </h3>  intervalo promedio: 1.0168350168350169 ms <br>  desviaci√≥n del intervalo promedio, RMS: 0.21645930182417966 ms <br>  mediana del intervalo: 1 ms <br><br><h3>  performance.now () </h3>  intervalo promedio: 1.0134453781512605 ms <br>  desviaci√≥n del intervalo promedio, RMS: 0.1734108492762375 ms <br>  mediana del intervalo: 1 ms <br></div></div><br><br><h3>  Cromo </h3><br><img src="https://habrastorage.org/webt/zv/_y/pp/zv_yppcegrbidigvmp6npdcwzf0.png"><br><div class="spoiler">  <b class="spoiler_title">estad√≠sticas</b> <div class="spoiler_text">  Versi√≥n del navegador: 79.0.3945.88 <br><br><h3>  Date.now () </h3>  intervalo promedio: 1.02442996742671 ms <br>  desviaci√≥n del intervalo promedio, RMS: 0.49858684744444 ms <br>  mediana del intervalo: 1 ms <br><br><h3>  performance.now () </h3>  intervalo promedio: 0.005555847229948915 ms <br>  desviaci√≥n del intervalo promedio, RMS: 0.027497846727194235 ms <br>  mediana del intervalo: 0.0050000089686363935 ms <br></div></div><br><br>  Ok, Chrome, haz zoom a 1 ms. <br><br><img src="https://habrastorage.org/webt/2o/9m/ik/2o9mikwf_owbi8mn1saodrmd_e8.png"><br><br>  Por lo tanto, Chrome todav√≠a est√° aguantando, y su implementaci√≥n de <code>performance.now()</code> a√∫n no se ha estrangulado y el paso es hermoso 0.005 ms.  ¬°Bajo Edge, el temporizador <code>performance.now()</code> es m√°s duro que <code>Date.now()</code> !  En Firefox, ambos temporizadores tienen la misma precisi√≥n de milisegundos. <br><br>  En esta etapa, ya se pueden sacar algunas conclusiones.  Pero hay otro temporizador en javascript (sin el cual no podemos prescindir). <br><br><h2>  WebAudio API Timer </h2><br>  Esta es una bestia ligeramente diferente.  Se utiliza para colas de audio retrasadas.  El hecho es que los eventos de audio (reproducci√≥n de notas, gesti√≥n de efectos) no pueden depender de herramientas de JavaScript as√≠ncronas est√°ndar: <code>setInterval</code> y <code>setTimeout</code> , debido a su error demasiado grande.  Y esto no es solo el error <i>de los valores del</i> temporizador (con los que tratamos anteriormente), sino que es el error con el que la m√°quina de eventos ejecuta eventos.  Y ya es algo alrededor de 5-25 ms, incluso en condiciones de invernadero. <br><br><div class="spoiler">  <b class="spoiler_title">Gr√°ficos para el caso as√≠ncrono debajo del spoiler</b> <div class="spoiler_text">  El resultado de la prueba en un intervalo de 100 ms: <br><br><div class="spoiler">  <b class="spoiler_title">C√≥digo de prueba: medici√≥n del tiempo en un ciclo asincr√≥nico</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pause</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">duration</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function">) =&gt;</span></span> { setInterval(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { resolve(); }, duration); }); } <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">measureTimesInAsyncLoop</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">length</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> d = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(length); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> p = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(length); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; length; i++) { d[i] = <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now(); p[i] = performance.now(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> pause(<span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { d, p } }</code> </pre> <br></div></div><br><img src="https://habrastorage.org/webt/lt/rr/xo/ltrrxo5m-cfdsf7kpwy_vm0d4nu.png" align="left"> <code>Date.now()</code> <br> <img src="https://habrastorage.org/webt/hp/h-/w3/hph-w3yafyxorpopqiksdnd6j5g.png" align="left"> <code>performance.now()</code> <br> <br><h3>  Borde </h3><br><img src="https://habrastorage.org/webt/_z/im/h2/_zimh2thj4w5t2o_ounushbk94m.png"><br><div class="spoiler">  <b class="spoiler_title">estad√≠sticas</b> <div class="spoiler_text">  Versi√≥n del navegador: 44.17763.771.0 <br><br><h3>  Date.now () </h3>  intervalo promedio: 25.595959595959595 ms <br>  desviaci√≥n del intervalo promedio, RMS: 10.12639235162126 ms <br>  mediana del intervalo: 28 ms <br><br><h3>  performance.now () </h3>  intervalo promedio: 25.862596938775525 ms <br>  desviaci√≥n del intervalo promedio, RMS: 10.123711255512573 ms <br>  Intervalo medio: 27.027099999999336 ms <br></div></div><br><br><h3>  Firefox </h3><br><img src="https://habrastorage.org/webt/bm/pn/bs/bmpnbsvv3esgusduj0djwdvazg4.png"><br><div class="spoiler">  <b class="spoiler_title">estad√≠sticas</b> <div class="spoiler_text">  Versi√≥n del navegador: 71.0 <br><br><h3>  Date.now () </h3>  intervalo promedio: 1.6914893617021276 ms <br>  desviaci√≥n del intervalo promedio, RMS: 0.6018870280772611 ms <br>  mediana del intervalo: 2 ms <br><br><h3>  performance.now () </h3>  intervalo promedio: 1.7865168539325842 ms <br>  desviaci√≥n del intervalo promedio, RMS: 0.6442818510935484 ms <br>  mediana del intervalo: 2 ms <br></div></div><br><br><h3>  Cromo </h3><br><img src="https://habrastorage.org/webt/ig/my/wf/igmywf_jvwphlqdqm9qac2evy64.png"><br><div class="spoiler">  <b class="spoiler_title">estad√≠sticas</b> <div class="spoiler_text">  Versi√≥n del navegador: 79.0.3945.88 <br><br><h3>  Date.now () </h3>  intervalo promedio: 4.7878787878787888, ms <br>  desviaci√≥n del intervalo promedio, RMS: 0.7557553886872682 ms <br>  mediana del intervalo: 5 ms <br><br><h3>  performance.now () </h3>  intervalo promedio: 4.783989898979516 ms <br>  desviaci√≥n del intervalo promedio, RMS: 0.6483716900974945 ms <br>  intervalo medio: 4.750000000058208 ms <br></div></div><br></div></div><br><br>  Quiz√°s alguien recordar√° las primeras aplicaciones experimentales de audio HTML.  Antes de que WebAudio de pleno derecho llegara a los navegadores, todos parec√≠an un poco borrachos, descuidados.  Solo porque usaron <code>setTimeout</code> como secuenciador. <br><br>  La API moderna de WebAudio, por el contrario, ofrece una resoluci√≥n garantizada de hasta 0,02 ms (especulaci√≥n basada en la frecuencia de muestreo de 44100Hz).  Esto se debe al hecho de que se utiliza un mecanismo diferente para la reproducci√≥n de sonido diferido que <code>setTimeout</code> : <br><br><pre> <code class="javascript hljs">source.start(when);</code> </pre> <br>  De hecho, cualquier reproducci√≥n de una muestra de audio est√° "retrasada".  Solo para perderlo "no se pospone", debe posponerlo "hasta ahora". <br><br><pre> <code class="javascript hljs">source.start(audioCtx.currentTime);</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Acerca de la m√∫sica generada por software en tiempo real</b> <div class="spoiler_text">  Si toca una melod√≠a sintetizada por programa a partir de notas, entonces estas notas deben agregarse a la cola de reproducci√≥n con un poco de anticipaci√≥n.  Luego, a pesar de todas las restricciones e irregularidades no fundamentales de los temporizadores, la melod√≠a se reproducir√° perfectamente. <br><br>  En otras palabras, la melod√≠a sintetizada en tiempo real no debe ser "inventada" en tiempo real, sino un poco por adelantado. <br></div></div><br><br><h2>  Un temporizador para gobernarlos a todos </h2><br>  Dado que <code>audioCtx.currentTime</code> tan estable y preciso, ¬øtal vez deber√≠amos usarlo como la fuente principal de tiempo relativo?  Ejecutemos la prueba nuevamente. <br><br><div class="spoiler">  <b class="spoiler_title">C√≥digo de prueba: medici√≥n de tiempo s√≠ncrono en un ciclo</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">measureTimesInLoop</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">length</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> d = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(length); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> p = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(length); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(length); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; length; i++) { d[i] = <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now(); p[i] = performance.now(); a[i] = audioCtx.currentTime * <span class="hljs-number"><span class="hljs-number">1000</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { d, p, a } }</code> </pre> <br></div></div><br><img src="https://habrastorage.org/webt/lt/rr/xo/ltrrxo5m-cfdsf7kpwy_vm0d4nu.png" align="left"> <code>Date.now()</code> <br> <img src="https://habrastorage.org/webt/hp/h-/w3/hph-w3yafyxorpopqiksdnd6j5g.png" align="left"> <code>performance.now()</code> <br> <img src="https://habrastorage.org/webt/xo/or/r9/xoorr9ldh_oivoxxvbxj8yozwqc.png" align="left"> <code>audioCtx.currentTime</code> <br> <br><h3>  Borde </h3><br><img src="https://habrastorage.org/webt/rt/xx/u0/rtxxu0ckburybooxuw93uiya7-s.png"><br><div class="spoiler">  <b class="spoiler_title">estad√≠sticas</b> <div class="spoiler_text">  Versi√≥n del navegador: 44.17763.771.0 <br><br><h3>  Date.now () </h3>  intervalo promedio: 1.037037037037037 ms <br>  desviaci√≥n del intervalo promedio, RMS: 0.6166609846299806 ms <br>  mediana del intervalo: 1 ms <br><br><h3>  performance.now () </h3>  intervalo promedio: 1.5447103117505993 ms <br>  desviaci√≥n del intervalo promedio, RMS: 0.4390514285320851 ms <br>  mediana del intervalo: 1.5015000000000782 ms <br><br><h3>  audioCtx.currentTime </h3>  intervalo promedio: 2.955751134714949 ms <br>  desviaci√≥n del intervalo promedio, RMS: 0.6193645611529503 ms <br>  Intervalo medio: 2.902507781982422 ms <br><br></div></div><br><br><h3>  Firefox </h3><br><img src="https://habrastorage.org/webt/rr/v6/ws/rrv6wsi1tmnpdb8yf7y6wmfvyo8.png"><br><div class="spoiler">  <b class="spoiler_title">estad√≠sticas</b> <div class="spoiler_text">  Versi√≥n del navegador: 71.0 <br><br><h3>  Date.now () </h3>  intervalo promedio: 1.005128205128205 ms <br>  desviaci√≥n del intervalo promedio, RMS: 0.12392867665225249 ms <br>  mediana del intervalo: 1 ms <br><br><h3>  performance.now () </h3>  intervalo promedio: 1.00513698630137 ms <br>  desviaci√≥n del intervalo promedio, RMS: 0.07148844433269844 ms <br>  mediana del intervalo: 1 ms <br><br><h3>  audioCtx.currentTime </h3>  Firefox no actualiza el valor del temporizador de audio en el bucle de sincronizaci√≥n <br><br></div></div><br><br><h3>  Cromo </h3><br><img src="https://habrastorage.org/webt/yx/wx/rk/yxwxrkmxhv3yzxzpzckvfhouz6y.png"><br><div class="spoiler">  <b class="spoiler_title">estad√≠sticas</b> <div class="spoiler_text">  Versi√≥n del navegador: 79.0.3945.88 <br><br><h3>  Date.now () </h3>  intervalo promedio: 1.0207612456747406 ms <br>  desviaci√≥n del intervalo promedio, RMS: 0.49870223457982504 ms <br>  mediana del intervalo: 1 ms <br><br><h3>  performance.now () </h3>  intervalo promedio: 0.005414502034674972 ms <br>  desviaci√≥n del intervalo promedio, RMS: 0.027441293974958335 ms <br>  intervalo medio: 0.004999999873689376 ms <br><br><h3>  audioCtx.currentTime </h3>  intervalo promedio: 3.0877599266656963 ms <br>  desviaci√≥n del intervalo promedio, RMS: 1.1445555956407658 ms <br>  mediana del intervalo: 2.9024943310650997 ms <br><br></div></div><br><br><div class="spoiler">  <b class="spoiler_title">Gr√°ficos para el caso as√≠ncrono debajo del spoiler</b> <div class="spoiler_text"><div class="spoiler">  <b class="spoiler_title">C√≥digo de prueba: medici√≥n del tiempo en un ciclo asincr√≥nico</b> <div class="spoiler_text">  El resultado de la prueba en un intervalo de 100 ms: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pause</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">duration</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function">) =&gt;</span></span> { setInterval(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { resolve(); }, duration); }); } <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">measureTimesInAsyncLoop</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">length</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> d = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(length); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> p = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(length); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(length); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; length; i++) { d[i] = <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now(); p[i] = performance.now(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> pause(<span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { d, p } }</code> </pre> <br></div></div><br><br><img src="https://habrastorage.org/webt/lt/rr/xo/ltrrxo5m-cfdsf7kpwy_vm0d4nu.png" align="left"> <code>Date.now()</code> <br> <img src="https://habrastorage.org/webt/hp/h-/w3/hph-w3yafyxorpopqiksdnd6j5g.png" align="left"> <code>performance.now()</code> <br> <img src="https://habrastorage.org/webt/xo/or/r9/xoorr9ldh_oivoxxvbxj8yozwqc.png" align="left"> <code>audioCtx.currentTime</code> <br> <br><h3>  Borde </h3><br><img src="https://habrastorage.org/webt/3o/sz/az/3oszazaq71kxfdaftgn6v3z23xe.png"><br><div class="spoiler">  <b class="spoiler_title">estad√≠sticas</b> <div class="spoiler_text">  Versi√≥n del navegador: 44.17763.771.0 <br><br><h3>  Date.now (): </h3>  intervalo promedio: 24.505050505050505 ms <br>  desviaci√≥n del intervalo promedio: 11.513166584195204 ms <br>  mediana del intervalo: 26 ms <br><br><h3>  performance.now (): </h3>  intervalo promedio: 24.50935757575754 ms <br>  desviaci√≥n del intervalo promedio: 11.679091435527388 ms <br>  mediana del intervalo: 25.525499999999738 ms <br><br><h3>  audioCtx.currentTime: </h3>  intervalo promedio: 24.76005164944396 ms <br>  desviaci√≥n del intervalo promedio: 11.311571546205316 ms <br>  mediana del intervalo: 26.121139526367187 ms <br><br></div></div><br><h3>  Firefox </h3><br><img src="https://habrastorage.org/webt/wf/4n/jn/wf4njn3z7u9uoxluprufhlbctai.png"><br><div class="spoiler">  <b class="spoiler_title">estad√≠sticas</b> <div class="spoiler_text">  Versi√≥n del navegador: 71.0 <br><br><h3>  Date.now (): </h3>  intervalo promedio: 1.6875 ms <br>  desviaci√≥n del intervalo promedio: 0.6663410663216448 ms <br>  mediana del intervalo: 2 ms <br><br><h3>  performance.now (): </h3>  intervalo promedio: 1.7234042553191489 ms <br>  desviaci√≥n del intervalo promedio: 0.6588877688171075 ms <br>  mediana del intervalo: 2 ms <br><br><h3>  audioCtx.currentTime: </h3>  intervalo promedio: 10.158730158730123 ms <br>  desviaci√≥n del intervalo promedio: 1.4512471655330046 ms <br>  intervalo medio: 8.707482993195299 ms <br><br></div></div><br><h3>  Cromo </h3><br><img src="https://habrastorage.org/webt/_s/hd/uh/_shduhzpetwube_gn6kxmwyobiu.png"><br><div class="spoiler">  <b class="spoiler_title">estad√≠sticas</b> <div class="spoiler_text">  Versi√≥n del navegador: 79.0.3945.88 <br><br><h3>  Date.now (): </h3>  intervalo promedio: 4.585858585858586 ms <br>  desviaci√≥n del intervalo promedio: 0.9102125516015199 ms <br>  mediana del intervalo: 5 ms <br><br><h3>  performance.now (): </h3>  intervalo promedio: 4.592424242424955 ms <br>  desviaci√≥n del intervalo promedio: 0.719936993603155 ms <br>  Intervalo medio: 4.605000001902226 ms <br><br><h3>  audioCtx.currentTime: </h3>  intervalo promedio: 10.12648022171832 ms <br>  desviaci√≥n del intervalo promedio: 1.4508887886499262 ms <br>  mediana del intervalo: 8.707482993197118 ms <br><br></div></div><br></div></div><br>  Bueno, no funcionar√°.  "Fuera", este temporizador es el m√°s inexacto.  Firefox no actualiza el valor del temporizador dentro del bucle.  Pero en general: la resoluci√≥n es de 3 ms y peor y notable jitter.  Quiz√°s el valor de <code>audioCtx.currentTime</code> refleja la posici√≥n en el b√∫fer en anillo del controlador de la tarjeta de audio.  En otras palabras, muestra el tiempo m√≠nimo que a√∫n es posible retrasar de forma segura la reproducci√≥n. <br><br>  Y que hacer  Despu√©s de todo, necesitamos un temporizador preciso para sincronizar con el servidor y lanzar eventos de JavaScript en la pantalla, ¬°y un temporizador de audio para eventos de sonido! <br><br>  Resulta que necesita sincronizar todos los temporizadores entre s√≠: <br><br><ul><li>  Cliente <code>audioCtx.currentTime</code> con el <code>performance.now()</code> cliente.now <code>performance.now()</code> en el cliente. </li><li>  Y cliente <code>performance.now()</code> con <code>performance.now()</code> del lado del servidor. </li></ul><br><h2>  Sincronizado, sincronizado </h2><br><img src="https://habrastorage.org/webt/f1/ph/o9/f1pho9gss4d40786nszfeicwrog.png" align="right">  En general, esto es bastante divertido si lo piensa: puede tener dos buenas fuentes de tiempo A y B, cada una de las cuales es muy gruesa y ruidosa en la salida (A '= A + err <sub>A</sub> ; B' = B + err <sub>B</sub> ) para que pueda incluso ser inutilizable por s√≠ solo.  Pero la diferencia d entre las fuentes originales no ruidosas puede restaurarse con mucha precisi√≥n. <br><br>  Dado que la distancia de tiempo real entre los relojes ideales es constante, tomando mediciones n veces, reduciremos el error de medici√≥n err n veces, respectivamente.  A menos, por supuesto, que el reloj funcione a la misma velocidad. <br><br><h2>  Si no sincronizado </h2><br>  La mala noticia es que no, no van a la misma velocidad.  Y no estoy hablando de la divergencia de horas en el servidor y en el cliente, esto es comprensible y esperado.  Lo que es m√°s inesperado: <code>audioCtx.currentTime</code> divergiendo gradualmente de <code>performance.now()</code> .  Est√° dentro del cliente.  Es posible que no nos demos cuenta, pero a veces, bajo carga, el sistema de audio puede no tragar una peque√±a pieza de datos y (al contrario de la naturaleza del b√∫fer en anillo) el tiempo de audio cambiar√° en relaci√≥n con el tiempo del sistema.  Esto no ocurre tan raramente, simplemente no afecta a muchas personas: pero si, por ejemplo, lanzas dos videos de YouTube al mismo tiempo simult√°neamente en diferentes computadoras, no es un hecho que dejen de reproducirse al mismo tiempo.  Y el punto, por supuesto, no est√° en la publicidad. <br><br>  Por lo tanto, para un funcionamiento estable y sincr√≥nico.  Necesitamos revisar <i>peri√≥dicamente</i> todos los relojes entre s√≠, utilizando la hora del servidor, como referencia.  Y luego aparece el equilibrio en cu√°ntas mediciones usar para promediar: cuanto m√°s, m√°s preciso, pero mayor es la posibilidad de que un salto brusco en <code>audioCtx.currentTime</code> caiga en la ventana de tiempo en la que filtramos los valores.  Luego, si, por ejemplo, usamos la ventana de minutos, todos los minutos tendremos el tiempo transcurrido.  La elecci√≥n de los filtros es amplia: <a href="https://ru.wikipedia.org/wiki/%25D0%25AD%25D0%25BA%25D1%2581%25D0%25BF%25D0%25BE%25D0%25BD%25D0%25B5%25D0%25BD%25D1%2586%25D0%25B8%25D0%25B0%25D0%25BB%25D1%258C%25D0%25BD%25D0%25BE%25D0%25B5_%25D1%2581%25D0%25B3%25D0%25BB%25D0%25B0%25D0%25B6%25D0%25B8%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5" rel="nofollow">exponencial</a> , <a href="https://ru.wikipedia.org/wiki/%25D0%259C%25D0%25B5%25D0%25B4%25D0%25B8%25D0%25B0%25D0%25BD%25D0%25B0_(%25D1%2581%25D1%2582%25D0%25B0%25D1%2582%25D0%25B8%25D1%2581%25D1%2582%25D0%25B8%25D0%25BA%25D0%25B0)" rel="nofollow">mediana</a> , <a href="https://ru.wikipedia.org/wiki/%25D0%25A4%25D0%25B8%25D0%25BB%25D1%258C%25D1%2582%25D1%2580_%25D0%259A%25D0%25B0%25D0%25BB%25D0%25BC%25D0%25B0%25D0%25BD%25D0%25B0" rel="nofollow">filtro de Kalman</a> , etc.  Pero esta compensaci√≥n es en cualquier caso. <br><br><h2>  Ventana de tiempo </h2><br>  En el caso de sincronizar <code>audioCtx.currentTime</code> con <code>performance.now()</code> , en un bucle as√≠ncrono, para no interferir con la interfaz de usuario, podemos tomar una medida, digamos, 100 ms. <br>  Suponga que el error de medici√≥n err = errA + errB = 1 + 3 = 4 ms <br>  En consecuencia, en 1 segundo podemos reducirlo a 0,4 ms, y en 10 segundos a 0,04 ms.  Una mejora adicional del resultado no tiene sentido, y una buena ventana para el filtrado ser√°: 1 - 10 segundos. <br><br>  En el caso de la sincronizaci√≥n de red, los retrasos y los errores ya son mucho m√°s significativos, pero no hay un salto repentino en el tiempo, como es el caso de <code>audioCtx.currentTime</code> .  Y puede permitirse acumular estad√≠sticas realmente excelentes.  Despu√©s de todo, err para ping puede ser de hasta 500 ms.  Y las medidas en s√≠ no podemos hacer tan a menudo. <br><br>  En este punto, propongo parar.  Si alguien estaba interesado, estar√© encantado de decirle c√≥mo "dibujar el resto de la lechuza".  Pero como parte de la historia sobre los temporizadores, creo que mi historia ha terminado. <br><br>  Y quiero compartir lo que obtuve.  De todos modos, el a√±o nuevo. <br><br><h2>  Que paso </h2><br>  Descargo de responsabilidad: T√©cnicamente, este es un sitio de relaciones p√∫blicas en Habr√©, pero este es un proyecto de mascotas de c√≥digo abierto completamente sin fines de lucro en el que prometo nunca: poner anuncios o ganar dinero de otra manera.  Por el contrario, he recaudado m√°s casos de mi dinero ahora para sobrevivir a un posible efecto de habra.  Por lo tanto, por favor, buena gente, no me rompan y no me alcancen.  Todo esto es puramente divertido. <br><br>  Feliz a√±o nuevo, Habr! <br><br><hr><br><h3>  <a href="http://habr.snowtime.fun/" rel="nofollow">snowtime.fun</a> </h3>  Puede girar las perillas y controlar la visualizaci√≥n, la m√∫sica y los efectos de audio.  Si tiene una tarjeta de video normal, vaya a la configuraci√≥n y configure el n√∫mero de part√≠culas al 100%. <br><br>  Requiere WebAudio y WebGL. <br><br><hr><br><br>  <b>UPD:</b> no funciona en Safari con macOS Mojave.  Desafortunadamente, no hay forma de averiguar r√°pidamente qu√© est√° sucediendo, debido a la ausencia de este Safari en s√≠.  iOS parece estar funcionando. <br><br>  <b>UPD2:</b> Si <a href="http://snowtime.fun/" rel="nofollow">snowtime.fun</a> y <a href="http://web.snowtime.fun/" rel="nofollow">web.snowtime.fun</a> no responden, pruebe el nuevo subdominio <a href="http://habr.snowtime.fun/" rel="nofollow"><b>habr</b> .snowtime.fun</a> .  Traslad√≥ el servidor a otro centro de datos, y la antigua IP se almacen√≥ en cach√© en DNS, <code>expire=1w</code> .  :( <br><br>  Repositorio: <a href="https://bitbucket.org/barkalov/snowtime.fun/src" rel="nofollow">bitbucket</a> <br>  Al escribir este art√≠culo, se utilizaron ilustraciones de <a href="http://www.freepik.com/" rel="nofollow">macrovector / Freepik</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/482168/">https://habr.com/ru/post/482168/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../482154/index.html">¬øPor qu√© limitar la herencia con final?</a></li>
<li><a href="../482156/index.html">Entrevista con Will Kurt sobre su nuevo libro, Bayesian Statistics - It's Great</a></li>
<li><a href="../482158/index.html">Conoce a Ember Octane</a></li>
<li><a href="../482162/index.html">Los matem√°ticos han encontrado un patr√≥n, entendiendo c√≥mo evitar su aparici√≥n.</a></li>
<li><a href="../482166/index.html">Servicio de adiestramiento canino en el aeropuerto: ya est√° olisqueado</a></li>
<li><a href="../482170/index.html">Procesador de guerras. La historia de la liebre azul y la tortuga roja</a></li>
<li><a href="../482176/index.html">¬øC√≥mo fue la conferencia @Kubernetes el 29 de noviembre: video y resultados</a></li>
<li><a href="../482178/index.html">La historia de un estudiante coreano que recibi√≥ un premio del ministerio por un sistema de monitoreo de colas</a></li>
<li><a href="../482182/index.html">¬øQu√© problemas tendr√≠a si luchara por el equilibrio de g√©nero en TI?</a></li>
<li><a href="../482194/index.html">Generar autom√°ticamente y llenar elementos de configuraci√≥n de dispositivos de red con Nornir</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>