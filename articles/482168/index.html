<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>   "Cuando el reloj marca las doce". O una guirnalda en el navegador   </title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Supongamos que tenemos varios monitores. Y quer铆amos usar estos monitores como guirnalda. Por ejemplo, haz que parpadeen al mismo tiempo. O tal vez ca...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>"Cuando el reloj marca las doce". O una guirnalda en el navegador</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/482168/">  Supongamos que tenemos varios monitores.  Y quer铆amos usar estos monitores como guirnalda.  Por ejemplo, haz que parpadeen al mismo tiempo.  O tal vez cambie sincr贸nicamente el color de acuerdo con alg煤n tipo de algoritmo inteligente.  Y qu茅 pasa si lo haces en un navegador, entonces puedes conectar tel茅fonos inteligentes y tabletas a esto.  Todo eso est谩 a la mano. <br><br><img src="https://habrastorage.org/webt/yo/1c/a8/yo1ca85ahnnxg_5crc1hh84n9ng.jpeg"><br><br>  Y, como estamos usando un navegador, tambi茅n puede agregar dise帽o de sonido.  Despu茅s de todo, si es lo suficientemente preciso como para sincronizar los dispositivos a tiempo, puede reproducir sonidos en cada uno como si un sistema multicanal sonara. <br><br><hr>  <i>Lo que se puede encontrar al sincronizar Web Audio y relojes de juego dentro de una aplicaci贸n javascript;</i>  <i>cu谩ntas "horas" diferentes hay en javasctipt (隆tres!) y por qu茅 se necesitan todas, as铆 como una <a href="http://habr.snowtime.fun/" rel="nofollow">aplicaci贸n</a> preparada para node.js debajo del gato.</i> <a name="habracut"></a><hr><br><h2>  Mira el reloj </h2><br>  Para cualquier guirnalda en l铆nea condicional, se requiere una sincronizaci贸n precisa del reloj.  Despu茅s de todo, puede ignorar cualquier retraso de red (incluso intermitente).  Es suficiente proporcionar a los comandos de control una marca de tiempo y generar estos comandos un poco "hacia el futuro".  En los clientes, se almacenar谩n en el b煤fer y luego se ejecutar谩n sincr贸nicamente y a tiempo. <br><br>  O incluso puede ir m谩s all谩: tome el viejo algoritmo aleatorio determinista y use una semilla com煤n (emitida por el servidor una vez, cuando est茅 conectada) en todos los dispositivos.  Si usa dicha semilla <i>junto</i> con el tiempo exacto, puede determinar completamente el comportamiento del algoritmo en todos los dispositivos.  Imag铆nese: de hecho, no necesita una red o un servidor para cambiar el estado de forma 煤nica y sincr贸nica.  La semilla ya contiene la totalidad (condicionalmente infinita) "grabaci贸n de video" de acciones por adelantado.  Lo principal es la hora exacta. <br><br><img src="https://habrastorage.org/webt/kd/tx/tt/kdtxttvwqoqkb69jvoov077o8vs.gif"><br><hr>  <i>Cada m茅todo tiene sus l铆mites de aplicabilidad.</i>  <i>Con la entrada instant谩nea del usuario, por supuesto, no hay nada que hacer, queda transmitirlo "tal cual".</i>  <i>Pero todo lo que se puede calcular es calcular.</i>  <i>En mi implementaci贸n, utilizo los tres enfoques, dependiendo de la situaci贸n.</i> <hr><br><h2>  Subjetivo "al mismo tiempo" </h2><br>  Idealmente, todo deber铆a sonar "al mismo tiempo": no se necesita m谩s de 卤 10 ms de discrepancia para el peor par entre los dispositivos combinados.  No puede contar con esa precisi贸n desde la hora del sistema, y los m茅todos est谩ndar para sincronizar la hora utilizando el protocolo NTP no est谩n disponibles en el navegador.  Por lo tanto, manejaremos nuestro servidor de sincronizaci贸n.  El principio es simple: el casco "pings" y aceptar "pongs" con la marca de tiempo del servidor.  Si hace esto muchas veces seguidas, puede nivelar estad铆sticamente el error y obtener el tiempo de retraso promedio. <br><br><div class="spoiler">  <b class="spoiler_title">C贸digo: calcular la hora del servidor en el cliente</b> <div class="spoiler_text"><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> pingClientTime = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">// performace.now() time when ping started let pongClientTime = 3; // performace.now() time when pong received let pongServerTime = 20; // server timstamp in pong answer let clientServerRawOffset = pongServerTime - pongClientTime; let pingPongOffset = pongClientTime - pingClientTime; // roundtrip let estimatedPingOffset = pingPongOffset / 2; // one-way let offset = clientServerRawOffset + estimatedPingOffset; console.log(estimatedPingOffset) // 1 console.log(offset); // 18 let sharedServerTime = performace.now() + offset;</span></span></code> </pre> <br></div></div><br><br>  Los sockets web y las soluciones basadas en 茅l son los m谩s adecuados porque no requieren tiempo para crear una conexi贸n TCP y puede "comunicarse" con ellos en ambas direcciones.  No UDP o ICMP, por supuesto, pero incomparablemente m谩s r谩pido que una conexi贸n en fr铆o normal que utiliza la API HTTP.  Por lo tanto, socket.io.  Todo es muy f谩cil all铆: <br><br><div class="spoiler">  <b class="spoiler_title">C贸digo: implementaci贸n socket.io</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// server socket.on('ping', (pongCallback) =&gt; { let pongServerTime = performace.now(); pongCallback(pongServerTime); }); //client const binSize = 100; let clientServerCalculatedOffset; function ping() { socket.emit('ping', pongCallback); const pingClientTime = performace.now(); function pongCallback(pongServerTime) { const pongClientTime = performace.now(); const clientServerRawOffset = pongServerTime - pongClientTime; const pingPongOffset = pongClientTime - pingClientTime; // roundtrip const estimatedPingOffset = pingPongOffset / 2; // one-way const offset = clientServerRawOffset + estimatedPingOffset; offsets.unshift(offset); offsets.splice(binSize); let offsetSum = 0; offsets.forEach((offset) =&gt; { offsetSum += offset; }); clientServerCalculatedOffset = offsetSum / offset.length(); } }</span></span></code> </pre> <br>  <i>Ser铆a bueno, en lugar de calcular el promedio, calcular la mediana; esto mejorar谩 la precisi贸n con una conexi贸n inestable.</i>  <i>La elecci贸n de los m茅todos de filtrado depende del lector.</i>  <i>Deliberadamente simplifico el c贸digo aqu铆 a favor de los esquemas.</i>  <i>Mi soluci贸n completa se puede encontrar en el repositorio.</i> <br></div></div><br><br><h2>  performance.now () </h2><br>  Perm铆tame recordarle que el objeto de <code>performance</code> es una API que proporciona acceso a un temporizador de alta resoluci贸n.  Compara: <br><br><ul><li>  <b><code>Date.now()</code></b> devuelve el n煤mero de milisegundos desde el 1 de enero de 1970, y lo hace en forma <b>entera</b> .  Es decir, el error solo del redondeo es 0.5 ms en promedio.  Por ejemplo, en una operaci贸n de resta <code>ab</code> puede "perder" sin 茅xito hasta 2 ms.  Adem谩s, hist贸rica y conceptualmente, el medidor de tiempo en s铆 mismo no garantiza una alta precisi贸n y est谩 afilado para trabajar con una escala de tiempo m谩s grande. </li><li>  <b><code>performance.now()</code></b> devuelve el n煤mero de milisegundos <a href="https://developer.mozilla.org/en-US/docs/Web/API/DOMHighResTimeStamp" rel="nofollow">desde que se abri贸 la p谩gina web</a> . <br>  Esta es una API relativamente reciente, "afilada" espec铆ficamente para la medici贸n precisa de intervalos de tiempo.  Devuelve <b>un valor de punto flotante</b> , te贸ricamente dando un nivel de precisi贸n cercano a las capacidades del sistema operativo en s铆. <br></li></ul><br><br>  Creo que esta informaci贸n es conocida por casi todos los desarrolladores de JavaScript.  Pero no todos saben eso ... <br><br><h2>  Espectro </h2><br>  Debido al sensacional ataque de sincronizaci贸n de Specter en 2018, todo llega al punto de que el temporizador de alta resoluci贸n se endurecer谩 artificialmente si no hay otra soluci贸n al problema de vulnerabilidad.  Firefox, comenzando con la versi贸n 60, redondea el valor de este temporizador a un milisegundo, y Edge, a煤n peor. <br><br>  Esto es lo que dice <a href="https://developer.mozilla.org/en-US/docs/Web/API/Performance/now" rel="nofollow">MDN</a> : <br><br><blockquote>  La marca de tiempo no es en realidad de alta resoluci贸n.  Para mitigar las amenazas de seguridad como Spectre, los navegadores actualmente redondean los resultados en diversos grados.  (Firefox comenz贸 a redondearse a 1 milisegundo en Firefox 60). Algunos navegadores tambi茅n pueden aleatorizar ligeramente la marca de tiempo.  La precisi贸n puede mejorar nuevamente en futuras versiones;  Los desarrolladores de navegadores a煤n est谩n investigando estos ataques de tiempo y la mejor manera de mitigarlos. </blockquote><br>  Ejecutemos la prueba y echemos un vistazo a los gr谩ficos.  Este es el resultado de la prueba en un intervalo de 10 ms: <br><br><div class="spoiler">  <b class="spoiler_title">C贸digo de prueba: medici贸n del tiempo en un ciclo</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">measureTimesLoop</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">length</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> d = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(length); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> p = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(length); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; length; i++) { d[i] = <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now(); p[i] = performance.now(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { d, p } }</code> </pre> <br></div></div><br><img src="https://habrastorage.org/webt/lt/rr/xo/ltrrxo5m-cfdsf7kpwy_vm0d4nu.png" align="left"> <code>Date.now()</code> <br> <img src="https://habrastorage.org/webt/hp/h-/w3/hph-w3yafyxorpopqiksdnd6j5g.png" align="left"> <code>performance.now()</code> <br> <br><h3>  Borde </h3><br><img src="https://habrastorage.org/webt/g2/t2/bs/g2t2bssr-dhq8cbyb95-pwjxclw.png"><br><div class="spoiler">  <b class="spoiler_title">estad铆sticas</b> <div class="spoiler_text">  Versi贸n del navegador: 44.17763.771.0 <br><br><h3>  Date.now () </h3>  intervalo promedio: 1.0538336052202284 ms <br>  desviaci贸n del intervalo promedio, RMS: 0.7547819181245603 ms <br>  mediana del intervalo: 1 ms <br><br><h3>  performance.now () </h3>  intervalo promedio: 1.567100970873786 ms <br>  desviaci贸n del intervalo promedio, RMS: 0.6748006785171455 ms <br>  mediana del intervalo: 1.5015000000003056 ms <br></div></div><br><br><h3>  Firefox </h3><br><img src="https://habrastorage.org/webt/7y/6b/a_/7y6ba_0b_lgehjq2yko_60ip4am.png"><br><div class="spoiler">  <b class="spoiler_title">estad铆sticas</b> <div class="spoiler_text">  Versi贸n del navegador: 71.0 <br><br><h3>  Date.now () </h3>  intervalo promedio: 1.0168350168350169 ms <br>  desviaci贸n del intervalo promedio, RMS: 0.21645930182417966 ms <br>  mediana del intervalo: 1 ms <br><br><h3>  performance.now () </h3>  intervalo promedio: 1.0134453781512605 ms <br>  desviaci贸n del intervalo promedio, RMS: 0.1734108492762375 ms <br>  mediana del intervalo: 1 ms <br></div></div><br><br><h3>  Cromo </h3><br><img src="https://habrastorage.org/webt/zv/_y/pp/zv_yppcegrbidigvmp6npdcwzf0.png"><br><div class="spoiler">  <b class="spoiler_title">estad铆sticas</b> <div class="spoiler_text">  Versi贸n del navegador: 79.0.3945.88 <br><br><h3>  Date.now () </h3>  intervalo promedio: 1.02442996742671 ms <br>  desviaci贸n del intervalo promedio, RMS: 0.49858684744444 ms <br>  mediana del intervalo: 1 ms <br><br><h3>  performance.now () </h3>  intervalo promedio: 0.005555847229948915 ms <br>  desviaci贸n del intervalo promedio, RMS: 0.027497846727194235 ms <br>  mediana del intervalo: 0.0050000089686363935 ms <br></div></div><br><br>  Ok, Chrome, haz zoom a 1 ms. <br><br><img src="https://habrastorage.org/webt/2o/9m/ik/2o9mikwf_owbi8mn1saodrmd_e8.png"><br><br>  Por lo tanto, Chrome todav铆a est谩 aguantando, y su implementaci贸n de <code>performance.now()</code> a煤n no se ha estrangulado y el paso es hermoso 0.005 ms.  隆Bajo Edge, el temporizador <code>performance.now()</code> es m谩s duro que <code>Date.now()</code> !  En Firefox, ambos temporizadores tienen la misma precisi贸n de milisegundos. <br><br>  En esta etapa, ya se pueden sacar algunas conclusiones.  Pero hay otro temporizador en javascript (sin el cual no podemos prescindir). <br><br><h2>  WebAudio API Timer </h2><br>  Esta es una bestia ligeramente diferente.  Se utiliza para colas de audio retrasadas.  El hecho es que los eventos de audio (reproducci贸n de notas, gesti贸n de efectos) no pueden depender de herramientas de JavaScript as铆ncronas est谩ndar: <code>setInterval</code> y <code>setTimeout</code> , debido a su error demasiado grande.  Y esto no es solo el error <i>de los valores del</i> temporizador (con los que tratamos anteriormente), sino que es el error con el que la m谩quina de eventos ejecuta eventos.  Y ya es algo alrededor de 5-25 ms, incluso en condiciones de invernadero. <br><br><div class="spoiler">  <b class="spoiler_title">Gr谩ficos para el caso as铆ncrono debajo del spoiler</b> <div class="spoiler_text">  El resultado de la prueba en un intervalo de 100 ms: <br><br><div class="spoiler">  <b class="spoiler_title">C贸digo de prueba: medici贸n del tiempo en un ciclo asincr贸nico</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pause</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">duration</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function">) =&gt;</span></span> { setInterval(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { resolve(); }, duration); }); } <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">measureTimesInAsyncLoop</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">length</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> d = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(length); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> p = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(length); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; length; i++) { d[i] = <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now(); p[i] = performance.now(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> pause(<span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { d, p } }</code> </pre> <br></div></div><br><img src="https://habrastorage.org/webt/lt/rr/xo/ltrrxo5m-cfdsf7kpwy_vm0d4nu.png" align="left"> <code>Date.now()</code> <br> <img src="https://habrastorage.org/webt/hp/h-/w3/hph-w3yafyxorpopqiksdnd6j5g.png" align="left"> <code>performance.now()</code> <br> <br><h3>  Borde </h3><br><img src="https://habrastorage.org/webt/_z/im/h2/_zimh2thj4w5t2o_ounushbk94m.png"><br><div class="spoiler">  <b class="spoiler_title">estad铆sticas</b> <div class="spoiler_text">  Versi贸n del navegador: 44.17763.771.0 <br><br><h3>  Date.now () </h3>  intervalo promedio: 25.595959595959595 ms <br>  desviaci贸n del intervalo promedio, RMS: 10.12639235162126 ms <br>  mediana del intervalo: 28 ms <br><br><h3>  performance.now () </h3>  intervalo promedio: 25.862596938775525 ms <br>  desviaci贸n del intervalo promedio, RMS: 10.123711255512573 ms <br>  Intervalo medio: 27.027099999999336 ms <br></div></div><br><br><h3>  Firefox </h3><br><img src="https://habrastorage.org/webt/bm/pn/bs/bmpnbsvv3esgusduj0djwdvazg4.png"><br><div class="spoiler">  <b class="spoiler_title">estad铆sticas</b> <div class="spoiler_text">  Versi贸n del navegador: 71.0 <br><br><h3>  Date.now () </h3>  intervalo promedio: 1.6914893617021276 ms <br>  desviaci贸n del intervalo promedio, RMS: 0.6018870280772611 ms <br>  mediana del intervalo: 2 ms <br><br><h3>  performance.now () </h3>  intervalo promedio: 1.7865168539325842 ms <br>  desviaci贸n del intervalo promedio, RMS: 0.6442818510935484 ms <br>  mediana del intervalo: 2 ms <br></div></div><br><br><h3>  Cromo </h3><br><img src="https://habrastorage.org/webt/ig/my/wf/igmywf_jvwphlqdqm9qac2evy64.png"><br><div class="spoiler">  <b class="spoiler_title">estad铆sticas</b> <div class="spoiler_text">  Versi贸n del navegador: 79.0.3945.88 <br><br><h3>  Date.now () </h3>  intervalo promedio: 4.7878787878787888, ms <br>  desviaci贸n del intervalo promedio, RMS: 0.7557553886872682 ms <br>  mediana del intervalo: 5 ms <br><br><h3>  performance.now () </h3>  intervalo promedio: 4.783989898979516 ms <br>  desviaci贸n del intervalo promedio, RMS: 0.6483716900974945 ms <br>  intervalo medio: 4.750000000058208 ms <br></div></div><br></div></div><br><br>  Quiz谩s alguien recordar谩 las primeras aplicaciones experimentales de audio HTML.  Antes de que WebAudio de pleno derecho llegara a los navegadores, todos parec铆an un poco borrachos, descuidados.  Solo porque usaron <code>setTimeout</code> como secuenciador. <br><br>  La API moderna de WebAudio, por el contrario, ofrece una resoluci贸n garantizada de hasta 0,02 ms (especulaci贸n basada en la frecuencia de muestreo de 44100Hz).  Esto se debe al hecho de que se utiliza un mecanismo diferente para la reproducci贸n de sonido diferido que <code>setTimeout</code> : <br><br><pre> <code class="javascript hljs">source.start(when);</code> </pre> <br>  De hecho, cualquier reproducci贸n de una muestra de audio est谩 "retrasada".  Solo para perderlo "no se pospone", debe posponerlo "hasta ahora". <br><br><pre> <code class="javascript hljs">source.start(audioCtx.currentTime);</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Acerca de la m煤sica generada por software en tiempo real</b> <div class="spoiler_text">  Si toca una melod铆a sintetizada por programa a partir de notas, entonces estas notas deben agregarse a la cola de reproducci贸n con un poco de anticipaci贸n.  Luego, a pesar de todas las restricciones e irregularidades no fundamentales de los temporizadores, la melod铆a se reproducir谩 perfectamente. <br><br>  En otras palabras, la melod铆a sintetizada en tiempo real no debe ser "inventada" en tiempo real, sino un poco por adelantado. <br></div></div><br><br><h2>  Un temporizador para gobernarlos a todos </h2><br>  Dado que <code>audioCtx.currentTime</code> tan estable y preciso, 驴tal vez deber铆amos usarlo como la fuente principal de tiempo relativo?  Ejecutemos la prueba nuevamente. <br><br><div class="spoiler">  <b class="spoiler_title">C贸digo de prueba: medici贸n de tiempo s铆ncrono en un ciclo</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">measureTimesInLoop</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">length</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> d = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(length); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> p = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(length); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(length); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; length; i++) { d[i] = <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now(); p[i] = performance.now(); a[i] = audioCtx.currentTime * <span class="hljs-number"><span class="hljs-number">1000</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { d, p, a } }</code> </pre> <br></div></div><br><img src="https://habrastorage.org/webt/lt/rr/xo/ltrrxo5m-cfdsf7kpwy_vm0d4nu.png" align="left"> <code>Date.now()</code> <br> <img src="https://habrastorage.org/webt/hp/h-/w3/hph-w3yafyxorpopqiksdnd6j5g.png" align="left"> <code>performance.now()</code> <br> <img src="https://habrastorage.org/webt/xo/or/r9/xoorr9ldh_oivoxxvbxj8yozwqc.png" align="left"> <code>audioCtx.currentTime</code> <br> <br><h3>  Borde </h3><br><img src="https://habrastorage.org/webt/rt/xx/u0/rtxxu0ckburybooxuw93uiya7-s.png"><br><div class="spoiler">  <b class="spoiler_title">estad铆sticas</b> <div class="spoiler_text">  Versi贸n del navegador: 44.17763.771.0 <br><br><h3>  Date.now () </h3>  intervalo promedio: 1.037037037037037 ms <br>  desviaci贸n del intervalo promedio, RMS: 0.6166609846299806 ms <br>  mediana del intervalo: 1 ms <br><br><h3>  performance.now () </h3>  intervalo promedio: 1.5447103117505993 ms <br>  desviaci贸n del intervalo promedio, RMS: 0.4390514285320851 ms <br>  mediana del intervalo: 1.5015000000000782 ms <br><br><h3>  audioCtx.currentTime </h3>  intervalo promedio: 2.955751134714949 ms <br>  desviaci贸n del intervalo promedio, RMS: 0.6193645611529503 ms <br>  Intervalo medio: 2.902507781982422 ms <br><br></div></div><br><br><h3>  Firefox </h3><br><img src="https://habrastorage.org/webt/rr/v6/ws/rrv6wsi1tmnpdb8yf7y6wmfvyo8.png"><br><div class="spoiler">  <b class="spoiler_title">estad铆sticas</b> <div class="spoiler_text">  Versi贸n del navegador: 71.0 <br><br><h3>  Date.now () </h3>  intervalo promedio: 1.005128205128205 ms <br>  desviaci贸n del intervalo promedio, RMS: 0.12392867665225249 ms <br>  mediana del intervalo: 1 ms <br><br><h3>  performance.now () </h3>  intervalo promedio: 1.00513698630137 ms <br>  desviaci贸n del intervalo promedio, RMS: 0.07148844433269844 ms <br>  mediana del intervalo: 1 ms <br><br><h3>  audioCtx.currentTime </h3>  Firefox no actualiza el valor del temporizador de audio en el bucle de sincronizaci贸n <br><br></div></div><br><br><h3>  Cromo </h3><br><img src="https://habrastorage.org/webt/yx/wx/rk/yxwxrkmxhv3yzxzpzckvfhouz6y.png"><br><div class="spoiler">  <b class="spoiler_title">estad铆sticas</b> <div class="spoiler_text">  Versi贸n del navegador: 79.0.3945.88 <br><br><h3>  Date.now () </h3>  intervalo promedio: 1.0207612456747406 ms <br>  desviaci贸n del intervalo promedio, RMS: 0.49870223457982504 ms <br>  mediana del intervalo: 1 ms <br><br><h3>  performance.now () </h3>  intervalo promedio: 0.005414502034674972 ms <br>  desviaci贸n del intervalo promedio, RMS: 0.027441293974958335 ms <br>  intervalo medio: 0.004999999873689376 ms <br><br><h3>  audioCtx.currentTime </h3>  intervalo promedio: 3.0877599266656963 ms <br>  desviaci贸n del intervalo promedio, RMS: 1.1445555956407658 ms <br>  mediana del intervalo: 2.9024943310650997 ms <br><br></div></div><br><br><div class="spoiler">  <b class="spoiler_title">Gr谩ficos para el caso as铆ncrono debajo del spoiler</b> <div class="spoiler_text"><div class="spoiler">  <b class="spoiler_title">C贸digo de prueba: medici贸n del tiempo en un ciclo asincr贸nico</b> <div class="spoiler_text">  El resultado de la prueba en un intervalo de 100 ms: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pause</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">duration</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function">) =&gt;</span></span> { setInterval(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { resolve(); }, duration); }); } <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">measureTimesInAsyncLoop</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">length</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> d = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(length); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> p = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(length); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(length); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; length; i++) { d[i] = <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now(); p[i] = performance.now(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> pause(<span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { d, p } }</code> </pre> <br></div></div><br><br><img src="https://habrastorage.org/webt/lt/rr/xo/ltrrxo5m-cfdsf7kpwy_vm0d4nu.png" align="left"> <code>Date.now()</code> <br> <img src="https://habrastorage.org/webt/hp/h-/w3/hph-w3yafyxorpopqiksdnd6j5g.png" align="left"> <code>performance.now()</code> <br> <img src="https://habrastorage.org/webt/xo/or/r9/xoorr9ldh_oivoxxvbxj8yozwqc.png" align="left"> <code>audioCtx.currentTime</code> <br> <br><h3>  Borde </h3><br><img src="https://habrastorage.org/webt/3o/sz/az/3oszazaq71kxfdaftgn6v3z23xe.png"><br><div class="spoiler">  <b class="spoiler_title">estad铆sticas</b> <div class="spoiler_text">  Versi贸n del navegador: 44.17763.771.0 <br><br><h3>  Date.now (): </h3>  intervalo promedio: 24.505050505050505 ms <br>  desviaci贸n del intervalo promedio: 11.513166584195204 ms <br>  mediana del intervalo: 26 ms <br><br><h3>  performance.now (): </h3>  intervalo promedio: 24.50935757575754 ms <br>  desviaci贸n del intervalo promedio: 11.679091435527388 ms <br>  mediana del intervalo: 25.525499999999738 ms <br><br><h3>  audioCtx.currentTime: </h3>  intervalo promedio: 24.76005164944396 ms <br>  desviaci贸n del intervalo promedio: 11.311571546205316 ms <br>  mediana del intervalo: 26.121139526367187 ms <br><br></div></div><br><h3>  Firefox </h3><br><img src="https://habrastorage.org/webt/wf/4n/jn/wf4njn3z7u9uoxluprufhlbctai.png"><br><div class="spoiler">  <b class="spoiler_title">estad铆sticas</b> <div class="spoiler_text">  Versi贸n del navegador: 71.0 <br><br><h3>  Date.now (): </h3>  intervalo promedio: 1.6875 ms <br>  desviaci贸n del intervalo promedio: 0.6663410663216448 ms <br>  mediana del intervalo: 2 ms <br><br><h3>  performance.now (): </h3>  intervalo promedio: 1.7234042553191489 ms <br>  desviaci贸n del intervalo promedio: 0.6588877688171075 ms <br>  mediana del intervalo: 2 ms <br><br><h3>  audioCtx.currentTime: </h3>  intervalo promedio: 10.158730158730123 ms <br>  desviaci贸n del intervalo promedio: 1.4512471655330046 ms <br>  intervalo medio: 8.707482993195299 ms <br><br></div></div><br><h3>  Cromo </h3><br><img src="https://habrastorage.org/webt/_s/hd/uh/_shduhzpetwube_gn6kxmwyobiu.png"><br><div class="spoiler">  <b class="spoiler_title">estad铆sticas</b> <div class="spoiler_text">  Versi贸n del navegador: 79.0.3945.88 <br><br><h3>  Date.now (): </h3>  intervalo promedio: 4.585858585858586 ms <br>  desviaci贸n del intervalo promedio: 0.9102125516015199 ms <br>  mediana del intervalo: 5 ms <br><br><h3>  performance.now (): </h3>  intervalo promedio: 4.592424242424955 ms <br>  desviaci贸n del intervalo promedio: 0.719936993603155 ms <br>  Intervalo medio: 4.605000001902226 ms <br><br><h3>  audioCtx.currentTime: </h3>  intervalo promedio: 10.12648022171832 ms <br>  desviaci贸n del intervalo promedio: 1.4508887886499262 ms <br>  mediana del intervalo: 8.707482993197118 ms <br><br></div></div><br></div></div><br>  Bueno, no funcionar谩.  "Fuera", este temporizador es el m谩s inexacto.  Firefox no actualiza el valor del temporizador dentro del bucle.  Pero en general: la resoluci贸n es de 3 ms y peor y notable jitter.  Quiz谩s el valor de <code>audioCtx.currentTime</code> refleja la posici贸n en el b煤fer en anillo del controlador de la tarjeta de audio.  En otras palabras, muestra el tiempo m铆nimo que a煤n es posible retrasar de forma segura la reproducci贸n. <br><br>  Y que hacer  Despu茅s de todo, necesitamos un temporizador preciso para sincronizar con el servidor y lanzar eventos de JavaScript en la pantalla, 隆y un temporizador de audio para eventos de sonido! <br><br>  Resulta que necesita sincronizar todos los temporizadores entre s铆: <br><br><ul><li>  Cliente <code>audioCtx.currentTime</code> con el <code>performance.now()</code> cliente.now <code>performance.now()</code> en el cliente. </li><li>  Y cliente <code>performance.now()</code> con <code>performance.now()</code> del lado del servidor. </li></ul><br><h2>  Sincronizado, sincronizado </h2><br><img src="https://habrastorage.org/webt/f1/ph/o9/f1pho9gss4d40786nszfeicwrog.png" align="right">  En general, esto es bastante divertido si lo piensa: puede tener dos buenas fuentes de tiempo A y B, cada una de las cuales es muy gruesa y ruidosa en la salida (A '= A + err <sub>A</sub> ; B' = B + err <sub>B</sub> ) para que pueda incluso ser inutilizable por s铆 solo.  Pero la diferencia d entre las fuentes originales no ruidosas puede restaurarse con mucha precisi贸n. <br><br>  Dado que la distancia de tiempo real entre los relojes ideales es constante, tomando mediciones n veces, reduciremos el error de medici贸n err n veces, respectivamente.  A menos, por supuesto, que el reloj funcione a la misma velocidad. <br><br><h2>  Si no sincronizado </h2><br>  La mala noticia es que no, no van a la misma velocidad.  Y no estoy hablando de la divergencia de horas en el servidor y en el cliente, esto es comprensible y esperado.  Lo que es m谩s inesperado: <code>audioCtx.currentTime</code> divergiendo gradualmente de <code>performance.now()</code> .  Est谩 dentro del cliente.  Es posible que no nos demos cuenta, pero a veces, bajo carga, el sistema de audio puede no tragar una peque帽a pieza de datos y (al contrario de la naturaleza del b煤fer en anillo) el tiempo de audio cambiar谩 en relaci贸n con el tiempo del sistema.  Esto no ocurre tan raramente, simplemente no afecta a muchas personas: pero si, por ejemplo, lanzas dos videos de YouTube al mismo tiempo simult谩neamente en diferentes computadoras, no es un hecho que dejen de reproducirse al mismo tiempo.  Y el punto, por supuesto, no est谩 en la publicidad. <br><br>  Por lo tanto, para un funcionamiento estable y sincr贸nico.  Necesitamos revisar <i>peri贸dicamente</i> todos los relojes entre s铆, utilizando la hora del servidor, como referencia.  Y luego aparece el equilibrio en cu谩ntas mediciones usar para promediar: cuanto m谩s, m谩s preciso, pero mayor es la posibilidad de que un salto brusco en <code>audioCtx.currentTime</code> caiga en la ventana de tiempo en la que filtramos los valores.  Luego, si, por ejemplo, usamos la ventana de minutos, todos los minutos tendremos el tiempo transcurrido.  La elecci贸n de los filtros es amplia: <a href="https://ru.wikipedia.org/wiki/%25D0%25AD%25D0%25BA%25D1%2581%25D0%25BF%25D0%25BE%25D0%25BD%25D0%25B5%25D0%25BD%25D1%2586%25D0%25B8%25D0%25B0%25D0%25BB%25D1%258C%25D0%25BD%25D0%25BE%25D0%25B5_%25D1%2581%25D0%25B3%25D0%25BB%25D0%25B0%25D0%25B6%25D0%25B8%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5" rel="nofollow">exponencial</a> , <a href="https://ru.wikipedia.org/wiki/%25D0%259C%25D0%25B5%25D0%25B4%25D0%25B8%25D0%25B0%25D0%25BD%25D0%25B0_(%25D1%2581%25D1%2582%25D0%25B0%25D1%2582%25D0%25B8%25D1%2581%25D1%2582%25D0%25B8%25D0%25BA%25D0%25B0)" rel="nofollow">mediana</a> , <a href="https://ru.wikipedia.org/wiki/%25D0%25A4%25D0%25B8%25D0%25BB%25D1%258C%25D1%2582%25D1%2580_%25D0%259A%25D0%25B0%25D0%25BB%25D0%25BC%25D0%25B0%25D0%25BD%25D0%25B0" rel="nofollow">filtro de Kalman</a> , etc.  Pero esta compensaci贸n es en cualquier caso. <br><br><h2>  Ventana de tiempo </h2><br>  En el caso de sincronizar <code>audioCtx.currentTime</code> con <code>performance.now()</code> , en un bucle as铆ncrono, para no interferir con la interfaz de usuario, podemos tomar una medida, digamos, 100 ms. <br>  Suponga que el error de medici贸n err = errA + errB = 1 + 3 = 4 ms <br>  En consecuencia, en 1 segundo podemos reducirlo a 0,4 ms, y en 10 segundos a 0,04 ms.  Una mejora adicional del resultado no tiene sentido, y una buena ventana para el filtrado ser谩: 1 - 10 segundos. <br><br>  En el caso de la sincronizaci贸n de red, los retrasos y los errores ya son mucho m谩s significativos, pero no hay un salto repentino en el tiempo, como es el caso de <code>audioCtx.currentTime</code> .  Y puede permitirse acumular estad铆sticas realmente excelentes.  Despu茅s de todo, err para ping puede ser de hasta 500 ms.  Y las medidas en s铆 no podemos hacer tan a menudo. <br><br>  En este punto, propongo parar.  Si alguien estaba interesado, estar茅 encantado de decirle c贸mo "dibujar el resto de la lechuza".  Pero como parte de la historia sobre los temporizadores, creo que mi historia ha terminado. <br><br>  Y quiero compartir lo que obtuve.  De todos modos, el a帽o nuevo. <br><br><h2>  Que paso </h2><br>  Descargo de responsabilidad: T茅cnicamente, este es un sitio de relaciones p煤blicas en Habr茅, pero este es un proyecto de mascotas de c贸digo abierto completamente sin fines de lucro en el que prometo nunca: poner anuncios o ganar dinero de otra manera.  Por el contrario, he recaudado m谩s casos de mi dinero ahora para sobrevivir a un posible efecto de habra.  Por lo tanto, por favor, buena gente, no me rompan y no me alcancen.  Todo esto es puramente divertido. <br><br>  Feliz a帽o nuevo, Habr! <br><br><hr><br><h3>  <a href="http://habr.snowtime.fun/" rel="nofollow">snowtime.fun</a> </h3>  Puede girar las perillas y controlar la visualizaci贸n, la m煤sica y los efectos de audio.  Si tiene una tarjeta de video normal, vaya a la configuraci贸n y configure el n煤mero de part铆culas al 100%. <br><br>  Requiere WebAudio y WebGL. <br><br><hr><br><br>  <b>UPD:</b> no funciona en Safari con macOS Mojave.  Desafortunadamente, no hay forma de averiguar r谩pidamente qu茅 est谩 sucediendo, debido a la ausencia de este Safari en s铆.  iOS parece estar funcionando. <br><br>  <b>UPD2:</b> Si <a href="http://snowtime.fun/" rel="nofollow">snowtime.fun</a> y <a href="http://web.snowtime.fun/" rel="nofollow">web.snowtime.fun</a> no responden, pruebe el nuevo subdominio <a href="http://habr.snowtime.fun/" rel="nofollow"><b>habr</b> .snowtime.fun</a> .  Traslad贸 el servidor a otro centro de datos, y la antigua IP se almacen贸 en cach茅 en DNS, <code>expire=1w</code> .  :( <br><br>  Repositorio: <a href="https://bitbucket.org/barkalov/snowtime.fun/src" rel="nofollow">bitbucket</a> <br>  Al escribir este art铆culo, se utilizaron ilustraciones de <a href="http://www.freepik.com/" rel="nofollow">macrovector / Freepik</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/482168/">https://habr.com/ru/post/482168/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../482154/index.html">驴Por qu茅 limitar la herencia con final?</a></li>
<li><a href="../482156/index.html">Entrevista con Will Kurt sobre su nuevo libro, Bayesian Statistics - It's Great</a></li>
<li><a href="../482158/index.html">Conoce a Ember Octane</a></li>
<li><a href="../482162/index.html">Los matem谩ticos han encontrado un patr贸n, entendiendo c贸mo evitar su aparici贸n.</a></li>
<li><a href="../482166/index.html">Servicio de adiestramiento canino en el aeropuerto: ya est谩 olisqueado</a></li>
<li><a href="../482170/index.html">Procesador de guerras. La historia de la liebre azul y la tortuga roja</a></li>
<li><a href="../482176/index.html">驴C贸mo fue la conferencia @Kubernetes el 29 de noviembre: video y resultados</a></li>
<li><a href="../482178/index.html">La historia de un estudiante coreano que recibi贸 un premio del ministerio por un sistema de monitoreo de colas</a></li>
<li><a href="../482182/index.html">驴Qu茅 problemas tendr铆a si luchara por el equilibrio de g茅nero en TI?</a></li>
<li><a href="../482194/index.html">Generar autom谩ticamente y llenar elementos de configuraci贸n de dispositivos de red con Nornir</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>