<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👿 🚒 🧒🏼 如何在本体网络上为WebAssembly编写智能合约？ 第2部分：C ++ 🤬 👨‍👨‍👦‍👦 👨🏿‍🔬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在本文中，我们将看两个如何使用基于本体区块链网络的WASM用C ++编写智能合约的示例。 今天，在测试模式下稳定运行了几个月之后， Ontology在主网络上启动了WASM ，它可以轻松，以较低的成本将具有复杂业务逻辑的dApp合同转移到区块链上，从而显着丰富了dApp生态系统。 

 本体论Was...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>如何在本体网络上为WebAssembly编写智能合约？ 第2部分：C ++</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/473784/"><img src="https://habrastorage.org/getpro/habr/post_images/3e1/ec5/4dd/3e1ec54ddc0f1d35cad05f7f2b6e600e.png" alt="图片"><br><br> 在本文中，我们将看两个如何使用基于本体<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">区块</a>链网络的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">WASM</a>用C ++编写智能合约的示例。 今天，在测试模式下稳定运行了几个月之后， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Ontology</a>在主网络上<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">启动了WASM</a> ，它可以轻松，以较低的成本将具有复杂业务逻辑的dApp合同转移到区块链上，从而显着丰富了dApp生态系统。 <br><br> 本体论Wasm还支持使用Rust语言创建智能合约，您可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在此处</a>阅读有关内容。 <br><br> 以下是智能合约的两个示例：首先，写下“ Hello world！”。 然后创建一个虚拟货币信封，可以将其作为礼物发送给朋友。 <br><br><h2> 使用C ++开发WASM合同 </h2><br><a name="habracut"></a><br><h3> 例子1. Hello World </h3><br> 让我们从Hello World开始： <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;ontiolib/ontio.hpp&gt; #include&lt;stdio.h&gt; using namespace ontio; class hello:public contract { public: using contract::contract: void sayHello(){ printf("hello world!"); } }; ONTIO_DISPATCH(hello, (sayHello));</span></span></span></span></code> </pre> <br><h3> 合同创建 </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Ontology Wasm CDT</a>编译器包含一个入口点和解析参数，因此开发人员无需重新定义输入方法。 此外，要编写服务逻辑，您可以调用智能合约的API方法。 <br><br><pre> <code class="cpp hljs">ONTIO_DISPATCH(hello, (sayHello));</code> </pre> <br> 在上面的示例中，到目前为止，我们仅支持sayHello： <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"hello world!"</span></span>);</code> </pre> <br>  “你好，世界！” 将显示在调试节点日志中。 直接编写智能合约时，printf仅可用于调试，因为智能合约本身包含更多功能命令。 <br><br><h3> 智能合约API </h3><br> 本体论Wasm提供以下API与服务器区块链进行交互： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d29/dad/66d/d29dad66d40c938e872179cc3487172e.png" alt="图片"><br><br><h2> 示例2：钱信封 </h2><br> 现在，让我们来看一个使用Wasm智能合约API的更复杂的示例。 <br><br> 在此示例中，我们将编写一个虚拟货币信封，红色信封（hongbao）的类似物是中国微信使者的流行功能，它使您可以在聊天中向朋友汇款。 用户收到一个红色信封形式的消息，打开该消息，这笔钱将自动记入帐户余额中。 <br><br> 作为智能合约的一部分，用户可以使用该合约使用虚拟货币信封将ONT，ONG或OEP-4令牌发送给他们的朋友，然后朋友可以将令牌转移到他们的区块链钱包中。 <br><br><h3> 准备创建合同 </h3><br> 首先，创建源合同文件，并将其命名为redEnvelope.cpp。 接下来，我们需要此合同的三个API： <br><br><ul><li>  <i>createRedEnvelope</i> ：创建一个钱信封 </li><li>  <i>queryEnvelope</i> ：请求信封信息 </li><li>  <i>ClaimEnvelope</i> ：打开一个信封并收到钱 </li></ul><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;ontiolib/ontio.hpp&gt; using namespace ontio; class redEnvlope: public contract{ } ONTIO_DISPATCH(redEnvlope, (createRedEnvlope)(queryEnvlope)(claimEnvelope));</span></span></span></span></code> </pre> <br> 现在我们需要保存键值。 在智能合约中，数据作为键值存储在合约的上下文中，我们需要在KEY数据中添加前缀以用于后续请求。 <br><br> 在下面，我们定义了三个将要使用的前缀： <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> rePrefix = <span class="hljs-string"><span class="hljs-string">"RE_PREFIX_"</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> sentPrefix = <span class="hljs-string"><span class="hljs-string">"SENT_COUNT_"</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> claimPrefix = <span class="hljs-string"><span class="hljs-string">"CLAIM_PREFIX_"</span></span>;</code> </pre><br> 由于合同同时支持ONT和ONG这两个本体令牌，因此我们可以提前确定其合同地址。 与标准智能合约不同，Ontology自己的合约地址是固定的，并且不是从合约的哈希中得出的。 <br><br><pre> <code class="cpp hljs">address ONTAddress = {<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>}; address ONGAddress = {<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>};</code> </pre> <br> 接下来，您需要在合同中保存有关已使用令牌的信息：合同令牌的地址，信封的总数和信封的数量。 <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">receiveRecord</span></span></span><span class="hljs-class">{</span></span> address account; <span class="hljs-comment"><span class="hljs-comment">//User address asset amount; //Received amount ONTLIB_SERIALIZE(receiveRecord,(account)(amount)) }; struct envlopeStruct{ address tokenAddress; //Token asset address asset totalAmount; //Total amount asset totalPackageCount; //Total number of red envelope asset remainAmount; //Remaining amount asset remainPackageCount; //Remaining number of red envelope std::vector&lt;struct receiveRecord&gt; records; //Received records ONTLIB_SERIALIZE( envlopeStruct, (tokenAddress)(totalAmount)(totalPackageCount)(remainAmount)(remainPackageCount)(records) ) };</span></span></code> </pre> <br> 以下是本体论Wasm CDT定义的宏操作，该操作用于数据结构化之前的序列化。 <br><br><pre> <code class="cpp hljs">ONTLIB_SERIALIZE(receiveRecord,(account)(amount))</code> </pre> <br><h3> 创建信封 </h3><br> 现在，我们已经完成了必要的准备工作，我们将开始API逻辑的开发。 <br><br>  1.在创建货币信封时，必须指出所有者的地址，信封的数量和数量以及代币的地址： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createRedEnvlope</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(address owner,asset packcount, asset amount,address tokenAddr )</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  2.检查所有者的签名，否则我们将回滚（回滚交易）并退出： <br><br><pre> <code class="cpp hljs">ontio_assert(check_witness(owner),<span class="hljs-string"><span class="hljs-string">"checkwitness failed"</span></span>);</code> </pre> <br>  <i>注意</i> ：ontio_assert（expr，errormsg）：false expr返回错误并退出合同。 <br><br>  3.如果在信封中使用了ONT令牌，请务必记住，ONT不会分段（至少1个ONT）。 然后，货币信封的总金额必须大于或等于令牌数量，以确保每个信封中至少有1个ONT： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isONTToken(tokenAddr)){ ontio_assert(amount &gt;= packcount,<span class="hljs-string"><span class="hljs-string">"ont amount should greater than packcount"</span></span>); }</code> </pre> <br>  4.接下来，我们为信封持有人确定他发送的货币信封总数： <br><br><pre> <code class="cpp hljs">key sentkey = make_key(sentPrefix,owner.tohexstring()); asset sentcount = <span class="hljs-number"><span class="hljs-number">0</span></span>; storage_get(sentkey,sentcount); sentcount += <span class="hljs-number"><span class="hljs-number">1</span></span>; storage_put(sentkey,sentcount);</code> </pre> <br>  5.生成信封的哈希-标记该信封的标识符： <br><br><pre> <code class="cpp hljs">H256 hash ; hash256(make_key(owner,sentcount),hash) ; key rekey = make_key(rePrefix,hash256ToHexstring(hash));</code> </pre> <br>  6.我们将代币转换为合同。 我们使用self_address（）命令找出当前正在执行的合同的地址，然后根据令牌的类型将分配的令牌数量转移到合同中： <br><br><pre> <code class="cpp hljs">address selfaddr = self_address(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isONTToken(tokenAddr)){ <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> result = ont::transfer(owner,selfaddr ,amount); ontio_assert(result,<span class="hljs-string"><span class="hljs-string">"transfer native token failed!"</span></span>); }<span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isONGToken(tokenAddr)){ <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> result = ong::transfer(owner,selfaddr ,amount); ontio_assert(result,<span class="hljs-string"><span class="hljs-string">"transfer native token failed!"</span></span>); }<span class="hljs-keyword"><span class="hljs-keyword">else</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt; params = pack(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>(<span class="hljs-string"><span class="hljs-string">"transfer"</span></span>),owner,selfaddr,amount); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> res; call_contract(tokenAddr,params, res ); ontio_assert(res,<span class="hljs-string"><span class="hljs-string">"transfer oep4 token failed!"</span></span>); }</code> </pre><br>  <u>注1：</u>对于ONT和ONG，Ontology Wasm CDT提供了ont :: transfer API来传输令牌；  OEP-4令牌必须使用常规的跨合同呼叫方法发送。 <br><br>  <u>注意2：</u>合约地址可以像普通的钱包地址一样接受任何类型的令牌。 但是，合同地址是由编译后的二进制哈希生成的，因此没有对应的私钥，因此无法使用合同令牌。 如果尚未设置私钥，则将无法管理这些令牌。 <br><br>  7.将有关合同的信息保存在数据仓库中： <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">envlopeStruct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">es</span></span></span><span class="hljs-class"> ;</span></span> es.tokenAddress = tokenAddr; es.totalAmount = amount; es.totalPackageCount = packcount; es.remainAmount = amount; es.remainPackageCount = packcount; es.records = {}; storage_put(rekey, es);</code> </pre> <br>  8.发送有关信封创建的通知。 这是用于调用智能合约的异步过程，该合约还将发送有关执行结果的通知。 执行格式可以由合同的作者确定。 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buffer [<span class="hljs-number"><span class="hljs-number">100</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(buffer, <span class="hljs-string"><span class="hljs-string">"{\"states\":[\"%s\", \"%s\", \"%s\"]}"</span></span>,<span class="hljs-string"><span class="hljs-string">"createEnvlope"</span></span>,owner.tohexstring().c_str(),hash256ToHexstring(hash).c_str()); notify(buffer); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>;</code> </pre> <br> 万岁，钱袋子已经快准备好了。 现在，让我们看看如何请求信封信息。 <br><br><h3> 查询信封（查询 </h3><br> 请求的逻辑很简单，您只需要从数据存储中获取信息和格式，然后输出： <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">queryEnvlope</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hash)</span></span></span></span>{ key rekey = make_key(rePrefix,hash); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">envlopeStruct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">es</span></span></span><span class="hljs-class">;</span></span> storage_get(rekey,es); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> formatEnvlope(es); }</code> </pre> <br>  <u>注意：</u>对于只读智能合约操作（例如查询），您可以通过pre-exec查看结果。 与常规合同通话不同，高级执行人员不需要钱包签名，因此不需要ONG中的佣金。 完成此操作后，如果其他用户有信封哈希（信封ID），则现在可以申请信封。 <br><br><h3> 接收信封 </h3><br> 现在，在此阶段，我们已经成功地将令牌转移到了智能合约中，以便您的朋友可以在信封中成功申领份额，您需要向他们发送信封标识符（哈希）。 <br><br>  1.要收到信封，您必须输入帐户地址和信封的哈希值： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">claimEnvlope</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(address account, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hash)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  2.接下来，合同将验证您的帐户签名，以确保您是帐户所有者。 每个帐户只能申请一次信封： <br><br><pre> <code class="cpp hljs">ontio_assert(check_witness(account),<span class="hljs-string"><span class="hljs-string">"checkwitness failed"</span></span>); key claimkey = make_key(claimPrefix,hash,account); asset claimed = <span class="hljs-number"><span class="hljs-number">0</span></span> ; storage_get(claimkey,claimed); ontio_assert(claimed == <span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-string"><span class="hljs-string">"you have claimed this envlope!"</span></span>);</code> </pre><br>  3.根据从商店收到的哈希信息检查是否收到信封： <br><br><pre> <code class="cpp hljs">key rekey = make_key(rePrefix,hash); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">envlopeStruct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">es</span></span></span><span class="hljs-class">;</span></span> storage_get(rekey,es); ontio_assert(es.remainAmount &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"the envlope has been claimed over!"</span></span>); ontio_assert(es.remainPackageCount &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"the envlope has been claimed over!"</span></span>);</code> </pre> <br>  4.创建索赔记录： <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">receiveRecord</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">record</span></span></span><span class="hljs-class"> ;</span></span> record.account = account; asset claimAmount = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br>  5.计算每个信封申请人的金额。 <br> 对于最后一个参与者，确定剩余的数量，对于其他参与者，声明的数量由当前块的哈希值和有关信封的当前信息计算出的随机数确定： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (es.remainPackageCount == <span class="hljs-number"><span class="hljs-number">1</span></span>){ claimAmount = es.remainAmount; record.amount = claimAmount; }<span class="hljs-keyword"><span class="hljs-keyword">else</span></span>{ H256 random = current_blockhash() ; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> part[<span class="hljs-number"><span class="hljs-number">8</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>(part,&amp;random,<span class="hljs-number"><span class="hljs-number">8</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> random_num = *(<span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>*)part; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> percent = random_num % <span class="hljs-number"><span class="hljs-number">100</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>; claimAmount = es.remainAmount * percent / <span class="hljs-number"><span class="hljs-number">100</span></span>; <span class="hljs-comment"><span class="hljs-comment">//ont case if (claimAmount == 0){ claimAmount = 1; }else if(isONTToken(es.tokenAddress)){ if ( (es.remainAmount - claimAmount) &lt; (es.remainPackageCount - 1)){ claimAmount = es.remainAmount - es.remainPackageCount + 1; } } record.amount = claimAmount; } es.remainAmount -= claimAmount; es.remainPackageCount -= 1; es.records.push_back(record);</span></span></code> </pre> <br><h3>  6.贷记资金 </h3><br> 根据计算结果，将相应数量的代币转移到信封申请人的账户中： <br><br><pre> <code class="cpp hljs">address selfaddr = self_address(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isONTToken(es.tokenAddress)){ <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> result = ont::transfer(selfaddr,account ,claimAmount); ontio_assert(result,<span class="hljs-string"><span class="hljs-string">"transfer ont token failed!"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isONGToken(es.tokenAddress)){ <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> result = ong::transfer(selfaddr,account ,claimAmount); ontio_assert(result,<span class="hljs-string"><span class="hljs-string">"transfer ong token failed!"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt; params = pack(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>(<span class="hljs-string"><span class="hljs-string">"transfer"</span></span>),selfaddr,account,claimAmount); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> res = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; call_contract(es.tokenAddress,params, res ); ontio_assert(res,<span class="hljs-string"><span class="hljs-string">"transfer oep4 token failed!"</span></span>); }</code> </pre><br>  7.我们将记下有关资金接收的信息以及有关保管箱中信封的最新信息，并发送有关合同履行的通知： <br><br><pre> <code class="cpp hljs">storage_put(claimkey,claimAmount); storage_put(rekey,es); <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buffer [<span class="hljs-number"><span class="hljs-number">100</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(buffer, <span class="hljs-string"><span class="hljs-string">"{\"states\":[\"%s\",\"%s\",\"%s\",\"%lld\"]}"</span></span>,<span class="hljs-string"><span class="hljs-string">"claimEnvlope"</span></span>,hash.c_str(),account.tohexstring().c_str(),claimAmount); notify(buffer); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>;</code> </pre><br> 如上所述，该合同可以通过ClaimEnvelope API从合同中发送令牌。 这样就可以确保令牌在信封中时的安全性，因为没有人不能在没有满足必要要求的情况下提取资产。 <br><br> 做完了！ 您编写了第一个智能合约。 完整的合同代码可以在GitHub上<a href="">找到</a> 。 <br><br><h3> 合同测试 </h3><br> 有两种验证合同的方法： <br><br><ol><li> 使用<a href="">CLI</a> </li><li> 使用<a href="">Golang SDK</a> </li></ol><br><h2> 结论 </h2><br> 在本文中，我们讨论了如何使用区块链API为Ontolgy Wasm编写智能合约。 仍然需要解决隐私问题，以便将智能合约转变为成熟的产品。 在代码的这一阶段，任何人都可以通过跟踪合同记录来获得红色信封的哈希，这意味着任何人都可以要求获得信封中的份额。 这个问题可以简单地解决-我们定义了一个可以在创建信封时申请的帐户列表。 如果需要，也可以测试此功能。 <br><br><hr><br> 从$ 20,000获得dApp开发<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的</a>本体<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">资助</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">申请</a>本体学生人才计划 <br><br><hr><br> 您是开发人员吗？ 加入我们的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Discord</a>技术社区。 此外，请访问我们网站上<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的开发人员中心</a> ，您可以在其中找到开发人员工具，文档等。 <br><br><h4> 本体论 </h4><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">本体网站</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GitHub</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">不和谐</a> </li><li> 电报<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">英语</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">俄语</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Twitter</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Reddit</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN473784/">https://habr.com/ru/post/zh-CN473784/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN473770/index.html">大量Python代码的静态分析：Instagram经验。 第二部分</a></li>
<li><a href="../zh-CN473774/index.html">DF Cloud上的安全云</a></li>
<li><a href="../zh-CN473776/index.html">通过Asp core + VueJS的示例统一验证规则</a></li>
<li><a href="../zh-CN473778/index.html">图像优化：如何使用Google的Vision AI理解图像排名原则</a></li>
<li><a href="../zh-CN473780/index.html">4K视频中的快速轮廓检测：颜色和复杂形状</a></li>
<li><a href="../zh-CN473786/index.html">里加黑客马拉松的注册工作即将结束。 奖-PhysTech短期培训</a></li>
<li><a href="../zh-CN473788/index.html">蛋白质发现现代生物学的未知方面</a></li>
<li><a href="../zh-CN473790/index.html">3d图形中的样条线，最自动化的选项</a></li>
<li><a href="../zh-CN473794/index.html">移动网络钓鱼-无尽的威胁</a></li>
<li><a href="../zh-CN473796/index.html">光纤HDMI延长器。 300米</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>