<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚òòÔ∏è üï∂Ô∏è ü§∂üèæ Grokay DLR üë®üèæ‚Äç‚öñÔ∏è ü§∂ üíª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vorwort des √úbersetzers 

 Dies ist eher eine kostenlose Nacherz√§hlung, keine √úbersetzung. Ich habe in diesen Artikel nur diejenigen Teile des Origina...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Grokay DLR</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/469075/"> <i><b>Vorwort des √úbersetzers</b></i> <i><br><br></i>  <i>Dies ist eher eine kostenlose Nacherz√§hlung, keine √úbersetzung.</i>  <i>Ich habe in diesen Artikel nur diejenigen Teile des Originals aufgenommen, die in direktem Zusammenhang mit den internen Mechanismen des DLR stehen oder wichtige Ideen erl√§utern.</i>  <i>Notizen werden in eckigen Klammern eingeschlossen.</i> <br><br>  Viele .NET-Entwickler haben von Dynamic Language Runtime (DLR) geh√∂rt, wissen aber fast nichts dar√ºber.  Entwickler, die in Sprachen wie C # oder Visual Basic schreiben, vermeiden dynamische Tippsprachen aus Angst vor historisch verwandten Skalierbarkeitsproblemen.  Sie sind auch besorgt dar√ºber, dass Sprachen wie Python oder Ruby beim Kompilieren keine Typpr√ºfung durchf√ºhren, was zu Laufzeitfehlern f√ºhren kann, die schwer zu finden und zu beheben sind.  Dies sind begr√ºndete Bef√ºrchtungen, die erkl√§ren k√∂nnten, warum das DLR auch zwei Jahre nach der offiziellen Ver√∂ffentlichung bei der Mehrheit der .NET-Entwickler nicht beliebt ist <i>[der Artikel ist ziemlich alt, aber seitdem hat sich nichts ge√§ndert]</i> .  Schlie√ülich sollte jede .NET- <i>Laufzeit</i> , deren Name die W√∂rter <i>Dynamisch</i> und <i>Sprache enth√§lt, ausschlie√ülich</i> so konzipiert sein, dass sie Sprachen wie Python unterst√ºtzt, oder? <br><br>  Langsam fahren.  W√§hrend das DLR wirklich darauf ausgelegt war, die Iron-Implementierung von Python und Ruby in .NET Framework zu unterst√ºtzen, bietet seine Architektur viel tiefere Abstraktionen. <br><br><img src="https://habrastorage.org/webt/9p/co/0r/9pco0rjy7-sqeqb0hzgdngobjky.png"><br><a name="habracut"></a><br>  Unter der Haube bietet das DLR eine Vielzahl von Schnittstellen f√ºr die prozess√ºbergreifende Kommunikation [Inter-Process Communication (IPC)].  Im Laufe der Jahre haben Entwickler viele Microsoft-Tools f√ºr die Interaktion zwischen Anwendungen gesehen: DDE, DCOM, ActiveX, .Net Remoting, WCF, OData.  Diese Liste kann lange dauern.  Dies ist eine fast endlose Parade von Akronymen, von denen jedes eine Technologie darstellt, die verspricht, dass es in diesem Jahr noch einfacher sein wird, Daten auszutauschen oder Remote-Code aufzurufen als zuvor. <br><br><h2>  Sprache der Sprachen </h2><br>  Als ich Jim Hugunin zum ersten Mal √ºber das DLR sprechen h√∂rte, √ºberraschte mich seine Rede.  Jim erstellte eine Python-Implementierung f√ºr die Java Virtual Machine (JVM) namens Jython.  Kurz vor der Show trat er Microsoft bei, um IronPython f√ºr .NET zu erstellen.  Aufgrund seines Hintergrunds erwartete ich, dass er sich auf die Sprache konzentrieren w√ºrde, aber stattdessen sprach Jim fast die ganze Zeit √ºber abstruse Dinge wie Ausdrucksb√§ume, dynamischer Anrufversand und Anruf-Caching-Mechanismen.  Jim beschrieb eine Reihe von Laufzeitkompilierungsdiensten, mit denen zwei beliebige Sprachen praktisch ohne Leistungseinbu√üen miteinander interagieren konnten. <br><br>  W√§hrend dieser Rede schrieb ich einen Begriff auf, der in meinem Kopf auftauchte, als ich h√∂rte, wie Jim die DLR-Architektur nacherz√§hlte: die Sprache der Sprachen.  Vier Jahre sp√§ter kennzeichnet dieser Spitzname das DLR noch sehr genau.  Nachdem ich jedoch praktische Erfahrungen gesammelt hatte, wurde mir klar, dass es beim DLR nicht nur um Sprachkompatibilit√§t geht.  Dank der Unterst√ºtzung dynamischer Typen in C # und Visual Basic kann das DLR als Gateway von unseren bevorzugten .NET-Sprachen zu Daten und Code in jedem Remote-System fungieren, unabh√§ngig davon, welche Art von Ausr√ºstung oder Software das letztere verwendet. <br><br><img src="https://habrastorage.org/webt/sp/l2/k3/spl2k3kcuitbvqg151r1wfx_zzc.png"><br><br>  Um die Idee hinter dem DLR zu verstehen, einem integrierten Mechanismus in der IPC-Sprache, beginnen wir mit einem Beispiel, das nichts mit dynamischer Programmierung zu tun hat.  Stellen Sie sich zwei Computersysteme vor: eines als Initiator und das zweite als Zielsystem.  Der Initiator muss die Funktion <b>foo</b> auf dem Zielsystem ausf√ºhren, dort einen bestimmten Parametersatz √ºbergeben und die Ergebnisse abrufen.  Nachdem das Zielsystem erkannt wurde, muss der Initiator alle f√ºr die Ausf√ºhrung der Funktion erforderlichen Informationen in einem f√ºr ihn verst√§ndlichen Format bereitstellen.  Diese Informationen enthalten mindestens den Namen der Funktion und die √ºbergebenen Parameter.  Nach dem Entpacken der Anforderung und dem √úberpr√ºfen der Parameter f√ºhrt das Zielsystem die Funktion foo aus.  Danach sollte das Ergebnis einschlie√ülich aller w√§hrend der Ausf√ºhrung aufgetretenen Fehler gepackt und an den Initiator zur√ºckgesendet werden.  Schlie√ülich sollte der Initiator in der Lage sein, die Ergebnisse zu entpacken und das Ziel zu benachrichtigen.  Dieses Anforderungs- / Antwortmuster ist weit verbreitet und beschreibt auf hoher Ebene die Funktionsweise fast aller IPC-Mechanismen. <br><br><h3>  Dynamisches Metaobjekt </h3><br>  Um zu verstehen, wie das DLR das dargestellte Muster implementiert, schauen wir uns eine der zentralen Klassen des DLR an: <b>DynamicMetaObject</b> .  Wir beginnen mit der Untersuchung von drei der zw√∂lf Schl√ºsselmethoden dieses Typs: <br><br><ol><li>  BindCreateInstance - Erstellt oder aktiviert ein Objekt </li><li>  BindInvokeMember - Ruft die gekapselte Methode auf </li><li>  BindInvoke - Objektausf√ºhrung (als Funktion) </li></ol><br>  Wenn Sie eine Methode auf einem Remote-System ausf√ºhren m√ºssen, m√ºssen Sie zuerst eine Instanz des Typs erstellen.  Nat√ºrlich sind nicht alle Systeme objektorientiert, daher kann der Begriff ‚ÄûInstanz‚Äú eine Metapher sein.  Tats√§chlich kann der von uns ben√∂tigte Dienst als Objektpool oder als Singleton implementiert werden, sodass die Begriffe "Aktivierung" oder "Verbindung" mit demselben Recht wie "Instanz" verwendet werden k√∂nnen. <br><br>  Andere Frameworks folgen demselben Muster.  Beispielsweise bietet COM eine <b>CoCreateInstance-</b> Funktion zum Erstellen von Objekten.  In .NET Remoting k√∂nnen Sie die <b>CreateInstance-</b> Methode aus der <b>System.Activator-</b> Klasse verwenden.  DLR <b>DynamicMetaObject</b> bietet eine <b>BindCreateInstance</b> f√ºr √§hnliche Zwecke. <br><br>  Nach der Verwendung der <b>BindCreateInstance-</b> Methode kann ein erstelltes <b>Objekt</b> ein Typ sein, der mehrere Methoden <b>verf√ºgbar</b> macht.  Die <b>Metaobject-Methode</b> BindInvokeMember <b>wird</b> verwendet, um eine Operation zu binden, die eine Funktion aufrufen kann.  In der obigen Abbildung kann die Zeichenfolge foo als Parameter √ºbergeben werden, um dem Ordner anzuzeigen, dass eine Methode mit diesem Namen aufgerufen werden soll.  Zus√§tzlich sind Informationen √ºber die Anzahl der Argumente, ihre Namen und ein spezielles Flag enthalten, das dem Ordner anzeigt, ob es m√∂glich ist, Gro√ü- und Kleinschreibung bei der Suche nach einem geeigneten benannten Element zu ignorieren.  Schlie√ülich wird bei nicht allen Sprachen zwischen Gro√ü- und Kleinschreibung unterschieden. <br><br>  Wenn <i>etwas, das</i> von <b>BindCreateInstance zur√ºckgegeben</b> wird, nur eine Funktion (oder ein Delegat) ist, wird die BindInvoke-Methode verwendet.  Schauen wir uns zur Verdeutlichung des Bildes den folgenden kleinen dynamischen Code an: <br><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">delegate</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IntWriter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">dynamic</span></span> Write = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IntWriter(Console.WriteLine); Write(<span class="hljs-number"><span class="hljs-number">5</span></span>); }</code> </pre> <br>  Dieser Code ist nicht der beste Weg, um die Nummer 5 auf der Konsole zu drucken.  Ein guter Entwickler wird niemals etwas so Verschwenderisches verwenden.  Dieser Code veranschaulicht jedoch die Verwendung einer dynamischen Variablen, deren Wert ein Delegat ist, der als Funktion verwendet werden kann.  Wenn der Delegatentyp die <b>IDynamicMetaObjectProvider-</b> Schnittstelle implementiert, wird die <b>BindInvoke-</b> Methode von <b>DynamicMetaObject</b> verwendet, um die Operation an die eigentliche Arbeit zu binden.  Dies liegt daran, dass der Compiler erkennt, dass das dynamische <b>Write-</b> Objekt <i>syntaktisch</i> als Funktion verwendet wird.  Betrachten Sie nun einen weiteren Code, um zu verstehen, wann der Compiler <b>BindInvokeMember</b> generiert: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Writer</span></span> : <span class="hljs-title"><span class="hljs-title">IDynamicMetaObjectProvider</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Write</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n</span></span></span><span class="hljs-function">)</span></span> { Console.WriteLine(n); } <span class="hljs-comment"><span class="hljs-comment">//    } void Main() { dynamic Writer = new Writer(); Writer.Write(7); }</span></span></code> </pre><br>  Ich werde die Implementierung der Schnittstelle in diesem kleinen Beispiel weglassen, da viel Code erforderlich ist, um dies korrekt zu demonstrieren.  In diesem verk√ºrzten Beispiel implementieren wir ein dynamisches Metaobjekt mit nur wenigen Codezeilen. <br><br>  Es ist wichtig zu verstehen, dass der Compiler erkennt, dass <b>Writer.Write (7)</b> eine Elementzugriffsoperation ist.  Was wir in C # normalerweise als "Punktoperator" bezeichnen, wird formal als "Typmitgliedszugriffsoperator" bezeichnet.  Der in diesem Fall vom Compiler generierte DLR-Code ruft schlie√ülich <b>BindInvokeMember auf</b> , in das er die Schreibzeichenfolge und die Parameternummer 7 an die Operation <b>√ºbergibt</b> , die den Aufruf <b>ausf√ºhren</b> kann.  Kurz gesagt, <b>BindInvoke wird</b> verwendet, um ein dynamisches Objekt als Funktion <b>aufzurufen</b> , w√§hrend <b>BindInvokeMember</b> verwendet wird, um eine Methode als Element eines dynamischen Objekts aufzurufen. <br><br><h3>  Greifen Sie √ºber DynamicMetaObject auf Eigenschaften zu </h3><br>  Aus den obigen Beispielen ist ersichtlich, dass der Compiler die Sprachsyntax verwendet, um zu bestimmen, welche DLR-Bindungsoperationen ausgef√ºhrt werden sollen.  Wenn Sie Visual Basic zum Arbeiten mit dynamischen Objekten verwenden, wird dessen Semantik verwendet.  Der Zugriffsoperator (Punkt) wird nat√ºrlich nicht nur f√ºr den Zugriff auf Methoden ben√∂tigt.  Sie k√∂nnen damit auf Eigenschaften zugreifen.  Das DLR-Metaobjekt bietet drei Methoden f√ºr den Zugriff auf die Eigenschaften dynamischer Objekte: <br><br><ol><li>  BindGetMember - Liefert den Eigenschaftswert </li><li>  BindSetMember - Eigenschaftswert festlegen </li><li>  BindDeleteMember - l√∂scht ein Element </li></ol><br>  Der Zweck von <b>BindGetMember</b> und <b>BindSetMember</b> sollte offensichtlich sein.  Besonders jetzt, wo Sie wissen, wie sie sich auf die Funktionsweise von .NET mit Eigenschaften beziehen.  Wenn der Compiler die <i>get</i> ("read") - Eigenschaften eines dynamischen Objekts berechnet, verwendet er einen Aufruf von <b>BindGetMember</b> .  Wenn der Compiler set berechnet ("record"), verwendet er <b>BindSetMember</b> . <br><br><h3>  Darstellung eines Objekts als Array </h3><br>  Einige Klassen sind Container f√ºr Instanzen anderer Typen.  Das DLR kann mit solchen F√§llen umgehen.  Jede "Array-orientierte" Metaobjektmethode hat einen "Index" -Postfix: <br><br><ol><li>  BindGetIndex - Wert nach Index abrufen </li><li>  BindSetIndex - Wert nach Index festlegen </li><li>  BindDeleteIndex - L√∂scht einen Wert nach Index </li></ol><br>  Um zu verstehen, wie <b>BindGetIndex</b> und <b>BindSetIndex verwendet werden</b> , stellen Sie sich eine <b>JavaBridge-</b> Wrapper- <b>Klasse vor</b> , die Dateien mit Java-Klassen laden kann und die es Ihnen erm√∂glicht, sie problemlos aus .NET-Code zu verwenden.  Ein solcher Wrapper kann zum Laden der <b>Customer</b> Java-Klasse verwendet werden, die ORM-Code enth√§lt.  Mit dem DLR-Metaobjekt kann dieser ORM-Code aus .NET im klassischen C # -Stil aufgerufen werden.  Im Folgenden finden Sie einen Beispielcode, der zeigt, wie <b>JavaBridge</b> in der Praxis <b>funktionieren</b> kann: <br><br><pre> <code class="cs hljs">JavaBridge java = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JavaBridge(); <span class="hljs-keyword"><span class="hljs-keyword">dynamic</span></span> customers = java.Load(<span class="hljs-string"><span class="hljs-string">"Customer.class"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">dynamic</span></span> Jason = customers[<span class="hljs-string"><span class="hljs-string">"Bock"</span></span>]; Jason.Balance = <span class="hljs-number"><span class="hljs-number">17.34</span></span>; customers[<span class="hljs-string"><span class="hljs-string">"Wagner"</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Customer(<span class="hljs-string"><span class="hljs-string">"Bill"</span></span>);</code> </pre> <br>  Da die dritte und f√ºnfte Zeile den Zugriffsoperator anhand des Index ([]) verwenden, erkennt der Compiler dies und verwendet die <b>Methoden</b> <b>BindGetIndex</b> und <b>BindSetIndex,</b> wenn er mit dem von <b>JavaBridge</b> zur√ºckgegebenen <b>Metaobjekt arbeitet</b> .  Es versteht sich, dass die Implementierung dieser Methoden auf dem zur√ºckgegebenen Objekt die Ausf√ºhrung der Methode von der JVM √ºber den Java Remote Method Invocation (RMI) anfordert.  In diesem Szenario fungiert das DLR als Br√ºcke zwischen C # und einer anderen Sprache mit statischer Typisierung.  Ich hoffe, dies verdeutlicht, warum ich das DLR als ‚ÄûSprache der Sprachen‚Äú bezeichnet habe. <br><br>  Die <b>BindDeleteMember-</b> Methode ist genau wie <b>BindDeleteIndex</b> nicht f√ºr die Verwendung in Sprachen mit statischer Typisierung wie C # und Visual Basic vorgesehen, da sie das Konzept selbst nicht unterst√ºtzen.  Sie k√∂nnen jedoch zustimmen, eine Operation, die durch die Sprache ausgedr√ºckt wird, in Betracht zu ziehen, wenn dies f√ºr Sie n√ºtzlich ist.  Beispielsweise k√∂nnen Sie BindDeleteMember so implementieren, dass ein Element nach Index auf Null gesetzt wird. <br><br><h3>  Transformationen und Operatoren </h3><br>  Die letzte Gruppe von DLR-Metaobjektmethoden befasst sich mit der Behandlung von Operatoren und Transformationen. <br><br><ol><li>  BindConvert - Konvertiert ein Objekt in einen anderen Typ </li><li>  BindBinaryOperation - Verwenden eines Bin√§roperators f√ºr zwei Operanden </li><li>  BindUnaryOperation - Verwenden eines un√§ren Operators f√ºr einen Operanden </li></ol><br>  Die <b>BindConvert-</b> Methode <b>wird</b> verwendet, wenn der Compiler erkennt, dass das Objekt in einen anderen bekannten Typ konvertiert werden muss.  Eine implizite Konvertierung erfolgt, wenn das Ergebnis eines dynamischen Aufrufs einer Variablen mit einem statischen Typ zugewiesen wird.  Im folgenden C # <b>-Beispiel</b> f√ºhrt das Zuweisen der Variablen <b>y beispielsweise</b> zu einem impliziten Aufruf von <b>BindConvert</b> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">dynamic</span></span> x = <span class="hljs-number"><span class="hljs-number">13</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = x + <span class="hljs-number"><span class="hljs-number">11</span></span>;</code> </pre> <br>  Die <b>Methoden</b> <b>BindBinaryOperation</b> und <b>BindUnaryOperation</b> werden immer verwendet, wenn arithmetische Operationen ("+") oder Inkremente ("++") auftreten.  Im obigen Beispiel ruft das Hinzuf√ºgen der dynamischen Variablen <b>x</b> zur Konstante 11 die <b>BindBinaryOperation-</b> Methode auf.  Denken Sie an dieses kleine Beispiel, wir verwenden es im n√§chsten Abschnitt, um eine andere wichtige DLR-Klasse namens CallSite zu knallen. <br><br><h2>  Dynamischer Versand mit CallSite </h2><br>  Wenn Ihre Einf√ºhrung in das DLR nicht √ºber die Verwendung des <b>dynamischen</b> Schl√ºsselworts hinausgegangen w√§re, h√§tten Sie wahrscheinlich nie von der Existenz von CallSite in .NET Framework gewusst.  Dieser bescheidene Typ, der formal als <b>CallSite</b> <b>&lt;</b> <b>T</b> <b>&gt; bezeichnet wird</b> , befindet sich im <b>System.Runtime.CompilerServices-Namespace</b> .  Dies ist die ‚ÄûEnergiequelle‚Äú der Metaprogrammierung: Sie enth√§lt alle Arten von Optimierungsmethoden, die dynamischen .NET-Code schnell und effizient machen.  Ich werde die Leistungsaspekte von <b>CallSite</b> <b>&lt;</b> <b>T</b> <b>&gt;</b> am Ende des Artikels erw√§hnen. <br><br>  Das meiste, was CallSite in dynamischem .NET-Code tut, besteht darin, Code zur Laufzeit zu generieren und zu kompilieren.  Es ist wichtig zu beachten, dass die <b>CallSite</b> <b>&lt;</b> <b>T</b> <b>&gt;</b> -Klasse im Namespace liegt, der die W√∂rter " <b>Runtime</b> " und " <b>CompilerServices</b> " enth√§lt.  Wenn das DLR eine "Sprache der Sprachen" ist, ist <b>CallSite</b> <b>&lt;</b> <b>T</b> <b>&gt;</b> eine seiner wichtigsten grammatikalischen Konstruktionen.  Schauen wir uns noch einmal unser Beispiel aus dem vorherigen Abschnitt an, um CallSite kennenzulernen und zu erfahren, wie der Compiler sie in Ihren Code einbettet. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">dynamic</span></span> x = <span class="hljs-number"><span class="hljs-number">13</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = x + <span class="hljs-number"><span class="hljs-number">11</span></span>;</code> </pre> <br>  Wie Sie bereits wissen, werden die Methoden <b>BindBinaryOperaion</b> und <b>BindConvert</b> aufgerufen, um diesen Code auszuf√ºhren.  Anstatt Ihnen eine lange Liste des vom Compiler generierten zerlegten MSIL-Codes zu zeigen, habe ich ein Diagramm erstellt: <br><br><img src="https://habrastorage.org/webt/c8/pw/0o/c8pw0osalzvckhg3w6b3eddlik4.png"><br><br>  Denken Sie daran, dass der Compiler die Sprachsyntax verwendet, um zu bestimmen, welche dynamischen Typmethoden ausgef√ºhrt werden sollen.  In unserem Beispiel werden zwei Operationen ausgef√ºhrt: Hinzuf√ºgen der Variablen <b>x</b> zur Zahl ( <b>Site2</b> ) und <b>Umwandeln</b> des Ergebnisses in int ( <b>Site1</b> ).  Jede dieser Aktionen wird zu CallSite, die in einem speziellen Container gespeichert wird.  Wie Sie im Diagramm sehen k√∂nnen, werden CallSites in umgekehrter Reihenfolge erstellt, aber auf die richtige Weise aufgerufen. <br><br>  In der Abbildung sehen Sie, dass die Metaobjektmethoden <b>BindConvert</b> und <b>BindBinaryOperation</b> unmittelbar vor den Operationen "create CallSite1" und "create CallSite2" aufgerufen werden.  Gebundene Operationen werden jedoch nur ganz am Ende ausgef√ºhrt.  Ich hoffe, die Visualisierung hilft Ihnen zu verstehen, dass Bindungsmethoden und deren Aufruf im Kontext des DLR unterschiedliche Operationen sind.  Dar√ºber hinaus erfolgt die Bindung nur einmal, w√§hrend der Aufruf so oft wie n√∂tig erfolgt, wobei die bereits initialisierten CallSites zur Optimierung der Leistung wiederverwendet werden. <br><br><h2>  Folgen Sie dem einfachen Weg </h2><br>  Im Herzen des DLR werden Expressionsb√§ume verwendet, um Funktionen zu generieren, die an die oben dargestellten zw√∂lf Bindungsmethoden gebunden sind.  Viele Entwickler sind st√§ndig mit Ausdrucksb√§umen konfrontiert, die LINQ verwenden, aber nur wenige verf√ºgen √ºber ausreichend Erfahrung, um den <b>IDynamicMetaObjectProvider-</b> Vertrag vollst√§ndig zu implementieren.  Gl√ºcklicherweise enth√§lt .NET Framework eine Basisklasse namens <b>DynamicObject</b> , die den gr√∂√üten Teil der Arbeit <b>erledigt</b> . <br><br>  Um Ihre eigene dynamische Klasse zu erstellen, m√ºssen Sie <b>lediglich</b> von <b>DynamicObject</b> erben und die folgenden zw√∂lf Methoden implementieren: <br><br><ol><li>  TryCreateInstance </li><li>  TryInvokeMember </li><li>  Tryinvoke </li><li>  TryGetMember </li><li>  TrySetMember </li><li>  TryDeleteMember </li><li>  TryGetIndex </li><li>  TrySetIndex </li><li>  TryDeleteIndex </li><li>  Tryconvert </li><li>  TryBinaryOperation </li><li>  TryUnaryOperation </li></ol><br>  Kommen Ihnen die Methodennamen bekannt vor?  Sie m√ºssen, weil Sie gerade die Elemente der Abstract <b>DynamicMetaObject-</b> Klasse studiert haben, die Methoden wie <b>BindCreateInstance</b> und <b>BindInvoke enthalten</b> .  Die <b>DynamicMetaObject-</b> Klasse bietet eine Implementierung f√ºr <b>IDynamicMetaObjectProvider</b> , die ein <b>DynamicMetaObject</b> von ihrer einzigen Methode zur√ºckgibt.  Die Operationen, die der <b>Basisimplementierung</b> des <b>Metaobjekts zugeordnet sind,</b> delegieren ihre Aufrufe einfach an Methoden, die mit "Try" in der <b>DynamicObject-</b> Instanz beginnen.  Sie m√ºssen <b>lediglich</b> Methoden wie <b>TryGetMember</b> und <b>TrySetMember</b> in der von <b>DynamicObject</b> geerbten Klasse <b>√ºberladen</b> , w√§hrend das <b>Metaobjekt</b> die gesamte Drecksarbeit mit Ausdrucksb√§umen √ºbernimmt. <br><br><h2>  Caching </h2><br>  <i>[Weitere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Informationen zum</a> Caching finden Sie in meinem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vorherigen Artikel zum DLR.</a> ]</i> <br><br>  Das gr√∂√üte Problem bei der Arbeit mit dynamischen Sprachen f√ºr Entwickler ist die Leistung.  Das DLR ergreift au√üerordentliche Ma√ünahmen, um diese Erfahrungen zu zerstreuen.  Ich habe kurz die Tatsache erw√§hnt, dass sich <b>CallSite</b> <b>&lt;</b> <b>T</b> <b>&gt;</b> in einem Namespace namens <b>System.Runtime.CompilerServices befindet</b> .  Im selben Namespace befinden sich mehrere andere Klassen, die mehrstufiges Caching bereitstellen.  Mit diesen Typen implementiert das DLR drei Hauptstufen des Caching, um dynamische Vorg√§nge zu beschleunigen: <br><br><ol><li>  Globaler Cache </li><li>  Lokaler Cache </li><li>  Polymorpher Delegaten-Cache </li></ol><br>  Der Cache wird verwendet, um unn√∂tige Ressourcenverschwendung beim Erstellen von Bindungen f√ºr eine bestimmte CallSite zu vermeiden.  Wenn zwei Objekte vom Typ <i>string</i> an eine dynamische Methode √ºbergeben werden, die <i>int</i> zur√ºckgibt, speichert der globale oder lokale Cache die resultierende Bindung.  Dies vereinfacht nachfolgende Anrufe erheblich. <br><br>  Der Delegat-Cache, der sich in CallSite selbst befindet, wird als polymorph bezeichnet, da diese Delegaten unterschiedliche Formen annehmen k√∂nnen, je nachdem, welcher dynamische Code ausgef√ºhrt wird und welche Regeln aus anderen Caches zum Generieren verwendet wurden.  Der Delegaten-Cache wird manchmal auch als Inline-Cache bezeichnet.  Der Grund f√ºr die Verwendung dieses Begriffs besteht darin, dass die vom DLR und ihren Bindemitteln generierten Ausdr√ºcke wie jeder andere .NET-Code in MSIL-Code konvertiert werden, der die JIT-Kompilierung durchl√§uft.  Die Kompilierung zur Laufzeit erfolgt gleichzeitig mit der ‚Äûnormalen‚Äú Ausf√ºhrung Ihres Programms.  Es ist klar, dass die Umwandlung von dynamischem On-the-Fly-Code in kompilierten MSIL-Code w√§hrend der Programmausf√ºhrung die Anwendungsleistung erheblich beeintr√§chtigen kann. Daher sind Caching-Mechanismen von entscheidender Bedeutung. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de469075/">https://habr.com/ru/post/de469075/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de469055/index.html">Zen-Praxis im offenen Raum</a></li>
<li><a href="../de469059/index.html">Was ist neu in ML.NET und Model Builder?</a></li>
<li><a href="../de469061/index.html">Rust 1.38.0 Release: Pipeline-Kompilierung, # [veraltet] f√ºr Makros und std :: any :: type_name</a></li>
<li><a href="../de469071/index.html">K√ºnstliche Intelligenz Microsoft beherrschte Mahjong</a></li>
<li><a href="../de469073/index.html">Diskrete Ableitung oder Zusammenfassung der Summenreihen</a></li>
<li><a href="../de469077/index.html">Microsofts neuer Python-Kurs [auf Englisch]</a></li>
<li><a href="../de469079/index.html">Python in Visual Studio Code: September-Erweiterungsupdate</a></li>
<li><a href="../de469085/index.html">Wir nehmen die Software aus dem passwortgesch√ºtzten Mikrocontroller Renesas M16C heraus</a></li>
<li><a href="../de469087/index.html">MVCC in PostgreSQL-2. Gabeln, Dateien, Seiten</a></li>
<li><a href="../de469093/index.html">Vergleich weniger popul√§rer und nicht sehr CLI-Bibliotheken: Cliff, Plac, Plumbum und andere (Teil 2)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>