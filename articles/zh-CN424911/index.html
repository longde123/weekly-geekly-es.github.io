<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕺🏾 👐 👉🏿 简要介绍软件架构的类型，以及我们为IaaS提供商选择的架构 🕺 🐮 🏥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="有许多类型的软件体系结构各有利弊。 接下来，我们将讨论其中最受欢迎的功能，并讨论我们向微服务的过渡。 

  
 / libreshot / PD 

 软件架构的类型 
 分层架构 
 这是最常见的体系结构之一。 在此基础上，构建了许多大型框架-Java EE，Drupal，Express。 这种...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>简要介绍软件架构的类型，以及我们为IaaS提供商选择的架构</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/1cloud/blog/424911/"> 有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">许多类型的软件体系结构</a>各有利弊。 接下来，我们将讨论其中最受欢迎的功能，并讨论我们向微服务的过渡。 <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/xy/c4/0n/xyc40n4lngvgriexbx9vviubxki.jpeg"></a> <a name="habracut"></a><br>  <font color="#A9A9A9"><i>/ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">libreshot</a> / PD</i></font> <br><br><h2> 软件架构的类型 </h2><br><h5> 分层架构 </h5><br> 这是最常见的体系结构之一。 在此基础上，构建了许多大型框架-Java EE，Drupal，Express。 这种架构最著名的例子也许就是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">OSI</a>网络模型。 <br><br> 该系统分为多个级别，每个级别仅与两个相邻的级别交互。 因此，通常位于交互链末端的对数据库的查询顺序地通过每个“层”。 <br><br> 体系结构<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">并不意味着</a>任何强制性的级别-可以有三个，四个，五个或更多。 大多数情况下，使用三层系统：表示层（客户端），逻辑层和数据层。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nn/qa/b8/nnqab847wdvsg0sbvwph-yumd3e.png" width="300"></div><br> 关于多层架构的书籍和文章已不计其数。 对其优缺点也有不同的看法。 <br><br>  <i>优点：</i> <br><br> 此体系结构的每个级别执行一组严格受限的功能（不会逐层重复），并且不知道其他级别如何安排。 因此，级别的“内容”可以更改，而不会出现层之间全局冲突的风险。 <br><br> 通常，多层应用程序如此广泛，以至于需要为其开发创建特殊的模板生成器。 例如， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">用于Visual Studio的LASG</a>提供了几种代码生成方法，这些方法可以自动执行例行任务并帮助构建应用程序层。 <br><br>  <i>缺点：</i> <br><br> 在编程中，有一种说法是，可以通过添加另一个抽象级别来解决任何问题。 但是，这种方法最终会导致代码的组织不良，并使开发人员感到困惑。 <br><br> 另一个问题由此产生-低速。 在不使用业务逻辑的情况下，许多信息开始层层传递。 这个问题有时<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">被称为</a>下沉反模式，当无用操作的数量开始超过有用的操作时，这种设计模式就会出现。 <br><br> 在多层系统上查找错误也<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">可能很困难</a> 。 在进入数据库之前，信息会遍历各个级别（因为数据库是最终组件）。 如果由于某种原因该信息已损坏（或在运行过程中丢失），则为了查找错误，您必须分别分析每个级别。 <br><br>  <i>适合度：</i> <br><br><ul><li> 创建需要快速部署的新应用程序。 这是一种“通用模板”。 <br><br><blockquote> 在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">1cloud中</a>开始研究虚拟基础架构提供商的内部系统时，我们使用了这种特殊类型的架构。 最初，我们没有创建能够处理成千上万用户流量的IaaS服务的任务。 我们决定迅速在市场上推出该产品，并开始发展客户群，并解决可扩展性问题（现在，我们将所有系统转移到微服务架构，这将在后面讨论）。 </blockquote><br> 在开发人员中， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">有一种观点</a>认为从项目开始的第一天就没有必要为巨大的负载做准备（编写面向未来的软件）。 应用程序或服务的实际要求可能与预期有所不同，并且<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">业务目标可能会更改</a> 。 因此，着眼于遥远的未来编写的代码有可能成为技术债务。 </li><li> 根据O'Reilly的说法，分层架构是许多企业应用程序的自然选择。 由于公司（尤其是大型公司）通常共享能力：有一个团队负责前端，有一些人负责后端，依此类推。 这意味着将应用程序自然地划分为多个级别：一些开发人员在客户端上工作，其他开发人员在逻辑上工作。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">康威（Conway）的法律</a> （早在1967年制定）也<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">规定</a>了组织结构与应用程序开发方法之间的类似关系。 上面写着：“开发系统时，组织被迫遵守重复公司内部通信结构的方案。” </li></ul><br><h5> 面向事件的架构 </h5><br> 在这种情况下，开发人员会在发生任何事件时规定程序的行为（反应）。 系统中的事件被认为是其状态的重大变化。 <br><br> 您可以在车厢里买车来类比。 当汽车找到新的拥有者时，其状况从“待售”变为“已售”。 此活动启动了售前准备过程-安装其他设备，检查技术条件，清洗等。 <br><br> 事件驱动的系统通常包含两个组件：事件源（代理）及其使用者（接收器）。 通常也有两种类型的事件：发起事件和消费者响应的事件。 <br><br>  Java Swing库是实现此体系结构的一个示例。 如果该类需要有关事件的警报，则开发人员将实现所谓的侦听器-ActionListener（他“捕获”相应的事件），并将其附加到该事件可以生成的对象上。 <br><br>  Wiki提供了此机制的以下实现代码： <br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FooPanel</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JPanel</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ActionListener</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FooPanel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(); JButton btn = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JButton(<span class="hljs-string"><span class="hljs-string">"Click Me!"</span></span>); btn.addActionListener(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.add(btn); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">actionPerformed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ActionEvent ae)</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"Button has been clicked!"</span></span>); } }</code> </pre> <br>  <i>体系结构的优势：</i> <br><br> 由于应用程序由大量异步模块组成（它们不具有彼此的实现信息），因此易于扩展。 这样的系统被组装为构造函数-您无需注册依赖项，只需实现一个新模块即可。 此外，异步模型还可以提高应用程序性能。 <br><br>  <i>缺点：</i> <br><br> 这种应用程序的异步特性使调试变得复杂。 一个事件可以一次触发多个动作链。 如果有很多这样的链条，那么<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">可能很难</a>理解到底是什么导致了故障。 为了解决这个问题，我们<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">必须</a>解决错误处理的困难条件。 从这里开始，日志记录的问题随之而来-日志<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">难以</a>构造。 <br><br>  <i>适用于：</i> <br><br><ul><li> 创建异步系统。 这是显而易见的，因为架构本身包含大量异步模块。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">可用于</a>创建UI。 网页充当容器，每个组件都在其中被隔离并响应某些用户操作。 </li><li> 在各种信息系统之间组织消息传递。 </li></ul><br><h5> 微内核架构 </h5><br> 这种类型的体系结构包含两个组件：系统核心和插件。 插件负责业务逻辑，内核负责管理它们的加载和卸载。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/5t/fm/sy/5tfmsyjhqdngpuld3y-8feeurxs.png" width="400"></div><br> 作为微内核体系结构的示例，O'Reilly的书<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">提供了</a> Eclipse IDE。 这是一个简单的编辑器，用于打开文件，允许对其进行编辑并运行后台进程。 但是，通过添加插件（例如Java编译器），其功能得以扩展。 <br><br> 微内核架构曾一次将Symbian操作系统用于移动设备（开发于2012年停止）。 在她的微内核中有一个任务调度程序，内存管理系统和驱动程序，以及负责电话通信的文件系统和组件充当插件。 <br><br>  <i>体系结构的优势：</i> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">将</a>应用程序从一个环境<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">移植</a>到另一个环境很容易，因为只需要修改微内核。 高级别策略和低级别机制的分离简化了系统支持并确保了其可扩展性。 <br><br>  <i>缺点：</i> <br><br> 如果插入太多模块，则会降低应用程序性能。 但是，在插件数量和微核任务数量之间<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">找到平衡</a> （通常只包含经常使用的代码）可能会<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">成问题</a> 。 <br><br> 提前（在开发应用程序之前）确定微核代码的最佳片段化程度也是困难的。 后来改变方法几乎是不可能的。 <br><br>  <i>适用于：</i> <br><br><ul><li> 创建可被大量人使用的可扩展应用程序。 例如，iPhone OS具有“微内核”的根源-它的开发人员从<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Mach</a> （这是微内核的第一个示例）中汲取了灵感。 </li><li> 创建应用程序，将基本方法和高级规则清楚地分开。 </li><li> 开发具有动态变化的规则集的系统，这些规则集必须经常更新。 </li></ul><br><h5> 微服务 </h5><br> 类似于事件驱动的体系结构和微内核。 但是，当可以将各个应用程序任务轻松地划分为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">独立</a>于小功能的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">服务</a>时，可以使用它们。 这些服务可以用不同的编程语言编写，因为它们使用REST API（例如，使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">JSON</a>或<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Thrift</a> ）相互通信。 <br><br> 开发人员决定将代码按什么比例划分，但是“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">创建</a>微服务”一书的作者Sam Newman建议您为微服务分配尽可能多的代码行，以使团队能够在两周内重现。 据他介绍，这将避免过多的建筑“膨胀”。 <br><br> 微服务通常是在所谓的容器中启动的。 这些容器可通过网络访问其他微服务和应用程序，编排系统将它们全部管理：示例包括Kubernetes，Docker Swarm等。 <br><br>  <i>优点：</i> <br><br> 微服务架构简化了应用程序扩展。 要实现新功能，只需编写新服务即可。 如果不再需要该功能，则可以禁用微服务。 每个微服务都是一个单独的项目，因此很容易在开发团队之间分配有关它们的工作。 <br><br> 在Martin L. Abbott的书《可伸缩性的艺术》中，详细了解微服务系统的伸缩机制。 <br><br>  <i>缺点：</i> <br><br> 很难找到错误。 与单片系统不同（当所有功能都在同一内核中时），可能很难确定请求为何“下降”。 有关详细信息，您必须转到“有罪”过程的日志（如果有多个，则问题会更加严重）。 <br><br> 这为微服务之间的消息传输增加了额外的开销。 根据我们的估计，网络成本的增长可以达到25％。 <br><br> 另一个缺点是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">需要忍受</a>最终一致性（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">从长远来看是一致性</a> ）的概念。 微服务有自己的数据仓库，其他微服务可以访问它们。 有关此数据更改的信息不会立即通过系统分发。 因此，当某些微服务（尽管时间非常短）的数据过时时，就会出现这种情况。 <br><br>  <i>使用地点：</i> <br><br><ul><li> 在高负荷的大型项目中。 例如，流平台使用微服务。 内容交付系统和其他支持服务可以相互独立缩放，以适应负载变化。 </li><li> 在使用“混合”资源的系统中。 如果应用程序的一部分需要更多的处理器时间，第二部分需要更多的内存，则将它们划分为微服务是有意义的。 然后可以将它们托管在不同的计算机上-分别具有强大的CPU或大量的内存。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">需要安全性时</a> 。 由于微服务是隔离的并通过API进行通信，因此可以确保仅传输特定服务所需的信息。 在使用密码或支付卡数据时，这一点很重要。 </li></ul><br><h2> 我们为什么要在1cloud中切换到微服务 </h2><br> 正如我们已经说过的，我们提供的服务（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">私有云</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">虚拟服务器</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">对象云存储</a>等）的基础是多层架构。 她表现出良好的一面，但现在她的扩展能力开始耗尽。 <br><br> 我们正在成为越来越多的合作伙伴，他们可以基于我们的特许经营平台提供解决方案。 有些远程站点和服务很难从一个角度进行管理（特别是，我们的设备位于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">俄罗斯，哈萨克斯坦和白俄罗斯的</a>多个数据中心）。 <br><br> 为了使扩展现有功能和引入新功能更加容易，我们将整个基础架构转移到<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">1cloud中的</a>微服务上。 <br><br><img src="https://habrastorage.org/webt/qc/en/nv/qcennvcdxbriz_2it7sf3jhtpv8.png"><br><br> 我们希望将它们分成单独的模块，而不是从一个复杂的数据库中获得N个简单的数据库。 因此，在新架构中，每个功能都将具有一个单独的数据库。 它在支持和开发方面更加方便和高效。 <br><br> 我们将能够在多个开发人员（公司的重点专长）之间划分服务工作，并有效地横向扩展-必要时，我们只需连接新的微服务即可。 <br><br> 我们的客户还将获得许多优势。 由于微服务未相互连接，因此当特定服务失败时，只有微服务将不可用，其余所有服务将继续正常运行。 此外，即使我们的服务出现全球性下降，控制面板也将继续工作。 <br><br> 来自哈萨克斯坦和白俄罗斯（以及我们将在其开设代表处的其他国家/地区）的客户将注意到界面的速度和响应能力有了显着提高，因为控制面板位于本地。 <br><br><h5> 已经做了什么 </h5><br> 到目前为止，我们仅实施了第一个试点项目：“监视服务”。 其余服务将在2018年底-2019年初转移到新的轨道。 <br><br> 同时，新架构为下一阶段奠定了技术基础-迁移到容器。 现在，我们使用Windows基础结构，并切换到容器，我们需要将所有累积的代码重写为.NetCore并将其传输到Linux。 <br><br> 我们计划在2019年初开始新的过渡，并在明年年底完成。 <br><br><div class="spoiler">  <b class="spoiler_title">用简单的话说一下关于建筑值得记住的东西</b> <div class="spoiler_text"><ul><li>  <b>多级体系结构</b> -应用程序分为多个级别，每个级别执行一组严格定义的功能。 每个级别都可以单独修改。 缺点包括代码速度低和难以发现错误。 <br><br> 适用于需要快速推向市场的开发应用程序。 常用于创建企业服务。 </li><li>  <b>面向事件的体系结构</b> -在这里，开发人员规定了系统对任何事件的反应。 例如，如果接收到数据，则将其写入文件。 由于所有事件处理程序都不了解彼此的实现，因此基于事件的体系结构的应用程序易于扩展。 但是，调试此类系统很困难-单个动作可能一次导致多个动作链（很难理解是哪个动作导致了故障）。 <br><br> 用于创建异步系统，图形界面和消息传递系统的组织。 </li><li>  <b>微内核架构</b> -由两个关键组件组成：插件和内核。 插件负责业务逻辑，内核负责加载和卸载它们。 职责分离简化了系统支持。 但是，它会影响性能-它直接取决于连接和活动模块的数量。 <br><br> 它适用于开发可被大量人员使用的可扩展应用程序，以及具有经常需要更新的一组规则的系统（插件可确保易于更新）。 </li><li> 微服务<b>架构</b> -应用程序分为功能-微服务。 每个微服务都是具有自己的业务逻辑的独立组件。 这些组件使用API​​相互通信。 这样的应用程序易于开发（可以在开发团队之间分配工作），但是却很难调试。 <br><br> 用于要求高安全性的大型项目中。 </li></ul><br><br></div></div><br><h5> 我们还在1cloud博客上写些什么： </h5><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">1cloud云架构演进：调制挑战</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">IaaS如何帮助1C加盟商：1cloud体验</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">为什么需要监视？</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN424911/">https://habr.com/ru/post/zh-CN424911/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN424897/index.html">一次意外的会议。 第18章</a></li>
<li><a href="../zh-CN424899/index.html">关于音频的聆听内容：15个播客</a></li>
<li><a href="../zh-CN424901/index.html">272号移动开发人员的有趣材料摘要（9月24日至9月30日）</a></li>
<li><a href="../zh-CN424905/index.html">从零开始开发hexapod（第2部分）-构建</a></li>
<li><a href="../zh-CN424907/index.html">DEFCON会议22. GTVHacker集团。 破解一切：在45分钟内破解20台设备。 第一部分</a></li>
<li><a href="../zh-CN424913/index.html">国际能源署：2027年风能将在欧洲盛行</a></li>
<li><a href="../zh-CN424915/index.html">DEFCON会议22. GTVHacker集团。 破解一切：在45分钟内破解20台设备。 第二部分</a></li>
<li><a href="../zh-CN424917/index.html">我们如何将糟糕的预测重塑为更好的结果</a></li>
<li><a href="../zh-CN424919/index.html">来自跳蚤市场的珍珠或IP摄像机DCS-5220A1的逆向工程</a></li>
<li><a href="../zh-CN424921/index.html">网络数学如何帮助您结交朋友</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>