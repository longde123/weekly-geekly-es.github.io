<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🖐️ 👆🏼 ✔️ Mengapa LLVM dapat memanggil fungsi yang tidak pernah dipanggil? ↩️ 😯 👀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Aku tidak peduli apa yang dikatakan nagamu, itu bohong. Naga berbohong. Anda tidak tahu apa yang menunggu Anda di sisi lain. 

 Michael Swanwick, Putr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mengapa LLVM dapat memanggil fungsi yang tidak pernah dipanggil?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/458442/"><blockquote>  <i>Aku tidak peduli apa yang dikatakan nagamu, itu bohong.</i>  <i>Naga berbohong.</i>  <i>Anda tidak tahu apa yang menunggu Anda di sisi lain.</i> <br><br>  Michael Swanwick, Putri Naga Besi </blockquote>  Artikel ini didasarkan pada posting di blog Krister Walfridsson, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Mengapa perilaku yang tidak terdefinisi dapat memanggil fungsi yang tidak pernah disebut?"</a>  . <br><br>  Artikel menarik kesimpulan sederhana: perilaku tidak terdefinisi dalam kompiler dapat melakukan apa saja, bahkan sesuatu yang benar-benar tak terduga.  Pada artikel ini, saya memeriksa mekanisme internal dari pengoptimalan ini berfungsi. <br><a name="habracut"></a><br>  Untuk rekap singkat pos Waldfridsson, dalam kode sumber di bawah ini, fungsi EraseAll tidak boleh dipanggil dari main, dan tidak benar-benar dipanggil saat dikompilasi dengan -O0, tetapi tiba-tiba dipanggil dengan optimasi -O1 dan lebih tinggi. <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;cstdlib&gt; typedef int (*Function)(); static Function Do; static int EraseAll() { return system(“rm -rf /”); } void NeverCalled() { Do = EraseAll; } int main() { return Do(); }</span></span></span></span></code> </pre> <br>  Bagaimana cara kompiler mengoptimalkannya?  Pada awalnya, Do, pointer ke suatu fungsi batal, karena, sesuai dengan standar C, semua variabel global memiliki nilai nol ketika sebuah program dimulai. <br><br><img src="https://habrastorage.org/webt/5i/k5/s0/5ik5s0xohytqkbqnw2exo1on1jc.jpeg"><br><br>  Program akan mencoba melakukan dereferensi pada penunjuk Do dan memanggil fungsi yang ditugaskan.  Tetapi jika kita mencoba untuk mengubah pointer nol, standar mengatakan bahwa itu adalah perilaku undefined UB.  Biasanya, jika kita mengkompilasi tanpa optimisasi, dengan opsi -O0, kita akan mendapatkan Kesalahan Segmentasi (di Linux).  Tetapi Standar mengatakan, bahwa dalam hal UB, sebuah program dapat melakukan apa saja. <br><br><img src="https://habrastorage.org/webt/ez/mq/bc/ezmqbco46shm4fqad2pbjyfhygw.jpeg"><br><br>  Kompiler menggunakan fitur standar ini untuk menghapus operasi yang tidak perlu.  Jika kompilator melihat bahwa Do ditugaskan di mana saja dalam program, ia dapat menetapkan nilai ini dalam waktu inisialisasi, dan tidak menetapkannya di runtime.  Pada kenyataannya, ada dua kemungkinan: <br><br>  1. jika sebuah pointer ditereferensi setelah ditetapkan, kita menang, karena kompiler dapat menghapus tugas yang tidak perlu. <br><br>  2. jika pointer direferensikan sebelum ditetapkan, standar mengatakan bahwa itu adalah UB, dan perilaku dapat berupa apa saja, termasuk memanggil fungsi arbitrer.  Artinya, memanggil fungsi PrintHello () tidak bertentangan dengan standar. <br><br>  Artinya, dalam hal apa pun, kami dapat menetapkan beberapa nilai tidak-nol ke pointer yang tidak diinisialisasi dan mendapatkan perilaku, sesuai dengan standar. <br><br><img src="https://habrastorage.org/webt/se/th/yx/sethyxxeoe2wjcy941i8nxzj4gm.jpeg"><br><br>  Apa kondisi yang memungkinkan pengoptimalan ini?  Pada awalnya, sebuah program harus berisi sebuah penunjuk global tanpa nilai awal atau dengan nilai nol (itu sama).  Selanjutnya, program harus berisi tugas nilai untuk pointer ini, di mana saja, tidak peduli, sebelum pointer dereferencing atau sesudahnya.  Dalam contoh di atas, tugas belum terjadi sama sekali, tetapi kompiler melihat bahwa tugas itu ada. <br><br>  Jika kondisi ini terpenuhi, kompiler dapat menghapus tugas dan mengubahnya menjadi nilai awal pointer. <br><br>  Dalam kode yang diberikan variabel Do adalah penunjuk ke fungsi, dan memiliki nilai awal nol.  Ketika kami mencoba memanggil fungsi pada penunjuk nol, perilaku program tidak terdefinisi (perilaku tidak terdefinisi, UB) dan kompiler berhak untuk mengoptimalkan UB seperti yang diinginkan.  Dalam hal ini, kompiler segera menjalankan tugas Do = EraseAll. <br><br>  Mengapa ini terjadi?  Dalam sisa teks, LLVM dan Dentang versi 5.0.0 digunakan sebagai kompiler.  Contoh kode bisa dijalankan untuk Anda berlatih sendiri. <br><br>  Untuk memulainya, mari kita lihat kode IR saat mengoptimalkan dengan -O0 dan -O1.  Mari kita ubah sedikit kode sumber agar tidak terlalu dramatis: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;cstdlib&gt; typedef int (*Function)(); static Function Do; static int PrintHello() { return printf("hello world\n"); } void NeverCalled() { Do = PrintHello; } int main() { return Do(); }</span></span></span></span></code> </pre> <br>  Dan kami mengkompilasi kode IR dengan -O0 (informasi debugging dihilangkan untuk kejelasan): <br><br><pre> <code class="cpp hljs">; ModuleID = <span class="hljs-string"><span class="hljs-string">'test.c'</span></span> source_filename = <span class="hljs-string"><span class="hljs-string">"test.c"</span></span> target datalayout = <span class="hljs-string"><span class="hljs-string">"em:e-i64:64-f80:128-n8:16:32:64-S128"</span></span> target triple = <span class="hljs-string"><span class="hljs-string">"x86_64-unknown-linux-gnu"</span></span> @Do = internal global i32 (...)* null, align <span class="hljs-number"><span class="hljs-number">8</span></span> @.str = <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> unnamed_addr constant [<span class="hljs-number"><span class="hljs-number">13</span></span> x i8] c<span class="hljs-string"><span class="hljs-string">"hello world\0A\00"</span></span>, align <span class="hljs-number"><span class="hljs-number">1</span></span> ; Function Attrs: noinline nounwind optnone uwtable define <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> @NeverCalled() #<span class="hljs-number"><span class="hljs-number">0</span></span> { entry: <span class="hljs-function"><span class="hljs-function">store </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">i32</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bitcast</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i32 ()* @PrintHello to i32 (...)*)</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">i32</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span><span class="hljs-function">** @Do, align 8 ret </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> } </span></span>; Function Attrs: noinline nounwind optnone uwtable define i32 @main() #<span class="hljs-number"><span class="hljs-number">0</span></span> { entry: %retval = alloca i32, align <span class="hljs-number"><span class="hljs-number">4</span></span> store i32 <span class="hljs-number"><span class="hljs-number">0</span></span>, i32* %retval, align <span class="hljs-number"><span class="hljs-number">4</span></span> %<span class="hljs-number"><span class="hljs-number">0</span></span> = load i32 (...)*, i32 (...)** @Do, align <span class="hljs-number"><span class="hljs-number">8</span></span> %call = call i32 (...) %<span class="hljs-number"><span class="hljs-number">0</span></span>() ret i32 %call } ; Function Attrs: noinline nounwind optnone uwtable define internal i32 @PrintHello() #<span class="hljs-number"><span class="hljs-number">0</span></span> { entry: %call = call i32 (i8*, ...) @<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(i8* getelementptr inbounds ([<span class="hljs-number"><span class="hljs-number">13</span></span> x i8], [<span class="hljs-number"><span class="hljs-number">13</span></span> x i8]* @.str, i32 <span class="hljs-number"><span class="hljs-number">0</span></span>, i32 <span class="hljs-number"><span class="hljs-number">0</span></span>)) ret i32 %call } declare i32 @<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(i8*, ...) #<span class="hljs-number"><span class="hljs-number">1</span></span> And with -O1: ; ModuleID = <span class="hljs-string"><span class="hljs-string">'test.ll'</span></span> source_filename = <span class="hljs-string"><span class="hljs-string">"test.c"</span></span> target datalayout = <span class="hljs-string"><span class="hljs-string">"em:e-i64:64-f80:128-n8:16:32:64-S128"</span></span> target triple = <span class="hljs-string"><span class="hljs-string">"x86_64-unknown-linux-gnu"</span></span> @.str = <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> unnamed_addr constant [<span class="hljs-number"><span class="hljs-number">13</span></span> x i8] c<span class="hljs-string"><span class="hljs-string">"hello world\0A\00"</span></span>, align <span class="hljs-number"><span class="hljs-number">1</span></span> ; Function Attrs: noinline nounwind optnone uwtable define <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> @NeverCalled() local_unnamed_addr #<span class="hljs-number"><span class="hljs-number">0</span></span> { entry: ret <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> } ; Function Attrs: noinline nounwind optnone uwtable define i32 @main() local_unnamed_addr #<span class="hljs-number"><span class="hljs-number">0</span></span> { entry: %retval = alloca i32, align <span class="hljs-number"><span class="hljs-number">4</span></span> store i32 <span class="hljs-number"><span class="hljs-number">0</span></span>, i32* %retval, align <span class="hljs-number"><span class="hljs-number">4</span></span> %call = call i32 (...) bitcast (i32 ()* @PrintHello to i32 (...)*)() ret i32 %call } ; Function Attrs: noinline nounwind optnone uwtable define internal i32 @PrintHello() unnamed_addr #<span class="hljs-number"><span class="hljs-number">0</span></span> { entry: %call = call i32 (i8*, ...) @<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(i8* getelementptr inbounds ([<span class="hljs-number"><span class="hljs-number">13</span></span> x i8], [<span class="hljs-number"><span class="hljs-number">13</span></span> x i8]* @.str, i32 <span class="hljs-number"><span class="hljs-number">0</span></span>, i32 <span class="hljs-number"><span class="hljs-number">0</span></span>)) ret i32 %call } declare i32 @<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(i8*, ...) local_unnamed_addr #<span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  Jika Anda mengkompilasi executable, Anda akan mengonfirmasi bahwa dalam kasus pertama, kesalahan segmentasi terjadi, dan dalam kasus kedua, "halo dunia" ditampilkan.  Dengan opsi pengoptimalan lainnya, hasilnya sama dengan -O1. <br><br>  Sekarang temukan bagian dari kode kompiler yang melakukan optimasi ini.  Arsitektur LLVM frontend tidak berurusan dengan optimisasi itu sendiri, mis. Cfe (Clang Frontend) selalu menghasilkan kode tanpa optimisasi, yang kita lihat dalam versi untuk -O0, dan semua optimasi dilakukan oleh utilitas opt: <br><br><img src="https://habrastorage.org/webt/1o/c9/vt/1oc9vtkgl4qt2yxundzkjso_u0w.jpeg"><br><br>  Dengan -O1, 186 lintasan optimasi dilakukan. <br><br>  Mematikan pass satu demi satu, kami menemukan apa yang kami cari: <i>globalopt</i> pass.  Kami hanya dapat meninggalkan pass optimasi ini, dan memastikan bahwa itu, dan tidak ada orang lain, menghasilkan kode yang kami butuhkan.  Sumbernya ada di file /lib/Transforms/IPO/GlobalOpt.cpp.  Anda dapat melihat kode sumber di repositori LLVM.  Untuk singkatnya, saya hanya menyediakan fungsi yang penting untuk memahami cara kerjanya. <br><br><img src="https://habrastorage.org/webt/4k/-g/nl/4k-gnlzr7e6573zeobjdcp91x5q.jpeg"><br><br>  Gambar ini mewakili struktur representasi IR.  Kode dalam representasi IR LLVM memiliki level hierarkis: modul mewakili level hierarki tertinggi, dan mencakup semua fungsi dan objek global, seperti variabel global.  Suatu fungsi adalah level paling penting dari representasi IR dan sebagian besar pass berfungsi pada level ini.  Blok dasar adalah salah satu konsep terpenting dari teori kompiler.  Blok dasar terdiri dari instruksi, yang tidak dapat membuat lompatan dari tengah blok dasar atau di dalam blok dasar.  Semua transisi antara blok dasar hanya dimungkinkan dari ujung blok dasar dan ke awal blok dasar, dan setiap lompatan dari atau ke tengah blok dasar tidak pernah mungkin.  Level instruksi mewakili instruksi kode IR LLVM.  Ini bukan instruksi prosesor, ini adalah instruksi dari beberapa mesin virtual yang sangat umum dengan jumlah register yang tidak terbatas. <br><br><img src="https://habrastorage.org/webt/6y/dt/wn/6ydtwn5hajletngggvj27uzurls.png"><br><br>  Gambar ini menunjukkan hierarki lintasan LLVM.  Di lintasan kiri bekerja pada kode LLVM IR ditampilkan, di lintasan kanan bekerja dengan instruksi target ditampilkan. <br><br>  Awalnya, ia mengimplementasikan metode runOnModule, yaitu ketika bekerja, ia melihat dan mengoptimalkan seluruh modul (yang, tentu saja, masuk akal dalam kasus ini).  Fungsi yang melakukan optimasi adalah mengoptimalkanGlobalsInModule: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">optimizeGlobalsInModule</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Module &amp;M, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> DataLayout &amp;DL, TargetLibraryInfo *TLI, function_ref&lt;dominatortree&gt; LookupDomTree)</span></span></span><span class="hljs-function"> </span></span>{ SmallSet&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> comdat=<span class="hljs-string"><span class="hljs-string">"Comdat"</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span>=<span class="hljs-string"><span class="hljs-string">"8"</span></span>&gt; NotDiscardableComdats; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Changed = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> LocalChange = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (LocalChange) { LocalChange = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; NotDiscardableComdats.clear(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> GlobalVariable &amp;GV : M.globals()) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Comdat *C = GV.getComdat()) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!GV.isDiscardableIfUnused() || !GV.use_empty()) NotDiscardableComdats.insert(C); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Function &amp;F : M) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Comdat *C = F.getComdat()) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!F.isDefTriviallyDead()) NotDiscardableComdats.insert(C); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (GlobalAlias &amp;GA : M.aliases()) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Comdat *C = GA.getComdat()) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!GA.isDiscardableIfUnused() || !GA.use_empty()) NotDiscardableComdats.insert(C); <span class="hljs-comment"><span class="hljs-comment">// Delete functions that are trivially dead, ccc -&gt; fastcc LocalChange |= OptimizeFunctions(M, TLI, LookupDomTree, NotDiscardableComdats); // Optimize global_ctors list. LocalChange |= optimizeGlobalCtorsList(M, [&amp;](Function *F) { return EvaluateStaticConstructor(F, DL, TLI); }); // Optimize non-address-taken globals. LocalChange |= OptimizeGlobalVars(M, TLI, LookupDomTree, NotDiscardableComdats); // Resolve aliases, when possible. LocalChange |= OptimizeGlobalAliases(M, NotDiscardableComdats); // Try to remove trivial global destructors if they are not removed // already. Function *CXAAtExitFn = FindCXAAtExit(M, TLI); if (CXAAtExitFn) LocalChange |= OptimizeEmptyGlobalCXXDtors(CXAAtExitFn); Changed |= LocalChange; } // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> Move all global ctors functions to the end of the module for code // layout. return Changed; }</span></span></code> </pre> <br>  Mari kita coba gambarkan dengan kata-kata apa fungsi ini.  Untuk setiap variabel global dalam modul, ia meminta objek Comdat. <br><br>  Apa itu objek Comdat? <br><br>  Bagian Comdat adalah bagian dalam file objek, di mana objek ditempatkan, yang dapat diduplikasi dalam file objek lainnya.  Setiap objek memiliki informasi untuk linker, menunjukkan apa yang harus dilakukan ketika duplikat terdeteksi.  Opsinya bisa: Apa saja - lakukan apa saja, ExactMatch - duplikat harus benar-benar cocok, jika tidak terjadi kesalahan, Terbesar - ambil objek dengan nilai terbesar, NoDublicates - tidak boleh ada duplikat, SameSize - duplikat harus memiliki ukuran yang sama, jika tidak terjadi kesalahan. <br><br>  Dalam LLVM, data Comdat diwakili oleh enumerasi: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> SelectionKind { Any, <span class="hljs-comment"><span class="hljs-comment">///&lt; The linker may choose any COMDAT. ExactMatch, ///&lt; The data referenced by the COMDAT must be the same. Largest, ///&lt; The linker will choose the largest COMDAT. NoDuplicates, ///&lt; No other Module may specify this COMDAT. SameSize, ///&lt; The data referenced by the COMDAT must be the same size. };</span></span></code> </pre> <br>  dan kelas Comdat sebenarnya mewakili pasangan (Nama, SelectionKind).  (Faktanya, semuanya lebih rumit.) Semua variabel yang karena alasan tertentu tidak dapat dihapus ditempatkan di set NotDiscardableComdats.  Dengan fungsi dan alias global, kami melakukan hal yang sama - sesuatu yang tidak dapat dihapus ditempatkan di NotDiscardableComdats.  Kemudian, fungsi optimisasi terpisah untuk konstruktor global, fungsi global, variabel global, alias global, dan destruktor global disebut.  Optimasi berlanjut dalam loop sampai tidak ada optimasi yang dilakukan.  Pada setiap iterasi loop, himpunan NotDiscardableComdats diatur ke nol. <br><br>  Mari kita lihat objek apa yang terdaftar dari sumber pengujian kami. <br><br>  Variabel global: <br><br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">1.</span></span> @Do = internal global i32 (...)* null, align <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-number"><span class="hljs-number">2.</span></span> @.str = <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> unnamed_addr constant [<span class="hljs-number"><span class="hljs-number">13</span></span> x i8] c<span class="hljs-string"><span class="hljs-string">"hello world\0A\00"</span></span>, align <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  (sedikit ke depan, saya dapat mengatakan bahwa variabel pertama akan dihapus oleh pengoptimal pada iterasi pertama). <br>  Fungsi: <br><br><pre> <code class="cpp hljs">define <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> @NeverCalled() define i32 @main() define internal i32 @PrintHello() declare i32 @<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(i8*, ...)</code> </pre> <br>  Perhatikan bahwa printf hanya dideklarasikan, tetapi tidak didefinisikan. <br><br>  Tidak ada alias global. <br><br>  Mari kita lihat contoh pass optimasi ini dan perhatikan bagaimana hasil ini ternyata.  Tentu saja, untuk menganalisis semua opsi pengoptimalan bahkan dalam satu langkah adalah tugas yang sangat besar, karena melibatkan banyak kasus khusus pengoptimalan.  Kami akan berkonsentrasi pada contoh kami, dengan mempertimbangkan fungsi-fungsi dan struktur data yang penting untuk memahami pekerjaan pass optimasi ini. <br><br>  Awalnya, pengoptimal melakukan berbagai pemeriksaan yang tidak menarik dalam kasus ini, dan memanggil fungsi processInternalGlobal, yang mencoba mengoptimalkan variabel global.  Fungsi ini juga cukup kompleks dan melakukan banyak hal berbeda, tetapi kami tertarik pada satu hal: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GS.StoredType == GlobalStatus::StoredOnce &amp;&amp; GS.StoredOnceValue) { ... <span class="hljs-comment"><span class="hljs-comment">// We are trying to optimize global variables, about which it is known that they are assigned a value only once, except the initializing value. if (optimizeOnceStoredGlobal(GV, GS.StoredOnceValue, GS.Ordering, DL, TLI)) return true; ... }</span></span></code> </pre> <br>  Informasi bahwa variabel global diberi nilai satu dan hanya sekali diekstraksi dari struktur GS (GlobalStatus).  Struktur ini diisi dalam fungsi panggilan: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processGlobal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GlobalValue &amp;GV, TargetLibraryInfo *TLI, function_ref&lt;dominatortree&gt; LookupDomTree)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GV.getName().startswith(<span class="hljs-string"><span class="hljs-string">"llvm."</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; GlobalStatus GS; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GlobalStatus::analyzeGlobal(&amp;GV, GS)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; ...</code> </pre> <br>  Di sini kita melihat satu fakta yang lebih menarik: objek yang namanya dimulai dengan "llvm."  tidak tunduk pada optimasi (karena mereka adalah panggilan sistem untuk runtime llvm).  Dan, untuk berjaga-jaga, nama-nama variabel dalam LLVM IR dapat berisi titik (dan bahkan terdiri dari satu titik dengan awalan @ atau%).  Function analysisGlobal adalah panggilan ke API LLVM dan kami tidak akan mempertimbangkan pekerjaan internalnya.  Struktur GlobalStatus harus dilihat secara terperinci karena mengandung informasi yang sangat penting untuk lintasan optimasi. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/// As we analyze each global, keep track of some information about it. If we /// find out that the address of the global is taken, none of this info will be /// accurate. struct GlobalStatus { /// True if the global's address is used in a comparison. bool IsCompared = false; /// True if the global is ever loaded. If the global isn't ever loaded it /// can be deleted. bool IsLoaded = false; /// Keep track of what stores to the global look like. enum StoredType { /// There is no store to this global. It can thus be marked constant. NotStored, /// This global is stored to, but the only thing stored is the constant it /// was initialized with. This is only tracked for scalar globals. InitializerStored, /// This global is stored to, but only its initializer and one other value /// is ever stored to it. If this global isStoredOnce, we track the value /// stored to it in StoredOnceValue below. This is only tracked for scalar /// globals. StoredOnce, /// This global is stored to by multiple values or something else that we /// cannot track. Stored } StoredType = NotStored; /// If only one value (besides the initializer constant) is ever stored to /// this global, keep track of what value it is. Value *StoredOnceValue = nullptr; ... };</span></span></code> </pre> <br>  Perlu dijelaskan mengapa "Jika kami mengetahui bahwa alamat global diambil, tidak ada info ini yang akurat."  Bahkan, jika kita mengambil alamat variabel global, dan kemudian menulis sesuatu di alamat ini, bukan dengan nama, maka akan sangat sulit untuk melacak ini, dan lebih baik meninggalkan variabel seperti apa adanya, tanpa mencoba mengoptimalkan . <br><br>  Jadi, kita masuk ke fungsi optimOnceStoredGlobal, di mana variabel (GV) dan nilai tersimpan (StoredOnceVal) dilewatkan.  Inilah mereka: <br><br><pre> <code class="cpp hljs">@Do = internal unnamed_addr global i32 (...)* null, align <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-comment"><span class="hljs-comment">// the variable i32 (...)* bitcast (i32 ()* @PrintHello to i32 (...)*) // the value</span></span></code> </pre> <br>  Selanjutnya, untuk nilainya, bitcast tidak signifikan dihapus, dan untuk variabel kondisi berikut diperiksa: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GV-&gt;getInitializer()-&gt;getType()-&gt;isPointerTy() &amp;&amp; GV-&gt;getInitializer()-&gt;isNullValue()) { ...</code> </pre> <br>  yaitu variabel harus diinisialisasi dengan pointer nol.  Jika ini masalahnya, maka kami membuat variabel SOVC baru yang sesuai dengan nilai StoredOnceVal yang digunakan untuk tipe GV: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Constant *SOVC = dyn_cast&lt;constant&gt;(StoredOnceVal)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GV-&gt;getInitializer()-&gt;getType() != SOVC-&gt;getType()) SOVC = ConstantExpr::getBitCast(SOVC, GV-&gt;getInitializer()-&gt;getType());</code> </pre> <br>  Di sini, getBitCast adalah metode yang mengembalikan perintah bitcast, yang mengetikkan tipe-tipe dalam bahasa IR LLVM. <br><br>  Setelah itu, fungsi OptimizeAwayTrappingUsesOfLoads dipanggil.  Ini mentransfer variabel global GV dan LV konstan. <br><br>  Optimalisasi langsung dilakukan oleh fungsi OptimizeAwayTrappingUsesOfValue (Value * V, Constant * NewV). <br><br>  Untuk setiap penggunaan variabel: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> UI = V-&gt;user_begin(), E = V-&gt;user_end(); UI != E; ) { Instruction *I = cast&lt;instruction&gt;(*UI++);</code> </pre> <br>  jika ini adalah perintah Load, ganti operan dengan nilai baru: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (LoadInst *LI = dyn_cast&lt;loadinst&gt;(I)) { LI-&gt;setOperand(<span class="hljs-number"><span class="hljs-number">0</span></span>, NewV); Changed = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  Jika variabel digunakan dalam pemanggilan fungsi atau memanggil (yang persis seperti yang terjadi dalam contoh kita), buat fungsi baru, ganti argumennya dengan nilai baru: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isa&lt;callinst&gt;(I) || isa&lt;invokeinst&gt;(I)) { <span class="hljs-function"><span class="hljs-function">CallSite </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CS</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(I)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (CS.getCalledValue() == V) { <span class="hljs-comment"><span class="hljs-comment">// Calling through the pointer! Turn into a direct call, but be careful // that the pointer is not also being passed as an argument. CS.setCalledFunction(NewV); Changed = true; bool PassedAsArg = false; for (unsigned i = 0, e = CS.arg_size(); i != e; ++i) if (CS.getArgument(i) == V) { PassedAsArg = true; CS.setArgument(i, NewV); }</span></span></code> </pre> <br>  Semua argumen lain ke fungsi cukup disalin. <br><br>  Juga, algoritma penggantian serupa disediakan untuk instruksi Cast dan GEP, tetapi dalam kasus kami ini tidak terjadi. <br><br>  Tindakan selanjutnya adalah sebagai berikut: kita melihat melalui semua penggunaan variabel global, mencoba untuk menghapus semuanya, kecuali penugasan nilai.  Jika ini berhasil, maka kita dapat menghapus variabel Do. <br><br>  Jadi, kami meninjau secara singkat pekerjaan optimasi lulus LLVM pada contoh tertentu.  Pada prinsipnya, tidak ada yang super rumit di sini, tetapi pemrograman yang lebih cermat diperlukan untuk menyediakan semua kemungkinan kombinasi perintah dan tipe variabel.  Tentu saja, semua ini harus ditanggung oleh tes.  Mempelajari kode sumber pengoptimal LLVM akan membantu Anda menulis pengoptimalan, yang memungkinkan Anda meningkatkan kode untuk beberapa kasus tertentu. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id458442/">https://habr.com/ru/post/id458442/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id458428/index.html">Google membuka kode sumber pengurai robots.txt</a></li>
<li><a href="../id458432/index.html">Menggabungkan beberapa paket menjadi satu namespace Python</a></li>
<li><a href="../id458434/index.html">Pelatihan Cisco 200-125 CCNA v3.0. Hari 11. Dasar-Dasar VLAN</a></li>
<li><a href="../id458436/index.html">Kesalahan logging umum</a></li>
<li><a href="../id458440/index.html">Dukungan teknis di hari kerja: cerita tentang apa yang terjadi ketika Anda tidak dapat menjangkau pengguna</a></li>
<li><a href="../id458444/index.html">Internet untuk penduduk musim panas. Bagian 4. Satu kartu SIM sudah cukup</a></li>
<li><a href="../id458446/index.html">Pusat data Hyperscale: siapa yang membangunnya dan berapa biayanya</a></li>
<li><a href="../id458450/index.html">Karakteristik komputer kuantum</a></li>
<li><a href="../id458452/index.html">Cara membuat dapur kantor melalui pendekatan grosir</a></li>
<li><a href="../id458458/index.html">Kamera kedalaman - revolusi diam (saat robot akan melihat) Bagian 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>