<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👊🏾 🌪️ 👨🏾‍🤝‍👨🏼 Infrastruktur sebagai kode, kami menang dalam skala besar (Kirill Vetchinkin, TYME) 🙅 🗜️ 🦃</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Model Infrastructure as Code (IaC), kadang-kadang disebut sebagai "infrastruktur yang dapat diprogram", adalah model di mana proses konfigurasi infras...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Infrastruktur sebagai kode, kami menang dalam skala besar (Kirill Vetchinkin, TYME)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438748/"><p>  Model Infrastructure as Code (IaC), kadang-kadang disebut sebagai "infrastruktur yang dapat diprogram", adalah model di mana proses konfigurasi infrastruktur mirip dengan proses pemrograman perangkat lunak.  Pada dasarnya, ini menandai awal dari menghilangkan batas antara menulis aplikasi dan menciptakan lingkungan untuk aplikasi ini.  Aplikasi dapat berisi skrip yang membuat dan mengelola mesin virtual mereka sendiri.  Ini adalah dasar dari komputasi awan dan bagian integral dari DevOps. </p><br><p>  Infrastruktur sebagai kode memungkinkan Anda mengelola mesin virtual di tingkat perangkat lunak.  Ini menghilangkan kebutuhan untuk konfigurasi manual dan pembaruan untuk masing-masing komponen peralatan.  Infrastruktur menjadi sangat "tangguh," yaitu, dapat direproduksi dan terukur.  Satu operator dapat menggunakan dan mengelola satu dan 1000 mesin menggunakan serangkaian kode yang sama.  Di antara manfaat infrastruktur yang dijamin sebagai kode adalah kecepatan, efektivitas biaya, dan pengurangan risiko. </p><br><p>  Inilah yang dimaksud dengan decoding laporan Kirill Vetchinkin di DevOpsDays Moscow 2018. Laporan: penggunaan kembali modul Ansible, penyimpanan di Git, tinjau, pembangunan kembali, manfaat finansial, penskalaan horizontal 1-klik. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/mElPCgMl_Wg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Siapa yang peduli, tolong, di bawah kucing. </p><a name="habracut"></a><br><p>  Halo semuanya.  Seperti yang sudah dikatakan, saya Vetchinkin Kirill.  Saya bekerja di TYME dan hari ini kita akan berbicara tentang infrastruktur sebagai kode.  Kami juga akan berbicara tentang bagaimana kami belajar menghemat praktik ini, karena itu cukup mahal.  Menulis banyak kode cukup mahal untuk mengatur infrastruktur. </p><br><p>  Saya akan berbicara singkat tentang perusahaan.  Saya bekerja di TYME.  Kami memiliki rebranding.  Sekarang kita disebut PaySystem - seperti namanya, kita terlibat dalam sistem pembayaran.  Kami memiliki solusi kami sendiri - ini adalah prosesing, dan pengembangan kustom.  Pengembangan kustom adalah perbankan elektronik, penagihan, dan sejenisnya.  Dan seperti yang Anda tahu, jika ini adalah pengembangan kustom, maka ini adalah sejumlah besar proyek setiap tahun.  Proyek berjalan setelah proyek.  Semakin banyak proyek, semakin banyak infrastruktur dari jenis yang sama harus ditingkatkan.  Karena proyek sering kali dimuat banyak, kami menggunakan arsitektur microservice.  Oleh karena itu, dalam satu proyek ada banyak, banyak sub proyek kecil. </p><br><p><img src="https://habrastorage.org/webt/e2/pn/or/e2pnoryduehiqs7tpmruibojxng.png"></p><br><p>  Karenanya, mengelola seluruh kebun binatang ini tanpa DevOps penuh sangat sulit.  Oleh karena itu, perusahaan kami telah menerapkan berbagai praktik DevOps.  Secara alami, kami bekerja di kanban, di SCRUM, kami menyimpan semuanya di git.  Setelah melakukan, ada integrasi terus menerus, tes dijalankan.  Penguji menulis tes ujung ke ujung pada PyTest yang dimulai setiap malam.  Unit-test dimulai setelah setiap komit.  Kami menggunakan proses build dan deploy yang terpisah: assembled, kemudian deploy ke berbagai lingkungan berkali-kali.  Kami berada di windows.  Di windows kami menggunakan menggunakan Octopus, tahun ini kami mengembangkan di DotNet Core.  Karena itu, kami sekarang dapat menjalankan perangkat lunak pada sistem Linux.  Kami meninggalkan Octopus dan tiba di Ansible.  Hari ini kita akan membicarakan bagian ini, yang merupakan praktik baru yang kami kembangkan tahun ini, sesuatu yang belum pernah kami lakukan sebelumnya.  Ketika Anda memiliki tes, ketika Anda tahu cara membangun aplikasi dengan baik, menempatkannya di suatu tempat tidak masalah.  Tetapi jika Anda memiliki dua lingkungan yang dikonfigurasi secara berbeda, maka Anda masih akan jatuh, dan jatuh pada produksi.  Oleh karena itu, mengelola konfigurasi adalah praktik yang sangat penting.  Itulah yang akan kita bicarakan hari ini. </p><br><p><img src="https://habrastorage.org/webt/_u/di/kj/_udikjskq0g3yi48718mjn1hf54.png"><br>  Saya akan menjelaskan secara singkat bagaimana ekonomi tenaga kerja produk dibangun: <strong>60</strong> persen dihabiskan untuk <strong>pengembangan</strong> , <strong>analitik</strong> membutuhkan sekitar <strong>10</strong> persen, <strong>QA</strong> (pengujian) memakan waktu sekitar <strong>20</strong> persen, dan segala sesuatu yang lain dialokasikan untuk konfigurasi.  Ketika sistem berjalan dalam aliran penuh, mereka memiliki banyak perangkat lunak pihak ketiga, sistem operasi itu sendiri dikonfigurasi dengan cara yang hampir sama.  Kami menghabiskan waktu ekstra untuk melakukan ini, pada dasarnya melakukan hal yang sama.  Ada ide untuk mengotomatisasi segalanya dan mengurangi biaya konfigurasi infrastruktur.  Tugas serupa diotomatiskan, debugged dengan baik dan tidak mengandung operasi manual. </p><br><p><img src="https://habrastorage.org/webt/zf/vh/wm/zfvhwmb7pvlufeihfrgj0xk6dnq.png"><br>  Setiap aplikasi berfungsi dalam beberapa jenis lingkungan.  Mari kita lihat terdiri dari apa semua itu.  Minimal, kita harus memiliki <strong>sistem operasi</strong> , perlu dikonfigurasi, ada beberapa <strong>aplikasi pihak ketiga</strong> yang juga perlu dikonfigurasi, <strong>aplikasi itu sendiri</strong> harus menerima konfigurasi, tetapi untuk seluruh produk untuk bekerja, aplikasi itu sendiri harus mulai, yang beroperasi di seluruh sistem ini.  Ada juga <strong>jaringan</strong> yang juga perlu dikonfigurasi, tetapi kami tidak akan berbicara tentang jaringan hari ini, karena kami memiliki pelanggan yang berbeda, perangkat jaringan yang berbeda.  Kami juga mencoba mengotomatiskan konfigurasi jaringan, tetapi karena perangkatnya berbeda, tidak ada manfaat khusus dari ini, kami menghabiskan lebih banyak sumber daya untuk ini.  Tetapi kami mengotomatiskan sistem operasi, aplikasi pihak ketiga, dan transfer parameter konfigurasi ke aplikasi itu sendiri. </p><br><p><img src="https://habrastorage.org/webt/mp/gx/l0/mpgxl0kr4wzjrc9zymbmjn2pk6c.png"></p><br><p>  Ada dua pendekatan untuk bagaimana Anda dapat mengkonfigurasi server: dengan tangan - jika Anda mengonfigurasinya dengan tangan, Anda mungkin akan mendapatkan situasi sedemikian rupa sehingga Anda telah mengonfigurasi produksi dengan satu cara, tes yang lain, semuanya berwarna hijau pada pengujian, tes berwarna hijau.  Anda menyebarkan ke produksi, dan tidak ada kerangka kerja di sana - tidak ada yang berhasil untuk Anda.  Contoh lain: tiga server Aplikasi dikonfigurasikan dengan tangan.  Satu server aplikasi dikonfigurasikan dalam satu cara, server aplikasi lain dengan cara yang berbeda.  Server dapat bekerja dengan berbagai cara.  Contoh lain: ada situasi ketika satu server Panggung benar-benar berhenti bekerja untuk kami.  Kami mulai membuat server baru menggunakan dan setelah 30 server siap.  Contoh lain: server baru saja berhenti bekerja.  Jika Anda mengaturnya dengan tangan Anda, maka Anda perlu mencari orang yang tahu cara mengkonfigurasinya, Anda perlu meningkatkan dokumentasi.  Seperti yang kita ketahui, dokumentasi hampir tidak relevan.  Ini adalah masalah besar.  Dan, yang paling penting, ini adalah audit, yaitu, secara kasar, Anda memiliki sepuluh administrator, masing-masing mengatur sesuatu dengan tangannya, tidak terlalu jelas apakah mereka mengaturnya dengan benar atau salah, dan bagaimana memahami apakah kemudian pengaturan, mereka bisa meletakkan sesuatu yang berlebihan, buka beberapa port yang tidak perlu. </p><br><p><img src="https://habrastorage.org/webt/uz/pr/be/uzprbex2cscs4xglphdoy_wsenw.png"></p><br><p>  Ada opsi alternatif - inilah yang kita bicarakan hari ini - ini adalah konfigurasi dari kode.  Artinya, kami memiliki repositori git di mana seluruh infrastruktur disimpan.  Semua skrip disimpan di sana, dengan bantuan yang akan kami konfigurasikan.  Karena ini semua ada di git, kita mendapatkan semua manfaat dari manajemen kode, seperti dalam pengembangan, yaitu, kita dapat melakukan tinjauan, audit, mengubah sejarah, siapa yang melakukannya, mengapa melakukannya, komentar, kita dapat memutar kembali.  Untuk bekerja dengan kode Anda perlu menggunakan pipa perakitan terus menerus - pipa penyebaran.  Agar suatu sistem tertentu dapat membuat perubahan pada server, yaitu, tidak seorang pun akan melakukan sesuatu dengan tangannya, tetapi sistem akan melakukannya secara eksklusif. </p><br><p><img src="https://habrastorage.org/webt/0r/dj/j_/0rdjj_cdepjplmukudcdg5sbnlo.png"></p><br><p>  Sebagai sistem yang melakukan perubahan, kami menggunakan Ansible.  Karena kami tidak memiliki banyak server, sangat cocok untuk kami.  Jika Anda memiliki 100-200 server di sana, maka Anda akan memiliki masalah kecil, karena itu (mis. Ansible) masih terhubung ke masing-masing dan mengkonfigurasinya secara bergantian - ini adalah masalah.  Lebih baik menggunakan cara lain yang tidak mendorong, tetapi menarik.  Tetapi untuk sejarah kami, ketika kami memiliki banyak proyek, tetapi tidak lebih dari 20 server, ini sangat cocok untuk kami.  Ansible memiliki nilai tambah besar - ini merupakan ambang masuk yang rendah.  Artinya, secara harfiah setiap spesialis TI dalam tiga minggu dapat sepenuhnya menguasainya.  Dia memiliki banyak modul.  Artinya, Anda dapat mengelola cloud, jaringan, file, menginstal program, menyebarkan - benar-benar segalanya.  Jika tidak ada modul, Anda dapat menulis sendiri, Anda akhirnya dapat menulis sesuatu menggunakan modul shell atau perintah Ansible. </p><br><p><img src="https://habrastorage.org/webt/y6/2j/vq/y62jvqqmsm9jwm0shngvgrp_5_g.png"></p><br><p>  Secara umum, kami akan mempertimbangkan secara singkat tampilannya secara umum, alat ini.  Ansible memiliki modul yang sudah saya bicarakan.  Artinya, mereka dapat disampaikan, ditulis sendiri, yang sedang melakukan sesuatu.  Ada inventaris - ini adalah tempat kami akan menggulirkan perubahan kami, yaitu, ini adalah host, alamat IP mereka, variabel khusus untuk host ini.  Dan, karenanya, peran.  Peran adalah apa yang akan kita putar di server ini.  Dan juga host kita dikelompokkan ke dalam grup, yaitu, dalam hal ini kita melihat bahwa kita memiliki dua grup: server database dan server aplikasi.  Di setiap grup kami memiliki tiga mobil.  Mereka terhubung melalui ssh.  Jadi, kami memecahkan masalah yang kami bicarakan sebelumnya, bahwa sejak awal server kami dikonfigurasi secara identik, karena peran yang sama bergulir ke server.  Dan dengan cara yang sama, jika kita menjalankan peran ini pada beberapa mesin, maka untuk masing-masing itu akan bekerja dengan cara yang sama. </p><br><p><img src="https://habrastorage.org/webt/h2/hr/-t/h2hr-t11qunwpnaa-9ro7wxhfio.png"></p><br><p>  Jika kita melihat lebih dalam pada bagaimana proyek Ansible terstruktur, maka di sini kita melihat bahwa host dapat diterima untuk inventaris produksi.  Grup ini ditunjukkan dan ada dua server di dalamnya.  Jika kita pergi ke server tertentu, kita melihat bahwa alamat IP mesin ini ditunjukkan di sini.  Parameter lain juga dapat ditunjukkan di sana - variabel spesifik untuk lingkungan ini.  Jika kita melihat perannya.  Peran itu berisi beberapa tugas yang akan dilakukan.  Dalam hal ini, ini adalah peran untuk menginstal PostgreSQL.  Artinya, kita menginstal aplikasi yang diperlukan, membuat database.  Di sini kita menggunakan perulangan.  Mereka (basis data) akan dibuat sedikit.  Kemudian kami membuat koneksi yang diperlukan - alamat IP yang dapat masuk ke database ini.  Dan, karenanya, kami mengonfigurasi di bagian paling akhir firewall.  Pengaturan akan diterapkan ke semua server dalam grup. </p><br><p><img src="https://habrastorage.org/webt/zg/ia/zo/zgiazoqklptftwwsjnxyqtq-1jc.png"></p><br><p>  Cukup dekati masalahnya sendiri: kami mempelajari cara mengkonfigurasi server menggunakan Ansible dan semuanya baik-baik saja.  Tetapi, seperti yang saya katakan, kami memiliki banyak proyek.  Mereka hampir semuanya sama.  Beberapa sistem ini terlibat dalam setiap proyek (k8s, RabbitMQ, Vault, ELK, PostgreSQL, HAProxy).  Untuk masing-masing, kami menulis peran.  Kita bisa menggulungnya dari tombol. </p><br><p><img src="https://habrastorage.org/webt/c3/ob/ez/c3obezyaxpshu6akdh6_qodbhp4.png"></p><br><p>  Tetapi kami memiliki banyak proyek, dan masing-masing proyek pada dasarnya tumpang tindih.  Yaitu, di satu set seperti itu, di set kedua, di set ketiga.  Kami mendapatkan titik persimpangan di mana peran yang sama di berbagai proyek. </p><br><p><img src="https://habrastorage.org/webt/zk/fi/ag/zkfiagc0lsac1-a9tnce_rr7cha.png"></p><br><p>  Kami memiliki repositori dengan aplikasi, kami memiliki repositori dengan infrastruktur untuk proyek tersebut.  Proyek kedua persis sama.  Infrastruktur yang berkelanjutan.  Dan yang ketiga.  Jika kita menerapkan hal yang sama, maka pada dasarnya copy-paste akan berubah.  Kami akan melakukan peran yang sama di 10 tempat.  Kemudian, jika ada kesalahan, kami akan memerintah di 10 tempat. </p><br><p><img src="https://habrastorage.org/webt/g8/qe/ht/g8qehtvllis6iwedgzaasbu9pe8.png"></p><br><p>  Apa yang kami lakukan: kami mengambil setiap peran yang umum untuk semua proyek dan semua konfigurasinya yang datang dari luar ke repositori terpisah dan menempatkannya di git di folder terpisah - kami disebut TYME Infrastructure.  Di sana kami memiliki peran untuk PostgreSQL, untuk ELK, untuk menyebarkan kluster Kubernetes.  Jika kita perlu memasukkan beberapa proyek, katakanlah PostgreSQL yang sama, kemudian nyalakan saja sebagai submodule, tulis ulang inventaris, yaitu, secara kasar, konfigurasi tempat untuk menjalankan peran ini.  Kami tidak menulis ulang peran itu sendiri: sudah ada.  Dan dengan mengklik tombol, PostgreSQL muncul di semua proyek baru.  Jika Anda perlu menaikkan kluster Kubernetes - hal yang sama. </p><br><p><img src="https://habrastorage.org/webt/iy/q1/p0/iyq1p0mgtf6vhnk06s4mnirypls.png"></p><br><p>  Dengan demikian, ternyata mengurangi biaya peran menulis.  Yaitu, mereka menulis sekali - mereka menggunakannya 10 kali.  Ketika proyek berjalan setelah proyek - itu sangat nyaman.  Tetapi karena kita sekarang bekerja dengan infrastruktur sebagai kode, kita tentu membutuhkan pipa yang kita bicarakan.  Orang-orang berkomitmen pada git, mereka dapat melakukan semacam kesalahan - kita perlu melacak ini semua.  Oleh karena itu, kami telah membangun pipa semacam itu.  Artinya, pengembang melakukan skrip Ansible di git.  Teamity melacak mereka dan mentransfernya ke Ansible.  Teamcity diperlukan di sini hanya untuk satu alasan: pertama, ia memiliki antarmuka visual (ada versi gratis Ansible Tower - AWX, yang memecahkan masalah yang sama - kira-kira.) Tidak seperti Ansible gratis dan, pada prinsipnya, kami memiliki Teamcity sebagai satu Ci.  Jadi, pada prinsipnya, Ansible memiliki modul yang dengan sendirinya dapat melacak git.  Tetapi dalam hal ini mereka melakukannya hanya dalam gambar dan rupa.  Dan begitu dia melacaknya, ia mentransfer semua kode ke Ansible dan Ansible, masing-masing, meluncurkannya di server integrasi dan mengubah konfigurasi.  Jika proses ini dilanggar, maka kami menganalisis apa yang salah, mengapa skrip ditulis dengan buruk. </p><br><p><img src="https://habrastorage.org/webt/rj/hc/wj/rjhcwjfpwdf_xwr8vpk4z2se26c.png"></p><br><p>  Poin kedua adalah bahwa ada infrastruktur khusus, di sini kita memiliki infrastruktur yang digunakan secara terpisah, aplikasi ini digunakan secara terpisah.  Tetapi ada infrastruktur khusus untuk setiap aplikasi, yaitu, yang perlu digunakan sebelum kita meluncurkannya.  Di sini, karenanya, tidak mungkin untuk mentransfernya ke saluran pipa yang berbeda.  Anda harus menempatkan ini di wadah yang sama dengan aplikasi itu sendiri.  Yaitu, katakanlah, kerangka kerja adalah hal yang populer ketika Anda perlu menginstal satu kerangka kerja untuk aplikasi baru dan menempatkan kerangka kerja lain untuk yang lain.  Begini caranya dengan situasi ini.  Atau Anda perlu membersihkan cache.  Misalnya, Ansible juga bisa memanjat, membersihkan cache. </p><br><p><img src="https://habrastorage.org/webt/b5/qj/rf/b5qjrf25y_2k4znz0-zidclu7fi.png"></p><br><p>  Tapi di sini kita menggunakan buruh pelabuhan dalam kombinasi dengan Ansible.  Artinya, infrastruktur spesifik kita adalah di buruh pelabuhan, non-spesifik di Ansible.  Jadi, kami membagi delta kecil ini di docker, yang lainnya, fundamental - dalam Ansible. </p><br><p><img src="https://habrastorage.org/webt/xq/6i/21/xq6i21qkn6l18s8f68becyjgt7y.png"></p><br><p>  Poin yang sangat penting - jika Anda menggulung infrastruktur melalui beberapa jenis skrip, melalui kode, maka jika Anda masih memiliki manipulasi server manual, maka ini adalah kerentanan potensial.  Karena katakanlah Anda meletakkan java di server pengujian, menulis peran ELK, menggulungnya.  Menyebarkan dalam tes berhasil.  Menyebarkan dalam produksi, tetapi tidak ada java.  Dan Anda tidak menentukan java dalam skrip - penyebaran dalam produksi jatuh.  Karena itu, Anda perlu mengambil hak dari semua server dari administrator sehingga mereka tidak merangkak ke dalamnya dengan tangan Anda dan membuat semua perubahan melalui git.  Semua conveyor yang kami lalui sendiri.  Ada satu hal tetapi - jangan mengencangkan mur terlalu banyak.  Artinya, perlu untuk memperkenalkan proses semacam itu secara bertahap.  Karena masih mentah.  Dalam kasus kami, kami meninggalkan akses ke semua sistem di kepala administrator utama jika terjadi insiden yang tidak terduga.  Akses diberikan dengan ketentuan bahwa itu tidak akan mengkonfigurasi apa pun dengan tangan. </p><br><p><img src="https://habrastorage.org/webt/za/ka/i0/zakai07gy34i3f7gjx8d-jtvpfy.png"></p><br><p>  Bagaimana cara kerja pengembangan?  Peluncuran dalam pementasan, produksi harus bebas dari kesalahan.  Sesuatu bisa pecah di sini.  Jika peluncuran di lingkungan integrasi terus-menerus jatuh pada kesalahan, itu akan menjadi buruk.  Ini mirip dengan aplikasi debug pada mesin jarak jauh.  Ketika seorang pengembang pertama kali mengembangkan segala sesuatu pada mesin, kompilasi itu.  Jika semuanya dikompilasi, maka kirimkan ke repositori.  Ini menggunakan pendekatan yang sama.  Pengembang menggunakan Visual Studio Code dengan plugins Ansible, Vagrant, Docker, dll.  Pengembang menguji kode infrastruktur mereka pada gelandangan lokal.  Ada sistem operasi yang bersih.  Script sendiri untuk meningkatkan mesin ini juga ada dalam repositori ini dengan infrastruktur yang kita bicarakan.  Pengembang mulai menginstal server FTP di atasnya.  Jika terjadi kesalahan, ia cukup menghapusnya, memuatnya kembali, dan kembali mencoba menginstal perangkat lunak yang diperlukan menggunakan skrip penerapan.  Setelah men-debug skrip penerapan, itu membuat Permintaan Gabung ke cabang utama.  Setelah menggabungkan Permintaan Gabung, CI mengembalikan perubahan ini ke server integrasi. </p><br><p><img src="https://habrastorage.org/webt/6q/os/qq/6qosqq_jtbghh6dvamxnj1sdvru.png"></p><br><p>  Karena semua skrip adalah kode, kita dapat menulis tes.  Katakanlah kita menginstal PostgreSQL.  Kami ingin memeriksa apakah berfungsi atau tidak.  Untuk melakukan ini, gunakan modul Ansible assert.  Bandingkan versi PostgreSQL yang diinstal dengan versi di skrip.  Dengan demikian, kami memahami bahwa itu diinstal, umumnya berjalan, itu adalah versi yang kami harapkan. </p><br><p><img src="https://habrastorage.org/webt/fc/3g/lf/fc3glflk8ozxdmpluhltv2a5mye.png"></p><br><p>  Kami melihat bahwa tes tersebut lulus.  Jadi buku pedoman kami berfungsi dengan benar.  Anda dapat menulis sebanyak mungkin tes yang Anda inginkan.  Mereka idempoten.  <strong>Idempotency</strong> (operasi yang, jika diterapkan pada nilai apa pun beberapa kali, selalu menghasilkan nilai yang sama dengan satu aplikasi).  Jika Anda menulis skrip gratis untuk instalasi dan konfigurasi, maka pastikan skrip Anda selalu mendapatkan nilai yang sama jika Anda menjalankannya beberapa kali. </p><br><p><img src="https://habrastorage.org/webt/cn/tx/zd/cntxzd9yeatgui-yml_a61pegsa.png"></p><br><p>  Ada jenis tes lain yang tidak secara langsung terkait dengan pengujian infrastruktur.  Tetapi mereka tampaknya secara tidak langsung mempengaruhi dirinya.  Ini adalah tes ujung ke ujung.  Kami memiliki infrastruktur dan aplikasi itu sendiri diinstal pada server yang sama, yang diuji oleh penguji.  Jika kita menggulung beberapa jenis infrastruktur yang salah, maka kita hanya tes kompleks yang tidak akan lulus.  Artinya, aplikasi kita entah bagaimana akan bekerja secara salah.  Dalam contoh ini, kami memasang versi baru pada produksi - aplikasi berfungsi.  Kemudian komit dibuat dalam git dan tes end-to-end, yang berlangsung pada malam hari, dilacak bahwa di sini kita tidak memiliki file di ftp.  Kami membongkar kasus ini dan melihat bahwa masalahnya ada di pengaturan ftp.  Kami memperbaiki skrip dalam kode, menyebarkan lagi dan semuanya berubah hijau.  Kisah yang sama dengan kode.  Kode dan infrastruktur infrastruktur diuji secara tidak langsung dengan satu atau lain cara.  Kami kemudian dapat menggunakannya untuk produksi. </p><br><p><img src="https://habrastorage.org/webt/mx/bo/e3/mxboe3llquz_vb46qalw6yir85m.png"></p><br><p>  Ketika kami memperkenalkan pendekatan ini, CI (Teamcity), yang meluncurkan perubahan ke server integrasi, turun 8 kali dari 10. Tidak ada yang memperhatikannya karena tidak ada umpan balik.  Untuk pengembang, proses ini telah diimplementasikan untuk waktu yang lama, tetapi pesan tidak mencapai OPS (administrator sistem).  Oleh karena itu, kami menambahkan Dashboard dengan rakitan proyek ini ke monitor besar di tempat yang menonjol di kantor.  Di atasnya, berbagai proyek disorot dalam <strong>warna hijau</strong> - ini berarti bahwa segala sesuatunya sesuai dengannya.  Jika disorot dengan <strong>warna merah</strong> berarti semuanya buruk dengannya.  Kami melihat bahwa beberapa tes gagal.  Pada presentasi, di sisi kiri yang kedua, dari atas kita melihat hasil dari depot penyebaran infrastruktur.    .  ,    ,    ,   . :  -    .    .    Slack    ,   - - -    . </p><br><p><img src="https://habrastorage.org/webt/3b/bw/l1/3bbwl1jej_cien9satd3epefgqi.png"></p><br><p> Ok,     ,   ,    -  ,         .   trunk based .   Master  —    .    Master  CI  (Teamcity)    integration .    CI  ,           integration .  release candidate.      .        .   ,  end-to-end  ,          staging .     production.         ,  staging     . </p><br><p><img src="https://habrastorage.org/webt/ut/lg/rb/utlgrbwe6gtssxn-ivmxwp3hpuc.png"></p><br><p>         .  ?   ,    PostgreSQL.      5     .    ,  .   1-2 .       .  ,  PostgreSQL      .      PostgreSQL  ,    staging, production 4 .   ,   ,         .          ,      .          - . </p><br><p><img src="https://habrastorage.org/webt/ts/28/cl/ts28clrdqnfeocxls1rudzn0k5i.png"></p><br><p>   git submodule     Ansible .       ,   .  git submodule  Ansible    .   inventories ,    .   30 .    git submodule         . </p><br><p><img src="https://habrastorage.org/webt/qx/y3/_w/qxy3_w7ra6n-35jnlc1oyhy_cew.png"></p><br><p>   :     ,           .   ,     ,     ,   staging    ,   . ,   ,   ,   ,   ,    ,     staging.       —    , ,    -  . </p><br><p><img src="https://habrastorage.org/webt/mv/lv/nb/mvlvnbmp76dzsemwy9xdkv8nzda.png"></p><br><p>      6 .  —   10  .            .      .    ,   . -    git submodule,         .      .      ,     ,      ,         .  ,       ,    . </p><br><p><img src="https://habrastorage.org/webt/tz/bm/n4/tzbmn4-jneygsmiecrtjudgw5ne.png"><br> . </p><br><p> -,   ,        :        ,   Ansible   git , : “ ,   - ”.     ?     git .   ,     .  100%  .  .       . </p><br><p>  ,     .    .   ,      RabbitMQ, ELK,    .     ,   ELK    .         ,  ,     ELK.    ELK,    ,    ELK  . </p><br><p>    ,    ,      ,   ,   .     , , ,   ,  .         ,     .       . </p><br><p>    .   ,    ,     ,  ,   ,  ,   .           git.    ,     —    git,   ,  :     ,   -    .     . </p><br><p>   ,       ,    ,     code review.   ,     ,   .  ,    .  ,   , ,  ,  ,   .   ,    :      .   .          .     ,   - - . </p><br><p>    ,    . </p><br><p> :     ,       git submodule,        .     - ,     latest .      inventories.    —   ,   .   , ,   ..  .  —    .      . </p><br><p> :    -   Ansible          ( A   B, B  C      A,      )?   ,     ? </p><br><p> :      .      .  ,   -    IP  ,       ,   ,     ,      .       . ,      ,    ,    ,     ,  .        ,    -   ,  , , RabbitMQ     RabbitMQ,      . -      ,   . </p><br><p> PS      github       .     github  .          <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github </a> —     Pull request   . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id438748/">https://habr.com/ru/post/id438748/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id438732/index.html">Pengukuran Radio Amatir: Analisis Sinyal Bus I2C</a></li>
<li><a href="../id438734/index.html">Kusut orang-orang yang berpikiran sama</a></li>
<li><a href="../id438736/index.html">DevDay for Managers: Kelola TI</a></li>
<li><a href="../id438740/index.html">Mengelola Rahasia dengan HashiCorp Vault</a></li>
<li><a href="../id438746/index.html">Dalam perjalanan ke prinsip fisik evolusi biologis. Lanjutan</a></li>
<li><a href="../id438750/index.html">Peradaban Mata Air, 4/5</a></li>
<li><a href="../id438752/index.html">Akuntansi langsung di bank: cara membuat pengusaha individu bahagia</a></li>
<li><a href="../id438754/index.html">Bagaimana kami melakukan pemantauan jaringan untuk 14.000 objek</a></li>
<li><a href="../id438756/index.html">Periksa Chromium Keenam, Kata Penutup</a></li>
<li><a href="../id438758/index.html">Mengapa Google mengubah antarmuka URL standar di browser</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>