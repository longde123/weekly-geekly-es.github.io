<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏼‍⚖️ 🐶 👐🏻 MVCC di PostgreSQL-6. Vakum 🥕 🐃 🕹️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kami mulai dengan masalah yang berkaitan dengan isolasi , membuat penyimpangan tentang struktur data tingkat rendah , kemudian membahas versi baris da...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MVCC di PostgreSQL-6. Vakum</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/484106/">  Kami mulai dengan masalah yang berkaitan dengan <a href="https://habr.com/ru/company/postgrespro/blog/467437/">isolasi</a> , membuat penyimpangan tentang <a href="https://habr.com/ru/company/postgrespro/blog/469087/">struktur data tingkat rendah</a> , kemudian membahas <a href="https://habr.com/ru/company/postgrespro/blog/477648/">versi baris</a> dan mengamati bagaimana <a href="https://habr.com/ru/company/postgrespro/blog/479512/">snapshot data</a> diperoleh dari versi baris. <br><br>  <a href="https://habr.com/ru/company/postgrespro/blog/483768/">Terakhir kali</a> kami berbicara tentang pembaruan HOT dan penyedotan halaman, dan hari ini kami akan melanjutkan ke <em>vacuum vulgaris yang</em> terkenal.  Sungguh, sudah banyak yang telah ditulis tentang hal itu sehingga saya hampir tidak dapat menambahkan sesuatu yang baru, tetapi keindahan dari gambar penuh membutuhkan pengorbanan.  Jadi, bersabarlah. <br><br><h1>  Vakum </h1><br><h2>  Apa yang dilakukan dengan vakum? </h2><br>  Vakum dalam halaman berfungsi dengan cepat, tetapi hanya membebaskan sebagian ruang.  Ini berfungsi dalam satu halaman tabel dan tidak menyentuh indeks. <br><br>  Dasar, vakum "normal" dilakukan dengan menggunakan perintah VACUUM, dan kami akan menyebutnya hanya "vakum" (meninggalkan "autovacuum" untuk diskusi terpisah). <br><br>  Jadi, proses vakum seluruh tabel.  Ini mengosongkan tidak hanya tupel mati, tetapi juga referensi untuk mereka dari semua indeks. <br><br>  Penghisapan debu bersamaan dengan kegiatan lain dalam sistem.  Tabel dan indeks dapat digunakan secara teratur baik untuk membaca dan memperbarui (namun, eksekusi perintah bersamaan seperti CREATE INDEX, ALTER TABLE dan beberapa lainnya tidak mungkin). <br><br>  Hanya halaman-halaman tabel yang dilihat melalui tempat beberapa kegiatan berlangsung.  Untuk mendeteksinya, <em>peta visibilitas</em> digunakan (untuk mengingatkan Anda, peta melacak halaman-halaman yang berisi tupel yang cukup tua, yang terlihat jelas di semua snapshot data).  Hanya halaman tersebut yang diproses yang tidak dilacak oleh peta visibilitas, dan peta itu sendiri akan diperbarui. <br><br>  <em>Peta ruang bebas</em> juga akan diperbarui dalam proses untuk mencerminkan ruang bebas tambahan di halaman. <br><a name="habracut"></a><br>  Seperti biasa, mari kita buat tabel: <br><br><pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> vac( id <span class="hljs-type"><span class="hljs-type">serial</span></span>, s <span class="hljs-type"><span class="hljs-type">char</span></span>(<span class="hljs-number"><span class="hljs-number">100</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> (autovacuum_enabled = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> vac_s <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> vac(s); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> vac(s) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'A'</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> vac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'B'</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> vac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'C'</span></span>;</code> </pre> <br>  Kami menggunakan parameter <em>autovacuum_enabled</em> untuk mematikan proses autovacuum.  Kami akan membahasnya lain kali, dan sekarang sangat penting bagi percobaan kami bahwa kami mengontrol penyedotan debu secara manual. <br><br>  Tabel sekarang memiliki tiga tupel, yang masing-masing dirujuk dari indeks: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | hhu | hot | t_ctid -------+--------+----------+----------+-----+-----+-------- (0,1) | normal | 4000 (c) | 4001 (c) | | | (0,2) (0,2) | normal | 4001 (c) | 4002 | | | (0,3) (0,3) | normal | 4002 | 0 (a) | | | (0,3) (3 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> index_page(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><pre> <code class="plaintext hljs"> itemoffset | ctid ------------+------- 1 | (0,1) 2 | (0,2) 3 | (0,3) (3 rows)</code> </pre><br>  Setelah menyedot debu, tuple mati disedot, dan hanya satu, hidup, tuple tetap.  Dan hanya satu referensi yang tersisa dalam indeks: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> vac; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | hhu | hot | t_ctid -------+--------+----------+-------+-----+-----+-------- (0,1) | unused | | | | | (0,2) | unused | | | | | (0,3) | normal | 4002 (c) | 0 (a) | | | (0,3) (3 rows)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> index_page(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><pre> <code class="plaintext hljs"> itemoffset | ctid ------------+------- 1 | (0,3) (1 row)</code> </pre><br>  Perhatikan bahwa dua petunjuk pertama memperoleh status "tidak digunakan" alih-alih "mati", yang akan mereka peroleh dengan kekosongan halaman. <br><br><h2>  Tentang cakrawala transaksi sekali lagi </h2><br>  Bagaimana PostgreSQL mengetahui tupel mana yang dapat dianggap mati?  Kami sudah menyentuh konsep horizon transaksi ketika membahas <a href="https://habr.com/ru/company/postgrespro/blog/479512/">snapshot data</a> , tetapi tidak ada salahnya untuk mengulangi masalah penting tersebut. <br><br>  Mari kita mulai eksperimen sebelumnya lagi. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">TRUNCATE</span></span> vac; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> vac(s) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'A'</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> vac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'B'</span></span>;</code> </pre><br>  Tetapi sebelum memperbarui baris sekali lagi, biarkan satu lagi transaksi dimulai (tetapi tidak berakhir).  Dalam contoh ini, ia akan menggunakan tingkat Komitmen Baca, tetapi harus mendapatkan nomor transaksi yang benar (bukan virtual).  Sebagai contoh, transaksi dapat mengubah dan bahkan mengunci baris tertentu di tabel apa pun, bukan <code>vac</code> wajib: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> s <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span>;</code> </pre><pre> <code class="plaintext hljs">| s | ----- | FOO | BAR | (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> vac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'C'</span></span>;</code> </pre><br>  Ada tiga baris dalam tabel dan tiga referensi dalam indeks sekarang.  Apa yang akan terjadi setelah menyedot debu? <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> vac; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | hhu | hot | t_ctid -------+--------+----------+----------+-----+-----+-------- (0,1) | unused | | | | | (0,2) | normal | 4005 (c) | 4007 (c) | | | (0,3) (0,3) | normal | 4007 (c) | 0 (a) | | | (0,3) (3 rows)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> index_page(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><pre> <code class="plaintext hljs"> itemoffset | ctid ------------+------- 1 | (0,2) 2 | (0,3) (2 rows)</code> </pre><br>  Dua tuple tetap ada dalam tabel: VACUUM memutuskan bahwa tuple (0,2) belum dapat disedot.  Alasannya tentu saja dalam cakrawala transaksi dari basis data, yang dalam contoh ini ditentukan oleh transaksi yang tidak selesai: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> backend_xmin <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_activity <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs">| backend_xmin | -------------- | 4006 | (1 row)</code> </pre><br>  Kami dapat meminta VACUUM untuk melaporkan apa yang terjadi: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VERBOSE</span></span> vac;</code> </pre><pre> <code class="plaintext hljs">INFO: vacuuming "public.vac" INFO: index "vac_s" now contains 2 row versions in 2 pages DETAIL: 0 index row versions were removed. 0 index pages have been deleted, 0 are currently reusable. CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s. INFO: "vac": found 0 removable, 2 nonremovable row versions in 1 out of 1 pages DETAIL: 1 dead row versions cannot be removed yet, oldest xmin: 4006 There were 1 unused item pointers. Skipped 0 pages due to buffer pins, 0 frozen pages. 0 pages are entirely empty. CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s. VACUUM</code> </pre><br>  Perhatikan bahwa: <br><br><ul><li>  <code>2 nonremovable row versions</code> yang tidak dapat dihapus - dua tupel yang tidak dapat dihapus ditemukan dalam tabel. </li><li>  <code>1 dead row versions cannot be removed yet</code> - salah satunya mati. </li><li>  <code>oldest xmin</code> menunjukkan cakrawala saat ini. </li></ul><br>  Mari kita ulangi kesimpulannya: jika sebuah database memiliki transaksi yang berumur panjang (tidak selesai atau dilakukan sangat lama), ini dapat menyebabkan penggembungan tabel terlepas dari seberapa sering penyedotan terjadi.  Oleh karena itu, beban kerja tipe OLTP dan OLAP buruk hidup berdampingan dalam satu database PostgreSQL: laporan yang berjalan berjam-jam tidak akan membiarkan tabel yang diperbarui disedot debu secara tepat.  Pembuatan replika terpisah untuk tujuan pelaporan dapat menjadi solusi yang memungkinkan untuk ini. <br><br>  Setelah menyelesaikan transaksi terbuka, cakrawala bergerak, dan situasinya diperbaiki: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VERBOSE</span></span> vac;</code> </pre><pre> <code class="plaintext hljs">INFO: vacuuming "public.vac" INFO: scanned index "vac_s" to remove 1 row versions DETAIL: CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s INFO: "vac": removed 1 row versions in 1 pages DETAIL: CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s INFO: index "vac_s" now contains 1 row versions in 2 pages DETAIL: 1 index row versions were removed. 0 index pages have been deleted, 0 are currently reusable. CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s. INFO: "vac": found 1 removable, 1 nonremovable row versions in 1 out of 1 pages DETAIL: 0 dead row versions cannot be removed yet, oldest xmin: 4008 There were 1 unused item pointers. Skipped 0 pages due to buffer pins, 0 frozen pages. 0 pages are entirely empty. CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s. VACUUM</code> </pre><br>  Sekarang hanya versi terbaru, langsung, baris yang tersisa di halaman: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | hhu | hot | t_ctid -------+--------+----------+-------+-----+-----+-------- (0,1) | unused | | | | | (0,2) | unused | | | | | (0,3) | normal | 4007 (c) | 0 (a) | | | (0,3) (3 rows)</code> </pre><br>  Indeks ini juga hanya memiliki satu baris: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> index_page(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><pre> <code class="plaintext hljs"> itemoffset | ctid ------------+------- 1 | (0,3) (1 row)</code> </pre><br><h2>  Apa yang terjadi di dalam? </h2><br>  Penyedot debu harus memproses tabel dan indeks secara bersamaan dan melakukan ini agar tidak mengunci proses lainnya.  Bagaimana bisa begitu? <br><br>  Semua dimulai dengan fase <strong>tumpukan pemindaian</strong> (peta visibilitas diperhitungkan, sebagaimana telah disebutkan).  Di halaman yang dibaca, tupel mati terdeteksi, dan <code>tid</code> mereka dituliskan ke array khusus.  Array disimpan dalam memori lokal dari proses vakum, di mana memori <em>maintenance_work_mem</em> dialokasikan untuk itu.  Nilai default dari parameter ini adalah 64 MB.  Perhatikan bahwa jumlah penuh memori dialokasikan sekaligus, daripada saat diperlukan.  Namun, jika tabelnya tidak besar, jumlah memori yang lebih kecil dialokasikan. <br><br>  Kemudian kita mencapai akhir tabel atau memori yang dialokasikan untuk array berakhir.  Dalam kedua kasus, fase <strong>indeks penyedotan</strong> dimulai.  Untuk tujuan ini, <em>setiap</em> indeks yang dibuat di atas tabel <em>dipindai sepenuhnya</em> untuk mencari baris yang merujuk pada tuple yang diingat.  Baris yang ditemukan dihilangkan dari halaman indeks. <br><br>  Di sini kita menghadapi yang berikut: indeks belum memiliki referensi untuk tupel mati, sementara tabel masih memilikinya.  Dan ini tidak bertentangan dengan apa pun: saat menjalankan kueri, kami tidak menekan tupel mati (dengan akses indeks) atau menolaknya pada pemeriksaan visibilitas (saat memindai tabel). <br><br>  Setelah itu, fase <strong>tumpukan debu</strong> dimulai.  Tabel dipindai kembali untuk membaca halaman yang sesuai, menyedotnya dari tupel yang diingat dan melepaskan pointer.  Kita dapat melakukan ini karena tidak ada referensi dari indeks lagi. <br><br>  Jika tabel tidak sepenuhnya dibaca selama siklus pertama, array dihapus dan semuanya diulang dari tempat kami mencapai. <br><br>  Singkatnya: <br><br><ul><li>  Tabel selalu dipindai dua kali. </li><li>  Jika menyedot debu menghapus begitu banyak tupel sehingga semuanya tidak sesuai dengan memori <em>maintenance_work_mem</em> ukuran, semua indeks akan dipindai sebanyak yang diperlukan. </li></ul><br>  Untuk tabel besar, ini membutuhkan banyak waktu dan menambah beban kerja sistem yang signifikan.  Tentu saja, pertanyaan tidak akan dikunci, tetapi input / output tambahan jelas tidak diinginkan. <br><br>  Untuk mempercepat proses, masuk akal untuk memanggil VACUUM lebih sering (sehingga tidak terlalu banyak tuple yang disedot setiap kali) atau mengalokasikan lebih banyak memori. <br><br>  Untuk dicatat dalam tanda kurung, dimulai dengan versi 11, PostgreSQL <a href="https://git.postgresql.org/gitweb/%3Fp%3Dpostgresql.git%3Ba%3Dcommit%3Bh%3D857f9c36cda520030381bd8c2af20adf0ce0e1d4">dapat melewati pemindaian indeks</a> kecuali jika ada kebutuhan yang mendesak.  Ini harus membuat hidup lebih mudah bagi pemilik tabel besar di mana baris hanya ditambahkan (tetapi tidak diubah). <br><br><h2>  Pemantauan </h2><br>  Bagaimana kita mengetahui bahwa VACUUM tidak dapat melakukan tugasnya dalam satu siklus? <br><br>  Kami telah melihat cara pertama: untuk memanggil perintah VACUUM dengan opsi VERBOSE.  Dalam hal ini, informasi tentang fase proses akan dikeluarkan ke konsol. <br><br>  Kedua, dimulai dengan versi 9.6, tampilan <code>pg_stat_progress_vacuum</code> tersedia, yang juga menyediakan semua informasi yang diperlukan. <br><br>  (Cara ketiga juga tersedia: untuk menampilkan informasi ke log pesan, tetapi ini hanya berfungsi untuk autovacuum, yang akan dibahas lain kali.) <br><br>  Mari kita sisipkan beberapa baris dalam tabel, untuk proses vakum berlangsung cukup lama, dan mari kita perbarui semuanya, agar VACUUM dapat melakukan sesuatu. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">TRUNCATE</span></span> vac; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> vac(s) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-string"><span class="hljs-string">'A'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">500000</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> vac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'B'</span></span>;</code> </pre><br>  Mari kita kurangi ukuran memori yang dialokasikan untuk array pengidentifikasi: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> maintenance_work_mem = <span class="hljs-string"><span class="hljs-string">'1MB'</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_reload_conf();</code> </pre><br>  Mari kita mulai VACUUM dan ketika sedang bekerja, mari kita akses tampilan <code>pg_stat_progress_vacuum</code> beberapa kali: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VERBOSE</span></span> vac;</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_progress_vacuum \gx</code> </pre><pre> <code class="plaintext hljs">| -[ RECORD 1 ]------+------------------ | pid | 6715 | datid | 41493 | datname | test | relid | 57383 | phase | vacuuming indexes | heap_blks_total | 16667 | heap_blks_scanned | 2908 | heap_blks_vacuumed | 0 | index_vacuum_count | 0 | max_dead_tuples | 174762 | num_dead_tuples | 174480</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_progress_vacuum \gx</code> </pre><pre> <code class="plaintext hljs">| -[ RECORD 1 ]------+------------------ | pid | 6715 | datid | 41493 | datname | test | relid | 57383 | phase | vacuuming indexes | heap_blks_total | 16667 | heap_blks_scanned | 5816 | heap_blks_vacuumed | 2907 | index_vacuum_count | 1 | max_dead_tuples | 174762 | num_dead_tuples | 174480</code> </pre><br>  Di sini kita dapat melihat, khususnya: <br><br><ul><li>  Nama fase saat ini - kami membahas tiga fase utama, tetapi ada <a href="https://postgrespro.com/docs/postgresql/11/progress-reporting">lebih banyak</a> dari mereka secara umum. </li><li>  Jumlah total halaman tabel ( <code>heap_blks_total</code> ). </li><li>  Jumlah halaman yang dipindai ( <code>heap_blks_scanned</code> ). </li><li>  Jumlah halaman yang sudah dihisap debu ( <code>heap_blks_vacuumed</code> ). </li><li>  Jumlah siklus vakum indeks ( <code>index_vacuum_count</code> ). </li></ul><br>  Kemajuan umum ditentukan oleh rasio <code>heap_blks_vacuumed</code> ke <code>heap_blks_total</code> , tetapi kita harus memperhitungkan bahwa nilai ini berubah dalam peningkatan besar daripada lancar karena pemindaian indeks.  Perhatian utama, bagaimanapun, harus diberikan pada jumlah siklus vakum: jumlah yang lebih besar dari 1 berarti bahwa memori yang dialokasikan tidak cukup untuk menyelesaikan proses vakum dalam satu siklus. <br><br>  Output dari perintah VACUUM VERBOSE, yang sudah selesai pada saat itu, akan menampilkan gambaran umum: <br><br><pre> <code class="plaintext hljs">INFO: vacuuming "public.vac"</code> </pre><pre> <code class="plaintext hljs">INFO: scanned index "vac_s" to remove 174480 row versions DETAIL: CPU: user: 0.50 s, system: 0.07 s, elapsed: 1.36 s INFO: "vac": removed 174480 row versions in 2908 pages DETAIL: CPU: user: 0.02 s, system: 0.02 s, elapsed: 0.13 s</code> </pre><pre> <code class="plaintext hljs">INFO: scanned index "vac_s" to remove 174480 row versions DETAIL: CPU: user: 0.26 s, system: 0.07 s, elapsed: 0.81 s INFO: "vac": removed 174480 row versions in 2908 pages DETAIL: CPU: user: 0.01 s, system: 0.02 s, elapsed: 0.10 s</code> </pre><pre> <code class="plaintext hljs">INFO: scanned index "vac_s" to remove 151040 row versions DETAIL: CPU: user: 0.13 s, system: 0.04 s, elapsed: 0.47 s INFO: "vac": removed 151040 row versions in 2518 pages DETAIL: CPU: user: 0.01 s, system: 0.02 s, elapsed: 0.08 s</code> </pre><pre> <code class="plaintext hljs">INFO: index "vac_s" now contains 500000 row versions in 17821 pages DETAIL: 500000 index row versions were removed. 8778 index pages have been deleted, 0 are currently reusable. CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s. INFO: "vac": found 500000 removable, 500000 nonremovable row versions in 16667 out of 16667 pages DETAIL: 0 dead row versions cannot be removed yet, oldest xmin: 4011 There were 0 unused item pointers. 0 pages are entirely empty. CPU: user: 1.10 s, system: 0.37 s, elapsed: 3.71 s. VACUUM</code> </pre><br>  Kita dapat melihat di sini bahwa tiga siklus atas indeks telah dilakukan, dan dalam setiap siklus, 174480 pointer ke tuple mati dihilangkan.  Kenapa tepatnya nomor ini?  Satu <code>tid</code> menempati 6 byte, dan 1024 * 1024/6 = 174762, yang merupakan angka yang kita lihat di <code>pg_stat_progress_vacuum.max_dead_tuples</code> .  Pada kenyataannya, sedikit lebih sedikit dapat digunakan: ini memastikan bahwa ketika halaman berikutnya dibaca, semua pointer ke tuple yang mati pasti sesuai dengan memori. <br><br><h2>  Analisis </h2><br>  Analisis, atau, dengan kata lain, mengumpulkan statistik untuk perencana kueri, secara formal tidak terkait dengan menyedot debu sama sekali.  Namun demikian, kita dapat melakukan analisis tidak hanya menggunakan perintah ANALYZE, tetapi menggabungkan penyedotan dan analisis dalam VACUUM ANALYZE.  Di sini kekosongan dilakukan pertama dan kemudian analisis, jadi ini tidak memberikan keuntungan. <br><br>  Tetapi seperti yang akan kita lihat nanti, autovacuum dan analisis otomatis dilakukan dalam satu proses dan dikendalikan dengan cara yang sama. <br><br><h1>  VACUUM FULL </h1><br>  Seperti disebutkan di atas, vakum membebaskan lebih banyak ruang daripada vakum dalam-halaman, tetapi tetap saja itu tidak sepenuhnya menyelesaikan masalah. <br><br>  Jika karena alasan tertentu ukuran tabel atau indeks telah meningkat banyak, VACUUM akan mengosongkan ruang di dalam halaman yang ada: "lubang" akan terjadi di sana, yang kemudian akan digunakan untuk memasukkan tupel baru.  Tetapi jumlah halaman tidak akan berubah, dan karena itu, dari sudut pandang sistem operasi, file akan menempati ruang yang sama persis seperti sebelum vakum.  Dan ini tidak baik karena: <br><br><ul><li>  Pemindaian penuh tabel (atau indeks) melambat. </li><li>  Cache penyangga yang lebih besar mungkin diperlukan (karena itu adalah halaman yang disimpan di sana dan kepadatan informasi yang berguna berkurang). </li><li>  Di pohon indeks, level tambahan dapat terjadi, yang akan memperlambat akses indeks. </li><li>  File menempati ruang ekstra pada disk dan dalam salinan cadangan. </li></ul><br>  (Satu-satunya pengecualian adalah halaman yang benar-benar menyedot debu, terletak di akhir file. Halaman ini dipangkas dari file dan dikembalikan ke sistem operasi.) <br><br>  Jika pembagian informasi yang berguna dalam file berada di bawah batas yang wajar, administrator dapat melakukan VACUUM FULL dari tabel.  Dalam hal ini, tabel dan semua indeksnya dibangun kembali dari awal dan datanya dikemas dengan cara yang sebagian besar ringkas (tentu saja, parameter <code>fillfactor</code> dipertimbangkan).  Selama proses pembangunan kembali, PostgreSQL pertama-tama membangun kembali tabel dan kemudian masing-masing indeks satu-per-satu.  Untuk setiap objek, file baru dibuat, dan file lama dihapus pada akhir pembangunan kembali.  Kita harus memperhitungkan bahwa ruang disk tambahan akan dibutuhkan dalam proses. <br><br>  Untuk mengilustrasikan ini, mari kita kembali memasukkan sejumlah baris ke dalam tabel: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">TRUNCATE</span></span> vac; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> vac(s) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-string"><span class="hljs-string">'A'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">500000</span></span>);</code> </pre><br>  Bagaimana kita bisa memperkirakan kepadatan informasi?  Untuk melakukan ini, lebih mudah menggunakan ekstensi khusus: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXTENSION</span></span> pgstattuple; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pgstattuple(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>) \gx</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]------+--------- table_len | 68272128 tuple_count | 500000 tuple_len | 64500000 tuple_percent | 94.47 dead_tuple_count | 0 dead_tuple_len | 0 dead_tuple_percent | 0 free_space | 38776 free_percent | 0.06</code> </pre><br>  Fungsi membaca seluruh tabel dan menunjukkan statistik: data mana yang menempati berapa banyak ruang dalam file.  Informasi utama yang kami minati sekarang adalah bidang <code>tuple_percent</code> : persentase data yang berguna.  Kurang dari 100 karena overhead informasi yang tak terhindarkan di dalam halaman, tetapi masih cukup tinggi. <br><br>  Untuk indeks, informasi yang berbeda adalah output, tetapi bidang <code>avg_leaf_density</code> memiliki arti yang sama: persentase informasi yang berguna (di halaman daun). <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pgstatindex(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>) \gx</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]------+--------- version | 3 tree_level | 3 index_size | 72802304 root_block_no | 2722 internal_pages | 241 leaf_pages | 8645 empty_pages | 0 deleted_pages | 0 avg_leaf_density | 83.77 leaf_fragmentation | 64.25</code> </pre><br>  Dan ini adalah ukuran tabel dan indeks: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_size_pretty(pg_table_size(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>)) table_size, pg_size_pretty(pg_indexes_size(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>)) index_size;</code> </pre><pre> <code class="plaintext hljs"> table_size | index_size ------------+------------ 65 MB | 69 MB (1 row)</code> </pre><br>  Sekarang mari kita hapus 90% dari semua baris.  Kami melakukan pilihan acak baris untuk dihapus, sehingga setidaknya satu baris sangat mungkin untuk tetap di setiap halaman: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">DELETE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> vac <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> random() &lt; <span class="hljs-number"><span class="hljs-number">0.9</span></span>;</code> </pre><pre> <code class="plaintext hljs">DELETE 450189</code> </pre><br>  Berapa ukuran benda setelah VACUUM? <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> vac; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_size_pretty(pg_table_size(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>)) table_size, pg_size_pretty(pg_indexes_size(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>)) index_size;</code> </pre><pre> <code class="plaintext hljs"> table_size | index_size ------------+------------ 65 MB | 69 MB (1 row)</code> </pre><br>  Kita dapat melihat bahwa ukurannya tidak berubah: VACUUM tidak mungkin mengurangi ukuran file.  Dan ini meskipun kepadatan informasi menurun sekitar 10 kali: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> vac.tuple_percent, vac_s.avg_leaf_density <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pgstattuple(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>) vac, pgstatindex(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>) vac_s;</code> </pre><pre> <code class="plaintext hljs"> tuple_percent | avg_leaf_density ---------------+------------------ 9.41 | 9.73 (1 row)</code> </pre><br>  Sekarang mari kita periksa apa yang kita dapatkan setelah VACUUM FULL.  Sekarang tabel dan indeks menggunakan file-file berikut: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_relation_filepath(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>), pg_relation_filepath(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> pg_relation_filepath | pg_relation_filepath ----------------------+---------------------- base/41493/57392 | base/41493/57393 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FULL</span></span> vac; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_relation_filepath(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>), pg_relation_filepath(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> pg_relation_filepath | pg_relation_filepath ----------------------+---------------------- base/41493/57404 | base/41493/57407 (1 row)</code> </pre><br>  File diganti dengan yang baru sekarang.  Ukuran tabel dan indeks menurun secara signifikan, sementara kepadatan informasi meningkat sesuai: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_size_pretty(pg_table_size(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>)) table_size, pg_size_pretty(pg_indexes_size(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>)) index_size;</code> </pre><pre> <code class="plaintext hljs"> table_size | index_size ------------+------------ 6648 kB | 6480 kB (1 row)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> vac.tuple_percent, vac_s.avg_leaf_density <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pgstattuple(<span class="hljs-string"><span class="hljs-string">'vac'</span></span>) vac, pgstatindex(<span class="hljs-string"><span class="hljs-string">'vac_s'</span></span>) vac_s;</code> </pre><pre> <code class="plaintext hljs"> tuple_percent | avg_leaf_density ---------------+------------------ 94.39 | 91.08 (1 row)</code> </pre><br>  Perhatikan bahwa kepadatan informasi dalam indeks bahkan lebih besar daripada yang asli.  Lebih menguntungkan untuk membangun kembali indeks (B-tree) dari data yang tersedia daripada memasukkan data dalam indeks baris demi baris yang ada. <br><br>  Fungsi ekstensi <a href="https://postgrespro.com/docs/postgresql/11/pgstattuple">pgstattuple</a> yang kami gunakan membaca seluruh tabel.  Tapi ini merepotkan jika tabelnya besar, sehingga ekstensi memiliki fungsi <code>pgstattuple_approx</code> , yang melompati halaman yang ditandai di peta visibilitas dan menunjukkan angka perkiraan. <br><br>  Satu lagi cara, tetapi bahkan kurang akurat, adalah dengan menggunakan katalog sistem untuk memperkirakan secara kasar rasio ukuran data dengan ukuran file.  Anda dapat menemukan contoh pertanyaan seperti itu <a href="https://wiki.postgresql.org/wiki/Show_database_bloat">di wiki</a> . <br><br>  VACUUM FULL tidak dimaksudkan untuk penggunaan biasa karena ia memblokir semua pekerjaan dengan tabel (termasuk kueri) untuk semua durasi proses.  Sudah jelas bahwa untuk sistem yang banyak digunakan, ini mungkin tampak tidak dapat diterima.  Kunci akan dibahas secara terpisah, dan sekarang kami hanya akan menyebutkan ekstensi <a href="https://github.com/reorg/pg_repack">pg_repack</a> , yang mengunci tabel hanya untuk jangka waktu singkat di akhir pekerjaan. <br><br><h2>  Perintah serupa </h2><br>  Ada beberapa perintah yang juga sepenuhnya membangun kembali tabel dan indeks dan karenanya menyerupai VACUUM FULL.  Semuanya sepenuhnya memblokir semua pekerjaan dengan tabel, mereka semua menghapus file data lama dan membuat yang baru. <br><br>  Perintah CLUSTER semuanya mirip dengan VACUUM FULL, tetapi juga secara fisik memesan tupel menurut salah satu indeks yang tersedia.  Ini memungkinkan perencana untuk menggunakan akses indeks lebih efisien dalam beberapa kasus.  Tetapi kita harus ingat bahwa pengelompokan tidak dipertahankan: tatanan fisik tupel akan rusak dengan perubahan tabel selanjutnya. <br><br>  Perintah REINDEX membangun kembali indeks terpisah di atas meja.  VACUUM FULL dan CLUSTER sebenarnya menggunakan perintah ini untuk membangun kembali indeks. <br><br>  Logika dari perintah TRUNCATE mirip dengan DELETE - ia menghapus semua baris tabel.  Tapi HAPUS, seperti yang telah disebutkan, hanya menandai tupel sebagai dihapus, dan ini membutuhkan penyedotan lebih lanjut.  Dan TRUNCATE hanya membuat file baru yang bersih.  Sebagai aturan, ini bekerja lebih cepat, tetapi kami harus memikirkan bahwa TRUNCATE akan memblokir semua pekerjaan dengan tabel hingga akhir transaksi. <br><br>  <a href="https://habr.com/ru/company/postgrespro/blog/486104/">Baca terus</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id484106/">https://habr.com/ru/post/id484106/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id484092/index.html">Agak berpakaian pangeran dan bangsawan</a></li>
<li><a href="../id484094/index.html">Buat penembak zombie orang ketiga dengan DOTS</a></li>
<li><a href="../id484096/index.html">Pertempuran dua Yakozun, atau Cassandra vs HBase. Pengalaman tim Sberbank</a></li>
<li><a href="../id484100/index.html">Bekerja dengan antarmuka di Google Maps SDK untuk Android</a></li>
<li><a href="../id484102/index.html">PHP vs Python vs Ruby on Rails: Perbandingan Lengkap</a></li>
<li><a href="../id484108/index.html">Etherblade.net Encapsulator dan Substitusi Impor untuk Komponen Jaringan (Bagian Dua)</a></li>
<li><a href="../id484112/index.html">Apakah mungkin untuk meretas pesawat</a></li>
<li><a href="../id484114/index.html">Pilihan 143 terjemahan esai Paul Graham (dari 184)</a></li>
<li><a href="../id484118/index.html">32 Januari</a></li>
<li><a href="../id484120/index.html">Keterampilan yang paling dicari dalam profesi insinyur data</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>