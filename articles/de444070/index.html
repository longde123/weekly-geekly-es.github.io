<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üïµüèΩ üÉè üí¥ Entwicklung eines Hexapods von Grund auf neu (Teil 4) - mathematische Trajektorien und Sequenzen üÖæÔ∏è üóæ ‚ùé</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo allerseits! Die Hexapod-Entwicklung ist noch einen Schritt weiter gegangen. Dieses Mal werden die Trajektorien der Bewegung der Gliedma√üen imple...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Entwicklung eines Hexapods von Grund auf neu (Teil 4) - mathematische Trajektorien und Sequenzen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444070/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/ft/93/m5/ft93m5szh_bfaxkmnxialxpkoiu.png"></div><br>  Hallo allerseits!  Die Hexapod-Entwicklung ist noch einen Schritt weiter gegangen.  Dieses Mal werden die Trajektorien der Bewegung der Gliedma√üen implementiert und getestet - der n√§chste Teil der Bewegungsmathematik.  In diesem Artikel werde ich √ºber diese Trajektorien und grundlegenden Bewegungsabl√§ufe sprechen.  Ich hoffe es wird interessant. <br><br>  <b>Entwicklungsstadien:</b> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1 - Design</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2 - Montage</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3 - Kinematik</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><b>Teil 4 - mathematische Trajektorien und Sequenzen</b></a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 5 - Elektronik</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 6 - √úbergang zum 3D-Druck</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 7 - Neues Geh√§use, Anwendungssoftware und Kommunikationsprotokolle</a> <br><a name="habracut"></a><br><h2>  Flugbahnen </h2><br>  Das Wesentliche an diesem Mechanismus ist, dass Sie beim Setzen von zwei Punkten die Flugbahn der Extremit√§t ausw√§hlen k√∂nnen.  Beim √úbergang von einem Punkt zum anderen √§ndern sich die Koordinaten gem√§√ü bestimmten parametrischen Gleichungen.  Der Mechanismus erwies sich als ziemlich leistungsf√§hig und erm√∂glicht es Ihnen, interessante Kurven f√ºr die Bewegung zu erhalten.  Es implementiert auch eine Gl√§ttung von Bewegungen durch √Ñndern des Schritts des Parameters t - je kleiner der Schritt, desto mehr Zwischenpunkte gibt es, desto niedriger ist die Geschwindigkeit und desto glatter ist die Bewegung. <br><br>  Das Verfahren zum Einstellen der Parameter der Flugbahn ist an einigen Stellen etwas unverst√§ndlich und kann verwirrt sein.  Die Schwierigkeit liegt in der Tatsache, dass beim Festlegen der Koordinaten der Start- und Endpunkte die Koordinaten der realen Punkte im Raum nicht immer festgelegt werden, d. H.  Einige Koordinaten legen die Trajektorienparameter fest.  Ich musste ein Programm schreiben, das einen bestimmten Pfad anzeigt und gleichzeitig die Erreichbarkeit jedes Punkts des Pfads √ºberpr√ºft. <br><br>  Der Treiber unterst√ºtzt die folgenden Bewegungspfade: <br><br><ol><li>  <b>XYZ_LINAR</b> ist die einfachste aller Trajektorien.  Die Flugbahn wird verwendet, wenn Sie sich vorw√§rts, r√ºckw√§rts, auf und ab bewegen.  Alle Koordinaten √§ndern sich linear und werden wie folgt berechnet: <br><br><pre><code class="cpp hljs">x = t * (x1 - x0) / <span class="hljs-number"><span class="hljs-number">180.0f</span></span> + x0; y = t * (y1 - y0) / <span class="hljs-number"><span class="hljs-number">180.0f</span></span> + y0; z = t * (z1 - z0) / <span class="hljs-number"><span class="hljs-number">180.0f</span></span> + z0;</code> </pre> <br>  Hier verstehen wir, dass es keine Probleme gibt.  Die Koordinaten geben die Parallelepipedwinkel an und stimmen mit den realen Koordinaten √ºberein.  Die Bewegung erfolgt entlang der Diagonale der Box. <br><br><div class="spoiler">  <b class="spoiler_title">Trajektorienvisualisierung</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/t5/55/uy/t555uy9zum9cfwqa6hw4gwotdni.png"><br><img src="https://habrastorage.org/webt/bn/2n/p-/bn2np-sm7n7onhmvariez7_0jy4.png"><br><img src="https://habrastorage.org/webt/5p/g6/yw/5pg6yw_fpcqdxnr4lotb-n0so4u.png"><br></div></div><br></li><li>  <b>YZ_ARC_Y_LINEAR</b> - Mit dieser Trajektorie k√∂nnen Sie Bewegungen entlang eines Bogens implementieren.  Die Flugbahn wird beim Wenden verwendet, wenn Sie ein Glied auf dem Boden bewegen m√ºssen.  Die Koordinaten werden wie folgt berechnet: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> R = <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(x0 * x0 + z0 * z0); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> atan0 = RAD_TO_DEG(<span class="hljs-built_in"><span class="hljs-built_in">atan2</span></span>(x0, z0)); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> atan1 = RAD_TO_DEG(<span class="hljs-built_in"><span class="hljs-built_in">atan2</span></span>(x1, z1)); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t_mapped_rad = DEG_TO_RAD(t * (atan1 - atan0) / <span class="hljs-number"><span class="hljs-number">180.0f</span></span> + atan0); x = R * <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(t_mapped_rad); <span class="hljs-comment"><span class="hljs-comment">// Circle Y y = t * (y1 - y0) / 180.0f + y0; z = R * cos(t_mapped_rad); // Circle X</span></span></code> </pre><br>  Hier beginnt der Spa√ü.  Die Koordinaten geben die Richtung der Strahlen an, um den Bogen zu begrenzen, und sie stimmen m√∂glicherweise nicht mit den tats√§chlichen Koordinaten √ºberein.  Die Strahlen befinden sich in derselben Ebene, w√§hrend der Radius des Kreises gleich der L√§nge des Vektors zum Startpunkt ist. <br><br><div class="spoiler">  <b class="spoiler_title">Trajektorienvisualisierung</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/ky/p0/dw/kyp0dwzfg-0t_qsrmwvstiwlweq.png"><br><br><img src="https://habrastorage.org/webt/ak/ng/ey/akngeyx2imiyht44jebbuydxyaw.png"><br></div></div><br></li><li>  <b>XZ_ARC_Y_SINUS</b> - Mit dieser Trajektorie k√∂nnen Sie auch Bewegungen entlang eines Bogens implementieren, die jedoch komplexer sind als YZ_ARC_Y_LINEAR.  Die Flugbahn wird beim Wenden verwendet, wenn Sie ein Glied durch die Luft bewegen m√ºssen.  Die Koordinaten werden wie folgt berechnet: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> R = <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(x0 * x0 + z0 * z0); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> atan0 = RAD_TO_DEG(<span class="hljs-built_in"><span class="hljs-built_in">atan2</span></span>(x0, z0)); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> atan1 = RAD_TO_DEG(<span class="hljs-built_in"><span class="hljs-built_in">atan2</span></span>(x1, z1)); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t_mapped_rad = DEG_TO_RAD(t * (atan1 - atan0) / <span class="hljs-number"><span class="hljs-number">180.0f</span></span> + atan0); x = R * <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(t_mapped_rad); <span class="hljs-comment"><span class="hljs-comment">// circle Y y = (y1 - y0) * sin(DEG_TO_RAD(t)) + y0; z = R * cos(t_mapped_rad); // circle X</span></span></code> </pre><br>  Der Spa√ü geht weiter.  Die Koordinaten geben auch die Richtung der Strahlen an, um den Bogen zu begrenzen, stimmen jedoch NICHT mit den tats√§chlichen Koordinaten √ºberein.  Die Y-Koordinate des Zielpunkts legt die Sinush√∂he fest. <br><br><div class="spoiler">  <b class="spoiler_title">Trajektorienvisualisierung</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/t6/2g/tf/t62gtfnlk7nwgibcchhawz2ug4e.png"><br></div></div><br></li><li>  <b>XZ_ELLIPTICAL_Y_SINUS</b> - Mit dieser Trajektorie k√∂nnen Sie Bewegungen entlang einer Ellipse implementieren.  Die Flugbahn wird verwendet, wenn Sie sich vorw√§rts und r√ºckw√§rts bewegen, wenn Sie ein Glied durch die Luft bewegen m√ºssen.  Diese Flugbahn ist eine Komplikation von XZ_ARC_Y_SINUS und wurde nur wegen des visuell h√§sslichen Gangs bei Verwendung von XZ_ARC_Y_SINUS ben√∂tigt (Beine zu stark gestreckt).  Die Koordinaten werden wie folgt berechnet: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> a = (z1 - z0) / <span class="hljs-number"><span class="hljs-number">2.0f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> b = (x1 - x0); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> c = (y1 - y0); x = b * <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(DEG_TO_RAD(<span class="hljs-number"><span class="hljs-number">180.0f</span></span> - t)) + x0; <span class="hljs-comment"><span class="hljs-comment">// circle Y y = c * sin(DEG_TO_RAD(t)) + y0; z = a * cos(DEG_TO_RAD(180.0f - t)) + z0 + a;</span></span></code> </pre><br>  Die Koordinaten geben die Parallelepipedwinkel an und stimmen NICHT mit den realen Koordinaten √ºberein.  Die Bewegung erfolgt von den unteren Ecken des Kastens aus, die sich in derselben Ebene befinden wie das Ber√ºhren der Oberseite seines Teils.  Es ist besser, sich das Bild im Spoiler anzusehen, ich wei√ü nicht, wie ich es kurz in Worten beschreiben soll. <br><br><div class="spoiler">  <b class="spoiler_title">Trajektorienvisualisierung</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/pn/3x/4w/pn3x4wot6ajk1ofy4wl7rtjyp1y.png"><br></div></div></li></ol><br>  Dies vervollst√§ndigt die grundlegende Mathematik der Bewegung des Hexapods.  In meinem Projekt ist dies ein notwendiges Minimum f√ºr die Umsetzung fast jeder Bewegung. <br><br><h2>  Sequenzen </h2><br><h3>  Ein bisschen Theorie </h3><br>  Sequenzen sind die elementaren Aktionen, aus denen sich der Gang zusammensetzt.  Sie sind in zyklische und nichtzyklische unterteilt. <br><br><ul><li>  Zyklische Sequenzen k√∂nnen viele Male ausgef√ºhrt werden und sollten am Ende jedes Zyklus die Gliedma√üen in ihre urspr√ºngliche Position zur√ºckbringen (Bewegung und Drehung); </li><li>  Nichtzyklische Sequenzen werden nur einmal durchgef√ºhrt (Auf- und Abstieg); </li></ul><br>  Jede Sequenz hat drei Iterationsbl√∂cke: Vorbereitungsblock, Hauptblock, Abschlussblock. <br><br><ul><li>  Trainingsblock - enth√§lt Iterationen, um die Gliedma√üen in die Ausgangsposition f√ºr die Sequenz zu bewegen.  In meinem Fall erfordert das Vorw√§rtsbewegen, dass Sie Ihre Beine in eine bestimmte Position bringen, bevor Sie sich bewegen.  Es wird einmal beim √úbergang zur Sequenz ausgef√ºhrt; </li><li>  Hauptblock - enth√§lt die Hauptiteration der Sequenz.  Es kann zyklisch durchgef√ºhrt werden; </li><li>  Blockvervollst√§ndigung - enth√§lt Iterationen zum Bewegen der Gliedma√üen in die Basisposition (die Position, in der die Gliedma√üen nach dem Anheben eingestellt werden); </li></ul><br>  Die folgende Abbildung zeigt die Reihenfolge f√ºr das Vorw√§rtsbewegen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yt/yf/vw/ytyfvwd1slowqjmordig0qenioa.png"></div><br><ul><li>  Rote Punkte zeigen die Ausgangsposition der Gliedma√üen an, bevor sie sich bewegen </li><li>  Blaue Linien zeigen die Flugbahnen der Extremit√§t am Boden an </li><li>  Die schwarzen Linien zeigen die Flugbahnen des Gliedes in der Luft an </li><li>  Die Pfeile geben die Reihenfolge an </li></ul><br>  Die Koordinaten der Punkte werden basierend auf der Konfiguration des Geh√§uses ausgew√§hlt.  Ich habe die Punkte so nah wie m√∂glich am K√∂rper gew√§hlt, um die L√§nge des Hebels zu verringern.  In einem Zyklus der Sequenz bewegt sich der Hexapod um 18 cm (in 1 Zyklus werden 2 Schritte ausgef√ºhrt - 1 Schritt in 3 Gliedma√üen).  Wenn Sie den Abstand vergr√∂√üern, klammern sich die Gliedma√üen aneinander.  Dieser Parameter ist nur durch die Fallkonfiguration begrenzt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/67/hs/0b/67hs0bhvmyfefjvvxyb0qh0lojy.png"></div><br>  Die Sequenz wird durch zwei Punkte (1, 2) f√ºr jedes Glied definiert und zwei Pfade werden verwendet: XYZ_LINEAR (blaue Linien) und XZ_ELLIPTICAL_Y_SINUS (schwarze Linien).  Punkt 1 wird von der XZ_ELLIPTICAL_Y_SINUS-Trajektorie verwendet, um die Sinush√∂he und dementsprechend die H√∂he festzulegen, auf die der Fu√ü steigt.  Die Punkte 2 und 3 sind echte Punkte, die ein Glied beim Bewegen erreicht. <br><br>  Die Position der Punkte h√§ngt nur von Ihrer Vorstellungskraft und den F√§higkeiten des Hexapods ab.  Vielleicht hat sich alles als etwas kompliziert herausgestellt und es gibt eine einfachere Option, aber anscheinend habe ich sie noch nicht erreicht. <br><br><h3>  Implementierung </h3><br>  Schauen wir uns nun die Umsetzung all dieses Gl√ºcks an.  Strukturen mit Sequenzparametern sind wie folgt: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">point_3d_t</span></span> point_list[SUPPORT_LIMB_COUNT]; <span class="hljs-keyword"><span class="hljs-keyword">path_type_t</span></span> path_list[SUPPORT_LIMB_COUNT]; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> smooth_point_count; } <span class="hljs-keyword"><span class="hljs-keyword">sequence_iteration_t</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> is_sequence_looped; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> main_sequence_begin; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> finalize_sequence_begin; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> total_iteration_count; <span class="hljs-keyword"><span class="hljs-keyword">sequence_iteration_t</span></span> iteration_list[<span class="hljs-number"><span class="hljs-number">15</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">sequence_id_t</span></span> available_sequences[SUPPORT_SEQUENCE_COUNT]; } <span class="hljs-keyword"><span class="hljs-keyword">sequence_info_t</span></span>;</code> </pre> <br>  <b>sequence_iteration_t</b> - enth√§lt Informationen zur Iteration der Sequenz: <br><br><ul><li>  point_list - ein Array von Punkten f√ºr jedes Glied im XYZ-Format; </li><li>  path_list - ein Array von Trajektorien f√ºr jedes Glied; </li><li>  ooth_point_count - legt die Anzahl der Pfadpunkte fest (Parameterschritt t); </li></ul><br>  <b>sequence_info_t</b> - enth√§lt Informationen zur gesamten Sequenz: <br><br><ul><li>  is_sequence_looped - legt den Sequenztyp fest: zyklisch oder nicht; </li><li>  main_sequence_begin - legt den Startindex des Hauptblocks im Array iteration_list fest; </li><li>  finalize_sequence_begin - legt den Startindex des Abschlussblocks im Array iteration_list fest; </li><li>  total_iteration_count - Legt die Anzahl der Iterationen in der Sequenz fest. </li><li>  iteration_list - ein Array von Iterationen; </li><li>  available_sequences - Legt die Liste der Sequenzen fest, die f√ºr den √úbergang von der aktuellen Sequenz verf√ºgbar sind (z. B. k√∂nnen wir nicht mit dem Gehen beginnen, ohne zuerst vom Boden aufzustehen). </li></ul><br>  <i>HINWEIS: Der Index des Vorbereitungsblocks wird nicht absichtlich angegeben, sondern befindet sich immer am Anfang des Iterationsarrays.</i> <i><br></i> <br>  Leider kann ich hier keinen Code zur Bestimmung der Reihenfolge angeben, da  es ist ziemlich breit und sieht nach Transfers schrecklich aus.  Ich hinterlasse hier nur einen Link zur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Definitionsdatei</a> . <br><br><h3>  Bewegungsverarbeitungsschema </h3><br>  Es lohnt sich, alle H√∂llenkreise zu erkennen, die die Sequenz zur Laufzeit durchl√§uft.  Das Verarbeitungsschema ist wie folgt: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hz/bd/h-/hzbdh-sihkvi9t9lmxn73igosv8.png"></div><br><ol><li>  <b>MOVEMENT ENGINE</b> - organisiert die Verarbeitung und das Umschalten zwischen Sequenzen.  Dort werden keine Berechnungen durchgef√ºhrt.  Wenn vereinfacht, verschiebt dieses Modul den n√§chsten Punkt zum LIBMS DRIVER-Modul, nachdem die aktuelle Verarbeitung abgeschlossen ist. <br>  <i>Moduleingabe: Array von Koordinaten der Zielpunkte.</i> <i><br></i>  <i>Modulausgabe: Zielpunkt f√ºr die aktuelle Iteration der Sequenz.</i> </li><li>  <b>LIBMS DRIVER</b> ist das komplexeste aller Module.  Hier herrscht die gesamte Bewegungsmathematik: inverse Kinematik, Flugbahnberechnungen und Gl√§ttung von Bewegungen.  Dieses Modul ist streng mit dem PWM-Modul synchronisiert.  Die Berechnungen werden mit einer Frequenz von jeweils 150 Hz durchgef√ºhrt, der Steuerimpuls zu den Antrieben wird ebenfalls mit einer Frequenz von 150 Hz geliefert. <br>  <i>Moduleingabe: Koordinaten des Zielpunktes.</i> <i><br></i>  <i>Modulausgang: Servodrehwinkel.</i> </li><li>  <b>SERVO-FAHRER</b> .  Es gibt nichts Besonderes, au√üer einer Reihe von Parametern zum Einrichten und Einstellen von Laufwerken. <br>  <i>Moduleingang: Servodrehwinkel.</i> <i><br></i>  <i>Modulausgang: Steuerimpulsbreite.</i> </li><li>  <b>PWM-TREIBER</b> .  PWM-Treibersoftware zur Laufwerkssteuerung.  Hier zucken die Stifte nur zur richtigen Zeit.  Die PWM-Synchronisationssynchronisationsvariable wird in jeder PWM-Periode inkrementiert. <br>  <i>Moduleingang: Steuerimpulsbreite.</i> <i><br></i>  <i>Modulausgang: Impulse an Steuerpins.</i> </li></ol><br>  Ich habe versucht, die Module unabh√§ngig voneinander zu machen, und es ist mir gelungen.  Auf diese Weise k√∂nnen Sie jedes Zwischenmodul (z. B. das Anpassungsmodul an die Landschaft) in diese Schaltung einf√ºgen, und gleichzeitig wird nichts unterbrochen, w√§hrend die Implementierung mit minimalen √Ñnderungen im Code erfolgt. <br><br><h2>  Neueste Nachrichten und Projektkrebse gefunden </h2><br><div class="spoiler">  <b class="spoiler_title">Neueste Nachrichten</b> <div class="spoiler_text"><ol><li>  Eine neue Testversion des Geh√§uses kam heraus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">(Archiv mit Zeichnungen)</a> und ich habe es ein wenig gemalt.  Die komplette Montage des Hexapods mit den Antriebsd√ºsen in der Mittelstellung dauert 7-8 Stunden ununterbrochene Montage, und dies ber√ºcksichtigt, dass ich diesen Vorgang bereits mehr als einmal durchgef√ºhrt habe. <br><br><div class="spoiler">  <b class="spoiler_title">Fotos</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/rj/ux/k0/rjuxk0f6rfsfinjvlr9j8elgpna.jpeg"><br><br><img src="https://habrastorage.org/webt/53/nk/it/53nkit0njb3bc_tslbr8ql2utwe.jpeg"><br><br><img src="https://habrastorage.org/webt/1p/kj/cs/1pkjcsdujiutmq5ueqgtaeqjvxk.jpeg"><br><br><img src="https://habrastorage.org/webt/yw/ll/_0/ywll_0aat4jlvvx-ayq1byjbkz0.jpeg"><br></div></div></li><li>  Ich habe ein OLED-Display darauf gelegt, um Informationen anzuzeigen. Es hat sich als sehr gut herausgestellt. <br><div class="spoiler">  <b class="spoiler_title">Fotos</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/gf/g8/q1/gfg8q1mn_1brvu8vlbl84uj2d4s.jpeg"><br><br><img src="https://habrastorage.org/webt/pb/6n/gl/pb6ngln4uduzi3ivvdea5bda4gs.jpeg"><br></div></div></li><li>  Kommunikation √ºber WIFI gestartet.  Jetzt wird es vom Telefon aus gesteuert (Tool musste sein eigenes schreiben) </li><li>  Reduzierte Versorgungsspannung von 12V auf 7V aufgrund von Problemen mit √úberhitzung der Stromversorgungsplatine </li><li>  Mit der Ver√∂ffentlichung von Teil 5 der Entwicklung werde ich einen Link zu den Quellen ver√∂ffentlichen, sie haben endlich einen Zustand erreicht, in dem sie sich nicht sch√§men, Menschen zu zeigen </li></ol><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Krebse gefunden</b> <div class="spoiler_text"><ol><li>  HC-SR04.  Ich wusste, dass dieser Sensor schlecht ist, aber ich dachte nicht.  Im Allgemeinen ben√∂tigen Sie einen anderen Rangmeter </li><li>  MG996R erf√ºllen nicht die angegebenen Spezifikationen.  Sie versprachen 12 kg \ cm - tats√§chlich 5 kg \ cm bei PWM mit einer Frequenz von 300 Hz, bei 50 Hz war es sogar noch schlimmer und au√üerdem erwiesen sie sich als analog (sie versprachen eine Zahl).  Nur f√ºr Kurven geeignet.  Ich musste auf teurere digitale Laufwerke DS3218 mit 20 kg / cm umsteigen - tats√§chlich 23 kg / cm </li><li>  Ich habe alle 10 Grad eine Winkel-Impuls-Tabelle erstellt und festgestellt, dass die Steuerimpulsbreiten f√ºr den MG996R in unterschiedlichen Abst√§nden voneinander liegen.  Ich musste f√ºr jeden Antrieb Kalibrierungstabellen erstellen und den Impuls einzeln berechnen. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ez/9e/my/ez9emybwzomnlc0vxeslvl0l_im.png"></div><br>  Wie Sie sehen k√∂nnen, ist die Impulsteilung f√ºr jedes Laufwerk unterschiedlich, es war eine unerwartete Entdeckung f√ºr mich. </li><li>  Die minimalen, maximalen und zentralen Werte des Impulses unterscheiden sich aufgrund der D√ºsen f√ºr die Antriebe (was auch immer man sagen mag, es ist immer noch nicht glatt).  Die Abbildung zeigt die Antriebe, an die der 1500us-Impuls angelegt wird, und es ist ersichtlich, dass sich eine D√ºse nicht in der Mitte befindet. Dementsprechend muss der Impuls so eingestellt werden, dass sich alle D√ºsen in derselben Position befinden. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qv/md/bs/qvmdbsnasfavacafddclxdbug4o.jpeg"></div><br></li></ol><br>  √úbrigens habe ich die Kalibrierung mit diesem Ger√§t durchgef√ºhrt: <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pb/vx/de/pbvxdeg2clwcwtnh3ynnb9zg-d8.jpeg"></div><br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de444070/">https://habr.com/ru/post/de444070/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de444058/index.html">Wenn Kinder verstehen, dass ihr ganzes Leben bereits online ist</a></li>
<li><a href="../de444060/index.html">Migration von Nagios zu Icinga2 in Australien</a></li>
<li><a href="../de444062/index.html">Licht auf! Nachttransformationen des Lakhta Centers</a></li>
<li><a href="../de444064/index.html">Neue Ideen f√ºr eine neue Zukunft</a></li>
<li><a href="../de444068/index.html">Wer schaut zu?</a></li>
<li><a href="../de444072/index.html">Android Shopping - Abrechnungsbibliothek abspielen</a></li>
<li><a href="../de444074/index.html">Internet der Dinge: Vier Technologiegeschichten</a></li>
<li><a href="../de444076/index.html">Wie ich versucht habe, TP4056 zu besiegen</a></li>
<li><a href="../de444078/index.html">Linux 5.1 Kernel - was ist √ºber die √Ñnderungen bekannt</a></li>
<li><a href="../de444082/index.html">Die Zusammenfassung interessanter Materialien f√ºr den mobilen Entwickler # 290 (11. - 17. M√§rz)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>