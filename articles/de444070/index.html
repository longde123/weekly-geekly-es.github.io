<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕵🏽 🃏 💴 Entwicklung eines Hexapods von Grund auf neu (Teil 4) - mathematische Trajektorien und Sequenzen 🅾️ 🗾 ❎</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo allerseits! Die Hexapod-Entwicklung ist noch einen Schritt weiter gegangen. Dieses Mal werden die Trajektorien der Bewegung der Gliedmaßen imple...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Entwicklung eines Hexapods von Grund auf neu (Teil 4) - mathematische Trajektorien und Sequenzen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444070/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/ft/93/m5/ft93m5szh_bfaxkmnxialxpkoiu.png"></div><br>  Hallo allerseits!  Die Hexapod-Entwicklung ist noch einen Schritt weiter gegangen.  Dieses Mal werden die Trajektorien der Bewegung der Gliedmaßen implementiert und getestet - der nächste Teil der Bewegungsmathematik.  In diesem Artikel werde ich über diese Trajektorien und grundlegenden Bewegungsabläufe sprechen.  Ich hoffe es wird interessant. <br><br>  <b>Entwicklungsstadien:</b> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1 - Design</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2 - Montage</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3 - Kinematik</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><b>Teil 4 - mathematische Trajektorien und Sequenzen</b></a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 5 - Elektronik</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 6 - Übergang zum 3D-Druck</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 7 - Neues Gehäuse, Anwendungssoftware und Kommunikationsprotokolle</a> <br><a name="habracut"></a><br><h2>  Flugbahnen </h2><br>  Das Wesentliche an diesem Mechanismus ist, dass Sie beim Setzen von zwei Punkten die Flugbahn der Extremität auswählen können.  Beim Übergang von einem Punkt zum anderen ändern sich die Koordinaten gemäß bestimmten parametrischen Gleichungen.  Der Mechanismus erwies sich als ziemlich leistungsfähig und ermöglicht es Ihnen, interessante Kurven für die Bewegung zu erhalten.  Es implementiert auch eine Glättung von Bewegungen durch Ändern des Schritts des Parameters t - je kleiner der Schritt, desto mehr Zwischenpunkte gibt es, desto niedriger ist die Geschwindigkeit und desto glatter ist die Bewegung. <br><br>  Das Verfahren zum Einstellen der Parameter der Flugbahn ist an einigen Stellen etwas unverständlich und kann verwirrt sein.  Die Schwierigkeit liegt in der Tatsache, dass beim Festlegen der Koordinaten der Start- und Endpunkte die Koordinaten der realen Punkte im Raum nicht immer festgelegt werden, d. H.  Einige Koordinaten legen die Trajektorienparameter fest.  Ich musste ein Programm schreiben, das einen bestimmten Pfad anzeigt und gleichzeitig die Erreichbarkeit jedes Punkts des Pfads überprüft. <br><br>  Der Treiber unterstützt die folgenden Bewegungspfade: <br><br><ol><li>  <b>XYZ_LINAR</b> ist die einfachste aller Trajektorien.  Die Flugbahn wird verwendet, wenn Sie sich vorwärts, rückwärts, auf und ab bewegen.  Alle Koordinaten ändern sich linear und werden wie folgt berechnet: <br><br><pre><code class="cpp hljs">x = t * (x1 - x0) / <span class="hljs-number"><span class="hljs-number">180.0f</span></span> + x0; y = t * (y1 - y0) / <span class="hljs-number"><span class="hljs-number">180.0f</span></span> + y0; z = t * (z1 - z0) / <span class="hljs-number"><span class="hljs-number">180.0f</span></span> + z0;</code> </pre> <br>  Hier verstehen wir, dass es keine Probleme gibt.  Die Koordinaten geben die Parallelepipedwinkel an und stimmen mit den realen Koordinaten überein.  Die Bewegung erfolgt entlang der Diagonale der Box. <br><br><div class="spoiler">  <b class="spoiler_title">Trajektorienvisualisierung</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/t5/55/uy/t555uy9zum9cfwqa6hw4gwotdni.png"><br><img src="https://habrastorage.org/webt/bn/2n/p-/bn2np-sm7n7onhmvariez7_0jy4.png"><br><img src="https://habrastorage.org/webt/5p/g6/yw/5pg6yw_fpcqdxnr4lotb-n0so4u.png"><br></div></div><br></li><li>  <b>YZ_ARC_Y_LINEAR</b> - Mit dieser Trajektorie können Sie Bewegungen entlang eines Bogens implementieren.  Die Flugbahn wird beim Wenden verwendet, wenn Sie ein Glied auf dem Boden bewegen müssen.  Die Koordinaten werden wie folgt berechnet: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> R = <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(x0 * x0 + z0 * z0); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> atan0 = RAD_TO_DEG(<span class="hljs-built_in"><span class="hljs-built_in">atan2</span></span>(x0, z0)); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> atan1 = RAD_TO_DEG(<span class="hljs-built_in"><span class="hljs-built_in">atan2</span></span>(x1, z1)); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t_mapped_rad = DEG_TO_RAD(t * (atan1 - atan0) / <span class="hljs-number"><span class="hljs-number">180.0f</span></span> + atan0); x = R * <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(t_mapped_rad); <span class="hljs-comment"><span class="hljs-comment">// Circle Y y = t * (y1 - y0) / 180.0f + y0; z = R * cos(t_mapped_rad); // Circle X</span></span></code> </pre><br>  Hier beginnt der Spaß.  Die Koordinaten geben die Richtung der Strahlen an, um den Bogen zu begrenzen, und sie stimmen möglicherweise nicht mit den tatsächlichen Koordinaten überein.  Die Strahlen befinden sich in derselben Ebene, während der Radius des Kreises gleich der Länge des Vektors zum Startpunkt ist. <br><br><div class="spoiler">  <b class="spoiler_title">Trajektorienvisualisierung</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/ky/p0/dw/kyp0dwzfg-0t_qsrmwvstiwlweq.png"><br><br><img src="https://habrastorage.org/webt/ak/ng/ey/akngeyx2imiyht44jebbuydxyaw.png"><br></div></div><br></li><li>  <b>XZ_ARC_Y_SINUS</b> - Mit dieser Trajektorie können Sie auch Bewegungen entlang eines Bogens implementieren, die jedoch komplexer sind als YZ_ARC_Y_LINEAR.  Die Flugbahn wird beim Wenden verwendet, wenn Sie ein Glied durch die Luft bewegen müssen.  Die Koordinaten werden wie folgt berechnet: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> R = <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(x0 * x0 + z0 * z0); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> atan0 = RAD_TO_DEG(<span class="hljs-built_in"><span class="hljs-built_in">atan2</span></span>(x0, z0)); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> atan1 = RAD_TO_DEG(<span class="hljs-built_in"><span class="hljs-built_in">atan2</span></span>(x1, z1)); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t_mapped_rad = DEG_TO_RAD(t * (atan1 - atan0) / <span class="hljs-number"><span class="hljs-number">180.0f</span></span> + atan0); x = R * <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(t_mapped_rad); <span class="hljs-comment"><span class="hljs-comment">// circle Y y = (y1 - y0) * sin(DEG_TO_RAD(t)) + y0; z = R * cos(t_mapped_rad); // circle X</span></span></code> </pre><br>  Der Spaß geht weiter.  Die Koordinaten geben auch die Richtung der Strahlen an, um den Bogen zu begrenzen, stimmen jedoch NICHT mit den tatsächlichen Koordinaten überein.  Die Y-Koordinate des Zielpunkts legt die Sinushöhe fest. <br><br><div class="spoiler">  <b class="spoiler_title">Trajektorienvisualisierung</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/t6/2g/tf/t62gtfnlk7nwgibcchhawz2ug4e.png"><br></div></div><br></li><li>  <b>XZ_ELLIPTICAL_Y_SINUS</b> - Mit dieser Trajektorie können Sie Bewegungen entlang einer Ellipse implementieren.  Die Flugbahn wird verwendet, wenn Sie sich vorwärts und rückwärts bewegen, wenn Sie ein Glied durch die Luft bewegen müssen.  Diese Flugbahn ist eine Komplikation von XZ_ARC_Y_SINUS und wurde nur wegen des visuell hässlichen Gangs bei Verwendung von XZ_ARC_Y_SINUS benötigt (Beine zu stark gestreckt).  Die Koordinaten werden wie folgt berechnet: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> a = (z1 - z0) / <span class="hljs-number"><span class="hljs-number">2.0f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> b = (x1 - x0); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> c = (y1 - y0); x = b * <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(DEG_TO_RAD(<span class="hljs-number"><span class="hljs-number">180.0f</span></span> - t)) + x0; <span class="hljs-comment"><span class="hljs-comment">// circle Y y = c * sin(DEG_TO_RAD(t)) + y0; z = a * cos(DEG_TO_RAD(180.0f - t)) + z0 + a;</span></span></code> </pre><br>  Die Koordinaten geben die Parallelepipedwinkel an und stimmen NICHT mit den realen Koordinaten überein.  Die Bewegung erfolgt von den unteren Ecken des Kastens aus, die sich in derselben Ebene befinden wie das Berühren der Oberseite seines Teils.  Es ist besser, sich das Bild im Spoiler anzusehen, ich weiß nicht, wie ich es kurz in Worten beschreiben soll. <br><br><div class="spoiler">  <b class="spoiler_title">Trajektorienvisualisierung</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/pn/3x/4w/pn3x4wot6ajk1ofy4wl7rtjyp1y.png"><br></div></div></li></ol><br>  Dies vervollständigt die grundlegende Mathematik der Bewegung des Hexapods.  In meinem Projekt ist dies ein notwendiges Minimum für die Umsetzung fast jeder Bewegung. <br><br><h2>  Sequenzen </h2><br><h3>  Ein bisschen Theorie </h3><br>  Sequenzen sind die elementaren Aktionen, aus denen sich der Gang zusammensetzt.  Sie sind in zyklische und nichtzyklische unterteilt. <br><br><ul><li>  Zyklische Sequenzen können viele Male ausgeführt werden und sollten am Ende jedes Zyklus die Gliedmaßen in ihre ursprüngliche Position zurückbringen (Bewegung und Drehung); </li><li>  Nichtzyklische Sequenzen werden nur einmal durchgeführt (Auf- und Abstieg); </li></ul><br>  Jede Sequenz hat drei Iterationsblöcke: Vorbereitungsblock, Hauptblock, Abschlussblock. <br><br><ul><li>  Trainingsblock - enthält Iterationen, um die Gliedmaßen in die Ausgangsposition für die Sequenz zu bewegen.  In meinem Fall erfordert das Vorwärtsbewegen, dass Sie Ihre Beine in eine bestimmte Position bringen, bevor Sie sich bewegen.  Es wird einmal beim Übergang zur Sequenz ausgeführt; </li><li>  Hauptblock - enthält die Hauptiteration der Sequenz.  Es kann zyklisch durchgeführt werden; </li><li>  Blockvervollständigung - enthält Iterationen zum Bewegen der Gliedmaßen in die Basisposition (die Position, in der die Gliedmaßen nach dem Anheben eingestellt werden); </li></ul><br>  Die folgende Abbildung zeigt die Reihenfolge für das Vorwärtsbewegen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yt/yf/vw/ytyfvwd1slowqjmordig0qenioa.png"></div><br><ul><li>  Rote Punkte zeigen die Ausgangsposition der Gliedmaßen an, bevor sie sich bewegen </li><li>  Blaue Linien zeigen die Flugbahnen der Extremität am Boden an </li><li>  Die schwarzen Linien zeigen die Flugbahnen des Gliedes in der Luft an </li><li>  Die Pfeile geben die Reihenfolge an </li></ul><br>  Die Koordinaten der Punkte werden basierend auf der Konfiguration des Gehäuses ausgewählt.  Ich habe die Punkte so nah wie möglich am Körper gewählt, um die Länge des Hebels zu verringern.  In einem Zyklus der Sequenz bewegt sich der Hexapod um 18 cm (in 1 Zyklus werden 2 Schritte ausgeführt - 1 Schritt in 3 Gliedmaßen).  Wenn Sie den Abstand vergrößern, klammern sich die Gliedmaßen aneinander.  Dieser Parameter ist nur durch die Fallkonfiguration begrenzt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/67/hs/0b/67hs0bhvmyfefjvvxyb0qh0lojy.png"></div><br>  Die Sequenz wird durch zwei Punkte (1, 2) für jedes Glied definiert und zwei Pfade werden verwendet: XYZ_LINEAR (blaue Linien) und XZ_ELLIPTICAL_Y_SINUS (schwarze Linien).  Punkt 1 wird von der XZ_ELLIPTICAL_Y_SINUS-Trajektorie verwendet, um die Sinushöhe und dementsprechend die Höhe festzulegen, auf die der Fuß steigt.  Die Punkte 2 und 3 sind echte Punkte, die ein Glied beim Bewegen erreicht. <br><br>  Die Position der Punkte hängt nur von Ihrer Vorstellungskraft und den Fähigkeiten des Hexapods ab.  Vielleicht hat sich alles als etwas kompliziert herausgestellt und es gibt eine einfachere Option, aber anscheinend habe ich sie noch nicht erreicht. <br><br><h3>  Implementierung </h3><br>  Schauen wir uns nun die Umsetzung all dieses Glücks an.  Strukturen mit Sequenzparametern sind wie folgt: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">point_3d_t</span></span> point_list[SUPPORT_LIMB_COUNT]; <span class="hljs-keyword"><span class="hljs-keyword">path_type_t</span></span> path_list[SUPPORT_LIMB_COUNT]; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> smooth_point_count; } <span class="hljs-keyword"><span class="hljs-keyword">sequence_iteration_t</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> is_sequence_looped; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> main_sequence_begin; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> finalize_sequence_begin; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> total_iteration_count; <span class="hljs-keyword"><span class="hljs-keyword">sequence_iteration_t</span></span> iteration_list[<span class="hljs-number"><span class="hljs-number">15</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">sequence_id_t</span></span> available_sequences[SUPPORT_SEQUENCE_COUNT]; } <span class="hljs-keyword"><span class="hljs-keyword">sequence_info_t</span></span>;</code> </pre> <br>  <b>sequence_iteration_t</b> - enthält Informationen zur Iteration der Sequenz: <br><br><ul><li>  point_list - ein Array von Punkten für jedes Glied im XYZ-Format; </li><li>  path_list - ein Array von Trajektorien für jedes Glied; </li><li>  ooth_point_count - legt die Anzahl der Pfadpunkte fest (Parameterschritt t); </li></ul><br>  <b>sequence_info_t</b> - enthält Informationen zur gesamten Sequenz: <br><br><ul><li>  is_sequence_looped - legt den Sequenztyp fest: zyklisch oder nicht; </li><li>  main_sequence_begin - legt den Startindex des Hauptblocks im Array iteration_list fest; </li><li>  finalize_sequence_begin - legt den Startindex des Abschlussblocks im Array iteration_list fest; </li><li>  total_iteration_count - Legt die Anzahl der Iterationen in der Sequenz fest. </li><li>  iteration_list - ein Array von Iterationen; </li><li>  available_sequences - Legt die Liste der Sequenzen fest, die für den Übergang von der aktuellen Sequenz verfügbar sind (z. B. können wir nicht mit dem Gehen beginnen, ohne zuerst vom Boden aufzustehen). </li></ul><br>  <i>HINWEIS: Der Index des Vorbereitungsblocks wird nicht absichtlich angegeben, sondern befindet sich immer am Anfang des Iterationsarrays.</i> <i><br></i> <br>  Leider kann ich hier keinen Code zur Bestimmung der Reihenfolge angeben, da  es ist ziemlich breit und sieht nach Transfers schrecklich aus.  Ich hinterlasse hier nur einen Link zur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Definitionsdatei</a> . <br><br><h3>  Bewegungsverarbeitungsschema </h3><br>  Es lohnt sich, alle Höllenkreise zu erkennen, die die Sequenz zur Laufzeit durchläuft.  Das Verarbeitungsschema ist wie folgt: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hz/bd/h-/hzbdh-sihkvi9t9lmxn73igosv8.png"></div><br><ol><li>  <b>MOVEMENT ENGINE</b> - organisiert die Verarbeitung und das Umschalten zwischen Sequenzen.  Dort werden keine Berechnungen durchgeführt.  Wenn vereinfacht, verschiebt dieses Modul den nächsten Punkt zum LIBMS DRIVER-Modul, nachdem die aktuelle Verarbeitung abgeschlossen ist. <br>  <i>Moduleingabe: Array von Koordinaten der Zielpunkte.</i> <i><br></i>  <i>Modulausgabe: Zielpunkt für die aktuelle Iteration der Sequenz.</i> </li><li>  <b>LIBMS DRIVER</b> ist das komplexeste aller Module.  Hier herrscht die gesamte Bewegungsmathematik: inverse Kinematik, Flugbahnberechnungen und Glättung von Bewegungen.  Dieses Modul ist streng mit dem PWM-Modul synchronisiert.  Die Berechnungen werden mit einer Frequenz von jeweils 150 Hz durchgeführt, der Steuerimpuls zu den Antrieben wird ebenfalls mit einer Frequenz von 150 Hz geliefert. <br>  <i>Moduleingabe: Koordinaten des Zielpunktes.</i> <i><br></i>  <i>Modulausgang: Servodrehwinkel.</i> </li><li>  <b>SERVO-FAHRER</b> .  Es gibt nichts Besonderes, außer einer Reihe von Parametern zum Einrichten und Einstellen von Laufwerken. <br>  <i>Moduleingang: Servodrehwinkel.</i> <i><br></i>  <i>Modulausgang: Steuerimpulsbreite.</i> </li><li>  <b>PWM-TREIBER</b> .  PWM-Treibersoftware zur Laufwerkssteuerung.  Hier zucken die Stifte nur zur richtigen Zeit.  Die PWM-Synchronisationssynchronisationsvariable wird in jeder PWM-Periode inkrementiert. <br>  <i>Moduleingang: Steuerimpulsbreite.</i> <i><br></i>  <i>Modulausgang: Impulse an Steuerpins.</i> </li></ol><br>  Ich habe versucht, die Module unabhängig voneinander zu machen, und es ist mir gelungen.  Auf diese Weise können Sie jedes Zwischenmodul (z. B. das Anpassungsmodul an die Landschaft) in diese Schaltung einfügen, und gleichzeitig wird nichts unterbrochen, während die Implementierung mit minimalen Änderungen im Code erfolgt. <br><br><h2>  Neueste Nachrichten und Projektkrebse gefunden </h2><br><div class="spoiler">  <b class="spoiler_title">Neueste Nachrichten</b> <div class="spoiler_text"><ol><li>  Eine neue Testversion des Gehäuses kam heraus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">(Archiv mit Zeichnungen)</a> und ich habe es ein wenig gemalt.  Die komplette Montage des Hexapods mit den Antriebsdüsen in der Mittelstellung dauert 7-8 Stunden ununterbrochene Montage, und dies berücksichtigt, dass ich diesen Vorgang bereits mehr als einmal durchgeführt habe. <br><br><div class="spoiler">  <b class="spoiler_title">Fotos</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/rj/ux/k0/rjuxk0f6rfsfinjvlr9j8elgpna.jpeg"><br><br><img src="https://habrastorage.org/webt/53/nk/it/53nkit0njb3bc_tslbr8ql2utwe.jpeg"><br><br><img src="https://habrastorage.org/webt/1p/kj/cs/1pkjcsdujiutmq5ueqgtaeqjvxk.jpeg"><br><br><img src="https://habrastorage.org/webt/yw/ll/_0/ywll_0aat4jlvvx-ayq1byjbkz0.jpeg"><br></div></div></li><li>  Ich habe ein OLED-Display darauf gelegt, um Informationen anzuzeigen. Es hat sich als sehr gut herausgestellt. <br><div class="spoiler">  <b class="spoiler_title">Fotos</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/gf/g8/q1/gfg8q1mn_1brvu8vlbl84uj2d4s.jpeg"><br><br><img src="https://habrastorage.org/webt/pb/6n/gl/pb6ngln4uduzi3ivvdea5bda4gs.jpeg"><br></div></div></li><li>  Kommunikation über WIFI gestartet.  Jetzt wird es vom Telefon aus gesteuert (Tool musste sein eigenes schreiben) </li><li>  Reduzierte Versorgungsspannung von 12V auf 7V aufgrund von Problemen mit Überhitzung der Stromversorgungsplatine </li><li>  Mit der Veröffentlichung von Teil 5 der Entwicklung werde ich einen Link zu den Quellen veröffentlichen, sie haben endlich einen Zustand erreicht, in dem sie sich nicht schämen, Menschen zu zeigen </li></ol><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Krebse gefunden</b> <div class="spoiler_text"><ol><li>  HC-SR04.  Ich wusste, dass dieser Sensor schlecht ist, aber ich dachte nicht.  Im Allgemeinen benötigen Sie einen anderen Rangmeter </li><li>  MG996R erfüllen nicht die angegebenen Spezifikationen.  Sie versprachen 12 kg \ cm - tatsächlich 5 kg \ cm bei PWM mit einer Frequenz von 300 Hz, bei 50 Hz war es sogar noch schlimmer und außerdem erwiesen sie sich als analog (sie versprachen eine Zahl).  Nur für Kurven geeignet.  Ich musste auf teurere digitale Laufwerke DS3218 mit 20 kg / cm umsteigen - tatsächlich 23 kg / cm </li><li>  Ich habe alle 10 Grad eine Winkel-Impuls-Tabelle erstellt und festgestellt, dass die Steuerimpulsbreiten für den MG996R in unterschiedlichen Abständen voneinander liegen.  Ich musste für jeden Antrieb Kalibrierungstabellen erstellen und den Impuls einzeln berechnen. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ez/9e/my/ez9emybwzomnlc0vxeslvl0l_im.png"></div><br>  Wie Sie sehen können, ist die Impulsteilung für jedes Laufwerk unterschiedlich, es war eine unerwartete Entdeckung für mich. </li><li>  Die minimalen, maximalen und zentralen Werte des Impulses unterscheiden sich aufgrund der Düsen für die Antriebe (was auch immer man sagen mag, es ist immer noch nicht glatt).  Die Abbildung zeigt die Antriebe, an die der 1500us-Impuls angelegt wird, und es ist ersichtlich, dass sich eine Düse nicht in der Mitte befindet. Dementsprechend muss der Impuls so eingestellt werden, dass sich alle Düsen in derselben Position befinden. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qv/md/bs/qvmdbsnasfavacafddclxdbug4o.jpeg"></div><br></li></ol><br>  Übrigens habe ich die Kalibrierung mit diesem Gerät durchgeführt: <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pb/vx/de/pbvxdeg2clwcwtnh3ynnb9zg-d8.jpeg"></div><br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de444070/">https://habr.com/ru/post/de444070/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de444058/index.html">Wenn Kinder verstehen, dass ihr ganzes Leben bereits online ist</a></li>
<li><a href="../de444060/index.html">Migration von Nagios zu Icinga2 in Australien</a></li>
<li><a href="../de444062/index.html">Licht auf! Nachttransformationen des Lakhta Centers</a></li>
<li><a href="../de444064/index.html">Neue Ideen für eine neue Zukunft</a></li>
<li><a href="../de444068/index.html">Wer schaut zu?</a></li>
<li><a href="../de444072/index.html">Android Shopping - Abrechnungsbibliothek abspielen</a></li>
<li><a href="../de444074/index.html">Internet der Dinge: Vier Technologiegeschichten</a></li>
<li><a href="../de444076/index.html">Wie ich versucht habe, TP4056 zu besiegen</a></li>
<li><a href="../de444078/index.html">Linux 5.1 Kernel - was ist über die Änderungen bekannt</a></li>
<li><a href="../de444082/index.html">Die Zusammenfassung interessanter Materialien für den mobilen Entwickler # 290 (11. - 17. März)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>