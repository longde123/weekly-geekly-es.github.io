<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üî≠ üòº üë©üèø‚Äçüéì Una introducci√≥n a Kubernetes para usuarios de VMware. Parte 1. Teor√≠a üë®‚Äçüë¶‚Äçüë¶ üë©üèª‚Äçüîß üòØ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Esta es la segunda parte de mi serie de publicaciones Kubernetes in the Enterprise . Como mencion√© en mi √∫ltima publicaci√≥n, es muy importante al pasa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Una introducci√≥n a Kubernetes para usuarios de VMware. Parte 1. Teor√≠a</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dataline/blog/436028/">  Esta es la segunda parte de mi serie de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">publicaciones Kubernetes in the Enterprise</a> .  Como mencion√© en mi √∫ltima publicaci√≥n, es muy importante al pasar a las <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Gu√≠as de dise√±o e implementaci√≥n" que</a> todos est√©n en el mismo nivel de comprensi√≥n de Kubernetes (K8). <br><br>  No quiero usar el enfoque tradicional aqu√≠ para explicar la arquitectura y las tecnolog√≠as de Kubernetes, pero explicar√© todo a trav√©s de una comparaci√≥n con la plataforma vSphere, con la que ustedes, como usuarios de VMware, est√°n familiarizados.  Esto le permitir√° superar la aparente confusi√≥n y la gravedad de la comprensi√≥n de Kubernetes.  Utilic√© este enfoque dentro de VMware para presentar Kubernetes a diferentes audiencias, y demostr√≥ que funciona muy bien y ayuda a las personas a acostumbrarse a los conceptos clave m√°s r√°pido. <br><br>  Nota importante antes de comenzar.  No uso esta comparaci√≥n para probar similitudes o diferencias entre vSphere y Kubernetes.  Tanto eso como otro, en esencia, son sistemas distribuidos y, por lo tanto, deben tener similitudes con cualquier otro sistema similar.  Por lo tanto, al final, trato de presentar una tecnolog√≠a tan maravillosa como Kubernetes a una amplia comunidad de usuarios. <br><img src="https://habrastorage.org/webt/2x/8j/gn/2x8jgnlfylvf_sfzkylizlg3huk.png"><a name="habracut"></a><br><br><h3>  Un poco de historia </h3><br>  Leer esta publicaci√≥n implica conocer los contenedores.  No describir√© los conceptos b√°sicos de los contenedores, ya que hay muchos recursos que hablan de esto.  Al hablar con los clientes muy a menudo, veo que no pueden entender por qu√© los contenedores se apoderaron de nuestra industria y se hicieron muy populares en un tiempo r√©cord.  Para responder a esta pregunta, hablar√© sobre mi experiencia pr√°ctica en la comprensi√≥n de los cambios que est√°n teniendo lugar en nuestra industria. <br><br>  Antes de explorar el mundo de las telecomunicaciones, fui desarrollador web (2003). <br><br>  Este fue mi segundo trabajo remunerado despu√©s de trabajar como ingeniero / administrador de redes (s√© que era un experto en todos los oficios).  Desarroll√© en PHP.  Desarroll√© todo tipo de aplicaciones, comenzando con las peque√±as que usaba mi empleador, terminando con una aplicaci√≥n de votaci√≥n profesional para programas de televisi√≥n, e incluso aplicaciones de telecomunicaciones que interact√∫an con los concentradores VSAT y los sistemas satelitales.  La vida fue genial, con la excepci√≥n de un obst√°culo importante que todo desarrollador conoce: las adicciones. <br><br>  Al principio desarroll√© la aplicaci√≥n en mi computadora port√°til, usando algo como la pila LAMP, cuando funcion√≥ bien en mi computadora port√°til, descargu√© el c√≥digo fuente a los servidores host (¬øtodos recuerdan RackShack?) O a los servidores privados del cliente.  Puedes imaginar que tan pronto como hice esto, la aplicaci√≥n se bloque√≥ y no funcion√≥ en estos servidores.  La raz√≥n de esto es la adicci√≥n.  Los servidores ten√≠an otras versiones del software (Apache, PHP, MySQL, etc.) que las que yo usaba en la computadora port√°til.  As√≠ que necesitaba encontrar una manera de actualizar las versiones de software en los servidores remotos (mala idea) o reescribir el c√≥digo en mi computadora port√°til para que coincida con las versiones en los servidores remotos (peor idea).  Fue una pesadilla, a veces me odiaba y me preguntaba por qu√© me gano la vida. <br><br>  Han pasado 10 a√±os, apareci√≥ la compa√±√≠a Docker.  Como consultor de VMware en Professional Services (2013), escuch√© acerca de Docker y me dej√≥ decir que no pod√≠a entender esta tecnolog√≠a en esos d√≠as.  Continu√© diciendo algo como: ¬øpor qu√© usar contenedores si hay m√°quinas virtuales?  ¬øPor qu√© renunciar a tecnolog√≠as importantes como vSphere HA, DRS o vMotion debido a ventajas tan extra√±as como el lanzamiento instant√°neo de contenedores o la eliminaci√≥n de la sobrecarga del hipervisor?  Despu√©s de todo, todos trabajan con m√°quinas virtuales y funcionan perfectamente.  En resumen, lo mir√© en t√©rminos de infraestructura. <br><br>  Pero luego comenc√© a mirar de cerca y me di cuenta.  Todo lo relacionado con Docker est√° relacionado con los desarrolladores.  Reci√©n comenzando a pensar como desarrollador, inmediatamente me di cuenta de que si tuviera esta tecnolog√≠a en 2003, podr√≠a empaquetar todas mis dependencias.  Mis aplicaciones web podr√≠an funcionar independientemente del servidor utilizado.  Adem√°s, no ser√≠a necesario descargar el c√≥digo fuente o configurar algo.  Simplemente puede "empaquetar" mi aplicaci√≥n en una imagen y pedir a los clientes que descarguen y ejecuten esta imagen.  ¬°Este es el sue√±o de cualquier desarrollador web! <br><br>  Todo esto es genial.  Docker resolvi√≥ el gran problema de interacci√≥n y empaque, pero ¬øqu√© sigue?  ¬øPuedo, como cliente corporativo, administrar estas aplicaciones mientras escalo?  Todav√≠a quiero usar HA, DRS, vMotion y DR.  Docker resolvi√≥ los problemas de mis desarrolladores y cre√≥ un mont√≥n de problemas para mis administradores (equipo de DevOps).  Necesitan una plataforma para lanzar contenedores, la misma que para lanzar m√°quinas virtuales.  Y volvimos nuevamente al principio. <br><br>  Pero luego apareci√≥ Google, dici√©ndole al mundo sobre el uso de contenedores durante muchos a√±os (de hecho, los contenedores fueron inventados por Google: cgroups) y el m√©todo correcto de usarlos, a trav√©s de una plataforma que llamaron Kubernetes.  Luego abrieron el c√≥digo fuente de Kubernetes.  Presentado a la comunidad de Kubernetes.  Y eso cambi√≥ todo de nuevo. <br><br><h3>  Comprensi√≥n de Kubernetes versus vSphere </h3><br>  Entonces, ¬øqu√© es Kubernetes?  En pocas palabras, Kubernetes para contenedores es lo mismo que vSphere para m√°quinas virtuales en un centro de datos moderno.  Si utiliz√≥ VMware Workstation a principios de la d√©cada de 2000, sabr√° que esta soluci√≥n se consider√≥ seriamente como una soluci√≥n para centros de datos.  Cuando apareci√≥ VI / vSphere con vCenter y hosts ESXi, el mundo de las m√°quinas virtuales cambi√≥ dr√°sticamente.  Kubernetes est√° haciendo lo mismo hoy con el mundo de los contenedores, brindando la capacidad de lanzar y administrar contenedores en producci√≥n.  Y es por eso que comenzaremos a comparar vSphere lado a lado con Kubernetes para explicar los detalles de este sistema distribuido para comprender sus funciones y tecnolog√≠as. <br><img src="https://habrastorage.org/webt/2l/ke/vg/2lkevgzxfllfuhfd29vtofvm4ii.png"><br><br><h3>  Resumen del sistema </h3><br>  Como en vSphere hay hosts vCenter y ESXi en el concepto de Kubernetes, hay Master y Node's.  En este contexto, Master en K8s es el equivalente de vCenter, en el sentido de que es el plano de gesti√≥n de un sistema distribuido.  Tambi√©n es el punto de entrada para la API con la que interact√∫a al administrar su carga de trabajo.  Del mismo modo, los nodos K8 funcionan como recursos inform√°ticos, de forma similar a los hosts ESXi.  Es en ellos que ejecutan cargas de trabajo (en el caso de los K8, los llamamos Pods).  Los nodos pueden ser m√°quinas virtuales o servidores f√≠sicos.  Por supuesto, con vSphere ESXi, los hosts siempre deben ser f√≠sicos. <br><img src="https://habrastorage.org/webt/to/va/hq/tovahqozye9ym14sljwpbilywto.png"><br><br>  Puede ver que K8 tiene un almac√©n de valores clave llamado "etcd".  Este almacenamiento es similar a la base de datos de vCenter, donde guarda la configuraci√≥n de cl√∫ster deseada a la que desea adherirse. <br><br>  En cuanto a las diferencias: en Master K8s tambi√©n puede ejecutar cargas de trabajo, pero en vCenter no puede.  vCenter es un dispositivo virtual dedicado √∫nicamente a la administraci√≥n.  En el caso de los K8, Master se considera un recurso inform√°tico, pero ejecutar aplicaciones empresariales en √©l no es una buena idea. <br><br>  Entonces, ¬øc√≥mo se ver√° en la realidad?  Utilizar√° principalmente la CLI para interactuar con Kubernetes (pero la GUI sigue siendo una opci√≥n muy viable).  La captura de pantalla siguiente muestra que estoy usando una m√°quina Windows para conectarme a mi cl√∫ster de Kubernetes a trav√©s de la l√≠nea de comandos (uso cmder si est√° interesado)  En la captura de pantalla tengo un nodo maestro y 4 nodos.  Funcionan bajo el control de K8s v1.6.5, y el sistema operativo (SO) Ubuntu 16.04 est√° instalado en los nodos.  Al momento de escribir esta publicaci√≥n, vivimos principalmente en el mundo de Linux, donde Master y Node siempre ejecutan una distribuci√≥n de Linux. <br><br><img src="https://habrastorage.org/webt/gm/qn/gj/gmqngjq1mraqces6uo1sectxm6i.png"><br>  <i>Gesti√≥n de cl√∫steres de K8 a trav√©s de CLI y GUI.</i> <br><br><h3>  Factor de forma de carga de trabajo </h3><br>  En vSphere, la m√°quina virtual es el l√≠mite l√≥gico del sistema operativo.  En Kubernetes, los Pods son l√≠mites de contenedores, al igual que el host ESXi, que puede ejecutar varias m√°quinas virtuales simult√°neamente.  Cada nodo puede ejecutar varios pods.  Cada Pod recibe una direcci√≥n IP enrutable, como m√°quinas virtuales, para que los Pods se comuniquen entre s√≠. <br><br>  En vSphere, las aplicaciones se ejecutan dentro del sistema operativo y en Kubernetes, las aplicaciones se ejecutan dentro de contenedores.  Una m√°quina virtual solo puede funcionar con un sistema operativo a la vez, y un Pod puede ejecutar m√∫ltiples contenedores. <br><img src="https://habrastorage.org/webt/hv/cv/9b/hvcv9bj4gw6wsunhhqeqvvfx5d4.png"><br><br>  As√≠ es como puede enumerar los Pods dentro del cl√∫ster K8s utilizando la herramienta kubectl a trav√©s de la CLI, verificar la capacidad de trabajo de los Pods, su edad, direcci√≥n IP y Nodos en los que est√°n trabajando actualmente. <br><img src="https://habrastorage.org/webt/0u/qj/_0/0uqj_0gl0qmxiqbby9gd8ln98nc.png"><br><br><h3>  Gesti√≥n </h3><br>  Entonces, ¬øc√≥mo gestionamos nuestros Masters, Nodos y Pods?  En vSphere, utilizamos el cliente web para administrar la mayor√≠a de los componentes (si no todos) de nuestra infraestructura virtual.  Para Kubernetes, de manera similar, usando Dashboard.  Este es un buen portal web basado en GUI al que puede acceder a trav√©s de su navegador de la misma manera que con el cliente web vSphere.  En las secciones anteriores, puede ver que puede administrar su cl√∫ster K8 utilizando el comando kubeclt de la CLI.  Siempre es discutible d√≥nde pasar√° la mayor parte de su tiempo en la CLI o en el Tablero gr√°fico.  Dado que este √∫ltimo se est√° convirtiendo en una herramienta cada vez m√°s poderosa todos los d√≠as (puede ver este video para estar seguro).  Personalmente, creo que el Tablero es muy conveniente para monitorear r√°pidamente el estado o mostrar los detalles de varios componentes de K8, sin tener que ingresar comandos largos en la CLI.  Encontrar√° un equilibrio entre ellos de forma natural. <br><br><img src="https://habrastorage.org/webt/hi/hu/cj/hihucj_bhrydsrgy0ad5xifupuc.png"><br><br><h3>  Configuraciones </h3><br>  Uno de los conceptos muy importantes en Kubernetes es el estado deseado de las configuraciones.  Usted declara que desea para casi cualquier componente de Kubernetes a trav√©s de un archivo YAML, y crea todo esto usando kubectl (o mediante un Tablero gr√°fico) como su estado deseado.  De ahora en adelante, Kubernetes siempre se esforzar√° por mantener su entorno en un estado operativo determinado.  Por ejemplo, si desea tener 4 r√©plicas de un Pod, los K8 continuar√°n monitoreando estos Pods, y si uno de ellos muri√≥ o el Nodo en el que funcion√≥ tuvo problemas, K8 se recuperar√° autom√°ticamente y crear√° autom√°ticamente Pod en otro lado. <br><br>  Volviendo a nuestros archivos de configuraci√≥n de YAML, puede considerarlos como un archivo .VMX para una m√°quina virtual o un descriptor .OVF para un dispositivo virtual que desea implementar en vSphere.  Estos archivos definen la configuraci√≥n de la carga de trabajo / componente que desea ejecutar.  A diferencia de los archivos VMX / OVF, que son exclusivos de las m√°quinas virtuales / dispositivos virtuales, los archivos de configuraci√≥n YAML se utilizan para definir cualquier componente K8, como ReplicaSets, Services, Deployments, etc.  Considere esto en las siguientes secciones. <br><img src="https://habrastorage.org/webt/qg/2w/np/qg2wnppfqeu9ksyev67haaiz19m.png"><br><br><h3>  Clusters virtuales </h3><br>  En vSphere, tenemos hosts ESXi f√≠sicos que est√°n agrupados l√≥gicamente en cl√∫steres.  Estos grupos pueden dividirse en otros grupos virtuales llamados "Grupos de recursos".  Estos "grupos" se utilizan principalmente para limitar los recursos.  En Kubernetes, tenemos algo muy similar.  Los llamamos "espacios de nombres", tambi√©n se pueden utilizar para proporcionar l√≠mites de recursos, que se reflejar√°n en la siguiente secci√≥n.  Sin embargo, la mayor√≠a de las veces los "espacios de nombres" se utilizan como una herramienta de arrendamiento m√∫ltiple para aplicaciones (o usuarios, si utiliza cl√∫steres K8 comunes).  Esta es tambi√©n una de las opciones con las que puede realizar la segmentaci√≥n de la red con NSX-T.  Considere esto en las siguientes publicaciones. <br><img src="https://habrastorage.org/webt/n6/ve/kr/n6vekro9uz1bx9i_0kqgxquyduw.png"><br><br><h3>  Gesti√≥n de recursos </h3><br>  Como mencion√© en la secci√≥n anterior, los espacios de nombres en Kubernetes se usan com√∫nmente como un medio de segmentaci√≥n.  Otro uso de los espacios de nombres es la asignaci√≥n de recursos.  Esta opci√≥n se llama "Cuotas de recursos".  Como se deduce de las secciones anteriores, la definici√≥n de esto ocurre en los archivos de configuraci√≥n YAML, en los que se declara el estado deseado.  En vSphere, como se puede ver en la captura de pantalla a continuaci√≥n, determinamos esto a partir de la configuraci√≥n de los grupos de recursos. <br><img src="https://habrastorage.org/webt/jq/oy/nl/jqoynlerkguited5ozdgsndtj4w.png"><br><br><h3>  Identificaci√≥n de carga de trabajo </h3><br>  Esto es bastante simple y casi lo mismo para vSphere y Kubernetes.  En el primer caso, usamos los conceptos de Etiquetas para definir (o agrupar) cargas de trabajo similares, y en el segundo usamos el t√©rmino "Etiquetas".  En el caso de Kubernetes, la identificaci√≥n de la carga de trabajo es obligatoria. <br><img src="https://habrastorage.org/webt/j_/2s/go/j_2sgoekii7mwswdmhspterznoq.png"><br><br><h3>  Reserva </h3><br>  Ahora por verdadera diversi√≥n.  Si fue o es un gran admirador de vSphere FT, como yo, le encantar√° esta caracter√≠stica en Kubernetes, a pesar de algunas diferencias en las dos tecnolog√≠as.  En vSphere, es una m√°quina virtual con una instancia de sombra en ejecuci√≥n que se ejecuta en un host diferente.  Grabamos instrucciones en la m√°quina virtual principal y las reproducimos en la m√°quina virtual en la sombra.  Si la m√°quina principal deja de funcionar, la m√°quina virtual oculta se enciende de inmediato.  Luego, vSphere intenta encontrar otro host ESXi para crear una nueva instancia oculta de la m√°quina virtual para mantener la misma redundancia.  En Kubernetes, tenemos algo muy similar.  ReplicaSets es la cantidad que especifica para ejecutar varias instancias de Pods.  Si un Pod falla, hay otras instancias disponibles para atender el tr√°fico.  Al mismo tiempo, los K8 intentar√°n lanzar un nuevo Pod en cualquier Nodo disponible para mantener el estado de configuraci√≥n deseado.  La diferencia principal, como ya habr√°s notado, es que en el caso de los K8, los Pods siempre funcionan y sirven el tr√°fico.  No son cargas de trabajo sombra. <br><img src="https://habrastorage.org/webt/29/u-/sd/29u-sdyxbg1n0qdzwpkwjmcyuxe.png"><br><br><h3>  Balanceo de carga </h3><br>  Aunque esta no sea una funci√≥n integrada en vSphere, es muy, muy a menudo necesario ejecutar equilibradores de carga en la plataforma.  En el mundo vSphere, existen equilibradores de carga f√≠sicos o virtuales para distribuir el tr√°fico de red entre m√∫ltiples m√°quinas virtuales.  Puede haber muchos modos de configuraci√≥n diferentes, pero supongamos que nos referimos a la configuraci√≥n One-Armed.  En este caso, equilibra la carga del tr√°fico Este-Oeste en sus m√°quinas virtuales. <br><br>  Del mismo modo, Kubernetes tiene el concepto de "Servicios".  El servicio en K8 tambi√©n se puede utilizar en diferentes modos de configuraci√≥n.  Elija la configuraci√≥n "ClusterIP" para compararla con el equilibrador de carga de un solo brazo.  En este caso, el Servicio en K8 tendr√° una direcci√≥n IP virtual (VIP), que siempre es est√°tica y no cambia.  Este VIP distribuir√° el tr√°fico entre varios Pods.  Esto es especialmente importante en el mundo de Kubernetes, donde por naturaleza los Pods son ef√≠meros, se pierde la direcci√≥n IP del Pod en el momento en que muere o se elimina.  Por lo tanto, siempre debe proporcionar un VIP est√°tico. <br><br>  Como ya mencion√©, el Servicio tiene muchas otras configuraciones, por ejemplo, "NodePort", donde asigna un puerto en el nivel de Nodo y luego realiza la traducci√≥n de traducci√≥n de direcci√≥n de puerto para Pods.  Tambi√©n hay un "LoadBalancer" donde ejecuta una instancia de Load Balancer desde un proveedor externo o en la nube. <br><img src="https://habrastorage.org/webt/s9/4g/my/s94gmy5frfcjkyxeywlp3gcwtkm.png"><br><br>  Kuberentes tiene otro mecanismo de equilibrio de carga muy importante llamado "Controlador de entrada".  Puede considerarlo un equilibrador de carga de aplicaciones en l√≠nea.  La idea principal es que el Controlador de Ingreso (en forma de Pod) se iniciar√° con una direcci√≥n IP visible desde el exterior.  Esta direcci√≥n IP puede tener algo as√≠ como registros DNS comod√≠n.  Cuando el tr√°fico llega al Controlador de Ingreso usando una direcci√≥n IP externa, verifica los encabezados y determina usando el conjunto de reglas que estableci√≥ previamente a qu√© Pod pertenece este nombre.  Por ejemplo: sphinx-v1.esxcloud.net se dirigir√° al Servicio sphinx-svc-1, y sphinx-v2.esxcloud.net se dirigir√° al Servicio sphinx-svc2, etc. <br><img src="https://habrastorage.org/webt/fk/jr/t_/fkjrt_3ho51djc-euoshgcjccas.png"><br><br><h3>  Almacenamiento y red </h3><br>  El almacenamiento y las redes son temas muy, muy amplios cuando se trata de Kubernetes.  Es casi imposible hablar brevemente sobre estos dos temas en una publicaci√≥n introductoria, pero pronto hablar√© en detalle sobre los diferentes conceptos y opciones para cada uno de estos temas.  Mientras tanto, veamos r√°pidamente c√≥mo funciona la pila de red en Kubernetes, ya que la necesitaremos en la siguiente secci√≥n. <br><br>  Kubernetes tiene varios "complementos" de red que puede usar para configurar la red de sus nodos y pods.  Un complemento com√∫n es "kubenet", que actualmente se usa en mega nubes como GCP y AWS.  Aqu√≠ hablar√© brevemente sobre la implementaci√≥n de GCP y luego mostrar√© un ejemplo pr√°ctico de implementaci√≥n en GKE. <br><img src="https://habrastorage.org/webt/vc/vh/n6/vcvhn6ll9s46qdbwvurxheaykg8.png"><br><br>  A primera vista, esto puede parecer demasiado complicado, pero espero que puedan entender todo esto al final de esta publicaci√≥n.  En primer lugar, vemos que tenemos dos nodos de Kubernetes: Nodo 1 y Nodo (m).  Cada nodo tiene una interfaz eth0, como cualquier m√°quina Linux.  Esta interfaz tiene una direcci√≥n IP para el mundo exterior, en nuestro caso, en la subred 10.140.0.0/24.  El dispositivo Upstream L3 act√∫a como la puerta de enlace predeterminada para enrutar nuestro tr√°fico.  Puede ser un conmutador L3 en su centro de datos o un enrutador VPC en la nube, como GCP, como veremos m√°s adelante.  ¬øVa todo bien? <br><br>  Adem√°s, vemos que tenemos la interfaz Bridge cbr0 dentro del nodo.  Esta interfaz es la puerta de enlace predeterminada para la subred IP 10.40.1.0/24 en el caso del nodo 1. Kubernetes asigna esta subred a cada nodo.  Los nodos generalmente obtienen una subred / 24, pero puede cambiar esto usando NSX-T (lo cubriremos en las siguientes publicaciones).  Por el momento, esta subred es la que emitiremos direcciones IP para Pods.  De esta manera, cualquier Pod dentro del Nodo 1 obtendr√° una direcci√≥n IP de esta subred.  En nuestro caso, el Pod 1 tiene una direcci√≥n IP de 10.40.1.10.  Sin embargo, observa que hay dos contenedores anidados en este Pod.  Ya hemos dicho que dentro de un Pod se pueden lanzar uno o varios contenedores, que est√°n estrechamente relacionados entre s√≠ en t√©rminos de funcionalidad.  Esto es lo que vemos en la figura.  El contenedor 1 escucha en el puerto 80 y el contenedor 2 escucha en el puerto 90. Ambos contenedores tienen la misma direcci√≥n IP 10.40.1.10, pero no poseen el espacio de nombres de red.  OK, entonces, ¬øqui√©n es el due√±o de esta pila de red?  En realidad, hay un contenedor especial llamado "Pause Container".  El diagrama muestra que su direcci√≥n IP es la direcci√≥n IP de Pod para comunicarse con el mundo exterior.  Por lo tanto, Pause Container posee esta pila de red, incluida la direcci√≥n IP 10.40.1.10, y, por supuesto, redirige el tr√°fico al contenedor 1 al puerto 80, y tambi√©n redirige el tr√°fico al contenedor 2 al puerto 90. <br><br>  ¬øAhora tiene que preguntarse c√≥mo se redirige el tr√°fico al mundo exterior?  Tenemos el reenv√≠o IP est√°ndar de Linux habilitado para reenviar el tr√°fico de cbr0 a eth0.  Esto es genial, pero ¬øno est√° claro c√≥mo el dispositivo L3 puede aprender c√≥mo reenviar el tr√°fico a su destino?  En este ejemplo espec√≠fico, no tenemos enrutamiento din√°mico para el anuncio de esta red.  Por lo tanto, debemos tener alg√∫n tipo de rutas est√°ticas en el dispositivo L3.  Para llegar a la subred 10.40.1.0/24, debe reenviar el tr√°fico a la direcci√≥n IP del nodo 1 (10.140.0.11) y llegar a la subred 10.40.2.0/24, la pr√≥xima esperanza es el nodo (m) con la direcci√≥n IP 10.140.0.12. <br><br>  Todo esto es genial, pero es una forma poco pr√°ctica de administrar sus redes.  Soportar todas estas rutas mientras escala su cl√∫ster ser√° una pesadilla absoluta para los administradores de red.  Es por eso que se necesitan algunas soluciones, como CNI (Container Network Interface) en Kuberentes, para administrar la conectividad de red.  NSX-T es una de esas soluciones con una funcionalidad muy amplia tanto para la interacci√≥n de red como para la seguridad. <br><br>  Recuerde que miramos el complemento kubenet, no CNI.  El complemento de Kubenet es lo que utiliza Google Container Engine (GKE), y la forma en que lo hacen es bastante divertido porque est√° completamente definido por software y automatizado en su nube.  ,            GCP.     . <br><br><h3>  Que sigue </h3><br>     Kuberentes.        ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">   </a> . <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">La segunda parte</a> <br><br>     .    . <br>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es436028/">https://habr.com/ru/post/es436028/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es436016/index.html">Asterisk Voice Recognition IVR - R√°pido, F√°cil, Gratis</a></li>
<li><a href="../es436020/index.html">Magento 2: importaci√≥n de productos de fuentes externas</a></li>
<li><a href="../es436022/index.html">C√≥mo desarrollamos LibreK 5 DevKit completamente en software libre</a></li>
<li><a href="../es436024/index.html">C√≥mo no tirar basura en Java</a></li>
<li><a href="../es436026/index.html">Mesa de informaci√≥n: "Archivo de Internet" - historia, misi√≥n y proyectos subsidiarios</a></li>
<li><a href="../es436032/index.html">Tutorial React Parte 9: Propiedades del componente</a></li>
<li><a href="../es436036/index.html">¬øPueden los investigadores de inteligencia artificial confiarle una prueba de su trabajo?</a></li>
<li><a href="../es436038/index.html">El sonido del silencio: ¬øcu√°ntos aparatos locos son necesarios para lograr un entorno √≥ptimo para dormir?</a></li>
<li><a href="../es436040/index.html">Optimizaci√≥n de gr√°ficos. Interesante casco c√≥ncavo</a></li>
<li><a href="../es436042/index.html">Panel de herramientas adicionales para el desarrollador en InterSystems IRIS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>