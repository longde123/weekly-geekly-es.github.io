<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚è™ üö† ü§ôüèº √çndices no PostgreSQL - 7 (GIN) üõê ‚ôíÔ∏è üç¥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="J√° nos familiarizamos com o mecanismo de indexa√ß√£o do PostgreSQL e a interface dos m√©todos de acesso e discutimos √≠ndices de hash , √°rvores B e tamb√©m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>√çndices no PostgreSQL - 7 (GIN)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/448746/">  J√° nos familiarizamos com o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">mecanismo de indexa√ß√£o do</a> PostgreSQL e a interface dos m√©todos de acesso e discutimos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">√≠ndices de hash</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">√°rvores B e</a> tamb√©m os √≠ndices <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GiST</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SP-GiST</a> .  E este artigo apresentar√° o √≠ndice GIN. <br><br><h1>  Gin </h1><br>  <em>"Gin? .. Gin √©, ao que parece, uma bebida t√£o americana? .."</em> <em><br></em>  <em>"Eu n√£o sou um drinque, oh, garoto curioso!"</em>  <em>novamente o velho se acendeu, novamente percebeu a si mesmo e novamente se pegou na m√£o.</em>  <em>"Eu n√£o sou uma bebida, mas um esp√≠rito poderoso e destemido, e n√£o existe tal m√°gica no mundo que eu n√£o seria capaz de fazer".</em> <br>  - Lazar Lagin, "Velho Khottabych". <br><br>  <em>Gin significa √çndice Invertido Generalizado e deve ser considerado um g√™nio, n√£o uma bebida.</em> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">README</a> <br><a name="habracut"></a><br><h2>  Conceito geral </h2><br>  GIN √© o √çndice Invertido Generalizado abreviado.  Este √© o chamado <em>√≠ndice invertido</em> .  Ele manipula tipos de dados cujos valores n√£o s√£o at√¥micos, mas consistem em elementos.  Vamos chamar esses tipos de compostos.  E esses n√£o s√£o os valores que s√£o indexados, mas elementos individuais;  cada elemento faz refer√™ncia aos valores em que ocorre. <br><br>  Uma boa analogia a esse m√©todo √© o √≠ndice no final de um livro, que para cada termo fornece uma lista de p√°ginas em que esse termo ocorre.  O m√©todo de acesso deve garantir a pesquisa r√°pida de elementos indexados, assim como o √≠ndice de um livro.  Portanto, esses elementos s√£o armazenados como uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">√°rvore B</a> familiar (uma implementa√ß√£o diferente e mais simples √© usada para isso, mas n√£o importa nesse caso).  Um conjunto ordenado de refer√™ncias a linhas da tabela que cont√™m valores compostos com o elemento √© vinculado a cada elemento.  A ordem n√£o √© essencial para a recupera√ß√£o de dados (a ordem de classifica√ß√£o dos TIDs n√£o significa muito), mas importante para a estrutura interna do √≠ndice. <br><br>  Os elementos nunca s√£o exclu√≠dos do √≠ndice GIN.  Considera-se que os valores que cont√™m elementos podem desaparecer, surgir ou variar, mas o conjunto de elementos dos quais s√£o compostos √© mais ou menos est√°vel.  Essa solu√ß√£o simplifica significativamente os algoritmos para o trabalho simult√¢neo de v√°rios processos com o √≠ndice. <br><br>  Se a lista de TIDs for muito pequena, poder√° caber na mesma p√°gina que o elemento (e √© chamada de "lista de lan√ßamentos").  Mas se a lista for grande, √© necess√°ria uma estrutura de dados mais eficiente, e j√° estamos cientes disso - √© a √°rvore B novamente.  Essa √°rvore est√° localizada em p√°ginas de dados separadas (e √© chamada "a √°rvore de lan√ßamento"). <br><br>  Portanto, o √≠ndice GIN consiste na √°rvore B de elementos, e as √°rvores B ou listas planas de TIDs est√£o vinculadas √†s linhas das folhas dessa √°rvore B. <br><br>  Assim como os √≠ndices GiST e SP-GiST, discutidos anteriormente, o GIN fornece ao desenvolvedor de aplicativos a interface para oferecer suporte a v√°rias opera√ß√µes sobre tipos de dados compostos. <br><br><h2>  Pesquisa de texto completo </h2><br>  A principal √°rea de aplica√ß√£o do m√©todo GIN √© acelerar a pesquisa de texto completo, o que √©, portanto, razo√°vel para ser usado como exemplo em uma discuss√£o mais detalhada desse √≠ndice. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O artigo relacionado ao GiST</a> j√° forneceu uma pequena introdu√ß√£o √† pesquisa de texto completo, ent√£o vamos direto ao ponto sem repeti√ß√µes.  √â claro que os valores compostos, neste caso, s√£o <em>documentos</em> e os elementos desses documentos s√£o <em>lexemas</em> . <br><br>  Vamos considerar o exemplo do artigo relacionado ao GiST: <br><br><pre><code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> ts(doc <span class="hljs-type"><span class="hljs-type">text</span></span>, doc_tsv <span class="hljs-type"><span class="hljs-type">tsvector</span></span>); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> ts(doc) <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-string"><span class="hljs-string">'Can a sheet slitter slit sheets?'</span></span>), (<span class="hljs-string"><span class="hljs-string">'How many sheets could a sheet slitter slit?'</span></span>), (<span class="hljs-string"><span class="hljs-string">'I slit a sheet, a sheet I slit.'</span></span>), (<span class="hljs-string"><span class="hljs-string">'Upon a slitted sheet I sit.'</span></span>), (<span class="hljs-string"><span class="hljs-string">'Whoever slit the sheets is a good sheet slitter.'</span></span>), (<span class="hljs-string"><span class="hljs-string">'I am a sheet slitter.'</span></span>), (<span class="hljs-string"><span class="hljs-string">'I slit sheets.'</span></span>), (<span class="hljs-string"><span class="hljs-string">'I am the sleekest sheet slitter that ever slit sheets.'</span></span>), (<span class="hljs-string"><span class="hljs-string">'She slits the sheet she sits on.'</span></span>); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> ts <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> doc_tsv = to_tsvector(doc); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> ts <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gin(doc_tsv);</code> </pre> <br>  Uma estrutura poss√≠vel desse √≠ndice √© mostrada na figura: <br><br><img src="https://habrastorage.org/webt/lc/nh/m-/lcnhm-vqquxgvzpklv8kemu6z-a.png"><br><br>  Diferentemente de todas as figuras anteriores, as refer√™ncias √†s linhas da tabela (TIDs) s√£o indicadas com valores num√©ricos em um fundo escuro (o n√∫mero da p√°gina e a posi√ß√£o na p√°gina), e n√£o com as setas. <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> ctid, left(doc,<span class="hljs-number"><span class="hljs-number">20</span></span>), doc_tsv <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ts;</code> </pre><pre> <code class="plaintext hljs"> ctid | left | doc_tsv -------+----------------------+--------------------------------------------------------- (0,1) | Can a sheet slitter | 'sheet':3,6 'slit':5 'slitter':4 (0,2) | How many sheets coul | 'could':4 'mani':2 'sheet':3,6 'slit':8 'slitter':7 (0,3) | I slit a sheet, a sh | 'sheet':4,6 'slit':2,8 (1,1) | Upon a slitted sheet | 'sheet':4 'sit':6 'slit':3 'upon':1 (1,2) | Whoever slit the she | 'good':7 'sheet':4,8 'slit':2 'slitter':9 'whoever':1 (1,3) | I am a sheet slitter | 'sheet':4 'slitter':5 (2,1) | I slit sheets. | 'sheet':3 'slit':2 (2,2) | I am the sleekest sh | 'ever':8 'sheet':5,10 'sleekest':4 'slit':9 'slitter':6 (2,3) | She slits the sheet | 'sheet':4 'sit':6 'slit':2 (9 rows)</code> </pre><br>  Neste exemplo especulativo, a lista de TIDs se encaixa em p√°ginas regulares para todos os lexemas, exceto "folha", "fenda" e "talhadeira".  Esses lexemes ocorreram em muitos documentos e as listas de TIDs foram colocadas em √°rvores B individuais. <br><br>  A prop√≥sito, como podemos descobrir quantos documentos cont√™m um l√©xico?  Para uma tabela pequena, uma t√©cnica ‚Äúdireta‚Äù, mostrada abaixo, funcionar√°, mas aprenderemos mais o que fazer com as maiores. <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> (unnest(doc_tsv)).lexeme, count(*) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ts <span class="hljs-keyword"><span class="hljs-keyword">group</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">desc</span></span>;</code> </pre><pre> <code class="plaintext hljs"> lexeme | count ----------+------- sheet | 9 slit | 8 slitter | 5 sit | 2 upon | 1 mani | 1 whoever | 1 sleekest | 1 good | 1 could | 1 ever | 1 (11 rows)</code> </pre><br>  Observe tamb√©m que, diferentemente de uma √°rvore B comum, as p√°ginas do √≠ndice GIN s√£o conectadas por uma lista unidirecional, e n√£o bidirecional.  Isso √© suficiente, pois uma travessia de √°rvore √© feita apenas de uma maneira. <br><br><h3>  Exemplo de uma Consulta </h3><br>  Como a seguinte consulta ser√° executada para o nosso exemplo? <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> doc <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ts <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> doc_tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'many &amp; slitter'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN --------------------------------------------------------------------- Bitmap Heap Scan on ts Recheck Cond: (doc_tsv @@ to_tsquery('many &amp; slitter'::text)) -&gt; Bitmap Index Scan on ts_doc_tsv_idx Index Cond: (doc_tsv @@ to_tsquery('many &amp; slitter'::text)) (4 rows)</code> </pre><br>  Os lexemes individuais (chaves de pesquisa) s√£o extra√≠dos da consulta primeiro: "mani" e "slitter".  Isso √© feito por uma fun√ß√£o API especializada que leva em conta o tipo de dados e a estrat√©gia determinados pela classe de operador <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> amop.amopopr::<span class="hljs-type"><span class="hljs-type">regoperator</span></span>, amop.amopstrategy <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_opclass opc, pg_opfamily opf, pg_am am, pg_amop amop <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> opc.opcname = <span class="hljs-string"><span class="hljs-string">'tsvector_ops'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> opf.oid = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.oid = opf.opfmethod <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amopfamily = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.amname = <span class="hljs-string"><span class="hljs-string">'gin'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amoplefttype = opc.opcintype;</code> </pre><pre> <code class="plaintext hljs"> amopopr | amopstrategy -----------------------+-------------- @@(tsvector,tsquery) | 1 matching search query @@@(tsvector,tsquery) | 2 synonym for @@ (for backward compatibility) (2 rows)</code> </pre><br>  Na √°rvore B dos lexemas, encontramos as duas chaves e examinamos as listas prontas de IDs.  Temos: <br><br>  para "mani" - (0,2). <br>  para "talhadeira" - (0,1), (0,2), (1,2), (1,3), (2,2). <br><br><img src="https://habrastorage.org/webt/mg/qc/do/mgqcdou-xlhsztvkxii5qluc5rq.png"><br><br>  Finalmente, para cada TID encontrado, √© chamada uma fun√ß√£o de consist√™ncia da API, que deve determinar quais linhas encontradas correspondem √† consulta de pesquisa.  Como os lexemes em nossa consulta s√£o unidos por Boolean "e", a √∫nica linha retornada √© (0,2): <br><br><pre> <code class="plaintext hljs"> | | | consistency | | | function TID | mani | slitter | slit &amp; slitter -------+------+---------+---------------- (0,1) | f | T | f (0,2) | T | T | T (1,2) | f | T | f (1,3) | f | T | f (2,2) | f | T | f</code> </pre><br>  E o resultado √©: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> doc <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ts <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> doc_tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'many &amp; slitter'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> doc --------------------------------------------- How many sheets could a sheet slitter slit? (1 row)</code> </pre><br>  Se compararmos essa abordagem com a j√° discutida no GiST, a vantagem do GIN para a pesquisa de texto completo parece evidente.  Mas h√° mais nisso do que aparenta. <br><br><h3>  O problema de uma atualiza√ß√£o lenta </h3><br>  O problema √© que a inser√ß√£o ou atualiza√ß√£o de dados no √≠ndice GIN √© bem lenta.  Cada documento geralmente cont√©m muitos lexemes a serem indexados.  Portanto, quando apenas um documento √© adicionado ou atualizado, precisamos atualizar massivamente a √°rvore de √≠ndices. <br><br>  Por outro lado, se v√°rios documentos forem atualizados simultaneamente, alguns de seus lexemas podem ser os mesmos e a quantidade total de trabalho ser√° menor do que na atualiza√ß√£o de documentos um por um. <br><br>  O √≠ndice GIN possui um par√¢metro de armazenamento "fastupdate", que podemos especificar durante a cria√ß√£o e atualiza√ß√£o do √≠ndice posteriormente: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> ts <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gin(doc_tsv) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> (fastupdate = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>);</code> </pre><br>  Com esse par√¢metro ativado, as atualiza√ß√µes ser√£o acumuladas em uma lista n√£o ordenada separada (em p√°ginas conectadas individuais).  Quando essa lista fica grande o suficiente ou durante a aspira√ß√£o, todas as atualiza√ß√µes acumuladas s√£o feitas instantaneamente no √≠ndice.  A lista a considerar "suficientemente grande" √© determinada pelo par√¢metro de configura√ß√£o "gin_pending_list_limit" ou pelo par√¢metro de armazenamento com o mesmo nome do √≠ndice. <br><br>  Mas essa abordagem tem desvantagens: primeiro, a pesquisa √© mais lenta (uma vez que a lista n√£o ordenada precisa ser examinada al√©m da √°rvore) e, segundo, uma pr√≥xima atualiza√ß√£o pode levar inesperadamente muito tempo se a lista n√£o ordenada for excedida. <br><br><h3>  Pesquisa de uma correspond√™ncia parcial </h3><br>  Podemos usar correspond√™ncia parcial na pesquisa de texto completo.  Por exemplo, considere a seguinte consulta: <br><br><pre> <code class="pgsql hljs">gin=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> doc <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ts <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> doc_tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'slit:*'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> doc -------------------------------------------------------- Can a sheet slitter slit sheets? How many sheets could a sheet slitter slit? I slit a sheet, a sheet I slit. Upon a slitted sheet I sit. Whoever slit the sheets is a good sheet slitter. I am a sheet slitter. I slit sheets. I am the sleekest sheet slitter that ever slit sheets. She slits the sheet she sits on. (9 rows)</code> </pre><br>  Esta consulta encontrar√° documentos que cont√™m lexemas come√ßando com "fenda".  Neste exemplo, esses lexemes s√£o "fenda" e "talhadeira". <br><br>  Uma consulta certamente funcionar√° de qualquer maneira, mesmo sem √≠ndices, mas o GIN tamb√©m permite acelerar a seguinte pesquisa: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> doc <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ts <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> doc_tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'slit:*'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------------------------------------------- Bitmap Heap Scan on ts Recheck Cond: (doc_tsv @@ to_tsquery('slit:*'::text)) -&gt; Bitmap Index Scan on ts_doc_tsv_idx Index Cond: (doc_tsv @@ to_tsquery('slit:*'::text)) (4 rows)</code> </pre><br>  Aqui todos os lexemes com o prefixo especificado na consulta de pesquisa s√£o procurados na √°rvore e unidos por booleano "ou". <br><br><h3>  Lexemes frequentes e pouco frequentes </h3><br>  Para observar como a indexa√ß√£o funciona com dados ao vivo, vamos pegar o arquivo de e-mail "pgsql-hackers", que j√° usamos ao discutir o GiST.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Esta vers√£o do arquivo</a> cont√©m 356125 mensagens com a data de envio, assunto, autor e texto. <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> <span class="hljs-keyword"><span class="hljs-keyword">column</span></span> tsv <span class="hljs-type"><span class="hljs-type">tsvector</span></span>; fts=# <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> tsv = to_tsvector(body_plain);</code> </pre><pre> <code class="plaintext hljs">NOTICE: word is too long to be indexed DETAIL: Words longer than 2047 characters are ignored. ... UPDATE 356125</code> </pre><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gin(tsv);</code> </pre><br>  Vamos considerar um l√©xico que ocorre em muitos documentos.  A consulta que usa "unnest" n√£o funcionar√° em um tamanho de dados t√£o grande, e a t√©cnica correta √© usar a fun√ß√£o "ts_stat", que fornece as informa√ß√µes sobre lexemes, o n√∫mero de documentos em que eles ocorreram e o n√∫mero total de ocorr√™ncias. <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> word, ndoc <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ts_stat(<span class="hljs-string"><span class="hljs-string">'select tsv from mail_messages'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> ndoc <span class="hljs-keyword"><span class="hljs-keyword">desc</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>;</code> </pre><pre> <code class="plaintext hljs"> word | ndoc -------+-------- re | 322141 wrote | 231174 use | 176917 (3 rows)</code> </pre><br>  Vamos escolher "escreveu". <br><br>  E usaremos uma palavra que n√£o √© frequente no e-mail dos desenvolvedores, como "tatuagem": <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> word, ndoc <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ts_stat(<span class="hljs-string"><span class="hljs-string">'select tsv from mail_messages'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> word = <span class="hljs-string"><span class="hljs-string">'tattoo'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> word | ndoc --------+------ tattoo | 2 (1 row)</code> </pre><br>  Existem documentos onde esses dois lexemes ocorrem?  Parece que existem: <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'wrote &amp; tattoo'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> count ------- 1 (1 row)</code> </pre><br>  Surge uma pergunta sobre como executar esta consulta.  Se obtivermos listas de TIDs para ambos os lexemas, como descrito acima, a pesquisa ser√° evidentemente ineficiente: teremos que passar por mais de 200 mil valores, restando apenas um deles.  Felizmente, usando as estat√≠sticas do planejador, o algoritmo entende que o l√©xico "escrito" ocorre com frequ√™ncia, enquanto "tatoo" ocorre com pouca frequ√™ncia.  Portanto, √© realizada a pesquisa do lexeme infreq√ºente e os dois documentos recuperados s√£o verificados quanto √† ocorr√™ncia de lexeme "gravado".  E isso fica claro na consulta, que √© realizada rapidamente: <br><br><pre> <code class="pgsql hljs">fts=# \<span class="hljs-keyword"><span class="hljs-keyword">timing</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'wrote &amp; tattoo'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> count ------- 1 (1 row) Time: 0,959 ms</code> </pre><br>  A pesquisa de "escreveu" sozinha leva significativamente mais tempo: <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'wrote'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> count -------- 231174 (1 row) Time: 2875,543 ms (00:02,876)</code> </pre><br>  Essa otimiza√ß√£o certamente funciona n√£o apenas para dois lexemas, mas tamb√©m em casos mais complexos. <br><br><h3>  Limitando o resultado da consulta </h3><br>  Um recurso do m√©todo de acesso GIN √© que o resultado √© sempre retornado como um bitmap: esse m√©todo n√£o pode retornar o resultado TID por TID.  √â por isso que todos os planos de consulta neste artigo usam verifica√ß√£o de bitmap. <br><br>  Portanto, a limita√ß√£o do resultado da varredura de √≠ndice usando a cl√°usula LIMIT n√£o √© muito eficiente.  Preste aten√ß√£o ao custo previsto da opera√ß√£o (campo "custo" do n√≥ "Limite"): <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'wrote'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ----------------------------------------------------------------------------------------- Limit (cost=1283.61..1285.13 rows=1) -&gt; Bitmap Heap Scan on mail_messages (cost=1283.61..209975.49 rows=137207) Recheck Cond: (tsv @@ to_tsquery('wrote'::text)) -&gt; Bitmap Index Scan on mail_messages_tsv_idx (cost=0.00..1249.30 rows=137207) Index Cond: (tsv @@ to_tsquery('wrote'::text)) (5 rows)</code> </pre><br>  O custo √© estimado em 1285.13, um pouco maior que o custo da constru√ß√£o de todo o bitmap 1249.30 (campo "cost" do n√≥ Bitmap Index Scan). <br><br>  Portanto, o √≠ndice possui uma capacidade especial para limitar o n√∫mero de resultados.  O valor do limite √© especificado no par√¢metro de configura√ß√£o "gin_fuzzy_search_limit" e √© igual a zero por padr√£o (nenhuma limita√ß√£o ocorre).  Mas podemos definir o valor limite: <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> gin_fuzzy_search_limit = <span class="hljs-number"><span class="hljs-number">1000</span></span>; fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'wrote'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> count ------- 5746 (1 row)</code> </pre><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> gin_fuzzy_search_limit = <span class="hljs-number"><span class="hljs-number">10000</span></span>; fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'wrote'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> count ------- 14726 (1 row)</code> </pre><br>  Como podemos ver, o n√∫mero de linhas retornadas pela consulta difere para diferentes valores de par√¢metros (se o acesso ao √≠ndice for usado).  A limita√ß√£o n√£o √© estrita: mais linhas do que as especificadas podem ser retornadas, o que justifica parte "difusa" do nome do par√¢metro. <br><br><h3>  Representa√ß√£o compacta </h3><br>  Entre os demais, os √≠ndices GIN s√£o bons, gra√ßas √† sua compacidade.  Primeiro, se um mesmo lexeme ocorrer em v√°rios documentos (e esse geralmente √© o caso), ele ser√° armazenado no √≠ndice apenas uma vez.  Segundo, os TIDs s√£o armazenados no √≠ndice de maneira ordenada, e isso nos permite usar uma compacta√ß√£o simples: cada pr√≥ximo TID da lista √© realmente armazenado como sua diferen√ßa em rela√ß√£o ao anterior;  esse geralmente √© um n√∫mero pequeno, que requer muito menos bits que um TID completo de seis bytes. <br><br>  Para ter uma id√©ia do tamanho, vamos construir uma √°rvore B a partir do texto das mensagens.  Mas uma compara√ß√£o justa certamente n√£o vai acontecer: <br><br><ul><li>  O GIN √© criado com um tipo de dados diferente ("tsvector" em vez de "texto"), que √© menor, </li><li>  ao mesmo tempo, o tamanho das mensagens para a √°rvore B deve ser reduzido para aproximadamente dois kilobytes. </li></ul><br>  No entanto, continuamos: <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> mail_messages_btree <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> mail_messages(substring(body_plain <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-number"><span class="hljs-number">2048</span></span>));</code> </pre><br>  Tamb√©m criaremos o √≠ndice GiST: <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> mail_messages_gist <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gist(tsv);</code> </pre><br>  O tamanho dos √≠ndices no "v√°cuo cheio": <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> pg_size_pretty(pg_relation_size(<span class="hljs-string"><span class="hljs-string">'mail_messages_tsv_idx'</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> gin, pg_size_pretty(pg_relation_size(<span class="hljs-string"><span class="hljs-string">'mail_messages_gist'</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> gist, pg_size_pretty(pg_relation_size(<span class="hljs-string"><span class="hljs-string">'mail_messages_btree'</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> btree;</code> </pre><pre> <code class="plaintext hljs"> gin | gist | btree --------+--------+-------- 179 MB | 125 MB | 546 MB (1 row)</code> </pre><br>  Devido √† compacta√ß√£o da representa√ß√£o, podemos tentar usar o √≠ndice GIN durante a migra√ß√£o do Oracle como um substituto para √≠ndices de bitmap (sem entrar em detalhes, forne√ßo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">uma refer√™ncia √† postagem de Lewis</a> para mentes inquisitivas).  Como regra, √≠ndices de bitmap s√£o usados ‚Äã‚Äãpara campos com poucos valores exclusivos, o que tamb√©m √© excelente para o GIN.  E, como mostrado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">no primeiro artigo</a> , o PostgreSQL pode criar um bitmap com base em qualquer √≠ndice, incluindo GIN, em tempo real. <br><br><h3>  GiST ou GIN? </h3><br>  Para muitos tipos de dados, as classes de operadores est√£o dispon√≠veis para GiST e GIN, o que levanta uma quest√£o sobre qual √≠ndice usar.  Talvez j√° possamos tirar algumas conclus√µes. <br><br>  Como regra, o GIN supera o GiST em precis√£o e velocidade de pesquisa.  Se os dados n√£o forem atualizados com frequ√™ncia e a pesquisa r√°pida for necess√°ria, provavelmente o GIN ser√° uma op√ß√£o. <br><br>  Por outro lado, se os dados forem atualizados intensivamente, os custos indiretos da atualiza√ß√£o do GIN podem parecer muito grandes.  Nesse caso, teremos que comparar as duas op√ß√µes e escolher aquela cujas caracter√≠sticas s√£o mais equilibradas. <br><br><h2>  Matrizes </h2><br>  Outro exemplo de uso do GIN √© a indexa√ß√£o de matrizes.  Nesse caso, os elementos da matriz entram no √≠ndice, o que permite acelerar v√°rias opera√ß√µes nas matrizes: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> amop.amopopr::<span class="hljs-type"><span class="hljs-type">regoperator</span></span>, amop.amopstrategy <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_opclass opc, pg_opfamily opf, pg_am am, pg_amop amop <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> opc.opcname = <span class="hljs-string"><span class="hljs-string">'array_ops'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> opf.oid = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.oid = opf.opfmethod <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amopfamily = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.amname = <span class="hljs-string"><span class="hljs-string">'gin'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amoplefttype = opc.opcintype;</code> </pre><pre> <code class="plaintext hljs"> amopopr | amopstrategy -----------------------+-------------- &amp;&amp;(anyarray,anyarray) | 1 intersection @&gt;(anyarray,anyarray) | 2 contains array &lt;@(anyarray,anyarray) | 3 contained in array =(anyarray,anyarray) | 4 equality (4 rows)</code> </pre><br>  Nosso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">banco de dados de demonstra√ß√£o</a> possui visualiza√ß√£o de "rotas" com informa√ß√µes sobre voos.  Entre o restante, essa exibi√ß√£o cont√©m a coluna "days_of_week" - uma matriz de dias da semana em que os voos ocorrem.  Por exemplo, um voo de Vnukovo para Gelendzhik sai √†s ter√ßas, quintas e domingos: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> departure_airport_name, arrival_airport_name, days_of_week <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> routes <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> flight_no = <span class="hljs-string"><span class="hljs-string">'PG0049'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> departure_airport_name | arrival_airport_name | days_of_week ------------------------+----------------------+-------------- Vnukovo | Gelendzhik | {2,4,7} (1 row)</code> </pre><br>  Para criar o √≠ndice, vamos "materializar" a visualiza√ß√£o em uma tabela: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> routes_t <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> routes; demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> routes_t <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gin(days_of_week);</code> </pre><br><br>  Agora podemos usar o √≠ndice para conhecer todos os voos que partem √†s ter√ßas, quintas e domingos: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> routes_t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> days_of_week = <span class="hljs-keyword"><span class="hljs-keyword">ARRAY</span></span>[<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">7</span></span>];</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ----------------------------------------------------------- Bitmap Heap Scan on routes_t Recheck Cond: (days_of_week = '{2,4,7}'::integer[]) -&gt; Bitmap Index Scan on routes_t_days_of_week_idx Index Cond: (days_of_week = '{2,4,7}'::integer[]) (4 rows)</code> </pre><br>  Parece que existem seis deles: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> flight_no, departure_airport_name, arrival_airport_name, days_of_week <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> routes_t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> days_of_week = <span class="hljs-keyword"><span class="hljs-keyword">ARRAY</span></span>[<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">7</span></span>];</code> </pre><pre> <code class="plaintext hljs"> flight_no | departure_airport_name | arrival_airport_name | days_of_week -----------+------------------------+----------------------+-------------- PG0005 | Domodedovo | Pskov | {2,4,7} PG0049 | Vnukovo | Gelendzhik | {2,4,7} PG0113 | Naryan-Mar | Domodedovo | {2,4,7} PG0249 | Domodedovo | Gelendzhik | {2,4,7} PG0449 | Stavropol | Vnukovo | {2,4,7} PG0540 | Barnaul | Vnukovo | {2,4,7} (6 rows)</code> </pre><br>  Como essa consulta √© realizada?  Exatamente da mesma maneira descrita acima: <br><br><ol><li>  Da matriz {2,4,7}, que desempenha o papel da consulta de pesquisa aqui, elementos (palavras-chave de pesquisa) s√£o extra√≠dos.  Evidentemente, esses s√£o os valores de "2", "4" e "7". <br></li><li>  Na √°rvore de elementos, as chaves extra√≠das s√£o encontradas e, para cada um deles, a lista de TIDs √© selecionada. <br></li><li>  De todos os TIDs encontrados, a fun√ß√£o de consist√™ncia seleciona aqueles que correspondem ao operador na consulta.  Para o operador <code>=</code> , apenas os TIDs correspondem ao que ocorreu nas tr√™s listas (em outras palavras, a matriz inicial deve conter todos os elementos).  Mas isso n√£o √© suficiente: tamb√©m √© necess√°rio que a matriz n√£o contenha outros valores e n√£o podemos verificar essa condi√ß√£o com o √≠ndice.  Portanto, nesse caso, o m√©todo de acesso solicita que o mecanismo de indexa√ß√£o verifique novamente todos os TIDs retornados com a tabela. <br></li></ol><br>  Curiosamente, existem estrat√©gias (por exemplo, "contidas na matriz") que n√£o podem verificar nada e precisam verificar novamente todos os TIDs encontrados na tabela. <br><br>  Mas o que fazer se precisarmos conhecer os voos que partem de Moscou √†s ter√ßas, quintas e domingos?  O √≠ndice n√£o suporta a condi√ß√£o adicional, que entra na coluna "Filtro". <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> routes_t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> days_of_week = <span class="hljs-keyword"><span class="hljs-keyword">ARRAY</span></span>[<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">7</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> departure_city = <span class="hljs-string"><span class="hljs-string">'Moscow'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ----------------------------------------------------------- Bitmap Heap Scan on routes_t Recheck Cond: (days_of_week = '{2,4,7}'::integer[]) Filter: (departure_city = 'Moscow'::text) -&gt; Bitmap Index Scan on routes_t_days_of_week_idx Index Cond: (days_of_week = '{2,4,7}'::integer[]) (5 rows)</code> </pre><br>  Aqui est√° OK (o √≠ndice seleciona apenas seis linhas de qualquer maneira), mas nos casos em que a condi√ß√£o adicional aumenta a capacidade seletiva, √© desej√°vel ter esse suporte.  No entanto, n√£o podemos apenas criar o √≠ndice: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> routes_t <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gin(days_of_week,departure_city);</code> </pre><pre> <code class="plaintext hljs">ERROR: data type text has no default operator class for access method "gin" HINT: You must specify an operator class for the index or define a default operator class for the data type.</code> </pre><br>  Mas a extens√£o " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">btree_gin</a> " ajudar√°, o que adiciona classes de operadores GIN que simulam o trabalho de uma √°rvore B comum. <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extension</span></span> btree_gin; demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> routes_t <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gin(days_of_week,departure_city); demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> routes_t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> days_of_week = <span class="hljs-keyword"><span class="hljs-keyword">ARRAY</span></span>[<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">7</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> departure_city = <span class="hljs-string"><span class="hljs-string">'Moscow'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN --------------------------------------------------------------------- Bitmap Heap Scan on routes_t Recheck Cond: ((days_of_week = '{2,4,7}'::integer[]) AND (departure_city = 'Moscow'::text)) -&gt; Bitmap Index Scan on routes_t_days_of_week_departure_city_idx Index Cond: ((days_of_week = '{2,4,7}'::integer[]) AND (departure_city = 'Moscow'::text)) (4 rows)</code> </pre><br><h2>  Jsonb </h2><br>  Mais um exemplo de um tipo de dados composto que possui suporte GIN interno √© JSON.  Para trabalhar com valores JSON, v√°rios operadores e fun√ß√µes s√£o definidos no momento, alguns dos quais podem ser acelerados usando √≠ndices: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> opc.opcname, amop.amopopr::<span class="hljs-type"><span class="hljs-type">regoperator</span></span>, amop.amopstrategy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> str <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_opclass opc, pg_opfamily opf, pg_am am, pg_amop amop <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> opc.opcname <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (<span class="hljs-string"><span class="hljs-string">'jsonb_ops'</span></span>,<span class="hljs-string"><span class="hljs-string">'jsonb_path_ops'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> opf.oid = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.oid = opf.opfmethod <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amopfamily = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.amname = <span class="hljs-string"><span class="hljs-string">'gin'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amoplefttype = opc.opcintype;</code> </pre><pre> <code class="plaintext hljs"> opcname | amopopr | str ----------------+------------------+----- jsonb_ops | ?(jsonb,text) | 9 top-level key exists jsonb_ops | ?|(jsonb,text[]) | 10 some top-level key exists jsonb_ops | ?&amp;(jsonb,text[]) | 11 all top-level keys exist jsonb_ops | @&gt;(jsonb,jsonb) | 7 JSON value is at top level jsonb_path_ops | @&gt;(jsonb,jsonb) | 7 (5 rows)</code> </pre><br>  Como podemos ver, duas classes de operadores est√£o dispon√≠veis: "jsonb_ops" e "jsonb_path_ops". <br><br>  A primeira classe de operador "jsonb_ops" √© usada por padr√£o.  Todas as chaves, valores e elementos da matriz chegam ao √≠ndice como elementos do documento JSON inicial.  Um atributo √© adicionado a cada um desses elementos, o que indica se esse elemento √© uma chave (isso √© necess√°rio para estrat√©gias "existentes", que distinguem entre chaves e valores). <br><br>  Por exemplo, vamos representar algumas linhas de "rotas" como JSON da seguinte maneira: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> routes_jsonb <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> to_jsonb(t) route <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> departure_airport_name, arrival_airport_name, days_of_week <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> routes <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> flight_no <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> ) t; demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> ctid, jsonb_pretty(route) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> routes_jsonb;</code> </pre><pre> <code class="plaintext hljs"> ctid | jsonb_pretty -------+------------------------------------------------- (0,1) | { + | "days_of_week": [ + | 1 + | ], + | "arrival_airport_name": "Surgut", + | "departure_airport_name": "Ust-Ilimsk" + | } (0,2) | { + | "days_of_week": [ + | 2 + | ], + | "arrival_airport_name": "Ust-Ilimsk", + | "departure_airport_name": "Surgut" + | } (0,3) | { + | "days_of_week": [ + | 1, + | 4 + | ], + | "arrival_airport_name": "Sochi", + | "departure_airport_name": "Ivanovo-Yuzhnyi"+ | } (0,4) | { + | "days_of_week": [ + | 2, + | 5 + | ], + | "arrival_airport_name": "Ivanovo-Yuzhnyi", + | "departure_airport_name": "Sochi" + | } (4 rows)</code> </pre><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> routes_jsonb <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gin(route);</code> </pre><br><br>  O √≠ndice pode ter a seguinte apar√™ncia: <br><br><img src="https://habrastorage.org/webt/oo/yi/x3/ooyix34gx7mrpiwdcol3a3ewnwu.png"><br><br>  Agora, uma consulta como esta, por exemplo, pode ser realizada usando o √≠ndice: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> jsonb_pretty(route) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> routes_jsonb <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> route @&gt; <span class="hljs-string"><span class="hljs-string">'{"days_of_week": [5]}'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN --------------------------------------------------------------- Bitmap Heap Scan on routes_jsonb Recheck Cond: (route @&gt; '{"days_of_week": [5]}'::jsonb) -&gt; Bitmap Index Scan on routes_jsonb_route_idx Index Cond: (route @&gt; '{"days_of_week": [5]}'::jsonb) (4 rows)</code> </pre><br>  Come√ßando com a raiz do documento JSON, o operador <code>@&gt;</code> verifica se a rota especificada ( <code>"days_of_week": [5]</code> ) ocorre.  Aqui a consulta retornar√° uma linha: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> jsonb_pretty(route) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> routes_jsonb <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> route @&gt; <span class="hljs-string"><span class="hljs-string">'{"days_of_week": [5]}'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> jsonb_pretty ------------------------------------------------ { + "days_of_week": [ + 2, + 5 + ], + "arrival_airport_name": "Ivanovo-Yuzhnyi",+ "departure_airport_name": "Sochi" + } (1 row)</code> </pre><br>  A consulta √© realizada da seguinte maneira: <br><br><ol><li>  Na consulta de pesquisa ( <code>"days_of_week": [5]</code> ) os elementos (chaves de pesquisa) s√£o extra√≠dos: "days_of_week" e "5". <br></li><li>  Na √°rvore de elementos, as chaves extra√≠das s√£o encontradas e, para cada um deles, a lista de TIDs √© selecionada: para "5" - (0,4) e para "dias_de_semana" - (0,1), (0,2 ), (0,3), (0,4). <br></li><li>  De todos os TIDs encontrados, a fun√ß√£o de consist√™ncia seleciona aqueles que correspondem ao operador na consulta.  Para o operador <code>@&gt;</code> , os documentos que n√£o cont√™m todos os elementos da consulta de pesquisa n√£o ser√£o suficientes, portanto, apenas (0,4) ser√° deixado.  Mas ainda precisamos verificar novamente o TID deixado com a tabela, pois n√£o est√° claro no √≠ndice em que ordem os elementos encontrados ocorrem no documento JSON. <br></li></ol><br>  Para descobrir mais detalhes de outros operadores, voc√™ pode ler <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">a documenta√ß√£o</a> . <br><br>  Al√©m das opera√ß√µes convencionais para lidar com JSON, a extens√£o "jsquery" est√° dispon√≠vel h√° muito tempo, que define uma linguagem de consulta com recursos mais avan√ßados (e certamente com suporte aos √≠ndices GIN).  Al√©m disso, em 2016, foi emitido um novo padr√£o SQL, que define seu pr√≥prio conjunto de opera√ß√µes e a linguagem de consulta "caminho SQL / JSON".  Uma implementa√ß√£o deste padr√£o j√° foi realizada e acreditamos que ele aparecer√° no PostgreSQL 11. <br><br><blockquote>  O patch do caminho SQL / JSON foi finalmente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">confirmado</a> no PostgreSQL 12, enquanto outras partes ainda est√£o a caminho.  Esperamos ver o recurso totalmente implementado no PostgreSQL 13. <br></blockquote><br><h2>  Internals </h2><br>  Podemos examinar o √≠ndice GIN usando a extens√£o " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pageinspect</a> ". <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extension</span></span> pageinspect;</code> </pre><br>  As informa√ß√µes da p√°gina meta mostram estat√≠sticas gerais: <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> gin_metapage_info(get_raw_page(<span class="hljs-string"><span class="hljs-string">'mail_messages_tsv_idx'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>));</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]----+----------- pending_head | 4294967295 pending_tail | 4294967295 tail_free_size | 0 n_pending_pages | 0 n_pending_tuples | 0 n_total_pages | 22968 n_entry_pages | 13751 n_data_pages | 9216 n_entries | 1423598 version | 2</code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">A estrutura da p√°gina</a> fornece uma √°rea especial onde os m√©todos de acesso armazenam suas informa√ß√µes;  essa √°rea √© "opaca" para programas comuns, como o v√°cuo.  A fun√ß√£o "Gin_page_opaque_info" mostra esses dados para o GIN.  Por exemplo, podemos conhecer o conjunto de p√°ginas de √≠ndice: <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> flags, count(*) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">22967</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> g(id), <span class="hljs-comment"><span class="hljs-comment">-- n_total_pages gin_page_opaque_info(get_raw_page('mail_messages_tsv_idx',g.id)) group by flags;</span></span></code> </pre><pre> <code class="plaintext hljs"> flags | count ------------------------+------- {meta} | 1 meta page {} | 133 internal page of element B-tree {leaf} | 13618 leaf page of element B-tree {data} | 1497 internal page of TID B-tree {data,leaf,compressed} | 7719 leaf page of TID B-tree (5 rows)</code> </pre><br>  A fun√ß√£o "Gin_leafpage_items" fornece informa√ß√µes sobre os TIDs armazenados nas p√°ginas {data, leaf, compactado}: <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> gin_leafpage_items(get_raw_page(<span class="hljs-string"><span class="hljs-string">'mail_messages_tsv_idx'</span></span>,<span class="hljs-number"><span class="hljs-number">2672</span></span>));</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]--------------------------------------------------------------------- first_tid | (239,44) nbytes | 248 tids | {"(239,44)","(239,47)","(239,48)","(239,50)","(239,52)","(240,3)",... -[ RECORD 2 ]--------------------------------------------------------------------- first_tid | (247,40) nbytes | 248 tids | {"(247,40)","(247,41)","(247,44)","(247,45)","(247,46)","(248,2)",... ...</code> </pre><br>  Observe aqui que as p√°ginas da √°rvore dos TIDs cont√™m, na verdade, pequenas listas compactadas de ponteiros para linhas da tabela, em vez de ponteiros individuais. <br><br><h2>  Propriedades </h2><br>  Vamos examinar as propriedades do m√©todo de acesso GIN (consultas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">j√° foram fornecidas</a> ). <br><br><pre> <code class="plaintext hljs"> amname | name | pg_indexam_has_property --------+---------------+------------------------- gin | can_order | f gin | can_unique | f gin | can_multi_col | t gin | can_exclude | f</code> </pre><br>  Curiosamente, o GIN suporta a cria√ß√£o de √≠ndices com v√°rias colunas.  No entanto, diferentemente de uma √°rvore B comum, em vez de chaves compostas, um √≠ndice de v√°rias colunas ainda armazenar√° elementos individuais e o n√∫mero da coluna ser√° indicado para cada elemento. <br><br>  As seguintes propriedades da camada de √≠ndice est√£o dispon√≠veis: <br><br><pre> <code class="plaintext hljs"> name | pg_index_has_property ---------------+----------------------- clusterable | f index_scan | f bitmap_scan | t backward_scan | f</code> </pre><br>  Observe que o retorno de resultados TID por TID (varredura de √≠ndice) n√£o √© suportado;  somente a verifica√ß√£o de bitmap √© poss√≠vel. <br><br>  A verifica√ß√£o reversa tamb√©m n√£o √© suportada: esse recurso √© essencial apenas para a verifica√ß√£o de √≠ndice, mas n√£o para a verifica√ß√£o de bitmap. <br><br>  E a seguir est√£o as propriedades da camada de coluna: <br><br><pre> <code class="plaintext hljs"> name | pg_index_column_has_property --------------------+------------------------------ asc | f desc | f nulls_first | f nulls_last | f orderable | f distance_orderable | f returnable | f search_array | f search_nulls | f</code> </pre><br>  Nada est√° dispon√≠vel aqui: sem classifica√ß√£o (o que √© claro), sem uso do √≠ndice como cobertura (uma vez que o documento em si n√£o est√° armazenado no √≠ndice), sem manipula√ß√£o de NULLs (pois n√£o faz sentido para elementos do tipo composto) . <br><br><h2>  Outros tipos de dados </h2><br>  Est√£o dispon√≠veis mais algumas extens√µes que adicionam suporte ao GIN para alguns tipos de dados. <br><br><ul><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pg_trgm</a> " nos permite determinar a "semelhan√ßa" das palavras, comparando quantas seq√º√™ncias iguais de tr√™s letras (trigramas) est√£o dispon√≠veis.  Duas classes de operadores s√£o adicionadas, "gist_trgm_ops" e "gin_trgm_ops", que suportam v√°rios operadores, incluindo a compara√ß√£o por meio de LIKE e express√µes regulares.  Podemos usar essa extens√£o juntamente com a pesquisa de texto completo para sugerir op√ß√µes de palavras para corrigir erros de digita√ß√£o. <br></li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">hstore</a> " implementa armazenamento "key-value".  Para esse tipo de dados, est√£o dispon√≠veis classes de operadores para v√°rios m√©todos de acesso, incluindo GIN.  No entanto, com a introdu√ß√£o do tipo de dados "jsonb", n√£o h√° motivos especiais para usar o "hstore". <br></li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">intarray</a> " estende a funcionalidade de matrizes inteiras.  O suporte ao √≠ndice inclui GiST, bem como GIN (classe de operador "gin__int_ops"). <br></li></ul><br>  E essas duas extens√µes j√° foram mencionadas acima: <br><br><ul><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">btree_gin</a> " adiciona suporte GIN a tipos de dados regulares para que eles sejam usados ‚Äã‚Äãem um √≠ndice de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">v√°rias colunas</a> junto com tipos compostos. <br></li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">jsquery</a> " define um idioma para consulta JSON e uma classe de operador para suporte ao √≠ndice desse idioma.  Esta extens√£o n√£o est√° inclu√≠da em uma entrega padr√£o do PostgreSQL. <br></li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Continue lendo</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt448746/">https://habr.com/ru/post/pt448746/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt448730/index.html">Monitorar overclock</a></li>
<li><a href="../pt448732/index.html">H√©rnia intervertebral? Trabalhe nela</a></li>
<li><a href="../pt448734/index.html">Drones e rob√¥s ajudam a salvar a Catedral de Notre Dame de Paris</a></li>
<li><a href="../pt448740/index.html">Ouvimos m√∫sica SID (Commodore 64) atrav√©s do OPL3 em PCs modernos</a></li>
<li><a href="../pt448744/index.html">Como transferir uma vari√°vel de fragmento para atividade no Android?</a></li>
<li><a href="../pt448748/index.html">Reflex√µes sobre beleza e c√≥digo</a></li>
<li><a href="../pt448750/index.html">Sobre uma vulnerabilidade que n√£o √©</a></li>
<li><a href="../pt448754/index.html">Quem √© quem em c√≥digo aberto: biografias de geeks</a></li>
<li><a href="../pt448756/index.html">Hist√≥rico: por que a Apple e a Qualcomm brigaram e depois se reconciliaram</a></li>
<li><a href="../pt448758/index.html">Rel√≥gio inteligente com BASIC no 6502 f√≠sico</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>