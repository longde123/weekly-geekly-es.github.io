<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêù üò© ü¶é Tumpukan navigasi sendiri. Lebih baik daripada ROS? üêô üíÑ üîã</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ini adalah artikel kedua oleh tim setUP tentang pengalaman kami dalam membuat robot otonom untuk kompetisi Eurobot Open dan menggunakan ROS untuk ini....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tumpukan navigasi sendiri. Lebih baik daripada ROS?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/479636/"> Ini adalah artikel kedua oleh tim setUP tentang pengalaman kami dalam membuat robot otonom untuk kompetisi Eurobot Open dan menggunakan ROS untuk ini. <br><br>  <a href="https://habr.com/ru/post/478836/">Artikel pertama adalah tentang mekanika dan arsitektur umum robot.</a> <br><br>  Robot melakukan perjalanan di bidang datar dan sebagian besar hambatan diketahui sebelumnya, namun, lawan yang jahat dapat mencoba mencuri sumber daya kami (dan kami terkadang ingin memakan beberapa lusin poin tambahan), sementara kami ingin berkendara ke titik yang diinginkan secepat mungkin dan tidak menyentuh rintangan.  Dari kamera eksternal di lapangan, kami mendapatkan data tentang posisi musuh dan tahu di mana dia sekarang.  Namun, tidak cukup mengetahui posisinya - Anda harus dapat menggunakan informasi ini. <br><br>  Hari ini kami akan mencoba mengemudi dari titik A ke titik B tanpa melakukan perjalanan di sepanjang ekor kucing yang tertidur di lapangan.  Secara khusus, kami akan menjelaskan bagaimana kami membangun rute dan mengontrol kecepatan robot, serta memberi tahu bagaimana memulai semuanya di komputer kami. <br><br><img src="https://habrastorage.org/webt/om/x0/a6/omx0a6wfefbht9c1pialld-9vqy.png"><br><a name="habracut"></a><br><h3>  Mencoba bertahan dengan sedikit darah </h3><br>  Saat memecahkan masalah ini, Anda bisa mengambil materi siap pakai yang ditulis oleh para profesional, maka tidak akan ada siksaan dan penemuan "sepeda" berikutnya.  Kami menggunakan platform roda omni, jadi meskipun ada upaya untuk menggunakan planer lokal yang sudah jadi dari ROS, karena sejumlah alasan mereka menemukan ini tidak menjanjikan.  Di bawah ini Anda dapat melihat berapa banyak barang yang dibutuhkan oleh perancang glider standar: <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** * @class TrajectoryPlanner * @brief Computes control velocities for a robot given a costmap, a plan, and the robot's position in the world. */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TrajectoryPlanner</span></span></span><span class="hljs-class">{</span></span> <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TrajectoryPlannerTest</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">//Need this for gtest to work public: /** * @brief Constructs a trajectory controller * @param world_model The WorldModel the trajectory controller uses to check for collisions * @param costmap A reference to the Costmap the controller should use * @param footprint_spec A polygon representing the footprint of the robot. (Must be convex) * @param inscribed_radius The radius of the inscribed circle of the robot * @param circumscribed_radius The radius of the circumscribed circle of the robot * @param acc_lim_x The acceleration limit of the robot in the x direction * @param acc_lim_y The acceleration limit of the robot in the y direction * @param acc_lim_theta The acceleration limit of the robot in the theta direction * @param sim_time The number of seconds to "roll-out" each trajectory * @param sim_granularity The distance between simulation points should be small enough that the robot doesn't hit things * @param vx_samples The number of trajectories to sample in the x dimension * @param vtheta_samples The number of trajectories to sample in the theta dimension * @param pdist_scale A scaling factor for how close the robot should stay to the path * @param gdist_scale A scaling factor for how aggresively the robot should pursue a local goal * @param occdist_scale A scaling factor for how much the robot should prefer to stay away from obstacles * @param heading_lookahead How far the robot should look ahead of itself when differentiating between different rotational velocities * @param oscillation_reset_dist The distance the robot must travel before it can explore rotational velocities that were unsuccessful in the past * @param escape_reset_dist The distance the robot must travel before it can exit escape mode * @param escape_reset_theta The distance the robot must rotate before it can exit escape mode * @param holonomic_robot Set this to true if the robot being controlled can take y velocities and false otherwise * @param max_vel_x The maximum x velocity the controller will explore * @param min_vel_x The minimum x velocity the controller will explore * @param max_vel_th The maximum rotational velocity the controller will explore * @param min_vel_th The minimum rotational velocity the controller will explore * @param min_in_place_vel_th The absolute value of the minimum in-place rotational velocity the controller will explore * @param backup_vel The velocity to use while backing up * @param dwa Set this to true to use the Dynamic Window Approach, false to use acceleration limits * @param heading_scoring Set this to true to score trajectories based on the robot's heading after 1 timestep * @param heading_scoring_timestep How far to look ahead in time when we score heading based trajectories * @param meter_scoring adapt parameters to costmap resolution * @param simple_attractor Set this to true to allow simple attraction to a goal point instead of intelligent cost propagation * @param y_vels A vector of the y velocities the controller will explore * @param angular_sim_granularity The distance between simulation points for angular velocity should be small enough that the robot doesn't hit things */ TrajectoryPlanner(WorldModel&amp; world_model, const costmap_2d::Costmap2D&amp; costmap, std::vector&lt;geometry_msgs::Point&gt; footprint_spec, double acc_lim_x = 1.0, double acc_lim_y = 1.0, double acc_lim_theta = 1.0, double sim_time = 1.0, double sim_granularity = 0.025, int vx_samples = 20, int vtheta_samples = 20, double pdist_scale = 0.6, double gdist_scale = 0.8, double occdist_scale = 0.2, double heading_lookahead = 0.325, double oscillation_reset_dist = 0.05, double escape_reset_dist = 0.10, double escape_reset_theta = M_PI_2, bool holonomic_robot = true, double max_vel_x = 0.5, double min_vel_x = 0.1, double max_vel_th = 1.0, double min_vel_th = -1.0, double min_in_place_vel_th = 0.4, double backup_vel = -0.1, bool dwa = false, bool heading_scoring = false, double heading_scoring_timestep = 0.1, bool meter_scoring = true, bool simple_attractor = false, std::vector&lt;double&gt; y_vels = std::vector&lt;double&gt;(0), double stop_time_buffer = 0.2, double sim_period = 0.1, double angular_sim_granularity = 0.025);</span></span></code> </pre> <br>  <i>Ini adalah contoh inisialisasi parameter untuk pengaturan kecepatan dan lintasan secara keseluruhan.</i> <br><br>  Parameter penting untuk perhitungan lengkap: <br><br><ol><li>  Parameter world_model. </li><li>  Parameter peta biaya: tautan ke peta yang berisi rintangan, serta "ekstensi maya" mereka, dengan mempertimbangkan potensi tabrakan. </li></ol><br>  Dari kelebihan tumpukan standar, Anda dapat menyoroti ketersediaan dokumentasi dan kemampuan untuk menemukan informasi di forum.  <a href="https://github.com/ros-planning/navigation" rel="nofollow">Anda dapat membaca lebih lanjut di situs web resmi dengan dokumentasi</a> <br><br>  Penting untuk menyebutkan bahwa paket ROS ditulis untuk platform roda dua dan di bawah Omni mereka dioptimalkan dengan meningkatkan sudut rotasi yang tersedia ketika bergerak hingga 360 derajat, yang tentunya merupakan penopang. <br><br>  Setelah menganalisis proyek, kami menyadari bahwa akan ada kesulitan dalam mempelajari dan menambah, serta ada banyak chip berat yang tidak kita butuhkan.  Kelihatannya, biarkan saja, tetapi kami menggunakan Odroid xu4 (prosesor yang masih menggunakan Samsung s5), dan hasil kinerja yang menyedihkan, dan ruang untuk sesuatu yang lebih kuat (dan raspberry 4 dan prosesor jetson nano dengan gugup mengeluarkan asap dengan gugup dibandingkan dengan dengan dia) tidak.  Saya harus meninggalkan tumpukan standar dan mencoba membuat perencana global, perencana lokal, dan pengatur lintasan sendiri <br><br><img src="https://habrastorage.org/webt/ij/qe/es/ijqeesrak1vuhjqfr1ij6exr4_a.jpeg"><br><br><h3>  Perencana global, perencana lokal, pengatur lintasan, dan semuanya </h3><br>  Glider global dan lokal diperlukan untuk mendapatkan arah ke tujuan.  Mengapa pemisahan itu perlu?  Mengapa Anda tidak bisa mengambil <a href="https://ru.wikipedia.org/wiki/A*" rel="nofollow">A *</a> dan mengendarainya?  Sebagai aturan, perencana global, ketika membangun rute, dapat menggunakan seluruh peta dalam pekerjaannya, sehingga algoritma harus secepat mungkin, bahkan mungkin dengan beberapa penyederhanaan.  Untuk memperlancar penyederhanaan ini, mereka juga menggunakan perencana lokal, yang, berdasarkan hasil perencana global (atau hanya beberapa area terbatas di sekitar robot), mencoba memperhitungkan semua nuansa. <br><br>  Setelah kami membangun rute, kami tahu ke mana robot harus pergi, tetapi bagaimana dia bisa diberitahu tentang ini?  Untuk melakukan ini, ada regulator lintasan.  Ini menghitung pada kecepatan apa dan ke arah mana robot harus bergerak saat ini agar tidak menyimpang dari lintasan.  Dalam banyak hal, paket ini bertanggung jawab atas seberapa cepat dan cantik robot itu. <br><br>  Selain ketiga entitas ini, ada keempat - server peta, yang memungkinkan Anda untuk dengan mudah memproses keadaan dunia.  Ini mengatur bagaimana kita menggambarkan peta, kemungkinan apa yang kita miliki saat bekerja dengan peta, dan, dalam banyak hal, menentukan kecepatan pesawat layang. <br><br>  Sebelum melanjutkan dengan deskripsi tumpukan navigasi, alangkah baiknya menguraikan alasan mengapa cost_map dipilih sebagai server peta.  Secara umum, kami mencoba berbagai opsi untuk penangan peta: <a href="https://github.com/IntelRealSense/realsense-ros/tree/occupancy-mapping" rel="nofollow">Occupancy_grid</a> , <a href="http://wiki.ros.org/grid_map" rel="nofollow">Grid_map</a> , <a href="https://github.com/stonier/cost_map" rel="nofollow">Cost_map</a> , tetapi memilih yang terakhir. <br><br>  Alasan: <br><br><ol><li>  Mudah berinteraksi dengan peta. </li><li>  Ada berbagai iterator yang kita butuhkan dalam berbagai bentuk (lingkaran, linier, persegi panjang, dll.). </li><li>  Anda dapat menyimpan banyak lapisan peta dengan parameter berbeda. </li><li>  Manajemen memori yang baik. </li><li>  Dan yang terpenting, kecepatan.  Grid map bekerja dengan tipe ganda dan karena ini beberapa kali lebih lambat daripada server peta yang menggunakan int8 untuk bekerja. </li></ol><br>  Terlepas dari kenyataan bahwa grid Occupancy juga bekerja dengan int8, itu tidak dapat membanggakan kegunaan yang sama, jadi saya harus meninggalkannya. <br><br>  Dari peta, kita perlu tahu di mana zona bebas, berbahaya dan tak tertahankan.  Untuk setiap objek yang ada di lapangan, kita bisa menyesuaikan bidang inflasi - nilai yang, tergantung pada jarak ke objek, mencirikan permeabilitas sel.  Inflasi adalah ekor kucing, mudah untuk tidak menyadarinya, tetapi kemudian Anda akan menyesalinya untuk waktu yang sangat lama.  Kami memetakan robot musuh dan menambahkan zona bahaya yang hanya diperhitungkan perencana lokal.  Perencana global mengabaikan semua poin, jika itu bukan halangan. <br><br><h4>  Perencana global </h4><br>  Hal pertama yang mereka tulis dalam navigasi adalah perencana global.  Ini didasarkan pada algoritma theta *.  Singkatnya, ini adalah <a href="https://ru.wikipedia.org/wiki/A*" rel="nofollow">A * yang</a> dimodifikasi, di mana penekanannya adalah pada menemukan simpul induk, yang dapat dihubungi secara langsung, mis.  tidak ada hambatan baginya.  Ini memungkinkan kita untuk membangun jalur yang nyaman dan mulus yang digunakan dalam perencana lokal. <br><br><img src="https://habrastorage.org/webt/it/qs/e4/itqse4uuumbbzu8rxws07gapbn8.png"><br>  <i>Perbandingan A * dan theta *</i> <br><br>  Untuk perencana global, kami memiliki file dengan parameter (params / path_planner.yaml) yang menjelaskan topik peta dan topik dengan lokasi semua robot (untuk keempat robot di lapangan, di mana "null" adalah topik dengan data tentang robot saat ini). <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta"># small robot debug param list robot_id: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"small"</span></span></span><span class="hljs-meta"> ########################### # cost_map_server params ## ########################### cost_map_server/big_robot_size: 0.45 cost_map_server/little_robot_size: 0.45 cost_map_server/cube_size: 0.11 cost_map_server/inscribed_radius: 0.3 cost_map_server/inflation_radius: 0.3 cost_map_server/inflation_exponential_rate: 0.6 cost_map_server/big_robot1: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"/aruco/big_robot"</span></span></span><span class="hljs-meta"> cost_map_server/big_robot2: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"/aruco/enemy_robot1"</span></span></span><span class="hljs-meta"> cost_map_server/small_robot1: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"null"</span></span></span><span class="hljs-meta"> cost_map_server/small_robot2: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"/aruco/enemy_robot2"</span></span></span><span class="hljs-meta"> cost_map_server/collision: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"collision"</span></span></span><span class="hljs-meta"> cost_map_server/image_resource_name: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"$(find cost_map_server)/param/image_resource.yaml"</span></span></span><span class="hljs-meta"> cost_map_server/min_diff_points: 0.01 ########################### ### path_planner params ### ########################### global_planner/path_layer: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"inflation_layer"</span></span></span><span class="hljs-meta"> global_planner/path_force_layer: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"obstacle_inflation_layer"</span></span></span><span class="hljs-meta"> global_planner/frame_id: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"map"</span></span></span><span class="hljs-meta"> global_planner/current_position: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"real_corr"</span></span></span><span class="hljs-meta"> global_planner/path_filter_epsilon: 0</span></span></code> </pre> <br>  Ini juga menunjukkan: <br><br><ol><li>  salah satu algoritma yang dapat Anda pilih untuk membangun rute, </li><li>  nama lapisan di mana kita akan membangun rute itu sendiri, </li><li>  topik tentang posisi kami, tempat data yang disaring dikeluarkan (dalam kasus kami ini adalah kombinasi data lokasi dari kamera dan odometri). </li></ol><br>  Algoritma pencarian jalur itu sendiri - Theta Star - disorot dalam file terpisah (src / global_planner.cpp) untuk kenyamanan menambahkan algoritma baru: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cost_so_far[<span class="hljs-number"><span class="hljs-number">300</span></span>][<span class="hljs-number"><span class="hljs-number">200</span></span>]; PriorityPoint neighbors[<span class="hljs-number"><span class="hljs-number">8</span></span>]; PriorityPoint current; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> come_from[<span class="hljs-number"><span class="hljs-number">300</span></span>][<span class="hljs-number"><span class="hljs-number">200</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>]; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makePath_ThetaStar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;cost_map::Index&gt; &amp;path, PriorityPoint start, PriorityPoint goal, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> layer, cost_map::CostMap &amp;cost_map, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> grid_cost, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> only_cost)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::priority_queue&lt;PriorityPoint, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;PriorityPoint&gt;, myCompare&gt; openSet; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> max_x = cost_map.getSize()[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> max_y = cost_map.getSize()[<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::fill_n(*cost_so_far, max_x * max_y, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::numeric_limits&lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt;::max()); cost_so_far[start.x][start.y] = <span class="hljs-number"><span class="hljs-number">0</span></span>; come_from[start.x][start.y][<span class="hljs-number"><span class="hljs-number">0</span></span>] = start.x; come_from[start.x][start.y][<span class="hljs-number"><span class="hljs-number">1</span></span>] = start.y; openSet.push(start); grid_cost=<span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!openSet.empty()) { current = openSet.top(); openSet.pop(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current == goal) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } current.GetNeighbors(neighbors); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> current_cost = cost_so_far[current.x][current.y]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> parent_carent[<span class="hljs-number"><span class="hljs-number">2</span></span>] ={come_from[current.x][current.y][<span class="hljs-number"><span class="hljs-number">0</span></span>], come_from[current.x][current.y][<span class="hljs-number"><span class="hljs-number">1</span></span>]}; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">8</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!neighbors[i].OnMap(max_x, max_y)) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> onLine = lineOfSight(parent_carent[<span class="hljs-number"><span class="hljs-number">0</span></span>], parent_carent[<span class="hljs-number"><span class="hljs-number">1</span></span>], neighbors[i].x, neighbors[i].y, cost_map, layer, grid_cost + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (onLine) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> new_cost = cost_so_far[parent_carent[<span class="hljs-number"><span class="hljs-number">0</span></span>]][parent_carent[<span class="hljs-number"><span class="hljs-number">1</span></span>]] + HeuristicEvclid(parent_carent, neighbors[i], grid_cost*<span class="hljs-number"><span class="hljs-number">10</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (new_cost &lt; cost_so_far[neighbors[i].x][neighbors[i].y]) { cost_so_far[neighbors[i].x][neighbors[i].y] = new_cost; neighbors[i].priority = HeuristicEvclid(neighbors[i], goal, grid_cost*<span class="hljs-number"><span class="hljs-number">10</span></span>) + new_cost; openSet.push(neighbors[i]); come_from[neighbors[i].x][neighbors[i].y][<span class="hljs-number"><span class="hljs-number">0</span></span>] = parent_carent[<span class="hljs-number"><span class="hljs-number">0</span></span>]; come_from[neighbors[i].x][neighbors[i].y][<span class="hljs-number"><span class="hljs-number">1</span></span>] = parent_carent[<span class="hljs-number"><span class="hljs-number">1</span></span>]; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> neighbor_price = cost_map.at(layer, cost_map::Index({neighbors[i].x, neighbors[i].y})) + neighbors[i].priority; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> new_cost = current_cost + neighbor_price; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (new_cost &lt; cost_so_far[neighbors[i].x][neighbors[i].y]) { cost_so_far[neighbors[i].x][neighbors[i].y] = new_cost; neighbors[i].priority =HeuristicEvclid(neighbors[i], goal, grid_cost*<span class="hljs-number"><span class="hljs-number">10</span></span>) + new_cost; openSet.push(neighbors[i]); come_from[neighbors[i].x][neighbors[i].y][<span class="hljs-number"><span class="hljs-number">0</span></span>] = current.x; come_from[neighbors[i].x][neighbors[i].y][<span class="hljs-number"><span class="hljs-number">1</span></span>] = current.y; } } } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (only_cost) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cost_so_far[current.x][current.y]; } path.clear(); PriorityPoint temp_point; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (current != start) { path.push_back({current.x, current.y}); temp_point.x = come_from[current.x][current.y][<span class="hljs-number"><span class="hljs-number">0</span></span>]; temp_point.y = come_from[current.x][current.y][<span class="hljs-number"><span class="hljs-number">1</span></span>]; current = temp_point; } path.push_back({current.x, current.y}); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  Algoritma untuk menghapus poin tambahan pada jalur RamerDouglasPeucker juga dialokasikan ke file terpisah. <br>  Ini menghilangkan titik dari jalan jika berada di luar jarak tertentu dari garis yang menghubungkan dua titik tetangga. <br><br><img src="https://habrastorage.org/webt/en/_9/dw/en_9dw6khdarxbyf7gvrhpqg7b4.jpeg"><br><br><h4>  Perencana lokal </h4><br>  Dia bekerja untuk kita berdasarkan gradient descent di bidang potensial.  Sebagai masukan, jalan dari perencana global.  Namun, ini tidak semua yang dia mampu.  Di local_planner, ada layanan internal untuk memilih mode pembangunan jalur.  Ada dua mode operasi secara total: mode titik bergeser di sepanjang gradien, menggunakan beberapa lintasan di peta, serta mode pergeseran, di mana kami segera menghitung kenaikan dalam dua koordinat dan memindahkan titik ke tepi zona aman.  Jika titik tersebut jatuh ke beberapa zona seperti itu, maka kita bergeser ke tempat-tempat persimpangan mereka, karena ada yang paling aman. <br><br>  Mode operasi adalah sebagai berikut: jika tidak ada halangan di jalur dari iterasi sebelumnya, maka kita memecah jalur setiap 2 cm, dan kemudian menggesernya sepanjang gradien, jika tidak kita menggunakan mode operasi perencana lokal kedua. <br><br>  Opsi kedua cukup ringan dan, seperti perencana global, tidak banyak memuat prosesor.  Kami menggunakan beberapa versi dari algoritma ini dan berbagai manipulasi dengan peta.  Sebagai contoh, kami mencoba untuk menulis grafik di mana simpul ditemukan setiap 10 cm dan digeser maksimal 4 cm, setelah itu algoritma Dijkstra digunakan pada grafik yang diperoleh untuk menemukan jarak terkecil.  Titik akhir dalam kasus ini menggunakan titik offset terdekat.  Tetapi algoritma seperti itu lebih cocok untuk perencana global dan kami memutuskan untuk meninggalkan implementasi ini. <br><br>  Kami juga mencoba menggunakan pembangunan jalur dari awal menggunakan metode gradient descent.  Metode ini adalah yang pertama yang kami putuskan untuk ditulis.  Ternyata tidak efisien dalam memori (ini menghabiskan lebih dari 400 mb RAM murni, karena menggunakan peta biaya dengan setiap pass) dan lambat.  Kontrol frekuensi dimatikan karena optimasi yang buruk dan kecepatannya kurang dari 30 kali per detik, yang tidak cocok untuk kami. <br><br>  Sebagai hasilnya, kami memutuskan untuk menggunakan gradient descent di bidang potensial berdasarkan jalur planer global.  Itu ternyata merupakan algoritma yang ringan dan relatif sederhana, yang sepenuhnya sesuai dengan kami dalam hal kualitas jalur, waktu kerja dan jumlah RAM yang dikonsumsi di wilayah 100-150 mb, yang beberapa kali lebih sedikit daripada di iterasi pertama pengembangan. <br><br><img src="https://habrastorage.org/webt/sg/oq/mo/sgoqmogivjs8elhylt74oqjqrdw.png"><br>  <i>Contoh jalur diimbangi oleh planer lokal</i> <br><br>  Tidak seperti global_planner, parameter dalam local_planner sangat kecil, yang disebabkan oleh kesederhanaannya, karena semua tugas yang paling penting terletak pada global_planner: <br><br><pre> <code class="cpp hljs">grid_map_server/big_robot1 : <span class="hljs-number"><span class="hljs-number">0.4</span></span> grid_map_server/big_robot2 : <span class="hljs-number"><span class="hljs-number">0.4</span></span> grid_map_server/small_robot1 : <span class="hljs-number"><span class="hljs-number">0.4</span></span> grid_map_server/small_robot2 : <span class="hljs-number"><span class="hljs-number">0.4</span></span> local_planner/radius : <span class="hljs-number"><span class="hljs-number">0.15</span></span> global_planner/frame_id : <span class="hljs-string"><span class="hljs-string">"map"</span></span></code> </pre> <br>  Dalam hal ini, kami mengonfigurasi: <br><br><ul><li>  Jari-jari zona aman untuk masing-masing robot. </li><li>  Jalur maksimum diimbangi oleh planer lokal. </li><li>  Nama layer peta yang sedang kami kerjakan. </li></ul><br>  Di kelas yang terpisah semua fungsi yang paling penting dialokasikan.  Dalam hal ini, itu adalah kerusakan jalur rekursif, penciptaan glider dan konstruktor virtual dan destruktor. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Planner</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Planner(<span class="hljs-keyword"><span class="hljs-keyword">double</span></span> inflation_radius_, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> frame_id_) { inflation_radius = inflation_radius_; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">300</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; <span class="hljs-number"><span class="hljs-number">200</span></span>; j++) our_map[i][j] = <span class="hljs-number"><span class="hljs-number">3000.0</span></span>; } OurPath-&gt;poses.resize(<span class="hljs-number"><span class="hljs-number">50</span></span>); geometry_msgs::Pose pose; pose.position.x = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; pose.position.y = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">50</span></span>; i++) { OurPath-&gt;poses[i].pose = pose; } frame_id = frame_id_; } <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~Planner() { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdatePath</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; ros::Publisher move_pub; ros::Publisher BigEnemyPub; ros::Publisher LittleEnemyPub; ros::Publisher local_path_publisher; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-comment"><span class="hljs-comment">// virtual double Calculate_Path_Len(); nav_msgs::Path* recursive_path(nav_msgs::Path *path, std::pair&lt;double, double&gt; start, std::pair&lt;double, double&gt; end, double epsilon, int &amp;index) { if (CalcDistance(start, end) &lt; (epsilon) || path-&gt;poses.size() &gt; 200) return path; double start_x = (start.first + end.first) / 2.0; double start_y = (start.second + end.second) / 2.0; index = find_out(path, start); geometry_msgs::PoseStamped pose; pose.pose.position.x = start_x; pose.pose.position.y = start_y; path-&gt;poses.insert(path-&gt;poses.begin() + index, pose); recursive_path(path, start, std::pair&lt;double, double&gt;{start_x, start_y}, epsilon, index); recursive_path(path, std::pair&lt;double, double&gt;{start_x, start_y}, end, epsilon, index); } int find_out(nav_msgs::Path *path, pair_double point) { int index = 0; for (int i = 0; i &lt; path-&gt;poses.size(); i++) if (path-&gt;poses[i].pose.position.x == point.first &amp;&amp; path-&gt;poses[i].pose.position.y == point.second) return ++i; return index; } void add_in_path(nav_msgs::Path* Path, geometry_msgs::PoseStamped pose, int&amp; Index) { Path-&gt;poses[Index % max_size] = pose; Index++; } double inflation_radius; double our_map[300][200]; int max_size = 49; std::string frame_id; nav_msgs::Path *path = new nav_msgs::Path; nav_msgs::Path *OurPath = new nav_msgs::Path; };</span></span></code> </pre> <br>  Kelas LocalPlanning diwarisi darinya, di mana seluruh inti glider berada, yaitu, menggeser poin ke tepi zona aman dan memutuskan apa yang harus dilakukan dengan jalur secara khusus. <br><br>  Semua fungsi lainnya disorot dalam file terpisah fichi.hpp, dan gradient descent di potential_field.hpp.  Di bawah ini adalah snapshot dari file ini, yang menunjukkan fungsi untuk membuat bidang potensial pada peta cost_map: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CalcAttractivePotential</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(grid_map::Index index, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> goalx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> goaly)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(index[<span class="hljs-number"><span class="hljs-number">0</span></span>] - goalx, <span class="hljs-number"><span class="hljs-number">2</span></span>) + <span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(index[<span class="hljs-number"><span class="hljs-number">1</span></span>] - goaly, <span class="hljs-number"><span class="hljs-number">2</span></span>)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CalcPotential</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> startx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> starty, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> goalx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> goaly, cost_map::CostMap &amp;cost_map, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (&amp;our_map)[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">300</span></span></span></span><span class="hljs-function"><span class="hljs-params">][</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">200</span></span></span></span><span class="hljs-function"><span class="hljs-params">])</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Use some magic for normalisation of Field double max_distance = (CalcAttractivePotential(grid_map::Index(startx, starty), goalx, goaly) + 15); if (max_distance == 0.0) { max_distance = 0.01; } for (cost_map::CircleIterator iterator(cost_map, grid_map::Position(startx / 100.0, starty / 100.0), max_distance / 100.); !iterator.isPastEnd(); ++iterator) { try { grid_map::Index index(*iterator); double uf; uf = cost_map.at("obstacle_inflation_layer", *iterator); // if we on free podouble - field is more less then if it not free podouble if ( uf &gt;= 10) { uf = 3000.0; // CP - is const variable } else uf += CalcAttractivePotential(index, goalx, goaly)/max_distance * 256; our_map[299-index(0)][199-index(1)] = uf; } catch(std::exception&amp; e) { ROS_INFO("Exception! %s", e.what() ); } } }</span></span></code> </pre> <br><h4>  Regulator lintasan </h4><br>  Terakhir, namun tidak kalah pentingnya, adalah regulator lintasan.  Dia bertanggung jawab untuk mengubah jalur perencana lokal ke jalur dan memberikan kecepatan untuk langkah saat ini. <br><br>  Versi pertamanya, yang kami gunakan pada final Eurobot 2018, adalah campuran dari pengontrol percepatan dan pengereman, di mana vektor dinormalisasi ke titik berikutnya di jalur, relatif terhadap jarak ke titik akhir. <br><br>  Pengontrol PID, singkatnya, adalah jumlah dari tiga status sistem yang membantu memperbaiki kesalahan sistem dan acak yang kadang-kadang terjadi. <br><br>  Fungsi-fungsi ini dipilih secara empiris dan tergantung pada jarak ke titik akhir di jalan (bisa kuadratik, kubik, terbalik, tetapi kemudian kita menetap di kuadratik).  Ini berhasil, tetapi satu-satunya hal yang tidak sesuai dengan kami adalah bahwa robot tidak dapat mengerem dalam waktu dengan kecepatan di atas 0,7 meter per detik.  Karena itu, ketika saatnya tiba, kami memutuskan untuk membangun kembali seluruh algoritma. <br><br>  Iterasi pertama dalam perjalanan ke lintasan baru adalah penggantian vektor yang akan kami tuju.  Sekarang jumlah vektor untuk ketiga berikutnya dengan koefisien yang berbeda.  Iterasi kedua adalah menulis Jerk Minimum.  Singkatnya, ini adalah konstruksi polinomial derajat 5, di mana koordinat x dan y tergantung pada waktu kedatangan ke setiap titik. <br><br><img src="https://habrastorage.org/webt/ho/mw/hd/homwhdagbnkgdlrigettcc6yook.png"><br>  <i>Gambar menunjukkan grafik dari salah satu koordinat versus waktu, serta kecepatan di sepanjang koordinat ini</i> <br><br>  Regulator lintasan jenis ini lebih cocok untuk kita, karena memerlukan manipulasi yang lebih sedikit dengan pemilihan koefisien yang berbeda, karena semua koefisien adalah nilai dalam polinomial, yang dihitung berdasarkan waktu kedatangan, kecepatan dan percepatan saat ini, kecepatan saat ini dan percepatan, kecepatan keluaran dan percepatan. <br><br>  Hasil penulisan ulang lintasan adalah bahwa kami berhasil menggandakan kecepatan rata-rata robot. <br><br>  Seperti dalam dua kasus sebelumnya, semua fungsi utama disorot dalam file terpisah untuk memudahkan interaksi.  Kali ini, kelas PlannerTrajectory bertanggung jawab untuk membangun lintasan berdasarkan MinimumJerk <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> velocity; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> acceleration; State(<span class="hljs-keyword"><span class="hljs-keyword">double</span></span> v_, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> a_) : velocity(v_), acceleration(a_) {} State() { velocity = <span class="hljs-number"><span class="hljs-number">0</span></span>; acceleration = <span class="hljs-number"><span class="hljs-number">0</span></span>; } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PlannerTrajectory</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: nav_msgs::Path global_path; cost_map::CostMap *costmap_ptr; geometry_msgs::PoseStamped Goal_pred; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt; trajectory_x; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt; trajectory_y; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> average_velocity = <span class="hljs-number"><span class="hljs-number">80</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Defualt or get from param // double max_velocity = 100; double coef_x[6]; double coef_y[6]; int frequency = 30; // Defualt or get from param // int index; public: PlannerTrajectory(cost_map::CostMap *costmap_, const int &amp;frequency_, const double &amp;max_velocity_, const double &amp;average_velocity_) { average_velocity = average_velocity;; max_velocity = max_velocity_; costmap_ptr = costmap_; frequency = frequency_; Goal_pred.pose.position.x = 0.0; Goal_pred.pose.position.y = 0.0; }</span></span></code> </pre> <br>  <i>Foto menunjukkan semua variabel yang dideklarasikan yang kami gunakan.</i> <br><br>  Segala sesuatu yang lain disorot dalam file lain (termasuk / trajectory_regulator.h): menerima poin dari topik, memutuskan apakah akan pergi ke titik berikutnya (jika itu dalam hambatan, maka kita tidak akan pergi) dan banyak lagi. <br><br><h3>  Bermigrasi ke ROS Melodic </h3><br>  Sampai tahun lalu, kami menggunakan RTE - ROS Kinetic lte.  Dia umumnya cocok untuk kita, tetapi dukungannya akan berakhir tahun depan, dan banyak paket yang kita butuhkan mulai keluar secara eksklusif untuk ROS Melodic.  Dan kemudian ternyata costmap_server yang kami gunakan tidak di bawah Melodic. <br><br>  Terjadi masalah saat memproses data dari kartu. <br><br>  Kami memilih peta Grid, karena tumpukannya mirip, tetapi awal peta berada di tempat yang berbeda, dan nilai peta itu sendiri bervariasi dari 0 hingga 1. Ini telah menjadi masalah besar di seluruh tumpukan navigasi.  Jika sebelumnya perencana global diluncurkan 50 kali per detik (ada batasan frekuensi, dan karena itu prosesor tidak digunakan terlalu banyak, bahkan dalam setengah dari satu utas), sekarang ia membuka jalan setiap dua detik dan menganggapnya buruk: benar-benar memuat satu inti.  Dalam 2 detik, robot bisa melintasi seluruh peta.  Ini tidak sesuai dengan kami, dan upaya untuk memparalelkan proses ini berakhir dengan kegagalan, karena dengan demikian tidak ada kinerja yang tersisa untuk proyek lain (dengan mempertimbangkan biaya paralelisasi). <br><br>  Kami memutuskan untuk mengubah tumpukan lagi, meninggalkan peta kisi demi kisi hunian.  Masalah baru telah muncul - ketidakmampuan untuk menyimpan beberapa versi peta pada saat yang sama (misalnya, lengkap, dengan semua hambatan, dan peta statis, dengan hanya hambatan dinamis).  Saya harus mengubah setengah dari kode, yang tidak terlalu dapat diandalkan.  Oleh karena itu, kami memutuskan untuk mencari solusi alternatif untuk masalah ini. <br><br><h4>  Server Peta Biaya </h4><br>  Setelah pencarian yang panjang, kami menemukan peta fork costmap_serverr: <a href="" rel="nofollow">https://github.com/lelongg/cost_map.git</a> - sangat berguna untuk sistem fork kami. <br><br><img src="https://habrastorage.org/webt/27/rb/oh/27rbohj3kefxprwtjqrg4mwtqjc.png"><br><br>  Dan sekarang, alih-alih hanya melayani peta kisi, untuk pengiriman, kami berhasil menghitung kemungkinan lokasi musuh berdasarkan prediksi filter Kalman. <br><br><img src="https://habrastorage.org/webt/ni/pm/nz/nipmnzvhcrqdje1cu8glf9quude.png"><br><br>  Salah satu hal terpenting untuk server peta adalah file peta, yang digunakan untuk pembuatan awal semua lapisan, yang selanjutnya hanya diperbarui.  Ini adalah gambar png biner, di mana hitam adalah hambatan dan putih adalah zona bebas. <br><br><img src="https://habrastorage.org/webt/2b/l5/rg/2bl5rgpuecb7he51heslqpvcazm.png"><br><br>  Ada juga file pengaturan untuk konfigurasi cost_map_server.  Ini berisi topik dengan poin musuh, zona inflasi dan ukuran alun-alun, yang juga dapat digunakan untuk menempatkan zona berbahaya musuh di peta. <br><br><pre> <code class="cpp hljs">########################### # cost_map_server params ## ########################### cost_map_server/big_robot_size: <span class="hljs-number"><span class="hljs-number">0.4</span></span> cost_map_server/little_robot_size: <span class="hljs-number"><span class="hljs-number">0.4</span></span> cost_map_server/cube_size: <span class="hljs-number"><span class="hljs-number">0.11</span></span> cost_map_server/inscribed_radius: <span class="hljs-number"><span class="hljs-number">0.25</span></span> cost_map_server/inflation_radius: <span class="hljs-number"><span class="hljs-number">0.25</span></span> cost_map_server/inflation_exponential_rate: <span class="hljs-number"><span class="hljs-number">0.6</span></span> cost_map_server/big_robot1: <span class="hljs-string"><span class="hljs-string">"/aruco/robot1"</span></span> cost_map_server/big_robot2: <span class="hljs-string"><span class="hljs-string">"/aruco/robot2"</span></span> cost_map_server/small_robot1: <span class="hljs-string"><span class="hljs-string">"/aruco/robot3"</span></span> cost_map_server/small_robot2: <span class="hljs-string"><span class="hljs-string">"/aruco/robot4"</span></span> cost_map_server/collision: <span class="hljs-string"><span class="hljs-string">"collision"</span></span> cost_map_server/image_resource_name: <span class="hljs-string"><span class="hljs-string">"$(find cost_map_server)/param/image_resource.yaml"</span></span> cost_map_server/min_diff_points: <span class="hljs-number"><span class="hljs-number">0.01</span></span></code> </pre> <br>  Semua lapisan diterbitkan hanya jika seseorang berlangganan: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PublishChanges</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ nav_msgs::OccupancyGrid msg; cost_map_msgs::CostMap cost_map_msg; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obstacle_inflation_publisher.getNumSubscribers() &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { cost_map::toOccupancyGrid(costmap, <span class="hljs-string"><span class="hljs-string">"obstacle_layer"</span></span>, msg); obstacle_inflation_publisher.publish(msg); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (inflation_publisher.getNumSubscribers() &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { cost_map::toOccupancyGrid(costmap, <span class="hljs-string"><span class="hljs-string">"inflation_layer"</span></span>, msg); inflation_publisher.publish(msg); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cost_map_publisher.getNumSubscribers() &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { cost_map::toMessage(costmap, cost_map_msg); cost_map_publisher.publish(cost_map_msg); } }</code> </pre> <br><h3>  Jalankan di komputer Anda </h3><br>  Untuk memulai seluruh tumpukan, Anda harus: <br><br><ul><li>  Masukan ROS </li><li>  roslaunch cost_map_server cost_map_server_alone.launch - untuk memulai peta </li><li>  roslaunch global_planner global_planner.launch - luncurkan planer global dengan parameter </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> rosparam memuat $ (temukan local_planner) /param/param.yaml </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> rosrun local_planner local_planning </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> rosrun trajectory_regulator trajectory_regulator </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> rosrun global_planner penggerak </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> rosrun rviz </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tambahkan inflation_layer </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sekarang mengirim pesan ke topik / gp / tujuan, kami mengirim robot ke titik yang diinginkan </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sebagai hasil dari peluncuran semua item, Anda akan memiliki simulasi yang siap untuk meluncurkan tumpukan kami di komputer Anda. </font></font><a href="https://github.com/lelongg/cost_map" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Garpu yang diperlukan</font></font></a> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/iRY5WHgAFns" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Awalnya, kami membutuhkan navigasi yang akan membantu robot kami berkendara dengan indah, cepat dan akurat pada roda omni. </font><font style="vertical-align: inherit;">Selama persiapan kompetisi, tidak ada satupun kucing yang terluka, dan robotnya tampan. </font><font style="vertical-align: inherit;">Sebagai hasilnya, kami memiliki tumpukan navigasi ringan untuk kontes yang mirip dengan eurobot, yang kami cukup puas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bagi kami, tumpukan ini lebih baik daripada yang standar, tapi ... </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Telegram kami: t.me/SetUpSber </font></font><br> <a href="https://github.com/ristle/EUrobotNavigation" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Repositori semua kreativitas kami</font></font></a> <br><br><img src="https://habrastorage.org/webt/98/gl/4m/98gl4mdibk20qgavmhzkbdppu4w.jpeg"></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id479636/">https://habr.com/ru/post/id479636/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id479618/index.html">Postgres Pro Standard 12.1 Dirilis</a></li>
<li><a href="../id479620/index.html">Membalikkan logika</a></li>
<li><a href="../id479622/index.html">Cara kerja prototipe transaksi anonim di blockchain Waves</a></li>
<li><a href="../id479624/index.html">Greg Postgres Professional Oleg Bartunov memberi tahu Faride Roslovets tentang PostgreSQL dan bisnis di Rusia</a></li>
<li><a href="../id479626/index.html">Resonator dengan twist yang tidak diketahui oleh fisikawan</a></li>
<li><a href="../id479642/index.html">Betapa bodohnya keputusan ketika merancang pesawat dari Perang Dunia Kedua yang mengarah pada penciptaan Macintosh</a></li>
<li><a href="../id479644/index.html">Kata-kata sederhana tentang Programmatic</a></li>
<li><a href="../id479646/index.html">Saran atau alasan buruk untuk terus belajar bahasa Inggris setelah Intermediate</a></li>
<li><a href="../id479650/index.html">Top 12 infografis dinamis dinamis TI paling menarik</a></li>
<li><a href="../id479654/index.html">Generator Django vue</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>