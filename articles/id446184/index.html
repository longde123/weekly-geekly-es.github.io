<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ« ğŸš¥ ğŸ™… Aplikasi TDD pada Spring Boot: menyelaraskan tes dan bekerja dengan konteksnya âœŠğŸ½ ğŸ§˜ ğŸ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Artikel ketiga dalam seri dan cabang kecil dari seri utama - kali ini saya akan menunjukkan cara kerja Spring Integration Testing Library dan cara ker...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Aplikasi TDD pada Spring Boot: menyelaraskan tes dan bekerja dengan konteksnya</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/446184/"><p> Artikel ketiga dalam seri dan cabang kecil dari seri utama - kali ini saya akan menunjukkan cara kerja Spring Integration Testing Library dan cara kerjanya, apa yang terjadi ketika tes dimulai dan bagaimana Anda dapat menyempurnakan aplikasi dan lingkungannya untuk pengujian. </p><a name="habracut"></a><br><p>  Saya diminta untuk menulis artikel ini dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">komentar</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">Hixon10</a> tentang cara menggunakan basis nyata, seperti Postgres, dalam tes integrasi.  Penulis komentar menyarankan untuk menggunakan pustaka yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">disematkan</a> semua <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pangkalan data yang</a> disertakan.  Dan saya sudah menambahkan paragraf dan contoh penggunaan dalam kode, tapi kemudian saya memikirkannya.  Tentu saja, mengambil perpustakaan yang sudah jadi adalah benar dan baik, tetapi jika tujuannya adalah untuk <em>memahami cara menulis tes</em> untuk aplikasi Musim Semi, maka akan lebih berguna untuk menunjukkan bagaimana menerapkan sendiri fungsi yang sama.  Pertama, ini adalah alasan yang bagus untuk membicarakan apa yang ada di balik tudung <strong>Uji Musim Semi</strong> .  Dan kedua, saya percaya bahwa Anda tidak bisa bergantung pada perpustakaan pihak ketiga, jika Anda tidak mengerti bagaimana mereka diatur di dalam, ini hanya mengarah pada penguatan mitos "keajaiban" teknologi. </p><br><p>  Kali ini tidak akan ada fitur pengguna, tetapi akan ada masalah yang perlu diselesaikan - <em>Saya ingin memulai database nyata pada port acak dan menghubungkan aplikasi ke database sementara ini secara otomatis, dan setelah tes saya berhenti dan menghapus database.</em> </p><br><p>  Pada awalnya, seperti yang sudah biasa, sedikit teori.  Untuk orang-orang yang tidak terlalu terbiasa dengan konsep bin, konteks, konfigurasi, saya merekomendasikan pengetahuan yang menyegarkan, misalnya, dalam artikel saya Sisi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sebaliknya dari Spring / Habr</a> . </p><br><h1 id="spring-test">  Tes pegas </h1><br><p>  Uji Musim Semi adalah salah satu perpustakaan yang termasuk dalam Kerangka Kerja Musim Semi, pada kenyataannya, segala sesuatu yang dijelaskan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bagian dokumentasi</a> tentang pengujian integrasi hanyalah tentang itu.  Empat tugas utama yang dipecahkan perpustakaan adalah: </p><br><ul><li>  Kelola wadah IoC Musim Semi dan penyimpanannya di antara pengujian </li><li>  Berikan injeksi ketergantungan untuk kelas tes </li><li>  Berikan manajemen transaksi yang cocok untuk tes integrasi </li><li>  Berikan satu set kelas dasar untuk membantu pengembang menulis tes integrasi </li></ul><br><p>  Saya sangat merekomendasikan membaca dokumentasi resmi, katanya banyak hal yang berguna dan menarik.  Di sini saya akan memberikan pemerasan cepat dan beberapa tips praktis yang berguna untuk diingat. </p><br><h1 id="zhiznennyy-cikl-testa">  Uji siklus hidup </h1><br><p><img src="https://habrastorage.org/webt/si/oq/ed/sioqedpwtepmojxgj2fqzcyy-d0.jpeg"><br>  Siklus hidup tes terlihat seperti ini: </p><br><ol><li> Ekstensi untuk kerangka uji ( <code>SpringRunner</code> untuk JUnit 4 dan <code>SpringExtension</code> untuk JUnit 5) memanggil Test Context Bootstrapper </li><li>  Boostrapper menciptakan <code>TestContext</code> - kelas utama yang menyimpan status pengujian dan aplikasi saat ini </li><li>  <code>TestContext</code> mengatur kait yang berbeda (seperti memulai transaksi sebelum pengujian dan rollback setelah), menyuntikkan dependensi ke dalam kelas uji (semua bidang <code>@Autowired</code> pada kelas tes) dan membuat konteks </li><li>  Konteks dibuat menggunakan <em>Context Loader</em> - ia mengambil konfigurasi dasar aplikasi dan menggabungkannya dengan konfigurasi pengujian (properti, profil, nampan, penginstalasi, dan lain-lain yang tumpang tindih). </li><li>  Konteks di-cache menggunakan kunci komposit yang sepenuhnya menggambarkan aplikasi - satu set tempat sampah, properti, dll. </li><li>  Tes berjalan </li></ol><br><blockquote>  Semua pekerjaan kotor dalam mengelola tes dilakukan, pada kenyataannya, dengan <code>spring-test</code> , dan <code>Spring Boot Test</code> pada gilirannya, menambahkan beberapa kelas pembantu, seperti <code>@DataJpaTest</code> dan <code>@SpringBootTest</code> , utilitas bermanfaat seperti <code>TestPropertyValues</code> untuk mengubah properti konteks secara dinamis.  Ini juga memungkinkan Anda untuk menjalankan aplikasi sebagai server web nyata, atau sebagai lingkungan tiruan (tanpa akses melalui HTTP), akan lebih mudah untuk menghapus komponen sistem menggunakan <code>@MockBean</code> , dll. </blockquote><br><h1 id="keshirovanie-konteksta">  Caching Konteks </h1><br><p>  Mungkin salah satu topik yang sangat tidak jelas dalam pengujian integrasi yang menimbulkan banyak pertanyaan dan kesalahpahaman adalah <strong>caching konteks</strong> (lihat paragraf 5 di atas) antara tes dan pengaruhnya terhadap kecepatan tes.  Komentar yang sering saya dengar adalah bahwa tes integrasi "lambat" dan "jalankan aplikasi untuk setiap tes."  Jadi, mereka menjalankan - tetapi tidak untuk setiap tes.  Setiap konteks (mis. Instance aplikasi) akan digunakan kembali secara maksimal, mis.  jika 10 tes menggunakan konfigurasi aplikasi yang sama, maka aplikasi akan mulai satu kali untuk semua 10 tes.  Apa arti "konfigurasi yang sama" dari aplikasi?  Untuk Uji Musim Semi, ini berarti set kacang, kelas konfigurasi, profil, properti, dll., Tidak berubah.  Dalam praktiknya, ini berarti bahwa, misalnya, dua tes ini akan menggunakan konteks yang sama: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@SpringBootTest</span></span> <span class="hljs-meta"><span class="hljs-meta">@ActiveProfiles</span></span>(<span class="hljs-string"><span class="hljs-string">"test"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@TestPropertySource</span></span>(<span class="hljs-string"><span class="hljs-string">"foo=bar"</span></span>) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FirstTest</span></span></span><span class="hljs-class"> </span></span>{ } <span class="hljs-meta"><span class="hljs-meta">@SpringBootTest</span></span> <span class="hljs-meta"><span class="hljs-meta">@ActiveProfiles</span></span>(<span class="hljs-string"><span class="hljs-string">"test"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@TestPropertySource</span></span>(<span class="hljs-string"><span class="hljs-string">"foo=bar"</span></span>) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SecondTest</span></span></span><span class="hljs-class"> </span></span>{ }</code> </pre> <br><blockquote>  Jumlah konteks dalam cache dibatasi hingga 32 - lebih lanjut, sesuai dengan prinsip LRSU, salah satunya akan dihapus dari cache. </blockquote><p>  Apa yang dapat mencegah Uji Coba menggunakan kembali konteks dari cache dan membuat yang baru? </p><br><p>  <strong>@DirtiesContext</strong> <br>  Opsi termudah adalah jika tes ditandai dengan anotasi, konteksnya tidak akan di-cache.  Ini dapat berguna jika tes mengubah keadaan aplikasi dan Anda ingin "mengatur ulang" itu. </p><br><p>  <strong>@MockBean</strong> <br>  Opsi yang sangat tidak jelas, saya bahkan merendernya secara terpisah - @MockBean menggantikan kacang asli dalam konteks dengan tiruan yang dapat diuji melalui Mockito (dalam artikel berikut saya akan menunjukkan cara menggunakannya).  Poin kuncinya adalah bahwa anotasi ini <em>mengubah set kacang</em> dalam aplikasi dan memaksa Uji Musim Semi untuk menciptakan konteks baru.  Jika kita mengambil contoh sebelumnya, misalnya, dua konteks sudah akan dibuat di sini: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@SpringBootTest</span></span> <span class="hljs-meta"><span class="hljs-meta">@ActiveProfiles</span></span>(<span class="hljs-string"><span class="hljs-string">"test"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@TestPropertySource</span></span>(<span class="hljs-string"><span class="hljs-string">"foo=bar"</span></span>) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FirstTest</span></span></span><span class="hljs-class"> </span></span>{ } <span class="hljs-meta"><span class="hljs-meta">@SpringBootTest</span></span> <span class="hljs-meta"><span class="hljs-meta">@ActiveProfiles</span></span>(<span class="hljs-string"><span class="hljs-string">"test"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@TestPropertySource</span></span>(<span class="hljs-string"><span class="hljs-string">"foo=bar"</span></span>) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SecondTest</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@MockBean</span></span> CakeFinder cakeFinderMock; }</code> </pre> <br><p>  <strong>@TestPropertySource</strong> <br>  Setiap perubahan properti secara otomatis mengubah kunci cache dan konteks baru dibuat. </p><br><p>  <strong>@ActiveProfiles</strong> <br>  Mengubah profil yang aktif juga akan memengaruhi cache. </p><br><p>  <strong>@ContextConfiguration</strong> <br>  Dan tentu saja, perubahan konfigurasi apa pun juga akan membuat konteks baru. </p><br><h1 id="zapuskaem-bazu">  Kami memulai pangkalan </h1><br><p>  Jadi sekarang dengan semua pengetahuan ini kami akan mencoba <del>  lepas landas </del>  memahami bagaimana dan di mana Anda dapat menjalankan basis data.  Tidak ada jawaban yang benar di sini, itu tergantung pada persyaratan, tetapi Anda dapat memikirkan dua opsi: </p><br><ol><li>  Jalankan sekali sebelum semua tes di kelas. </li><li>  Jalankan instance acak dan database terpisah untuk setiap konteks yang di-cache (berpotensi lebih dari satu kelas). </li></ol><br><p>  Tergantung pada persyaratan, Anda dapat memilih opsi apa pun.  Jika dalam kasus saya, Postgres mulai relatif cepat dan opsi kedua terlihat cocok, maka yang pertama mungkin cocok untuk sesuatu yang lebih sulit. </p><br><blockquote>  Opsi pertama tidak terikat pada Spring, melainkan pada kerangka uji.  Misalnya, Anda dapat membuat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ekstensi untuk JUnit 5 Anda</a> . </blockquote><p>  Jika Anda mengumpulkan semua pengetahuan tentang pustaka tes, konteks dan caching, tugas bermuara sebagai berikut: <em>saat membuat konteks aplikasi baru, Anda perlu menjalankan database pada port acak dan mentransfer data koneksi ke konteks</em> . </p><br><p>  Antarmuka <code>ApplicationContextInitializer</code> bertanggung jawab untuk melakukan tindakan dengan konteks sebelum diluncurkan di Spring. </p><br><h1 id="applicationcontextinitializer">  ApplicationContextInitializer </h1><br><p>  Antarmuka hanya memiliki satu metode <code>initialize</code> , yang dieksekusi sebelum konteksnya "dimulai" (yaitu, sebelum metode <code>refresh</code> dipanggil) dan memungkinkan Anda untuk membuat perubahan pada konteks - tambahkan nampan, properti. </p><br><p>  Dalam kasus saya, kelasnya terlihat seperti ini: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EmbeddedPostgresInitializer</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApplicationContextInitializer</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GenericApplicationContext</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initialize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GenericApplicationContext applicationContext)</span></span></span><span class="hljs-function"> </span></span>{ EmbeddedPostgres postgres = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EmbeddedPostgres(); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { String url = postgres.start(); TestPropertyValues values = TestPropertyValues.of( <span class="hljs-string"><span class="hljs-string">"spring.test.database.replace=none"</span></span>, <span class="hljs-string"><span class="hljs-string">"spring.datasource.url="</span></span> + url, <span class="hljs-string"><span class="hljs-string">"spring.datasource.driver-class-name=org.postgresql.Driver"</span></span>, <span class="hljs-string"><span class="hljs-string">"spring.jpa.hibernate.ddl-auto=create"</span></span>); values.applyTo(applicationContext); applicationContext.registerBean(EmbeddedPostgres.class, () -&gt; postgres, beanDefinition -&gt; beanDefinition.setDestroyMethodName(<span class="hljs-string"><span class="hljs-string">"stop"</span></span>)); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (IOException e) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RuntimeException(e); } } }</code> </pre> <br><p>  Hal pertama yang terjadi di sini adalah embedded Postgres diluncurkan dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pustaka yandex-qatools / postgresql-embedded</a> .  Kemudian, serangkaian properti dibuat - URL JDBC untuk basis yang baru diluncurkan, tipe driver, dan perilaku Hibernate untuk skema (secara otomatis dibuat).  Satu hal yang tidak jelas adalah hanya <code>spring.test.database.replace=none</code> - ini adalah apa yang kami katakan kepada DataJpaTest bahwa kami tidak harus mencoba untuk terhubung ke database tertanam, seperti H2, dan kami tidak perlu mengganti nampan DataSource (ini berfungsi). </p><br><p>  Dan poin penting lainnya adalah <code>application.registerBean(â€¦)</code> .  Secara umum, kacang ini tentu saja tidak dapat didaftarkan - jika tidak ada yang menggunakannya dalam aplikasi, maka kacang ini tidak terlalu dibutuhkan.  Registrasi hanya diperlukan untuk menentukan metode penghancuran yang akan dipanggil Spring ketika konteksnya dihancurkan, dan dalam kasus saya, metode ini akan memanggil <code>postgres.stop()</code> dan menghentikan basis data. </p><br><p>  Secara umum, itu saja, keajaiban berakhir, jika ada.  Sekarang saya akan mendaftarkan inisialisasi ini dalam konteks pengujian: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@DataJpaTest</span></span> <span class="hljs-meta"><span class="hljs-meta">@ContextConfiguration</span></span>(initializers = EmbeddedPostgresInitializer.class) ...</code> </pre> <br><p>  Atau bahkan untuk kenyamanan, Anda dapat membuat anotasi Anda sendiri, karena kita semua menyukai anotasi! </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Target</span></span>(ElementType.TYPE) <span class="hljs-meta"><span class="hljs-meta">@Retention</span></span>(RetentionPolicy.RUNTIME) <span class="hljs-meta"><span class="hljs-meta">@DataJpaTest</span></span> <span class="hljs-meta"><span class="hljs-meta">@ContextConfiguration</span></span>(initializers = EmbeddedPostgresInitializer.class) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-meta"><span class="hljs-meta">@interface</span></span> EmbeddedPostgresTest { }</code> </pre> <br><p>  Sekarang setiap tes yang dianotasikan oleh <code>@EmbeddedPostgrestTest</code> akan memulai database pada port acak dan dengan nama acak, konfigurasikan Spring untuk terhubung ke database ini dan menghentikannya di akhir tes. </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@EmbeddedPostgresTest</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JpaCakeFinderTestWithEmbeddedPostgres</span></span></span><span class="hljs-class"> </span></span>{ ... }</code> </pre> <br><h1 id="zaklyuchenie">  Kesimpulan </h1><br><p>  Saya ingin menunjukkan bahwa tidak ada sihir misterius di Spring, hanya ada banyak mekanisme internal yang "pintar" dan fleksibel, tetapi mengetahui mereka Anda bisa mendapatkan kontrol penuh pada tes dan aplikasi itu sendiri.  Secara umum, dalam proyek pertempuran, saya tidak memotivasi semua orang untuk menulis metode dan kelas mereka sendiri untuk mengatur lingkungan integrasi untuk tes, jika ada solusi yang siap pakai, maka Anda dapat mengambilnya.  Meskipun jika keseluruhan metode adalah 5 baris kode, maka mungkin menyeret ketergantungan ke dalam proyek, terutama tidak memahami implementasi, adalah berlebihan. </p><br><h1 id="ssylki-na-ostalnye-stati-serii">  Tautan ke artikel lain dalam seri ini </h1><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cara membangun piramida di trunk atau aplikasi Development-Driven Development di Spring Boot</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Aplikasi TDD pada Spring Boot: bekerja dengan database</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id446184/">https://habr.com/ru/post/id446184/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id446166/index.html">Codec ASN1 sprintf sederhana</a></li>
<li><a href="../id446172/index.html">Batasi Pesan API VK - apa yang harus dilakukan</a></li>
<li><a href="../id446174/index.html">Yandex.Alice dan Telegram bot dalam PHP dengan fungsi tunggal</a></li>
<li><a href="../id446176/index.html">Pengenalan tangki dalam aliran video menggunakan metode pembelajaran mesin (+2 video di platform Elbrus dan Baikal)</a></li>
<li><a href="../id446180/index.html">Apakah MongoDB pilihan yang tepat?</a></li>
<li><a href="../id446186/index.html">Bagaimana Elon Musk mencoba menghancurkan informan di jajaran Tesla, dan apa yang terjadi</a></li>
<li><a href="../id446188/index.html">Apakah sudah waktunya untuk URL emoji?</a></li>
<li><a href="../id446190/index.html">Sistem otomasi rumah saya. Membuat gambar sistem operasi</a></li>
<li><a href="../id446192/index.html">Cadangan riwayat: tujuh penemu yang mungkin belum pernah Anda dengar</a></li>
<li><a href="../id446194/index.html">Galatea baru atau menghidupkan gadis android untuk novel fiksi ilmiah</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>