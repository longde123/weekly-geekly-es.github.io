<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔁 👨🏿‍🤝‍👨🏽 ⛵️ Lebih baik kehilangan sehari 🍒 🦍 👀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam berinvestasi, ada konsep "Buruk sekarang - bagus kalau begitu." Investor secara teratur menggigit 10, 20% atau bahkan 30% dari pendapatannya unt...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Lebih baik kehilangan sehari</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/433328/">  Dalam berinvestasi, ada konsep "Buruk sekarang - bagus kalau begitu."  Investor secara teratur menggigit 10, 20% atau bahkan 30% dari pendapatannya untuk masa depan.  Dia menginvestasikan uang ini dalam bentuk obligasi, saham, OFZ, ETF - yang sangat berharga.  Sekarang, pada saat ini, investor mengambil pendapatannya, merampas beberapa keuntungan, sehingga di masa depan, di cakrawala 10-20 tahun, dia akan mendapat manfaat dari investasi.  Keuntungan di masa depan akan mencakup kesulitan hari ini.  Tentang strategi yang sama yang dianut oleh <b>Alexei Okhrimenko</b> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">obenjiro</a> ), tetapi berkaitan dengan pengembangan - lebih baik kehilangan satu hari, dan kemudian terbang dalam 5 menit. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/155/66e/df2/15566edf2d1c0ed649a18e8849234e71.jpg"></div><br>  <a href=""><i>Sumber</i></a> <br><br>  Di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Frontend Conf 2018,</a> Alexey mengatakan bagaimana, setelah kehilangan banyak waktu sekarang, akhirnya menyelamatkannya nanti.  Laporan ini bukan tentang perasaan bosan dan bukan tentang bagaimana menangani tugas-tugas yang monoton dan rutin, tetapi tentang bagaimana <b>menghabiskan waktu secara maksimal</b> - berapa banyak, menghabiskan segalanya, dan melihat apa yang terjadi.  Transkrip laporan adalah pengalaman alat penulisan untuk debugging, pengujian, optimisasi, perancah dan validasi untuk berbagai proyek.  Sebagai bonus, Alexey akan berbicara tentang sejumlah alat yang ada dan manfaat yang mereka bawa.  Mari kita cari tahu apakah Anda perlu membuang waktu sama sekali. <br><br>  <b>Tentang pembicara: Alexei Okhrimenko</b> adalah pengembang di Avito Frontend Architecture, di mana ia sedikit meningkatkan kehidupan jutaan orang.  Memimpin podcast <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"5 min Angular"</a> , dan di waktu luangnya dari tidur dan podcast, mengorganisir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Angular Meetup</a> bersama-sama dengan orang-orang dari Tinkoff, dan membuat sejumlah besar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">laporan yang</a> berbeda dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kontroversial</a> . <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/OJ6cHlJo3P0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2>  Di mana saya bisa kehilangan waktu? </h2><br>  Langkah nol adalah membeli Mac / iMac dan segera mulai kehilangan waktu, atau meletakkan Linux di laptop dan kehilangan semua waktu kerja di dalamnya, mengubah konfigurasi.  Saya juga sangat merekomendasikan memulai dengan Gentoo. <br><br>  Ada 8 poin yang bisa kita habiskan. <br><br><ul><li>  Terminal <br></li><li>  Desain <br></li><li>  Buat proyek. <br></li><li>  Pembuatan Kode. <br></li><li>  Kode ejaan. <br></li><li>  Refactoring <br></li><li>  Pengujian. <br></li><li>  Debugging <br></li></ul><br>  Kami melanjutkan ke kerugian solid mulai dalam urutan. <br><br><h2>  Terminal </h2><br>  Di mana di terminal kita bisa menghabiskan waktu kita untuk kehilangan segalanya?  <b>Atur ruang kerja Anda</b> - buat folder "Pekerjaan saya", "proyek hobi saya" dan letakkan semuanya di dalamnya.  Atur diri Anda <b>Homebrew</b> untuk menginstal perangkat lunak tambahan yang akan disebutkan. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c63/c00/b9f/c63c00b9f7a31fac77167740f9d84711.png"><br><br>  Masukkan <b>iTerm2</b> , dan terminal default di Mac - buang. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f8a/548/c17/f8a548c1758377a842e5dd4a9ac42ba8.png"><br><br>  Instal pengaya seperti <b>oh-my-zsh</b> , yang datang dengan sekelompok plugin yang sangat keren. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/969/e3a/635/969e3a635b049c8a45280bf50bb4fea8.png"><br><br>  Memberikan <b>tmux</b> - terminal multiplexer.  Ini adalah program untuk terminal, yang memungkinkan Anda untuk membuka beberapa jendela dalam satu jendela dan juga mendukung sesi.  Biasanya, jika Anda menutup terminal, semuanya rusak dan berakhir, dan tmux akan terus bekerja, bahkan jika Anda mematikannya.  Jika saya belum pernah bekerja dengan tmux, saya merekomendasikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">review dari DBMS Studio</a> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/66c/fa9/cdb/66cfa9cdb20ff463821674050ed2ab1e.png"><br><br>  <b>Resepkan alias</b> .  Setiap kali Anda menulis sesuatu lebih dari sekali di terminal - tulis sendiri alias, itu akan berguna.  Dua kali - sudah banyak, pasti akan ada yang ketiga, keenam dan kesepuluh. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/902/4b7/189/9024b7189f259ca5be7947f87bdca0a4.png"><br><br>  Kirim alat tambahan, misalnya, <b>jmespath</b> atau dalam <b>bentuk</b> singkat - jp.  Itu dapat diinstal melalui pembuatan dan membuat permintaan-permintaan yang menarik dalam file JSON. <br><br><pre><code class="plaintext hljs">brew tap jmespath/jmespath brew instal jp</code> </pre> <br>  Misalnya, Anda telah mengemas file JSON, Anda dapat menelusuri semuanya dan mencari tahu versi Bereaksi mana dalam aplikasi dan proyek Anda. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ae4/8b6/877/ae48b6877aa3463d6cf3884da246b394.png"><br><br><blockquote>  Otomatiskan pekerjaan Anda - jangan buka file yang sama berkali-kali! </blockquote><br>  Sekarang mari kita bicara tentang di mana harus menghabiskan semuanya.  Semua yang ada di atas hanyalah sedikit kehilangan waktu, Anda bisa kehilangan lebih banyak dalam Script Shell. <br><br><h3>  Skrip shell </h3><br>  Ini adalah bahasa pemrograman, terutama untuk bash, dengan sintaksnya sendiri. <br><br><pre> <code class="plaintext hljs">#!/bin/bash for dir in 'ls $YOUR_TOP_LEVEL_FOLDER'; do for subdir in 'Is $YOUR_TOP_LEVEL_FOLDER/$dir' do $(PLAY AS MUCH AS YOU WANT); done done</code> </pre> <br>  Bahasa penuh - beberapa orang membuat game dan server web, yang saya tidak menyarankan untuk melakukannya.  Saya merekomendasikan semua pekerjaan yang meluangkan waktu untuk menghabiskannya lagi dan menulis semuanya sepenuhnya dalam file.  Mengapa  Semua pengembang yang akrab yang telah bekerja di industri untuk waktu yang lama hanya membuat repositori GitHub mereka sendiri untuk konfigurasi dan menempatkan konfigurasi di sana untuk multiplexer terminal-TMUX mereka, Script Shell untuk inisialisasi. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c90/972/e6b/c90972e6b90b2e831bc2c47e7acb5df0.png"><br><br>  Mengapa menghabiskan banyak waktu untuk apa yang sudah dilakukan sekali?  Kemudian, ketika Anda beralih ke pekerjaan lain, mereka akan mengubah komputer Anda di tempat kerja, motherboard akan terbakar dan Anda akan menghabiskan satu atau dua atau tiga hari lagi untuk mengatur <b>lingkungan</b> .  Ketika Anda memiliki repositori seperti itu, pengaturan dan instalasi hanya akan memakan waktu 10 menit. <br><br><h2>  Desain </h2><br>  Biasanya semua orang sangat terinspirasi sekaligus: “Ya, desain!  Diagram UML! ”, Tetapi ketika saya mengucapkan kata UML dengan lantang, banyak programmer yang memperhatikan: <br><br>  <i>- Tahun 2018 ?!</i>  <i>Ada apa denganmu?</i>  <i>UML adalah peninggalan masa lalu yang mengerikan.</i>  <i>Mengapa kamu menggali mayat?</i>  <i>Jatuhkan sekop!</i> <br><br>  Tetapi UML sangat bermanfaat.  Misalnya, pada reli Scrum, pengembang Java mendengarkan ketika programmer Python mendiskusikan arsitektur fitur backend.  Dia menggosok kepalanya dengan sedih dan menyadari bahwa dia tidak mengerti apa-apa, tetapi hanya kehilangan satu jam dari waktunya.  Pengembang Java tidak dapat berinteraksi dengan programmer Python - ia tidak akan mengatakan bagaimana menulis kode, menggunakan kelas, mixin, atau apa pun.  Dia sama sekali tidak terlibat dalam masalah ini.  Perusahaan kami memiliki JavaScript, Python, dan Lua.  Saat ini 2/3 orang bosan: pertama 2/3, lalu yang lain.  UML memecahkan masalah ini. <br><br><blockquote>  UML adalah bahasa visual abstrak universal untuk desain sistem, yang memungkinkan Anda mengabaikan fitur bahasa. </blockquote><br>  Saya akan memberikan dua contoh favorit saya. <br><br><h3>  Diagram urutan </h3><br>  Diagram ini membantu menunjukkan sejarah interaksi dari waktu ke waktu. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/109/bfe/8e1/109bfe8e1a55d65615452a5f1744d791.png"><br><br>  Pada sumbu Y vertikal, ketergantungan temporal turun: pertama kita mendapatkan permintaan otentikasi, lalu kita memberikan jawaban, dan kemudian kita memasukkan sesuatu ke dalam log.  Pada sumbu horizontal X sudah ada interaksi langsung antara karakter - peserta dalam beberapa acara. <br><br>  Secara pribadi, saya secara berkala menggunakan <b>Sequence Diagram</b> untuk menjelaskan proses otentikasi dalam aplikasi.  Dengan demikian, saya, pengembang JS, menemukan bahasa yang sama dengan backend Python, Lua dan Java.  Kita semua saling memahami dan tahu bagaimana kode akan berfungsi sebagai hasilnya, dan kami tidak peduli tentang implementasi spesifik bahasa ini atau itu. <br><br><h3>  Diagram kelas </h3><br>  Grafik ini juga sangat berguna.  JavaScript memiliki kelas, apa gunanya diagram?  Tapi ada TypeScript, dan dengan itu Anda bisa mendapatkan antarmuka, kelas abstrak - representasi lengkap dari arsitektur final. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/11c/0b7/937/11c0b7937af3d5970eef1575023e8edd.png"><br><br><blockquote>  Satu menit desain menghemat satu minggu pengkodean. </blockquote><br><h3>  PlantUML </h3><br>  Saya menggunakan <b>pustaka PlantUML</b> Java.  Dengannya Anda dapat menggunakan beberapa jenis dsl yang rumit, di mana, misalnya, menunjukkan bahwa Daftar diwarisi dari AbstractList, Koleksi dari AbstractCollection, serta interaksi, agregasi, properti, antarmuka, dan yang lainnya. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@startuml</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractList</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">abstract</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractCollection</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">List</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Collection</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">List</span></span></span><span class="hljs-class"> &lt;|— </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractList</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Collection</span></span></span><span class="hljs-class"> &lt;|— </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractCollection</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Collection</span></span></span><span class="hljs-class"> &lt;|— </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">List</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractCollection</span></span></span><span class="hljs-class"> &lt;|— </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractList</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractList</span></span></span><span class="hljs-class"> &lt;|— </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ArrayList</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ArrayList</span></span></span><span class="hljs-class"> </span></span>{ Object[ ] <span class="hljs-function"><span class="hljs-function">elementData </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">size</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> } </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">enum</span></span></span><span class="hljs-function"> TimeUnit </span></span>{ DAYS</code> </pre> <br>  Hasilnya, saya mendapatkan diagram final. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/45f/625/d97/45f625d97fb54c32a7f16e859e65177c.png"><br><br>  Semua ini berfungsi dengan baik, ada plugin untuk Visual Studio Code. <br>  Ada aplikasi lain yang menarik. <br><br><h3>  StarUML </h3><br>  Kami menggambar diagram paling sederhana: ada kelas dasar dari mana kelas tes diwarisi. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e4c/35a/e54/e4c35ae54a917714239af5be44f72a87.png"><br><br>  Selanjutnya kita menggunakan <b>StarUML</b> .  Itu tidak terlalu mahal dan bisa diekspor ke Jawa.  Tidak ada alat yang akan mengekspor diagram UML ke kode TypeScript, tetapi kita dapat mengekspor hanya menggunakan StarUML ke kode Java. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f34/447/d0f/f34447d0f4e84ce74d8153034b6b0517.png"><br><br><h3>  Jsweet </h3><br>  Kemudian kami menerapkan <b>JSweet</b> - perpustakaan yang memungkinkan Anda untuk mengkonversi kode Java ke kode TypeScript atau JavaScript. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d60/21c/ea1/d6021cea11abd53dfb2c4eb7d578d70d.png"><br><br>  Kode Java ... <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.until.*; <span class="hljs-comment"><span class="hljs-comment">/** * */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseClass</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * Default constructor */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BaseClass</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ } <span class="hljs-comment"><span class="hljs-comment">/** * some attribute */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> String baseAttribute; }</code> </pre> <br>  ... menggunakan konversi JSweet ke kode TypeScript: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/* Generated from Java with JSweet 2.0.0 — &lt;a href="http://www.jsweet.org/"&gt;http://www.jsweet.org&lt;/a&gt; */</span></span> <span class="hljs-comment"><span class="hljs-comment">/** * Default constructor * @class */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseClass</span></span></span><span class="hljs-class"> </span></span>{ public <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.baseAttribute = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/** * some attribute */</span></span> baseAttribute : string; } BaseClass[<span class="hljs-string"><span class="hljs-string">"_class«] = «BaseClass»;</span></span></code> </pre> <br>  Ada parameter tambahan <code>_class</code> - ini adalah fitur Java, ini dapat dihapus.  Hasilnya, kami mendapatkan boilerplate yang siap pakai dari kode TypeScript dari diagram - basis di mana Anda dapat bekerja.  Selain itu, pangkalan ini dirancang dan jelas untuk semua orang. <br><br><blockquote>  Menghabiskan waktu mendesain UML jelas sangat berharga. <br></blockquote><br><h2>  Pembuatan proyek </h2><br>  Siapa yang mengonfigurasi Webpack setiap saat dan membuat webpack-config di proyek baru - kawan, apa yang salah dengan Anda ?!  Apakah semuanya baik-baik saja?  Apakah Anda butuh bantuan?  Jika Anda disandera - tulis koordinat di komentar, kami akan mengirimkan helikopter penyelamat. <br><br>  Cara termudah untuk menghindari ini dan tidak mengkonfigurasi hal yang sama setiap kali adalah <b>membuat repositori umum di GitHub secara lokal</b> atau meningkatkan GitLub CI, klon repositori ini, masuk ke dalamnya dan hapus folder git. <br><br><pre> <code class="plaintext hljs">git clone something cd something rm -rf .git</code> </pre> <br>  Sekarang kami memiliki proyek referensi dari mana kami mengkloning.  Dengan pendekatan ini Anda bisa mendapatkan <b>bootstrap yang</b> sangat murah. <br><br><h3>  Yeoman - usang.  Slush - usang </h3><br>  Bahwa <b>Yeoman yang ditinggalkan</b> terlalu sombong.  Itu tidak ditinggalkan, hanya sedikit dan kurang menggunakannya, seperti <b>Slush</b> .  Ini adalah dua alat yang identik, hanya dengan basis yang berbeda: <b>Yeoman adalah Grunt dan pembuatan kode.</b>  <b>Slush adalah Galp dan pembuatan kode</b> . <br><br>  Terlepas dari kenyataan bahwa alatnya menarik, sekarang yang lain lebih sering digunakan. <br><br><h3>  CLI sudut, Buat Aplikasi Bereaksi, Vue CLI </h3><br>  Siapa yang bekerja dengan Angular - gunakan CLI Angular.  Buat Aplikasi Bereaksi - yang bekerja dengan Bereaksi.  Vue CLI - penggemar Vue.JS. <br><br>  Sebagian besar sudah pindah ke alat ini.  Salah satu argumen utama mengapa layak bekerja dengan CLI adalah <b>keseragaman</b> .  Jika Anda lupa mengambil proyek Anda menggunakan CLI, Anda yakin bahwa orang yang datang setelah Anda akan mengetahui struktur proyek: tim, fitur, yang dapat Anda jalankan end-to-end dan tes unit.  Alat-alat ini sangat bagus. <br><br><blockquote>  Apakah layak untuk menghabiskan waktu pada proyek bootstrap menggunakan CLI, daripada Yeoman?  Ya, jangan ragu. </blockquote><br><h2>  Pembuatan Kode </h2><br>  Kami memiliki basis kode tertentu.  Biasanya, ketika kita memulai sebuah proyek, kita membuat Routing terlebih dahulu, dan kemudian Redux - bagaimana kita bisa melakukannya tanpa itu?  Setiap kerangka kerja memiliki alat pembuatan kode khusus.  Di Angular, ini adalah <b>Skema CLI</b> .  Vue CLI memiliki bagian terpisah untuk menghasilkan <b>plugin Vue CLI</b> : Anda dapat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menghasilkan beberapa kode</a> untuk proyek kami di bagian plugins. <br><br><h3>  Redux CLI </h3><br>  Saya ingin fokus pada React dan Redux CLI, karena dari latihan saya, adalah programmer React yang paling tidak terlibat dalam pembuatan kode dan itu menyakitkan untuk melihatnya.  Setiap kali orang membuat file yang sama dan mengeluh bahwa sulit untuk bekerja dengan Redux, Anda harus membuat banyak semuanya.  Jadi sudah ada alat! <br><br>  Ini adalah <b>Redux CLI</b> , yang akan membuat file dock untuk Anda, di mana akan ada efek, dan reduksi, dan tindakan yang sesuai, dan komponen "bodoh", dan komponen "pintar".  Selain itu, Anda dapat membuat komponen atau basis kode menggunakan Redux CLI.  Redux CLI diinstal secara sederhana, Anda dapat membuat proyek dengan menggunakannya, atau menginisialisasinya dalam proyek yang sudah jadi, misalnya, dibuat menggunakan Create React App. <br><br><pre> <code class="javascript hljs">npm i redux-cli -g blueprint <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> &lt;project name&gt; blueprint init blueprint g dumb SimpleButton</code> </pre> <br>  Ada alat universal lain yang tidak bergantung pada kerangka kerja - <b>Celepuk</b> . <br><br><h3>  Celepuk </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/f3a/1b9/e40/f3a1b9e40e65c3ba83ecac65ad1ac938.png"><br><br>  Saya baru tahu tentang dia.  Plop melakukan hal yang sama seperti sebelumnya: dengan menginisialisasi alat ini, Anda dapat membuat semua komponen dasar yang diperlukan.  Tunjukkan komponen apa yang terdiri dari aplikasi Anda dan hasilkan saja.  Jadi Anda tidak membuang waktu membuat basis kode utama.  Memiliki cerita dan spesifikasi pengguna Anda dapat menghasilkan fungsionalitas dasar, tes, gaya dasar - <b>menghemat banyak pekerjaan</b> . <br><br>  Anda harus menyetel semua alat - saya secara berkala mencari React Blueprint, membuat perpustakaan komponen saya, tetapi <b>kali ini terbayar</b> . <br><br><h2>  Penulisan kode </h2><br>  Akan ada hal-hal sepele. <br><br><h3>  Cuplikan kode </h3><br>  <b>Cuplikan kode</b> memungkinkan Anda menulis sebuah fragmen kecil, kata kode kunci, dan mendapatkan fungsionalitas yang sudah jadi.  Misalnya, Anda dapat membuat komponen Angular dengan menulis <code>@Component</code> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/593/4a3/d33/5934a3d33c94da90b763f4d45a0bd269.png"><br>  Untuk Bereaksi dan Vue, ada cuplikan kode yang sama. <br><br>  Ada masalah dengan cuplikan kode biasa.  Semakin profesional pengembangnya, semakin sedikit ia menggunakan cuplikan kode - hanya karena ia sudah tahu bagaimana semuanya ditulis dan ia terlalu malas untuk membuatnya.  Dia sudah ingat bagaimana menulis komponen ini. <br><br>  Biarkan saya mengingatkan Anda bahwa <b>tujuan kami adalah menghabiskan waktu</b> tanpa melakukan sesuatu yang bermanfaat.  Karena itu, kami duduk dan menulis cuplikan kode.  Di sini Anda dapat menghabiskan banyak waktu, dan tujuannya akan tercapai. <br><br>  Secara pribadi, cuplikan sangat berguna ketika saya bekerja dengan <b>i-bem.js</b> : <br><br><pre> <code class="javascript hljs">modules.define(<span class="hljs-string"><span class="hljs-string">"button&lt;i&gt;«,&lt;/i&gt; [«i-bem-dom»], function(provide, bemDom) { provide( bemDom.declBlock( this.name, { /*   */ }, { /*   */ } ) ); });</span></span></code> </pre> <br>  Tidak ada yang rumit tentang deklarasi ini, tetapi sintaksnya tidak Angular, atau Bereaksi, atau Vue, dan sangat sulit untuk mengingatnya seratus kali pertama.  Seratus dan pertama diingat.  Saya tersiksa, menghabiskan banyak waktu, dan kemudian mulai membuat komponen-komponen ini secara massal hanya karena fakta bahwa saya menggunakan cuplikan kode. <br><br>  Bagi mereka yang bekerja dengan WebStorm, ini tidak terlalu berguna, hanya karena tidak memiliki ekosistem plug-in yang besar dan, pada dasarnya, semuanya termasuk pada awalnya - ini adalah <b>IDE yang lengkap</b> . <br><br><h3>  Ekstensi VScode / ekstensi VIM </h3><br>  Situasi dengan editor <b>Visual Studio Code</b> dan <b>VIM</b> berbeda.  Untuk mendapat manfaat darinya, Anda perlu menginstal plugin.  Anda dapat menghabiskan beberapa hari untuk menemukan semua plugin yang bagus dan menginstalnya - ada banyak plugin! <br><br><img src="https://habrastorage.org/getpro/habr/post_images/049/cf1/3fb/049cf13fb0a07156280f56de2376b98e.png"><br><br>  Saya membunuh banyak waktu untuk mencari mereka, yang saya rekomendasikan kepada Anda.  Anda bisa duduk berjam-jam, melihat, melihat mereka, di gif animasi yang indah - keajaiban!  Tulis di komentar jika Anda ingin saya membagikan semua yang saya miliki. <br><br>  Ada alat yang secara otomatis menyoroti kompleksitas kode, yang lulus uji, yang tidak, ketika Anda dapat melihat alasan kegagalan langsung dalam kode, kode mana yang dilewati atau tidak, pelengkapan otomatis, perbaikan-otomatis - semua ini dalam plugin. <br><br>  Di sini Anda dapat menghabiskan banyak waktu, dan kami akan mencapai tujuan kami.  Tentu saja, plugin tidak sedikit relevan dengan penulisan kode, tetapi bayangkan bahwa mereka membantu kami menulisnya. <br><br><h2>  Refactoring </h2><br>  Ini adalah topik favorit saya!  Dan saya memiliki laporan terpisah tentang refactoring: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">“Refactoring - Di mana?</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kemana?</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kapan?</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dari mana?</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mengapa</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mengapa dan Bagaimana? "</a>  Saya memberi tahu secara rinci apa itu dan bagaimana bekerja dengannya. <br><br>  Saya segera memperingatkan <b>Anda</b> , <b>refactoring bukanlah yang biasa Anda bayangkan</b> .  Biasanya, ini berarti: "Saya meningkatkan basis kode dan menambahkan fitur baru."  Ini bukan refactoring.  Jika Anda memiliki disonansi kognitif saat ini, lihat laporannya dan itu akan berlalu. <br><br><h3>  AngularJS Grunt -&gt; webpack </h3><br>  Tentang refactoring, saya ingin menceritakan satu kisah instruktif.  Kami memiliki proyek AngularJS yang sangat tua, yang dibangun menggunakan Grunt dengan penggabungan dangkal.  Proyek ini ditulis selama versi pertama dan kedua Angular.  Oleh karena itu, semuanya sangat sederhana di sana: file-file tersebut disatukan, lalu dicabut, dan hanya itu.  Pada titik tertentu, kami menyadari bahwa kami harus pindah ke Webpack.  Kami memiliki basis kode legacy yang sangat besar - bagaimana menerjemahkannya ke Webpack? <br><br>  Kami melakukan beberapa kunjungan yang menarik.  Pertama, mereka beralih ke perpustakaan <b>lebab.io</b> . <br><br><h3>  Lebab.io </h3><br>  Pustaka ini memungkinkan Anda untuk mengkonversi kode dari ES5 ke ES6, dan sangat baik.  Dia mengambil basis kode lama dan mengubahnya menjadi yang baru: memasukkan impor, menggunakan baris baru, kelas, set <code>let</code> dan <code>const</code> dengan benar - semuanya cocok untuk Anda.  Dalam hal ini, perpustakaan sangat bagus. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b90/22b/ccc/b9022bccc5ff0e5c8ff57e3d67272282.png"><br><br>  Kami menginstal plugin ini, menjalankan kode file melalui <b>Lebab.io</b> .  Setelah itu, mereka hanya mengambil <b>template</b> dan kode <b>Moustache</b> , yang tampak berbeda di bawah Angular 1.6 dan 1.5 baru dengan pendekatan komponen.  Dengan bantuan pelanggan tetap, kami mengeluarkan bagian-bagian yang diperlukan, dengan bantuan Moustache kami membuat template kami dengan cara yang berbeda dan melalui siklus melalui semua file kami. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> object_to_render = {<span class="hljs-attr"><span class="hljs-attr">key</span></span>: «value», ...}; fs.readFile(path_to_mustache_template, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err, data</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> err; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> output = Mustache.render(data.toString(), object_to_render); fs.saveFileSync(path_to_mustache_template); }):</code> </pre> <br>  Sebagai hasilnya, kami mengonversi sejumlah besar kode lawas ke dalam format modern dan Webpack yang terhubung dengan cepat.  Bagi saya pribadi, ceritanya sangat instruktif. <br><br><h3>  Jsfmt </h3><br>  Ini adalah alat yang memungkinkan Anda untuk memformat basis kode dan mencarinya bukan dengan pencarian biasa, tetapi secara <b>semantik</b> .  Kami menghubungkan perpustakaan kami, sistem file, membaca file dan ingin menemukan sesuatu.  Di bawah ini adalah contoh abstrak, saat ini kami bekerja dengan Angular. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> jsfmt = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'jsfmt'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> js = fs.readFileSync(<span class="hljs-string"><span class="hljs-string">'component.js'</span></span>); jsfmt.search(js,<span class="hljs-string"><span class="hljs-string">"R.Component(a, { dependencies : z })"</span></span>).map(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">matches, wildcards</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(wildcards.z); });</code> </pre> <br>  Seperti inilah permintaan kami: <br><br><pre> <code class="javascript hljs">&lt;b&gt;R.Component&lt;<span class="hljs-regexp"><span class="hljs-regexp">/b&gt; (a, { dependencies: z })</span></span></code> </pre> <br>  <code>R/Component</code> adalah perpustakaan <code>R</code> sendiri dan beberapa <code>Component</code> . <br><br>  Bagian ini terlihat sangat aneh: <br><br><pre> <code class="javascript hljs">R.Component&lt;b&gt; (<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">u</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">a</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">b</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">u</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>, { <span class="hljs-attr"><span class="hljs-attr">dependencies</span></span>: <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">b</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">u</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">z</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">b</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">u</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> })</code> </pre> <br>  Ini tampaknya bukan JavaScript yang valid - dan memang demikian.  Kami menyisipkan huruf kecil, seperti placeholder, dan memberi tahu <b>Jsfmt</b> bahwa kami tidak tertarik pada apa yang ada di sana: objek atau array, string atau nilai boolean, null atau tidak terdefinisi - tidak masalah.  Penting bagi kita untuk mendapatkan tautan ke <b>a</b> dan <b>z</b> , setelah itu, ketika kita menelusuri seluruh basis kode, kita akan menemukan semua varian <b>z</b> .  Sebagai contoh, kita dapat menemukan semua dependensi dari komponen ini.  Berkat ini, Anda dapat melakukan refactoring yang kompleks. <br><br>  Dengan menggunakan alat ini, saya dapat memperbaiki basis kode besar dengan pendekatan semantik menggunakan pohon dan analisis. <br><br><blockquote>  Saya tidak perlu menulis kueri yang rumit, pelanggan tetap atau parsing pohon sintaksis - Saya hanya membentuk kueri dan menunjukkan untuk apa perubahan itu. </blockquote><br><h3>  Dua alat tambahan </h3><br>  Dalam refactoring, ada hal sederhana yang harus saya katakan.  Jika Anda ingin memperbaiki sesuatu, maka dalam Visual Studio Code, pilih kode, dan akan ada petunjuk dan opsi refactoring yang ada di sana.  Misalnya, metode ekstrak, metode inline. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6ea/f5c/4b0/6eaf5c4b0d2b476f6b0e6a48b4b8a0cd.png"><br>  WebStorm memiliki menu konteks yang dapat dipanggil menggunakan kombinasi tombol, tergantung pada konfigurasi, dan basis kode yang direformasi. <br><img src="https://habrastorage.org/getpro/habr/post_images/77c/0d5/7e3/77c0d57e3c762a831e6053b8e45861de.png"><br>  Secara umum, WebStorm memiliki lebih banyak perintah, sekarang lebih dikembangkan daripada Visual Studio Code. <br><br><h2>  Pengujian </h2><br>  Sekarang yang paling menarik dan menginspirasi :) <br><br><h3>  IDE selenium </h3><br>  Pertama sedikit cerita.  Entah bagaimana penguji datang kepada saya dan berkata: <br><br>  <i>- Kami menulis tes ujung ke ujung, kami ingin mengotomatiskannya, dan kami memiliki Selenium IDE.</i> <br><br>  <b>Selenium IDE</b> hanyalah sebuah plugin untuk Firefox yang merekam tindakan Anda di browser.  Itu mengingat semua langkah Anda - klik, gulir, input, transisi, dan Anda bisa kehilangan langkah ini lagi.  Tapi itu belum semuanya.  Anda dapat mengekspor apa yang telah Anda tulis, misalnya, dalam Java atau Python, dan menjalankan tes end-to-end otomatis menggunakan Selenium IDE. <br><br>  Kedengarannya hebat, tetapi dalam kenyataannya Selenium IDE dengan sendirinya tidak berfungsi dengan sempurna, dan selain itu, pada saat itu kami masih memiliki <b>ExtJs</b> . <br><br><h3>  Extjs </h3><br>  Jika Anda memiliki ExtJ - simpati dan peluk.  Selenium IDE selalu menulis pemilih paling unik.  Pada elemen kami, ini id.  Tetapi ExtJs untuk setiap elemen menghasilkan id acak, saya tidak tahu mengapa.  Masalah dengan ExtJs ini hadir dengan versi nol. <br><br><pre> <code class="plaintext hljs">ExtJS = &lt;div id="random_6452"/&gt;</code> </pre> <br>  Akibatnya, penguji kami membuka aplikasi di pagi hari, merekam semuanya, lalu, <b>tanpa memuat ulang halaman</b> , menjalankannya secara berkala, mencoba memahami jika backend, misalnya, telah rusak.  Mereka memperbarui backend, tetapi tidak menyentuh frontend.  Hal utama adalah tidak mengklik menyegarkan, karena setelah itu id baru dibuat. <br><br>  Penguji segera datang dengan satu ide cemerlang.  Selenium IDE dapat mengekspor catatannya ke format HTML - kami dapat bekerja dengan HTML, kami memiliki mesin templating - mari kita coba melakukannya! <br><br><h3>  Ekstensi Google Chrome </h3><br>  Cepat membuat ekstensi Google Chrome dan segera menemukan metode chic <code>elementFromPoint</code> . <br><br><pre> <code class="plaintext hljs">document.elementFromPoint(x, y);</code> </pre> <br>  Basi merekam gerakan mouse di jendela dan kemudian memanggil elementFromPoint, ketika klik berhasil, saya menemukan koordinat elemen yang saya klik.  Lebih lanjut, perlu untuk membuat pemilih tertentu, entah bagaimana untuk memilih elemen ini secara khusus.  Id tidak dapat digunakan - apa yang harus dilakukan? <br><br>  Sebuah ide muncul - tambahan menggantung <b>test-id khusus</b> pada komponen.  Id tes abstrak dibuat untuk komponen, yang diperlukan hanya untuk pengujian. <br><br><pre> <code class="plaintext hljs">data-test-id="ComponentTestId«</code> </pre> <br>  Itu dihasilkan hanya di lingkungan pengujian, dan kami <code>select</code> sesuai dengan atribut data.  Tetapi ini tidak selalu cukup.  Sebagai contoh, kita memiliki komponen, tetapi di dalamnya masih ada <code>div</code> , <code>span</code> , <code>icon</code> , icon di i-tag.  Apa yang harus dilakukan? <br><br>  Untuk ekor ini, kami juga menghasilkan <code>XPath</code> : <br><br><pre> <code class="plaintext hljs">function createXPathFromElement(elm) { var allNodes = document.getElementsByTagName('*'); for (var segs = [ ]; elm &amp;&amp; elm.nodeType = 1; elm = elm.parentNode) { if (elm.hasAttribute('class')) { segs.unshift(elm.localName.toLowerCase() + '[a)class = «' + elm.getAttribute('class') + ' »] '); } else { for (i = 1, sib = elm.previousSibling; sib; sib = sib.previousSibling) { if (sib.localName = elm.localName) i++; }; segs.unshift(elm.localName.toLowerCase() + '[' + i + ']'); }; }; return segs.length ? '/' + segs.join('/') : null; };</code> </pre> <br>  Sebagai hasilnya, pemilih XPath unik dibentuk, yang terdiri, dalam kasus yang sukses, dari atribut data pemilih dengan atribut data dengan nama komponen: <br><br><pre> <code class="plaintext hljs">&lt;b&gt;&lt;u&gt;.//*[@data-test-id='ComponentName']&lt;/b&gt;&lt;/u&gt;/ul/li/div/p[2]</code> </pre> <br>  Jika masih ada semacam struktur kompleks di dalam komponen, semua yang lain menonjol sesuai dengan XPath yang ketat - tanpa id.  Kami menghindari id karena kami bekerja dengan ExtJs. <br><br>  XPath ini dapat dengan mudah diuji.  Kita semua merekam, mengekspor kembali ke dokumen HTML, mengunggah kembali ke Selenium IDE, dan menjalankannya. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/68d/c79/5a5/68dc795a559261a2735d862c16769841.png"><br><br>  Kami menciptakan Ekstensi Chrome, yang hanya menghasilkan format catatan Selenium IDE, tetapi dengan caranya sendiri, bukan seperti yang dilakukan Selenium IDE.  Di sana kami menambahkan banyak pemeriksaan pintar untuk pengguliran pemintalan, pemuatan aplikasi yang berhasil - kami menambahkan nuansa tambahan yang tidak diperhitungkan oleh Selenium IDE.  Berkat ini, kami memiliki tes ujung ke ujung yang sepenuhnya otomatis. <br><br>  Satu-satunya hal yang tersisa bagi penguji untuk dilakukan setelah itu adalah membuka versi aplikasi apa pun, klik, unggah ke Selenium IDE, periksa, simpan sebagai kode Python, nikmati kenaikan gaji dan bonus dan ucapkan "terima kasih" kepada saya. <br><br>  Untuk pengujian unit, saya tidak bisa menyenangkan orang-orang dari komunitas React dan VueJS - maaf!  Saya tidak tahu tentang alat serupa untuk Bereaksi dan VueJS - mungkin mereka.  Saya hanya akan menyenangkan mereka yang memiliki Angular. <br><br><h3>  Simontest </h3><br>  Ada plugin <b>SimonTest</b> dalam Visual Studio Code for Angular. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/925/3e4/6bc/9253e46bcbe70e30ffa2b42df31adfa2.png"><br><br>     unit-    —          unit-.      : <br><br><ul><li>     ,           ; <br></li><li>           . <br></li></ul><br>     -  -   ,  -     .   ,      unit-. <br><br><blockquote>     —    . </blockquote><br><h2>  Debugging </h2><br><blockquote>  80%      ,   80%  . </blockquote><br>      ,        ?           ? <br><br><h3> Chrome DevTools </h3><br>     ,  -     ,  ,     ,     . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c90/875/31a/c9087531aa93887c3c797f146098a045.png"><br><br>   Debugger  ? -  -    ,    .  Profiler,      ,  Dumps,      runtime,      ,   ,       . <br><br><h3> Tracing </h3><br>   — <b> :</b>      .  runtime    :  ,   ,    — promise,  setTimeout,  setTimeout   promise.     . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/002/6d1/c48/0026d1c48da8271802db064f3a92cb73.png"><br><br><h3> Spy-js vs TraceGL </h3><br>     : <b>Spy-js</b>  <b>TraceGL</b> .        ,    .   Debugger  : ,        —     ? , ,  —       . <br><br>  , ,    —    ,      .     ,   deadlocks —    deadlock   ,        . <br><br>  JS     ,   .        .    deadlocks  . <br><br> Spy-js  WebStorm,  ,     .     spy-js. TraceGL  Mozilla.     ,  ,   Firefox  -. TraceGL  ,  , ,              .  TraceGL  Chrome   ,  ,   . <br><br> ,  WebStorm,      Spy-js.    :     Spy-js,   ,              .  WebStorm     :    TypeScript, CoffeeScript,     .       Spy-js,  ,   ,  ,         .     . <br><br><blockquote>    ,   ,      5  ,   : , ,  ,   .   —       ,         ,  . </blockquote><br><h2>      ? </h2><br><ul><li>           <b></b> . <br></li><li>  <b></b>     ,     -   ,    ,     -. <br></li><li> <b> </b> .      . <br></li><li> <b></b> —    ,  ,     ; <br></li><li>   <b>  </b> ,     :     . <br></li><li>  <b></b>     ,    ,     —    ,   . <br></li><li>  <b></b>    —     . <br></li><li>  <b></b>    ,  !   . <br></li></ul><br>     ?     «,   »: <br><br> <i>—     ! :   ,   5  ! !</i> <br><br><blockquote>   —      2018 .      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Frontend Conf</a> .   ++. ? !   Frontend Conf ++  , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">  </a> :  , ,       . </blockquote><br> <b>.     ..</b> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id433328/">https://habr.com/ru/post/id433328/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id433318/index.html">garbage.collect ()</a></li>
<li><a href="../id433320/index.html">Layout Grid sebagai dasar dari layout modern</a></li>
<li><a href="../id433322/index.html">API JSON - kami bekerja sesuai dengan spesifikasi</a></li>
<li><a href="../id433324/index.html">Mengumpulkan bundel impian dengan Webpack</a></li>
<li><a href="../id433326/index.html">Kualitas kode</a></li>
<li><a href="../id433330/index.html">Pecahkan teka-teki silang Jepang dengan SAT Solver</a></li>
<li><a href="../id433332/index.html">Dukungan Python di Fungsi Azure</a></li>
<li><a href="../id433334/index.html">Perilaku XAML untuk WPF sekarang adalah Open Source</a></li>
<li><a href="../id433336/index.html">Implementasi perpustakaan Babel</a></li>
<li><a href="../id433338/index.html">Ikhtisar Produsen Printer 3D Creality</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>