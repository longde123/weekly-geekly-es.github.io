<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßñüèΩ ‚úåüèΩ üïß Convertir modelos poligonales en representaci√≥n de l√≠mites: algoritmo y ejemplos de c√≥digo üëª ü§´ üóÑÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En la mayor√≠a de los sistemas de dise√±o (CAD), la representaci√≥n principal del objeto simulado es la representaci√≥n de l√≠mites de la geometr√≠a o B-rep...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Convertir modelos poligonales en representaci√≥n de l√≠mites: algoritmo y ejemplos de c√≥digo</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/465869/"> En la mayor√≠a de los sistemas de dise√±o (CAD), la representaci√≥n principal del objeto simulado es la representaci√≥n de l√≠mites de la geometr√≠a o B-rep (representaci√≥n de l√≠mites).  Pero cada vez m√°s, los usuarios de CAD tienen que lidiar con modelos de pol√≠gonos, por ejemplo, obtenidos como resultado del escaneo 3D o tomados prestados de cat√°logos en l√≠nea. <br>  Para que sean adecuados para el trabajo posterior, debe convertir la malla poligonal en un modelo B-rep.  Y esto no es f√°cil. <br>  Desarrollamos el componente de software C3D B-Shaper, que est√° integrado en el sistema de dise√±o y convierte los modelos poligonales en una representaci√≥n de l√≠mites.  En esta publicaci√≥n mostraremos el algoritmo de conversi√≥n y ejemplos de implementaci√≥n en C ++. <br><br><img src="https://habrastorage.org/webt/df/p5/gz/dfp5gzfpczrbjte9f0gy-e-i0x0.png" alt="imagen"><br><a name="habracut"></a><br><br>  ¬øCu√°l es el principal problema de los modelos poligonales en t√©rminos de CAD?  No se les pueden aplicar las herramientas tradicionales: realizar operaciones booleanas, construir chaflanes y filetes, obtener proyecciones y secciones.  Si usar el modelo B-rep para construir su representaci√≥n poligonal es bastante f√°cil (esto se hace usando triangulaci√≥n), entonces la transformaci√≥n inversa es mucho m√°s dif√≠cil.  Surgen una serie de problemas: el reconocimiento de superficies de varios tipos (incluidas las superficies de forma libre), la presencia de ruido, que son caracter√≠sticos, por ejemplo, de los resultados de escaneo 3D. <br><br>  En el nuevo SDK, implementamos un mecanismo de tres etapas para convertir el modelo poligonal en B-rep: segmentaci√≥n, reconstrucci√≥n de superficie, construcci√≥n del modelo B-rep.  En general, se supone que el proceso es iterativo: si por alguna raz√≥n el usuario no est√° satisfecho con el resultado, puede realizar los cambios correctivos necesarios en las etapas de segmentaci√≥n y reconstrucci√≥n de las superficies. <br><br><img src="https://habrastorage.org/webt/pq/me/vz/pqmevzxv9fib3_wju48vzznszci.png" alt="imagen"><br>  <i>El esquema para convertir una representaci√≥n poligonal en un l√≠mite</i> <br><br>  Antes de iniciar el proceso de conversi√≥n a B-rep, es necesario, en algunos casos, mejorar la calidad de la malla poligonal original: coordine las direcciones de las normales en los pol√≠gonos vecinos, elimine los "agujeros", aplique algoritmos de suavizado en presencia de ruido en la malla original. <br><br><h1>  <font color="#00B2FF">Segmentaci√≥n poligonal</font> </h1><br>  En la primera etapa, el conjunto inicial de pol√≠gonos de malla se clasifica en subconjuntos (segmentos).  La informaci√≥n sobre las normales en los v√©rtices de la malla permite la segmentaci√≥n de primer orden y, por lo tanto, garantiza la partici√≥n inicial de la malla, as√≠ como tambi√©n clasifica las √°reas planas o fuertemente curvadas. <br><br>  La malla inicial se basa en la definici√≥n de los llamados bordes "afilados", tales bordes entre dos pol√≠gonos triangulares cuyo √°ngulo entre las normales promedio excede un cierto valor predeterminado. <br><br>  La segmentaci√≥n de segundo orden analiza la cuadr√≠cula de acuerdo con sus curvaturas principales, lo que proporciona una base suficiente para la clasificaci√≥n de superficies elementales.  Al calcular las curvaturas en los v√©rtices de la cuadr√≠cula, utilizamos los resultados de Mayer (Mark Meyer, Mathieu Desbrun, Peter Schroder y Alan H. Barr, Operadores discretos de geometr√≠a diferencial para colectores triangulares de 2, visualizaci√≥n y matem√°ticas III, 2003) para determinar el diferencial discreto operador para regiones trianguladas: para cada v√©rtice de la malla original, consideramos un conjunto de v√©rtices vecinos asociados con un v√©rtice dado a trav√©s de un borde.  Luego, <i>se</i> calcula un operador discreto <i>K</i> para un v√©rtice dado, en base al cual se determinan la curvatura promedio normal, promedio <i>K <sub>H</sub></i> y Gaussiana <i>K <sub>G</sub></i> en el v√©rtice de la cuadr√≠cula. <br><br><img src="https://habrastorage.org/webt/rz/ni/kf/rznikfmo-7jumijuvqo4pjgmurs.png" alt="imagen"><br>  <i>Sobre la definici√≥n de un operador diferencial discreto para dominios triangulados</i> <br><br>  Por lo tanto, se calcula el tensor de curvatura para cada v√©rtice de la cuadr√≠cula, cuyos valores propios son las curvaturas principales deseadas <i>K <sub>1</sub></i> y <i>K <sub>2</sub></i> , y los vectores propios son las direcciones principales del cambio de curvatura. <br><br>  A continuaci√≥n, los v√©rtices de malla se clasifican seg√∫n los valores de las curvaturas principales <i>K <sub>1</sub></i> y <i>K <sub>2</sub></i> calculadas en ellos.  El algoritmo de clasificaci√≥n de v√©rtices se basa en el m√©todo de k-medias, es decir, en minimizar la desviaci√≥n cuadr√°tica total de los puntos del grupo desde los centros de estos grupos.  Como resultado, en la salida del algoritmo, cada v√©rtice de la cuadr√≠cula est√° asociado con un determinado grupo <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>C</mi><mi>i</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.569ex" height="2.057ex" viewBox="0 -780.1 1106 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/465869/&amp;usg=ALkJrhjiEbgy174Uo37VAfgnvrQLYqcbwQ#MJMATHI-43" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/465869/&amp;usg=ALkJrhjiEbgy174Uo37VAfgnvrQLYqcbwQ#MJMATHI-69" x="760" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>C</mi><mi>i</mi></math></span></span><script type="math/tex" id="MathJax-Element-1"> Ci </script>  y un par de curvaturas (centro del grupo) (L. Guillaume, "Segmentaci√≥n de malla triangular basada en tensor de curvatura con rectificaci√≥n de l√≠mites", Proceedings Computer Graphics International (CGI), 2004). <br><br><img src="https://habrastorage.org/webt/rr/sf/zg/rrsfzgnpnkdjbk6tkaj2huigmno.png" alt="imagen"><br>  <i>Clasificaci√≥n de los v√©rtices de una malla poligonal en el espacio de curvaturas.</i> <br><br>  Despu√©s de clasificar los v√©rtices de la malla poligonal, es necesario clasificar los pol√≠gonos.  Al comienzo de este procedimiento, se selecciona un pol√≠gono triangular para el cual la curvatura puede considerarse completamente definida (los tres v√©rtices pertenecen a un grupo o dos v√©rtices se encuentran en un borde afilado).  Este pol√≠gono se declara un nuevo segmento, y el procedimiento recursivo para expandir el segmento comienza a partir de √©l: para cada pol√≠gono triangular, se consideran los pol√≠gonos adyacentes a √©l, siempre que el borde entre ellos no sea "afilado". <br><br>  Si el v√©rtice de un pol√≠gono vecino, opuesto al borde com√∫n, se encuentra en un borde afilado o pertenece al mismo grupo, entonces este pol√≠gono se agrega al segmento.  El proceso se repite hasta que se vean todos los pol√≠gonos de esta cuadr√≠cula.  As√≠ es como se ve el mecanismo de segmentaci√≥n de malla implementado. <br><br><img src="https://habrastorage.org/webt/dm/19/to/dm19tosiw5tu-_p97ufs380khyy.png" alt="imagen"><br>  <i>Mecanismo de segmentaci√≥n de malla poligonal</i> <br><br>  Al final del procedimiento de formaci√≥n de segmentos, se realiza un algoritmo especial para unir segmentos adyacentes para eliminar la segmentaci√≥n excesiva de la malla en cuesti√≥n. <br><br><h1>  <font color="#00B2FF">Reconocimiento de superficie</font> </h1><br>  En la segunda etapa, cada uno de los segmentos debe estar asociado con una determinada superficie que se aproxima a su forma con una precisi√≥n dada.  En primer lugar, los valores de las curvaturas principales para un segmento determinado determinan la posibilidad de describir la forma de un segmento por una superficie elemental: <br><ul><li>  plano: <i>k <sub>1</sub></i> = <i>k <sub>2</sub></i> = 0 </li><li>  esfera: <i>k <sub>1</sub></i> = <i>k <sub>2</sub></i> = <i>K</i> &gt; 0 </li><li>  cilindro: <i>k <sub>1</sub></i> = <i>K</i> &gt; 0, <i>k <sub>2</sub></i> = 0 </li><li>  cono: <i>k <sub>1</sub></i> ‚àà [ <i>a</i> , <i>b</i> ], <i>k <sub>2</sub></i> = 0 </li><li>  toro: <i>k <sub>1</sub></i> = <i>K</i> , <i>k <sub>2</sub></i> ‚àà [ <i>a</i> , <i>b</i> ] </li></ul><br><br>  Si ninguna de las superficies elementales es adecuada para describir un segmento, el algoritmo intentar√° reconocer la superficie de extrusi√≥n o rotaci√≥n.  Finalmente, si no fuera posible seleccionar una superficie anal√≠tica para describir la forma del segmento, se construir√° una superficie NURBS para √©l. <br><br>  Las superficies elementales se construyen utilizando m√©todos para ajustar objetos geom√©tricos simples en un conjunto de puntos.  Entonces, para ajustar el c√≠rculo y la esfera, se usa el m√©todo de m√≠nimos cuadrados, para ajustar el plano, el m√©todo del componente principal.  Se verifica que cada superficie reconstruida cumpla con un segmento para una precisi√≥n de reconocimiento dada. <br><br>  Para mayor claridad, pintamos las superficies reconocidas en diferentes colores: planos - azul, cilindros - rojo, esferas - verde, conos - amarillo, tori - p√∫rpura. <br><br><img src="https://habrastorage.org/webt/az/z_/jh/azz_jhkz6xkn0ffe8z95dhrfzum.png" alt="imagen"><br>  <i>Malla poligonal original (izquierda) y malla segmentada (derecha) con superficies reconocidas en segmentos</i> <br><br><h1>  <font color="#00B2FF">Construyendo un Modelo B-rep</font> </h1><br>  La etapa final de la transformaci√≥n es la construcci√≥n de un modelo B-rep basado en la segmentaci√≥n de las superficies reconocidas.  En este enfoque, un gr√°fico de regiones adyacentes se construye sobre la base de regiones segmentadas, lo que refleja la topolog√≠a del modelo y sirve como base para construir el modelo final de B-rep. <br><br>  A diferencia de las etapas anteriores de conversi√≥n, el ensamblaje B-rep se lleva a cabo en un modo totalmente autom√°tico: se encuentran las l√≠neas de intersecci√≥n de las superficies reconstruidas adyacentes, los bordes de las caras se construyen sobre ellas, las caras mismas y, finalmente, se ensambla la carcasa B-rep. <br><br><img src="https://habrastorage.org/webt/om/i7/zw/omi7zwcrrc3qzdvyfkvzphvsyra.png" alt="imagen"><br><br><img src="https://habrastorage.org/webt/is/zt/nw/isztnwvohh4t9nzgj4pusg9awek.png" alt="imagen"><br>  <i>Malla poligonal original (izquierda) y modelo B-rep (derecha)</i> <br><br>  Sin embargo, no siempre es posible construir un shell topol√≥gicamente correcto.  Como ejemplo de tal situaci√≥n, suponga que durante la reconstrucci√≥n de superficies tenemos dos superficies: un cilindro y un plano, y su posici√≥n en el espacio est√° cerca de la tangente.  Debido a errores en la reconstrucci√≥n de las superficies de su intersecci√≥n, puede que no haya ninguna.  En tales casos, la carcasa puede construirse con algunos defectos que el usuario puede corregir ajustando adecuadamente los par√°metros de la superficie. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/PQ3z2Rjdpdc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><h1>  <font color="#00B2FF">Tipos de modelos poligonales y la elecci√≥n del modo de conversi√≥n.</font> </h1><br>  Hoy en d√≠a, existen varias fuentes principales de modelos en la representaci√≥n poligonal: <br><ul><li>  cat√°logos en l√≠nea, bases de datos de modelos 3D en formato poligonal (STL, VRML, OBJ), por ejemplo, 3D Warehouse, Cults 3D, etc. </li><li>  Resultados de escaneo 3D </li><li>  resultados de la optimizaci√≥n del modelo topol√≥gico por algoritmos CAE. </li></ul><br><br>  Los modelos poligonales de estas fuentes se pueden dividir en dos grupos: el primero incluye modelos que son triangulaciones de objetos B-rep, y el segundo, todos los dem√°s.  Las diferencias caracter√≠sticas del primer grupo son la ausencia de ruido en la malla poligonal y el predominio de superficies definidas anal√≠ticamente.  Por lo tanto, la conversi√≥n a los modelos B-rep del primer grupo se realizar√° en modo totalmente autom√°tico o con una m√≠nima intervenci√≥n del usuario. <br><br>  Las cuadr√≠culas poligonales de los modelos del segundo grupo implican una interacci√≥n interactiva m√°s densa con el usuario.  Por lo tanto, inicialmente establecimos dos modos de funcionamiento en el C3D B-Shaper: totalmente autom√°tico e interactivo. <br><br>  La elecci√≥n de un modo particular tambi√©n depende del prop√≥sito de la transformaci√≥n: en algunos casos, la conectividad topol√≥gica de los elementos del shell resultante, as√≠ como su correcci√≥n, pueden descuidarse.  Tal enfoque es aceptable, por ejemplo, para optimizar el renderizado en una aplicaci√≥n BIM, cuando el usuario puede agregar elementos interiores arbitrarios al modelo actual de la sala.  Por otro lado, para problemas de ingenier√≠a inversa es necesario obtener la copia m√°s precisa del modelo original, por ejemplo, para preservar la alineaci√≥n de los cilindros con una precisi√≥n dada, para garantizar la ubicaci√≥n tangente de un par de superficies y, como resultado, para obtener la topolog√≠a correcta del modelo; en este caso, no puede prescindir de la intervenci√≥n del usuario en proceso de conversi√≥n <br><br>  La interfaz de conversi√≥n autom√°tica C3D B-Shaper est√° representada por las siguientes funciones, que aceptan la cuadr√≠cula de entrada y la configuraci√≥n de conversi√≥n como entrada: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">MbResultType </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConvertMeshToShell</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( MbMesh &amp; mesh, MbFaceShell *&amp; shell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> MbMeshProcessorValues &amp; params )</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">MbResultType </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConvertCollectionToShell</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( MbCollection &amp; collection, MbFaceShell *&amp; shell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> MbMeshProcessorValues &amp; params )</span></span></span></span>;</code> </pre> <br><br>  La configuraci√≥n de conversi√≥n incluye el valor de precisi√≥n de reconocimiento, es decir  La distancia m√°xima permitida de los v√©rtices de la malla poligonal dentro de los l√≠mites de este segmento a la superficie reconocida.  Esta precisi√≥n puede ser absoluta o relativa: cuando se usa la precisi√≥n relativa, la desviaci√≥n de las caras del cuerpo de la cuadr√≠cula se verifica con respecto al tama√±o del modelo. <br><br>  Adem√°s, el usuario tiene la opci√≥n de cambiar los modos de reconocimiento, lo que le permite controlar los tipos de superficies durante la reconstrucci√≥n. <br>  La interfaz de clase MbMeshProcessor proporciona capacidades avanzadas para gestionar los procesos de segmentaci√≥n y reconocimiento de superficie: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MbMeshProcessor</span></span></span><span class="hljs-class"> {</span></span> .. <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">// ‚Äú‚Äù . void SetUseMeshSmoothing( bool useSmoothing ); //   . const MbCollection &amp; GetSegmentedMesh(); MbResultType SegmentMesh( bool createSurfaces = true ); void ResetSegmentation(); void UniteSegments( size_t firstSegmentIdx, size_t secondSegmentIdx ); MbResultType SegmentMeshBySeparators( const std::vector&lt;std::vector&lt;uint&gt;&gt; &amp; sep ); //   . void FitSurfaceToSegment( size_t idxSegment ); void FitSurfaceToSegment( size_t idxSegment, MbeSpaceType surfaceType ); const MbSurface * GetSegmentSurface( size_t idxSegment ) const; //  B-rep . MbResultType CreateBRepShell( MbFaceShell *&amp; pShell ); .. }</span></span></code> </pre> <br><br>  Por ejemplo, para corregir los resultados de la segmentaci√≥n autom√°tica, se proporcionan herramientas para combinar segmentos, separarlos, etc.  El usuario puede ingresar una superficie de un tipo dado en un segmento, as√≠ como cambiar los par√°metros para una superficie ya reconocida. <br><br><h1>  <font color="#00B2FF">Que esta pasando ahora</font> </h1><br>  En julio, lanzamos la primera versi√≥n del componente y ahora continuamos desarroll√°ndonos en varias √°reas: algoritmos de segmentaci√≥n autom√°tica, herramientas de edici√≥n de segmentaci√≥n, construcci√≥n de superficies de forma libre (NURBS) basadas en un segmento y mejora de la calidad de construcci√≥n de los dep√≥sitos B-rep. <br><br>  Los desarrolladores interesados ‚Äã‚Äãpueden probar el C3D B-Shaper.  El componente se proporciona de forma gratuita durante tres meses previa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">solicitud</a> en nuestro sitio web. <br><br> <a href=""><img src="https://habrastorage.org/webt/k8/za/vg/k8zavgo-xihodwssql3y-aqlmam.jpeg"></a>  Autor - Andrey Tumanin, Ph.D., matem√°tico-programador de C3D Labs </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/465869/">https://habr.com/ru/post/465869/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../465857/index.html">Anti-googlers: los usuarios web toman medidas radicales para proteger sus datos</a></li>
<li><a href="../465859/index.html">Traducci√≥n Autom√°tica Neural Sostenible</a></li>
<li><a href="../465861/index.html">"Nube" confidencial. Estamos buscando una alternativa a las soluciones abiertas.</a></li>
<li><a href="../465863/index.html">C√≥mo usar MIDI para web en resumen</a></li>
<li><a href="../465867/index.html">Reprogramamos el cajero e imprimimos en √©l Keanu Reeves</a></li>
<li><a href="../465873/index.html">El problema que resuelves es m√°s importante que el c√≥digo que escribes</a></li>
<li><a href="../465877/index.html">Seguridad de la informaci√≥n desde la nube: c√≥mo funciona la plataforma de servicios de ciberseguridad unificada</a></li>
<li><a href="../465879/index.html">¬øY qu√© hay de las cunas?</a></li>
<li><a href="../465885/index.html">¬øC√≥mo convertirse en un l√≠der Scrum Master y Rock the Team?</a></li>
<li><a href="../465889/index.html">C√≥mo fuimos sobre la eficiencia energ√©tica</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>