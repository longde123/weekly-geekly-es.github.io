<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üò° ü§∞üèª üåØ Pemrograman reaktif, apakah itu layak untuk menjatuhkan segalanya dan bergegas menuju mimpi üëØ üèáüèº ü•õ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Artikel lain tentang pemrograman reaktif. Dan jangan memutar mata Anda pada baris ini dan berbicara dengan suara lantang - "Nah, apa lagi yang bisa An...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pemrograman reaktif, apakah itu layak untuk menjatuhkan segalanya dan bergegas menuju mimpi</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/481716/"><p>  Artikel lain tentang pemrograman reaktif.  Dan jangan memutar mata Anda pada baris ini dan berbicara dengan suara lantang - "Nah, apa lagi yang bisa Anda ceritakan tentang pemrograman reaktif ... eh?"  Ini sedikit berbeda dari yang lain, ditulis seperti kertas karbon, jadi beberapa hal di dalamnya mungkin tampak ... aneh atau bahkan sama sekali tidak pantas, seperti humor yang disortir. </p><br><p>  Sama sekali tidak masalah apakah Anda mengetahui manifesto reaktif dengan hati, apakah ada tekanan balik dalam kopi pagi Anda, jika Anda menyentuh semua jenis penerbit dan pelanggan dengan pena ini, atau Anda menulis kode sinkron dan blokir yang baik.  Atau mungkin hanya baru-baru ini, seseorang dengan laporan iklannya yang jujur ‚Äã‚Äãtentang masa depan yang cerah dan orgasme yang mengalir (baik, atau inkjet, di sini seluk-beluk terjemahan menentukan segalanya), tentu saja, dari menggunakan salah satu perpustakaan reaktif, memicu minat pada teknologi baru di mata Anda. </p><br><p>  Itu akan menarik. </p><a name="habracut"></a><br>
<h3 id="vozvedenie-v-absolyut">  Mutlak </h3><br><p>  Jadi, mari kita bayangkan bahwa kita benar-benar gila ... Meskipun kata itu akan disajikan di sini lebih untuk kebenaran politik, karena semua orang yang mengenal penulis menyadari fakta bahwa dia duduk sepanjang hari di apartemen yang terkunci.  Ini bekerja pada malam hari, merokok tiga hookah sehari, dan pergi keluar beberapa kali seminggu.  Ini biasanya terjadi untuk bertemu dengan terapis Anda, tetapi kadang-kadang alasannya sangat berbeda - IKEA. </p><br><p>  Jadi, kami mengambil kode lama yang sinkron, tetapi berfungsi: </p><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-number"><span class="hljs-number">4</span></span>;</code> </pre> <br><p>  Dan kami mencoba untuk menolaknya, karena tampaknya bagi kami ... Meskipun tidak, itu terlalu banyak, tidak ada yang akan melakukannya dalam pikiran mereka.  Tidak ada  Di pikiran kanan Anda. </p><br><pre> <code class="java hljs">Mono&lt;Integer&gt; result = Flux.concat( Mono.just(<span class="hljs-number"><span class="hljs-number">1</span></span>), Flux.concat(Mono.just(<span class="hljs-number"><span class="hljs-number">2</span></span>), Mono.just(<span class="hljs-number"><span class="hljs-number">4</span></span>)) .reduce((a, b) -&gt; a * b)) .reduce((a, b) -&gt; a + b); StepVerifier.create(result) .expectNext(<span class="hljs-number"><span class="hljs-number">9</span></span>) .expectComplete() .verify();</code> </pre><br><p>  Tapi seperti yang mungkin Anda perhatikan, saya melakukannya.  Dan harap diperhatikan!  Saya menahan diri dari menggunakan beberapa layanan mikro dalam contoh ini, satu untuk penambahan dan satu untuk perkalian, yang harus saya komunikasikan melalui <code>rSocket</code> dan <code>kafka</code> . </p><br><p>  Ngomong-ngomong, itu adalah pemanasan.  Sebelum kita mulai, saya ingin memberikan dua tips.  Jadi, saran pertama: selalu siap untuk kenyataan bahwa kolega Anda dapat menjadi psikopat yang benar-benar sakit dengan sekelompok kompleks anak-anak yang akan muncul dalam bentuk kode, bukan kualitas terbaik, dan solusi arsitektur yang sangat elegan. </p><br><p>  Kiat kedua.  Saya memutuskan untuk meninggalkannya di akhir artikel.  Tetapi jika setelah semua yang Anda lihat, Anda memutuskan bahwa Anda harus menjauh dari ini% &amp; @ a, maka Anda tahu di mana mencarinya. </p><br><h3 id="bolee-realnyy-primer">  Contoh yang lebih nyata </h3><br><p>  Mari kita ambil contoh yang sedikit lebih realistis.  Misalnya ... pohon.  Kenapa tepatnya mereka?  Karena kita semua suka pohon baik sebagai objek dalam kehidupan nyata maupun sebagai struktur data.  Ini adalah salah satu bagian terpenting dunia di sekitar kita.  Pohon menghasilkan oksigen sehingga kita bisa bernafas. </p><br><p>  Banyak hewan hidup di pohon, atau di tempat-tempat akumulasi benda-benda ini (tempat-tempat ini disebut taman atau hutan, tergantung pada), tetapi hewan, bahkan orang-orang tunawisma, hidup dalam kotak kardus yang awalnya pohon. </p><br><p>  Ngomong-ngomong, fakta yang menarik, sejak zaman kuno, umat manusia telah mengekstraksi dari pohon salah satu bahan yang paling umum digunakan dalam kehidupan manusia - kayu.  Bayangkan saja, semua tongkat yang kita masukkan ke roda kita sepanjang hidup kita, dan pada saat yang sama menyalahkan orang lain, juga terbuat dari kayu. </p><br><p>  Kami memiliki pohon, pohon biasa, yang biasa-biasa saja yang tumbuh di halaman kode kami dan bermimpi suatu hari ketika tumbuh, berubah menjadi BST: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TreeNode</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> val; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> TreeNode left, right; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TreeNode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> val, TreeNode left, TreeNode right)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.val = val; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.left = left; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.right = right; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TreeNode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> val)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>(val, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); } <span class="hljs-comment"><span class="hljs-comment">//       TreeNode invert() { // ... } int sumOfLeftLeaves() { // ... } TreeNode searchBST(int val) { // .. } public List&lt;Integer&gt; toList() { List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); if (left != null) list.addAll(left.toList()); list.add(val); if (right != null) list.addAll(right.toList()); return list; } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; TreeNode treeNode = (TreeNode) o; return val == treeNode.val; } @Override public int hashCode() { return val; } @Override public String toString() { return toList().toString(); } }</span></span></code> </pre><br><p>  Dan pada satu titik, misalnya, pada hari Senin pukul enam pagi, setelah malam tanpa tidur, seorang programmer punya ide untuk membuatnya reaktif.  Dan dia melakukannya.  Karena dia adalah orang yang bekerja. </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TreeNode</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Mono&lt;Integer&gt; value; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Mono&lt;TreeNode&gt; left; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Mono&lt;TreeNode&gt; right; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TreeNode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Mono&lt;Integer&gt; value, Mono&lt;TreeNode&gt; left, Mono&lt;TreeNode&gt; right)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.value = value; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.left = left; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.right = right; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TreeNode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value, TreeNode left, TreeNode right)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>(Mono.just(value), Mono.justOrEmpty(left), Mono.justOrEmpty(right)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TreeNode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>(Mono.just(value), Mono.empty(), Mono.empty()); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Flux&lt;TreeNode&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">flux</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Flux.concat( left.flatMapMany(TreeNode::flux), Mono.just(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>), right.flatMapMany(TreeNode::flux) ); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> flux() .flatMap(n -&gt; n.value) .collectList() .map(Object::toString) .block(); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">equals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object o)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> == o) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (o == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || getClass() != o.getClass()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; TreeNode treeNode = (TreeNode) o; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Objects.equals(value.block(), treeNode.value.block()); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hashCode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value.block(); }</code> </pre><br><p>  Anda merasakan pertanyaan yang menggantung di udara - ‚ÄúMengapa?!‚Äù.  Pertama, itu indah, dan kedua sangat terukur, karena asinkron, juga ramah lingkungan dan Greta Tunberg tidak akan datang kepada kita sekali pun di kereta dengan tali pengikat besar ... Anda tahu maksud saya.  Dan jangan lupa bahwa sekarang kita telah menekan kembali.  Dan omong-omong, saya mengingatkan Anda bahwa tidak ada refactoring yang dapat dilakukan tanpa cakupan tes. </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TreeNodeTest</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testFlux</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ TreeNode tree = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TreeNode(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TreeNode(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TreeNode(<span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TreeNode(<span class="hljs-number"><span class="hljs-number">3</span></span>)), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TreeNode(<span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TreeNode(<span class="hljs-number"><span class="hljs-number">6</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TreeNode(<span class="hljs-number"><span class="hljs-number">9</span></span>))); StepVerifier.create(tree.flux().flatMap(n -&gt; n.value)) .expectNext(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>) .expectComplete() .verify(); } }</code> </pre> <br><p>  Bagus  Awal telah dibuat, sekarang kita hanya perlu <code>sumOfLeftLeaves</code> tiga metode sederhana <code>invert</code> , <code>sumOfLeftLeaves</code> dan <code>searchBST</code> di pohon tua, membosankan, sinkron dan menambahkan beberapa tes. </p><br><h3 id="invert">  Balikkan </h3><br><p>  Jadi, kami sudah memiliki metode <code>invert</code> diimplementasikan, tetapi, sayangnya, itu tidak reaktif, lihat betapa sedihnya tampilannya, satu-satunya plus dari metode ini adalah mudah dibaca dan mudah dipahami bahwa jika kita membalikkan pohon, maka kami secara rekursif melewati semua simpulnya, membuat salinan dan menukar anak-anaknya.  Yaitu, di anak kiri dari simpul baru, kami menempatkan simpul terbalik dari anak kanan dan sebaliknya.  Dan di mana-mana cek ini batal. </p><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> TreeNode </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> invert(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> TreeNode </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TreeNode root)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (root == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; TreeNode swap = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TreeNode(root.val); swap.right = invert(root.left); swap.left = invert(root.right); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> swap; }</code> </pre><br><p>  Lihat apa yang terjadi ketika kami menulis ulang, itu dimainkan dengan warna baru, dan sebagai bonus, kami mendapat nol keamanan gratis. </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Mono&lt;TreeNode&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Mono.just(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) .map(n -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TreeNode(n.value, n.right.flatMap(TreeNode::invert), n.left.flatMap(TreeNode::invert) )); } <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testInvert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ TreeNode tree = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TreeNode(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TreeNode(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TreeNode(<span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TreeNode(<span class="hljs-number"><span class="hljs-number">3</span></span>)), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TreeNode(<span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TreeNode(<span class="hljs-number"><span class="hljs-number">6</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TreeNode(<span class="hljs-number"><span class="hljs-number">9</span></span>))); Flux&lt;Integer&gt; inverted = tree.invert() .flatMapMany(TreeNode::flux) .flatMap(n -&gt; n.value); StepVerifier.create(inverted) .expectNext(<span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) .expectComplete() .verify(); }</code> </pre> <br><h3 id="sumofleftleaves">  sumOfLeftLeaves </h3><br><p>  Biasanya orang dibagi menjadi dua jenis, tipe pertama adalah mereka yang mengerti apa yang akan dilakukan metode ini dari namanya, dan semua orang lain yang tidak meninggalkan kamar mereka selama bertahun-tahun dan tidak pernah melihat pohon. </p><br><p>  Saya dapat membantu orang jenis kedua dengan saran dari psikoterapis saya, yang kemungkinan akan dapat menyusun rejimen pengobatan.  Dan ceritakan arti dari metode ini.  Suatu simpul dianggap sebagai <code>leaf</code> jika tidak memiliki anak, dan pergi jika tumbuh pada induknya dari penunjuk <code>left</code> .  Ini ditulis atas nama metode. </p><br><p>  Tapi mengapa kata-kata, mari kita ke bisnis, lihat bagaimana itu ... </p><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sumOfLeftLeaves</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sumOfLeftLeaves(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sumOfLeftLeaves</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> left, TreeNode root)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (root == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (root.left == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; root.right == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; left) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> root.val; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sumOfLeftLeaves(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, root.left) + sumOfLeftLeaves(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, root.right); }</code> </pre> <br><p>  ... dan bagaimana jadinya </p><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Mono&lt;Integer&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sumOfLeftLeaves</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sumOfLeftLeaves(Mono.just(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) .flatMap(n -&gt; n.value) .reduce(Integer::sum); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Flux&lt;TreeNode&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sumOfLeftLeaves</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Mono&lt;TreeNode&gt; node, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> left)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> node .flux() .concatMap(n -&gt; Flux.concat( sumOfLeftLeaves(n.left, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>), Flux.first(n.left, n.right) .map(x -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TreeNode(<span class="hljs-number"><span class="hljs-number">0</span></span>)) .switchIfEmpty( Mono.just(n) ) .filter(x -&gt; left), sumOfLeftLeaves(n.right, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) )); } <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testSumOfLeftLeaves</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ TreeNode tree = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TreeNode(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TreeNode(<span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TreeNode(<span class="hljs-number"><span class="hljs-number">11</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TreeNode(<span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TreeNode(<span class="hljs-number"><span class="hljs-number">15</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TreeNode(<span class="hljs-number"><span class="hljs-number">7</span></span>)) ); StepVerifier.create(tree.sumOfLeftLeaves()) .expectNext(<span class="hljs-number"><span class="hljs-number">26</span></span>) .expectComplete() .verify(); }</code> </pre> <br><p>  Wow!  Sangat reaktif.  Banyak async.  Terlalu mengagumkan  Jadi keamanan nol.  Banyak tekanan balik.  Sangat scalable ... </p><br><p>  Ngomong-ngomong, kita masih memiliki satu metode lagi, di mana, aku berjanji, kita akan mengarahkan semua kekuatan ini ke arah yang benar. </p><br><h3 id="searchbst">  searchBST </h3><br><p>  Setiap pohon bermimpi menjadi pohon pencarian biner, dan metode ini akan membantu kita dalam mencarinya.  Ini mengatakan itu semua, jadi saya segera menunjukkan betapa mengerikannya itu, dan betapa indahnya jadinya. </p><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> TreeNode </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">searchBST</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> val)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> searchBST(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, val); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> TreeNode </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">searchBST</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TreeNode root, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> val)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (root == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (val &lt; root.val) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> searchBST(root.left, val); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (val &gt; root.val) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> searchBST(root.right, val); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> root; }</code> </pre> <br><p>  Rasakan saja: </p><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Mono&lt;TreeNode&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testSearchBST</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> val)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> searchBST(Mono.just(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>), val); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Mono&lt;TreeNode&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">searchBST</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Mono&lt;TreeNode&gt; root, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> val)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> root.flatMap(node -&gt; node.value .filter(v -&gt; v &gt; val) .flatMap(v -&gt; searchBST(node.left, val)) .switchIfEmpty(node.value .filter(v -&gt; v &lt; val) .flatMap(v -&gt; searchBST(node.right, val)) .switchIfEmpty(node.value .filter(v -&gt; v == val) .flatMap(v -&gt; root) ) )); } <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">searchBST</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ TreeNode tree = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TreeNode(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TreeNode(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TreeNode(<span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TreeNode(<span class="hljs-number"><span class="hljs-number">3</span></span>)), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TreeNode(<span class="hljs-number"><span class="hljs-number">7</span></span>)); StepVerifier.create(tree.searchBST(<span class="hljs-number"><span class="hljs-number">3</span></span>).flatMap(n -&gt; n.value)) .expectNext(<span class="hljs-number"><span class="hljs-number">3</span></span>) .expectComplete() .verify(); }</code> </pre> <br><p>  Tidak ada lagi yang ditambahkan.  Ini adalah pemrograman reaktif, ini adalah yang paling. </p><br><h3 id="esche-ne-konec">  Belum berakhir </h3><br><p>  Ketika Anda melakukan hal-hal yang sangat keren, sangat sulit untuk berhenti.  Anda lelah, mata Anda tertutup, Anda ingin tidur, tetapi di dalam Anda merasakan aliran motivasi yang sangat besar.  Anda melakukan segalanya dengan benar, Anda tidak bisa berhenti, menangkap perasaan ini, terus membuat dunia menjadi tempat yang lebih baik. </p><br><p>  Karena itu, setelah menyingkirkan pepohonan, Anda, tanpa ragu, melanjutkan ke daftar lama yang baik dan terhubung.  Waktu mereka belum berlalu, masih ribuan orang di wawancara teknis memeriksa mereka untuk fiksasi.  Sudah waktunya untuk melakukannya secara reaktif. </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ListNode</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> val; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ListNode next; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ListNode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> val)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.val = val; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ListNode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> val, ListNode next)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.val = val; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.next = next; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> ListNode </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">of</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">... array)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (array.length &lt; <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; ListNode head = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ListNode(array[<span class="hljs-number"><span class="hljs-number">0</span></span>]); ListNode tail = head; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; array.length; i++) { ListNode next = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ListNode(array[i]); tail.next = next; tail = next; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> head; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ListNode </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">last</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (next != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> next.last(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ListTestNode</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Mono&lt;Boolean&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hasCycle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ListNode head)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Mono.justOrEmpty(head) .flatMapMany(node -&gt; { Flux&lt;ListNode&gt; flux = Flux.generate(() -&gt; head, (n, sink) -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { sink.complete(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } sink.next(n); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n.next; }); Flux&lt;ListNode&gt; fast = flux.skip(<span class="hljs-number"><span class="hljs-number">1</span></span>); Flux&lt;ListNode&gt; slow = flux.flatMap(n -&gt; Flux.just(n, n)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fast.zipWith(slow); }) .any(objects -&gt; objects.getT1() == objects.getT2()) .defaultIfEmpty(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); } <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hasCycle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ StepVerifier.create(hasCycle(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>)) .expectNext(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) .expectComplete() .verify(); ListNode withoutCycle = ListNode.of(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>); StepVerifier.create(hasCycle(withoutCycle)) .expectNext(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) .expectComplete() .verify(); ListNode withCycle = ListNode.of(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>); withCycle.last().next = withCycle.next.next; StepVerifier.create(hasCycle(withCycle)) .expectNext(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) .expectComplete() .verify(); }</code> </pre> <br><p>  Karena kita menyentuh topik wawancara teknis, kita tidak boleh melupakan tugas tercinta untuk memeriksa kurung kurung.  Pertunjukan harus berlanjut! </p><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Mono&lt;Boolean&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isValidParentheses</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String s)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Flux.range(<span class="hljs-number"><span class="hljs-number">0</span></span>, s.length()) .map(s::charAt) .reduceWith(() -&gt; <span class="hljs-string"><span class="hljs-string">""</span></span>, (str, c) -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c == <span class="hljs-string"><span class="hljs-string">'{'</span></span> || c == <span class="hljs-string"><span class="hljs-string">'['</span></span> || c == <span class="hljs-string"><span class="hljs-string">'('</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> str + c; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> last = str.charAt(str.length() - <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c == <span class="hljs-string"><span class="hljs-string">'}'</span></span> &amp;&amp; last != <span class="hljs-string"><span class="hljs-string">'{'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> str; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c == <span class="hljs-string"><span class="hljs-string">']'</span></span> &amp;&amp; last != <span class="hljs-string"><span class="hljs-string">'['</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> str; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c == <span class="hljs-string"><span class="hljs-string">')'</span></span> &amp;&amp; last != <span class="hljs-string"><span class="hljs-string">'('</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> str; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> str.substring(<span class="hljs-number"><span class="hljs-number">0</span></span>, str.length() - <span class="hljs-number"><span class="hljs-number">1</span></span>); }) .map(String::isEmpty); } <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testIsValidParentheses</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ StepVerifier.create(isValidParentheses(<span class="hljs-string"><span class="hljs-string">"()"</span></span>)) .expectNext(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) .expectComplete() .verify(); StepVerifier.create(isValidParentheses(<span class="hljs-string"><span class="hljs-string">"()[]{}"</span></span>)) .expectNext(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) .expectComplete() .verify(); StepVerifier.create(isValidParentheses(<span class="hljs-string"><span class="hljs-string">"{()[]()}"</span></span>)) .expectNext(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) .expectComplete() .verify(); StepVerifier.create(isValidParentheses(<span class="hljs-string"><span class="hljs-string">"()"</span></span>)) .expectNext(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) .expectComplete() .verify(); StepVerifier.create(isValidParentheses(<span class="hljs-string"><span class="hljs-string">"(]"</span></span>)) .expectNext(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) .expectComplete() .verify(); StepVerifier.create(isValidParentheses(<span class="hljs-string"><span class="hljs-string">"([)]"</span></span>)) .expectNext(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) .expectComplete() .verify(); }</code> </pre> <br><p>  Wow  Sangat abadi ... Banyak yang reaktif. </p><br><h3 id="sovet-nomer-dva">  Kiat nomor dua </h3><br><p>  Ngomong-ngomong, seperti yang saya janjikan, di akhir artikel adalah saran nomor dua: <code>               .</code>  Kadang-kadang itu akan terlihat setidaknya konyol dan tidak praktis. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id481716/">https://habr.com/ru/post/id481716/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id481704/index.html">Ini adalah norma - 2: bagaimana peta normal dipanggang</a></li>
<li><a href="../id481706/index.html">Komputer kuantum yang hilang dalam lomba dan kesalahan fatal mereka</a></li>
<li><a href="../id481708/index.html">Apakah PocketBook Sangat Bagus?</a></li>
<li><a href="../id481710/index.html">Singkatnya, membuat warna blockbuster seratus tahun</a></li>
<li><a href="../id481714/index.html">Mengapa video game dan permainan papan bukanlah indikator terbaik dari kemampuan AI (wawancara dengan pencipta Keras)</a></li>
<li><a href="../id481718/index.html">11 faktor dan peretasan kehidupan yang akan meningkatkan efektivitas Anda</a></li>
<li><a href="../id481726/index.html">Laravel Routing yang dilokalkan</a></li>
<li><a href="../id481728/index.html">Cungkil -> REPL untuk Ruby, yang sangat berharga</a></li>
<li><a href="../id481730/index.html">Dengarkan MPow T6 - headphone TWS hebat dengan kontrol yang praktis</a></li>
<li><a href="../id481734/index.html">Pengalaman dengan printer kartu, bagian 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>