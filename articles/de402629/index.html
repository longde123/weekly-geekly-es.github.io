<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛌🏻 ✳️ 👩🏾‍💻 Meine kleinen Relais: Brainfuck Computer ist Magie 🐅 🍎 👨🏿‍🤝‍👨🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einführung 


 Es war einmal, als alles groß war und ich klein, las ich Wojciechowskis Buch "Electronic Toys", um die darin beschriebenen Geräte zum L...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Meine kleinen Relais: Brainfuck Computer ist Magie</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/402629/"><h2 id="vvedenie">  Einführung </h2><br><p>  Es war einmal, als alles groß war und ich klein, las ich Wojciechowskis Buch "Electronic Toys", um die darin beschriebenen Geräte zum Leben zu erwecken.  So wurde im bereits fernen Jahr 2008 aus mehreren zehn elektromagnetischen Relais eine 4-Bit-ALU ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RCVM1 - Relay Digital Computing Machine - Version 1</a> ) zusammengesetzt, die addieren und subtrahieren kann.  Und dann dachte ich - und was ist, wenn ich eine wesentlich größere Anzahl von Relais zusammenbaue und einen vollwertigen Relaiscomputer baue?  Es dauerte nur 8 Jahre, um das Relais hier und da langsam bis zur erforderlichen Anzahl zusammenzubauen, und ich begann zu erstellen. </p><br><p>  Lassen Sie mich Ihnen Ihr Projekt vorstellen, um eine zweite Version eines digitalen Relay-Computers mit dem Codenamen „BrainfuckPC“ zu erstellen - einen 16-Bit-Computer mit Von Neumann-Architektur und einer Reihe von Anweisungen für die Brainfuck-Sprache.  Die Designarbeiten sind abgeschlossen und ich bin gerade dabei, dieses Monster herzustellen. <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/47f/633/aca/47f633aca9ef41d2956fbd513c33223e.jpg"></a> </p><br><h2 id="1-tehnicheskie-harakteristiki">  1 Technische Daten </h2><br><ul><li>  Adressbusbreite: 16 Bit </li><li>  Adressierung: Wort für Wort, 16 Bit / Wort </li><li>  Speicherkapazität: 64 Kiloslov (128 KB) </li><li>  Datenbusbreite: 16 Bit </li><li>  Einheitlicher Adressraum für Code und Daten (Von Neumann Architecture) </li><li>  Taktfrequenz (Design): 100 Hz, <strong>1 Befehl / Zyklus</strong> </li><li>  Befehlssatz: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Brainfuck</a> ++ </li><li>  Anzahl der Relais (Ausführung): 792 </li><li>  Verwendete Relais: Reedschalter, RES55 (1p), RES64 (1z) </li></ul><br><p>  Details gerollt </p><a name="habracut"></a><br><h2 id="obschiy-princip-raboty">  Allgemeines Arbeitsprinzip </h2><br><p>  Betrachten Sie die verallgemeinerte Struktur eines Computers: </p><br><img src="https://habrastorage.org/files/119/8ac/780/1198ac780bef4e6780cf3c32552e2d38.jpg"><br><p>  <em>Abbildung 1: Verallgemeinerte Computerstruktur</em> </p><br><p>  Das zentrale Element ist der Addierer, und zwar nicht einfach, sondern mit paralleler Übertragung.  Warum dies erforderlich ist - werde ich weiter unten erläutern. </p><br><p>  Das Programm und die Daten werden in einem Speicherblock gespeichert.  Der Zugriff auf sie erfolgt an der Adresse, die im IP-Befehlsregister oder im AP-Adressregister aufgezeichnet ist, basierend auf dem, was wir jetzt lesen möchten - Daten an der im AP angegebenen Adresse oder dem Befehl, der an der IP-Adresse aufgezeichnet ist. </p><br><p>  Um dieses Turing-Band zu bedienen (und die Programmiersprache Brainfuck identifiziert es genau), müssen wir in der Lage sein, eine von drei Aktionen auszuführen: </p><br><ul><li>  Ändern Sie den Wert in der aktuellen Datenzelle, dh führen Sie Add / Sub-Operationen aus.  In Brainfuck kann der Wert in der Zelle nur um eins geändert werden, d. H.  +1 oder -1.  Bei einem vollwertigen Addierer ist es jedoch eine Sünde, lange Ketten ++++++++++++++ (------------) nicht zu einer Operation zusammenzufassen. <em>AP + = N (</em> AP- = N) beschleunigt den Prozess erheblich Berechnungen.  (Vergessen Sie auch nicht, [-] (oder [+]) in * AP = 0 umzuwandeln); </li><li>  Ändern Sie die Nummer der aktuell ausgewählten Datenzelle.  Das heißt, durch den Datenspeicher gehen (AP ++, AP--); </li><li>  Ändern Sie die Nummer der aktuellen Anweisung.  Zuerst müssen wir nach jedem Befehl den Wert im IP-Register um eins erhöhen.  Ändern Sie zweitens diesen Wert, wenn der Code Verzweigungen enthält (standardmäßig zum Organisieren von Schleifen).  Es gibt nur ein Steuerflag - Z. Dementsprechend gibt es die Befehle JumpIfZero und JumpIfNotZero. </li></ul><br><p>  Insgesamt müssen wir in der Lage sein, einem Eingang des Addierers den Wert eines der folgenden drei Blöcke zu liefern - AP-Register, IP-Register, DATA-Bus.  Wir werden dies durch ein temporäres Register tun, in dem wir einen der erforderlichen Werte speichern und den gewünschten mit 16-Bit-Schlüsseln verbinden. </p><br><p>  Bei der zweiten Eingabe des Addierers geben wir eine Zahl ein, um die sich einer dieser Werte in Plus oder Minus ändern soll.  Aufgrund der begrenzten Breite des Befehls können Sie ihn nur um eine + -12-Bit-Nummer ändern.  Für Brainfuck ist dies jedoch mehr als genug ("genug für alle", ja). <br>  Wir werden diese 12 Bits aus dem Befehlsregister entnehmen. Bei Vorhandensein solcher Befehle ist dies natürlich, da einige Teams den Addierer überhaupt nicht verwenden.  Vergessen Sie nicht, dass negative Zahlen im erweiterten Code bereitgestellt werden, wobei zusätzliche Dateien eingereicht werden.  Einheitentransfereingang (d. h. A + invB + 1) </p><br><p>  Das Berechnungsergebnis wird sofort dort geladen, wo wir es erhalten haben.  Aufgrund des temporären Registers können wir dies schmerzlos tun. </p><br><p>  Weitere Details (ich würde sogar sagen langweilig) zur Architektur finden Sie in diesem Video: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/Vkg3DC9bF2k" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2 id="nabor-instrukciy">  Befehlssatz </h2><br><p>  Nachdem ich ein allgemeines schematisches Diagramm gezeichnet hatte, das 8 grundlegende Brainfuck-Anweisungen implementieren konnte, stellte ich fest, dass es ein viel größeres Potenzial hat.  Aus diesem Grund habe ich einen breiteren Befehlssatz entwickelt, der mit Brainfuck kompatibel ist, für den jedoch jeder Brainfuck-Quellbefehl zu einem 16-Bit-Computerbefehl kompiliert werden muss. </p><br><h1 id="obschee-opisanie-instrukcii">  Allgemeine Beschreibung der Anweisungen </h1><br><p>  Alle Anweisungen sind 16-Bit.  Aus mehreren Teilen geformt. </p><br><ul><li>  Bits 15, 14, 13 - bestimmen die Unterrichtsklasse </li><li>  Bit 12 - Vorzeichenbit für Vorzeichenanweisungen </li><li>  Bits 11-0 - enthalten die unteren 12 Bits des vorzeichenbehafteten int-a.  Die höchstwertigen 4 Bits werden gemäß dem Wert des 12. Bits gebildet. </li></ul><br><h1 id="tablica-instrukciy">  Anweisungstabelle </h1><br><table><thead><tr><th>  Bedienungsanleitung </th><th>  Opcode </th><th>  Bedienung </th><th>  Entspricht Brainfuck </th><th>  Beschreibung </th></tr></thead><tbody><tr><td>  füge m16 hinzu </td><td>  0X XX </td><td>  <em>AP ←</em> AP + m16 </td><td>  '+' (M16 mal wiederholen) </td><td>  Fügt die Basis zum aktuellen Wert der ausgewählten Zelle hinzu </td></tr><tr><td>  sub m16 </td><td>  1X XX </td><td>  <em>AP ←</em> AP - m16 </td><td>  '-' (m16 mal wiederholen) </td><td>  Dementsprechend subtrahiert es die Basis von </td></tr><tr><td>  ada m16 </td><td>  2X XX </td><td>  AP ← AP + m16 </td><td>  '&gt;' (M16 mal wiederholen) </td><td>  Erhöht den Wert der Adresse </td></tr><tr><td>  Anzeigen m16 </td><td>  3X XX </td><td>  AP ← AP - m16 </td><td>  '&lt;' (M16 mal wiederholen) </td><td>  Verringert den Adresswert. </td></tr><tr><td>  jz m16 </td><td>  4X XX </td><td>  (* AP == 0)?  IP ← IP + m16: IP ← IP </td><td>  '[' </td><td>  Gehen Sie zu IP + m16, wenn der Wert der aktuellen Zelle Null ist </td></tr><tr><td>  jz m16 </td><td>  5X XX </td><td>  (* AP == 0)?  IP ← IP - m16: IP ← IP </td><td>  Nein </td><td>  Gehen Sie zu IP - m16, wenn der Wert der aktuellen Zelle Null ist </td></tr><tr><td>  jnz m16 </td><td>  6X XX </td><td>  (* AP! = 0)?  IP ← IP + m16: IP ← IP </td><td>  Nein </td><td>  Gehen Sie zu IP + m16, wenn der Wert der aktuellen Zelle nicht Null ist </td></tr><tr><td>  jnz m16 </td><td>  7X XX </td><td>  (* AP! = 0)?  IP ← IP - m16: IP ← IP </td><td>  ']' </td><td>  Gehen Sie zu IP - m16, wenn der Wert der aktuellen Zelle nicht Null ist </td></tr><tr><td>  und m16 </td><td>  8X XX </td><td>  <em>AP ←</em> AP UND m16 </td><td>  Nein </td><td>  Logisches UND mit einer positiven Zahl </td></tr><tr><td>  und m16 </td><td>  9X XX </td><td>  <em>AP ←</em> AP UND m16 </td><td>  Nein </td><td>  Logisches UND mit einer negativen Zahl (jemand anderes muss die hohen 4 Bits bilden) </td></tr><tr><td>  oder m16 </td><td>  aX XX </td><td>  <em>AP ←</em> AP ODER m16 </td><td>  Nein </td><td>  Logisches ODER mit positiver Konstante </td></tr><tr><td>  oder m16 </td><td>  bX XX </td><td>  <em>AP ←</em> AP ODER m16 </td><td>  Nein </td><td>  Logisches ODER mit negativer Konstante </td></tr><tr><td>  in </td><td>  c0 00 </td><td>  * AP ← CIN </td><td>  ',' </td><td>  Lesen Sie ein m8-Zeichen von der Konsole.  Wenn der Eingabepuffer leer ist, warten Sie darauf. </td></tr><tr><td>  raus </td><td>  c0 01 </td><td>  COUT ← * AP </td><td>  '.' </td><td>  M8-Zeichen auf die Konsole drucken </td></tr><tr><td>  clr.ap </td><td>  d0 01 </td><td>  AP ← 0 </td><td>  Nein </td><td>  AP-Register löschen.  Der Befehl ermöglicht die Kombination </td></tr><tr><td>  clr.ip </td><td>  d0 02 </td><td>  IP ← 0 </td><td>  Nein </td><td>  IP-Register löschen.  Der Befehl ermöglicht die Kombination </td></tr><tr><td>  clr.dp </td><td>  d0 04 </td><td>  * AP ← 0 </td><td>  '[+]' oder '[-]' </td><td>  Speicherzelle löschen.  Der Befehl ermöglicht die Kombination </td></tr><tr><td>  set.ap </td><td>  d0 10 </td><td>  AP ← * AP </td><td>  Nein </td><td>  Schreiben Sie den aktuellen Wert in das AP-Register </td></tr><tr><td>  set.ip </td><td>  d0 20 </td><td>  IP ← * AP </td><td>  Nein </td><td>  Schreiben Sie den aktuellen Wert in das IP-Register </td></tr><tr><td>  get.ap. </td><td>  d1 00 </td><td>  * AP ← AP </td><td>  Nein </td><td>  Lesen Sie den aktuellen Wert aus dem AP-Register </td></tr><tr><td>  get.ip. </td><td>  d2 00 </td><td>  * AP ← IP </td><td>  Nein </td><td>  Lesen Sie den aktuellen Wert aus dem IP-Register </td></tr><tr><td>  mode.b8 </td><td>  e1 00 </td><td></td><td>  Nein </td><td>  8-Bit-Aktivierung (1) </td></tr><tr><td>  mode.b16 </td><td>  e2 00 </td><td></td><td>  Nein </td><td>  16-Bit-Aktivierung </td></tr><tr><td>  halt </td><td>  f0 00 </td><td></td><td>  Nein </td><td>  Maschine anhalten </td></tr></tbody></table><br><ul><li>  AP - Adressregister </li><li>  IP - Anweisungsregister </li><li>  * AP - Aktueller Speicherort </li><li>  CIN - Konsoleneingang </li><li>  COUT - Konsolenausgabe </li></ul><br><ol><li>  Wenn der 8-Bit-Modus aktiviert ist, arbeitet der Addierer im 16-Bit-Modus weiter.  Bedingte Anweisungen (nämlich Testen des Werts der aktuellen Speicherzelle auf Gleichheit mit Null) werden jedoch 8-Bit.  ( <em>AP &amp; 0x00FF == 0)?</em>  <em>und (</em> AP &amp; 0x00FF! = 0)?  Die bisherige Eingabe und Ausgabe der Konsole hat beschlossen, immer 8-Bit zu belassen.  Nicht in Unicode zum Drucken am Ende? </li></ol><br><p>  In diesem Video habe ich ausführlich (aber wenig verstanden) darüber gesprochen, was jede Anweisung tut und welchen Brainfuck-Anweisungen sie entspricht: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/mU3KTtWeB-s" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2 id="parallelnyy-summator">  Paralleladdierer </h2><br><p>  Relaiscomputer sollten nicht nur Relais sein, sondern auch schnell.  Wie jeder andere Computer wird auch mein Computer eine Synchronmaschine sein, die mit einem Taktgenerator ausgestattet ist.  Natürlich möchte ich keine Taktzyklen verschwenden und versuchen, jede Operation in einen Zyklus zu integrieren - das heißt, für die ansteigenden und abfallenden Flanken des Synchrongenerators kann ich einen neuen Befehl laden und ausführen.  Gleichzeitig ist es wünschenswert, dass alle Befehle für den gleichen Zeitraum ausgeführt werden. </p><br><p>  Jedes Relais hat eine bestimmte Verzögerung bei Betrieb und Freigabe, die wir für 1 herkömmliche Zeiteinheit (cu) benötigen. Wenn wir das Relais RES22 verwenden, 1u.e.  entspricht 12-15 ms (informativ), RES64 - 1,3 ms (informativ).  Die teuerste (und häufigste) Operation in meinem Auto ist der Addierer. <br>  An sich ist es recht einfach und schnell, aber "es gibt eine Einschränkung", die in der Methode zur Berechnung und Übertragung des Übertragungssignals liegt. </p><br><img src="https://habrastorage.org/files/a80/76a/c2b/a8076ac2b99b4a96b08530067edebfe6.png"><br><p>  <em>Abbildung 2: Serial Transfer Addierer.</em> </p><br><p>  Anfangs wollte ich einen sequentiellen Carry-Addierer verwenden.  Bei einem solchen Addierer hängt jede nachfolgende Entladung vom Zustand des Entladungsübertragungssignals des aktuellen ab.  Infolgedessen schwankt die Dauer des Berechnungsvorgangs zwischen 2 cu  - N * 2 cu, wobei N die Anzahl der Ziffern ist.  Infolgedessen hat ein sequentieller 16-Bit-Übertragsaddierer eine maximale Verzögerung von 32 cu </p><br><p>  Parallel Carry Addierer bieten maximale Leistung.  Ihnen fehlen die Ausbreitungsprozesse von Übertragungen von Entladung zu Entladung.  In jeder Kategorie werden gleichzeitig Ausgabewerte generiert: </p><br><img src="https://habrastorage.org/files/cce/54f/b48/cce54fb4896d4c2a87710b8f5d117a44.jpg"><br><p>  <em>Abbildung 3: Paralleler Carry-Addierer</em> </p><br><p>  Die Fähigkeit, einen Addierer mit den angegebenen Eigenschaften zu erstellen, basiert auf der Reproduktion der Summen- und Übertragungsfunktionen, die unabhängig vom Ort der Entladung im Entladungsnetz nur von den Werten der Terme abhängen.  Der Haken ist, dass das parallele Übertragungsschema selbst mit jeder nachfolgenden Entladung komplizierter wird.  Hier sehen Sie, was passiert: </p><br><img src="https://habrastorage.org/files/1fe/89c/432/1fe89c432a5b49b7a45cf4a8223e42fe.png"><br><p>  <em>Abbildung 4: (Was in Form von LaTeX-Formeln hätte sein sollen, aber nicht) Die Gleichung zur Berechnung des Übertragungssignals für die Bits.</em>  <em>Wo</em> <math> </math><em><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>k</mi><mi>i</mi></msub><mo>=</mo><msub><mi>a</mi><mi>i</mi></msub><mtext>&amp;#xA0;</mtext><mi>c</mi><mi>d</mi><mi>o</mi><mi>t</mi><msub><mi>b</mi><mi>i</mi></msub></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="13.707ex" height="2.419ex" viewBox="0 -780.1 5901.5 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/402629/&amp;usg=ALkJrhhrq8uSeORrtX_4lvVwCZGn2KqOOg#MJMATHI-6B" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/402629/&amp;usg=ALkJrhhrq8uSeORrtX_4lvVwCZGn2KqOOg#MJMATHI-69" x="737" y="-213"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/402629/&amp;usg=ALkJrhhrq8uSeORrtX_4lvVwCZGn2KqOOg#MJMAIN-3D" x="1143" y="0"></use><g transform="translate(2199,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/402629/&amp;usg=ALkJrhhrq8uSeORrtX_4lvVwCZGn2KqOOg#MJMATHI-61" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/402629/&amp;usg=ALkJrhhrq8uSeORrtX_4lvVwCZGn2KqOOg#MJMATHI-69" x="748" y="-213"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/402629/&amp;usg=ALkJrhhrq8uSeORrtX_4lvVwCZGn2KqOOg#MJMATHI-63" x="3323" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/402629/&amp;usg=ALkJrhhrq8uSeORrtX_4lvVwCZGn2KqOOg#MJMATHI-64" x="3757" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/402629/&amp;usg=ALkJrhhrq8uSeORrtX_4lvVwCZGn2KqOOg#MJMATHI-6F" x="4280" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/402629/&amp;usg=ALkJrhhrq8uSeORrtX_4lvVwCZGn2KqOOg#MJMATHI-74" x="4766" y="0"></use><g transform="translate(5127,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/402629/&amp;usg=ALkJrhhrq8uSeORrtX_4lvVwCZGn2KqOOg#MJMATHI-62" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/402629/&amp;usg=ALkJrhhrq8uSeORrtX_4lvVwCZGn2KqOOg#MJMATHI-69" x="607" y="-213"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>k</mi><mi>i</mi></msub><mo>=</mo><msub><mi>a</mi><mi>i</mi></msub><mtext>&nbsp;</mtext><mi>c</mi><mi>d</mi><mi>o</mi><mi>t</mi><msub><mi>b</mi><mi>i</mi></msub></math></span></span><script type="math/tex" id="MathJax-Element-1"> k_i = a_i \ cdot b_i </script></em>   <em>- bitweise Und,</em> <math> </math><em><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>h</mi><mi>i</mi></msub><mo>=</mo><msub><mi>a</mi><mi>i</mi></msub><mo>+</mo><msub><mi>b</mi><mi>i</mi></msub></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="11.904ex" height="2.419ex" viewBox="0 -780.1 5125.4 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/402629/&amp;usg=ALkJrhhrq8uSeORrtX_4lvVwCZGn2KqOOg#MJMATHI-68" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/402629/&amp;usg=ALkJrhhrq8uSeORrtX_4lvVwCZGn2KqOOg#MJMATHI-69" x="815" y="-213"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/402629/&amp;usg=ALkJrhhrq8uSeORrtX_4lvVwCZGn2KqOOg#MJMAIN-3D" x="1198" y="0"></use><g transform="translate(2254,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/402629/&amp;usg=ALkJrhhrq8uSeORrtX_4lvVwCZGn2KqOOg#MJMATHI-61" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/402629/&amp;usg=ALkJrhhrq8uSeORrtX_4lvVwCZGn2KqOOg#MJMATHI-69" x="748" y="-213"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/402629/&amp;usg=ALkJrhhrq8uSeORrtX_4lvVwCZGn2KqOOg#MJMAIN-2B" x="3350" y="0"></use><g transform="translate(4351,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/402629/&amp;usg=ALkJrhhrq8uSeORrtX_4lvVwCZGn2KqOOg#MJMATHI-62" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/402629/&amp;usg=ALkJrhhrq8uSeORrtX_4lvVwCZGn2KqOOg#MJMATHI-69" x="607" y="-213"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>h</mi><mi>i</mi></msub><mo>=</mo><msub><mi>a</mi><mi>i</mi></msub><mo>+</mo><msub><mi>b</mi><mi>i</mi></msub></math></span></span><script type="math/tex" id="MathJax-Element-2"> h_i = a_i + b_i </script></em>   <em>- bitweise ODER</em> </p><br><p>  Infolgedessen ist die Implementierung einer parallelen Migration ziemlich teuer.  Es kann jedoch angemerkt werden, dass die nächste Entlastung die Gleichung zur Berechnung der vorherigen enthält (es sollte ein Mem „okay ??“ mit Nicolas Cage geben), daher reicht es im Prinzip aus, ein Transferberechnungsschema nur für die vorrangige Entlastung zu erstellen und den Rest daraus zu sammeln, sofern Abschluss der Zwischenergebnisse. </p><br><img src="https://habrastorage.org/files/4df/28d/64b/4df28d64bcdd4e41804483213342fc8a.png"><br><p>  <em>Abbildung 5: Vollständiges Diagramm eines 16-Bit-Paralleladdierers</em> </p><br><p>  In Abbildung 5 sind die ersten beiden Spalten die Addierer selbst.  Dann gibt es die Blöcke 2AND und 2OR, die Zwischenwerte von h und k bilden, die in 4 gezeigt sind. Ihre Anwesenheit veranlasste mich, die Liste der Befehle um logische Operationen der Addition und Multiplikation zu erweitern, für die ich nur ein paar Latches und den entsprechenden Mikrocode hinzufügen muss. </p><br><p>  Alles andere sind 5AND-Blöcke, die auf 4 RES64-Relais basieren und so verlötet werden können, dass ein Modul beispielsweise als 2AND + 3AND verwendet werden kann.  Bei diesen Blöcken wird jeder logische UND-Schritt über eine Diode ausgegeben, mit der Sie Zwischenübertragungssignale sammeln können. </p><br><p>  Geschätzte Signalausbreitungszeit: Addierer bewältigen 1 cu, zu diesem Zeitpunkt werden Signale an den Ausgängen von 2AND / 2OR-Blöcken erzeugt, dann 1 cu  - Durch Multiplikation in 5AND-Blöcken führt die logische Addition von Dioden nicht zu einer Verzögerung.  Nun, der letzte  für die Neuberechnung des Addierers ausgegeben. </p><br><p>  Insgesamt 3 cu  gegenüber 32 oder nicht mehr als 4,5 ms für den Addierer. </p><br><h2 id="registry">  Register </h2><br><p>  Es gibt vier 16-Bit-Spezialregister in der Maschine.  Keine RONs.  Nur enge Bindung, nur Hardcore!  Es besteht aus D-Flip-Flops, jedes D-Flip-Flop ist ein separates Modul auf 4 RES55-Relais mit folgender Schaltung: </p><br><img src="https://habrastorage.org/files/67e/b6f/f92/67eb6ff92b294f4a9ac193582e7f2aa0.jpg"><br><p>  <em>Abbildung 6: Schematische Darstellung des D-Flip-Flop-Moduls.</em>  <em>Irgendwo gibt es noch einen Stecker, aber hier ist es nicht wichtig, weil alles signiert ist.</em> </p><br><p>  Daten kommen an den Dateneingang, dessen Relais bestimmt, wohin das Synchronisationssignal geleitet wird - um den Trigger zurückzusetzen oder zu installieren (wofür zwei weitere Relais verantwortlich sind, eines mit Selbsthemmung).  Das vierte Relais erhält den Schaltausgang Q. Eine sehr nützliche Funktion. </p><br><h2 id="plata-pamyati">  Speicherkarte </h2><br><img src="https://habrastorage.org/files/b75/f2f/bef/b75f2fbefffd4d12aa1c0d045e18f874.jpg"><br><p>  <em>Abbildung 7: Speicherkarte.</em>  <em>Plattenabmessungen 315x200mm</em> </p><br><p>  Ein sehr komplexes und wichtiges Element, obwohl die Speicherschaltung selbst einen kleinen Teil der gesamten Füllung des Blocks ausmacht.  Die Aufgabe dieser Karte besteht zum einen darin, 64 Kiloslovos des gesamten Speichers von Programmen und Daten zu transportieren.  Es besteht aus zwei 64-KByte-Cache-Chips.  Die über die Schutzschaltungen und den Schalter eingegebene Adresse ist mit dem Computeradressbus verbunden, und auf der Datenbusseite ein komplexes System aus Eingangspuffer und Ausgangstreiber, ebenfalls mit dem Schalter.  Für das Lesen und Schreiben in den Speicher sind zwei Zeilen W / R und Sync verantwortlich.  Der erste wählt, was wir tun werden, der zweite - wird es tatsächlich tun. </p><br><p>  Und während diese Synchronisierung selbst nicht vorhanden ist, lebt die Speicherkarte natürlich ihr eigenes Leben.  Auf dem Render sehen Sie zwei 16x16 LED-Matrizen.  Diese Anzeige zeigt einen Speicherbereich.  Eine Art VideoRAM, das übrigens programmgesteuert bestimmt wird.  Fragt den Speicherchip ab und steuert den Ausgang des Atmega1280-Mikrocontrollers. </p><br><p>  Für sim enden die Aufgaben des Mikrocontrollers nicht dort.  Konsoleneingabe und -ausgabe hängen daran.  Wo es ausgegeben wird - ich habe mich noch nicht entschieden, daher sind der USB-Serial-Konverter für eine normale Konsole und ESp8266 für Wi-Fi auf der Platine geschieden.  Letzteren zufolge in den dringendsten Plänen eine Webseite mit der Möglichkeit, Programme für den Computer in den Speicher und die Konsole selbst herunterzuladen.  Ja, zu den Aufgaben von MK gehört auch das erstmalige Laden des Programms in den Arbeitsspeicher, für den es vollen Zugriff auf den Arbeitsspeicher hat, sowie ein kleines 1-Mbit-EEPROM-In zum Speichern von Programmen. </p><br><img src="https://habrastorage.org/files/8d3/620/24c/8d362024c8c04df680f8bc2a5a53a6cd.jpg"><br><p>  <em>Abbildung 8: Schematische Darstellung einer Speicherkarte.</em>  <em>Mikrocontroller- und Blockdiagramme nicht gezeigt</em> </p><br><h2 id="blok-logiki">  Logikblock </h2><br><p>  Ich habe keine Ahnung, wie er am Ende aussehen wird.  Die neueste Version ist auf der allgemeinen Computerschaltung vorhanden, aber ich mag es nicht.  Höchstwahrscheinlich werde ich einen 12-stufigen Sequenzer bauen und mit Hilfe von Tasten Signale an einzelne Blöcke senden. </p><br><img src="https://habrastorage.org/files/107/480/a84/107480a848914e7286ec88021385dd88.jpg"><br><p>  <em>Abbildung 9: Alles um 16-Bit-Blöcke herum ist ein Logikblock</em> </p><br><h2 id="konstrukciya">  Bau </h2><br><p>  Der Aufbau der Maschine ist modular, Blockrahmen.  Das KDPV zeigt deutlich, wie sich die Befüllung der Maschine befindet.  Aber das Wichtigste zuerst: </p><br><h1 id="modul">  Modul </h1><br><p>  Das Grundelement des Computers ist ein 60 x 44 mm großes Modul mit einem 16-poligen Stecker, der 4 Relais, deren Kabelbaum und 4 LEDs trägt, um Folgendes anzuzeigen: </p><br><img src="https://habrastorage.org/files/650/4da/5d0/6504da5d00ba42ecb3eb272370fd92f8.jpg"><br><p>  <em>Abbildung 10: 3D-Modell des Moduls</em> </p><br><p>  Module verschiedener Typen: </p><br><ol><li>  1-Bit-Addierer mit Übertragung - 16 Stück; </li><li>  5AND-Modul für parallele Übertragungsschaltung - 32 Stück; </li><li>  D-Flip-Flop-Modul - 64 Stück pro Register plus ein wenig Logik; </li><li>  Modul 4x2AND_SW zum Organisieren von Latches.  Es gibt nur 4 Schließrelais; </li><li>  4x2AND-Modul zum Organisieren von Latches.  Es gibt 3 von 4 Relais mit einem Wechselkontakt.  Bei 4 Relais war nicht genügend Ausgangsstift vorhanden. </li><li>  Das Modul ist eine Diode, 8 Dioden D226D.  So organisieren Sie ein ODER mit mehreren Eingängen </li><li>  Mit dem Universalmodul 2AND / 2OR können Sie 2AND-NOT, 2OR-NOT, 4AND, 4AND-NOT, 4OR, 4OR-NOT und eine beliebige Kombination erstellen.  Basierend auf 4 Relais mit Schaltkontakten und gemeinsamen Punkten; </li></ol><br><p>  Da ich, obwohl ich einen Block der Steuerlogik gefunden habe, bereits abgelehnt habe, kenne ich nicht die genaue Anzahl der Module jedes Typs.  Ich werde es auf der Straße herausfinden.  Die geschätzte Anzahl der Module beträgt 192 Stück. </p><br><h1 id="blok">  Blockieren </h1><br><p>  Wir nehmen eine 150x200mm Platine, löten 32 Stecker mit 16 Pins darauf, aber keine einfachen, aber zum <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Einwickeln</a> und Installieren unserer Module darauf in einer 8x4 Matrix, um einen solchen Block zu erhalten: </p><br><img src="https://habrastorage.org/files/012/981/0c4/0129810c41a8415aa3ed543cbc79e47f.jpg"><br><p>  <em>Abbildung 11: Block</em> </p><br><p>  In meinem Auto gibt es 6 solcher Blöcke - zwei Blöcke pro Addierer, zwei Blöcke pro Register und zwei Blöcke pro Logik.  Ich kratzte Rüben über ein paar weitere Riegelblöcke, aber wenn sie es sind, dann sind sie flach und verlötet </p><br><p>  Die Runduminstallation wurde gewählt, weil: Erstens kann sich die Schaltung jeder Basisplatine ändern, obwohl sie im Voraus bekannt ist, und ist fehleranfällig.  Zweitens ist es im Prinzip unmöglich, den Logikblock beim ersten Mal korrekt zu trennen. Wenn für den Registerblock alles klar ist und Sie beispielsweise mit einer Synchronisationsleitung einen Fehler machen können, müssen Sie die Logik tausend und einmal wiederholen.  Es ist viel besser, wenn Sie jede Komponente des Logikblocks schrittweise erfassen.  Drittens ein rein mechanischer Faktor - es ist physikalisch unmöglich, diese Blöcke auf einem zweilagigen Brett zu trennen :) 16-Bit-Reifen divergieren in viele Richtungen, die sich wiederholt überschneiden. </p><br><p>  Insgesamt enthält jede Einheit 32 Module mit einer Gesamtzahl von 128 Relais.  Die Leistung jeder Einheit beträgt 5V 2A. </p><br><h1 id="kompyuter">  Computer </h1><br><p>  Auf einem großen Rahmen mit Abmessungen von 640 x 480 mm (tatsächlich etwas mehr, aber die Anzahl ist wunderschön) befinden sich sechs Relaisblöcke und eine Speicherplatine: </p><br><img src="https://habrastorage.org/files/fe5/217/f56/fe5217f56d15451c890f7f01b86d9c32.jpg"><br><p>  <em>Abbildung 12: Position der Maschinenblöcke</em> </p><br><p>  Der gesamte Computer wird in einen Holzrahmen aus Edelholz mit Glas vorne und hinten eingesetzt. </p><br><h2 id="izgotovlenie">  Herstellung </h2><br><p>  Trotz des aktuellen Datums existiert das Projekt tatsächlich :-) Und es befindet sich nicht in der aktivsten, aber noch in der Herstellungsphase. </p><br><h1 id="rele">  Relais </h1><br><p>  Ich habe sie  In großer Zahl, aber das Problem ist, dass es dreihundert von mehr als tausend Lagerbeständen gibt - ein Relais mit 27 Volt und 5 Volt RES55 reicht mir möglicherweise nicht aus.  Ich kann das Ausmaß der Katastrophe nicht endgültig abschätzen, aber ich denke, dass das Problem beim nächsten Mal, wenn ich diese Höllenmaschine einsammle, aufgrund der Wiederauffüllung von außen verschwinden wird. </p><br><img src="https://habrastorage.org/files/d90/065/573/d90065573e5640e9b290f7b623732c17.jpg"><br><p>  <em>Abbildung 13: Relaisreserven</em>  <em>800 Relais - neu, erfolgreich auf dem Mitsa-Radiomarkt für einen Cent beschlagnahmt</em> </p><br><p>  Eine der Nachschubquellen sind die DAC-Relaisplatinen aus Labornetzteilen.  Hier sind diese: </p><br><img src="https://habrastorage.org/files/a7b/4e3/547/a7b4e35475444a50bc1ec89647d20427.jpg"><br><p>  <em>Abbildung 14: Karten von Netzteilen, die auf dem Funkmarkt gekauft wurden (nein, das bin ich nicht)</em> </p><br><h1 id="pechatnye-platy">  Leiterplatten </h1><br><p>  Ich habe beschlossen, alle Leiterplatten selbst zu machen.  Ich habe 300 Dollar an die Chinesen geklemmt und seit 4 Monaten arbeite ich daran, die Rohlinge mit Fotolack zu bedecken, durchscheinend, zu ätzen, mit einer Lötmaske zu bedecken, zu entwickeln, zu bohren und zu fräsen. </p><br><img src="https://habrastorage.org/files/fca/713/a66/fca713a6619b460499051e07f8c2a999.JPG"><br><p>  <em>Abbildung 15: Geätzte Platten verschiedener Art</em> </p><br><p>  Ich mache Platten in Platten, 9 Module auf einer 200x150mm Platte.  30 Platten geätzt und beim Auftragen einer Lötmaske aufgeklebt.  Ich werde in keiner Weise anfangen.  Die Lötmaske meines FSR-8000 ist blau, zweikomponentig und ich habe mich bereits zuvor damit befasst. </p><br><p>  200150    —    ,                  . </p><br><p>    (-  )          .     . </p><br><p>         ,      3- . </p><br><img src="https://habrastorage.org/files/d40/88f/5dd/d4088f5dd8e54549b4ea8f565b5f075a.jpg"><br><p> <em> 16: 3D-   DIY 2020CNC</em> </p><br><p>      175    .     ,       +  3-.    ,        —  . </p><br><p>          : </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/0F5jdi7wreg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2 id="programmy">  Programme </h2><br><p>       ,         .      (    )     Elf.     ,        (        ). <em>//TODO      —      ,          </em> . </p><br><p>    : .    , .      .   Segmentation Fault! </p><br><p>  ,  .       —         .    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">leBrainfuck</a> ,           . <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">   </a> ,      ,      Brainfuck     .    +-&lt;&gt;,      [-]   .     ,     . ,   . </p><br><p>    .          8 .       : </p><br><img src="https://habrastorage.org/files/f4e/5b4/e94/f4e5b4e949c94111ab3379b34f7b6923.jpg"><br><p>   —   10 .     LLVM    0,9 .       Intel Vtune Amplifier       120   10   . </p><br><p>    .    ,  3   brainfuck-.      100  50     347   — ..     ,     !          ,   ,  .             . </p><br><p>  ,    ,        ,    </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/whk8NKAdsB8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a>             . </p><br><h2 id="myslishki">  </h2><br><p>       -6        ,       ,           .            —       ,        .   —   .     -        —     30-40 -    6   . </p><br><h2 id="zacheeeem777"> ????777 </h2><br><img src="https://habrastorage.org/files/1fb/f24/c16/1fbf24c164974f8fabba8e7e03e5856b.jpg"><br><h2 id="ssylki">  Referenzen </h2><br><p>    openSource.      : </p><br><ol><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://github.com/radiolok/RelayComputer2</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - ein Repository mit schematischen Diagrammen und Leiterplattenlayouts. </font><font style="vertical-align: inherit;">Einen Link zum Firmware-Repository der Speicherplatine werde ich später hinzufügen</font></font></li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://github.com/radiolok/RelayComputer2/blob/master/roadmap.md</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ich werde diese Seite mit der Projekt-Roadmap, auf der wichtige Änderungen aufgezeichnet werden, separat vermerken.</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://hackaday.io/project/18599-brainfuck-relay-computer</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Auf dieser Seite veröffentliche ich detaillierte Berichte darüber, was getan wurde. </font><font style="vertical-align: inherit;">Je nach kritischer Masse werden sie zu einem Artikel über GT.</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://github.com/radiolok/bfutils</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Compiler und Emulator.</font></font></li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de402629/">https://habr.com/ru/post/de402629/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de402619/index.html">Eine vertikale Roboterfarm baut Pflanzen 400% effizienter an als eine herkömmliche Farm</a></li>
<li><a href="../de402621/index.html">Reise zum Mars: Was kann mit dem Astronauten auf dem Weg zum Planeten und auf seiner Oberfläche geschehen?</a></li>
<li><a href="../de402623/index.html">CampStove 2: Ein Campingkocher, von dem aus Sie Geräte aufladen können</a></li>
<li><a href="../de402625/index.html">CO2-Lampe (mh-z19)</a></li>
<li><a href="../de402627/index.html">Hat Russland eine Chance auf Führung im „Marathon der künstlichen Intelligenz“?</a></li>
<li><a href="../de402631/index.html">Welchen Herzfrequenzmesser Sie in der neuen Saison wählen sollten: Kompromisslösungen innerhalb von drei bis viertausend Rubel</a></li>
<li><a href="../de402633/index.html">Die Geschichte von Battlefield 1 in Full HD über die integrierte Grafik im Prozessor und die Montage der Konsole für "unvergänglich"</a></li>
<li><a href="../de402637/index.html">Der 17-jährige Student hat den NASA-Fehler korrigiert</a></li>
<li><a href="../de402639/index.html">Peter Watts über SOMA</a></li>
<li><a href="../de402641/index.html">Wie tief neuronale Netze aussehen und warum sie so viel Speicher benötigen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>