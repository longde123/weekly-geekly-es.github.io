<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐏 #⃣ 🧛🏾 Recettes pour ELF 🙍🏼 🤘🏿 😰</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En russe, il n'y a pas assez d'informations sur la façon de travailler avec les fichiers ELF (format exécutable et linkable - le format principal pour...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Recettes pour ELF</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/inforion/blog/460247/"><p><img src="https://habrastorage.org/webt/xk/e_/v6/xke_v6gzyavn2y7zh5skzlm3op0.jpeg" alt="image"></p><br><p>  En russe, il n'y a pas assez d'informations sur la façon de travailler avec les fichiers ELF (format exécutable et linkable - le format principal pour les fichiers exécutables de Linux et de nombreux systèmes Unix).  Nous ne prétendons pas couvrir entièrement tous les scénarios possibles de travail avec les elfes, mais nous espérons que les informations seront utiles sous la forme d'un guide et d'une collection de recettes pour les programmeurs et les ingénieurs inversés. </p><br><p>  Il est entendu que le lecteur au niveau de base est familier avec le format ELF (sinon, nous recommandons la série d'articles <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Executable et Linkable Format 101</a> ). </p><br><p>  Sous la coupe seront listés les outils de travail, les techniques décrites pour la lecture des méta-informations, la modification, la vérification et <del>  élevage </del>  créer des elfes, ainsi que des liens vers des documents utiles. </p><a name="habracut"></a><br><blockquote>  "Je suis aussi un elfe ... Bleu en rouge ... Les elfes sont très patients ... Bleu en rouge ... Et nous sommes des elfes! .. Bleu en rouge ... Il n'y a que des problèmes de magie ... <br>  (c) Le petit royaume de Ben et Holly </blockquote><br><h1 id="instrumenty">  Les outils </h1><br><p>  Dans la plupart des cas, les exemples peuvent être exécutés sur Linux et Windows. </p><br><p>  Dans les recettes, nous utiliserons les outils suivants: </p><br><ul><li>  utilitaires de l'ensemble binutils (objcopy, objdump, readelf, strip); </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cadre radare2</a> ; </li><li>  éditeur hexadécimal avec prise en charge des modèles de fichiers (les exemples montrent <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">010Editor</a> , mais vous pouvez utiliser, par exemple, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Veles</a> gratuit); </li><li>  Python et la bibliothèque <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">LIEF</a> ; </li><li>  d'autres utilitaires (les liens sont dans la recette). </li></ul><br><h1 id="testovye-elfy">  Elfes de test </h1><br><p>  En tant que «expérimental», nous utiliserons le <em>simple</em> fichier ELF de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la tâche</a> PieIsMyFav de nutcake sur crackmes.one, mais tout représentant de la famille «elfique» fera l'affaire.  Si le fichier fini avec les caractéristiques requises n'a pas été trouvé dans le domaine public, alors une méthode pour créer un tel elfe sera donnée. </p><br><p>  Elfes gratuits peuvent également être trouvés sur les liens: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Exemples d'elfes pour différentes plates-formes</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Test des elfes pour radare2</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Projet ElfHacks sur Github</a> - une sélection de petits elfes avec différents paramètres; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Crackme pour Unix / Linux</a> - mais gardez à l'esprit que des échantillons difficiles peuvent <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">apparaître</a> ici. </li></ul><br><h1 id="chtenie-poluchenie-informacii">  Lire, s'informer </h1><br><h2 id="tip-fayla-zagolovok-sekcii">  Type de fichier, titre, section </h2><br><p>  Selon la tâche, les éléments suivants peuvent être intéressants: </p><br><ul><li>  type de fichier (DYN - bibliothèque, EXEC - exécutable, RELOC - pouvant être lié); </li><li>  architecture cible (E_MACHINE - x86_64, x86, ARM, etc.); </li><li>  point d'entrée d'application (Entry Point); </li><li>  informations sur la section. </li></ul><br><h3 id="010editor">  010 Éditeur </h3><br><p> HEX Editor 010Editor fournit un système de modèles.  Pour les fichiers ELF, le modèle est appelé, curieusement, <em>ELF.bt</em> et se trouve dans la catégorie <em>Exécutable</em> (menu Modèles - Exécutable). <br>  Par exemple, le point d'entrée vers le fichier exécutable (point d'entrée) (enregistré dans l'en-tête du fichier) peut être intéressant. </p><br><p><img src="https://habrastorage.org/webt/uz/f4/i6/uzf4i6yhfy9epat61pd4uolvegw.png" alt="image"></p><br><h3 id="readelf">  lire </h3><br><p>  L'utilitaire readelf peut être considéré comme la norme de facto pour obtenir des informations sur un fichier ELF. </p><br><ul><li>  Lisez l'en-tête du fichier: <br><pre><code class="bash hljs">$ readelf -h simple</code> </pre> </li></ul><br><div class="spoiler">  <b class="spoiler_title">Résultat d'équipe</b> <div class="spoiler_text"><pre> <code class="markdown hljs">ELF Header: Magic: 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 Class: ELF64 Data: 2's complement, little endian Version: 1 (current) OS/ABI: UNIX - System V ABI Version: 0 Type: DYN (Shared object file) Machine: Advanced Micro Devices X86-64 Version: 0x1 Entry point address: 0x1070 Start of program headers: 64 (bytes into file) Start of section headers: 14800 (bytes into file) Flags: 0x0 Size of this header: 64 (bytes) Size of program headers: 56 (bytes) Number of program headers: 11 Size of section headers: 64 (bytes) Number of section headers: 30 Section header string table index: 29</code> </pre> </div></div><br><ul><li>  Lisez les informations sur les segments et les sections: <br><pre> <code class="bash hljs">$ readelf -l -W simple</code> </pre> </li></ul><br><div class="spoiler">  <b class="spoiler_title">Résultat d'équipe</b> <div class="spoiler_text"><p>  Pour plus de lisibilité, les adresses sont converties au format 32 bits: </p><br><pre> <code class="markdown hljs">Elf file type is DYN (Shared object file) Entry point 0x1070 There are 11 program headers, starting at offset 64 Program Headers: Type Offset VirtAddr PhysAddr FileSiz MemSiz Flg Align PHDR 0x000040 0x00000040 0x00000040 0x000268 0x000268 R 0x8 INTERP 0x0002a8 0x000002a8 0x000002a8 0x00001c 0x00001c R 0x1 [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2] LOAD 0x000000 0x00000000 0x00000000 0x0005f8 0x0005f8 R 0x1000 LOAD 0x001000 0x00001000 0x00001000 0x00026d 0x00026d RE 0x1000 LOAD 0x002000 0x00002000 0x00002000 0x0001b8 0x0001b8 R 0x1000 LOAD 0x002de8 0x00003de8 0x00003de8 0x000258 0x000260 RW 0x1000 DYNAMIC 0x002df8 0x00003df8 0x00003df8 0x0001e0 0x0001e0 RW 0x8 NOTE 0x0002c4 0x000002c4 0x000002c4 0x000044 0x000044 R 0x4 GNU<span class="hljs-emphasis"><span class="hljs-emphasis">_EH_</span></span>FRAME 0x002070 0x00002070 0x00002070 0x00003c 0x00003c R 0x4 GNU<span class="hljs-emphasis"><span class="hljs-emphasis">_STACK 0x000000 0x00000000 0x00000000 0x000000 0x000000 RW 0x10 GNU_</span></span>RELRO 0x002de8 0x00003de8 0x00003de8 0x000218 0x000218 R 0x1 Section to Segment mapping: Segment Sections... 00 01 .interp 02 .interp .note.ABI-tag .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version<span class="hljs-emphasis"><span class="hljs-emphasis">_r .rela.dyn .rela.plt 03 .init .plt .plt.got .text .fini 04 .rodata .eh_</span></span>frame<span class="hljs-emphasis"><span class="hljs-emphasis">_hdr .eh_</span></span>frame 05 .init<span class="hljs-emphasis"><span class="hljs-emphasis">_array .fini_</span></span>array .dynamic .got .got.plt .data .bss 06 .dynamic 07 .note.ABI-tag .note.gnu.build-id 08 .eh<span class="hljs-emphasis"><span class="hljs-emphasis">_frame_</span></span>hdr 09 10 .init<span class="hljs-emphasis"><span class="hljs-emphasis">_array .fini_</span></span>array .dynamic .got</code> </pre> </div></div><br><ul><li>  Lisez les informations de la section: <br><pre> <code class="bash hljs">$ readelf -S -W simple</code> </pre> </li></ul><br><div class="spoiler">  <b class="spoiler_title">Résultat d'équipe</b> <div class="spoiler_text"><p>  Pour plus de lisibilité, les adresses sont converties au format 32 bits: </p><br><pre> <code class="markdown hljs">There are 30 section headers, starting at offset 0x39d0: Section Headers: [Nr] Name Type Address Off Size ES Flg Lk Inf Al [ 0] NULL 00000000 000000 000000 00 0 0 0 [ 1] .interp PROGBITS 000002a8 0002a8 00001c 00 A 0 0 1 [ 2] .note.ABI-tag NOTE 000002c4 0002c4 000020 00 A 0 0 4 [ 3] .note.gnu.build-id NOTE 000002e4 0002e4 000024 00 A 0 0 4 [ 4] .gnu.hash GNU<span class="hljs-emphasis"><span class="hljs-emphasis">_HASH 00000308 000308 000024 00 A 5 0 8 [ 5] .dynsym DYNSYM 00000330 000330 0000d8 18 A 6 1 8 [ 6] .dynstr STRTAB 00000408 000408 0000a2 00 A 0 0 1 [ 7] .gnu.version VERSYM 000004aa 0004aa 000012 02 A 5 0 2 [ 8] .gnu.version_</span></span>r VERNEED 000004c0 0004c0 000030 00 A 6 1 8 [ 9] .rela.dyn RELA 000004f0 0004f0 0000c0 18 A 5 0 8 [10] .rela.plt RELA 000005b0 0005b0 000048 18 AI 5 23 8 [11] .init PROGBITS 00001000 001000 000017 00 AX 0 0 4 [12] .plt PROGBITS 00001020 001020 000040 10 AX 0 0 16 [13] .plt.got PROGBITS 00001060 001060 000008 08 AX 0 0 8 [14] .text PROGBITS 00001070 001070 0001f2 00 AX 0 0 16 [15] .fini PROGBITS 00001264 001264 000009 00 AX 0 0 4 [16] .rodata PROGBITS 00002000 002000 000070 00 A 0 0 8 [17] .eh<span class="hljs-emphasis"><span class="hljs-emphasis">_frame_</span></span>hdr PROGBITS 00002070 002070 00003c 00 A 0 0 4 [18] .eh<span class="hljs-emphasis"><span class="hljs-emphasis">_frame PROGBITS 000020b0 0020b0 000108 00 A 0 0 8 [19] .init_</span></span>array INIT<span class="hljs-emphasis"><span class="hljs-emphasis">_ARRAY 00003de8 002de8 000008 08 WA 0 0 8 [20] .fini_</span></span>array FINI_ARRAY 00003df0 002df0 000008 08 WA 0 0 8 [21] .dynamic DYNAMIC 00003df8 002df8 0001e0 10 WA 6 0 8 [22] .got PROGBITS 00003fd8 002fd8 000028 08 WA 0 0 8 [23] .got.plt PROGBITS 00004000 003000 000030 08 WA 0 0 8 [24] .data PROGBITS 00004030 003030 000010 00 WA 0 0 8 [25] .bss NOBITS 00004040 003040 000008 00 WA 0 0 1 [26] .comment PROGBITS 00000000 003040 00001c 01 MS 0 0 1 [27] .symtab SYMTAB 00000000 003060 000630 18 28 44 8 [28] .strtab STRTAB 00000000 003690 000232 00 0 0 1 [29] .shstrtab STRTAB 00000000 0038c2 000107 00 0 0 1 Key to Flags: W (write), A (alloc), X (execute), M (merge), S (strings), l (large) I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown) O (extra OS processing required) o (OS specific), p (processor specific)</code> </pre> </div></div><br><ul><li>  Lire les informations sur les symboles: <br><pre> <code class="bash hljs">$ readelf -s -W simple</code> </pre> </li></ul><br><div class="spoiler">  <b class="spoiler_title">Résultat d'équipe</b> <div class="spoiler_text"><p>  La sortie est raccourcie pour plus de lisibilité: </p><br><pre> <code class="markdown hljs">Symbol table '.dynsym' contains 9 entries: Num: Value Size Type Bind Vis Ndx Name 0: 00000000 0 NOTYPE LOCAL DEFAULT UND 1: 00000000 0 NOTYPE WEAK DEFAULT UND <span class="hljs-emphasis"><span class="hljs-emphasis">_ITM_</span></span>deregisterTMCloneTable 2: 00000000 0 FUNC GLOBAL DEFAULT UND puts@GLIBC<span class="hljs-emphasis"><span class="hljs-emphasis">_2.2.5 (2) 3: 00000000 0 FUNC GLOBAL DEFAULT UND printf@GLIBC_</span></span>2.2.5 (2) 4: 00000000 0 FUNC GLOBAL DEFAULT UND <span class="hljs-strong"><span class="hljs-strong">__libc_start_main@GLIBC_2.2.5 (2) 5: 00000000 0 NOTYPE WEAK DEFAULT UND __</span></span>gmon<span class="hljs-emphasis"><span class="hljs-emphasis">_start_</span></span><span class="hljs-emphasis"><span class="hljs-emphasis">_ 6: 00000000 0 FUNC GLOBAL DEFAULT UND _</span></span><span class="hljs-emphasis"><span class="hljs-emphasis">_isoc99_</span></span>scanf@GLIBC<span class="hljs-emphasis"><span class="hljs-emphasis">_2.7 (3) 7: 00000000 0 NOTYPE WEAK DEFAULT UND _</span></span>ITM<span class="hljs-emphasis"><span class="hljs-emphasis">_registerTMCloneTable 8: 00000000 0 FUNC WEAK DEFAULT UND _</span></span><span class="hljs-emphasis"><span class="hljs-emphasis">_cxa_</span></span>finalize@GLIBC<span class="hljs-emphasis"><span class="hljs-emphasis">_2.2.5 (2) Symbol table '.symtab' contains 66 entries: Num: Value Size Type Bind Vis Ndx Name 0: 00000000 0 NOTYPE LOCAL DEFAULT UND 1: 000002a8 0 SECTION LOCAL DEFAULT 1 2: 000002c4 0 SECTION LOCAL DEFAULT 2 3: 000002e4 0 SECTION LOCAL DEFAULT 3 4: 00000308 0 SECTION LOCAL DEFAULT 4 5: 00000330 0 SECTION LOCAL DEFAULT 5 6: 00000408 0 SECTION LOCAL DEFAULT 6 7: 000004aa 0 SECTION LOCAL DEFAULT 7 .... 26: 00000000 0 SECTION LOCAL DEFAULT 26 27: 00000000 0 FILE LOCAL DEFAULT ABS crtstuff.c 28: 000010a0 0 FUNC LOCAL DEFAULT 14 deregister_</span></span>tm<span class="hljs-emphasis"><span class="hljs-emphasis">_clones 29: 000010d0 0 FUNC LOCAL DEFAULT 14 register_</span></span>tm<span class="hljs-emphasis"><span class="hljs-emphasis">_clones 30: 00001110 0 FUNC LOCAL DEFAULT 14 _</span></span><span class="hljs-emphasis"><span class="hljs-emphasis">_do_</span></span>global<span class="hljs-emphasis"><span class="hljs-emphasis">_dtors_</span></span>aux 31: 00004040 1 OBJECT LOCAL DEFAULT 25 completed.7389 ....</code> </pre> </div></div><br><p>  L'option <code>-W</code> est nécessaire pour augmenter la largeur de la sortie de la console (par défaut, 80 caractères). </p><br><h3 id="lief">  Lief </h3><br><p>  Vous pouvez lire les informations d'en-tête et de section à l'aide du code Python et de la bibliothèque LIEF (fournit une API non seulement pour Python): </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief binary = lief.parse(<span class="hljs-string"><span class="hljs-string">"simple.elf"</span></span>) header = binary.header print(<span class="hljs-string"><span class="hljs-string">"Entry point: %08x"</span></span> % header.entrypoint) print(<span class="hljs-string"><span class="hljs-string">"Architecture: "</span></span>, header.machine_type) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> section <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> binary.sections: print(<span class="hljs-string"><span class="hljs-string">"Section %s - size: %s bytes"</span></span> % (section.name, section.size)</code> </pre> <br><h2 id="informaciya-o-kompilyatore">  Informations sur le compilateur </h2><br><p>  Pour plus d'informations sur le compilateur et la génération, consultez les <code>.note</code> <code>.comment</code> et <code>.note</code> . </p><br><h3 id="objdump">  objdump </h3><br><pre> <code class="bash hljs">$ objdump -s --section .comment simple</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Résultat d'équipe</b> <div class="spoiler_text"><pre> <code class="markdown hljs">simple: file format elf64-x86-64 Contents of section .comment: 0000 4743433a 20284465 6269616e 20382e32 GCC: (Debian 8.2 0010 2e302d39 2920382e 322e3000 .0-9) 8.2.0.</code> </pre> </div></div><br><h3 id="readelf-1">  lire </h3><br><pre> <code class="bash hljs">$ readelf -p .comment simple</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Résultat d'équipe</b> <div class="spoiler_text"><pre> <code class="markdown hljs">String dump of section '.comment': [ 0] GCC: (Debian 8.2.0-9) 8.2.0</code> </pre> </div></div><br><pre> <code class="bash hljs">$ readelf -n simple</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Résultat d'équipe</b> <div class="spoiler_text"><pre> <code class="markdown hljs">Displaying notes found at file offset 0x000002c4 with length 0x00000020: Owner Data size Description GNU 0x00000010 NT<span class="hljs-emphasis"><span class="hljs-emphasis">_GNU_</span></span>ABI<span class="hljs-emphasis"><span class="hljs-emphasis">_TAG (ABI version tag) OS: Linux, ABI: 3.2.0 Displaying notes found at file offset 0x000002e4 with length 0x00000024: Owner Data size Description GNU 0x00000014 NT_</span></span>GNU<span class="hljs-emphasis"><span class="hljs-emphasis">_BUILD_</span></span>ID (unique build ID bitstring) Build ID: dae0509e4edb79719a65af37962b74e4cf2a8c2e</code> </pre> </div></div><br><h3 id="lief-1">  Lief </h3><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief binary = lief.parse(<span class="hljs-string"><span class="hljs-string">"simple"</span></span>) comment = binary.get_section(<span class="hljs-string"><span class="hljs-string">".comment"</span></span>) print(<span class="hljs-string"><span class="hljs-string">"Comment: "</span></span>, bytes(comment.content))</code> </pre><br><h2 id="ya-vychislyu-tebya-po-rpath">  Je vais te calculer par ... RPATH </h2><br><p>  Les elfes peuvent enregistrer des chemins pour trouver des bibliothèques connectées dynamiquement.  Afin de ne pas définir la variable système <code>LD_LIBRARY_PATH</code> avant de démarrer l'application, vous pouvez simplement «incorporer» ce chemin dans le fichier ELF. </p><br><p>  Pour ce faire, utilisez l'entrée dans la section <code>.dynamic</code> avec le type <code>DT_RPATH</code> ou <code>DT_RUNPATH</code> (voir le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">chapitre Répertoires recherchés par le Runtime Linker</a> dans la documentation). </p><br><p>  <strong>Et attention, jeune développeur, ne "dormez" pas votre répertoire de projet!</strong> </p><br><h3 id="kak-poyavlyaetsya-rpath">  Comment RPATH apparaît-il? </h3><br><p>  La principale raison de l'apparition d'un enregistrement RPATH dans un elfe est l'option linker <code>-rpath</code> pour rechercher une bibliothèque dynamique.  Quelque chose comme ça: </p><br><pre> <code class="bash hljs">$ gcc -L./lib -Wall -Wl,-rpath=/run/media/pablo/disk1/projects/cheat_sheets/ELF/lib/ -o test_rpath.elf bubble_main.c -lbubble</code> </pre> <br><p>  Une telle commande créera un enregistrement RPATH dans la section <code>.dynamic</code> avec la valeur <code>/run/media/pablo/disk1/projects/cheat_sheets/ELF/lib/</code> . </p><br><h3 id="readelf-2">  lire </h3><br><p>  Vous pouvez afficher les éléments de la section <code>.dynamic</code> (parmi lesquels il y a RPATH) comme suit: </p><br><pre> <code class="bash hljs">$ readelf -d test_rpath.elf</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Résultat d'équipe</b> <div class="spoiler_text"><p>  Pour faciliter la lecture, le résultat de la commande est réduit: </p><br><pre> <code class="markdown hljs">Dynamic section at offset 0x2dd8 contains 28 entries: Tag Type Name/Value 0x0000000000000001 (NEEDED) Shared library: [libbubble.so] 0x0000000000000001 (NEEDED) Shared library: [libc.so.6] 0x000000000000000f (RPATH) Library rpath: [/run/media/pablo/disk1/projects/cheat_sheets/ELF/lib/] 0x000000000000000c (INIT) 0x1000 0x000000000000000d (FINI) 0x11c8 ....</code> </pre> </div></div><br><h3 id="lief-2">  Lief </h3><br><p>  En utilisant la bibliothèque LIEF, vous pouvez également lire l'enregistrement RPATH dans l'elfe: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> lief.ELF <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> DYNAMIC_TAGS elf = lief.parse(<span class="hljs-string"><span class="hljs-string">"test_rpath.elf"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> elf.has(DYNAMIC_TAGS.RPATH): rpath = next(filter(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: x.tag == DYNAMIC_TAGS.RPATH, elf.dynamic_entries)) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> path <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> rpath.paths: print(path) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: print(<span class="hljs-string"><span class="hljs-string">"No RPATH in ELF"</span></span>)</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Lisez à propos de la section .dynamic</a> </p><br><h2 id="proverka-elfa-na-bezopasnost">  Vérification de la sécurité d'Elf </h2><br><p>  Le script de contrôle de sécurité <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">checksec.sh</a> du chercheur Tobias Klein (auteur de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">A Bug Hunter's Diary</a> ) n'a pas été mis à jour depuis 2011.  Ce script pour les fichiers ELF vérifie la disponibilité des options RelRO (Read Only Relocations), NX (Non-Executable Stack), Stack Canaries, PIE (Position Independent Executables) et utilise l'utilitaire readelf pour son travail. </p><br><h3 id="lief-3">  Lief </h3><br><p>  Vous pouvez créer votre propre analogique sur <del>  genou </del>  Python et LIEF (légèrement plus court que le progéniteur et avec vérification supplémentaire de l'option de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">code séparé</a> ): </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> lief.ELF <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> DYNAMIC_TAGS, SEGMENT_TYPES <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">filecheck</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(filename)</span></span></span><span class="hljs-function">:</span></span> binary = lief.parse(filename) <span class="hljs-comment"><span class="hljs-comment"># check RELRO if binary.has(SEGMENT_TYPES.GNU_RELRO): print("+ Full RELRO") if binary.has(DYNAMIC_TAGS.BIND_NOW) else print("~ Partial RELRO") else: print("- No RELRO") # check for stack canary support print("+ Canary found") if binary.has_symbol("__stack_chk_fail") else print("- No canary found") # check for NX support (check X-flag for GNU_STACK-segment) print("+ NX enabled") if binary.has_nx else print("- NX disabled") # check for PIE support print("+ PIE enabled") if binary.is_pie else print("- No PIE") # check for rpath / run path print("+ RPATH") if binary.has(DYNAMIC_TAGS.RPATH) else print("- No RPATH") print("+ RUNPATH")if binary.has(DYNAMIC_TAGS.RUNPATH) else print("- No RUNPATH") # check separate-code option if set(binary.get_section('.text').segments) == set(binary.get_section('.rodata').segments): print("- Not Separated Code Sections") else: print("+ Separated Code Sections") filecheck('test_rpath.elf')</span></span></code> </pre> <br><h3 id="radare2">  Radare2 </h3><br><p>  Merci à <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">dukebarman</a> pour l'ajout de l'utilisation de Radare2 pour afficher des informations similaires à <em>checksec</em> : </p><br><pre> <code class="bash hljs">&gt; r2 -ci~pic,canary,nx,crypto,stripped,static,relocs test_stack_proteck</code> </pre> <br><h2 id="syroy-kod-iz-elfa-binary-from-elf">  Code brut d'Elf (binaire d'ELF) </h2><br><p>  Il y a des situations où des «vêtements elfes» sous la forme d'une structure ELF ne sont pas nécessaires, mais seul le code d'application exécutable «nu» est nécessaire. </p><br><h3 id="objcopy">  objcopy </h3><br><p>  L'utilisation d' <em>objcopy est</em> probablement familière à ceux qui écrivent le firmware: </p><br><pre> <code class="bash hljs">$ objcopy -O binary -S -g simple.elf simple.bin</code> </pre> <br><ul><li>  <code>-S</code> - pour supprimer les informations sur les caractères; </li><li>  <code>-g</code> - pour supprimer les informations de débogage. </li></ul><br><h3 id="lief-4">  Lief </h3><br><p>  Pas de magie.  Prenez simplement le contenu des sections chargées et créez-en un binaire: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> lief.ELF <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> SECTION_FLAGS, SECTION_TYPES binary = lief.parse(<span class="hljs-string"><span class="hljs-string">"test"</span></span>) end_addr = <span class="hljs-number"><span class="hljs-number">0</span></span> data = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> section <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> filter(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: x.has(SECTION_FLAGS.ALLOC) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> x.type != SECTION_TYPES.NOBITS, binary.sections): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> &lt; end_addr &lt; section.virtual_address: align_bytes = <span class="hljs-string"><span class="hljs-string">b'\x00'</span></span> * (section.virtual_address - end_addr) data.append(align_bytes) data.append(bytes(section.content)) end_addr = section.virtual_address + section.size <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(<span class="hljs-string"><span class="hljs-string">'test.lief.bin'</span></span>, <span class="hljs-string"><span class="hljs-string">'wb'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> d_bytes <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> data: f.write(d_bytes)</code> </pre> <br><h2 id="mangled---demangled-imena-funkciy">  Mangled - noms de fonction démêlés </h2><br><p>  Dans les ELF créés à partir du code C ++, les noms des fonctions sont décorés (modifiés) pour simplifier la recherche de la fonction de classe correspondante.  Cependant, la lecture de ces noms dans l'analyse n'est pas très pratique. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Elfe de test</a> </p><br><h3 id="nm">  nm </h3><br><p>  Pour représenter des noms sous une forme lisible par l'homme, vous pouvez utiliser l'utilitaire <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">nm</a> de l'ensemble binutils: </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#        $ nm -D demangle-test-cpp ... U _Unwind_Resume U _ZdlPv U _Znwm U _ZSt17__throw_bad_allocv U _ZSt20__throw_length_errorPKc #        $ nm -D --demangle demangle-test-cpp ... U _Unwind_Resume U operator delete(void*) U operator new(unsigned long) U std::__throw_bad_alloc() U std::__throw_length_error(char const*)</span></span></code> </pre> <br><h3 id="lief-5">  Lief </h3><br><p>  Affichage des noms de symboles sous forme démangulée à l'aide de la bibliothèque LIEF: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief binary = lief.parse(<span class="hljs-string"><span class="hljs-string">"demangle-test-cpp"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> symb <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> binary.symbols: print(symb.name, symb.demangled_name)</code> </pre> <br><h1 id="sborka-zapis-modifikaciya-elfa">  Assemblage, enregistrement, modification de l'elfe </h1><br><h2 id="elf-bez-metainformacii">  Elfe sans méta-information </h2><br><p>  Une fois l'application déboguée et publiée dans le monde sauvage, il est logique de supprimer les méta-informations: </p><br><ul><li>  sections de débogage - inutiles dans la plupart des cas; </li><li>  noms des variables et des fonctions - n'affectent absolument rien pour l'utilisateur final (complique légèrement l'inverse); </li><li>  table de section - absolument pas nécessaire pour exécuter l'application (son manque compliquera légèrement l'inverse). </li></ul><br><h2 id="udalenie-simvolnoy-informacii">  Supprimer les informations sur les personnages </h2><br><p>  Les informations sur les caractères sont les noms des objets et des fonctions.  Sans cela, l'inverse de l'application est un peu plus compliqué. </p><br><h3 id="strip">  bande </h3><br><p>  Dans le cas le plus simple, vous pouvez utiliser l'utilitaire <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">strip</a> de l'ensemble binutils.  Pour supprimer toutes les informations sur les caractères, exécutez simplement la commande: </p><br><ul><li>  pour le fichier exécutable: <br><pre> <code class="bash hljs">$ strip -s simple</code> </pre> </li><li>  pour la bibliothèque dynamique: <br><pre> <code class="bash hljs">$ strip --strip-unneeded libsimple.so</code> </pre> </li></ul><br><h3 id="sstrip">  sstrip </h3><br><p>  Pour supprimer soigneusement les informations sur les caractères (y compris les octets zéro inutiles à la fin du fichier), vous pouvez utiliser l'utilitaire sstrip de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">suite ELFkickers</a> .  Pour supprimer toutes les informations sur les caractères, exécutez simplement la commande: </p><br><pre> <code class="bash hljs">$ sstrip -z simple</code> </pre> <br><h3 id="lief-6">  Lief </h3><br><p>  En utilisant la bibliothèque LIEF, vous pouvez également faire une bande rapide (la table des symboles est supprimée - section <code>.symtab</code> ): </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief binary = lief.parse(<span class="hljs-string"><span class="hljs-string">"simple"</span></span>) binary.strip() binary.write(<span class="hljs-string"><span class="hljs-string">"simple.stripped"</span></span>)</code> </pre> <br><h2 id="udalenie-tablicy-sekciy">  Suppression d'une table de partition </h2><br><p>  Comme mentionné ci-dessus, la présence / absence d'une table de section n'affecte pas le fonctionnement de l'application.  Mais en même temps, sans table de section, l'inverse de l'application devient un peu plus compliqué. <br>  Nous utiliserons la bibliothèque LIEF sous Python et l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">exemple de suppression de la table de section</a> : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief binary = lief.parse(<span class="hljs-string"><span class="hljs-string">"simple"</span></span>) binary.header.numberof_sections = <span class="hljs-number"><span class="hljs-number">0</span></span> binary.header.section_header_offset = <span class="hljs-number"><span class="hljs-number">0</span></span> binary.write(<span class="hljs-string"><span class="hljs-string">"simple.modified"</span></span>)</code> </pre> <br><h2 id="izmenenie-i-udalenie-rpath">  Modifier et supprimer RPATH </h2><br><h3 id="chrpath-patchelf">  chrpath, PatchELF </h3><br><p>  Pour changer RPATH sous Linux, vous pouvez utiliser les utilitaires <em>chrpath</em> (disponibles sur la plupart des distributions) ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PatchELF</a> . </p><br><ul><li><p>  Changer RPATH: </p><br><pre> <code class="bash hljs">$ chrpath -r /opt/my-libs/lib:/foo/lib test_rpath.elf</code> </pre> <br><p>  ou </p><br><pre> <code class="bash hljs">$ patchelf --<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>-rpath /opt/my-libs/lib:/foo/lib test_rpath.elf</code> </pre> <br></li><li><p>  Supprimer RPATH: </p><br><pre> <code class="bash hljs">$ chrpath -d test_rpath.elf</code> </pre> <br><p>  ou </p><br><pre> <code class="bash hljs">$ patchelf --shrink-rpath test_rpath.elf</code> </pre> <br></li></ul><br><h3 id="lief-7">  Lief </h3><br><p>  La bibliothèque LIEF vous permet également de modifier et de supprimer un enregistrement RPATH. </p><br><ul><li><p>  Changer RPATH: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief binary = lief.parse(<span class="hljs-string"><span class="hljs-string">"test_rpath.elf"</span></span>) rpath = next(filter(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: x.tag == lief.ELF.DYNAMIC_TAGS.RPATH, binary.dynamic_entries)) rpath.paths = [<span class="hljs-string"><span class="hljs-string">"/opt/my-lib/here"</span></span>] binary.write(<span class="hljs-string"><span class="hljs-string">"test_rpath.patched"</span></span>)</code> </pre> <br></li><li><p>  Supprimer RPATH: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief binary = lief.parse(<span class="hljs-string"><span class="hljs-string">"test_rpath.elf"</span></span>) binary.remove(lief.ELF.DYNAMIC_TAGS.RPATH) binary.write(<span class="hljs-string"><span class="hljs-string">"test_rpath.patched"</span></span>)</code> </pre> <br></li></ul><br><h2 id="obfuskaciya-simvolnoy-informacii">  Obfuscation des informations sur les personnages </h2><br><p>  Pour compliquer l'inverse de l'application, vous pouvez enregistrer des informations symboliques, mais confondre les noms des objets.  Nous utilisons l'elfe <em>crackme01_32bit</em> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">crackme01 par seveb</a> comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sujet de</a> test. </p><br><p>  Une version simplifiée d'un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">exemple</a> de la bibliothèque LIEF pourrait ressembler à ceci: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief binary = lief.parse(<span class="hljs-string"><span class="hljs-string">"crackme01_32bit"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i, symb <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(binary.static_symbols): symb.name = <span class="hljs-string"><span class="hljs-string">"zzz_%d"</span></span> % i binary.write(<span class="hljs-string"><span class="hljs-string">"crackme01_32bit.obfuscated"</span></span>)</code> </pre> <br><p>  En conséquence, nous obtenons: </p><br><pre> <code class="bash hljs">$ readelf -s crackme01_32bit.obfuscated ... Symbol table <span class="hljs-string"><span class="hljs-string">'.symtab'</span></span> contains 78 entries: Num: Value Size Type Bind Vis Ndx Name 0: 00000000 0 NOTYPE LOCAL DEFAULT UND zzz_0 1: 08048154 0 SECTION LOCAL DEFAULT 1 zzz_1 2: 08048168 0 SECTION LOCAL DEFAULT 2 zzz_2 3: 08048188 0 SECTION LOCAL DEFAULT 3 zzz_3 4: 080481ac 0 SECTION LOCAL DEFAULT 4 zzz_4 5: 080481d0 0 SECTION LOCAL DEFAULT 5 zzz_5 6: 080482b0 0 SECTION LOCAL DEFAULT 6 zzz_6 7: 0804835a 0 SECTION LOCAL DEFAULT 7 zzz_7 8: 08048378 0 SECTION LOCAL DEFAULT 8 zzz_8 9: 080483b8 0 SECTION LOCAL DEFAULT 9 zzz_9 10: 080483c8 0 SECTION LOCAL DEFAULT 10 zzz_10 ...</code> </pre> <br><h2 id="podmena-funkciy-cherez-pltgot">  Substitution de fonctions via PLT / GOT </h2><br><p>  Aussi connu comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ELF PLT INFECTION</a> . </p><br><p>  Afin de ne pas copier-coller, il suffit de laisser des liens sur le sujet: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Redirection de fonctions dans les bibliothèques ELF partagées</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Infecter le plt / got avec LIEF</a> </li></ul><br><h2 id="izmenit-tochku-vhoda">  Changer le point d'entrée </h2><br><p>  Il peut être utile lors de la création de correctifs, de l'installation de crochets et d'autres instruments dynamiques ou pour invoquer des fonctions cachées.  À titre expérimental, nous utilisons l'elfe crackme01_32bit de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">crackme01 par seveb</a> </p><br><h3 id="radare2-1">  radare2 </h3><br><p>  radare2 démarre en mode enregistrement (option <code>-w</code> ) - des modifications seront apportées au fichier d'origine: </p><br><pre> <code class="bash hljs">$ ./crackme01_32bit Please enter the secret number: ^C $ r2 -w -nn crackme01_32bit [0x00000000]&gt; .pf.elf_header.entry=0x0804860D [0x00000000]&gt; q $ ./crackme01_32bit Nope.</code> </pre> <br><h3 id="lief-8">  Lief </h3><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief binary = lief.parse(<span class="hljs-string"><span class="hljs-string">"crackme01_32bit"</span></span>) header = binary.header header.entrypoint = <span class="hljs-number"><span class="hljs-number">0x0804860D</span></span> binary.write(<span class="hljs-string"><span class="hljs-string">"crackme01_32bit.patched"</span></span>)</code> </pre> <br><h2 id="patching-koda">  Patch de code </h2><br><p>  Comme test simple, prenez le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">crackmepal du novn91 avec la fissure</a> .  Lorsqu'il est lancé sans paramètres, le programme affiche: </p><br><pre> <code class="bash hljs">$ ./crackmeMario usage &lt;password&gt;</code> </pre> <br><p>  Lorsqu'il est lancé avec un paramètre de chaîne arbitraire, il affiche: </p><br><pre> <code class="bash hljs">./crackmeMario qwerty try again pal.</code> </pre> <br><p>  Nous allons faire un patch pour que le programme affiche immédiatement au démarrage le message «bon travail!  maintenant keygen moi! " </p><br><h3 id="radare2-2">  radare2 </h3><br><p>  radare2 peut patcher tous les formats qu'il prend en charge lui-même.  Dans ce cas, il est possible de décrire les patchs au format texte: </p><br><pre> <code class="plaintext hljs"># Rapatch for https://crackmes.one/crackme/5ccecc7e33c5d4419da559b3 !echo Patching crackme 0x115D : jmp 0x1226</code> </pre> <br><p>  Vous pouvez appliquer un tel patch avec la commande: </p><br><pre> <code class="bash hljs">$ r2 -P patch.txt crackmeMario</code> </pre> <br><p>  Lisez à propos de la correction du code via radare2: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Application de correctifs binaires à l'aide de Radare2 par wolfshirtz</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Explorations Radare2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Tutoriel 1 - Patch simple</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ground Zero: Partie 3-2 - Ingénierie inverse - Patching des fichiers binaires avec Radare2 - ARM64</a> </li></ul><br><h3 id="lief-9">  Lief </h3><br><p>  LIEF vous permet de patcher l'elfe (écraser les octets) à l'adresse virtuelle spécifiée.  Le patch peut être sous la forme d'un tableau d'octets ou sous forme de valeur entière: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief binary = lief.parse(<span class="hljs-string"><span class="hljs-string">"crackmeMario"</span></span>) binary.patch_address(<span class="hljs-number"><span class="hljs-number">0x115D</span></span>, bytearray(<span class="hljs-string"><span class="hljs-string">b"\xe9\xc4\x00\x00\x00"</span></span>)) binary.write(<span class="hljs-string"><span class="hljs-string">"crackmeMario.patched"</span></span>)</code> </pre> <br><p>  Après avoir appliqué le patch, le programme affichera: </p><br><pre> <code class="bash hljs">$ ./crackmeMario.patched good job! now keygen me!</code> </pre> <br><h2 id="dobavit-sekciyu-v-elf">  Ajouter une section à ELF </h2><br><h3 id="objcopy-1">  objcopy </h3><br><p>  <em>objcopy</em> vous permet d'ajouter une section, mais cette section n'appartiendra à aucun segment et ne sera pas chargée dans la RAM au démarrage de l'application: </p><br><pre> <code class="bash hljs">$ objcopy --add-section .testme=data.zip \ --<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>-section-flags .testme=alloc,contents,load,<span class="hljs-built_in"><span class="hljs-built_in">readonly</span></span> \ --change-section-address .testme=0x08777777 \ simple simple.patched.elf</code> </pre> <br><h3 id="lief-10">  Lief </h3><br><p>  La bibliothèque LIEF vous permet d'ajouter une nouvelle section et son segment correspondant ( <strong><code>loaded=True</code></strong> flag) à un ELF existant: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief binary = lief.parse(<span class="hljs-string"><span class="hljs-string">"simple"</span></span>) data = bytearray(<span class="hljs-string"><span class="hljs-string">b"\xFF"</span></span> * <span class="hljs-number"><span class="hljs-number">16</span></span>) section = lief.ELF.Section(<span class="hljs-string"><span class="hljs-string">".testme"</span></span>, lief.ELF.SECTION_TYPES.PROGBITS) section += lief.ELF.SECTION_FLAGS.EXECINSTR section += lief.ELF.SECTION_FLAGS.ALLOC section.content = data binary.add(section, loaded=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) binary.write(<span class="hljs-string"><span class="hljs-string">"simple.testme.lief"</span></span>)</code> </pre> <br><h2 id="izmenit-sekciyu">  Changer de section </h2><br><h3 id="objcopy-2">  objcopy </h3><br><p>  <em>objcopy vous</em> permet de remplacer le contenu d'une section par des données d'un fichier, ainsi que de changer l'adresse virtuelle d'une section et des indicateurs: </p><br><pre> <code class="bash hljs">$ objcopy --update-section .testme=patch.bin \ --change-section-address .testme=0x08999999 simple simple.testme.elf</code> </pre> <br><h3 id="lief-11">  Lief </h3><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief binary = lief.parse(<span class="hljs-string"><span class="hljs-string">"simple"</span></span>) data = bytearray(<span class="hljs-string"><span class="hljs-string">b"\xFF"</span></span> * <span class="hljs-number"><span class="hljs-number">17</span></span>) section = binary.get_section(<span class="hljs-string"><span class="hljs-string">".text"</span></span>) section.content = data binary.write(<span class="hljs-string"><span class="hljs-string">"simple.patched"</span></span>)</code> </pre> <br><h2 id="udalit-sekciyu">  Supprimer la section </h2><br><h3 id="objcopy-3">  objcopy </h3><br><p>  <em>objcopy vous</em> permet de supprimer une section spécifique par son nom: </p><br><pre> <code class="bash hljs">$ objcopy --remove-section .testme simple.testme.elf simple.no_testme.elf</code> </pre> <br><h3 id="lief-12">  Lief </h3><br><p>  La suppression d'une section à l'aide de la bibliothèque LIEF ressemble à ceci: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief binary = lief.parse(<span class="hljs-string"><span class="hljs-string">"simple.testme.elf"</span></span>) binary.remove_section(<span class="hljs-string"><span class="hljs-string">".testme"</span></span>) binary.write(<span class="hljs-string"><span class="hljs-string">"simple.no_testme"</span></span>)</code> </pre> <br><h2 id="elf-konteyner">  Conteneur d'elfe </h2><br><p>  La recette est inspirée de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Gremlins et de la magie ELF: que faire si le fichier ELF est un conteneur?</a>  .  Il existe également des informations sur l'utilitaire elfwrap originaire de Solaris, qui vous permet de créer un fichier ELF à partir de données arbitraires, et le format ELF est utilisé simplement comme conteneur. </p><br><p>  Essayons de faire de même en Python et LIEF. <br>  Malheureusement, pour le moment, la bibliothèque LIEF n'est pas en mesure de créer un fichier elf à partir de zéro, vous devez donc l'aider - créez un modèle ELF vide: </p><br><pre> <code class="bash hljs">$ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span> | gcc -m32 -fpic -o empty.o -c -xc - $ gcc -m32 -shared -o libempty.so empty.o</code> </pre> <br><p>  Vous pouvez maintenant utiliser ce modèle pour remplir les données: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief binary = lief.parse(<span class="hljs-string"><span class="hljs-string">"libempty.so"</span></span>) filename = <span class="hljs-string"><span class="hljs-string">"crackme.zip"</span></span> data = open(filename, <span class="hljs-string"><span class="hljs-string">'rb'</span></span>).read() <span class="hljs-comment"><span class="hljs-comment"># Add section with zip-archive as content section = lief.ELF.Section() section.content = data section.name = ".%s"%filename binary.add(section, loaded=True) # Add symbol as a reference to zip-archive symb = lief.ELF.Symbol() symb.type = lief.ELF.SYMBOL_TYPES.OBJECT symb.binding = lief.ELF.SYMBOL_BINDINGS.GLOBAL symb.size = len(data) symb.name = filename symb.value = section.virtual_address binary.add_static_symbol(symb) binary.write("libdata.crackme.container")</span></span></code> </pre> <br><h2 id="elf-s-pricepom">  Elfe "avec une remorque" </h2><br><p>  Le format ELF n'impose pas de restrictions sur les données contenues dans le fichier, mais n'appartient à aucun segment.  Ainsi, il est possible de créer un fichier exécutable, qui sera stocké après la structure ELF.  C'est <em>quelque chose qui</em> ne sera pas chargé dans la RAM au moment de l'exécution, mais il sera écrit sur le disque et à tout moment, il pourra être lu à partir du disque. </p><br><ul><li>  <em>IDA Pro ne tiendra pas compte de ces données lors de l'analyse</em> </li></ul><br><p>  <em>Exemple de structure de fichier avec une bande-annonce</em> <br><img src="https://habrastorage.org/webt/rr/br/sk/rrbrsktjs_p8l7fmdfq7t4mejns.jpeg" alt="image"></p><br><h3 id="radare2-3">  radare2 </h3><br><p>  La présence d'une «bande-annonce» peut être établie en comparant les tailles de fichier réelles et calculées: </p><br><pre> <code class="bash hljs">$ radare2 test.elf [0x00001040]&gt; ?v <span class="hljs-variable"><span class="hljs-variable">$s</span></span> 0x40c1 [0x00001040]&gt; iZ 14699</code> </pre> <br><h3 id="readelf-3">  lire </h3><br><p>  <em>readelf n'affiche</em> pas d'informations sur la présence d'une "bande-annonce", mais peut être calculé manuellement: </p><br><pre> <code class="bash hljs">$ ls -l test.elf <span class="hljs-comment"><span class="hljs-comment">#   16577  $ readelf -h test.elf Start of section headers e_shoff 14704 Size of section headers e_shentsize 64 Number of section headers e_shnum 29 #  ELF-: e_shoff + ( e_shentsize * e_shnum ) = 16560</span></span></code> </pre> <br><h3 id="lief-13">  Lief </h3><br><p>  La bibliothèque LIEF vous permet à la fois de vérifier la présence d'une «bande-annonce» et de l'ajouter.  En utilisant LIEF, tout semble assez succinct: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lief binary = lief.parse(<span class="hljs-string"><span class="hljs-string">"test"</span></span>) <span class="hljs-comment"><span class="hljs-comment"># check if overlay exists print('ELF has overlay data') if binary.has_overlay else print("No overlay data") # add overlay data to ELF data = bytearray(b'\xFF'*17) binary.overlay = data binary.write('test.overlay')</span></span></code> </pre> <br><h2 id="elf-iz-pustoty-elf-from-scratch">  Elfe vide (ELF à partir de zéro) </h2><br><p>  Sur Internet, vous pouvez trouver des projets pour créer un fichier ELF «manuellement» - sans utiliser un compilateur et un éditeur de liens sous le nom général «ELF from scratch»: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Projet Github</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Elfe à partir de zéro</a> article </li><li>  Branche <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Elf_from_scratch</a> dans le référentiel de bibliothèque LIEF </li></ul><br><p>  La familiarité avec ces projets a un effet bénéfique sur l'absorption du format ELF. </p><br><h2 id="samyy-malenkiy-elf">  Le plus petit elfe </h2><br><p>  Des expériences intéressantes pour minimiser la taille de l'elfe sont décrites dans les articles: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Un tutoriel de tourbillon sur la création d'exécutables ELF vraiment Teensy pour Linux</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Un tutoriel tourbillonnant sur la création d'exécutables ELF quelque peu adolescents pour Linux</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Programme minimaliste au format ELF</a> </li></ul><br><p>  En bref, le chargeur elf dans le système d'exploitation n'utilise pas tous les champs d'en-tête et les tables de segments, et un code exécutable minimal peut être placé directement dans la structure d'en-tête ELF (le code est tiré du premier article): </p><br><pre> <code class="plaintext hljs">; tiny.asm BITS 32 org 0x00010000 db 0x7F, "ELF" ; e_ident dd 1 ; p_type dd 0 ; p_offset dd $$ ; p_vaddr dw 2 ; e_type ; p_paddr dw 3 ; e_machine dd _start ; e_version ; p_filesz dd _start ; e_entry ; p_memsz dd 4 ; e_phoff ; p_flags _start: mov bl, 42 ; e_shoff ; p_align xor eax, eax inc eax ; e_flags int 0x80 db 0 dw 0x34 ; e_ehsize dw 0x20 ; e_phentsize db 1 ; e_phnum ; e_shentsize ; e_shnum ; e_shstrndx filesize equ $ - $$</code> </pre> <br><p>  Assemblez et obtenez un ELF de taille ... <strong>45 octets</strong> : </p><br><pre> <code class="bash hljs"> $ nasm -f bin -o a.out tiny.asm $ chmod +x a.out $ ./a.out ; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> $? 42 $ wc -c a.out 45 a.out</code> </pre> <br><h2 id="elf-po-shablonu">  Motif elfe </h2><br><p>  Pour créer un elfe à l'aide de la bibliothèque LIEF, vous pouvez suivre les étapes suivantes (voir la recette "Elf-container"): </p><br><ul><li>  prendre un simple fichier ELF comme modèle; </li><li>  remplacer le contenu des sections, ajouter de nouvelles sections; </li><li>  configurer les paramètres nécessaires (point d'entrée, drapeaux). </li></ul><br><h1 id="vmesto-zaklyucheniya">  Au lieu d'une conclusion </h1><br><p>  Ajoutant à l'article, nous avons constaté qu'il s'est avéré être quelque chose comme une ode à la bibliothèque LIEF.  Mais ce n'était pas prévu - je voulais montrer comment travailler avec des fichiers ELF en utilisant différents outils. </p><br><p>  Il y a sûrement ou besoin de scripts qui n'ont pas été mentionnés ici - écrivez à ce sujet dans les commentaires. </p><br><h1 id="ssylki-i-literatura">  Références et littérature </h1><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Spécification du format ELF</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Une autre spécification de format dans la bibliothèque Oracle</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Utilisation des ELF à l'aide de radare2</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Documentation de la bibliothèque du LIEF</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Exemples de bibliothèques LIEF</a> </li><li>  Livre "ANALYSE BINAIRE PRATIQUE", Dennis Andriesse </li><li>  Apprendre l'analyse binaire Linux, par Ryan "elfmaster" O'Neill </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr460247/">https://habr.com/ru/post/fr460247/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr460231/index.html">OpenGear - Réduisez les temps d'arrêt de votre entreprise à l'aide d'un serveur de console avec une gestion hors bande</a></li>
<li><a href="../fr460233/index.html">Le jeu Cities: Skylines s'est avéré être Turing-complet: nous créons un additionneur 4 bits</a></li>
<li><a href="../fr460237/index.html">Escrocs eBay (une histoire de triche)</a></li>
<li><a href="../fr460239/index.html">Comment obtenir le pare-feu NextGen chez vous absolument gratuitement</a></li>
<li><a href="../fr460241/index.html">Enfer ou marée haute: histoire de la littérature scientifique populaire russe</a></li>
<li><a href="../fr460249/index.html">Solution de la tâche avec pwnable.kr 07 - entrée. Comprendre pwntools</a></li>
<li><a href="../fr460251/index.html">Stupidité artificielle: un bot qui ne m'a pas aidé</a></li>
<li><a href="../fr460253/index.html">10 raisons de faire vos compétences d'assistant vocal</a></li>
<li><a href="../fr460255/index.html">Backdoor sur Node.js: pourquoi, pourquoi et comment cela fonctionne</a></li>
<li><a href="../fr460257/index.html">Bonjour tout le monde! Immersion profonde dans les terminaux</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>