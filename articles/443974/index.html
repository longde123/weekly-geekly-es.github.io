<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèΩ‚Äç‚öñÔ∏è üññüèΩ ü§û Memoria y Span pt. 1 üëµüèø üë©‚Äç‚ù§Ô∏è‚Äçüíã‚Äçüë© üè®</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A partir de .NET Core 2.0 y .NET Framework 4.5 podemos usar nuevos tipos de datos: Span y Memory . Para usarlos, solo necesita instalar el paquete Sys...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Memoria y Span pt. 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/clrium/blog/443974/"><p><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img width="350" align="left" src="https://habrastorage.org/webt/vh/7j/tq/vh7jtqhzbne4h3rjhprca2pruhu.png"></a>  A partir de .NET Core 2.0 y .NET Framework 4.5 podemos usar nuevos tipos de datos: <code>Span</code> y <code>Memory</code> .  Para usarlos, solo necesita instalar el paquete <code>System.Memory</code> nuget: </p><br><blockquote> <code>PM&gt; Install-Package System.Memory</code> </blockquote> <p>  Estos tipos de datos son notables porque el equipo de CLR ha hecho un gran trabajo para implementar su soporte especial dentro del c√≥digo del compilador JIT .NET Core 2.1+ incorporando estos tipos de datos directamente en el n√∫cleo.  ¬øQu√© tipo de datos son estos y por qu√© valen un cap√≠tulo entero? </p><br><p>  Si hablamos de problemas que hicieron aparecer estos tipos, deber√≠a nombrar tres de ellos.  El primero es el c√≥digo no administrado. </p><br><p>  Tanto el lenguaje como la plataforma han existido durante muchos a√±os junto con los medios para trabajar con c√≥digo no administrado.  Entonces, ¬øpor qu√© lanzar otra API para trabajar con c√≥digo no administrado si la primera existi√≥ b√°sicamente durante muchos a√±os?  Para responder a esta pregunta, debemos entender lo que nos faltaba antes. </p><br><blockquote><img src="https://habrastorage.org/webt/tu/qf/aq/tuqfaqcncvjtdmb_uxgcbbzyr9o.png" align="left">  Este cap√≠tulo fue traducido del ruso conjuntamente por el autor y por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">traductores profesionales</a> .  Puede ayudarnos con la traducci√≥n del ruso o el ingl√©s a cualquier otro idioma, principalmente al chino o al alem√°n. <br><br>  Adem√°s, si quieres agradecernos, la mejor manera de hacerlo es darnos una estrella en Github o bifurcar el repositorio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/5n/wo/6u/5nwo6uvyk2eafkzdd0cdofjqm-0.png" width="22"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">github / sidristij / dotnetbook</a> . <br></blockquote><a name="habracut"></a><br><p>  Los desarrolladores de la plataforma ya intentaron facilitarnos el uso de recursos no administrados.  Implementaron envoltorios autom√°ticos para m√©todos importados y c√°lculo de referencias que funciona autom√°ticamente en la mayor√≠a de los casos.  Aqu√≠ tambi√©n pertenece a <code>stackalloc</code> , mencionado en el cap√≠tulo sobre una pila de hilos.  Sin embargo, como lo veo, los primeros desarrolladores de C # vinieron del mundo C ++ (mi caso), pero ahora cambian de lenguajes de m√°s alto nivel (conozco un desarrollador que escribi√≥ antes en JavaScript).  Esto significa que las personas se vuelven m√°s sospechosas al c√≥digo no administrado y las construcciones C / C +, tanto m√°s a Assembler. </p><br><p>  Como resultado, los proyectos contienen cada vez menos c√≥digo inseguro y la confianza en la API de la plataforma crece cada vez m√°s.  Esto es f√°cil de verificar si buscamos casos de uso de <code>stackalloc</code> en repositorios p√∫blicos; son escasos.  Sin embargo, tomemos cualquier c√≥digo que lo use: </p><br><p>  <strong>Clase Interop.ReadDir</strong> <br>  <a href="">/src/mscorlib/shared/Interop/Unix/System.Native/Interop.ReadDir.cs</a> </p><br><pre> <code class="plaintext hljs">unsafe { // s_readBufferSize is zero when the native implementation does not support reading into a buffer. byte* buffer = stackalloc byte[s_readBufferSize]; InternalDirectoryEntry temp; int ret = ReadDirR(dir.DangerousGetHandle(), buffer, s_readBufferSize, out temp); // We copy data into DirectoryEntry to ensure there are no dangling references. outputEntry = ret == 0 ? new DirectoryEntry() { InodeName = GetDirectoryEntryName(temp), InodeType = temp.InodeType } : default(DirectoryEntry); return ret; }</code> </pre> <br><p>  Podemos ver por qu√© no es popular.  Simplemente lea este c√≥digo y preg√∫ntese si conf√≠a en √©l.  Supongo que la respuesta es 'No'.  Entonces, preg√∫ntate por qu√©.  Es obvio: no solo vemos la palabra <code>Dangerous</code> , que sugiere que algo puede salir mal, sino que existe la palabra clave <code>unsafe</code> y el <code>byte* buffer = stackalloc byte[s_readBufferSize];</code>  l√≠nea (espec√≠ficamente - <code>byte*</code> ) que cambia nuestra actitud.  Este es un detonante para que pienses: "¬øNo hab√≠a otra forma de hacerlo"?  Entonces, profundicemos en el psicoan√°lisis: ¬øpor qu√© podr√≠a pensar de esa manera?  Por un lado, usamos construcciones de lenguaje y la sintaxis ofrecida aqu√≠ est√° lejos de, por ejemplo, C ++ / CLI, que permite cualquier cosa (incluso insertar c√≥digo de ensamblador puro).  Por otro lado, esta sintaxis parece inusual. </p><br><p>  El segundo problema que los desarrolladores pensaron impl√≠cita o expl√≠citamente es la incompatibilidad de los tipos string y char [].  Aunque, l√≥gicamente, una cadena es una matriz de caracteres, pero no puede convertir una cadena a char []: solo puede crear un nuevo objeto y copiar el contenido de una cadena a una matriz.  Esta incompatibilidad se introduce para optimizar las cadenas en t√©rminos de almacenamiento (no hay matrices de solo lectura).  Sin embargo, los problemas aparecen cuando comienza a trabajar con archivos.  ¬øC√≥mo leerlos?  Como una cadena o como una matriz?  Si elige una matriz, no puede usar algunos m√©todos dise√±ados para trabajar con cadenas.  ¬øQu√© hay de leer como una cuerda?  Puede ser muy largo  Si necesita analizarlo entonces, qu√© analizador deber√≠a elegir para los tipos de datos primitivos: no siempre desea analizarlos manualmente (enteros, flotantes, dados en diferentes formatos).  Tenemos muchos algoritmos probados que lo hacen de manera m√°s r√°pida y eficiente, ¬øno?  Sin embargo, tales algoritmos a menudo funcionan con cadenas que no contienen nada m√°s que un tipo primitivo.  Entonces, hay un dilema. </p><br><p>  El tercer problema es que los datos requeridos por un algoritmo rara vez forman un segmento de datos continuo y s√≥lido dentro de una secci√≥n de una matriz le√≠da de alguna fuente.  Por ejemplo, en el caso de archivos o datos le√≠dos de un socket, tenemos una parte de los que ya fueron procesados ‚Äã‚Äãpor un algoritmo, seguidos de una parte de los datos que deben ser procesados ‚Äã‚Äãpor nuestro m√©todo, y luego por datos a√∫n no procesados.  Idealmente, nuestro m√©todo solo desea los datos para los que se dise√±√≥ este m√©todo.  Por ejemplo, un m√©todo que analiza enteros no estar√° contento con una cadena que contenga algunas palabras con un n√∫mero esperado en alg√∫n lugar entre ellas.  Este m√©todo quiere un n√∫mero y nada m√°s.  O, si pasamos una matriz completa, hay un requisito para indicar, por ejemplo, el desplazamiento de un n√∫mero desde el comienzo de la matriz. </p><br><pre> <code class="plaintext hljs">int ParseInt(char[] input, int index) { while(char.IsDigit(input[index])) { // ... index++; } }</code> </pre> <br><p>  Sin embargo, este enfoque es pobre, ya que este m√©todo obtiene datos innecesarios.  En otras palabras, <em>el m√©todo se llama para contextos para los que no fue dise√±ado</em> y tiene que resolver algunas tareas externas.  Este es un mal dise√±o.  ¬øC√≥mo evitar estos problemas?  Como opci√≥n, podemos usar el tipo <code>ArraySegment&lt;T&gt;</code> que puede dar acceso a una secci√≥n de una matriz: </p><br><pre> <code class="plaintext hljs">int ParseInt(IList&lt;char&gt;[] input) { while(char.IsDigit(input.Array[index])) { // ... index++; } } var arraySegment = new ArraySegment(array, from, length); var res = ParseInt((IList&lt;char&gt;)arraySegment);</code> </pre> <br><p>  Sin embargo, creo que esto es demasiado tanto en t√©rminos de l√≥gica como de disminuci√≥n en el rendimiento.  <code>ArraySegment</code> est√° mal dise√±ado y ralentiza el acceso a los elementos 7 veces m√°s en comparaci√≥n con las mismas operaciones realizadas con una matriz. </p><br><p>  Entonces, ¬øc√≥mo resolvemos estos problemas?  ¬øC√≥mo hacemos que los desarrolladores vuelvan a usar c√≥digo no administrado y les demos una herramienta unificada y r√°pida para trabajar con fuentes de datos heterog√©neas: matrices, cadenas y memoria no administrada?  Era necesario darles una sensaci√≥n de confianza de que no pueden cometer un error sin saberlo.  Fue necesario proporcionarles un instrumento que no disminuya los tipos de datos nativos en t√©rminos de rendimiento, pero que resuelva los problemas enumerados.  <code>Span&lt;T&gt;</code> tipos <code>Span&lt;T&gt;</code> y <code>Memory&lt;T&gt;</code> son exactamente estos instrumentos. </p><br><h2 id="spanlttgt-readonlyspanlttgt">  Span &lt;T&gt;, ReadOnlySpan &lt;T&gt; </h2><br><p>  <code>Span</code> tipo de <code>Span</code> es un instrumento para trabajar con datos dentro de una secci√≥n de una matriz de datos o con un subrango de sus valores.  Como en el caso de una matriz, permite leer y escribir en los elementos de este subrango, pero con una restricci√≥n importante: obtienes o creas un <code>Span&lt;T&gt;</code> solo para un trabajo <em>temporal</em> con una matriz, solo para llamar a un grupo de m√©todos .  Sin embargo, para obtener una comprensi√≥n general, comparemos los tipos de datos para los que est√° dise√±ado <code>Span</code> y veamos sus posibles escenarios de uso. </p><br><p>  El primer tipo de datos es una matriz habitual.  Las matrices funcionan con <code>Span</code> de la siguiente manera: </p><br><pre> <code class="plaintext hljs"> var array = new [] {1,2,3,4,5,6}; var span = new Span&lt;int&gt;(array, 1, 3); var position = span.BinarySearch(3); Console.WriteLine(span[position]); // -&gt; 3</code> </pre> <br><p>  Al principio, creamos una matriz de datos, como se muestra en este ejemplo.  A continuaci√≥n, creamos <code>Span</code> (o un subconjunto) que hace referencia a la matriz y hace que un rango de valores inicializados previamente sea accesible para el c√≥digo que usa la matriz. </p><br><p>  Aqu√≠ vemos la primera caracter√≠stica de este tipo de datos, es decir, la capacidad de crear un determinado contexto.  Expandamos nuestra idea de contextos: </p><br><pre> <code class="plaintext hljs">void Main() { var array = new [] {'1','2','3','4','5','6'}; var span = new Span&lt;char&gt;(array, 1, 3); if(TryParseInt32(span, out var res)) { Console.WriteLine(res); } else { Console.WriteLine("Failed to parse"); } } public bool TryParseInt32(Span&lt;char&gt; input, out int result) { result = 0; for (int i = 0; i &lt; input.Length; i++) { if(input[i] &lt; '0' || input[i] &gt; '9') return false; result = result * 10 + ((int)input[i] - '0'); } return true; } ----- 234</code> </pre> <br><p>  Como vemos, <code>Span&lt;T&gt;</code> proporciona acceso abstracto a un rango de memoria tanto para lectura como para escritura.  Que nos da  Si recordamos para qu√© m√°s podemos usar <code>Span</code> , pensaremos en recursos y cadenas no administrados: </p><br><pre> <code class="plaintext hljs">// Managed array var array = new[] { '1', '2', '3', '4', '5', '6' }; var arrSpan = new Span&lt;char&gt;(array, 1, 3); if (TryParseInt32(arrSpan, out var res1)) { Console.WriteLine(res1); } // String var srcString = "123456"; var strSpan = srcString.AsSpan(); if (TryParseInt32(strSpan, out var res2)) { Console.WriteLine(res2); } // void * Span&lt;char&gt; buf = stackalloc char[6]; buf[0] = '1'; buf[1] = '2'; buf[2] = '3'; buf[3] = '4'; buf[4] = '5'; buf[5] = '6'; if (TryParseInt32(buf, out var res3)) { Console.WriteLine(res3); } ----- 234 234 234</code> </pre> <br><p>  Eso significa que <code>Span&lt;T&gt;</code> es una herramienta para unificar formas de trabajar con memoria, tanto administrada como no administrada.  Garantiza la seguridad mientras se trabaja con dichos datos durante la recolecci√≥n de basura.  Es decir, si los rangos de memoria con recursos no administrados comienzan a moverse, ser√° seguro. </p><br><p>  Sin embargo, ¬ødeber√≠amos estar tan emocionados?  ¬øPodr√≠amos lograr esto antes?  Por ejemplo, en el caso de las matrices administradas, no hay duda al respecto: solo necesita envolver una matriz en una clase m√°s (por ejemplo, [ArraySegment] existente ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://referencesource.microsoft.com/#mscorlib/system/ arraysegment.cs, 31</a> )) dando una interfaz similar y eso es todo.  Adem√°s, puede hacer lo mismo con las cadenas: tienen los m√©todos necesarios.  Nuevamente, solo necesita envolver una cadena del mismo tipo y proporcionar m√©todos para trabajar con ella.  Sin embargo, para almacenar una cadena, un b√∫fer y una matriz en un tipo, tendr√° mucho que ver con mantener referencias a cada variante posible en una sola instancia (con una sola variante activa, obviamente). </p><br><pre> <code class="plaintext hljs">public readonly ref struct OurSpan&lt;T&gt; { private T[] _array; private string _str; private T * _buffer; // ... }</code> </pre> <br><p>  O, seg√∫n la arquitectura, puede crear tres tipos que implementen una interfaz uniforme.  Por lo tanto, no es posible crear una interfaz uniforme entre estos tipos de datos que sea diferente de <code>Span&lt;T&gt;</code> y mantener el m√°ximo rendimiento. </p><br><p>  A continuaci√≥n, hay una pregunta de qu√© es la <code>ref struct</code> con respecto a <code>Span</code> .  Estas son exactamente esas "estructuras que existen solo en la pila" de las que escuchamos durante las entrevistas de trabajo con tanta frecuencia.  Significa que este tipo de datos puede asignarse solo en la pila y no puede ir al mont√≥n.  Es por esto que <code>Span</code> , que es una estructura de referencia, es un tipo de datos de contexto que permite el trabajo de m√©todos pero no el de objetos en la memoria.  En eso es en lo que debemos basarnos cuando tratamos de entenderlo. </p><br><p>  Ahora podemos definir el tipo <code>Span</code> y el tipo <code>ReadOnlySpan</code> relacionado: </p><br><blockquote>  Span es un tipo de datos que implementa una interfaz uniforme para trabajar con tipos heterog√©neos de matrices de datos y permite pasar un subconjunto de una matriz a un m√©todo para que la velocidad de acceso a la matriz original sea constante y m√°xima independientemente de la profundidad de la matriz. contexto. </blockquote><p>  De hecho, si tenemos un c√≥digo como </p><br><pre> <code class="plaintext hljs">public void Method1(Span&lt;byte&gt; buffer) { buffer[0] = 0; Method2(buffer.Slice(1,2)); } Method2(Span&lt;byte&gt; buffer) { buffer[0] = 0; Method3(buffer.Slice(1,1)); } Method3(Span&lt;byte&gt; buffer) { buffer[0] = 0; }</code> </pre> <br><p>  la velocidad de acceso al b√∫fer original ser√° la m√°s alta a medida que trabaje con un puntero administrado y no con un objeto administrado.  Eso significa que trabaja con un tipo inseguro en un contenedor administrado, pero no con un tipo administrado .NET. </p><br><blockquote><img src="https://habrastorage.org/webt/tu/qf/aq/tuqfaqcncvjtdmb_uxgcbbzyr9o.png" align="left">  Este cap√≠tulo fue traducido del ruso conjuntamente por el autor y por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">traductores profesionales</a> .  Puede ayudarnos con la traducci√≥n del ruso o el ingl√©s a cualquier otro idioma, principalmente al chino o al alem√°n. <br><br>  Adem√°s, si quieres agradecernos, la mejor manera de hacerlo es darnos una estrella en Github o bifurcar el repositorio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/5n/wo/6u/5nwo6uvyk2eafkzdd0cdofjqm-0.png" width="22"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">github / sidristij / dotnetbook</a> . <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/443974/">https://habr.com/ru/post/443974/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../443962/index.html">Patr√≥n desechable (Principio de dise√±o desechable) pt.3</a></li>
<li><a href="../443964/index.html">Kolesa Conf es la mayor conferencia de TI en Kazajst√°n. Anuncio de informes</a></li>
<li><a href="../443966/index.html">Google Docs: un chat favorito entre los estudiantes</a></li>
<li><a href="../443968/index.html">C√≥mo compramos una casa con paneles solares, y qu√© sali√≥ de ella</a></li>
<li><a href="../443972/index.html">Yandex buscar√° piratas usando un robot</a></li>
<li><a href="../443976/index.html">Memoria y Span pt.2</a></li>
<li><a href="../443978/index.html">ATtiny13 vs PLC, o c√≥mo obtener 14 E / S de un controlador de 8 pies</a></li>
<li><a href="../443980/index.html">Memoria y Span pt.3</a></li>
<li><a href="../443984/index.html">El nuevo est√°ndar basado en PCIe 5.0 "conectar√°" la CPU y la GPU, lo que se sabe al respecto</a></li>
<li><a href="../443986/index.html">Como una ardilla en una rueda o un poco sobre investigaci√≥n de usuarios en un entorno de discapacidad</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>