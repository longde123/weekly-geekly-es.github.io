<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéöÔ∏è üë©üèæ‚Äçü§ù‚Äçüë®üèø ‚èèÔ∏è Ports de finalisation epoll et Windows IO: la diff√©rence pratique ü•ã üë©üèΩ‚Äçü§ù‚Äçüë®üèø üï¢</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pr√©sentation 
 Dans cet article, nous allons essayer de comprendre en quoi le m√©canisme epoll diff√®re des ports d'ach√®vement dans la pratique (Windows...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ports de finalisation epoll et Windows IO: la diff√©rence pratique</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/infopulse/blog/415403/"><h3>  Pr√©sentation </h3><br>  Dans cet article, nous allons essayer de comprendre en quoi le m√©canisme epoll diff√®re des ports d'ach√®vement dans la pratique (Windows I / O Completion Port ou IOCP).  Cela peut √™tre int√©ressant pour les architectes syst√®me qui con√ßoivent des services r√©seau hautes performances ou pour les programmeurs qui portent du code r√©seau de Windows vers Linux ou vice versa. <br><br>  Ces deux technologies sont tr√®s efficaces pour g√©rer un grand nombre de connexions r√©seau. <br><br>  Ils diff√®rent des autres m√©thodes sur les points suivants: <br><br><ul><li>  Il n'y a aucune restriction (sauf pour les ressources syst√®me totales) sur le nombre total de descripteurs et de types d'√©v√©nements observ√©s </li><li>  La mise √† l'√©chelle fonctionne plut√¥t bien - si vous surveillez d√©j√† N descripteurs, le passage √† la surveillance N + 1 prendra tr√®s peu de temps et de ressources </li><li>  Il est assez facile d'utiliser un pool de threads pour traiter des √©v√©nements en parall√®le </li><li>  Il est inutile d'utiliser des connexions r√©seau uniques.  Tous les avantages commencent √† appara√Ætre avec plus de 1000 connexions </li></ul><br>  Pour paraphraser tout ce qui pr√©c√®de, ces deux technologies sont con√ßues pour d√©velopper des services r√©seau qui traitent de nombreuses connexions entrantes des clients.  Mais en m√™me temps, il y a une diff√©rence significative entre eux et lors du d√©veloppement des m√™mes services, il est important de le conna√Ætre. <br><br>  (Mise √† jour: cet article est une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">traduction</a> ) <br><br><a name="habracut"></a><br><h3>  Type de notifications </h3><br>  La premi√®re et la plus importante diff√©rence entre epoll et IOCP est la fa√ßon dont vous √™tes inform√© d'un √©v√©nement. <br><br><ul><li>  epoll vous indique quand le descripteur est pr√™t √† pouvoir faire quelque chose avec lui - " <b>maintenant vous pouvez commencer √† lire les donn√©es</b> " </li><li>  IOCP vous indique quand l'op√©ration demand√©e est termin√©e - " <b>vous avez demand√© √† lire les donn√©es et ici elles sont lues</b> " </li></ul><br>  Lors de l'utilisation de l'application epoll: <br><br><ul><li>  D√©cide quelle op√©ration il souhaite effectuer avec un certain descripteur (lecture, √©criture ou les deux) </li><li>  D√©finit le masque appropri√© √† l'aide d'epoll_ctl </li><li>  Appelle epoll_wait, qui bloque le thread actuel jusqu'√† ce qu'au moins un √©v√©nement attendu se produise (ou que le d√©lai expire) </li><li>  It√®re sur les √©v√©nements re√ßus, prend un pointeur sur le contexte (depuis le champ data.ptr) </li><li>  Lance le traitement des √©v√©nements en fonction de leur type (lecture, √©criture ou les deux op√©rations) </li><li>  Une fois l'op√©ration termin√©e (ce qui doit se produire imm√©diatement), elle continue d'attendre la r√©ception / l'envoi des donn√©es </li></ul><br>  Lors de l'utilisation de l'application IOCP: <br><br><ul><li>  Lance une op√©ration (ReadFile ou WriteFile) pour un descripteur, en utilisant l'argument OVERLAPPED non vide.  Le syst√®me d'exploitation ajoute l'exigence d'effectuer cette op√©ration √† lui-m√™me dans la file d'attente, et la fonction appel√©e imm√©diatement (sans attendre la fin de l'op√©ration) revient. </li><li>  Appelle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GetQueuedCompletionStatus ()</a> , qui bloque le thread actuel jusqu'√† ce qu'une des requ√™tes pr√©c√©demment ajout√©es se termine.  Si plusieurs sont termin√©s, un seul d'entre eux sera s√©lectionn√©. </li><li>  Il traite la notification re√ßue de la fin de l'op√©ration en utilisant la cl√© de fin et un pointeur sur OVERLAPPED. </li><li>  Continue d'attendre la r√©ception / l'envoi des donn√©es </li></ul><br>  La diff√©rence dans le type de notifications permet (et assez trivial) d'√©muler IOCP en utilisant epoll.  Par exemple, le projet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Wine</a> fait exactement cela.  Cependant, faire le contraire n'est pas si simple.  M√™me si vous r√©ussissez, cela entra√Ænera probablement une perte de performances. <br><br><h3>  Disponibilit√© des donn√©es </h3><br>  Si vous pr√©voyez de lire des donn√©es, votre code devrait avoir une sorte de tampon o√π vous pr√©voyez de les lire.  Si vous pr√©voyez d'envoyer des donn√©es, il devrait y avoir un tampon avec des donn√©es pr√™tes √† √™tre envoy√©es. <br><br><ul><li>  epoll ne s'inqui√®te pas du tout de la pr√©sence de ces tampons et ne les utilise en aucune fa√ßon </li><li>  IOCP ces tampons sont n√©cessaires.  L'int√©r√™t de l'utilisation d'IOCP est le travail dans le style de "me lire 256 octets de cette socket dans ce tampon".  Nous avons form√© une telle demande, l'avons remise √† l'OS, nous attendons la notification de la fin de l'op√©ration (et ne touchez pas au tampon pour le moment!) </li></ul><br>  Un service r√©seau typique fonctionne avec des objets de connexion, qui comprendront des descripteurs et des tampons associ√©s pour lire / √©crire des donn√©es.  En r√®gle g√©n√©rale, ces objets sont d√©truits lorsque le socket correspondant est ferm√©.  Et cela impose certaines limitations lors de l'utilisation d'IOCP. <br><br>  IOCP fonctionne en ajoutant √† la file d'attente des demandes de lecture et d'√©criture de donn√©es, ces demandes sont ex√©cut√©es dans l'ordre de la file d'attente (c'est-√†-dire un peu plus tard).  Dans les deux cas, les tampons transf√©r√©s doivent continuer d'exister jusqu'√† la fin des op√©rations requises.  De plus, on ne peut m√™me pas modifier les donn√©es de ces tampons en attendant.  Cela impose des limitations importantes: <br><br><ul><li>  Vous ne pouvez pas utiliser de variables locales (plac√©es sur la pile) comme tampon.  Le tampon doit √™tre valid√© avant la fin de l'op√©ration de lecture / √©criture et la pile est d√©truite lorsque la fonction actuelle se termine </li><li>  Vous ne pouvez pas r√©affecter le tampon √† la vol√©e (par exemple, il s'est av√©r√© que vous devez envoyer plus de donn√©es et que vous souhaitez augmenter le tampon).  Vous ne pouvez cr√©er qu'un nouveau tampon et une nouvelle demande d'envoi </li><li>  Si vous √©crivez quelque chose comme un proxy, lorsque les m√™mes donn√©es seront lues et envoy√©es, vous devrez utiliser deux tampons distincts pour elles.  Vous ne pouvez pas demander au syst√®me d'exploitation de lire les donn√©es dans un tampon dans une demande, et dans une autre demande, envoyez ces donn√©es directement </li><li>  Vous devez r√©fl√©chir soigneusement √† la fa√ßon dont votre classe de gestionnaire de connexions d√©truira chaque connexion particuli√®re.  Vous devez avoir une garantie compl√®te qu'au moment de la destruction de la connexion, il n'y a pas une seule demande de lecture / √©criture de donn√©es √† l'aide des tampons de cette connexion </li></ul><br>  Les op√©rations IOCP n√©cessitent √©galement de passer un pointeur vers une structure OVERLAPPED, qui doit √©galement continuer d'exister (et ne pas √™tre r√©utilis√©e) jusqu'√† la fin de l'op√©ration attendue.  Cela signifie que si vous devez lire et √©crire des donn√©es en m√™me temps, vous ne pouvez pas h√©riter de la structure OVERLAPPED (une id√©e qui vient souvent √† l'esprit).  Au lieu de cela, vous devez stocker les deux structures OVERLAPPED dans votre propre classe distincte, en passant l'une d'elles dans des demandes de lecture et l'autre dans des demandes d'√©criture. <br><br>  epoll n'utilise pas de tampons qui lui sont pass√©s depuis le code utilisateur, donc tous ces probl√®mes n'y sont pour rien. <br><br><h3>  Changer les conditions d'attente </h3><br>  L'ajout d'un nouveau type d'√©v√©nements attendus (par exemple, nous attendions l'occasion de lire les donn√©es du socket, et maintenant nous voulions √©galement pouvoir les envoyer) est possible et assez simple pour epoll et IOCP.  epoll vous permet de modifier le masque des √©v√©nements attendus (√† tout moment, m√™me √† partir d'un autre thread), et IOCP vous permet de d√©marrer une autre op√©ration pour attendre un nouveau type d'√©v√©nement. <br><br>  La modification ou la suppression des √©v√©nements attendus est cependant diff√©rente.  epoll vous permet toujours de modifier la condition en appelant epoll_ctl (y compris √† partir d'autres threads).  L'IOCP devient plus difficile.  Si une op√©ration d'E / S √©tait pr√©vue, elle peut √™tre annul√©e en appelant la fonction <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CancelIo ()</a> .  Pire, seul le m√™me thread qui a d√©marr√© l'op√©ration initiale peut appeler cette fonction.  Toutes les id√©es d'organisation d'un flux de contr√¥le s√©par√© sont bris√©es √† propos de cette limitation.  De plus, m√™me apr√®s avoir appel√© CancelIo (), nous ne pouvons pas √™tre s√ªrs que l'op√©ration sera imm√©diatement annul√©e (elle peut d√©j√† √™tre en cours, elle utilise la structure OVERLAPPED et le tampon pass√© pour la lecture / √©criture).  Nous devons encore attendre que l'op√©ration soit termin√©e (son r√©sultat sera retourn√© par la fonction GetOverlappedResult ()) et seulement apr√®s cela, nous pouvons lib√©rer le tampon. <br><br>  Un autre probl√®me avec IOCP est qu'une fois qu'une op√©ration a √©t√© planifi√©e pour ex√©cution, elle ne peut plus √™tre modifi√©e.  Par exemple, vous ne pouvez pas modifier la demande ReadFile planifi√©e et dire que vous souhaitez lire uniquement 10 octets, pas 8192. Vous devez annuler l'op√©ration en cours et en d√©marrer une nouvelle.  Ce n'est pas un probl√®me pour epoll qui, lorsque vous commencez √† attendre, n'a aucune id√©e de la quantit√© de donn√©es que vous souhaitez lire au moment de la notification de la capacit√© de lire les donn√©es. <br><br><h3>  Connexion non bloquante </h3><br>  Certaines impl√©mentations de services r√©seau (services associ√©s, FTP, p2p) n√©cessitent des connexions sortantes.  Epoll et IOCP prennent en charge une demande de connexion non bloquante, mais de diff√©rentes mani√®res. <br><br>  Lorsque vous utilisez epoll, le code est g√©n√©ralement le m√™me que pour select ou poll.  Vous cr√©ez un socket non bloquant, appelez connect () pour celui-ci et attendez une notification sur sa disponibilit√© pour l'√©criture. <br><br>  Lorsque vous utilisez IOCP, vous devez utiliser la fonction ConnectEx distincte, car l'appel √† connect () n'accepte pas la structure OVERLAPPED, ce qui signifie qu'il ne peut pas g√©n√©rer de notification sur le changement d'√©tat du socket ult√©rieurement.  Ainsi, le code d'initiation de la connexion ne diff√©rera pas seulement du code utilisant epoll, il sera m√™me diff√©rent du code Windows utilisant select ou poll.  Cependant, les changements peuvent √™tre consid√©r√©s comme minimes. <br><br>  Fait int√©ressant, accept () fonctionne avec IOCP comme d'habitude.  Il existe une fonction AcceptEx, mais son r√¥le n'est absolument pas li√© √† une connexion non bloquante.  Ce n'est pas une ¬´acceptation non bloquante¬ª, comme vous pourriez le penser par analogie avec connect / ConnectEx. <br><br><h3>  Suivi des √©v√©nements </h3><br>  Souvent, apr√®s le d√©clenchement d'un √©v√©nement, des donn√©es suppl√©mentaires arrivent tr√®s rapidement.  Par exemple, nous nous attendions √† ce que l'entr√©e du socket arrive √† l'aide d'epoll ou d'IOCP, nous avons eu un √©v√©nement sur les premiers octets de donn√©es, et l√†, pendant que nous les lisions, une centaine d'autres octets sont arriv√©s.  Puis-je les lire sans red√©marrer la surveillance des √©v√©nements? <br><br>  L'utilisation d'epoll est possible.  Vous obtenez l'√©v√©nement ¬´quelque chose peut maintenant √™tre lu¬ª - et vous lisez tout ce qui peut √™tre lu √† partir du socket (jusqu'√† ce que vous obteniez l'erreur EAGAIN).  La m√™me chose avec l'envoi de donn√©es - lorsque vous recevez un signal indiquant que le socket est pr√™t √† envoyer des donn√©es, vous pouvez y √©crire quelque chose jusqu'√† ce que la fonction d'√©criture renvoie EAGAIN. <br><br>  Avec l'IOCP, cela ne fonctionnera pas.  Si vous avez demand√© au socket de lire ou d'envoyer 10 octets de donn√©es - c'est combien seront lus / envoy√©s (m√™me si plus pourrait d√©j√† √™tre fait).  Pour chaque bloc suivant, vous devez effectuer une demande distincte √† l'aide de ReadFile ou WriteFile, puis attendez qu'il soit ex√©cut√©.  Cela peut cr√©er un niveau de complexit√© suppl√©mentaire.  Prenons l'exemple suivant: <br><br><ol><li>  La classe socket a cr√©√© une demande de lecture de donn√©es en appelant ReadFile.  Les threads A et B attendent le r√©sultat en appelant GetOverlappedResult () </li><li>  L'op√©ration de lecture est termin√©e, le thread A a re√ßu une notification et a appel√© une m√©thode de classe socket pour traiter les donn√©es re√ßues </li><li>  La classe socket a d√©cid√© que ces donn√©es ne sont pas suffisantes, nous devons nous attendre √† ce qui suit.  Il place une autre demande de lecture. </li><li>  Cette demande est ex√©cut√©e imm√©diatement (les donn√©es sont d√©j√† arriv√©es, le syst√®me d'exploitation peut les envoyer imm√©diatement).  Le flux B re√ßoit une notification, lit les donn√©es et les transmet √† la classe de socket. </li><li>  √Ä l'heure actuelle, la fonction de lecture des donn√©es dans la classe socket est appel√©e √† la fois √† partir des flux A et B, ce qui conduit soit au risque de corruption des donn√©es (sans utiliser des objets de synchronisation), soit √† des pauses suppl√©mentaires (lors de l'utilisation des objets de synchronisation) </li></ol><br>  Avec les objets de synchronisation dans ce cas, c'est g√©n√©ralement difficile.  Eh bien, s'il est seul.  Mais si nous avons 100 000 connexions et chacune d'elles aura une sorte d'objet de synchronisation, cela peut s√©rieusement affecter les ressources du syst√®me.  Et si vous en gardez toujours 2 (en cas de s√©paration du traitement des demandes de lecture et d'√©criture)?  Pire encore. <br><br>  La solution habituelle ici consiste √† cr√©er une classe de gestionnaire de connexions qui sera charg√©e d'appeler ReadFile ou WriteFile pour la classe de connexion.  Cela fonctionne mieux, mais rend le code plus complexe. <br><br><h3>  Conclusions </h3><br>  Epoll et IOCP conviennent (et sont utilis√©s dans la pratique) pour √©crire des services r√©seau hautes performances pouvant g√©rer un grand nombre de connexions.  Les technologies elles-m√™mes diff√®rent dans la fa√ßon dont elles g√®rent les √©v√©nements.  Ces diff√©rences sont si importantes qu'il ne vaut gu√®re la peine d'essayer de les √©crire sur une base commune (la quantit√© du m√™me code sera minime).  Plusieurs fois, j'ai travaill√© pour essayer d'apporter les deux approches √† une sorte de solution universelle - et chaque fois le r√©sultat √©tait pire en termes de complexit√©, de lisibilit√© et de support par rapport √† deux impl√©mentations ind√©pendantes.  Le r√©sultat universel obtenu a d√ª √™tre abandonn√© √† chaque fois. <br><br>  Lors du portage de code d'une plateforme √† une autre, il est g√©n√©ralement plus facile de porter le code IOCP pour utiliser epoll que l'inverse. <br><br>  Astuces: <br><br><ul><li>  Si votre t√¢che consiste √† d√©velopper un service r√©seau multiplateforme, vous devez commencer par une impl√©mentation Windows utilisant IOCP.  Une fois que tout est pr√™t et d√©bogu√© - ajoutez un back-end epoll trivial. </li><li>  Vous ne devez pas essayer d'√©crire les classes g√©n√©rales Connection et ConnectionMgr qui impl√©mentent la logique epoll et IOCP en m√™me temps.  Il semble mauvais du point de vue de l'architecture de code et conduit √† un tas de toutes sortes de #ifdef avec une logique diff√©rente √† l'int√©rieur.  Mieux vaut cr√©er des classes de base et en h√©riter des impl√©mentations distinctes.  Dans les classes de base, vous pouvez conserver certaines m√©thodes ou donn√©es g√©n√©rales, le cas √©ch√©ant. </li><li>  Surveillez de pr√®s la dur√©e de vie des objets de la classe Connection (ou tout ce que vous appelez la classe o√π les tampons pour les donn√©es re√ßues / envoy√©es seront stock√©s).  Il ne doit pas √™tre d√©truit tant que les op√©rations de lecture / √©criture planifi√©es √† l'aide de ses tampons ne sont pas termin√©es. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr415403/">https://habr.com/ru/post/fr415403/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr415393/index.html">Kubernetes: la vie d'un foyer</a></li>
<li><a href="../fr415395/index.html">T√©l√©viseurs ondul√©s</a></li>
<li><a href="../fr415397/index.html">PICASO 3D au Top 3D Expo 2018 - nouvelle imprimante 3D, nouveaux mat√©riaux</a></li>
<li><a href="../fr415399/index.html">Pourquoi les prix des DVD gratuits sur Fortnite atteignent-ils 450 $</a></li>
<li><a href="../fr415401/index.html">Nous r√©solvons le probl√®me d'un million d'onglets ouverts ou ¬´aidons le mat√©riel √† survivre¬ª</a></li>
<li><a href="../fr415405/index.html">Examen et test du serveur Fujitsu PRIMERGY RX2540 M4</a></li>
<li><a href="../fr415407/index.html">Godville - sauf pour les blagues</a></li>
<li><a href="../fr415409/index.html">Revue de l'imprimante 3D 3Dtool Raise3D PRO2</a></li>
<li><a href="../fr415411/index.html">De la l√©vitation de disques au son d'une bo√Æte en carton - 6 gadgets int√©ressants pour le vinyle</a></li>
<li><a href="../fr415413/index.html">Fonctionnalit√© crois√©e, gestionnaire de d√©pendances, surveillance dans les tests iOS et UI. Comment √©tait l'√©dition Avito iOS Summer Edition</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>