<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë¶üèø ü¶ì üòë Toda a verdade sobre o RTOS. Artigo 28. Temporizadores de software üë∂üèæ üòë ‚è≥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A id√©ia de temporizadores de software foi introduzida em um artigo anterior . Eles s√£o objetos do kernel que fornecem tarefas com uma maneira simples ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Toda a verdade sobre o RTOS. Artigo 28. Temporizadores de software</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455072/">  A id√©ia de temporizadores de software foi introduzida em um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo anterior</a> .  Eles s√£o objetos do kernel que fornecem tarefas com uma maneira simples de disparar eventos dentro do prazo ou, na maioria das vezes, uma maneira de executar a√ß√µes regularmente.  Todos os detalhes da funcionalidade relacionada ao tempo (precis√£o, manipula√ß√£o de interrup√ß√µes etc.) no Nucleus SE foram discutidos em um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo anterior</a> . <br><br><img src="https://habrastorage.org/webt/xu/5v/_s/xu5v_sdm50mq9i1ywof_lgsvqkw.jpeg"><br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Artigos anteriores da s√©rie:</b> <div class="spoiler_text"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo # 27</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Hora do sistema</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 26.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Canais: servi√ßos auxiliares e estruturas de dados</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 25.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Canais de Dados: Introdu√ß√£o e Servi√ßos B√°sicos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 24.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Filas: servi√ßos auxiliares e estruturas de dados</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 23.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Filas: introdu√ß√£o e servi√ßos b√°sicos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 22.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Caixas de correio: servi√ßos auxiliares e estruturas de dados</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 21.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Caixas de correio: Introdu√ß√£o e servi√ßos b√°sicos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 20.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Sem√°foros: Servi√ßos Auxiliares e Estruturas de Dados</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 19.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Sem√°foros: introdu√ß√£o e servi√ßos b√°sicos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo # 18</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Grupos de Sinalizadores de Eventos: Servi√ßos Auxiliares e Estruturas de Dados</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 17.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Grupos de Sinalizadores de Eventos: Introdu√ß√£o e Servi√ßos B√°sicos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 16.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Signals</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 15.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parti√ß√µes de mem√≥ria: servi√ßos e estruturas de dados</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 14.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Se√ß√µes de mem√≥ria: introdu√ß√£o e servi√ßos b√°sicos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 13.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Estruturas de dados da tarefa e chamadas de API n√£o suportadas</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 12.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Servi√ßos para trabalhar com tarefas</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 11.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Tarefas: configura√ß√£o e introdu√ß√£o √† API</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 10.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Agendador: recursos avan√ßados e preserva√ß√£o de contexto</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 9.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Agendador: implementa√ß√£o</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 8.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">N√∫cleo SE: Projeto Interno e Implanta√ß√£o</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo # 7</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">N√∫cleo SE: Introdu√ß√£o</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Outros servi√ßos RTOS</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Intera√ß√£o e sincroniza√ß√£o de tarefas</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Tarefas, altern√¢ncia de contexto e interrup√ß√µes</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo # 3</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Tarefas e planejamento</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">RTOS: estrutura e modo em tempo real</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><br></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">RTOS: introdu√ß√£o.</a> <br></div></div><br><h2>  Usando temporizadores </h2><br>  Os cron√¥metros de programa podem ser configurados para disparar uma vez, ou seja, eles iniciam e, depois de um per√≠odo especificado, simplesmente encerram o ciclo.  Ou o cron√¥metro pode ser configurado para reiniciar: ap√≥s a contagem ser conclu√≠da, o cron√¥metro √© reiniciado automaticamente.  O tempo de opera√ß√£o ap√≥s uma reinicializa√ß√£o pode diferir do tempo de opera√ß√£o inicial.  Al√©m disso, o temporizador pode opcionalmente ser configurado para executar uma fun√ß√£o de finaliza√ß√£o especial, que √© executada quando (ou toda vez) o cron√¥metro completa o ciclo de trabalho. <br><br><h2>  Configura√ß√µes do temporizador </h2><br><h3>  N√∫mero de temporizadores </h3><br>  Como na maioria dos aspectos do Nucleus SE, as configura√ß√µes do timer s√£o controladas pelas diretivas <b>#define</b> em <b>nuse_config.h</b> .  O par√¢metro principal √© <b>NUSE_TIMER_NUMBER</b> , que define os cron√¥metros configurados no aplicativo.  Por padr√£o, esse valor √© zero (ou seja, os temporizadores n√£o s√£o usados ‚Äã‚Äãno aplicativo) e pode levar valores at√© 16. Um valor incorreto levar√° a um erro de compila√ß√£o, que ser√° gerado ao verificar o arquivo <b>nuse_config_check.h</b> (esse arquivo est√° inclu√≠do no <b>nuse_config.c</b> e compila junto com ele), que acionar√° a diretiva <b>#error</b> . <br><br>  A sele√ß√£o de um valor diferente de zero √© o principal ativador do timer.  Este par√¢metro √© usado ao definir estruturas de dados, e seu tamanho depende de seu valor.  Al√©m disso, um valor diferente de zero ativa as configura√ß√µes da API. <br><br><h3>  Ativa√ß√£o da fun√ß√£o de conclus√£o </h3><br>  No Nucleus SE, tentei encontrar a oportunidade de tornar a funcionalidade opcional, onde economizar√° mem√≥ria.  Um bom exemplo √© o suporte para fun√ß√µes de conclus√£o do timer.  Al√©m do fato de esse recurso ser opcional para cada timer, o mecanismo pode ser ativado (ou n√£o) para todo o aplicativo usando o par√¢metro <b>NUSE_TIMER_EXPIRATION_ROUTINE_SUPPORT</b> em <b>nuse_config.h</b> .  Definir esse par√¢metro como <b>FALSE</b> bloqueia a defini√ß√£o de duas estruturas de dados na ROM, que ser√£o descritas em detalhes neste artigo. <br><br><h3>  Ativa√ß√£o de API </h3><br>  Cada fun√ß√£o de API (chamada de utilit√°rio) no Nucleus SE possui uma diretiva #define de ativa√ß√£o em nuse_config.h.  Para temporizadores, esses s√≠mbolos incluem: <br>  <b>NUSE_TIMER_CONTROL</b> <b><br></b>  <b>NUSE_TIMER_GET_REMAINING</b> <b><br></b>  <b>NUSE_TIMER_RESET</b> <b><br></b>  <b>NUSE_TIMER_INFORMATION</b> <b><br></b>  <b>NUSE_TIMER_COUNT</b> <br><br>  Por padr√£o, todos os ativadores s√£o definidos como <b>FALSE</b> , portanto, todas as chamadas de servi√ßo s√£o desativadas, bloqueando a inclus√£o do c√≥digo que as implementa.  Para configurar temporizadores no aplicativo, √© necess√°rio selecionar as chamadas de servi√ßo da API necess√°rias e configur√°-las como <b>TRUE</b> . <br><br>  A seguir, um trecho de c√≥digo do arquivo <b>nuse_config.h</b> padr√£o. <br><br><pre><code class="plaintext hljs">#define NUSE_TIMER_NUMBER 0/*      0-16 */ /*    */ #define NUSE_TIMER_CONTROL FALSE #define NUSE_TIMER_GET_REMAINING FALSE #define NUSE_TIMER_RESET FALSE #define NUSE_TIMER_INFORMATION FALSE #define NUSE_TIMER_COUNT FALSE</code> </pre> <br>  Se a fun√ß√£o API relacionada ao cron√¥metro estiver ativada e n√£o houver cron√¥metros configurados no aplicativo (exceto a fun√ß√£o <b>NUSE_Timer_Count ()</b> , que sempre est√° ativada), ocorrer√° um erro de compila√ß√£o.  Se o seu c√≥digo usar uma chamada de API que n√£o foi ativada, ocorrer√° um erro de layout porque o c√≥digo de implementa√ß√£o n√£o foi inclu√≠do no aplicativo. <br><br><h2>  Chamadas de servi√ßo do timer </h2><br>  O Nucleus RTOS suporta oito chamadas de utilit√°rio relacionadas ao timer que fornecem a seguinte funcionalidade: <br><br><ul><li>  Temporizador de gest√£o (iniciar / parar).  O n√∫cleo SE √© implementado na fun√ß√£o <b>NUSE_Timer_Control ()</b> . </li><li>  Recuperando o tempo restante do timer.  No Nucleus SE, implementado em <b>NUSE_Timer_Get_Remaining ()</b> . </li><li>  Restaurando o timer para seu estado original (redefinir).  N√∫cleo SE implementado em <b>NUSE_Timer_Reset ()</b> . </li><li>  Fornecendo informa√ß√µes sobre um cron√¥metro espec√≠fico.  O n√∫cleo SE √© implementado em <b>NUSE_Timer_Information ()</b> . </li><li>  Retorna o n√∫mero de temporizadores configurados (atualmente) no aplicativo.  O n√∫cleo SE √© implementado em <b>NUSE_Timer_Count ()</b> . </li><li>  Adicionando um novo cron√¥metro ao aplicativo (cria√ß√£o).  O n√∫cleo SE n√£o est√° implementado. </li><li>  Removendo um cron√¥metro do aplicativo.  O n√∫cleo SE n√£o est√° implementado. </li><li>  Retornando ponteiros para todos os cron√¥metros no aplicativo.  O n√∫cleo SE n√£o est√° implementado. </li></ul><br>  A implementa√ß√£o de cada chamada de servi√ßo ser√° discutida em detalhes abaixo. <br><br><h2>  Servi√ßos de Timer </h2><br>  As opera√ß√µes fundamentais que podem ser executadas com um timer s√£o controle (iniciar e parar) e leitura do valor atual.  O Nucleus RTOS e o Nucleus SE fornecem duas chamadas b√°sicas de utilit√°rio de API para essas opera√ß√µes. <br><br><h3>  Controle do temporizador </h3><br>  Uma chamada de utilit√°rio √† API do Nucleus RTOS para controlar o cron√¥metro permite ativar e desativar o cron√¥metro (iniciar e parar).  O Nucleus SE fornece funcionalidade semelhante. <br><br>  <b><i>Desafio de controle do temporizador no n√∫cleo RTOS</i></b> <br>  Prot√≥tipo de chamada de servi√ßo: <br><br>  <b>STATUS NU_Control_Timer (temporizador NU_TIMER *, ativa√ß√£o de OP√á√ÉO);</b> <br><br>  Par√¢metros: <br>  <b>timer</b> - ponteiro para o bloco de controle do timer fornecido pelo usu√°rio; <br>  <b>enable</b> √© a fun√ß√£o necess√°ria; ele pode assumir os valores <b>NU_ENABLE_TIMER</b> ou <b>NU_DISABLE_TIMER</b> . <br><br>  Valor de retorno: <br>  <b>NU_SUCCESS</b> - a chamada foi conclu√≠da com sucesso; <br>  <b>NU_INAVLID_TIMER</b> - ponteiro de timer inv√°lido; <br>  <b>NU_INAVLID_ENABLE</b> - fun√ß√£o inv√°lida. <br><br>  <b><i>Desafio de controle do temporizador no Nucleus SE</i></b> <br>  Essa chamada de API suporta a funcionalidade completa da API do Nucleus RTOS. <br><br>  Prot√≥tipo de chamada de servi√ßo: <br>  <b>STATUS NUSE_Timer_Control (temporizador NUSE_TIMER, ativa√ß√£o de OPTION);</b> <br><br>  Par√¢metros: <br>  <b>timer</b> - √≠ndice (ID) do timer usado; <br>  <b>enable</b> √© a fun√ß√£o necess√°ria; ele pode assumir os valores <b>NUSE_ENABLE_TIMER</b> ou <b>NUSE_DISABLE_TIMER</b> . <br><br>  Valor de retorno: <br>  <b>NUSE_SUCCESS</b> - a chamada foi conclu√≠da com sucesso; <br>  <b>NUSE_INCALID_TIMER</b> - √≠ndice de timer inv√°lido; <br>  <b>NUSE_INVALID_ENABLE</b> √© uma fun√ß√£o inv√°lida. <br><br>  <b><i>Implementar o gerenciamento de timer no Nucleus SE</i></b> <br>  O c√≥digo de fun√ß√£o da API <b>NUSE_Timer_Control ()</b> (depois de verificar os par√¢metros) √© bastante simples: <br><br><pre> <code class="plaintext hljs">NUSE_CS_Enter(); if (enable == NUSE_ENABLE_TIMER) { NUSE_Timer_Status[timer] = TRUE; if (NUSE_Timer_Expirations_Counter[timer] == 0) { NUSE_Timer_Value[timer] = NUSE_Timer_Initial_Time[timer]; } else { NUSE_Timer_Value[timer] = NUSE_Timer_Reschedule_Time[timer]; } } else /* enable == NUSE_DISABLE_TIMER */ { NUSE_Timer_Status[timer] = FALSE; } NUSE_CS_Exit();</code> </pre><br>  Se a fun√ß√£o <b>NUSE_DISABLE_TIMER</b> foi especificada, o status do timer (par√¢metro <b>NUSE_Timer_Status []</b> ) √© definido como <b>FALSE</b> , que ignora o timer pelo manipulador de interrup√ß√µes. <br><br>  Quando voc√™ seleciona a fun√ß√£o <b>NUSE_ENABLE_TIMER,</b> o contador do timer ( <b>NUSE_Timer_Value []</b> ) √© definido como <b>NUSE_Timer_initial_Time []</b> , desde que o timer nunca pare desde a √∫ltima redefini√ß√£o.  Caso contr√°rio, √© atribu√≠do o valor <b>NUSE_Timer_Reschedule_Time []</b> .  Em seguida, o status do timer (par√¢metro <b>NUSE_Timer_Status []</b> ) √© definido como <b>TRUE</b> , o que faz com que o timer seja processado pelo manipulador de interrup√ß√µes. <br><br><h3>  Leitura do temporizador </h3><br>  Para obter o tempo restante do timer, a chamada de servi√ßo da API do Nucleus RTOS retorna o n√∫mero de medidas at√© que ela expire.  O Nucleus SE fornece funcionalidade semelhante. <br><br>  <b><i>Ligue para obter o tempo restante no Nucleus RTOS</i></b> <br><br>  Prot√≥tipo de chamada de servi√ßo: <br>  <b>STATUS NU_Get_Remaining_Time (NU_TIMER * timer, UNSIGNED * restante_time);</b> <br><br>  Par√¢metros: <br>  <b>timer</b> - ponteiro para o bloco de controle do timer fornecido pelo usu√°rio; <br>  <b>restante_time</b> - um ponteiro para o armazenamento do valor de tempo restante, que √© uma vari√°vel do tipo <b>UNSIGNED</b> . <br><br>  Valor de retorno <br>  <b>NU_SUCCESS</b> - a chamada foi conclu√≠da com sucesso; <br>  <b>NU_INVALID_TIMER</b> - ponteiro de timer inv√°lido. <br><br>  <b><i>Ligue para obter o tempo restante no Nucleus SE</i></b> <br>  Essa chamada de API suporta a funcionalidade completa da API do Nucleus RTOS. <br><br>  Prot√≥tipo de chamada de servi√ßo: <br>  <b>STATUS NUSE_Timer_Get_Remaining (temporizador NUSE_TIMER, U16 * tempo_ restante);</b> <br><br>  Par√¢metros: <br>  <b>timer</b> - √≠ndice (ID) do timer usado; <br>  <b>restante_time</b> - um ponteiro para o armazenamento do valor de tempo restante, que √© uma vari√°vel do tipo <b>U16</b> . <br><br>  Valor de retorno: <br>  <b>NUSE_SUCCESS</b> - a chamada foi conclu√≠da com sucesso; <br>  <b>NUSE_INVALID_TIMER</b> - √≠ndice de timer inv√°lido; <br>  <b>NUSE_INVALID_POINTER</b> - ponteiro nulo para o tempo restante ( <b>NULL</b> ). <br><br>  <b><i>Implementando uma leitura de timer no Nucleus SE</i></b> <br>  A variante de c√≥digo de fun√ß√£o da API <b>NUSE_Timer_Get_Remaining ()</b> (depois de verificar os par√¢metros) √© trivialmente simples.  O valor <b>NUSE_Timer_Value [] √©</b> obtido e retornado na se√ß√£o cr√≠tica. <br><br><h2>  Servi√ßos Auxiliares de Temporizador </h2><br>  O Nucleus RTOS possui quatro chamadas de API que fornecem fun√ß√µes auxiliares relacionadas aos cron√¥metros: redefini√ß√£o de um cron√¥metro, obten√ß√£o de informa√ß√µes sobre o cron√¥metro, obten√ß√£o do n√∫mero de cron√¥metros em um aplicativo e indica√ß√£o de todos os cron√¥metros em um aplicativo.  As tr√™s primeiras fun√ß√µes s√£o implementadas no Nucleus SE. <br><br><h3>  Reset do temporizador </h3><br>  Essa chamada de API redefine o timer para seu estado original e n√£o utilizado.  O timer pode ser ativado ou desativado ap√≥s o t√©rmino desta chamada.  S√≥ pode ser usado depois que o timer foi desativado (usando <b>NUSE_Timer_Control ()</b> ).  Na pr√≥xima vez que o timer for ativado, ele ser√° inicializado com o par√¢metro <b>NUSE_Timer_Initial_Time []</b> .  O n√∫cleo RTOS permite fornecer um novo estado inicial e tempo de reagendamento, al√©m de especificar a fun√ß√£o de conclus√£o quando o timer for redefinido.  No Nucleus SE, esses valores s√£o definidos durante a instala√ß√£o e n√£o podem ser alterados, pois s√£o armazenados na ROM. <br><br>  <b><i>Ligue para redefinir um timer no Nucleus RTOS</i></b> <br><br>  Prot√≥tipo de chamada de servi√ßo: <br>  <b>STATUS NU_Reset_Timer (NU_TIMER * timer, VOID (* expiration_routine) (UNSIGNED), UNSIGNED initial_time, UNSIGNED reschedule_time, op√ß√£o habilitada);</b> <br><br>  Par√¢metros: <br>  <b>timer</b> - um ponteiro para um timer reinicializ√°vel; <br>  <b>expiration_routine</b> - indica a fun√ß√£o que ser√° executada quando o loop terminar; <br>  <b>initial_time</b> - o n√∫mero inicial de marcadores de tempo at√© o loop terminar; <br>  <b>reschedule_time</b> - o n√∫mero de <b>marca√ß√µes</b> do timer at√© o segundo e subsequente ciclo ser conclu√≠do; <br>  <b>enable</b> - o estado necess√°rio do cron√¥metro ap√≥s uma redefini√ß√£o, pode assumir os valores <b>NU_ENABLE_TIMER</b> ou <b>NU_DISABLE_TIMER</b> . <br><br>  Valor de retorno: <br>  <b>NU_SUCCESS</b> - a chamada foi conclu√≠da com sucesso; <br>  <b>NU_INVALID_TIMER</b> - ponteiro inv√°lido para a unidade de controle do temporizador; <br>  <b>NU_INVALID_FUNCTION</b> - ponteiro nulo para a fun√ß√£o de conclus√£o ( <b>NULL</b> ); <br>  <b>NU_INVALID_ENABLE</b> - o estado especificado est√° incorreto; <br>  <b>NU_NOT_DISABLED</b> - o timer j√° est√° em execu√ß√£o (deve ser parado antes de chamar esta fun√ß√£o). <br><br>  <b><i>Ligue para redefinir o timer no Nucleus SE</i></b> <br>  Esta chamada de servi√ßo da API suporta uma vers√£o simplificada da funcionalidade principal da API do Nucleus RTOS. <br><br>  Prot√≥tipo de chamada de servi√ßo: <br>  <b>STATUS NUSE_Timer_Reset (temporizador NUSE_TIMER, ativa√ß√£o de OPTION);</b> <br><br>  Par√¢metros: <br>  <b>timer</b> - √≠ndice (ID) do timer de redefini√ß√£o; <br>  <b>enable</b> - o estado necess√°rio ap√≥s a redefini√ß√£o, pode assumir os valores <b>NUSE_ENABLE_TIMER</b> ou <b>NUSE_DISABLE_TIMER</b> . <br><br>  Valor de retorno: <br>  <b>NUSE_SUCCESS</b> - a chamada foi conclu√≠da com sucesso; <br>  <b>NUSE_INVALID_TIMER</b> - √≠ndice de timer inv√°lido; <br>  <b>NUSE_INVALID_ENABLE</b> - o estado especificado est√° incorreto; <br>  <b>NUSE_NOT_DISABLED</b> - o timer j√° est√° em execu√ß√£o (ele deve ser parado antes de chamar esta fun√ß√£o). <br><br>  <b><i>Implementando uma redefini√ß√£o de timer no Nucleus SE</i></b> <br>  A vers√£o do c√≥digo de fun√ß√£o da API <b>NUSE_Timer_Reset ()</b> (depois de verificar os par√¢metros e o estado atual) √© bastante simples: <br><br><pre> <code class="plaintext hljs">NUSE_CS_Enter(); NUSE_Init_Timer(timer); if (enable == NUSE_ENABLE_TIMER) { NUSE_Timer_Status[timer] = TRUE; } /*  enable == NUSE_DISABLE_TIMER    FALSE */ NUSE_CS_Exit();</code> </pre><br>  Uma chamada para <b>NUSE_Init_Timer ()</b> inicializa o valor do tempo e limpa o contador de conclus√£o.  Depois disso, se necess√°rio, o valor do estado necess√°rio √© verificado e se o temporizador est√° ativado. <br><br><h3>  Informa√ß√µes do temporizador </h3><br>  Esta chamada de servi√ßo permite que voc√™ obtenha um conjunto de informa√ß√µes do temporizador.  A implementa√ß√£o do Nucleus SE difere do Nucleus RTOS, pois retorna menos informa√ß√µes, pois a nomea√ß√£o de objetos n√£o √© suportada. <br><br>  <b><i>Solicite informa√ß√µes sobre o temporizador no Nucleus RTOS</i></b> <br><br>  Prot√≥tipo de chamada de servi√ßo: <br>  <b>STATUS NU_Timer_Information (NU_TIMER * timer, CHAR * nome, OPTION * enable, expira√ß√µes UNSIGNED *, UNSIGNED * id, UNSIGNED * initial_time, UNSIGNED * reschedule_time);</b> <br><br>  Par√¢metros: <br>  <b>timer</b> - um ponteiro para um timer sobre quais informa√ß√µes s√£o solicitadas; <br>  <b>name</b> - ponteiro para a regi√£o de 8 caracteres para o nome do timer; <br>  <b>enable</b> - apontador para uma vari√°vel que leva o estado atual do ativador do timer: <b>NU_ENABLE_TIMER</b> ou <b>NU_DISABLE_TIMER</b> ; <br>  <b>vencimentos</b> - um ponteiro para uma vari√°vel que controla o n√∫mero de conclus√µes do ciclo do cron√¥metro desde sua √∫ltima redefini√ß√£o; <br>  <b>id</b> - ponteiro para uma vari√°vel que leva o valor do par√¢metro passado para a fun√ß√£o final do ciclo do timer; <br>  <b>initial_time</b> - um ponteiro para uma vari√°vel que assume um valor no qual o timer ser√° inicializado ap√≥s uma redefini√ß√£o; <br>  <b>reschedule_time</b> - um ponteiro para uma vari√°vel que leva um valor no qual o timer ser√° inicializado ap√≥s a conclus√£o. <br><br>  Valor de retorno: <br>  <b>NU_SUCCESS</b> - a chamada foi conclu√≠da com sucesso; <br>  <b>NU_INVALID_TIMER</b> - ponteiro de timer inv√°lido. <br><br>  <b><i>Ligue para obter informa√ß√µes sobre o temporizador no Nucleus SE</i></b> <br>  Essa chamada de API suporta a funcionalidade principal da API do Nucleus RTOS. <br><br>  Prot√≥tipo de chamada de servi√ßo: <br>  <b>STATUS NUSE_Timer_Information (timer NUSE_TIMER, OPTION * enable, U8 * expira√ß√µes, U8 * id, U16 * tempo_inicial, U16 * tempo de reagendamento);</b> <br><br>  Par√¢metros: <br>  <b>timer</b> - √≠ndice do timer sobre o qual as informa√ß√µes s√£o solicitadas; <br>  <b>enable</b> - um ponteiro para uma vari√°vel que assume o valor <b>TRUE</b> ou <b>FALSE</b> , dependendo se o timer est√° ativado ou n√£o; <br>  <b>vencimentos</b> - um ponteiro para uma vari√°vel do tipo <b>U8</b> que leva o valor do n√∫mero de conclus√µes do timer desde sua √∫ltima redefini√ß√£o; <br>  <b>id</b> - ponteiro para uma vari√°vel do tipo <b>U8</b> que leva o valor do par√¢metro passado para a fun√ß√£o de conclus√£o do timer (retornar√° um valor vazio se as fun√ß√µes de conclus√£o estiverem desativadas); <br>  <b>initial_time</b> - um ponteiro para uma vari√°vel do tipo <b>U16</b> que assume um valor pelo qual o timer ser√° inicializado ap√≥s uma redefini√ß√£o; <br>  <b>reschedule_time</b> - um ponteiro para uma vari√°vel do tipo <b>U16</b> , que assume o valor pelo qual o timer ser√° inicializado ap√≥s a conclus√£o. <br><br>  Valor de retorno: <br>  <b>NUSE_SUCCESS</b> - a chamada foi conclu√≠da com sucesso; <br>  <b>NUSE_INVALID_TIMER</b> - √≠ndice de timer inv√°lido; <br>  <b>NUSE_INVALID_POINTER</b> - um ou mais par√¢metros do ponteiro est√£o incorretos. <br><br>  <b><i>Implementando informa√ß√µes de timer no Nucleus SE</i></b> <br>  A implementa√ß√£o desta chamada de API √© bastante simples: <br><br><pre> <code class="plaintext hljs">NUSE_CS_Enter(); if (NUSE_Timer_Status[timer]) { *enable = NUSE_ENABLE_TIMER; } else { *enable = NUSE_DISABLE_TIMER; } *expirations = NUSE_Timer_Expirations_Counter[timer]; #if NUSE_TIMER_EXPIRATION_ROUTINE_SUPPORT *id = NUSE_Timer_Expiration_Routine_Parameter[timer]; #endif *initial_time = NUSE_Timer_Initial_Time[timer]; *reschedule_time = NUSE_Timer_Reschedule_Time[timer]; NUSE_CS_Exit();</code> </pre><br>  A fun√ß√£o retorna o status do timer.  O valor do par√¢metro da fun√ß√£o de finaliza√ß√£o √© retornado apenas se o suporte tiver sido ativado no aplicativo. <br><br><h3>  Obtendo o n√∫mero de temporizadores </h3><br>  Essa chamada de utilit√°rio retorna o n√∫mero de temporizadores configurados no aplicativo.  No Nucleus RTOS, esse valor pode mudar com o tempo e o valor de retorno exibir√° o n√∫mero atual de temporizadores.  No N√∫cleo SE, o valor de retorno √© definido durante a fase de montagem e n√£o pode ser alterado. <br><br>  <b><i>Ligue para um contador de temporizadores no Nucleus RTOS</i></b> <br><br>  Prot√≥tipo de chamada de servi√ßo: <br>  <b>NU_Established_Timers N√ÉO-ASSINADOS (VOID);</b> <br><br>  Par√¢metros: nenhum <br><br>  Valor de retorno: o n√∫mero de temporizadores criados no sistema. <br><br>  <b><i>Chamando o contador do temporizador no n√∫cleo SE</i></b> <br>  Essa chamada de API suporta a funcionalidade principal da API do Nucleus RTOS. <br><br>  Prot√≥tipo de chamada de servi√ßo: <br>  <b>U8 NUSE_Timer_Count (nulo);</b> <br><br>  Par√¢metros: nenhum <br><br>  Valor de retorno: <br>  o n√∫mero de temporizadores configurados no aplicativo <br><br><h3>  Implementa√ß√£o do contador de timer </h3><br>  A implementa√ß√£o desta chamada de API √© bastante simples: o valor do s√≠mbolo #define <b>NUSE_TIMER_NUMBER</b> √© <b>retornado</b> . <br><br><h2>  Estruturas de dados </h2><br>  Os cron√¥metros usam cinco ou sete estruturas de dados (localizadas na RAM ou ROM) que (como outros objetos do Nucleus SE) s√£o um conjunto de tabelas cujo tamanho e n√∫mero correspondem ao n√∫mero de cron√¥metros configurados e par√¢metros selecionados. <br><br>  Eu recomendo fortemente que o c√≥digo do aplicativo n√£o use acesso direto a essas estruturas de dados, mas fa√ßa refer√™ncia a elas atrav√©s das fun√ß√µes de API fornecidas.  Isso evitar√° a incompatibilidade com vers√µes futuras do Nucleus SE e efeitos colaterais indesejados, al√©m de simplificar a portabilidade de aplicativos para o Nucleus RTOS.  A seguir, √© apresentada uma vis√£o geral detalhada das estruturas para simplificar o entendimento da chamada de servi√ßo e do c√≥digo de depura√ß√£o. <br><br><h3>  Dados RAM </h3><br>  Esses dados t√™m a seguinte estrutura: <br>  <b>NUSE_Timer_Status []</b> √© uma matriz do tipo <b>U8</b> que possui uma entrada para cada timer configurado e armazena o status do timer (em execu√ß√£o ou parado: <b>TRUE</b> ou <b>FALSE</b> ). <br>  <b>NUSE_Timer_Value []</b> √© uma matriz do tipo <b>U16</b> que possui uma entrada para cada timer configurado e armazena o valor atual do contador do timer. <br>  <b>NUSE_Timer_Expirations_Counter []</b> - uma matriz do tipo <b>U8</b> , contendo um contador do n√∫mero de casos em que os temporizadores chegaram ao final do ciclo desde a √∫ltima redefini√ß√£o. <br><br>  Todas essas estruturas de dados s√£o inicializadas pela fun√ß√£o <b>NUSE_Init_Timer ()</b> quando o Nucleus SE √© iniciado.  Um dos artigos a seguir conter√° uma descri√ß√£o completa dos procedimentos de inicializa√ß√£o do Nucleus SE. <br><br>  A seguir, est√£o as defini√ß√µes dessas estruturas de dados no arquivo <b>nuse_init.c</b> : <br>  <b>RAM U8 Timer_Status [NUSE_TIMER_NUMBER];</b> <b><br></b>  <b>RAM U16 NUSE_Timer_Value [NUSE_TIMER_NUMBER];</b> <b><br></b>  <b>RAM U8 NUSE_Timer_Expirations_Counter [NUSE_TIMER_NUMBER];</b> <br><br><h3>  Dados ROM </h3><br>  A estrutura desses dados: <br>  <b>NUSE_Timer_Initial_Time []</b> √© uma matriz do tipo <b>U16</b> que possui uma entrada para cada timer configurado e armazena o valor de cada timer. <br>  <b>NUSE_Timer_Reschedule_Time []</b> √© uma matriz do tipo <b>U16</b> que possui uma entrada para cada timer configurado e armazena o valor no qual o timer ser√° definido ap√≥s a conclus√£o.  Um valor zero indica que o timer √© "√∫nico" e n√£o deve reiniciar automaticamente. <br>  <b>NUSE_Timer_Expiration_Routine_Address []</b> - uma matriz do tipo <b>ADDR que</b> cont√©m o endere√ßo dos procedimentos de expira√ß√£o do timer.  Essa matriz existe apenas se o suporte ao procedimento de expira√ß√£o do timer tiver sido ativado. <br>  <b>NUSE_Timer_Expiration_Routine_Parameter []</b> - uma matriz do tipo <b>U8 que</b> cont√©m os valores do par√¢metro que √© passado para a fun√ß√£o de conclus√£o do timer.  Essa matriz existe apenas se o suporte para fun√ß√µes de conclus√£o tiver sido ativado. <br><br>  Essas estruturas de dados s√£o declaradas e inicializadas (estaticamente) no arquivo <b>nuse_config.c</b> , assim: <br><br><pre> <code class="plaintext hljs">ROM U16 NUSE_Timer_Initial_Time[NUSE_TIMER_NUMBER] = { /*   ------ */ }; ROM U16 NUSE_Timer_Reschedule_Time[NUSE_TIMER_NUMBER] = { /*      ------ */ }; #if NUSE_TIMER_EXPIRATION_ROUTINE_SUPPORT || NUSE_INCLUDE_EVERYTHING /*    */ ROM ADDR NUSE_Timer_Expiration_Routine_Address[NUSE_TIMER_NUMBER] = { /*     ------ */ /*   NULL */ }; ROM U8 NUSE_Timer_Expiration_Routine_Parameter[NUSE_TIMER_NUMBER] = { /*     ------ */ }; #endif</code> </pre><br><h3>  A quantidade de mem√≥ria para o timer </h3><br>  Como todos os outros objetos do Nucleus SE, a quantidade de dados necess√°ria para os temporizadores √© previs√≠vel. <br><br>  A quantidade de dados na RAM (em bytes) para todos os cron√¥metros no aplicativo pode ser calculada da seguinte maneira: <br>  <b>NUSE_TIMER_NUMBER * 4</b> <br><br>  A quantidade de dados na ROM (em bytes) para todos os cron√¥metros no aplicativo, se o suporte para fun√ß√µes de conclus√£o estiver desativado, pode ser calculado da seguinte maneira: <br>  <b>NUSE_TIMER_NUMBER * 4</b> <br><br>  Caso contr√°rio, √© igual a: <br>  <b>NUSE_TIMER_NUMBER * (sizeof (ADDR) + 5)</b> <br><br><h2>  Chamadas de API n√£o realizadas </h2><br>  O Nucleus SE n√£o implementa as tr√™s chamadas de API que podem ser encontradas no RTOS. <br><br><h3>  Cria√ß√£o de temporizador </h3><br>  Essa chamada de API cria um cron√¥metro.  O Nucleus SE n√£o precisa, pois os temporizadores s√£o criados estaticamente. <br><br>  Prot√≥tipo de chamada de servi√ßo: <br>  <b>STATUS NU_Create_Timer (NU_TIMER * timer, CHAR * nome, VOID (* expiration_routine) (UNSIGNED), ID N√ÉO ASSINADO, N√ÉO ASSINADO tempo_inicial, hor√°rio n√£o assinado, habilita√ß√£o de op√ß√£o);</b> <br><br>  Par√¢metros: <br>  <b>timer</b> - ponteiro para o bloco de controle do timer fornecido pelo usu√°rio;  ser√° usado para controlar temporizadores em outras chamadas de API; <br>  <b>nome</b> - ponteiro para o nome de 7 caracteres do cron√¥metro com um zero final; <br>  <b>expiration_routine</b> - indica a fun√ß√£o que deve ser executada ap√≥s o t√©rmino do timer; <br>  <b>id</b> - um elemento de dados do tipo <b>UNSIGNED</b> passado para a fun√ß√£o de termina√ß√£o: este par√¢metro pode ser usado para identificar temporizadores com a mesma fun√ß√£o de termina√ß√£o; <br>  <b>initial_time</b> - indica o n√∫mero inicial de tiques do timer antes que o timer termine; <br>  <b>reschedule_time</b> - indica o n√∫mero de <b>marca√ß√µes</b> do timer at√© o segundo e subsequente ciclo ser conclu√≠do;  se este par√¢metro for igual a zero, o temporizador para apenas uma vez; <br>  <b>enable</b> - este par√¢metro pode assumir os valores <b>NU_ENABLE_TIMER</b> e <b>NU_DISABLE_TIMER</b> ;  <b>NU_ENABLE_TIMER</b> ativa um timer depois que ele √© criado;  <b>NU_DISABLE_TIMER</b> deixa o cron√¥metro desativado;  os cron√¥metros criados com o par√¢metro <b>NU_DISABLE_TIMER</b> devem ser ativados chamando <b>NU_Control_Timer</b> . <br><br>  Valor de retorno: <br>  <b>NU_SUCCESS</b> - a chamada foi conclu√≠da com sucesso; <br>  <b>NU_INVALID_TIMER</b> - um ponteiro nulo para uma unidade de controle de temporizador ( <b>NULL</b> ) ou a unidade de controle j√° est√° em uso; <br>  <b>NU_INVALID_FUNCTION</b> - ponteiro nulo para o programa de conclus√£o ( <b>NULL</b> ); <br>  <b>NU_INVALID_ENABLE</b> - par√¢metro de <b>ativa√ß√£o</b> inv√°lido; <br>  <b>NU_INVALID_OPERATION</b> - o par√¢metro <b>initial_time</b> era zero. <br><br><h3>  Excluir timer </h3><br>  Essa chamada de API exclui um cron√¥metro criado anteriormente.  O Nucleus SE n√£o precisa, porque os temporizadores s√£o criados estaticamente e n√£o podem ser exclu√≠dos. <br><br>  Prot√≥tipo de chamada de servi√ßo: <br>  <b>STATUS NU_Delete_Timer (NU_TIMER * timer);</b> <br><br>  Par√¢metros: <br>  <b>timer</b> - ponteiro para o bloco de controle do timer. <br><br>  Valor de retorno: <br>  <b>NU_SUCCESS</b> - a chamada foi conclu√≠da com sucesso; <br>  <b>NU_INVALID_TIMER</b> - ponteiro de timer inv√°lido; <br>  <b>NU_NOT_DISABLED</b> - O cron√¥metro especificado n√£o est√° desativado. <br><br><h3>  Ponteiros do temporizador </h3><br>  Essa chamada de API forma uma lista seq√ºencial de ponteiros para todos os cron√¥metros no sistema.  O Nucleus SE n√£o precisa, pois os temporizadores s√£o determinados por um √≠ndice simples, n√£o por um ponteiro. <br><br>  Prot√≥tipo de chamada de servi√ßo: <br>  <b>UNSIGNED NU_Timer_Pointers (NU_TIMER ** pointer_list, UNSIGNED maximum_pointers);</b> <br><br>  Par√¢metros: <br>  <b>pointer_list</b> - ponteiro para uma matriz de ponteiros <b>NU_TIMER</b> ;  ser√° preenchido com ponteiros para temporizadores configurados no sistema; <br>  <b>maximum_pointers</b> - o n√∫mero m√°ximo de ponteiros na matriz. <br><br>  Valor de retorno: <br>  O n√∫mero de ponteiros <b>NU_TIMER</b> colocados na matriz. <br><br><h2>  Compat√≠vel com n√∫cleo RTOS </h2><br>  Como com todos os outros objetos do Nucleus SE, meu objetivo era maximizar a compatibilidade do c√≥digo do aplicativo com o Nucleus RTOS.  Os temporizadores n√£o s√£o exce√ß√£o e, do ponto de vista do usu√°rio, eles s√£o implementados da mesma maneira que no Nucleus RTOS.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">H√° tamb√©m uma certa incompatibilidade, que eu considerava admiss√≠vel, pois, como resultado, o c√≥digo se tornaria mais compreens√≠vel e mais eficiente em termos da quantidade de mem√≥ria necess√°ria. </font><font style="vertical-align: inherit;">Caso contr√°rio, as chamadas da API do Nucleus RTOS poder√£o ser portadas quase diretamente para o Nucleus SE.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Identificadores de objeto </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No Nucleus RTOS, todos os objetos s√£o descritos por uma estrutura de dados - um bloco de controle que possui um tipo de dados espec√≠fico. Um ponteiro para esta unidade de controle √© um identificador de timer. Decidi que no Nucleus SE √© necess√°ria uma abordagem diferente para o uso eficiente da mem√≥ria: todos os objetos do kernel s√£o descritos por um conjunto de tabelas na RAM e / ou ROM. O tamanho dessas tabelas √© determinado pelo n√∫mero de objetos configurados de cada tipo. O identificador de um objeto espec√≠fico √© o √≠ndice nesta tabela. Ent√£o eu defini </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NUSE_TIMER</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> como o equivalente a </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">U8</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, uma vari√°vel (n√£o um ponteiro) desse tipo serve como identificador do cron√¥metro. </font><font style="vertical-align: inherit;">Essa ligeira incompatibilidade √© f√°cil de lidar se o c√≥digo for portado do Nucleus SE para o Nucleus RTOS e vice-versa. </font><font style="vertical-align: inherit;">Normalmente, nenhuma opera√ß√£o √© executada nos identificadores de objeto al√©m de mover e armazenar. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O n√∫cleo RTOS tamb√©m suporta temporizadores de nomea√ß√£o. </font><font style="vertical-align: inherit;">Esses nomes s√£o usados ‚Äã‚Äãapenas para depura√ß√£o. </font><font style="vertical-align: inherit;">Exclu√≠-os do Nucleus SE para economizar mem√≥ria.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tamanho do temporizador </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No Nucleus RTOS, os temporizadores s√£o implementados usando contadores de 32 bits. </font><font style="vertical-align: inherit;">Decidi reduzir esse valor para 16 bits no Nucleus SE. </font><font style="vertical-align: inherit;">Isso levou a melhorias significativas na efici√™ncia e no tempo de execu√ß√£o da mem√≥ria. </font><font style="vertical-align: inherit;">O N√∫cleo SE pode ser modificado se o aplicativo exigir um tempo de execu√ß√£o mais longo.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fun√ß√µes de conclus√£o </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O Nucleus SE implementa fun√ß√µes de termina√ß√£o de maneira semelhante ao Nucleus RTOS, somente elas podem ser desligadas completamente (o que permite economizar mem√≥ria) e tamb√©m s√£o determinadas estaticamente. </font><font style="vertical-align: inherit;">A fun√ß√£o final n√£o pode ser alterada quando o timer √© redefinido.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Chamadas de API n√£o realizadas </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O n√∫cleo RTOS suporta oito chamadas de servi√ßo de timer. </font><font style="vertical-align: inherit;">Destes, tr√™s n√£o est√£o implementados no Nucleus SE. </font><font style="vertical-align: inherit;">Uma descri√ß√£o detalhada dessas chamadas, bem como os motivos dessa decis√£o, pode ser encontrada anteriormente neste artigo, na se√ß√£o "Chamadas de API n√£o realizadas". </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O artigo a seguir examinar√° as interrup√ß√µes.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt455072/">https://habr.com/ru/post/pt455072/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt455060/index.html">Homer ou o primeiro opensource. parte 1</a></li>
<li><a href="../pt455062/index.html">Casos de experimentos bem-sucedidos (e n√£o muito) de Yandex.Navigator</a></li>
<li><a href="../pt455064/index.html">Talento vs. Sorte: O Papel da Chance no Sucesso e Fracasso</a></li>
<li><a href="../pt455066/index.html">Transmiss√£o e apresenta√ß√µes do MeetUp UPD2 de an√°lise do sistema</a></li>
<li><a href="../pt455070/index.html">Por que as entrevistas s√£o t√£o frequentemente perguntadas sobre listas vinculadas</a></li>
<li><a href="../pt455076/index.html">GameDev TDD ou Rabbit Hell</a></li>
<li><a href="../pt455078/index.html">Onde falar sobre o Apache Ignite e sistemas distribu√≠dos no ver√£o</a></li>
<li><a href="../pt455080/index.html">Os idosos n√£o pertencem aqui? Program√°vel ap√≥s trinta e cinco</a></li>
<li><a href="../pt455082/index.html">Estudamos MITRE ATT & CK. Matrizes m√≥veis: acesso ao dispositivo. Parte 4</a></li>
<li><a href="../pt455094/index.html">Como proteger o 5G em uma cidade inteligente: aplique uma nova arquitetura de seguran√ßa</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>