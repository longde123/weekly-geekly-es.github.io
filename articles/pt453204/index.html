<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëáüèº üôå üì° Cont√™ineres, microsservi√ßos e malhas de servi√ßo üë®üèø‚Äçüíº üöá ‚õîÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Existem v√°rios artigos sobre a malha de servi√ßo na Internet, e aqui est√° outro. Viva! Mas porque? Ent√£o, o que quero expressar minha opini√£o √© que ser...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cont√™ineres, microsservi√ßos e malhas de servi√ßo</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/453204/">  Existem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">v√°rios</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigos</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">sobre a</a> malha de servi√ßo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">na</a> Internet, e aqui est√° outro.  Viva!  Mas porque?  Ent√£o, o que quero expressar minha opini√£o √© que seria melhor que malhas de servi√ßo aparecessem h√° 10 anos, antes do surgimento de plataformas de cont√™ineres como Docker e Kubernetes.  N√£o afirmo que meu ponto de vista seja melhor ou pior que outros, mas como as malhas de servi√ßo s√£o animais bastante complexos, a multiplicidade de pontos de vista ajudar√° a melhor entend√™-los. <br><br>  Falarei sobre a plataforma dotCloud, que foi constru√≠da em mais de cem microsservi√ßos e suportou milhares de aplicativos em cont√™ineres.  Explicarei os problemas que encontramos durante seu desenvolvimento e lan√ßamento e como as malhas de servi√ßo podem ajudar (ou n√£o). <br><a name="habracut"></a><br><h1>  Hist√≥ria do dotCloud </h1><br>  Eu j√° escrevi sobre a hist√≥ria do dotCloud e a escolha da arquitetura para esta plataforma, mas falei um pouco sobre o n√≠vel da rede.  Se voc√™ n√£o quiser ler o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo anterior</a> sobre o dotCloud, aqui est√° um breve resumo: √© uma plataforma PaaS como servi√ßo que permite aos clientes iniciar uma ampla gama de aplicativos (Java, PHP, Python ...), com suporte para uma ampla variedade de servi√ßos de dados (MongoDB, MySQL, Redis ...) e um fluxo de trabalho como o Heroku: voc√™ carrega seu c√≥digo na plataforma, cria imagens de cont√™ineres e as implementa. <br><br>  Vou lhe dizer como o tr√°fego foi direcionado para a plataforma dotCloud.  N√£o porque foi especialmente legal (embora o sistema funcionou bem por seu tempo!), Mas principalmente porque, com a ajuda de ferramentas modernas, esse design pode ser facilmente implementado em pouco tempo por uma equipe modesta, se eles precisam de uma maneira de direcionar o tr√°fego entre v√°rios microsservi√ßos ou um monte de aplicativos.  Assim, voc√™ pode comparar as op√ß√µes: o que acontece se voc√™ desenvolver tudo sozinho ou usar a malha de servi√ßo existente.  Escolha padr√£o: fa√ßa voc√™ mesmo ou compre. <br><br><h1>  Roteamento de tr√°fego para aplicativos hospedados </h1><br>  Os aplicativos DotCloud podem fornecer pontos de extremidade HTTP e TCP. <br><br>  <b>Os pontos de extremidade HTTP s√£o</b> adicionados dinamicamente √† configura√ß√£o de cluster do balanceador de carga <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Hipache</a> .  Isso √© semelhante ao que os recursos do Kubernetes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Ingress</a> e um balanceador de carga como o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Traefik fazem hoje</a> . <br><br>  Os clientes se conectam aos pontos de extremidade HTTP por meio de seus respectivos dom√≠nios, desde que o nome do dom√≠nio aponte para os balanceadores de carga do dotCloud.  Nada de especial. <br><br>  <b>Os pontos de extremidade TCP</b> s√£o associados a um n√∫mero de porta, que √© passado para todos os cont√™ineres dessa pilha por meio de vari√°veis ‚Äã‚Äãde ambiente. <br><br>  Os clientes podem se conectar aos pontos de extremidade do TCP usando o nome do host apropriado (algo como gateway-X.dotcloud.com) e o n√∫mero da porta. <br><br>  Esse nome de host √© resolvido para um cluster de servidores "nats" (n√£o relacionados ao <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">NATS</a> ) que encaminham as conex√µes TCP de entrada para o cont√™iner correto (ou, no caso de servi√ßos com balanceamento de carga, para os cont√™ineres corretos). <br><br>  Se voc√™ estiver familiarizado com o Kubernetes, isso provavelmente lembrar√° os servi√ßos do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">NodePort</a> . <br><br>  N√£o havia servi√ßos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ClusterIP</a> equivalentes na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">plataforma dotCloud</a> : por simplicidade, o acesso aos servi√ßos era o mesmo, tanto de dentro como de fora da plataforma. <br><br>  Tudo foi organizado de maneira simples: as implementa√ß√µes iniciais das redes de roteamento HTTP e TCP, provavelmente apenas algumas centenas de linhas de Python.  Algoritmos simples (eu diria ing√™nuos) que foram finalizados com o crescimento da plataforma e o advento de requisitos adicionais. <br><br>  N√£o foi necess√°ria uma refatora√ß√£o extensiva do c√≥digo existente.  Em particular, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aplicativos de 12 fatores</a> podem usar diretamente o endere√ßo obtido por meio de vari√°veis ‚Äã‚Äãde ambiente. <br><br><h1>  Como isso difere de uma malha de servi√ßo moderna? </h1><br>  <b>Visibilidade</b> limitada.  Geralmente, n√£o t√≠nhamos m√©tricas para a grade de roteamento TCP.  Quanto ao roteamento HTTP, vers√µes posteriores t√™m m√©tricas HTTP detalhadas com c√≥digos de erro e tempos de resposta, mas as malhas de servi√ßo modernas v√£o ainda mais longe, fornecendo integra√ß√£o com sistemas de coleta de m√©tricas como o Prometheus, por exemplo. <br><br>  A visibilidade √© importante n√£o apenas do ponto de vista operacional (para ajudar a solucionar problemas), mas tamb√©m quando novos recursos s√£o lan√ßados.  Trata-se de uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">implanta√ß√£o azul esverdeada</a> segura e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">implanta√ß√£o de can√°rios</a> . <br><br>  <b>A efici√™ncia de roteamento</b> tamb√©m <b>√©</b> limitada.  Na grade de roteamento dotCloud, todo o tr√°fego precisava passar por um cluster de n√≥s de roteamento dedicados.  Isso significou um poss√≠vel cruzamento de v√°rias fronteiras do AZ (zonas de acessibilidade) e um aumento significativo no atraso.  Lembro-me de como corrigi problemas com o c√≥digo que fazia mais de cem consultas SQL por p√°gina e, para cada consulta, abriu uma nova conex√£o com o servidor SQL.  Quando iniciada localmente, a p√°gina √© carregada instantaneamente, mas no dotCloud, o carregamento leva alguns segundos, porque leva dezenas de milissegundos para cada conex√£o TCP (e consulta SQL subsequente).  Nesse caso em particular, conex√µes persistentes resolveram o problema. <br><br>  As malhas de servi√ßo modernas se saem melhor com esses problemas.  Primeiro, eles verificam se as conex√µes s√£o roteadas <i>na origem</i> .  O fluxo l√≥gico √© o mesmo: <code> ‚Üí  ‚Üí </code> , mas agora a malha funciona localmente e n√£o em n√≥s remotos, portanto, a conex√£o <code> ‚Üí </code> √© local e muito r√°pida (microssegundos em vez de milissegundos). <br><br>  As malhas de servi√ßo modernas tamb√©m implementam algoritmos de balanceamento de carga mais inteligentes.  Ao controlar o desempenho dos back-ends, eles podem enviar mais tr√°fego para back-ends mais r√°pidos, o que leva a um aumento no desempenho geral. <br><br>  <b>A seguran√ßa tamb√©m</b> √© melhor.  A grade de roteamento do dotCloud funcionou completamente no EC2 Classic e n√£o criptografou o tr√°fego (supondo que se algu√©m conseguisse detectar o tr√°fego de rede do EC2, voc√™ j√° ter√° grandes problemas).  As malhas de servi√ßo modernas protegem de forma transparente todo o nosso tr√°fego, por exemplo, com autentica√ß√£o TLS m√∫tua e criptografia subsequente. <br><br><h1>  Roteamento de tr√°fego para servi√ßos de plataforma </h1><br>  Ok, discutimos o tr√°fego entre aplicativos, mas e a plataforma dotCloud? <br><br>  A plataforma em si consistia em cerca de cem microsservi√ßos respons√°veis ‚Äã‚Äãpor v√°rias fun√ß√µes.  Alguns receberam pedidos de outros, e outros eram trabalhadores em segundo plano que se conectaram a outros servi√ßos, mas n√£o aceitaram conex√µes.  De qualquer forma, cada servi√ßo deve conhecer os pontos de extremidade dos endere√ßos aos quais √© necess√°rio se conectar. <br><br>  Muitos servi√ßos de alto n√≠vel podem usar a grade de roteamento descrita acima.  De fato, muitos dos mais de centenas de microsservi√ßos dotCloud foram implantados como aplicativos regulares na pr√≥pria plataforma dotCloud.  Mas um pequeno n√∫mero de servi√ßos de baixo n√≠vel (em particular, que implementam essa grade de roteamento) precisava de algo mais simples, com menos depend√™ncias (j√° que n√£o podiam depender de si mesmos para trabalhar - um bom e velho problema de galinha e ovo). <br><br>  Esses servi√ßos importantes e de baixo n√≠vel foram implantados executando cont√™ineres diretamente em v√°rios n√≥s principais.  Ao mesmo tempo, servi√ßos de plataforma padr√£o n√£o estavam envolvidos: o vinculador, o planejador e o corredor.  Se voc√™ deseja comparar com as modernas plataformas de cont√™ineres, √© como iniciar um plano de controle com a <code>docker run</code> diretamente nos n√≥s, em vez de delegar a tarefa Kubernetes.  Isso √© bastante semelhante ao conceito de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">m√≥dulos est√°ticos (lares)</a> que o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">kubeadm</a> ou o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">bootkube usa</a> ao carregar um cluster independente. <br><br>  Esses servi√ßos foram expostos de maneira simples e grosseira: seus nomes e endere√ßos foram listados no arquivo YAML;  e cada cliente teve que tirar uma c√≥pia desse arquivo YAML para implanta√ß√£o. <br><br>  Por um lado, √© extremamente confi√°vel, porque n√£o requer suporte a um armazenamento de chave / valor externo como o Zookeeper (n√£o se esque√ßa, naquele momento o etcd ou o Consul ainda n√£o existiam).  Por outro lado, isso dificultava a movimenta√ß√£o de servi√ßos.  Sempre que em movimento, todos os clientes devem ter recebido um arquivo YAML atualizado (e potencialmente reinicializados).  N√£o √© muito conveniente! <br><br>  Posteriormente, come√ßamos a introduzir um novo esquema, em que cada cliente se conectava a um servidor proxy local.  Em vez do endere√ßo e da porta, basta que ele saiba apenas o n√∫mero da porta do servi√ßo e conecte-se atrav√©s do <code>localhost</code> .  O servidor proxy local processa essa conex√£o e a encaminha para o servidor real.  Agora, ao mover o back-end para outra m√°quina ou escalar em vez de atualizar todos os clientes, √© necess√°rio atualizar apenas todos esses proxies locais;  e uma reinicializa√ß√£o n√£o √© mais necess√°ria. <br><br>  (Tamb√©m foi planejado encapsular o tr√°fego nas conex√µes TLS e colocar outro servidor proxy no lado receptor, al√©m de verificar os certificados TLS sem a participa√ß√£o do servi√ßo receptor, configurado para aceitar conex√µes apenas no <code>localhost</code> . Mais sobre isso mais adiante). <br><br>  Isso √© muito semelhante ao <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SmartStack</a> do Airbnb, mas a diferen√ßa significativa √© que o SmartStack √© implementado e implantado na produ√ß√£o, enquanto o sistema interno de roteamento dotCloud foi colocado em uma caixa quando o dotCloud se transformou no Docker. <br><br>  Pessoalmente, considero o SmartStack um dos antecessores de sistemas como Istio, Linkerd e Consul Connect, porque todos seguem o mesmo padr√£o: <br><br><ul><li>  Executando proxies em cada n√≥. <br></li><li>  Clientes se conectam ao proxy. <br></li><li>  O plano de gerenciamento atualiza a configura√ß√£o do proxy ao alterar back-end. <br></li><li>  ... Lucro! </li></ul><br><h1>  Implementa√ß√£o moderna de uma malha de servi√ßo </h1><br>  Se precisarmos implementar uma grade semelhante hoje, podemos usar princ√≠pios semelhantes.  Por exemplo, configure a zona DNS interna mapeando nomes de servi√ßo para endere√ßos em <code>127.0.0.0/8</code> .  Em seguida, execute o HAProxy em cada n√≥ do cluster, aceitando conex√µes com cada endere√ßo de servi√ßo ( <code>127.0.0.0/8</code> nesta sub-rede) e redirecionando / equilibrando a carga para os back-end correspondentes.  A configura√ß√£o do HAProxy pode ser controlada pelo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">confd</a> , permitindo armazenar informa√ß√µes de back-end no etcd ou Consul e enviar automaticamente a configura√ß√£o atualizada ao HAProxy quando necess√°rio. <br><br>  √â assim que o Istio funciona!  Mas com algumas diferen√ßas: <br><br><ul><li>  Usa o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Envoy Proxy em</a> vez do HAProxy. <br></li><li>  Salva a configura√ß√£o de back-end via API do Kubernetes, em vez do etcd ou Consul. <br></li><li>  Os servi√ßos s√£o endere√ßos alocados na sub-rede interna (endere√ßos do Kubernetes ClusterIP) em vez de 127.0.0.0/8. <br></li><li>  Possui um componente opcional (Citadel) para adicionar autentica√ß√£o TLS m√∫tua entre o cliente e os servidores. <br></li><li>  Suporta novos recursos, como quebra de circuito, rastreamento distribu√≠do, implanta√ß√£o de can√°rios, etc. </li></ul><br>  Vamos dar uma olhada r√°pida em algumas das diferen√ßas. <br><br><h3>  Proxy enviado </h3><br>  O Enftoy Proxy foi escrito por Lyft [concorrente da Uber no mercado de t√°xis - aprox.  trans.].  √â muito semelhante a outros proxies de v√°rias maneiras (por exemplo, HAProxy, Nginx, Traefik ...), mas Lyft escreveu o seu pr√≥prio porque precisava de fun√ß√µes que n√£o est√£o em outros proxies, e parecia mais razo√°vel criar um novo do que expandir o existente. <br><br>  O enviado pode ser usado sozinho.  Se eu tiver um servi√ßo espec√≠fico que deve se conectar a outros servi√ßos, posso configur√°-lo para conectar-se ao Envoy e, em seguida, configurar e reconfigurar dinamicamente o Envoy com a localiza√ß√£o de outros servi√ßos, enquanto recebo muitos recursos adicionais excelentes, por exemplo, visibilidade.  Em vez de uma biblioteca-cliente personalizada ou incorpora√ß√£o de rastreamento de chamadas no c√≥digo, direcionamos o tr√°fego para o Envoy e ele coleta m√©tricas para n√≥s. <br><br>  Mas o Envoy tamb√©m pode trabalhar como um plano de dados para uma malha de servi√ßo.  Isso significa que, para essa malha de servi√ßo, o Envoy agora est√° configurado <i>pelo</i> plano de controle. <br><br><h3>  Plano de controle </h3><br>  No plano de gerenciamento, o Istio conta com a API Kubernetes.  <i>Isso n√£o √© muito diferente do uso de confd</i> , que depende do etcd ou Consul para exibir um conjunto de chaves em um data warehouse.  O Istio, por meio da API do Kubernetes, exibe o conjunto de recursos do Kubernetes. <br><br>  <i>Entre o caso</i> : eu pessoalmente achei <a href="">√∫til</a> essa <a href="">descri√ß√£o da API do Kubernetes</a> , que diz: <br><br><blockquote>  O servidor de API do Kubernetes √© um "servidor burro" que oferece armazenamento, vers√£o, valida√ß√£o, atualiza√ß√£o e sem√¢ntica de recursos da API. </blockquote><br>  O Istio foi projetado para trabalhar com o Kubernetes;  e se voc√™ quiser us√°-lo fora do Kubernetes, precisar√° executar uma inst√¢ncia do servidor da API do Kubernetes (e servi√ßo auxiliar etcd). <br><br><h3>  Endere√ßos de Servi√ßo </h3><br>  O Istio conta com os endere√ßos ClusterIP que o Kubernetes aloca, para que os servi√ßos do Istio obtenham um endere√ßo interno (n√£o no intervalo <code>127.0.0.0/8</code> ). <br><br>  O tr√°fego para o endere√ßo ClusterIP de um servi√ßo espec√≠fico no cluster Kubernetes sem o Istio √© interceptado pelo kube-proxy e enviado √† parte do servidor desse proxy.  Se voc√™ estiver interessado em detalhes t√©cnicos, o kube-proxy definir√° as regras do iptables (ou balanceadores de carga IPVS, dependendo de como voc√™ a configura) para reescrever os endere√ßos IP de destino das conex√µes que v√£o para o endere√ßo ClusterIP. <br><br>  Depois de instalar o Istio no cluster Kubernetes, nada muda at√© que seja explicitamente ativado para o consumidor em quest√£o ou mesmo para todo o espa√ßo para nome, introduzindo o cont√™iner <code>sidecar</code> em lareiras personalizadas.  Esse cont√™iner iniciar√° uma inst√¢ncia do Envoy e definir√° uma s√©rie de regras do iptables para interceptar o tr√°fego para outros servi√ßos e redirecionar esse tr√°fego para o Envoy. <br><br>  Quando integrado ao DNS do Kubernetes, isso significa que nosso c√≥digo pode se conectar pelo nome do servi√ßo e tudo "simplesmente funciona".  Em outras palavras, nosso c√≥digo emite solicita√ß√µes como <code>http://api/v1/users/4242</code> , depois a <code>api</code> resolve a solicita√ß√£o para <code>10.97.105.48</code> , as regras do iptables interceptam conex√µes de 10.97.105.48 e as redirecionam para o proxy local do Envoy, e esse proxy local direciona solicita√ß√£o para a API de back-end real.  Fuh! <br><br><h3>  Coisinhas extras </h3><br>  O Istio tamb√©m fornece criptografia e autentica√ß√£o de ponta a ponta atrav√©s do mTLS (TLS m√∫tuo).  O componente chamado <i>Citadel</i> √© respons√°vel por isso. <br><br>  Tamb√©m existe um componente do <i>Mixer</i> que a Envoy pode solicitar para <i>cada</i> solicita√ß√£o, a fim de tomar uma decis√£o especial sobre essa solicita√ß√£o, dependendo de v√°rios fatores, como cabe√ßalhos, carregamento de back-end, etc. ... (n√£o se preocupe: existem v√°rias maneiras de garantir que o Mixer funcione e at√© se travar, o Enviado continuar√° funcionando normalmente como proxy). <br><br>  E, √© claro, mencionamos visibilidade: o Envoy coleta um grande n√∫mero de m√©tricas, fornecendo rastreamento distribu√≠do.  Na arquitetura dos microsservi√ßos, se uma solicita√ß√£o de API precisar passar pelos microsservi√ßos A, B, C e D, quando voc√™ efetuar login no sistema, o rastreio distribu√≠do adicionar√° um identificador exclusivo √† solicita√ß√£o e salvar√° esse identificador atrav√©s de subconsultas em todos esses microsservi√ßos, permitindo registrar todas as chamadas relacionadas, seus atrasos etc. <br><br><h1>  Desenvolver ou comprar </h1><br>  Istio tem uma reputa√ß√£o de ser um sistema complexo.  Por outro lado, a constru√ß√£o de uma grade de roteamento, que descrevi no in√≠cio deste post, √© relativamente simples usando as ferramentas existentes.  Ent√£o, faz sentido criar sua pr√≥pria malha de servi√ßo? <br><br>  Se tivermos necessidades modestas (voc√™ n√£o precisa de visibilidade, um disjuntor e outras sutilezas), ent√£o pensamos em desenvolver sua pr√≥pria ferramenta.  Mas se usarmos o Kubernetes, pode at√© n√£o ser necess√°rio, porque o Kubernetes j√° fornece ferramentas b√°sicas para descoberta de servi√ßos e balanceamento de carga. <br><br>  Por√©m, se tivermos requisitos avan√ßados, "comprar" uma malha de servi√ßo parece ser uma op√ß√£o muito melhor.  (Isso nem sempre √© uma "compra", porque o Istio vem com c√≥digo-fonte aberto, mas ainda precisamos investir tempo de engenharia para entender seu trabalho, implant√°-lo e gerenci√°-lo). <br><br><h1>  O que escolher: Istio, Linkerd ou Consul Connect? </h1><br>  At√© agora, falamos apenas do Istio, mas essa n√£o √© a √∫nica malha de servi√ßo.  Uma alternativa popular √© o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Linkerd</a> , e tamb√©m o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Consul Connect</a> . <br><br>  O que escolher? <br><br>  Honestamente, eu n√£o sei.  No momento, n√£o me considero competente o suficiente para responder a essa pergunta.  Existem alguns <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigos</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">interessantes</a> comparando essas ferramentas e at√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">refer√™ncias</a> . <br><br>  Uma abordagem promissora √© usar uma ferramenta como o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SuperGloo</a> .  Ele implementa uma camada de abstra√ß√£o para simplificar e unificar as APIs fornecidas pelas malhas de servi√ßo.  Em vez de estudar APIs espec√≠ficas (e, na minha opini√£o, relativamente complexas) de v√°rias malhas de servi√ßo, podemos usar constru√ß√µes SuperGloo mais simples - e alternar facilmente de uma para outra, como se tiv√©ssemos um formato de configura√ß√£o intermedi√°rio que descreve interfaces HTTP e back-end capazes de gerar a configura√ß√£o real para Nginx, HAProxy, Traefik, Apache ... <br><br>  Aceitei um pouco o Istio e o SuperGloo e, no pr√≥ximo artigo, quero mostrar como adicionar o Istio ou o Linkerd a um cluster existente usando o SuperGloo, e quanto o √∫ltimo suportar√° seu trabalho, ou seja, permite alternar de uma malha de servi√ßo para outra sem reescrever as configura√ß√µes. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt453204/">https://habr.com/ru/post/pt453204/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt453190/index.html">ANPR usando RoR & React Native</a></li>
<li><a href="../pt453192/index.html">Sincroniza√ß√£o e assincronia de processos</a></li>
<li><a href="../pt453194/index.html">Resolvemos o problema do Best Reverser com PHDays 9</a></li>
<li><a href="../pt453196/index.html">Pesquisa da Forrester: uma compara√ß√£o dos dez principais fornecedores de an√°lise de composi√ß√£o de software</a></li>
<li><a href="../pt453200/index.html">Discuss√£o: o projeto OpenROAD pretende resolver a tarefa de automatizar o design dos processadores</a></li>
<li><a href="../pt453206/index.html">Entrevista com Kelsey Moody: Como construir uma empresa e acabar com patologias relacionadas √† idade</a></li>
<li><a href="../pt453212/index.html">Consumer Reports: O mais recente piloto autom√°tico da Tesla est√° longe de ser perfeito</a></li>
<li><a href="../pt453214/index.html">Como e por que manter a forma se voc√™ √© uma pessoa de TI em um site remoto</a></li>
<li><a href="../pt453216/index.html">Sistemas de monitoramento de tr√°fego em redes VoIP. Parte Dois - Princ√≠pios da Organiza√ß√£o</a></li>
<li><a href="../pt453218/index.html">A principal coisa com o YaC 2019: cem drones nas estradas, Yandex.Module, food, smart home</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>