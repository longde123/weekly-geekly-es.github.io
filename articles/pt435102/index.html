<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•ò üõãÔ∏è üéé Um pouco sobre an√°lise lexical üëú ü§≤üèø üë©‚Äç‚ù§Ô∏è‚Äçüíã‚Äçüë®</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Era uma vez, quando o c√©u estava azul, a grama era mais verde e os dinossauros vagavam pela Terra ... N√£o, esque√ßa os dinossauros. Bem, em geral, era ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Um pouco sobre an√°lise lexical</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435102/"><img src="https://habrastorage.org/webt/93/ob/36/93ob36rkepacsoqhbmlu4bj3g0q.png"><br><br>  Era uma vez, quando o c√©u estava azul, a grama era mais verde e os dinossauros vagavam pela Terra ... N√£o, esque√ßa os dinossauros.  Bem, em geral, era uma vez a id√©ia de distrair-se da programa√ß√£o da Web padr√£o e fazer algo mais louco.  Poderia, √© claro, ser qualquer coisa, mas a escolha recaiu sobre escrever seu pr√≥prio int√©rprete.  O que posso dizer ... <i>Nunca escreva suas pr√≥prias linguagens de programa√ß√£o</i> .  Mas eu tenho alguma experi√™ncia com tudo isso, ent√£o decidi compartilh√°-la.  Vamos come√ßar com o pr√≥prio fundamento - o lexer. <br><a name="habracut"></a><br><h2>  Pref√°cio </h2><br>  Antes de come√ßar a entender que tipo de animal √© "lexer", vale a pena descobrir do que os YaPs s√£o feitos. <br><br>  No mundo moderno, cada compilador / int√©rprete / transpilador / qualquer outra coisa do tipo (vamos chamar de "compilador" adicional, sem distin√ß√£o entre tipos) √© dividido em duas partes.  Na terminologia dos tios inteligentes, essas pe√ßas s√£o chamadas de "front-end" e "back-end".  N√£o, n√£o √© isso que, ao trabalhar com a web, o que costum√°vamos chamar e a frente n√£o est√° escrita em JS com HTML.  Embora ... Ok. <br><br>  A tarefa do primeiro frontend √© pegar o <b>texto</b> e transform√°-lo em um <b>AST</b> (√°rvore de sintaxe abstrata), verificando a sintaxe (e √†s vezes a sem√¢ntica) no caminho.  A tarefa do segundo back-end √© fazer com que tudo funcione.  Se o c√≥digo for montado dentro do int√©rprete, o AST criar√° um conjunto de instru√ß√µes para o processador virtual (m√°quina virtual), se o compilador, o conjunto de instru√ß√µes para o processador real.  Na vida, tudo √© bem mais complicado e pode n√£o ser implementado dessa maneira.  Por exemplo, no caso do compilador GCC, tudo est√° confuso, mas Clang j√° √© mais can√¥nico, o LLVM √© um representante t√≠pico do "back-end" para compiladores. <br><br><img src="https://habrastorage.org/webt/un/ai/wa/unaiwa1kmx5jci6uxnhngor5ozs.png"><br><br>  Agora vamos conhecer uma pe√ßa chamada frontend. <br><br><h2>  An√°lise lexical </h2><br>  A tarefa do lexer e o est√°gio da an√°lise lexical √© obter muitas e muitas letras como entrada e agrup√°-las em algumas categorias - "tokens".  Portanto, a an√°lise lexical tamb√©m √© chamada de "tokeniza√ß√£o".  Esse √© o primeiro est√°gio do processamento de texto que todo compilador existente produz. <br><br>  Algo assim: <br><br><pre><code class="php hljs">$tokens = [<span class="hljs-string"><span class="hljs-string">'class'</span></span>, <span class="hljs-string"><span class="hljs-string">'\w+'</span></span>, <span class="hljs-string"><span class="hljs-string">'}'</span></span>, <span class="hljs-string"><span class="hljs-string">'{'</span></span>]; var_dump(lex(<span class="hljs-string"><span class="hljs-string">'class Example {}'</span></span>, $tokens)); <span class="hljs-comment"><span class="hljs-comment">// array(4) { // [0] =&gt; string(5) "class" // [1] =&gt; string(7) "Example" // [2] =&gt; string(1) "{" // [3] =&gt; string(1) "}" // }</span></span></code> </pre> <br>  A prop√≥sito, aqui j√° escrevemos v√°rias ferramentas para facilitar a vida.  As mesmas fun√ß√µes <i>pr√©vias</i> que costum√°vamos usar para analisar texto s√£o bastante <i>capazes</i> dessa tarefa.  No entanto, existem ferramentas mais convenientes para esse assunto: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Phlexy</a> , escrito por Nikita Popov. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Hoa</a> √© um kit de ferramentas composto por Lexer + Parser + Grammar. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Port Yacc</a> , escrito por Anthony Ferrara, que tamb√©m √© um kit de ferramentas complexo, e no qual o conhecido <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">analisador</a> Popov <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">PHP √©</a> escrito, aplic√°vel em ferramentas que usam an√°lise de c√≥digo. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Railt Lexer</a> minha implementa√ß√£o para PHP 7.1+ </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parle</a> √© uma extens√£o para PHP que permite um conjunto limitado de express√µes PCRE (sem visuais e outras constru√ß√µes de sintaxe). </li><li>  E, finalmente, a fun√ß√£o php padr√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">token_get_all</a> , destinada diretamente √† an√°lise lexical do PHP. </li></ul><br>  Bem, est√° claro que existem muitos dispositivos que podem dividir o texto por tokens; talvez eu at√© tenha esquecido algo, como o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Doctrine</a> lexer.  Mas o que vem depois? <br><br><h2>  Tipos de Lexers </h2><br>  E como sempre, nem tudo √© t√£o simples quanto parecia.  Existem pelo menos duas categorias diferentes de lexers.  Existe a op√ß√£o usual, bastante trivial, para a qual voc√™ aplica as regras, e ela j√° divide tudo em tokens.  A sua configura√ß√£o n√£o √© muito diferente do exemplo mostrado por mim acima.  No entanto, h√° outra op√ß√£o chamada <b>multistate</b> .  Tais lexers s√£o um pouco mais dif√≠ceis de entender, portanto, quero falar um pouco mais sobre eles. <br><br>  A tarefa de um lexer de v√°rios estados √© exibir v√°rios tokens, dependendo do estado anterior.  Bem, por exemplo, no PHP, esses estados "transit√≥rios" s√£o formados usando as Tags &lt;? Php +?&gt; Tags, linhas internas, coment√°rios e constru√ß√µes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">HEREDOC</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">NOWDOC</a> . <br><br>  Lembra do exemplo anterior com 4 tokens acima?  Vamos modific√°-lo um pouco para entender quais s√£o esses estados: <br><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Example</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// class Example {} }</span></span></code> </pre><br>  Nesse caso, se tivermos o lexer mais simples sem os amplos recursos do PCRE, obteremos o seguinte conjunto de tokens: <br><br><pre> <code class="php hljs">var_dump(lex(...)); <span class="hljs-comment"><span class="hljs-comment">// array(9) { // [0] =&gt; string(5) "class" // [1] =&gt; string(7) "Example" // [2] =&gt; string(1) "{" // [3] =&gt; string(2) "//" // [4] =&gt; string(5) "class" // [5] =&gt; string(7) "Example" // [6] =&gt; string(1) "{" // [7] =&gt; string(1) "}" // [8] =&gt; string(1) "}" //}</span></span></code> </pre><br>  Como voc√™ pode ver, recebemos um batente completamente banal nos elementos 3-5: O coment√°rio foi recebido inesperadamente e foi dividido em tokens, embora devesse ter sido considerado como um todo. <br><br>  Obviamente, com o PCRE funcional, esse token pode ser extra√≠do com a ajuda de uma simples regularidade " <i>// [^ \ n] * \ n</i> ", mas se n√£o for?  Ou queremos cort√°-lo com as m√£os?  Em resumo, no caso de um lexer de v√°rios estados - podemos dizer que todos os tokens devem estar no grupo <b>No1</b> , assim que o token " <i>//</i> " for encontrado, uma transi√ß√£o para o grupo <b>No2</b> dever√° ocorrer.  E dentro do segundo grupo, a transi√ß√£o reversa, se o token " <i>\ n</i> " for encontrado - a transi√ß√£o de volta para o primeiro grupo. <br><br>  Algo assim: <br><br><pre> <code class="php hljs">$tokens = [ <span class="hljs-string"><span class="hljs-string">'group-1'</span></span> =&gt; [ <span class="hljs-string"><span class="hljs-string">'class'</span></span>, <span class="hljs-string"><span class="hljs-string">'\w+'</span></span>, <span class="hljs-string"><span class="hljs-string">'{'</span></span>, <span class="hljs-string"><span class="hljs-string">'}'</span></span>, <span class="hljs-string"><span class="hljs-string">'//'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'group-2'</span></span> <span class="hljs-comment"><span class="hljs-comment">//      2 ], 'group-2' =&gt; [ "\n" =&gt; 'group-1', //    1    '.*' ] ];</span></span></code> </pre><br>  Acho que agora est√° ficando mais claro como o HEREDOC √© analisado, porque mesmo com todo o poder do PCRE, escrever um regular para este caso √© extremamente problem√°tico, j√° que essa sintaxe do HEREDOC suporta interpola√ß√£o vari√°vel.  Apenas tente analisar algo parecido com a fun√ß√£o <i>token_get_all interna</i> (note&gt; 12 token): <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> $example = <span class="hljs-number"><span class="hljs-number">42</span></span>; $a = &lt;&lt;&lt;EOL Your answer is $example !!! EOL; var_dump(token_get_all(file_get_contents(<span class="hljs-keyword"><span class="hljs-keyword">__FILE__</span></span>)));</code> </pre><br>  Bem, parece que estamos prontos para come√ßar a praticar. <br><br><h2>  Pr√°tica </h2><br>  Vamos lembrar o que temos em PHP para essas coisas?  Bem, √© claro, preg_match!  Ok, des√ßa.  O algoritmo baseado em preg_match √© implementado no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Hoa</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">nesta implementa√ß√£o do Phelxy</a> .  Sua tarefa √© bastante simples: <br><br><ol><li>  Temos em m√£os o texto fonte e uma s√©rie de regulares. </li><li>  Combinamos at√© encontrar algo adequado. </li><li>  Assim que encontrar uma pe√ßa, corte-a no texto e fa√ßa a correspond√™ncia. </li></ol><br>  Em forma de c√≥digo, ser√° algo parecido com isto: <br><br><div class="spoiler">  <b class="spoiler_title">Folha de c√≥digo</b> <div class="spoiler_text"><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleLexer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> array&lt;string&gt; */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $tokens = []; <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> array&lt;string&gt; $tokens */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(array $tokens)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($tokens <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $name =&gt; $definition) { <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;tokens[$name] = \sprintf(<span class="hljs-string"><span class="hljs-string">'/\G%s/isSum'</span></span>, $definition); } } <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> string $sources * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> iterable&amp;\Traversable&lt;string&gt; * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@throws</span></span></span><span class="hljs-comment"> RuntimeException */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string $sources)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">iterable</span></span></span><span class="hljs-function"> </span></span>{ [$offset, $length] = [<span class="hljs-number"><span class="hljs-number">0</span></span>, \strlen($sources)]; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ($offset &lt; $length) { [$name, $token] = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;next($sources, $offset); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> $name =&gt; $token; $offset += \strlen($token); } } <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> string $sources * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> int $offset * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> array&lt;string,string&gt; * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@throws</span></span></span><span class="hljs-comment"> RuntimeException */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">next</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string $sources, int $offset)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">array</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;tokens <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $name =&gt; $pcre) { \preg_match($pcre, $sources, $matches, <span class="hljs-number"><span class="hljs-number">0</span></span>, $offset); $token = \reset($matches); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (\count($matches) &amp;&amp; \strpos($sources, $token, $offset) === $offset) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [$name, $token]; } } <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> \RuntimeException(<span class="hljs-string"><span class="hljs-string">'Unrecognized token at offset '</span></span> . $offset); } }</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Usando uma folha de c√≥digo</b> <div class="spoiler_text"><pre> <code class="php hljs">$lexer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleLexer([ <span class="hljs-string"><span class="hljs-string">'T_CLASS'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'class'</span></span>, <span class="hljs-string"><span class="hljs-string">'T_CONST'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'\w+'</span></span>, <span class="hljs-string"><span class="hljs-string">'T_BRACE_OPEN'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'{'</span></span>, <span class="hljs-string"><span class="hljs-string">'T_BRACE_CLOSE'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'}'</span></span>, <span class="hljs-string"><span class="hljs-string">'T_WHITESPACE'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'\s+'</span></span>, ]); <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> \sprintf(<span class="hljs-string"><span class="hljs-string">'| %-10s | %-20s |'</span></span>, <span class="hljs-string"><span class="hljs-string">'VALUE'</span></span>, <span class="hljs-string"><span class="hljs-string">'NAME'</span></span>) . <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($lexer-&gt;lex(<span class="hljs-string"><span class="hljs-string">'class Example {}'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $name =&gt; $token) { <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> \sprintf(<span class="hljs-string"><span class="hljs-string">'| %-10s | %-20s |'</span></span>, <span class="hljs-string"><span class="hljs-string">'"'</span></span> . \trim($token, <span class="hljs-string"><span class="hljs-string">"\n"</span></span>) . <span class="hljs-string"><span class="hljs-string">'"'</span></span>, $name) . <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; }</code> </pre><br></div></div><br>  Essa abordagem √© bastante trivial e permite que alguns toques no teclado modifiquem o lexer na regi√£o do pr√≥ximo m√©todo (), adicionando uma transi√ß√£o entre estados e transformando essa pe√ßa de masturba√ß√£o em um lexer primitivo de v√°rios estados.  Na √°rea <i>$ this-&gt; tokens,</i> basta adicionar algo como <i>$ this-&gt; tokens [$ this-&gt; state]</i> . <br><br>  No entanto, al√©m do pr√≥prio primitivismo, h√° outra desvantagem, n√£o fatal, como pode acontecer, mas ainda assim ... Essa implementa√ß√£o √© incrivelmente lenta.  No i7 7600k, cujo dono por acaso eu sou por acaso - um algoritmo semelhante processa cerca de 400 tokens por segundo e com um aumento em suas varia√ß√µes (ou seja, as defini√ß√µes que passamos ao construtor) - pode diminuir a velocidade da mudan√ßa de presidentes na R√∫ssia ... desculpe  Eu queria dizer, √© claro, que funcionaria <b>muito lentamente</b> . <br><br>  Ok, o que podemos fazer?  Para iniciantes, voc√™ pode entender o que est√° acontecendo de errado.  O fato √© que toda vez que chamamos <b>preg_match</b> dentro da natureza da linguagem, um compilador com seu JIT chamado PCRE aumenta (e no PHP 7.3, o PCRE2 j√° est√°).  Cada vez que ele analisa os regulares e coleta um analisador para eles, com o qual analisamos o texto para criar fichas.  Parece um pouco estranho e tautol√≥gico.  Mas, resumindo, cada token requer compila√ß√£o de 1 a N regulares, onde N √© o n√∫mero de defini√ß√µes desses tokens.  Ao mesmo tempo, vale a pena notar que mesmo o sinalizador " <i>S</i> " aplicado e a otimiza√ß√£o usando " <i>\ G</i> " no construtor, onde express√µes regulares para tokens s√£o geradas, n√£o ajudam. <br><br>  Existe apenas uma maneira de sair dessa situa√ß√£o: voc√™ precisa analisar todo esse texto de uma s√≥ vez, ou seja,  executando apenas uma fun√ß√£o <b>preg_match</b> .  Resta resolver dois problemas: <br><br><ol><li>  Como indicar que o resultado da express√£o regular N1 corresponde ao token N2?  I.e.  como indicar que " <i>\ w +</i> ", por exemplo, √© <i>T_CONST</i> . </li><li>  Como determinar a sequ√™ncia de tokens como resultado.  Como voc√™ sabe, o resultado de <b>preg_match</b> ou <b>preg_match_all</b> conter√° tudo misturado.  E mesmo com a ajuda de bandeiras passadas como o quarto argumento, a situa√ß√£o n√£o mudar√°. </li></ol><br>  Aqui voc√™ pode fazer uma pausa e pensar um pouco.  Bem ou n√£o. <br><br>  A solu√ß√£o para o primeiro problema √© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">denominada grupos PCRE</a> , tamb√©m chamados de "sub-m√°scaras".  Usando as regras: " <i>(? &lt;T_WHITESPACE&gt; \ s + | &lt;T_WORD&gt; \ w + | ...)</i> ", voc√™ pode obter todos os tokens de uma s√≥ vez, comparando-os com seus nomes.  Como resultado da partida, uma matriz associativa ser√° formada, consistindo nos pares " <i>[TOKEN_NAME =&gt; TOKEN_VALUE]</i> ". <br><br>  O segundo √© um pouco mais complicado.  Mas aqui voc√™ pode aplicar um truque t√°tico e usar a fun√ß√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">preg_replace_callback</a> .  Sua peculiaridade √© que o anonimato passado como o segundo argumento ser√° chamado estritamente sequencialmente para cada token, do primeiro ao √∫ltimo. <br><br>  Para n√£o definhar - a implementa√ß√£o √© a seguinte: <br><br><div class="spoiler">  <b class="spoiler_title">Outra aba de c√≥digo</b> <div class="spoiler_text"><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PregReplaceLexer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> array&lt;string&gt; */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $tokens = []; <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> array&lt;string&gt; $tokens */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(array $tokens)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($tokens <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $name =&gt; $definition) { <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;tokens[] = \sprintf(<span class="hljs-string"><span class="hljs-string">'(?&lt;%s&gt;%s)'</span></span>, $name, $definition); } } <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> string $sources * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> iterable&amp;\Traversable&lt;string,string&gt; */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string $sources)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">iterable</span></span></span><span class="hljs-function"> </span></span>{ $result = []; \preg_replace_callback(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;compilePcre(), <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(array $matches)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(&amp;$result)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (\array_reverse($matches) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $name =&gt; $value) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (\is_string($name) &amp;&amp; $value !== <span class="hljs-string"><span class="hljs-string">''</span></span>) { $result[] = [$name, $value]; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } }, $sources); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($result <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> [$name, $value]) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> $name =&gt; $value; } } <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> string */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compilePcre</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> \sprintf(<span class="hljs-string"><span class="hljs-string">'/\G(?:%s)/isSum'</span></span>, \implode(<span class="hljs-string"><span class="hljs-string">'|'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;tokens)); } }</code> </pre><br></div></div><br>  E seu uso n√£o √© diferente da vers√£o anterior.  Ao mesmo tempo, a velocidade do trabalho aumenta de <b>400</b> para <b>57.000</b> tokens por segundo.  √â esse algoritmo que apliquei <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">na minha implementa√ß√£o</a> , assumindo a reescrita do c√≥digo-fonte Hoa.  A prop√≥sito, se voc√™ usa Parle, pode espremer at√© <b>600.000</b> tokens por segundo.  E a imagem geral se parece com isso (com o XDebug ativado no PHP 7.1, ent√£o os n√∫meros s√£o mais baixos, mas a propor√ß√£o pode ser representada aproximadamente). <br><br> <a href=""><img src="https://habrastorage.org/webt/rr/yw/qr/rrywqr04hb7lt5zdhdpmu8ppdc8.png"></a> <br><br><ul><li>  Amarelo √© a extens√£o nativa de Parle. </li><li>  Azul - implementa√ß√£o atrav√©s de <i>preg_replace_callback</i> com pr√©-montado regular. </li><li>  Vermelho - tudo a mesma coisa, mas com a <i>regularidade</i> gerada durante a chamada para <i>preg_replace_callback</i> . </li><li>  Verde - implementa√ß√£o atrav√©s de <i>preg_match</i> . </li></ul><br><h2>  Porque </h2><br>  Bem, tudo isso, √© claro, √© maravilhoso, mas os impacientes est√£o ansiosos para fazer a pergunta: "Quem precisa disso?"  No mundo abstrato do PHP, onde o princ√≠pio de "fig-fig-e-site-ready" domina - tais bibliotecas n√£o s√£o necess√°rias, seremos honestos.  Mas se falamos sobre o ecossistema como um todo, podemos lembrar as bibliotecas not√≥rias como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">symfony / yaml</a> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Doctrine</a> .  As anota√ß√µes no Symfony s√£o a mesma sub-linguagem no PHP, exigindo an√°lise lexical e sint√°tica separada.  Al√©m disso, existem transpilers CoffeeScript, Less e Scss / Sass ainda menos conhecidos, escritos em PHP.  Bem, ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Yay</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pr√©-processo com</a> base nisso.  Eu nem vou mencionar ferramentas de an√°lise de c√≥digo como phpmd ou phpcs.  E geradores de documenta√ß√£o como phpDocumentnor ou Sami s√£o bastante triviais.  Cada um desses projetos, em um grau ou outro, utiliza an√°lise lexical no primeiro est√°gio da an√°lise de texto / c√≥digo. <br><br>  Esta n√£o √© uma lista completa de projetos e, talvez, espero que minha hist√≥ria o ajude a descobrir algo novo e a reabastec√™-lo. <br><br><h2>  Posf√°cio </h2><br>  Olhando para o futuro, se houver algu√©m interessado no assunto de analisadores e compiladores, existem alguns relat√≥rios interessantes sobre esse t√≥pico, em particular dos caras do JetBrains: <br><br><div class="spoiler">  <b class="spoiler_title">V√≠deo</b> <div class="spoiler_text"><iframe width="560" height="315" src="https://www.youtube.com/embed/zI1QmnRRBMA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br></div></div><br>  Ainda assim, √© claro, a maioria das performances de Andrei <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">Breslav</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">abreslav</a> ), que pode ser encontrada na imensid√£o do YouTube - eu aconselho voc√™ a assistir. <br><br>  Bem, para os f√£s de fic√ß√£o, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">existe um recurso</a> que foi pessoalmente extremamente √∫til para mim. <br><br>  Post post scriptum.  Se voc√™ est√° em algum lugar selado na vastid√£o desse √©pico, pode informar com seguran√ßa o autor de qualquer forma conveniente para voc√™. <br><br>  Como um b√¥nus, eu gostaria de dar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">um exemplo de um simples lexer PHP</a> , parece que n√£o √© t√£o assustador agora, e agora ainda est√° claro o que faz, certo?  Embora a quem eu esteja enganando, os olhos sangram dos frequentadores.  =) <br><br>  Obrigada </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt435102/">https://habr.com/ru/post/pt435102/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt435088/index.html">A gigante chinesa de streaming Tencent Music abre capital p√∫blico - o que isso significa e o que os concorrentes devem esperar</a></li>
<li><a href="../pt435090/index.html">O grupo de motores Hyundai introduziu o conceito de carregamento sem fio e estacionamento aut√¥nomo</a></li>
<li><a href="../pt435094/index.html">Gamepad da Sega Mega Drive e Raspberry Pi Parte 2 (seis bot√µes finais)</a></li>
<li><a href="../pt435096/index.html">O efeito do r√°dio de tubo quente</a></li>
<li><a href="../pt435098/index.html">Spy Cam & Mic vs ADB</a></li>
<li><a href="../pt435106/index.html">Mais uma vez sobre o passport.js</a></li>
<li><a href="../pt435108/index.html">Usando o Prolog</a></li>
<li><a href="../pt435112/index.html">Entrevista corporativa</a></li>
<li><a href="../pt435114/index.html">Jpa de dados do Spring</a></li>
<li><a href="../pt435118/index.html">Save File Me - um servi√ßo de backup gratuito com criptografia do lado do cliente</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>