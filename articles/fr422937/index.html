<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏾‍🍳 📝 💅🏼 Mise en cache disque des arbres de calcul paresseux 📙 ⚗️ 👨🏻‍🎤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Le concept de l'informatique paresseuse ne mérite guère d'être abordé en détail. L'idée de faire la même chose moins souvent, surtout si elle est long...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mise en cache disque des arbres de calcul paresseux</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/422937/"><p>  Le concept de l'informatique paresseuse ne mérite guère d'être abordé en détail.  L'idée de faire la même chose moins souvent, surtout si elle est longue et lourde, est aussi vieille que le monde.  Parce que tout de suite au point. </p><br><p>  Selon l'auteur de ce texte, un lénifiant normal devrait: </p><br><ol><li>  Enregistrez les calculs entre les appels de programme. </li><li>  Suivez les changements dans l'arbre de calcul. </li><li>  Avoir une syntaxe modérément transparente. </li></ol><br><p><img src="https://habrastorage.org/webt/de/dw/ec/dedwectoekaqhwzkercd2dgnk1u.jpeg" alt="Arbre paresseux"></p><a name="habracut"></a><br><h2 id="koncepciya">  Concept </h2><br><p>  Pour: </p><br><ol><li> Enregistrez les calculs entre les appels de programme: <br>  En effet, si nous appelons le même script plusieurs dizaines de centaines de fois par jour, pourquoi devrions-nous recalculer le même chaque fois que le script est appelé, s'il est possible de stocker l'objet résultat dans un fichier.  Il vaut mieux retirer un objet du disque, mais ... il faut être sûr de sa pertinence.  Soudain, le script est réécrit et l'objet enregistré est obsolète.  Sur cette base, nous ne pouvons pas simplement charger l'objet sur l'existence d'un fichier.  Le deuxième point en découle. </li><li>  Suivez les changements dans l'arbre de calcul: <br>  La nécessité de mettre à jour l'objet doit être calculée à partir des données sur les arguments de la fonction qui le génère.  Nous allons donc être sûrs que l'objet chargé est valide.  En effet, pour une fonction pure, la valeur de retour ne dépend que des arguments.  Cela signifie que si nous mettons en cache les résultats des fonctions pures et surveillons le changement d'arguments, nous pouvons être calmes sur la pertinence du cache.  Dans le même temps, si l'objet calculé dépend d'un autre objet mis en cache (paresseux), qui à son tour en dépend un autre, vous devez déterminer correctement les modifications de ces objets, en mettant à jour en temps opportun les nœuds de chaîne qui ne sont plus pertinents.  En revanche, il serait intéressant de prendre en compte que nous n'avons pas toujours besoin de charger les données de toute la chaîne de calcul.  Souvent, le chargement de l'objet résultat final suffit. </li><li>  Avoir une syntaxe modérément transparente: <br>  Ce point est clair.  Si, pour réécrire le script en calculs paresseux, il est nécessaire de modifier tout le code, c'est une solution moyenne.  Des modifications doivent être apportées au minimum. </li></ol><br><p>  Ce raisonnement a conduit à une solution technique, stylisée en python par la bibliothèque evalcache (liens en fin d'article). </p><br><h2 id="sintaksicheskoe-reshenie-i-mehanizm-raboty">  Solution de syntaxe et mécanisme de travail </h2><br><div class="spoiler">  <b class="spoiler_title">Exemple simple</b> <div class="spoiler_text"><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> evalcache <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> hashlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> shelve lazy = evalcache.Lazy(cache = shelve.open(<span class="hljs-string"><span class="hljs-string">".cache"</span></span>), algo = hashlib.sha256) @lazy <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">summ</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a,b,c)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + b + c @lazy <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sqr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a * a a = <span class="hljs-number"><span class="hljs-number">1</span></span> b = sqr(<span class="hljs-number"><span class="hljs-number">2</span></span>) c = lazy(<span class="hljs-number"><span class="hljs-number">3</span></span>) lazyresult = summ(a, b, c) result = lazyresult.unlazy() print(lazyresult) <span class="hljs-comment"><span class="hljs-comment">#f8a871cd8c85850f6bf2ec96b223de2d302dd7f38c749867c2851deb0b24315c print(result) #8</span></span></code> </pre> </div></div><br><p>  Comment ça marche? </p><br><p>  La première chose qui attire votre attention ici est la création du décorateur paresseux.  Une telle solution syntaxique est assez standard pour les pythons Python.  Le décorateur paresseux reçoit un objet cache dans lequel le lénificateur stockera les résultats des calculs.  Les exigences de l'interface de type dict sont superposées au type de cache.  En d'autres termes, nous pouvons mettre en cache tout ce qui implémente la même interface que le type dict.  Pour démontrer dans l'exemple ci-dessus, nous avons utilisé le dictionnaire de la bibliothèque Shelve. </p><br><p>  Le décorateur reçoit également un protocole de hachage, qu'il utilisera pour construire des clés de hachage d'objets et quelques options supplémentaires (autorisation d'écriture, autorisation de lecture, sortie de débogage), qui peuvent être trouvées dans la documentation ou le code. </p><br><p>  Le décorateur peut être appliqué aux fonctions et aux objets d'autres types.  À ce moment, un objet paresseux est construit sur leur base avec une clé de hachage calculée sur la base de la représentation (ou en utilisant une fonction de hachage spécialement définie pour ce type de fonction). </p><br><p>  Une caractéristique clé de la bibliothèque est qu'un objet paresseux peut engendrer d'autres objets paresseux, et le hachage du parent (ou des parents) sera mélangé dans la clé de hachage du descendant.  Pour les objets paresseux, il est autorisé d'utiliser l'opération de prise d'un attribut, l'utilisation d'appels ( <code>__call__</code> ) d'objets et l'utilisation d'opérateurs. </p><br><p>  En passant par un script, en fait, aucun calcul n'est effectué.  Pour b, le carré n'est pas calculé et pour lazyresult, la somme des arguments n'est pas prise en compte.  Au lieu de cela, un arbre d'opérations est construit et les clés de hachage des objets paresseux sont calculées. </p><br><p>  Les calculs réels (si le résultat n'a pas été précédemment mis dans le cache) seront effectués uniquement dans la ligne: <code>result = lazyresult.unlazy()</code> </p><br><p>  Si l'objet a été calculé précédemment, il sera chargé à partir du fichier. <br>  Vous pouvez visualiser l'arborescence de construction: </p><br><div class="spoiler">  <b class="spoiler_title">Construire une visualisation d'arbre</b> <div class="spoiler_text"><pre> <code class="python hljs">evalcache.print_tree(lazyresult) ... generic: &lt;function summ at <span class="hljs-number"><span class="hljs-number">0x7f1cfc0d5048</span></span>&gt; args: <span class="hljs-number"><span class="hljs-number">1</span></span> generic: &lt;function sqr at <span class="hljs-number"><span class="hljs-number">0x7f1cf9af29d8</span></span>&gt; args: <span class="hljs-number"><span class="hljs-number">2</span></span> ------- <span class="hljs-number"><span class="hljs-number">3</span></span> -------</code> </pre> </div></div><br><p>  Comme les hachages d'objets sont construits sur la base de données sur les arguments qui génèrent ces objets, lorsque l'argument change, le hachage de l'objet change et avec lui les hachages de la chaîne entière en fonction.  Cela vous permet de garder les données du cache à jour en effectuant des mises à jour à temps. </p><br><p>  Des objets paresseux s'alignent dans un arbre.  Si nous effectuons une opération non perturbée sur l'un des objets, exactement autant d'objets seront chargés et comptés que nécessaire pour obtenir un résultat valide.  Idéalement, l'objet nécessaire se chargera simplement.  Dans ce cas, l'algorithme ne tirera pas les objets en formation dans la mémoire. </p><br><h2 id="v-deystvii">  En action </h2><br><p>  Ci-dessus était un exemple simple qui montre la syntaxe mais ne démontre pas la puissance de calcul de l'approche. <br>  Voici un exemple un peu plus proche de la vie réelle (en utilisant sympy). </p><br><div class="spoiler">  <b class="spoiler_title">Exemple utilisant sympy et numpy</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/python3.5 from sympy import * import numpy as np import math import evalcache lazy = evalcache.Lazy(evalcache.DirCache(".evalcache"), diag = True) pj1, psi, y0, gamma, gr= symbols("pj1 psi y0 gamma gr") ###################### Construct sympy expression ##################### F = 2500 xright = 625 re = 625 y0 = 1650 gr = 2*math.pi / 360 #gamma = pi / 2 xj1q = xright + re * (1 - cos(psi)) yj1q = (xright + re) * tan(psi) - re * sin(psi) #+ y0 pj1 = sqrt(xj1q**2 + yj1q**2) pj2 = pj1 + y0 * sin(psi) zj2 = (pj2**2)/4/F asqrt = sqrt(pj2**2 + 4*F**2) xp2 = 2*F / asqrt yp2 = pj2 / asqrt xp3 = yp2 yp3 = -xp2 xmpsi = 1295 gmpsi = 106 * gr aepsi = 600 bepsi = 125 b = 0.5*(1-cos(pi * gamma / gmpsi)) p1 = ( (gamma * xmpsi / gmpsi * xp2) * (1-b) + (aepsi * xp2 * sin(gamma) + bepsi * yp2 * (1-cos(gamma)))*b + pj1 ) ####################################################################### #First lazy node. Simplify is long operation. #Sympy has very good representations for expressions print("Expression:", repr(p1)) print() p1 = lazy(simplify)(p1) ######################################################################################### ## Really don't need to lazify fast operations Na = 200 angles = [t * 2 * math.pi / 360 / Na * 106 for t in range(0,Na+1)] N = int(200) a = (np.arange(0,N+1) - N/2) * 90/360*2*math.pi/N ######################################################################################### @lazy def genarray(angles, a, p1): points = [] for i in range(0, len(angles)): ex = p1.subs(gamma, angles[i]) func = lambdify(psi, ex, 'numpy') # returns a numpy-ready function rads = func(a) xs = rads*np.cos(a) ys = rads*np.sin(a) arr = np.column_stack((xs,ys,[i*2]*len(xs))) points.append(arr) return points #Second lazy node. arr = genarray(angles, a, p1).unlazy() print("\nResult list:", arr.__class__, len(arr))</span></span></code> </pre> </div></div><br><p>  Les opérations de simplification des expressions symboliques sont extrêmement coûteuses et demandent littéralement une lénification.  La construction d'un grand tableau prend encore plus de temps, mais grâce à la lénification, les résultats seront extraits du cache.  Veuillez noter que si certains coefficients sont modifiés en haut du script où l'expression sympy est générée, les résultats seront recalculés car la clé de hachage de l'objet paresseux changera (grâce aux <code>__repr__</code> ). </p><br><p>  Très souvent, une situation se produit lorsqu'un chercheur effectue des expériences de calcul sur un objet généré depuis longtemps.  Il peut utiliser plusieurs scripts pour séparer la génération et l'utilisation de l'objet, ce qui peut entraîner des problèmes de mise à jour intempestive des données.  L'approche proposée peut faciliter ce cas. </p><br><h2 id="radi-chego-vsyo-zatevalos">  De quoi s'agit-il? </h2><br><p>  evalcache fait partie du projet zencad.  Il s'agit d'un petit script cadique, inspiré et exploitant les mêmes idées que openscad.  Contrairement à openscad orienté maillage, zencad s'exécutant sur le noyau opencascade utilise une représentation brep des objets et les scripts sont écrits en python. </p><br><p>  Les opérations géométriques sont souvent effectuées pendant longtemps.  L'inconvénient des systèmes de script CAO est que chaque fois que vous exécutez le script, le produit est à nouveau entièrement recompté.  De plus, avec la croissance et la complication du modèle, les frais généraux ne croissent pas de façon linéaire.  Cela conduit au fait que vous ne pouvez travailler confortablement qu'avec des modèles extrêmement petits. </p><br><p>  La tâche d'evalcache était de résoudre ce problème.  Dans zencad, toutes les opérations sont déclarées paresseuses. </p><br><p>  Exemples: </p><br><div class="spoiler">  <b class="spoiler_title">Exemple de construction de modèle</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/python3 #coding: utf-8 from zencad import * xgate = 14.65 ygate = 11.6 zgate = 11 t = (xgate - 11.7) / 2 ear_r = 8.6/2 ear_w = 7.8 - ear_r ear_z = 3 hx_h = 2.0 bx = xgate + ear_w by = 2 bz = ear_z+1 gate = ( box(xgate, ygate, t).up(zgate - t) + box(t, ygate, zgate) + box(t, ygate, zgate).right(xgate - t) ) gate = gate.fillet(1, [5, 23,29, 76]) gate = gate.left(xgate/2) ear = (box(ear_w, ear_r * 2, ear_z) + cylinder(r = ear_r, h = ear_z).forw(ear_r).right(ear_w)).right(xgate/2 - t) hx = linear_extrude( ngon(r = 2.5, n = 6).rotateZ(deg(90)).forw(ear_r), hx_h ).up(ear_z - hx_h).right(xgate/2 -t + ear_w) m = ( gate + ear + ear.mirrorYZ() - hx - hx.mirrorYZ() - box(xgate-2*t, ygate, zgate, center = True).forw(ygate/2) - box(bx, by, bz, center = True).forw(ear_r).up(bz/2) - cylinder(r = 2/2, h = 100, center = True).right(xgate/2-t+ear_w).forw(ear_r) - cylinder(r = 2/2, h = 100, center = True).left(xgate/2-t+ear_w).forw(ear_r) ) display(m) show()</span></span></code> </pre> <br><p>  Ce script génère le modèle suivant: <br><img src="https://habrastorage.org/webt/np/4i/go/np4igo9nth8jdmuplhz6pd2o9mg.png"><br>  Notez qu'il n'y a pas d'appels evalcache dans le script.  L'astuce est que la lénification est intégrée dans la bibliothèque zencad elle-même et n'est même pas visible à première vue, bien que tout le travail ici fonctionne avec des objets paresseux, et le calcul direct se fait uniquement dans la fonction `` affichage ''.  Bien sûr, si certains paramètres du modèle sont modifiés, le modèle sera recompté à l'endroit où la première clé de hachage a été modifiée. </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Modèles informatiques volumineux</b> <div class="spoiler_text"><p>  Voici un autre exemple.  Cette fois, nous nous limiterons aux images: <br><img src="https://habrastorage.org/webt/go/3f/zu/go3fzuma_btpyqlvqsb8zxnc6qc.png"><br>  Le calcul d'une surface filetée n'est pas une tâche facile.  Sur mon ordinateur, un tel boulon est construit en dix secondes environ ... L'édition d'un modèle avec des threads est beaucoup plus agréable grâce à la mise en cache. </p><br><p>  Et maintenant, c'est un miracle: <br><img src="https://habrastorage.org/webt/ux/qs/kc/uxqskci0b_u_3cfdghkpdliygou.png"><br>  Le croisement de surfaces filetées est une tâche de calcul complexe.  Valeur pratique, cependant, rien d'autre que la vérification des mathématiques.  Le calcul prend une minute et demie.  Un objectif louable pour la lénification. </p></div></div><br><h2 id="problemy">  Les problèmes </h2><br><p>  Le cache peut ne pas fonctionner comme prévu. <br>  Les erreurs de cache peuvent être divisées en <strong>faux positifs</strong> et <strong>faux négatifs</strong> . </p><br><h3 id="lozhnootricatelnye-oshibki">  Fausses erreurs négatives </h3><br><p>  Les fausses erreurs négatives sont des situations où le résultat du calcul est dans le cache, mais le système ne l'a pas trouvé. <br>  Cela se produit si l'algorithme de clé de hachage utilisé par evalcache pour une raison quelconque a produit une clé différente pour le recalcul.  Si la fonction de hachage n'est pas remplacée pour l'objet du type mis en cache, evalcache utilise le <code>__repr__</code> objet pour construire la clé. <br>  Une erreur se produit, par exemple, si la classe louée ne remplace pas l' <code>object.__repr__</code> standard <code>object.__repr__</code> , qui change de début en début.  Ou, si le <code>__repr__</code> substitué, dépend en quelque sorte d'insignifiant pour le calcul des données changeantes (comme l'adresse de l'objet ou l'horodatage). </p><br><p>  Mauvais: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.i = <span class="hljs-number"><span class="hljs-number">3</span></span> A_lazy = lazy(A) A_lazy().unlazy() <span class="hljs-comment"><span class="hljs-comment">#        -  __repr__.</span></span></code> </pre> <br><p>  Bon: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.i = <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__repr__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"A({})"</span></span>.format(self.i) A_lazy = lazy(A) A_lazy().unlazy() <span class="hljs-comment"><span class="hljs-comment">#     .</span></span></code> </pre> <br><p>  Les fausses erreurs négatives conduisent au fait que la lénification ne fonctionne pas.  L'objet sera recompté à chaque nouvelle exécution de script. </p><br><h3 id="lozhnopolozhitelnye-oshibki">  Fausses erreurs positives </h3><br><p>  Il s'agit d'un type d'erreur plus ignoble, car il conduit à des erreurs dans l'objet final du calcul: <br>  Cela peut arriver pour deux raisons. </p><br><ul><li>  Incroyable: <br>  Une collision de clés de hachage s'est produite dans le cache.  Pour l'algorithme sha256 ayant un espace de 115792089237316195423570985008687907853269984665640564039457584007913129639936 clés possibles, la probabilité d'une collision est négligeable. </li><li>  Probable: <br>  Une représentation d'un objet (ou d'une fonction de hachage remplacée) ne le décrit pas complètement, ou coïncide avec une représentation d'un objet d'un autre type. </li></ul><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.i = <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__repr__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"({})"</span></span>.format(self.i) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.i = <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__repr__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"({})"</span></span>.format(self.i) A_lazy = lazy(A) B_lazy = lazy(B) a = A_lazy().unlazy() b = B_lazy().unlazy() <span class="hljs-comment"><span class="hljs-comment">#.     B,        A.</span></span></code> </pre> <br><p>  Les deux problèmes sont liés à un objet <code>__repr__</code> incompatible.  Si, pour une raison quelconque, il est impossible d'écraser le type d'objet <code>__repr__</code> , la bibliothèque vous permet de définir une fonction de hachage spéciale pour le type d'utilisateur. </p><br><h2 id="ob-analogah">  À propos des analogues </h2><br><p>  Il existe de nombreuses bibliothèques de lénification qui, fondamentalement, considèrent qu'il suffit d'exécuter un calcul pas plus d'une fois par appel de script. </p><br><p>  Il existe de nombreuses bibliothèques de mise en cache de disque qui, à votre demande, enregistreront un objet avec la clé nécessaire pour vous. </p><br><p>  Mais je ne pouvais toujours pas trouver de bibliothèques qui permettraient la mise en cache des résultats sur l'arbre d'exécution.  S'il y en a, s'il vous plaît, dangereux. </p><br><p>  Références: </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Projet Github</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Projet Pypi</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr422937/">https://habr.com/ru/post/fr422937/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr422923/index.html">Comment marquer la journée du programmeur sans décorer le ficus de bureau avec des zéros et des uns</a></li>
<li><a href="../fr422925/index.html">Entretien avec le président de la conférence RubyRussia Godfrey Chan</a></li>
<li><a href="../fr422929/index.html">Yandex Mail [était] indisponible pendant environ une heure à 12 h 16, heure de Moscou</a></li>
<li><a href="../fr422931/index.html">Nous regardons les outils de surveillance des applications distribuées</a></li>
<li><a href="../fr422935/index.html">2GIS est à portée de main. Comment nous avons ajouté une carte à l'Apple Watch</a></li>
<li><a href="../fr422939/index.html">Le livre "Kali Linux des développeurs"</a></li>
<li><a href="../fr422941/index.html">«Trois dans un bateau, la pauvreté et les chiens», ou comment l'antiplagiat cherche la paraphrase</a></li>
<li><a href="../fr422943/index.html">Un peu sur l'exploitation minière industrielle</a></li>
<li><a href="../fr422945/index.html">27 septembre, Moscou - Mitap QIWI SERVER PARTY 3.0</a></li>
<li><a href="../fr422947/index.html">Comment configurer l'archivage des sauvegardes Veeam dans Microsoft Azure Blob Storage à l'aide de StarWind VTL</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>