<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üõ°Ô∏è üíà ü§ôüèæ Reverse Engineering des NES-Emulators im Spiel f√ºr GameCube üò≠ üê´ üõåüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="W√§hrend ich nach M√∂glichkeiten suchte, die in Animal Crossing verbleibenden Entwicklermen√ºs zu aktivieren, einschlie√ülich des Spielauswahlmen√ºs f√ºr de...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Reverse Engineering des NES-Emulators im Spiel f√ºr GameCube</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/417117/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/499/dc8/2e4/499dc82e445ffd6bfd607d4f834ccd5a.png" alt="Bild"></div><br>  W√§hrend ich nach M√∂glichkeiten suchte, die in Animal Crossing verbleibenden Entwicklermen√ºs zu aktivieren, einschlie√ülich des Spielauswahlmen√ºs f√ºr den NES-Emulator, fand ich eine interessante Funktion, die im urspr√ºnglichen Spiel vorhanden war und st√§ndig aktiv war, aber von Nintendo nie verwendet wurde. <br><br>  Zus√§tzlich zu den NES / Famicom-Spielen im Spiel k√∂nnen Sie neue NES-Spiele von einer Speicherkarte herunterladen. <br><br>  Ich habe auch einen Weg gefunden, diesen ROM-Bootloader zu verwenden, um meinen Code und meine Daten in das Spiel zu patchen, wodurch Sie Code √ºber eine Speicherkarte ausf√ºhren k√∂nnen. <br><br><h2>  Einf√ºhrung - NES-Konsolenobjekte </h2><br>  Gew√∂hnliche NES-Spiele, die bei Animal Crossing erh√§ltlich sind, sind separate M√∂belst√ºcke in Form einer NES-Konsole mit einer darauf liegenden Patrone. <br><br>  Nachdem Sie dieses Objekt in Ihrem Haus gefunden und mit ihm interagiert haben, k√∂nnen Sie dieses einzige Spiel ausf√ºhren.  Das Bild unten zeigt Excitebike und Golf. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/40e/e33/409/40ee334095bd1151c3c968a84f8cf92b.png"></div><a name="habracut"></a><br>  Es gibt auch ein allgemeines NES-Konsolenobjekt, in dem keine integrierten Spiele vorhanden sind.  Es kann bei Redd gekauft und manchmal durch zuf√§llige Ereignisse erhalten werden, indem beispielsweise an der Pinnwand der Stadt gelesen wird, dass die Konsole an einem zuf√§lligen Punkt in der Stadt vergraben ist. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f41/d20/687/f41d20687aed7d6a4d044a5a5d084045.png"></div><br>  Dieses Objekt sieht aus wie eine NES-Konsole, auf der sich keine Kassetten befinden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/35c/010/9a3/35c0109a32b31deeb202280773f363a0.png"></div><br>  Das Problem mit diesem Objekt ist, dass es als nicht spielbar angesehen wurde.  Jedes Mal, wenn Sie mit ihm interagieren, sehen Sie eine Meldung, dass Sie keine Spielesoftware haben. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a9e/6d3/3b8/a9e6d33b8e039a2f17c12fd134cf0308.png"></div><br>  Es stellte sich heraus, dass dieses Objekt tats√§chlich versucht, die Speicherkarte nach speziell entwickelten Dateien zu durchsuchen, die ROM-Images f√ºr NES enthalten!  Der zum Ausf√ºhren eingebetteter Spiele verwendete NES-Emulator scheint der vollst√§ndige Standard-NES-Emulator f√ºr den GameCube zu sein und kann die meisten Spiele starten. <br><br>  Bevor ich diese Funktionen demonstriere, werde ich den Prozess des Reverse Engineering erl√§utern. <br><br><h2>  Suchen Sie den ROM-Bootloader auf der Speicherkarte </h2><br><h3>  Wir suchen ein Entwicklermen√º </h3><br>  Zun√§chst wollte ich einen Code finden, der verschiedene Entwicklermen√ºs aktiviert, z. B. das Kartenauswahlmen√º oder das Spielauswahlmen√º f√ºr den NES-Emulator.  Das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Forest Map Select-</a> Men√º, mit dem Sie problemlos verschiedene Orte des Spiels laden k√∂nnen, war recht einfach zu finden. Ich habe nur nach der Zeile FOREST MAP SELECT gesucht, die oben auf dem Bildschirm angezeigt wird (sie ist in verschiedenen Videos und Screenshots im Internet zu sehen ) <br><br>  In ‚ÄûFOREST MAP SELECT‚Äú gibt es Querverweise von Daten auf die Funktion <code>select_print_wait</code> , was zu einer Reihe anderer Funktionen f√ºhrt, die ebenfalls das Pr√§fix <code>select_*</code> , einschlie√ülich der Funktion <code>select_init</code> .  Es stellte sich heraus, dass es sich um Funktionen handelte, die das Kartenauswahlmen√º steuern. <br><br>  Die Funktion <code>select_init</code> f√ºhrt zu einer weiteren interessanten Funktion namens <code>game_get_next_game_dlftbl</code> .  Diese Funktion verkn√ºpft alle anderen Men√ºs und ‚ÄûSzenen‚Äú, die Sie ausf√ºhren k√∂nnen: einen Bildschirm mit dem Nintendo-Logo, den Hauptbildschirm, das Kartenauswahlmen√º, das NES-Emulatormen√º (Famicom) usw.  Es beginnt am Anfang der Hauptspielprozedur, findet heraus, welche <code>game_dlftbls</code> soll, und findet seinen Eintrag in der Tabellendatenstruktur mit dem Namen <code>game_dlftbls</code> .  Diese Tabelle enth√§lt Links zu den Verarbeitungsfunktionen verschiedener Szenen sowie einige andere Daten. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d93/cbc/019/d93cbc0191a754e6bb566525f1a21666.png"></div><br>  Eine sorgf√§ltige Untersuchung des ersten Blocks der Funktion ergab, dass die Funktion "next game init" geladen wird, und beginnt dann, sie mit einer Reihe bekannter init-Funktionen zu vergleichen: <br><br><ul><li> <code>first_game_init</code> </li> <li> <code>select_init</code> </li> <li> <code>play_init</code> </li> <li> <code>second_game_init</code> </li> <li> <code>trademark_init</code> </li> <li> <code>player_select_init</code> </li> <li> <code>save_menu_init</code> </li> <li> <code>famicom_emu_init</code> </li> <li> <code>prenmi_init</code> </li> </ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2e6/785/bae/2e6785bae4c526f3acba034d4f7e4b2e.png"></div><br>  Einer der Funktionszeiger, nach denen er sucht, ist <code>famicom_emu_init</code> , der f√ºr die Ausf√ºhrung des NES / Famicom-Emulators verantwortlich ist.  <code>game_get_next_game_init</code> Ergebnisses von <code>game_get_next_game_init</code> auf <code>famicom_emu_init</code> oder <code>select_init</code> im Dolphin-Debugger konnte ich spezielle Men√ºs anzeigen.  Der n√§chste Schritt besteht darin, zu bestimmen, wie diese Zeiger w√§hrend der Programmausf√ºhrung auf normale Weise gesetzt werden.  Die Funktion <code>game_get_next_game_init</code> l√§dt nur den Wert bei Offset <code>0xC</code> ersten Arguments in <code>game_get_next_game_dlftbl</code> . <br><br>  Das Verfolgen dieser in verschiedenen Datenstrukturen festgelegten Werte war etwas langweilig, daher gehe ich direkt zum Kern.  Das Wichtigste, was ich gefunden habe: <br><br><ul><li>  Wenn das Spiel auf die √ºbliche Weise startet, f√ºhrt es die folgende Abfolge von Aktionen aus: <br><ul><li> <code>first_game_init</code> </li> <li> <code>second_game_init</code> </li> <li> <code>trademark_init</code> </li> <li> <code>play_init</code> </li> </ul></li><li>  <code>player_select_init</code> setzt den n√§chsten Init auf <code>select_init</code> .  Dieser Bildschirm sollte es Ihnen erm√∂glichen, einen Spieler unmittelbar nach der Auswahl einer Karte auszuw√§hlen, aber es scheint, dass er nicht richtig funktioniert. </li></ul><br>  Ich habe auch eine namenlose Funktion gefunden, die die Init-Funktion des Emulators definiert, aber ich habe nichts gefunden, das die Init-Funktion auf den Init-Wert des Players oder der Kartenauswahl setzt. <br><br>  Zu diesem Zeitpunkt wurde mir klar, dass ich ein weiteres dummes Problem mit dem Laden von Funktionsnamen in die IDA hatte: Aufgrund des regul√§ren Ausdrucks zum Ausschneiden von Zeilen in der Debug-Symboldatei habe ich alle Funktionsnamen verpasst, die mit einem Gro√übuchstaben beginnen .  Die von <code>famicom_emu_init</code> eingerichtete Funktion sah aus wie √úberg√§nge zwischen Szenen und hie√ü <code>Game_play_fbdemo_wipe_proc</code> . <br><br>  <code>Game_play_fbdemo_wipe_proc</code> verarbeitet √úberg√§nge zwischen Szenen, wie z. B. Bildschirml√∂schungen und Stromausf√§lle. <br><br>  Unter bestimmten Bedingungen wurde der Bildschirm√ºbergang vom √ºblichen Gameplay zur Anzeige des Emulators durchgef√ºhrt.  Er hat die Emulator-Init-Funktion eingestellt. <br><br><h3>  Umgang mit Konsolenobjekten </h3><br>  Tats√§chlich wechseln Handler von M√∂belobjekten f√ºr NES-Konsolen den Bildschirm√ºbergangshandler zum Emulator.  Wenn ein Spieler mit einer der Konsolen <code>aMR_FamicomEmuCommonMove</code> , wird <code>aMR_FamicomEmuCommonMove</code> . <br><br>  Beim Aufrufen der Funktion enth√§lt <code>r6</code> den Indexwert, der den Zahlen in den Namen der NES- <code>famicom.arc</code> in <code>famicom.arc</code> : <br><br><ul><li> <code>01_nes_cluclu3.bin.szs</code> </li> <li> <code>02_usa_balloon.nes.szs</code> </li> <li> <code>03_nes_donkey1_3.bin.szs</code> </li> <li> <code>04_usa_jr_math.nes.szs</code> </li> <li> <code>05_pinball_1.nes.szs</code> </li> <li> <code>06_nes_tennis3.bin.szs</code> </li> <li> <code>07_usa_golf.nes.szs</code> </li> <li> <code>08_punch_wh.nes.szs</code> </li> <li> <code>09_usa_baseball_1.nes.szs</code> </li> <li> <code>10_cluclu_1.qd.szs</code> </li> <li> <code>11_usa_donkey3.nes.szs</code> </li> <li> <code>12_donkeyjr_1.nes.szs</code> </li> <li> <code>13_soccer.nes.szs</code> </li> <li> <code>14_exbike.nes.szs</code> </li> <li> <code>15_usa_wario.nes.szs</code> </li> <li> <code>16_usa_icecl.nes.szs</code> </li> <li> <code>17_nes_mario1_2.bin.szs</code> </li> <li> <code>18_smario_0.nes.szs</code> </li> <li> <code>19_usa_zelda1_1.nes.szs</code> </li> </ul><br>  ( <code>.arc</code> ist ein propriet√§res Dateiarchivformat.) <br><br>  Wenn <code>r6</code> ungleich Null ist, wird es in <code>aMR_RequestStartEmu</code> Aufruf von <code>aMR_RequestStartEmu</code> .  In diesem Fall wird der √úbergang zum Emulator ausgel√∂st. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f78/268/1d7/f782681d712b4098ad6f9269cf2df5cc.png"></div><br>  Wenn jedoch <code>r6</code> Null ist, wird <code>aMR_RequestStartEmu_MemoryC</code> die Funktion <code>aMR_RequestStartEmu_MemoryC</code> aufgerufen.  Wenn Sie den Wert im Debugger auf 0 setzen, wird die Meldung "Ich habe keine Software" angezeigt.  Ich habe mich nicht sofort daran erinnert, dass ich das NES-Konsolenobjekt √ºberpr√ºfen musste, um sicherzustellen, dass es den <code>r6</code> Wert zur√ºcksetzt, aber es stellte sich heraus, dass der Nullindex f√ºr das Konsolenobjekt ohne Kassette verwendet wird. <br><br>  Obwohl <code>aMR_RequestStartEmu</code> den Indexwert einfach in einer Art Datenstruktur <code>aMR_RequestStartEmu_MemoryC</code> f√ºhrt <code>aMR_RequestStartEmu_MemoryC</code> viel komplexere Operationen aus ... <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d23/844/831/d23844831e1e9f9b8ef5b6a4306948ab.png"></div><br>  Dieser dritte Codeblock ruft <code>aMR_GetCardFamicomCount</code> und <code>aMR_GetCardFamicomCount</code> nach einem Ergebnis ungleich Null. Andernfalls werden die meisten interessanten Dinge auf der linken Seite des Funktionsdiagramms √ºbersprungen. <br><br>  <code>aMR_GetCardFamicomCount</code> ruft <code>famicom_get_disksystem_titles</code> , das dann <code>memcard_game_list</code> , und hier wird alles sehr interessant. <br><br>  <code>memcard_game_list</code> die Speicherkarte <code>memcard_game_list</code> und beginnt im <code>memcard_game_list</code> , wobei jeder der einzelnen Werte <code>memcard_game_list</code> .  Durch Verfolgen der Funktion im Debugger konnte ich verstehen, dass die Werte mit jeder meiner Dateien auf der Speicherkarte verglichen wurden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/da1/e17/dd1/da1e17dd1b1acd6552eeeabaedc586fb.png"></div><br>  Die Funktion entscheidet abh√§ngig von den Ergebnissen der √úberpr√ºfung mehrerer Zeilen, ob die Datei heruntergeladen werden soll oder nicht.  Zun√§chst wird das Vorhandensein der Zeilen ‚ÄûGAFE‚Äú und ‚Äû01‚Äú √ºberpr√ºft, die die Kennungen des Spiels und des Unternehmens darstellen.  01 steht f√ºr Nintendo, GAFE steht f√ºr Animal Crossing.  Ich denke, es steht f√ºr GameCube Animal Forest English. <br><br>  Sie √ºberpr√ºft dann die Zeilen "DobutsunomoriP_F_" und "SAVE".  In diesem Fall sollte die erste Zeile √ºbereinstimmen, nicht jedoch die zweite.  Es stellte sich heraus, dass "DobutsunomoriP_F_SAVE" der Name der Datei ist, in der die Daten der eingebetteten Spiele f√ºr NES gespeichert sind.  Daher werden alle Dateien au√üer dieser mit dem Pr√§fix "DobutsunomoriP_F_" geladen. <br><br>  Mit dem Dolphin-Debugger, um Zeichenfolgenvergleiche mit "SAVE" zu √ºberspringen und den Spieltrick zu machen, um zu glauben, dass meine "SAVE" -Datei sicher heruntergeladen werden kann, habe ich dieses Men√º nach Verwendung der NES-Konsole erhalten: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d4/1d2/696/1d41d26963aeaf11450155f1d7d53085.png"></div><br>  Ich antwortete mit "Ja" und versuchte, die Sicherungsdatei als Spiel zu laden. Danach sah ich zum ersten Mal den eingebauten Spielabsturzbildschirm: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/41e/662/4cc/41e6624cc68fe28e897cd1803ba1a39a.png"></div><br>  Gro√üartig!  Jetzt wei√ü ich, dass sie tats√§chlich versucht, Spiele von einer Speicherkarte herunterzuladen, und ich kann mit der Analyse des Formats f√ºr die Sicherungsdateien beginnen, um festzustellen, ob ein echtes ROM heruntergeladen werden kann. <br><br>  Als erstes habe ich versucht herauszufinden, wo der Name des Spiels aus der Speicherkartendatei gelesen wird.  Beim Durchsuchen der Zeile "FEFSC", die in der Meldung "M√∂chten Sie &lt;Name&gt; spielen?" <code>0x642</code> war, fand ich den Offset, mit dem es aus der Datei gelesen wurde: <code>0x642</code> .  Ich habe die Sicherungsdatei kopiert, den Dateinamen in "DobutsunomoriP_F_TEST" ge√§ndert, die Bytes am Offset <code>0x642</code> in "TESTING" ge√§ndert und die ge√§nderte Speicherung importiert. <code>0x642</code> der gew√ºnschte Name im Men√º angezeigt. <br><br>  Nach dem Hinzuf√ºgen einiger weiterer Dateien in diesem Format wurden im Men√º einige weitere Optionen angezeigt: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/235/ca3/668/235ca3668ae0a02ad2609847bdf193c0.png"></div><br><h3>  ROM herunterladen </h3><br>  Wenn <code>aMR_GetCardFamicomCount</code> ungleich Null zur√ºckgegeben wird, wird der Speicher auf dem Heap zugewiesen. <code>famicom_get_disksystem_titles</code> wird direkt <code>famicom_get_disksystem_titles</code> aufgerufen. Anschlie√üend werden in der Datenstruktur eine Reihe zuf√§lliger Offsets angegeben.  Anstatt zu entschl√ºsseln, wo diese Werte gelesen werden, begann ich, die Liste der <code>famicom</code> Funktionen zu studieren. <br><br>  Es stellte sich heraus, dass ich <code>famicom_rom_load</code> brauchte.  Es steuert das Laden des ROM entweder von einer Speicherkarte oder von internen Ressourcen des Spiels. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/999/22b/462/99922b462892ef544d45e849da1c54a5.png"></div><br>  Das Wichtigste in diesem Block "Boot von Speicherkarte" ist, dass er aufruft <br>  <code>memcard_game_load</code> .  Sie legt die Datei erneut auf die Speicherkarte, liest sie und analysiert sie.  Hier werden die wichtigsten Dateiformatoptionen deutlich. <br><br><h4>  Pr√ºfsummenwert </h4><br>  Das erste, was nach dem Hochladen der Datei passiert, ist die Pr√ºfsummenberechnung.  Die Funktion <code>calcSum</code> wird <code>calcSum</code> ist ein sehr einfacher Algorithmus, der die Werte aller Bytes in den Daten von der Speicherkarte summiert.  Die unteren acht Bits des Ergebnisses m√ºssen Null sein.  Das hei√üt, um diese Pr√ºfung zu bestehen, m√ºssen Sie die Werte aller Bytes in der Quelldatei summieren, den Wert berechnen, der hinzugef√ºgt werden muss, damit die unteren acht Bits Null werden, und diesen Wert dann dem Pr√ºfsummenbyte in der Datei zuweisen. <br><br>  Wenn die √úberpr√ºfung fehlschl√§gt, erhalten Sie eine Meldung √ºber die Unm√∂glichkeit, die Speicherkarte korrekt zu lesen, und es passiert nichts.  W√§hrend des Debuggens muss ich nur diese Pr√ºfung √ºberspringen. <br><br><h4>  ROM kopieren </h4><br>  Gegen Ende von <code>memcard_game_load</code> passiert eine weitere interessante Sache.  Es gibt mehrere weitere interessante Codebl√∂cke zwischen ihr und der Pr√ºfsumme, aber keiner von ihnen f√ºhrt zu einer Verzweigung, die die Ausf√ºhrung dieses Verhaltens √ºberspringt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cc8/376/55d/cc837655d2ec1b207b0f7420db856a1e.png"></div><br>  Wenn ein bestimmter 16-Bit-Ganzzahlwert, der von der Speicherkarte gelesen wird, nicht gleich Null ist, wird eine Funktion aufgerufen, die den Komprimierungsheader im Puffer √ºberpr√ºft.  Es sucht nach propriet√§ren Nintendo-Komprimierungsformaten, indem es sich den Anfang des Yay0- oder Yaz0-Puffers ansieht.  Wird eine dieser Zeilen gefunden, wird die Entpackfunktion aufgerufen.  Andernfalls wird eine einfache Kopierkopierfunktion ausgef√ºhrt.  In jedem Fall wird danach eine Variable namens <code>nesinfo_data_size</code> . <br><br>  Ein weiterer Hinweis auf den Kontext ist, dass ROM-Dateien f√ºr eingebettete NES-Spiele die Yaz0-Komprimierung verwenden und diese Zeile in den Kopfzeilen ihrer Dateien vorhanden ist. <br><br>  Nachdem ich den Wert beobachtet hatte, der auf Null gepr√ºft und der Puffer an die Komprimierungspr√ºfungsfunktionen √ºbergeben wurde, fand ich schnell heraus, von wo das Spiel in der Datei auf der Speicherkarte gelesen wurde.  Die Nullpr√ºfung wird f√ºr einen Teil des 32-Byte-Puffers durchgef√ºhrt, der vom Offset <code>0x640</code> in der Datei kopiert wurde, bei der es sich h√∂chstwahrscheinlich um den ROM-Header handelt.  Diese Funktion √ºberpr√ºft auch andere Teile der Datei und in ihnen befindet sich der Name des Spiels (beginnend mit dem dritten Byte des Headers). <br><br>  In dem Code-Ausf√ºhrungspfad, den ich gefunden habe, befindet sich der ROM-Puffer unmittelbar nach diesem 32-Byte-Header-Puffer. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7c2/01f/34c/7c201f34c3b9427c288654d487acbcbf.png"></div><br>  Diese Informationen reichen aus, um zu versuchen, eine funktionierende ROM-Datei zu erstellen.  Ich habe gerade eine der anderen Animal Crossing-Sicherungsdateien genommen und sie in einem Hex-Editor bearbeitet, um den Dateinamen durch <code>DobutsunomoriP_F_TEST</code> zu ersetzen und alle Bereiche zu l√∂schen, in denen ich die Daten einf√ºgen wollte. <br><br>  F√ºr einen Testlauf habe ich das Pinball-Spiel-ROM verwendet, das sich bereits im Spiel befindet, und seinen Inhalt nach dem 32-Byte-Header eingef√ºgt.  Anstatt den Pr√ºfsummenwert zu berechnen, setze ich Haltepunkte, sodass ich <code>calcSum</code> einfach √ºberspringe und auch die Ergebnisse anderer √úberpr√ºfungen beobachte, die zu einem Zweig f√ºhren k√∂nnen, der den ROM-Startvorgang √ºberspringt. <br><br>  Schlie√ülich importierte ich die neue Datei √ºber den Dolphin-Speicherkarten-Manager, startete das Spiel neu und versuchte, die Konsole zu starten. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/199/d08/799/199d087997375f8666284220e7ffcc62.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/527/be8/5f5/527be85f54ab8f37609047d323c6b442.png"></div><br>  Es hat funktioniert!  Es gab einige kleine Grafikfehler im Zusammenhang mit Dolphin-Parametern, die sich auf den vom NES-Emulator verwendeten Grafikmodus auswirkten, aber im Allgemeinen lief das Spiel einwandfrei.  (In neueren Versionen von Dolphin sollte dies standardm√§√üig funktionieren.) <br><br>  Um sicherzustellen, dass auch andere Spiele gestartet werden, habe ich versucht, mehrere andere ROMs zu schreiben, die nicht im Spiel enthalten waren.  Battletoads wurden gestartet, funktionierten jedoch nach dem Begr√º√üungsbildschirmtext nicht mehr (nach weiteren Einstellungen konnte ich ihn spielbar machen).  Mega Man hingegen hat perfekt funktioniert: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/923/5a2/7da/9235a27da4d094a496a477cc24cd4846.png"></div><br>  Um zu lernen, wie man neue ROM-Dateien generiert, die ohne das Eingreifen von Debuggern geladen werden k√∂nnen, musste ich anfangen, Code zu schreiben und das Parsen des Dateiformats besser zu verstehen. <br><br><h3>  Externes ROM-Dateiformat </h3><br>  Der wichtigste Teil des Parsens von Dateien findet unter <code>memcard_game_load</code> .  Diese Funktion besteht aus sechs Hauptabschnitten von Code-Analysebl√∂cken: <br><br><ul><li>  Pr√ºfsumme </li><li>  Dateinamen speichern </li><li>  ROM-Datei-Header </li><li>  Unbekannter Puffer ohne Verarbeitung kopiert </li><li>  Textkommentar, Symbol und Bannerlader (um eine neue Sicherungsdatei zu erstellen) </li><li>  ROM-Bootloader </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f00/194/51e/f0019451e2d0070900f75c62cb83535a.png"></div><br><h4>  Pr√ºfsumme </h4><br>  Die unteren acht Bits der Summe aller Bytewerte in der Sicherungsdatei m√ºssen Null sein.  Hier ist einfacher Python-Code, der das erforderliche Pr√ºfsummenbyte generiert: <br><br><pre> <code class="python hljs">checksum = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> byte_val <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> new_data_tmp: checksum += byte_val checksum = checksum % (<span class="hljs-number"><span class="hljs-number">2</span></span>**<span class="hljs-number"><span class="hljs-number">32</span></span>) <span class="hljs-comment"><span class="hljs-comment"># keep it 32 bit checkbyte = 256 - (checksum % 256) new_data_tmp[-1] = checkbyte</span></span></code> </pre> <br>  Es gibt wahrscheinlich einen speziellen Ort zum Speichern des Pr√ºfsummenbytes, aber das Hinzuf√ºgen zum leeren Bereich ganz am Ende der Sicherungsdatei funktioniert recht gut. <br><br><h4>  Dateiname </h4><br>  Auch hier sollte der Name der Sicherungsdatei mit "DobutsunomoriP_F_" beginnen und mit etwas enden, das nicht "SAVE" enth√§lt.  Dieser Dateiname wird einige Male kopiert, und in einem Fall wird der Buchstabe "F" durch "S" ersetzt.  Dies ist der Name der Sicherungsdateien f√ºr das NES-Spiel ("DobutsunomoriP_S_NAME"). <br><br><h4>  ROM-Header </h4><br>  Eine direkte Kopie des 32-Byte-Headers wird in den Speicher geladen.  Einige der Werte in diesem Header werden verwendet, um zu bestimmen, wie nachfolgende Abschnitte behandelt werden sollen.  Grunds√§tzlich sind dies einige 16-Bit-Gr√∂√üenwerte und gepackte Parameterbits. <br><br>  Wenn Sie den vom Header kopierten Zeiger bis zum Start der Funktion verfolgen und die Position ihres Arguments ermitteln, zeigt die Signatur der folgenden Funktion, dass sie tats√§chlich den Typ <code>MemcardGameHeader_t*</code> . <br><br><pre> <code class="python hljs">memcard_game_load(unsigned char *, int, unsigned char **, char *, char *, MemcardGameHeader_t *, unsigned char *, unsigned long, unsigned char *, unsigned long)</code> </pre> <br><h4>  Unbekannter Puffer </h4><br>  √úberpr√ºft den 16-Bit-Gr√∂√üenwert aus dem Header.  Wenn es nicht gleich Null ist, wird die entsprechende Anzahl von Bytes direkt aus dem Dateipuffer in einen neuen Block des zugewiesenen Speichers kopiert.  Dadurch wird der Datenzeiger in den Dateipuffer verschoben, sodass das weitere Kopieren ab dem n√§chsten Abschnitt fortgesetzt werden kann. <br><br><h4>  Banner, Symbol und Kommentar </h4><br>  Ein anderer Gr√∂√üenwert wird im Header √ºberpr√ºft. Wenn er ungleich Null ist, wird die Funktion zur √úberpr√ºfung der Dateikomprimierung aufgerufen.  Bei Bedarf wird der <code>SetupExternCommentImage</code> gestartet, wonach <code>SetupExternCommentImage</code> . <br><br>  Diese Funktion f√ºhrt drei Dinge aus: "Kommentar", Bannerbild und Symbol.  F√ºr jeden von ihnen gibt es einen Code im ROM-Header, der zeigt, wie man mit ihnen umgeht.  Es gibt folgende Optionen: <br><br><ol><li>  Standardwert verwenden </li><li>  Kopieren Sie aus dem Bereich Banner / Symbol / Kommentar in die ROM-Datei </li><li>  Aus alternativem Puffer kopieren </li></ol><br>  Die Standardwerte des Codes bewirken, dass das Symbol oder Banner von der Ressource auf der Festplatte geladen wird. Dem Namen der Sicherungsdatei und dem Kommentar (Textbeschreibung der Datei) werden die Werte "Animal Crossing" und "NES Cassette Save Data" zugewiesen.  So sieht es aus: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/906/519/045/906519045718e74cf565c2983401692c.png"></div><br>  Der zweite Wert des Codes kopiert einfach den Namen des Spiels aus der ROM-Datei (eine Alternative zu "Animal Crossing") und versucht dann, die Zeichenfolge "] ROM" im Dateikommentar zu finden und durch "] SAVE" zu ersetzen.  Anscheinend sollten die Dateien, die Nintendo ver√∂ffentlichen wollte, das Format ‚ÄûGame Name [NES] ROM‚Äú oder √§hnliches haben. <br><br>  F√ºr das Symbol und das Banner versucht der Code, das Bildformat zu bestimmen, einen diesem Format entsprechenden festen Gr√∂√üenwert zu erhalten und das Bild dann zu kopieren. <br><br>  Beim letzten Codewert werden der Dateiname und die Beschreibung ohne √Ñnderungen aus dem Puffer kopiert, und das Symbol und das Banner werden ebenfalls aus dem alternativen Puffer geladen. <br><br><h4>  ROM </h4><br>  Wenn Sie sich den Screenshot des <code>memcard_game_load</code> Kopieren von <code>memcard_game_load</code> genau ansehen, sehen Sie, dass der auf Gleichheit auf Null gepr√ºfte 16-Bit-Wert um 4 Bit nach links verschoben wird (multipliziert mit 16) und dann als Gr√∂√üe der <code>memcpy</code> Funktion verwendet wird, wenn keine Komprimierung erkannt wird.  Dies ist ein weiterer Gr√∂√üenwert, der im Header vorhanden ist. <br><br>  Wenn die Gr√∂√üe ungleich Null ist, werden die ROM-Daten auf Komprimierung √ºberpr√ºft und dann kopiert. <br><br><h3>  Unbekannte Puffer- und Fehlersuche </h3><br>  Obwohl das Herunterladen neuer ROMs ziemlich merkw√ºrdig ist, war das Interessanteste an diesem ROM-Loader f√ºr mich, dass dies tats√§chlich der einzige Teil des Spiels ist, der Benutzereingaben variabler Gr√∂√üe empf√§ngt und an verschiedene Speicherorte kopiert.  Fast alles andere verwendet Puffer mit konstanter Gr√∂√üe.  Dinge wie Namen und Buchstabentexte m√∂gen unterschiedlich lang erscheinen, aber im Wesentlichen ist der leere Raum einfach mit Leerzeichen gef√ºllt.  Nullterminierte Zeichenfolgen werden selten verwendet, um h√§ufige Speicherbesch√§digungsfehler zu vermeiden, z. B. die Verwendung von <code>strcpy</code> mit einem Puffer, der zu klein ist, um Zeichenfolgen zu kopieren. <br><br>  Ich war sehr interessiert an der M√∂glichkeit, einen Exploit des Spiels basierend auf gespeicherten Dateien zu finden, und es schien, dass dies die beste Option war. <br><br>  Die meisten oben beschriebenen ROM-Dateivorg√§nge verwenden Kopien mit konstanter Gr√∂√üe, mit Ausnahme eines unbekannten Puffers und von ROM-Daten.  Leider weist der Code, der diesen Puffer verarbeitet, genau so viel Speicherplatz zu, wie zum Kopieren erforderlich ist, sodass kein √úberlauf auftritt und das Festlegen sehr gro√üer ROM-Dateigr√∂√üen nicht sehr n√ºtzlich war. <br><br>  Aber ich wollte immer noch wissen, was mit diesem Puffer passiert, der ohne Verarbeitung kopiert wird. <br><br><h4>  Handler f√ºr NES-Informationsetiketten </h4><br>  Ich kehrte zu <code>famicom_rom_load</code> .  Nach dem Laden des ROM von einer Speicherkarte oder Festplatte werden verschiedene Funktionen aufgerufen: <br><br><ul><li> <code>nesinfo_tag_process1</code> </li> <li> <code>nesinfo_tag_process2</code> </li> <li> <code>nesinfo_tag_process3</code> </li> </ul><br>  Nachdem ich den Ort verfolgt hatte, an dem der unbekannte Puffer kopiert wurde, stellte ich sicher, dass diese Aufgabe von diesen Funktionen ausgef√ºhrt wird.  Sie beginnen mit einem Aufruf von <code>nesinfo_next_tag</code> , der einen einfachen Algorithmus ausf√ºhrt: <br><br><ul><li>  √úberpr√ºft, ob der angegebene Zeiger <code>nesinfo_tags_end</code> Zeiger in <code>nesinfo_tags_end</code> .  Wenn es kleiner als <code>nesinfo_tags_end</code> oder <code>nesinfo_tags_end</code> Null ist, pr√ºft es, <code>nesinfo_tags_end</code> die Zeichenfolge "END" im Header des Zeigers vorhanden ist. <br><br><ul><li>  Wenn "END" erreicht ist oder der Zeiger auf oder √ºber <code>nesinfo_tags_end</code> , gibt die Funktion null zur√ºck. </li><li>  Andernfalls wird das Byte am Offset <code>0x3</code> Zeigers zu 4 und zum aktuellen Zeiger addiert, wonach der Wert zur√ºckgegeben wird. </li></ul></li></ul><br>  Dies sagt uns, dass es eine Art Etikettenformat aus einem aus drei Buchstaben bestehenden Namen, einem Datengr√∂√üenwert und den Daten selbst gibt.  Das Ergebnis ist ein Zeiger auf die n√§chste Beschriftung, da die aktuelle Beschriftung √ºbersprungen wird ( <code>cur_ptr + 4</code> √ºberspringt den dreistelligen Namen und ein Byte und <code>size_byte</code> √ºberspringt die Daten). <br><br>  Wenn das Ergebnis nicht Null ist, f√ºhrt die Etikettenverarbeitungsfunktion eine Reihe von Zeichenfolgenvergleichen durch, um herauszufinden, welches Etikett verarbeitet werden muss.  Einige der in <code>nesinfo_tag_process1</code> √ºberpr√ºften <code>nesinfo_tag_process1</code> : VEQ, VNE, GID, GNO, BBR und QDS. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0f1/094/08b/0f109408b8d01ec8cf4522445463e378.png"></div><br>  Wenn eine Beschriftungs√ºbereinstimmung gefunden wird, wird ein Handlercode ausgef√ºhrt.  Einige der Handler tun nichts anderes, als eine Bezeichnung in der Debug-Nachricht anzuzeigen.  Andere haben komplexere Handler.  Nach der Verarbeitung des Etiketts versucht die Funktion, das n√§chste Etikett zu erhalten und die Verarbeitung fortzusetzen. <br><br>  Gl√ºcklicherweise gibt es viele detaillierte Debugging-Meldungen, die angezeigt werden, wenn Tags erkannt werden.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie sind alle auf Japanisch, daher m√ºssen sie zuerst aus Shift-JIS dekodiert und √ºbersetzt werden. Beispielsweise k√∂nnte eine Nachricht f√ºr QDS lauten: "Laden eines Festplattenspeicherbereichs" oder "Da dies die erste Ausf√ºhrung ist, erstellen Sie einen Festplattenspeicherbereich". Die Meldungen f√ºr den BBR lauten "Laden eines Backups der Batterie" oder "Da dies der erste Start ist, f√ºhren wir eine Bereinigung durch". </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beide Codes laden auch einige Werte aus dem Datenabschnitt ihrer Beschriftungen und verwenden sie, um den Versatz in den ROM-Daten zu berechnen, wonach sie Kopiervorg√§nge ausf√ºhren. Offensichtlich sind sie f√ºr die Bestimmung der Teile im ROM-Speicher verantwortlich, die mit der Zustandserhaltung verbunden sind.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt auch ein "HSC" -Tag mit einer Debug-Nachricht, die besagt, dass Punktdatens√§tze verarbeitet werden. </font><font style="vertical-align: inherit;">Sie erh√§lt einen Versatz im ROM aus ihren Tag-Daten sowie den urspr√ºnglichen Wert des Score-Datensatzes. </font><font style="vertical-align: inherit;">Diese Markierungen k√∂nnen verwendet werden, um einen Platz im Speicher des NES-Spiels zum Speichern von Highscores anzuzeigen, m√∂glicherweise um sie in Zukunft zu speichern und wiederherzustellen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diese Tags erstellen ein ziemlich komplexes ROM-Metadaten-Download-System. </font><font style="vertical-align: inherit;">Dar√ºber hinaus f√ºhren viele von ihnen zu Anrufen, </font></font><code>memcpy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die auf den in den Etikettendaten √ºbertragenen Werten basieren.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Insektenjagd </font></font></h4><br>  ,     ,     ,           ,    16-  .      16-   NES,        ,            32-   GameCube. <br><br>    ,    ,  <code>memcpy</code> ,   <code>0xFFFF</code> . <br><br><h5> QDS </h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QDS l√§dt einen 24-Bit-Offset aus seinen Tag-Daten sowie einen 16-Bit-Gr√∂√üenwert. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Gute dabei ist, dass der Offset verwendet wird, um die Zieladresse des Kopiervorgangs zu berechnen. Die Basisadresse des Offsets ist der Anfang der heruntergeladenen Daten, die Kopierquelle befindet sich in der ROM-Datei der Speicherkarte und die Gr√∂√üe wird durch den 16-Bit-Gr√∂√üenwert auf dem Etikett festgelegt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der 24-Bit-Wert hat einen Maximalwert </font></font><code>0xFFFFFF</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, der viel mehr ist als zum Schreiben au√üerhalb der geladenen ROM-Daten erforderlich. Es gibt jedoch bestimmte Probleme ... </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das erste ist, dass der maximale Gr√∂√üenwert zwar gleich ist </font></font><code>0xFFFF</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, aber zun√§chst zum Zur√ºcksetzen der Speicherpartition verwendet wird. Wenn der Gr√∂√üenwert zu hoch ist (nicht viel gr√∂√üer </font></font><code>0x1000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), wird die ‚ÄûQDS‚Äú -Markierung im Spielcode zur√ºckgesetzt.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und darin liegt das Problem, weil es </font></font><code>nesinfo_tag_process1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tats√§chlich zweimal aufgerufen wird. Zum ersten Mal erh√§lt sie einige Informationen √ºber den Speicherplatz, den sie zur Vorbereitung der gespeicherten Daten ben√∂tigt. QDS- und BBR-Tags werden beim ersten Start nicht vollst√§ndig verarbeitet. Nach dem ersten Lauf wird ein Ort f√ºr die Sicherungsdaten vorbereitet und die Funktion erneut aufgerufen. Dieses Mal werden die QDS- und BBR-Tags vollst√§ndig verarbeitet. Wenn jedoch die Tag-Namenszeichenfolgen aus dem Speicher gel√∂scht werden, ist es unm√∂glich, die Tags erneut zuzuordnen! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies kann vermieden werden, indem ein kleinerer Gr√∂√üenwert eingestellt wird. Ein weiteres Problem besteht darin, dass sich der Versatzwert nur im Speicher vorw√§rts bewegen kann und sich die ROM-NES-Daten im Heap ziemlich nahe am Ende des verf√ºgbaren Speichers befinden.</font></font><br><br>      ,          ,    . <br><br>            ,    <code>malloc</code> ,    ,            <code>malloc</code> .           .                 <code>free</code>    . <br><br>     <code>malloc</code>     ( <code>0x7373</code> )      ,       <code>free</code> .      ,   <code>OSPanic</code>   . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/516/68f/447/51668f447b75887250574f1ad1ec1800.png"></div><br>      ,      -  ,    .  ,   -   ,     -    .   -   ,   <code>0x73730000</code>        <em></em> ,    ,        (   ,       ),         . <br><br><h5> <code>nesinfo_update_highscore</code> </h5> <br>   ,   QDS, BBR  HSC ‚Äî  <code>nesinfo_update_highscore</code> .    QDS, BBR  OFS (offset, )    ,     ,   HSC     .      ,   NES. <br><br>         ,   QDS,  <code>0xFFFF</code> .           BBR  QDS    <em></em> .  ,           .    ,        ROM     ,       <code>0xFFFF</code> . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Basisadresse, zu der der Offset hinzugef√ºgt wird, ist der </font></font><code>0x800C3180</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Speicherdatenpuffer. </font><font style="vertical-align: inherit;">Diese Adresse ist viel niedriger als die ROM-Daten, was uns mehr Freiheit bei der Auswahl eines Aufnahmeorts gibt. </font><font style="vertical-align: inherit;">Beispielsweise ist es recht einfach, die R√ºcksprungadresse im Stapel in die Adresse umzuschreiben </font></font><code>0x812F95DC</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Leider hat das auch nicht funktioniert. </font><font style="vertical-align: inherit;">Es stellt sich heraus, dass es </font></font><code>nesinfo_tag_process1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auch die akkumulierte Gr√∂√üe der Offsets dieser Labels √ºberpr√ºft und diese Gr√∂√üe verwendet, um den Speicherplatz zu initialisieren:</font></font><br><br><pre> <code class="cpp hljs">bzero(nintendo_hi_0, ((offset_sum + <span class="hljs-number"><span class="hljs-number">0xB</span></span>) * <span class="hljs-number"><span class="hljs-number">4</span></span>) + <span class="hljs-number"><span class="hljs-number">0x40</span></span>)</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7b3/531/0ab/7b35310ab9bae3406ee423acd1c1a1a5.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit dem Versatzwert, den ich zu berechnen versuchte, f√ºhrte dies dazu, dass </font></font><code>0x48D91EC</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(76.386.796) Bytes Speicher </font><font style="vertical-align: inherit;">gel√∂scht wurden </font><font style="vertical-align: inherit;">, weshalb das Spiel spektakul√§r abst√ºrzte.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PAT-Marke </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich hatte bereits begonnen, die Hoffnung zu verlieren, weil all diese Tags, die ungesch√ºtzte Anrufe </font></font><code>memcpy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t√§tigten, fehlgeschlagen waren, noch bevor ich sie verwenden konnte. Ich beschloss, nur den Zweck jedes Tags zu dokumentieren, und kam nach und nach zu den Tags in </font></font><code>nesinfo_tag_process2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die meisten Label-Handler </font></font><code>nesinfo_tag_process2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">starten nie, da sie nur funktionieren, wenn der Zeiger </font></font><code>nesinfo_rom_start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nicht Null ist. Nichts im Code weist diesem Zeiger einen Wert ungleich Null zu. Es wird mit einem Nullwert initialisiert und nie wieder verwendet. Beim Laden wird nur das ROM eingestellt </font></font><code>nesinfo_data_start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, so dass es wie toter Code aussieht. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt jedoch eine Bezeichnung, die auch dann funktionieren kann, wenn sie nicht Null ist </font></font><code>nesinfo_rom_start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: PAT. Dies ist die schwierigste Bezeichnung in einer Funktion </font></font><code>nesinfo_tag_process2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b5a/8fa/e47/b5a8fae47c7ba7f82b2ee9810a950c6e.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es wird auch als Zeiger verwendet </font></font><code>nesinfo_rom_start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, √ºberpr√ºft es jedoch nie auf Null. </font><font style="vertical-align: inherit;">Das PAT-Tag liest seinen eigenen Tag-Datenpuffer und verarbeitet Codes, die Offsets berechnen. </font><font style="vertical-align: inherit;">Diese Offsets werden dem Zeiger hinzugef√ºgt, </font></font><code>nesinfo_rom_start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">um die Zieladresse zu berechnen, und dann werden die Bytes aus dem Patch-Puffer an diesen Speicherort kopiert. </font><font style="vertical-align: inherit;">Dieses Kopieren erfolgt durch Laden und Speichern von Bytes ohne Verwendung von Anweisungen </font></font><code>memcpy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, sodass ich es vorher nicht bemerkt habe. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jeder PAT-Markierungsdatenpuffer hat einen 8-Bit-Typcode, eine 8-Bit-Patchgr√∂√üe und einen 16-Bit-Offsetwert, gefolgt von den Patchdaten.</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn der Code 2 ist, wird der Versatzwert zur aktuellen Summe der Vers√§tze addiert. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn der Code 9 ist, wird der Versatz um 4 Bits nach oben verschoben und zur aktuellen Summe der Vers√§tze addiert. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn der Code 3 ist, wird die Summe der Offsets auf 0 zur√ºckgesetzt. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die maximale Gr√∂√üe des NES-Informationsetiketts betr√§gt 255, d. H. Die gr√∂√üte PAT-Patchgr√∂√üe betr√§gt 251 Bytes. </font><font style="vertical-align: inherit;">Es k√∂nnen jedoch mehrere PAT-Markierungen verwendet werden, dh Sie k√∂nnen mehr als 251 Byte patchen sowie nicht zusammenh√§ngende Leerzeichen patchen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solange wir eine Reihe von PAT-Sohlen mit Code 2 oder Code 9 haben, sammelt sich der Versatz des Zielzeigers weiter an. </font><font style="vertical-align: inherit;">Beim Kopieren von Patch-Daten werden diese auf Null zur√ºckgesetzt. Wenn Sie jedoch eine Patch-Gr√∂√üe von Null verwenden, kann dies vermieden werden. </font><font style="vertical-align: inherit;">Es ist klar, dass dies verwendet werden kann, um einen beliebigen Versatz mit einem Nullzeiger unter </font></font><code>nesinfo_rom_start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verwendung vieler PAT-Markierungen </font><font style="vertical-align: inherit;">zu berechnen </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt jedoch zwei weitere √úberpr√ºfungen der Codewerte ...</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn der Code zwischen </font></font><code>0x80</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und liegt </font></font><code>0xFF</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, wird er hinzugef√ºgt </font></font><code>0x7F80</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und dann um 16 Bit nach oben verschoben. </font><font style="vertical-align: inherit;">Dann wird es zum 16-Bit-Offsetwert addiert und als Endadresse f√ºr das Patch verwendet.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dadurch k√∂nnen wir eine Zieladresse f√ºr den Patch im Bereich von </font></font><code>0x80000000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bis </font><font style="vertical-align: inherit;">zuweisen </font></font><code>0x807FFFFF</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">! </font><font style="vertical-align: inherit;">Hier befindet sich der Gro√üteil des Animal Crossing-Codes im Speicher. </font><font style="vertical-align: inherit;">Dies bedeutet, dass wir den Animal Crossing-Code selbst mithilfe von ROM-Metadatenbezeichnungen aus einer Datei auf einer Speicherkarte patchen k√∂nnen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit Hilfe eines kleinen Patch-Loaders k√∂nnen Sie sogar problemlos gr√∂√üere Patches von einer Speicherkarte an eine beliebige Adresse herunterladen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zur schnellen √úberpr√ºfung habe ich einen Patch erstellt, der "zuru mode 2" (Spieleentwicklermodus, beschrieben in meinem </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">vorherigen Artikel)</font></a><font style="vertical-align: inherit;"> enthielt</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"></font></a> )    ROM   . ,  -      ¬´zuru mode 1¬ª,       ,     2.                  . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/864/d51/d15/864d51d15fa180ea3fab552a0dd4977b.png"></div><br>       ROM. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/499/dc8/2e4/499dc82e445ffd6bfd607d4f834ccd5a.png"></div><br>   ROM     NES,   . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/694/6ea/3a2/6946ea3a20e0290b75eeba8bbf400d10.png"></div><br>  Es funktioniert! <br><br><h4>     </h4><br>     ,   ,   : <br><br> <code>000000 5a 5a 5a 00 50 41 54 08 a0 04 6f 9c 00 00 00 7d &gt;ZZZ.PAT...o....}&lt; <br> 000010 45 4e 44 00 &gt;END.&lt;</code> <br> <br><ul><li> <code>ZZZ \x00</code> :   . <code>0x00</code> ‚Äî     : . </li><li> <code>PAT \x08 \xA0 \x04 \x6F\x9C \x00\x00\x00\x7D</code> :  <code>0x80206F9C</code>  <code>0x0000007D</code> . <br><ul><li> <code>0x08</code> ‚Äî    . </li><li> <code>0xA0</code>    <code>0x7F80</code>  <code>0x8020</code> ,    16   . </li><li> <code>0x04</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ist die Gr√∂√üe der Patch-Daten ( </font></font><code>0x0000007D</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">).</font></font></li><li> <code>0x6F9C</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sind die unteren 16 Bits der Zieladresse. </font></font></li><li> <code>0x0000007D</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sind die Patch-Daten. </font></font></li></ul></li><li> <code>END \x00</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Endmarkierungsmarkierung. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie selbst mit der Erstellung von Patcher- oder ROM-Sicherungsdateien experimentieren m√∂chten, habe </font><font style="vertical-align: inherit;">ich unter </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://github.com/jamchamb/ac-nesrom-save-generator</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> einen sehr einfachen Code zum Generieren von Dateien ver√∂ffentlicht. </font><font style="vertical-align: inherit;">Ein Patch wie der oben gezeigte kann mit dem folgenden Befehl generiert werden:</font></font><br><br> <code>$ ./patcher.py Patcher /dev/null zuru_mode_2.gci -p 80206F9c 0000007D</code> <br> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Beliebige Codeausf√ºhrung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dank dieses Tags k√∂nnen Sie in Animal Crossing eine beliebige Codeausf√ºhrung erreichen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aber hier kommt die letzte H√ºrde: Die Verwendung von Patches f√ºr Daten funktioniert gut, aber beim Patchen von Codeanweisungen treten Probleme auf. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Patches aufgezeichnet werden, folgt das Spiel weiterhin den alten Anweisungen, die an seiner Stelle waren. Dies scheint ein Caching-Problem zu sein, und tats√§chlich ist es das auch. Die GameCube-CPU verf√ºgt √ºber Anweisungs-Caches, wie </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in den technischen Daten beschrieben</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um zu verstehen, wie Sie den Cache leeren k√∂nnen, habe ich begonnen, die Cache-bezogenen Funktionen aus der GameCube SDK-Dokumentation zu untersuchen, und festgestellt </font></font><code>ICInvalidateRange</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Diese Funktion macht die zwischengespeicherten Befehlsbl√∂cke an der angegebenen Speicheradresse ung√ºltig, wodurch der ge√§nderte Befehlsspeicher mit aktualisiertem Code ausgef√ºhrt werden kann.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ohne die M√∂glichkeit, den urspr√ºnglichen Code auszuf√ºhren, k√∂nnen wir jedoch immer noch nicht aufrufen </font></font><code>ICInvalidateRange</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. F√ºr eine erfolgreiche Codeausf√ºhrung ben√∂tigen wir noch einen Trick. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Als </font></font><code>malloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ich </font><font style="vertical-align: inherit;">die Implementierung </font><font style="vertical-align: inherit;">auf die M√∂glichkeit der Verwendung eines Exploits mit Heap-√úberlauf untersuchte, stellte ich fest, dass Implementierungsfunktionen </font></font><code>malloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mithilfe einer aufgerufenen Datenstruktur dynamisch deaktiviert werden k√∂nnen </font></font><code>my_malloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><code>my_malloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L√§dt einen Zeiger auf die aktuelle Implementierung </font></font><code>malloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">oder </font></font><code>free</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">von einer statischen Stelle im Speicher und ruft diese Funktion auf, wobei alle √ºbergebenen Argumente √ºbergeben werden </font></font><code>my_malloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NES-Emulator wird aktiv verwendet</font></font><code>my_malloc</code>         ROM NES ,    ,           ,     PAT. <br><br>  <code>my_malloc</code>         ,      ,   ,       <code>malloc</code>  <code>free</code> .      ,          <code>my_malloc</code> . <br><br>  - D≈çbutsu no Mori e+   Cuyler      PowerPC           : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://www.youtube.com/watch?v=BdxN7gP6WIc</a> . (D≈çbutsu no Mori e+    Animal Crossing  GameCube,    .    .)    ,        ID      Z. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/BdxN7gP6WIc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>     ,   homebrew    Animal <br> Crossing   GameCube. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de417117/">https://habr.com/ru/post/de417117/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de417107/index.html">Entwickler des Spiels w√§hrend True: Erfahren Sie () mehr √ºber Gamedev-Programmierung, VR-Probleme und ML-Simulationen</a></li>
<li><a href="../de417109/index.html">Richard Hamming: Kapitel 10. Codierungstheorie - I.</a></li>
<li><a href="../de417111/index.html">Online-Konferenzen: Streaming vs Webinar</a></li>
<li><a href="../de417113/index.html">Italienischer 3D-Drucker in Russland: Raise3D N1 Dual - Modellierung und Prototyping</a></li>
<li><a href="../de417115/index.html">Flutter.io begraben oder verbrennen?</a></li>
<li><a href="../de417119/index.html">Paginierung in Vue.js</a></li>
<li><a href="../de417123/index.html">Integration von Spark Streaming und Kafka</a></li>
<li><a href="../de417125/index.html">RTC Meetup .Net: Zum ersten Meeting einladen</a></li>
<li><a href="../de417127/index.html">Tesla unterzeichnet Vereinbarung zum Bau von Gigafactory 3 in China</a></li>
<li><a href="../de417129/index.html">Universum des Geistes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>