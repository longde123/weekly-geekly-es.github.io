<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛡️ 💈 🤙🏾 Reverse Engineering des NES-Emulators im Spiel für GameCube 😭 🐫 🛌🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Während ich nach Möglichkeiten suchte, die in Animal Crossing verbleibenden Entwicklermenüs zu aktivieren, einschließlich des Spielauswahlmenüs für de...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Reverse Engineering des NES-Emulators im Spiel für GameCube</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/417117/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/499/dc8/2e4/499dc82e445ffd6bfd607d4f834ccd5a.png" alt="Bild"></div><br>  Während ich nach Möglichkeiten suchte, die in Animal Crossing verbleibenden Entwicklermenüs zu aktivieren, einschließlich des Spielauswahlmenüs für den NES-Emulator, fand ich eine interessante Funktion, die im ursprünglichen Spiel vorhanden war und ständig aktiv war, aber von Nintendo nie verwendet wurde. <br><br>  Zusätzlich zu den NES / Famicom-Spielen im Spiel können Sie neue NES-Spiele von einer Speicherkarte herunterladen. <br><br>  Ich habe auch einen Weg gefunden, diesen ROM-Bootloader zu verwenden, um meinen Code und meine Daten in das Spiel zu patchen, wodurch Sie Code über eine Speicherkarte ausführen können. <br><br><h2>  Einführung - NES-Konsolenobjekte </h2><br>  Gewöhnliche NES-Spiele, die bei Animal Crossing erhältlich sind, sind separate Möbelstücke in Form einer NES-Konsole mit einer darauf liegenden Patrone. <br><br>  Nachdem Sie dieses Objekt in Ihrem Haus gefunden und mit ihm interagiert haben, können Sie dieses einzige Spiel ausführen.  Das Bild unten zeigt Excitebike und Golf. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/40e/e33/409/40ee334095bd1151c3c968a84f8cf92b.png"></div><a name="habracut"></a><br>  Es gibt auch ein allgemeines NES-Konsolenobjekt, in dem keine integrierten Spiele vorhanden sind.  Es kann bei Redd gekauft und manchmal durch zufällige Ereignisse erhalten werden, indem beispielsweise an der Pinnwand der Stadt gelesen wird, dass die Konsole an einem zufälligen Punkt in der Stadt vergraben ist. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f41/d20/687/f41d20687aed7d6a4d044a5a5d084045.png"></div><br>  Dieses Objekt sieht aus wie eine NES-Konsole, auf der sich keine Kassetten befinden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/35c/010/9a3/35c0109a32b31deeb202280773f363a0.png"></div><br>  Das Problem mit diesem Objekt ist, dass es als nicht spielbar angesehen wurde.  Jedes Mal, wenn Sie mit ihm interagieren, sehen Sie eine Meldung, dass Sie keine Spielesoftware haben. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a9e/6d3/3b8/a9e6d33b8e039a2f17c12fd134cf0308.png"></div><br>  Es stellte sich heraus, dass dieses Objekt tatsächlich versucht, die Speicherkarte nach speziell entwickelten Dateien zu durchsuchen, die ROM-Images für NES enthalten!  Der zum Ausführen eingebetteter Spiele verwendete NES-Emulator scheint der vollständige Standard-NES-Emulator für den GameCube zu sein und kann die meisten Spiele starten. <br><br>  Bevor ich diese Funktionen demonstriere, werde ich den Prozess des Reverse Engineering erläutern. <br><br><h2>  Suchen Sie den ROM-Bootloader auf der Speicherkarte </h2><br><h3>  Wir suchen ein Entwicklermenü </h3><br>  Zunächst wollte ich einen Code finden, der verschiedene Entwicklermenüs aktiviert, z. B. das Kartenauswahlmenü oder das Spielauswahlmenü für den NES-Emulator.  Das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Forest Map Select-</a> Menü, mit dem Sie problemlos verschiedene Orte des Spiels laden können, war recht einfach zu finden. Ich habe nur nach der Zeile FOREST MAP SELECT gesucht, die oben auf dem Bildschirm angezeigt wird (sie ist in verschiedenen Videos und Screenshots im Internet zu sehen ) <br><br>  In „FOREST MAP SELECT“ gibt es Querverweise von Daten auf die Funktion <code>select_print_wait</code> , was zu einer Reihe anderer Funktionen führt, die ebenfalls das Präfix <code>select_*</code> , einschließlich der Funktion <code>select_init</code> .  Es stellte sich heraus, dass es sich um Funktionen handelte, die das Kartenauswahlmenü steuern. <br><br>  Die Funktion <code>select_init</code> führt zu einer weiteren interessanten Funktion namens <code>game_get_next_game_dlftbl</code> .  Diese Funktion verknüpft alle anderen Menüs und „Szenen“, die Sie ausführen können: einen Bildschirm mit dem Nintendo-Logo, den Hauptbildschirm, das Kartenauswahlmenü, das NES-Emulatormenü (Famicom) usw.  Es beginnt am Anfang der Hauptspielprozedur, findet heraus, welche <code>game_dlftbls</code> soll, und findet seinen Eintrag in der Tabellendatenstruktur mit dem Namen <code>game_dlftbls</code> .  Diese Tabelle enthält Links zu den Verarbeitungsfunktionen verschiedener Szenen sowie einige andere Daten. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d93/cbc/019/d93cbc0191a754e6bb566525f1a21666.png"></div><br>  Eine sorgfältige Untersuchung des ersten Blocks der Funktion ergab, dass die Funktion "next game init" geladen wird, und beginnt dann, sie mit einer Reihe bekannter init-Funktionen zu vergleichen: <br><br><ul><li> <code>first_game_init</code> </li> <li> <code>select_init</code> </li> <li> <code>play_init</code> </li> <li> <code>second_game_init</code> </li> <li> <code>trademark_init</code> </li> <li> <code>player_select_init</code> </li> <li> <code>save_menu_init</code> </li> <li> <code>famicom_emu_init</code> </li> <li> <code>prenmi_init</code> </li> </ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2e6/785/bae/2e6785bae4c526f3acba034d4f7e4b2e.png"></div><br>  Einer der Funktionszeiger, nach denen er sucht, ist <code>famicom_emu_init</code> , der für die Ausführung des NES / Famicom-Emulators verantwortlich ist.  <code>game_get_next_game_init</code> Ergebnisses von <code>game_get_next_game_init</code> auf <code>famicom_emu_init</code> oder <code>select_init</code> im Dolphin-Debugger konnte ich spezielle Menüs anzeigen.  Der nächste Schritt besteht darin, zu bestimmen, wie diese Zeiger während der Programmausführung auf normale Weise gesetzt werden.  Die Funktion <code>game_get_next_game_init</code> lädt nur den Wert bei Offset <code>0xC</code> ersten Arguments in <code>game_get_next_game_dlftbl</code> . <br><br>  Das Verfolgen dieser in verschiedenen Datenstrukturen festgelegten Werte war etwas langweilig, daher gehe ich direkt zum Kern.  Das Wichtigste, was ich gefunden habe: <br><br><ul><li>  Wenn das Spiel auf die übliche Weise startet, führt es die folgende Abfolge von Aktionen aus: <br><ul><li> <code>first_game_init</code> </li> <li> <code>second_game_init</code> </li> <li> <code>trademark_init</code> </li> <li> <code>play_init</code> </li> </ul></li><li>  <code>player_select_init</code> setzt den nächsten Init auf <code>select_init</code> .  Dieser Bildschirm sollte es Ihnen ermöglichen, einen Spieler unmittelbar nach der Auswahl einer Karte auszuwählen, aber es scheint, dass er nicht richtig funktioniert. </li></ul><br>  Ich habe auch eine namenlose Funktion gefunden, die die Init-Funktion des Emulators definiert, aber ich habe nichts gefunden, das die Init-Funktion auf den Init-Wert des Players oder der Kartenauswahl setzt. <br><br>  Zu diesem Zeitpunkt wurde mir klar, dass ich ein weiteres dummes Problem mit dem Laden von Funktionsnamen in die IDA hatte: Aufgrund des regulären Ausdrucks zum Ausschneiden von Zeilen in der Debug-Symboldatei habe ich alle Funktionsnamen verpasst, die mit einem Großbuchstaben beginnen .  Die von <code>famicom_emu_init</code> eingerichtete Funktion sah aus wie Übergänge zwischen Szenen und hieß <code>Game_play_fbdemo_wipe_proc</code> . <br><br>  <code>Game_play_fbdemo_wipe_proc</code> verarbeitet Übergänge zwischen Szenen, wie z. B. Bildschirmlöschungen und Stromausfälle. <br><br>  Unter bestimmten Bedingungen wurde der Bildschirmübergang vom üblichen Gameplay zur Anzeige des Emulators durchgeführt.  Er hat die Emulator-Init-Funktion eingestellt. <br><br><h3>  Umgang mit Konsolenobjekten </h3><br>  Tatsächlich wechseln Handler von Möbelobjekten für NES-Konsolen den Bildschirmübergangshandler zum Emulator.  Wenn ein Spieler mit einer der Konsolen <code>aMR_FamicomEmuCommonMove</code> , wird <code>aMR_FamicomEmuCommonMove</code> . <br><br>  Beim Aufrufen der Funktion enthält <code>r6</code> den Indexwert, der den Zahlen in den Namen der NES- <code>famicom.arc</code> in <code>famicom.arc</code> : <br><br><ul><li> <code>01_nes_cluclu3.bin.szs</code> </li> <li> <code>02_usa_balloon.nes.szs</code> </li> <li> <code>03_nes_donkey1_3.bin.szs</code> </li> <li> <code>04_usa_jr_math.nes.szs</code> </li> <li> <code>05_pinball_1.nes.szs</code> </li> <li> <code>06_nes_tennis3.bin.szs</code> </li> <li> <code>07_usa_golf.nes.szs</code> </li> <li> <code>08_punch_wh.nes.szs</code> </li> <li> <code>09_usa_baseball_1.nes.szs</code> </li> <li> <code>10_cluclu_1.qd.szs</code> </li> <li> <code>11_usa_donkey3.nes.szs</code> </li> <li> <code>12_donkeyjr_1.nes.szs</code> </li> <li> <code>13_soccer.nes.szs</code> </li> <li> <code>14_exbike.nes.szs</code> </li> <li> <code>15_usa_wario.nes.szs</code> </li> <li> <code>16_usa_icecl.nes.szs</code> </li> <li> <code>17_nes_mario1_2.bin.szs</code> </li> <li> <code>18_smario_0.nes.szs</code> </li> <li> <code>19_usa_zelda1_1.nes.szs</code> </li> </ul><br>  ( <code>.arc</code> ist ein proprietäres Dateiarchivformat.) <br><br>  Wenn <code>r6</code> ungleich Null ist, wird es in <code>aMR_RequestStartEmu</code> Aufruf von <code>aMR_RequestStartEmu</code> .  In diesem Fall wird der Übergang zum Emulator ausgelöst. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f78/268/1d7/f782681d712b4098ad6f9269cf2df5cc.png"></div><br>  Wenn jedoch <code>r6</code> Null ist, wird <code>aMR_RequestStartEmu_MemoryC</code> die Funktion <code>aMR_RequestStartEmu_MemoryC</code> aufgerufen.  Wenn Sie den Wert im Debugger auf 0 setzen, wird die Meldung "Ich habe keine Software" angezeigt.  Ich habe mich nicht sofort daran erinnert, dass ich das NES-Konsolenobjekt überprüfen musste, um sicherzustellen, dass es den <code>r6</code> Wert zurücksetzt, aber es stellte sich heraus, dass der Nullindex für das Konsolenobjekt ohne Kassette verwendet wird. <br><br>  Obwohl <code>aMR_RequestStartEmu</code> den Indexwert einfach in einer Art Datenstruktur <code>aMR_RequestStartEmu_MemoryC</code> führt <code>aMR_RequestStartEmu_MemoryC</code> viel komplexere Operationen aus ... <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d23/844/831/d23844831e1e9f9b8ef5b6a4306948ab.png"></div><br>  Dieser dritte Codeblock ruft <code>aMR_GetCardFamicomCount</code> und <code>aMR_GetCardFamicomCount</code> nach einem Ergebnis ungleich Null. Andernfalls werden die meisten interessanten Dinge auf der linken Seite des Funktionsdiagramms übersprungen. <br><br>  <code>aMR_GetCardFamicomCount</code> ruft <code>famicom_get_disksystem_titles</code> , das dann <code>memcard_game_list</code> , und hier wird alles sehr interessant. <br><br>  <code>memcard_game_list</code> die Speicherkarte <code>memcard_game_list</code> und beginnt im <code>memcard_game_list</code> , wobei jeder der einzelnen Werte <code>memcard_game_list</code> .  Durch Verfolgen der Funktion im Debugger konnte ich verstehen, dass die Werte mit jeder meiner Dateien auf der Speicherkarte verglichen wurden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/da1/e17/dd1/da1e17dd1b1acd6552eeeabaedc586fb.png"></div><br>  Die Funktion entscheidet abhängig von den Ergebnissen der Überprüfung mehrerer Zeilen, ob die Datei heruntergeladen werden soll oder nicht.  Zunächst wird das Vorhandensein der Zeilen „GAFE“ und „01“ überprüft, die die Kennungen des Spiels und des Unternehmens darstellen.  01 steht für Nintendo, GAFE steht für Animal Crossing.  Ich denke, es steht für GameCube Animal Forest English. <br><br>  Sie überprüft dann die Zeilen "DobutsunomoriP_F_" und "SAVE".  In diesem Fall sollte die erste Zeile übereinstimmen, nicht jedoch die zweite.  Es stellte sich heraus, dass "DobutsunomoriP_F_SAVE" der Name der Datei ist, in der die Daten der eingebetteten Spiele für NES gespeichert sind.  Daher werden alle Dateien außer dieser mit dem Präfix "DobutsunomoriP_F_" geladen. <br><br>  Mit dem Dolphin-Debugger, um Zeichenfolgenvergleiche mit "SAVE" zu überspringen und den Spieltrick zu machen, um zu glauben, dass meine "SAVE" -Datei sicher heruntergeladen werden kann, habe ich dieses Menü nach Verwendung der NES-Konsole erhalten: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d4/1d2/696/1d41d26963aeaf11450155f1d7d53085.png"></div><br>  Ich antwortete mit "Ja" und versuchte, die Sicherungsdatei als Spiel zu laden. Danach sah ich zum ersten Mal den eingebauten Spielabsturzbildschirm: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/41e/662/4cc/41e6624cc68fe28e897cd1803ba1a39a.png"></div><br>  Großartig!  Jetzt weiß ich, dass sie tatsächlich versucht, Spiele von einer Speicherkarte herunterzuladen, und ich kann mit der Analyse des Formats für die Sicherungsdateien beginnen, um festzustellen, ob ein echtes ROM heruntergeladen werden kann. <br><br>  Als erstes habe ich versucht herauszufinden, wo der Name des Spiels aus der Speicherkartendatei gelesen wird.  Beim Durchsuchen der Zeile "FEFSC", die in der Meldung "Möchten Sie &lt;Name&gt; spielen?" <code>0x642</code> war, fand ich den Offset, mit dem es aus der Datei gelesen wurde: <code>0x642</code> .  Ich habe die Sicherungsdatei kopiert, den Dateinamen in "DobutsunomoriP_F_TEST" geändert, die Bytes am Offset <code>0x642</code> in "TESTING" geändert und die geänderte Speicherung importiert. <code>0x642</code> der gewünschte Name im Menü angezeigt. <br><br>  Nach dem Hinzufügen einiger weiterer Dateien in diesem Format wurden im Menü einige weitere Optionen angezeigt: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/235/ca3/668/235ca3668ae0a02ad2609847bdf193c0.png"></div><br><h3>  ROM herunterladen </h3><br>  Wenn <code>aMR_GetCardFamicomCount</code> ungleich Null zurückgegeben wird, wird der Speicher auf dem Heap zugewiesen. <code>famicom_get_disksystem_titles</code> wird direkt <code>famicom_get_disksystem_titles</code> aufgerufen. Anschließend werden in der Datenstruktur eine Reihe zufälliger Offsets angegeben.  Anstatt zu entschlüsseln, wo diese Werte gelesen werden, begann ich, die Liste der <code>famicom</code> Funktionen zu studieren. <br><br>  Es stellte sich heraus, dass ich <code>famicom_rom_load</code> brauchte.  Es steuert das Laden des ROM entweder von einer Speicherkarte oder von internen Ressourcen des Spiels. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/999/22b/462/99922b462892ef544d45e849da1c54a5.png"></div><br>  Das Wichtigste in diesem Block "Boot von Speicherkarte" ist, dass er aufruft <br>  <code>memcard_game_load</code> .  Sie legt die Datei erneut auf die Speicherkarte, liest sie und analysiert sie.  Hier werden die wichtigsten Dateiformatoptionen deutlich. <br><br><h4>  Prüfsummenwert </h4><br>  Das erste, was nach dem Hochladen der Datei passiert, ist die Prüfsummenberechnung.  Die Funktion <code>calcSum</code> wird <code>calcSum</code> ist ein sehr einfacher Algorithmus, der die Werte aller Bytes in den Daten von der Speicherkarte summiert.  Die unteren acht Bits des Ergebnisses müssen Null sein.  Das heißt, um diese Prüfung zu bestehen, müssen Sie die Werte aller Bytes in der Quelldatei summieren, den Wert berechnen, der hinzugefügt werden muss, damit die unteren acht Bits Null werden, und diesen Wert dann dem Prüfsummenbyte in der Datei zuweisen. <br><br>  Wenn die Überprüfung fehlschlägt, erhalten Sie eine Meldung über die Unmöglichkeit, die Speicherkarte korrekt zu lesen, und es passiert nichts.  Während des Debuggens muss ich nur diese Prüfung überspringen. <br><br><h4>  ROM kopieren </h4><br>  Gegen Ende von <code>memcard_game_load</code> passiert eine weitere interessante Sache.  Es gibt mehrere weitere interessante Codeblöcke zwischen ihr und der Prüfsumme, aber keiner von ihnen führt zu einer Verzweigung, die die Ausführung dieses Verhaltens überspringt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cc8/376/55d/cc837655d2ec1b207b0f7420db856a1e.png"></div><br>  Wenn ein bestimmter 16-Bit-Ganzzahlwert, der von der Speicherkarte gelesen wird, nicht gleich Null ist, wird eine Funktion aufgerufen, die den Komprimierungsheader im Puffer überprüft.  Es sucht nach proprietären Nintendo-Komprimierungsformaten, indem es sich den Anfang des Yay0- oder Yaz0-Puffers ansieht.  Wird eine dieser Zeilen gefunden, wird die Entpackfunktion aufgerufen.  Andernfalls wird eine einfache Kopierkopierfunktion ausgeführt.  In jedem Fall wird danach eine Variable namens <code>nesinfo_data_size</code> . <br><br>  Ein weiterer Hinweis auf den Kontext ist, dass ROM-Dateien für eingebettete NES-Spiele die Yaz0-Komprimierung verwenden und diese Zeile in den Kopfzeilen ihrer Dateien vorhanden ist. <br><br>  Nachdem ich den Wert beobachtet hatte, der auf Null geprüft und der Puffer an die Komprimierungsprüfungsfunktionen übergeben wurde, fand ich schnell heraus, von wo das Spiel in der Datei auf der Speicherkarte gelesen wurde.  Die Nullprüfung wird für einen Teil des 32-Byte-Puffers durchgeführt, der vom Offset <code>0x640</code> in der Datei kopiert wurde, bei der es sich höchstwahrscheinlich um den ROM-Header handelt.  Diese Funktion überprüft auch andere Teile der Datei und in ihnen befindet sich der Name des Spiels (beginnend mit dem dritten Byte des Headers). <br><br>  In dem Code-Ausführungspfad, den ich gefunden habe, befindet sich der ROM-Puffer unmittelbar nach diesem 32-Byte-Header-Puffer. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7c2/01f/34c/7c201f34c3b9427c288654d487acbcbf.png"></div><br>  Diese Informationen reichen aus, um zu versuchen, eine funktionierende ROM-Datei zu erstellen.  Ich habe gerade eine der anderen Animal Crossing-Sicherungsdateien genommen und sie in einem Hex-Editor bearbeitet, um den Dateinamen durch <code>DobutsunomoriP_F_TEST</code> zu ersetzen und alle Bereiche zu löschen, in denen ich die Daten einfügen wollte. <br><br>  Für einen Testlauf habe ich das Pinball-Spiel-ROM verwendet, das sich bereits im Spiel befindet, und seinen Inhalt nach dem 32-Byte-Header eingefügt.  Anstatt den Prüfsummenwert zu berechnen, setze ich Haltepunkte, sodass ich <code>calcSum</code> einfach überspringe und auch die Ergebnisse anderer Überprüfungen beobachte, die zu einem Zweig führen können, der den ROM-Startvorgang überspringt. <br><br>  Schließlich importierte ich die neue Datei über den Dolphin-Speicherkarten-Manager, startete das Spiel neu und versuchte, die Konsole zu starten. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/199/d08/799/199d087997375f8666284220e7ffcc62.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/527/be8/5f5/527be85f54ab8f37609047d323c6b442.png"></div><br>  Es hat funktioniert!  Es gab einige kleine Grafikfehler im Zusammenhang mit Dolphin-Parametern, die sich auf den vom NES-Emulator verwendeten Grafikmodus auswirkten, aber im Allgemeinen lief das Spiel einwandfrei.  (In neueren Versionen von Dolphin sollte dies standardmäßig funktionieren.) <br><br>  Um sicherzustellen, dass auch andere Spiele gestartet werden, habe ich versucht, mehrere andere ROMs zu schreiben, die nicht im Spiel enthalten waren.  Battletoads wurden gestartet, funktionierten jedoch nach dem Begrüßungsbildschirmtext nicht mehr (nach weiteren Einstellungen konnte ich ihn spielbar machen).  Mega Man hingegen hat perfekt funktioniert: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/923/5a2/7da/9235a27da4d094a496a477cc24cd4846.png"></div><br>  Um zu lernen, wie man neue ROM-Dateien generiert, die ohne das Eingreifen von Debuggern geladen werden können, musste ich anfangen, Code zu schreiben und das Parsen des Dateiformats besser zu verstehen. <br><br><h3>  Externes ROM-Dateiformat </h3><br>  Der wichtigste Teil des Parsens von Dateien findet unter <code>memcard_game_load</code> .  Diese Funktion besteht aus sechs Hauptabschnitten von Code-Analyseblöcken: <br><br><ul><li>  Prüfsumme </li><li>  Dateinamen speichern </li><li>  ROM-Datei-Header </li><li>  Unbekannter Puffer ohne Verarbeitung kopiert </li><li>  Textkommentar, Symbol und Bannerlader (um eine neue Sicherungsdatei zu erstellen) </li><li>  ROM-Bootloader </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f00/194/51e/f0019451e2d0070900f75c62cb83535a.png"></div><br><h4>  Prüfsumme </h4><br>  Die unteren acht Bits der Summe aller Bytewerte in der Sicherungsdatei müssen Null sein.  Hier ist einfacher Python-Code, der das erforderliche Prüfsummenbyte generiert: <br><br><pre> <code class="python hljs">checksum = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> byte_val <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> new_data_tmp: checksum += byte_val checksum = checksum % (<span class="hljs-number"><span class="hljs-number">2</span></span>**<span class="hljs-number"><span class="hljs-number">32</span></span>) <span class="hljs-comment"><span class="hljs-comment"># keep it 32 bit checkbyte = 256 - (checksum % 256) new_data_tmp[-1] = checkbyte</span></span></code> </pre> <br>  Es gibt wahrscheinlich einen speziellen Ort zum Speichern des Prüfsummenbytes, aber das Hinzufügen zum leeren Bereich ganz am Ende der Sicherungsdatei funktioniert recht gut. <br><br><h4>  Dateiname </h4><br>  Auch hier sollte der Name der Sicherungsdatei mit "DobutsunomoriP_F_" beginnen und mit etwas enden, das nicht "SAVE" enthält.  Dieser Dateiname wird einige Male kopiert, und in einem Fall wird der Buchstabe "F" durch "S" ersetzt.  Dies ist der Name der Sicherungsdateien für das NES-Spiel ("DobutsunomoriP_S_NAME"). <br><br><h4>  ROM-Header </h4><br>  Eine direkte Kopie des 32-Byte-Headers wird in den Speicher geladen.  Einige der Werte in diesem Header werden verwendet, um zu bestimmen, wie nachfolgende Abschnitte behandelt werden sollen.  Grundsätzlich sind dies einige 16-Bit-Größenwerte und gepackte Parameterbits. <br><br>  Wenn Sie den vom Header kopierten Zeiger bis zum Start der Funktion verfolgen und die Position ihres Arguments ermitteln, zeigt die Signatur der folgenden Funktion, dass sie tatsächlich den Typ <code>MemcardGameHeader_t*</code> . <br><br><pre> <code class="python hljs">memcard_game_load(unsigned char *, int, unsigned char **, char *, char *, MemcardGameHeader_t *, unsigned char *, unsigned long, unsigned char *, unsigned long)</code> </pre> <br><h4>  Unbekannter Puffer </h4><br>  Überprüft den 16-Bit-Größenwert aus dem Header.  Wenn es nicht gleich Null ist, wird die entsprechende Anzahl von Bytes direkt aus dem Dateipuffer in einen neuen Block des zugewiesenen Speichers kopiert.  Dadurch wird der Datenzeiger in den Dateipuffer verschoben, sodass das weitere Kopieren ab dem nächsten Abschnitt fortgesetzt werden kann. <br><br><h4>  Banner, Symbol und Kommentar </h4><br>  Ein anderer Größenwert wird im Header überprüft. Wenn er ungleich Null ist, wird die Funktion zur Überprüfung der Dateikomprimierung aufgerufen.  Bei Bedarf wird der <code>SetupExternCommentImage</code> gestartet, wonach <code>SetupExternCommentImage</code> . <br><br>  Diese Funktion führt drei Dinge aus: "Kommentar", Bannerbild und Symbol.  Für jeden von ihnen gibt es einen Code im ROM-Header, der zeigt, wie man mit ihnen umgeht.  Es gibt folgende Optionen: <br><br><ol><li>  Standardwert verwenden </li><li>  Kopieren Sie aus dem Bereich Banner / Symbol / Kommentar in die ROM-Datei </li><li>  Aus alternativem Puffer kopieren </li></ol><br>  Die Standardwerte des Codes bewirken, dass das Symbol oder Banner von der Ressource auf der Festplatte geladen wird. Dem Namen der Sicherungsdatei und dem Kommentar (Textbeschreibung der Datei) werden die Werte "Animal Crossing" und "NES Cassette Save Data" zugewiesen.  So sieht es aus: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/906/519/045/906519045718e74cf565c2983401692c.png"></div><br>  Der zweite Wert des Codes kopiert einfach den Namen des Spiels aus der ROM-Datei (eine Alternative zu "Animal Crossing") und versucht dann, die Zeichenfolge "] ROM" im Dateikommentar zu finden und durch "] SAVE" zu ersetzen.  Anscheinend sollten die Dateien, die Nintendo veröffentlichen wollte, das Format „Game Name [NES] ROM“ oder ähnliches haben. <br><br>  Für das Symbol und das Banner versucht der Code, das Bildformat zu bestimmen, einen diesem Format entsprechenden festen Größenwert zu erhalten und das Bild dann zu kopieren. <br><br>  Beim letzten Codewert werden der Dateiname und die Beschreibung ohne Änderungen aus dem Puffer kopiert, und das Symbol und das Banner werden ebenfalls aus dem alternativen Puffer geladen. <br><br><h4>  ROM </h4><br>  Wenn Sie sich den Screenshot des <code>memcard_game_load</code> Kopieren von <code>memcard_game_load</code> genau ansehen, sehen Sie, dass der auf Gleichheit auf Null geprüfte 16-Bit-Wert um 4 Bit nach links verschoben wird (multipliziert mit 16) und dann als Größe der <code>memcpy</code> Funktion verwendet wird, wenn keine Komprimierung erkannt wird.  Dies ist ein weiterer Größenwert, der im Header vorhanden ist. <br><br>  Wenn die Größe ungleich Null ist, werden die ROM-Daten auf Komprimierung überprüft und dann kopiert. <br><br><h3>  Unbekannte Puffer- und Fehlersuche </h3><br>  Obwohl das Herunterladen neuer ROMs ziemlich merkwürdig ist, war das Interessanteste an diesem ROM-Loader für mich, dass dies tatsächlich der einzige Teil des Spiels ist, der Benutzereingaben variabler Größe empfängt und an verschiedene Speicherorte kopiert.  Fast alles andere verwendet Puffer mit konstanter Größe.  Dinge wie Namen und Buchstabentexte mögen unterschiedlich lang erscheinen, aber im Wesentlichen ist der leere Raum einfach mit Leerzeichen gefüllt.  Nullterminierte Zeichenfolgen werden selten verwendet, um häufige Speicherbeschädigungsfehler zu vermeiden, z. B. die Verwendung von <code>strcpy</code> mit einem Puffer, der zu klein ist, um Zeichenfolgen zu kopieren. <br><br>  Ich war sehr interessiert an der Möglichkeit, einen Exploit des Spiels basierend auf gespeicherten Dateien zu finden, und es schien, dass dies die beste Option war. <br><br>  Die meisten oben beschriebenen ROM-Dateivorgänge verwenden Kopien mit konstanter Größe, mit Ausnahme eines unbekannten Puffers und von ROM-Daten.  Leider weist der Code, der diesen Puffer verarbeitet, genau so viel Speicherplatz zu, wie zum Kopieren erforderlich ist, sodass kein Überlauf auftritt und das Festlegen sehr großer ROM-Dateigrößen nicht sehr nützlich war. <br><br>  Aber ich wollte immer noch wissen, was mit diesem Puffer passiert, der ohne Verarbeitung kopiert wird. <br><br><h4>  Handler für NES-Informationsetiketten </h4><br>  Ich kehrte zu <code>famicom_rom_load</code> .  Nach dem Laden des ROM von einer Speicherkarte oder Festplatte werden verschiedene Funktionen aufgerufen: <br><br><ul><li> <code>nesinfo_tag_process1</code> </li> <li> <code>nesinfo_tag_process2</code> </li> <li> <code>nesinfo_tag_process3</code> </li> </ul><br>  Nachdem ich den Ort verfolgt hatte, an dem der unbekannte Puffer kopiert wurde, stellte ich sicher, dass diese Aufgabe von diesen Funktionen ausgeführt wird.  Sie beginnen mit einem Aufruf von <code>nesinfo_next_tag</code> , der einen einfachen Algorithmus ausführt: <br><br><ul><li>  Überprüft, ob der angegebene Zeiger <code>nesinfo_tags_end</code> Zeiger in <code>nesinfo_tags_end</code> .  Wenn es kleiner als <code>nesinfo_tags_end</code> oder <code>nesinfo_tags_end</code> Null ist, prüft es, <code>nesinfo_tags_end</code> die Zeichenfolge "END" im Header des Zeigers vorhanden ist. <br><br><ul><li>  Wenn "END" erreicht ist oder der Zeiger auf oder über <code>nesinfo_tags_end</code> , gibt die Funktion null zurück. </li><li>  Andernfalls wird das Byte am Offset <code>0x3</code> Zeigers zu 4 und zum aktuellen Zeiger addiert, wonach der Wert zurückgegeben wird. </li></ul></li></ul><br>  Dies sagt uns, dass es eine Art Etikettenformat aus einem aus drei Buchstaben bestehenden Namen, einem Datengrößenwert und den Daten selbst gibt.  Das Ergebnis ist ein Zeiger auf die nächste Beschriftung, da die aktuelle Beschriftung übersprungen wird ( <code>cur_ptr + 4</code> überspringt den dreistelligen Namen und ein Byte und <code>size_byte</code> überspringt die Daten). <br><br>  Wenn das Ergebnis nicht Null ist, führt die Etikettenverarbeitungsfunktion eine Reihe von Zeichenfolgenvergleichen durch, um herauszufinden, welches Etikett verarbeitet werden muss.  Einige der in <code>nesinfo_tag_process1</code> überprüften <code>nesinfo_tag_process1</code> : VEQ, VNE, GID, GNO, BBR und QDS. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0f1/094/08b/0f109408b8d01ec8cf4522445463e378.png"></div><br>  Wenn eine Beschriftungsübereinstimmung gefunden wird, wird ein Handlercode ausgeführt.  Einige der Handler tun nichts anderes, als eine Bezeichnung in der Debug-Nachricht anzuzeigen.  Andere haben komplexere Handler.  Nach der Verarbeitung des Etiketts versucht die Funktion, das nächste Etikett zu erhalten und die Verarbeitung fortzusetzen. <br><br>  Glücklicherweise gibt es viele detaillierte Debugging-Meldungen, die angezeigt werden, wenn Tags erkannt werden.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie sind alle auf Japanisch, daher müssen sie zuerst aus Shift-JIS dekodiert und übersetzt werden. Beispielsweise könnte eine Nachricht für QDS lauten: "Laden eines Festplattenspeicherbereichs" oder "Da dies die erste Ausführung ist, erstellen Sie einen Festplattenspeicherbereich". Die Meldungen für den BBR lauten "Laden eines Backups der Batterie" oder "Da dies der erste Start ist, führen wir eine Bereinigung durch". </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beide Codes laden auch einige Werte aus dem Datenabschnitt ihrer Beschriftungen und verwenden sie, um den Versatz in den ROM-Daten zu berechnen, wonach sie Kopiervorgänge ausführen. Offensichtlich sind sie für die Bestimmung der Teile im ROM-Speicher verantwortlich, die mit der Zustandserhaltung verbunden sind.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt auch ein "HSC" -Tag mit einer Debug-Nachricht, die besagt, dass Punktdatensätze verarbeitet werden. </font><font style="vertical-align: inherit;">Sie erhält einen Versatz im ROM aus ihren Tag-Daten sowie den ursprünglichen Wert des Score-Datensatzes. </font><font style="vertical-align: inherit;">Diese Markierungen können verwendet werden, um einen Platz im Speicher des NES-Spiels zum Speichern von Highscores anzuzeigen, möglicherweise um sie in Zukunft zu speichern und wiederherzustellen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diese Tags erstellen ein ziemlich komplexes ROM-Metadaten-Download-System. </font><font style="vertical-align: inherit;">Darüber hinaus führen viele von ihnen zu Anrufen, </font></font><code>memcpy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die auf den in den Etikettendaten übertragenen Werten basieren.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Insektenjagd </font></font></h4><br>  ,     ,     ,           ,    16-  .      16-   NES,        ,            32-   GameCube. <br><br>    ,    ,  <code>memcpy</code> ,   <code>0xFFFF</code> . <br><br><h5> QDS </h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QDS lädt einen 24-Bit-Offset aus seinen Tag-Daten sowie einen 16-Bit-Größenwert. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Gute dabei ist, dass der Offset verwendet wird, um die Zieladresse des Kopiervorgangs zu berechnen. Die Basisadresse des Offsets ist der Anfang der heruntergeladenen Daten, die Kopierquelle befindet sich in der ROM-Datei der Speicherkarte und die Größe wird durch den 16-Bit-Größenwert auf dem Etikett festgelegt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der 24-Bit-Wert hat einen Maximalwert </font></font><code>0xFFFFFF</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, der viel mehr ist als zum Schreiben außerhalb der geladenen ROM-Daten erforderlich. Es gibt jedoch bestimmte Probleme ... </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das erste ist, dass der maximale Größenwert zwar gleich ist </font></font><code>0xFFFF</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, aber zunächst zum Zurücksetzen der Speicherpartition verwendet wird. Wenn der Größenwert zu hoch ist (nicht viel größer </font></font><code>0x1000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), wird die „QDS“ -Markierung im Spielcode zurückgesetzt.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und darin liegt das Problem, weil es </font></font><code>nesinfo_tag_process1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tatsächlich zweimal aufgerufen wird. Zum ersten Mal erhält sie einige Informationen über den Speicherplatz, den sie zur Vorbereitung der gespeicherten Daten benötigt. QDS- und BBR-Tags werden beim ersten Start nicht vollständig verarbeitet. Nach dem ersten Lauf wird ein Ort für die Sicherungsdaten vorbereitet und die Funktion erneut aufgerufen. Dieses Mal werden die QDS- und BBR-Tags vollständig verarbeitet. Wenn jedoch die Tag-Namenszeichenfolgen aus dem Speicher gelöscht werden, ist es unmöglich, die Tags erneut zuzuordnen! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies kann vermieden werden, indem ein kleinerer Größenwert eingestellt wird. Ein weiteres Problem besteht darin, dass sich der Versatzwert nur im Speicher vorwärts bewegen kann und sich die ROM-NES-Daten im Heap ziemlich nahe am Ende des verfügbaren Speichers befinden.</font></font><br><br>      ,          ,    . <br><br>            ,    <code>malloc</code> ,    ,            <code>malloc</code> .           .                 <code>free</code>    . <br><br>     <code>malloc</code>     ( <code>0x7373</code> )      ,       <code>free</code> .      ,   <code>OSPanic</code>   . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/516/68f/447/51668f447b75887250574f1ad1ec1800.png"></div><br>      ,      -  ,    .  ,   -   ,     -    .   -   ,   <code>0x73730000</code>        <em></em> ,    ,        (   ,       ),         . <br><br><h5> <code>nesinfo_update_highscore</code> </h5> <br>   ,   QDS, BBR  HSC —  <code>nesinfo_update_highscore</code> .    QDS, BBR  OFS (offset, )    ,     ,   HSC     .      ,   NES. <br><br>         ,   QDS,  <code>0xFFFF</code> .           BBR  QDS    <em></em> .  ,           .    ,        ROM     ,       <code>0xFFFF</code> . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Basisadresse, zu der der Offset hinzugefügt wird, ist der </font></font><code>0x800C3180</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Speicherdatenpuffer. </font><font style="vertical-align: inherit;">Diese Adresse ist viel niedriger als die ROM-Daten, was uns mehr Freiheit bei der Auswahl eines Aufnahmeorts gibt. </font><font style="vertical-align: inherit;">Beispielsweise ist es recht einfach, die Rücksprungadresse im Stapel in die Adresse umzuschreiben </font></font><code>0x812F95DC</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Leider hat das auch nicht funktioniert. </font><font style="vertical-align: inherit;">Es stellt sich heraus, dass es </font></font><code>nesinfo_tag_process1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auch die akkumulierte Größe der Offsets dieser Labels überprüft und diese Größe verwendet, um den Speicherplatz zu initialisieren:</font></font><br><br><pre> <code class="cpp hljs">bzero(nintendo_hi_0, ((offset_sum + <span class="hljs-number"><span class="hljs-number">0xB</span></span>) * <span class="hljs-number"><span class="hljs-number">4</span></span>) + <span class="hljs-number"><span class="hljs-number">0x40</span></span>)</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7b3/531/0ab/7b35310ab9bae3406ee423acd1c1a1a5.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit dem Versatzwert, den ich zu berechnen versuchte, führte dies dazu, dass </font></font><code>0x48D91EC</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(76.386.796) Bytes Speicher </font><font style="vertical-align: inherit;">gelöscht wurden </font><font style="vertical-align: inherit;">, weshalb das Spiel spektakulär abstürzte.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PAT-Marke </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich hatte bereits begonnen, die Hoffnung zu verlieren, weil all diese Tags, die ungeschützte Anrufe </font></font><code>memcpy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tätigten, fehlgeschlagen waren, noch bevor ich sie verwenden konnte. Ich beschloss, nur den Zweck jedes Tags zu dokumentieren, und kam nach und nach zu den Tags in </font></font><code>nesinfo_tag_process2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die meisten Label-Handler </font></font><code>nesinfo_tag_process2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">starten nie, da sie nur funktionieren, wenn der Zeiger </font></font><code>nesinfo_rom_start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nicht Null ist. Nichts im Code weist diesem Zeiger einen Wert ungleich Null zu. Es wird mit einem Nullwert initialisiert und nie wieder verwendet. Beim Laden wird nur das ROM eingestellt </font></font><code>nesinfo_data_start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, so dass es wie toter Code aussieht. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt jedoch eine Bezeichnung, die auch dann funktionieren kann, wenn sie nicht Null ist </font></font><code>nesinfo_rom_start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: PAT. Dies ist die schwierigste Bezeichnung in einer Funktion </font></font><code>nesinfo_tag_process2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b5a/8fa/e47/b5a8fae47c7ba7f82b2ee9810a950c6e.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es wird auch als Zeiger verwendet </font></font><code>nesinfo_rom_start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, überprüft es jedoch nie auf Null. </font><font style="vertical-align: inherit;">Das PAT-Tag liest seinen eigenen Tag-Datenpuffer und verarbeitet Codes, die Offsets berechnen. </font><font style="vertical-align: inherit;">Diese Offsets werden dem Zeiger hinzugefügt, </font></font><code>nesinfo_rom_start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">um die Zieladresse zu berechnen, und dann werden die Bytes aus dem Patch-Puffer an diesen Speicherort kopiert. </font><font style="vertical-align: inherit;">Dieses Kopieren erfolgt durch Laden und Speichern von Bytes ohne Verwendung von Anweisungen </font></font><code>memcpy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, sodass ich es vorher nicht bemerkt habe. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jeder PAT-Markierungsdatenpuffer hat einen 8-Bit-Typcode, eine 8-Bit-Patchgröße und einen 16-Bit-Offsetwert, gefolgt von den Patchdaten.</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn der Code 2 ist, wird der Versatzwert zur aktuellen Summe der Versätze addiert. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn der Code 9 ist, wird der Versatz um 4 Bits nach oben verschoben und zur aktuellen Summe der Versätze addiert. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn der Code 3 ist, wird die Summe der Offsets auf 0 zurückgesetzt. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die maximale Größe des NES-Informationsetiketts beträgt 255, d. H. Die größte PAT-Patchgröße beträgt 251 Bytes. </font><font style="vertical-align: inherit;">Es können jedoch mehrere PAT-Markierungen verwendet werden, dh Sie können mehr als 251 Byte patchen sowie nicht zusammenhängende Leerzeichen patchen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solange wir eine Reihe von PAT-Sohlen mit Code 2 oder Code 9 haben, sammelt sich der Versatz des Zielzeigers weiter an. </font><font style="vertical-align: inherit;">Beim Kopieren von Patch-Daten werden diese auf Null zurückgesetzt. Wenn Sie jedoch eine Patch-Größe von Null verwenden, kann dies vermieden werden. </font><font style="vertical-align: inherit;">Es ist klar, dass dies verwendet werden kann, um einen beliebigen Versatz mit einem Nullzeiger unter </font></font><code>nesinfo_rom_start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verwendung vieler PAT-Markierungen </font><font style="vertical-align: inherit;">zu berechnen </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt jedoch zwei weitere Überprüfungen der Codewerte ...</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn der Code zwischen </font></font><code>0x80</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und liegt </font></font><code>0xFF</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, wird er hinzugefügt </font></font><code>0x7F80</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und dann um 16 Bit nach oben verschoben. </font><font style="vertical-align: inherit;">Dann wird es zum 16-Bit-Offsetwert addiert und als Endadresse für das Patch verwendet.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dadurch können wir eine Zieladresse für den Patch im Bereich von </font></font><code>0x80000000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bis </font><font style="vertical-align: inherit;">zuweisen </font></font><code>0x807FFFFF</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">! </font><font style="vertical-align: inherit;">Hier befindet sich der Großteil des Animal Crossing-Codes im Speicher. </font><font style="vertical-align: inherit;">Dies bedeutet, dass wir den Animal Crossing-Code selbst mithilfe von ROM-Metadatenbezeichnungen aus einer Datei auf einer Speicherkarte patchen können. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit Hilfe eines kleinen Patch-Loaders können Sie sogar problemlos größere Patches von einer Speicherkarte an eine beliebige Adresse herunterladen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zur schnellen Überprüfung habe ich einen Patch erstellt, der "zuru mode 2" (Spieleentwicklermodus, beschrieben in meinem </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">vorherigen Artikel)</font></a><font style="vertical-align: inherit;"> enthielt</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"></font></a> )    ROM   . ,  -      «zuru mode 1»,       ,     2.                  . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/864/d51/d15/864d51d15fa180ea3fab552a0dd4977b.png"></div><br>       ROM. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/499/dc8/2e4/499dc82e445ffd6bfd607d4f834ccd5a.png"></div><br>   ROM     NES,   . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/694/6ea/3a2/6946ea3a20e0290b75eeba8bbf400d10.png"></div><br>  Es funktioniert! <br><br><h4>     </h4><br>     ,   ,   : <br><br> <code>000000 5a 5a 5a 00 50 41 54 08 a0 04 6f 9c 00 00 00 7d &gt;ZZZ.PAT...o....}&lt; <br> 000010 45 4e 44 00 &gt;END.&lt;</code> <br> <br><ul><li> <code>ZZZ \x00</code> :   . <code>0x00</code> —     : . </li><li> <code>PAT \x08 \xA0 \x04 \x6F\x9C \x00\x00\x00\x7D</code> :  <code>0x80206F9C</code>  <code>0x0000007D</code> . <br><ul><li> <code>0x08</code> —    . </li><li> <code>0xA0</code>    <code>0x7F80</code>  <code>0x8020</code> ,    16   . </li><li> <code>0x04</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ist die Größe der Patch-Daten ( </font></font><code>0x0000007D</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">).</font></font></li><li> <code>0x6F9C</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sind die unteren 16 Bits der Zieladresse. </font></font></li><li> <code>0x0000007D</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sind die Patch-Daten. </font></font></li></ul></li><li> <code>END \x00</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Endmarkierungsmarkierung. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie selbst mit der Erstellung von Patcher- oder ROM-Sicherungsdateien experimentieren möchten, habe </font><font style="vertical-align: inherit;">ich unter </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://github.com/jamchamb/ac-nesrom-save-generator</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> einen sehr einfachen Code zum Generieren von Dateien veröffentlicht. </font><font style="vertical-align: inherit;">Ein Patch wie der oben gezeigte kann mit dem folgenden Befehl generiert werden:</font></font><br><br> <code>$ ./patcher.py Patcher /dev/null zuru_mode_2.gci -p 80206F9c 0000007D</code> <br> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Beliebige Codeausführung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dank dieses Tags können Sie in Animal Crossing eine beliebige Codeausführung erreichen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aber hier kommt die letzte Hürde: Die Verwendung von Patches für Daten funktioniert gut, aber beim Patchen von Codeanweisungen treten Probleme auf. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Patches aufgezeichnet werden, folgt das Spiel weiterhin den alten Anweisungen, die an seiner Stelle waren. Dies scheint ein Caching-Problem zu sein, und tatsächlich ist es das auch. Die GameCube-CPU verfügt über Anweisungs-Caches, wie </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in den technischen Daten beschrieben</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um zu verstehen, wie Sie den Cache leeren können, habe ich begonnen, die Cache-bezogenen Funktionen aus der GameCube SDK-Dokumentation zu untersuchen, und festgestellt </font></font><code>ICInvalidateRange</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Diese Funktion macht die zwischengespeicherten Befehlsblöcke an der angegebenen Speicheradresse ungültig, wodurch der geänderte Befehlsspeicher mit aktualisiertem Code ausgeführt werden kann.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ohne die Möglichkeit, den ursprünglichen Code auszuführen, können wir jedoch immer noch nicht aufrufen </font></font><code>ICInvalidateRange</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Für eine erfolgreiche Codeausführung benötigen wir noch einen Trick. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Als </font></font><code>malloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ich </font><font style="vertical-align: inherit;">die Implementierung </font><font style="vertical-align: inherit;">auf die Möglichkeit der Verwendung eines Exploits mit Heap-Überlauf untersuchte, stellte ich fest, dass Implementierungsfunktionen </font></font><code>malloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mithilfe einer aufgerufenen Datenstruktur dynamisch deaktiviert werden können </font></font><code>my_malloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><code>my_malloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lädt einen Zeiger auf die aktuelle Implementierung </font></font><code>malloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">oder </font></font><code>free</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">von einer statischen Stelle im Speicher und ruft diese Funktion auf, wobei alle übergebenen Argumente übergeben werden </font></font><code>my_malloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NES-Emulator wird aktiv verwendet</font></font><code>my_malloc</code>         ROM NES ,    ,           ,     PAT. <br><br>  <code>my_malloc</code>         ,      ,   ,       <code>malloc</code>  <code>free</code> .      ,          <code>my_malloc</code> . <br><br>  - Dōbutsu no Mori e+   Cuyler      PowerPC           : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://www.youtube.com/watch?v=BdxN7gP6WIc</a> . (Dōbutsu no Mori e+    Animal Crossing  GameCube,    .    .)    ,        ID      Z. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/BdxN7gP6WIc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>     ,   homebrew    Animal <br> Crossing   GameCube. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de417117/">https://habr.com/ru/post/de417117/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de417107/index.html">Entwickler des Spiels während True: Erfahren Sie () mehr über Gamedev-Programmierung, VR-Probleme und ML-Simulationen</a></li>
<li><a href="../de417109/index.html">Richard Hamming: Kapitel 10. Codierungstheorie - I.</a></li>
<li><a href="../de417111/index.html">Online-Konferenzen: Streaming vs Webinar</a></li>
<li><a href="../de417113/index.html">Italienischer 3D-Drucker in Russland: Raise3D N1 Dual - Modellierung und Prototyping</a></li>
<li><a href="../de417115/index.html">Flutter.io begraben oder verbrennen?</a></li>
<li><a href="../de417119/index.html">Paginierung in Vue.js</a></li>
<li><a href="../de417123/index.html">Integration von Spark Streaming und Kafka</a></li>
<li><a href="../de417125/index.html">RTC Meetup .Net: Zum ersten Meeting einladen</a></li>
<li><a href="../de417127/index.html">Tesla unterzeichnet Vereinbarung zum Bau von Gigafactory 3 in China</a></li>
<li><a href="../de417129/index.html">Universum des Geistes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>