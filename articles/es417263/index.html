<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔉 👎🏼 📮 JavaScript como la encarnación del mal ⛸️ 🤾🏽 🤘🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Los desarrolladores de JavaScript a menudo se quejan de que su lenguaje de programación es injustamente culpable de tener demasiadas funciones demasia...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>JavaScript como la encarnación del mal</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/417263/">  Los desarrolladores de JavaScript a menudo se quejan de que su lenguaje de programación es injustamente culpable de tener demasiadas funciones demasiado complicadas y confusas.  Muchos luchan con esta actitud hacia JS, hablando de por qué criticar este lenguaje por lo que es incorrecto.  El autor del material, cuya traducción publicamos hoy, decidió no defender a JS, volviéndose al lado oscuro del lenguaje.  Sin embargo, aquí no quiere hablar, por ejemplo, sobre las trampas que JavaScript establece para los programadores inexpertos.  Le interesa la pregunta de qué sucede si intenta confirmar la mala reputación del idioma con un código que podría escribir alguien a quien no le importan los demás. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/fy/w2/lv/fyw2lvruoubpwmlwluamnw0ye-o.jpeg"></a> <br><br>  En los ejemplos de este material, se utilizarán muchos mecanismos de lenguaje.  Gran parte de lo que ves aquí, por cierto, funciona en otros idiomas, por lo que, con la debida diligencia, también puedes encontrar sus lados oscuros.  Pero JavaScript, ciertamente, tiene un verdadero don para todo tipo de bullying, y es muy difícil competir con otros idiomas en esta área.  Si escribe un código con el que otras personas necesitarán trabajar, JS le brinda una cantidad inagotable de oportunidades para molestar, confundir, acosar y engañar a estas personas.  De hecho, aquí consideraremos solo una pequeña parte de tales técnicas. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Modificadores Getter</font> </h2><br>  JavaScript admite getters, funciones que le permiten trabajar con lo que devuelven como con una propiedad normal.  Bajo uso normal, se ve así: <br><br><pre><code class="hljs pgsql">let greeter = {  <span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Bob'</span></span>,  <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> hello() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> `Hello ${this.name}`} } console.log(greeter.hello) // Hello Bob greeter.name = <span class="hljs-string"><span class="hljs-string">'World'</span></span>; console.log(greeter.hello) // Hello World</code> </pre> <br>  Si usa captadores, tramando el mal, entonces, por ejemplo, puede crear objetos autodestructivos: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> obj = {  foo: <span class="hljs-number"><span class="hljs-number">1</span></span>,  bar: <span class="hljs-number"><span class="hljs-number">2</span></span>,  baz: <span class="hljs-number"><span class="hljs-number">3</span></span>,  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">get</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">evil</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> {     <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> keys = Object.keys(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>);     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(keys) {        delete <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[keys[<span class="hljs-number"><span class="hljs-number">0</span></span>]]     }     <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'Nothing to see here'</span></span>;  } }</code> </pre> <br>  Aquí, con cada llamada a <code>obj.evil</code> , se <code>obj.evil</code> una de las otras propiedades del objeto.  Al mismo tiempo, el código que funciona con <code>obj.evil</code> no sabrá que algo muy extraño está sucediendo justo debajo de su nariz.  Sin embargo, esto es solo el comienzo de la conversación sobre los efectos secundarios nocivos que se pueden lograr con los mecanismos de JavaScript. <br><br><h2>  <font color="#3AC1EF">Proxies inesperados</font> </h2><br>  Los captadores son geniales, pero han existido durante muchos años, muchos desarrolladores los conocen.  Ahora, gracias al proxy, tenemos a nuestra disposición una herramienta mucho más poderosa para entretener con objetos.  Los proxies son una característica de ES6 que le permite crear envoltorios alrededor de los objetos.  Con su ayuda, puede controlar lo que sucede cuando un usuario intenta leer o escribir propiedades de objetos proxy.  Esto permite, por ejemplo, crear un objeto que, en un tercio de los intentos de acceder a una determinada clave de dicho objeto, devolverá un valor mediante una clave seleccionada al azar. <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> obj = {<span class="hljs-attr"><span class="hljs-attr">a</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">b</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">c</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> handler = {   <span class="hljs-attr"><span class="hljs-attr">get</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">obj, prop</span></span></span><span class="hljs-function">) </span></span>{     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random() &gt; <span class="hljs-number"><span class="hljs-number">0.33</span></span>) {       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> obj[prop];     } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {       <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> keys = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.keys(obj);       <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> key = keys[<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor(<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random()*keys.length)]       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> obj[key];     }   } }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> evilObj = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Proxy</span></span>(obj, handler); <span class="hljs-comment"><span class="hljs-comment">//          console.log(evilObj.a); // 1 console.log(evilObj.b); // 1 console.log(evilObj.c); // 3 console.log(evilObj.a); // 2 console.log(evilObj.b); // 2 console.log(evilObj.c); // 3</span></span></code> </pre> <br>  Desafortunadamente, nuestra maldad es parcialmente revelada por herramientas de desarrollo que identifican <code>evilObj</code> como un objeto de tipo <code>Proxy</code> .  Sin embargo, la construcción descrita anteriormente, antes de que se revele su baja esencia, es capaz de brindar muchos minutos agradables a quienes trabajarán con ella. <br><br><h2>  <font color="#3AC1EF">Funciones contagiosas</font> </h2><br>  Hasta ahora, hemos hablado sobre cómo los objetos pueden modificarse a sí mismos.  Pero, además, podemos crear funciones de aspecto inocente que infectan los objetos que se les pasan, cambiando su comportamiento.  Por ejemplo, supongamos que tenemos una función <code>get()</code> simple que le permite buscar de forma segura una propiedad en el objeto que se le pasa, teniendo en cuenta el hecho de que dicho objeto puede no existir: <br><br><pre> <code class="hljs kotlin">let <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> = (obj, property, <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>) =&gt; {  <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!obj) {     <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;  }  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> obj[property]; }</code> </pre> <br>  Es fácil reescribir tal función para que infecte los objetos transferidos a ella, cambiándolos ligeramente.  Por ejemplo, puede asegurarse de que la propiedad a la que ayudó a acceder ya no se muestre cuando intente iterar sobre las claves de un objeto: <br><br><pre> <code class="hljs pgsql">let <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> = (obj, property, defaultValue) =&gt; {  <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!obj || !property <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> obj) {     <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> defaultValue;  }  let <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = obj[property];  <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> obj[property];  <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.defineProperty(obj, property, {     <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>,     enumerable: <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>  })  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> obj[property]; } let x = {a: <span class="hljs-number"><span class="hljs-number">1</span></span>, b:<span class="hljs-number"><span class="hljs-number">2</span></span> }; console.log(<span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.keys(x)); // [<span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span>] console.log(<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(x, <span class="hljs-string"><span class="hljs-string">'a'</span></span>)); console.log(<span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.keys(x)); // [<span class="hljs-string"><span class="hljs-string">'b'</span></span>]</code> </pre> <br>  Este es un ejemplo de una intervención muy sutil en el comportamiento de un objeto.  Enumerar las claves de un objeto no es la operación más notable, ya que no es muy raro, pero no se usa con demasiada frecuencia.  Dado que los errores que puede provocar dicha modificación de objetos no pueden vincularse a su código, pueden existir en un determinado proyecto durante bastante tiempo. <br><br><h2>  <font color="#3AC1EF">Prototipo de desorden</font> </h2><br>  Discutimos varias características de JS arriba, incluidas algunas bastante recientes.  Sin embargo, a veces no hay nada mejor que la tecnología antigua y probada.  Una de las características de JS, por lo que es más criticado, es la capacidad de modificar los prototipos incorporados.  Esta característica se utilizó en los primeros años de JS para extender objetos incrustados, como matrices.  Aquí se explica cómo extender las capacidades de la matriz estándar, por ejemplo, agregando el método <code>contains</code> a un prototipo de objeto <code>Array</code> : <br><br><pre> <code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.prototype.contains = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">item</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.indexOf(item) !== <span class="hljs-number"><span class="hljs-number">-1</span></span>; }</code> </pre> <br>  Como resultado, si hace algo como esto en una biblioteca realmente usada, puede <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">interrumpir el</a> trabajo con los mecanismos básicos del lenguaje en toda la aplicación que usa esta biblioteca.  Por lo tanto, la inclusión de métodos útiles adicionales en prototipos de objetos estándar puede considerarse un movimiento muy exitoso para los desarrolladores de pacientes que desean hacer otras cosas desagradables.  Sin embargo, si hablamos de sociópatas impacientes, se les puede ofrecer algo rápido, pero no menos interesante.  La modificación de prototipos tiene una propiedad muy útil, que consiste en el hecho de que la modificación afecta a todo el código que se ejecuta en un determinado entorno, incluso uno que se carga desde módulos o está en cierres.  Como resultado, si diseña el siguiente código en forma de secuencia de comandos de un tercero (por ejemplo, podría ser una secuencia de comandos de una red publicitaria o un servicio analítico), todo el sitio que use esta secuencia de comandos será propenso a pequeños errores. <br><br><pre> <code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.prototype.map = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fn</span></span></span><span class="hljs-function">) </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> arr = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> arr2 = arr.reduce(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">acc, val, idx</span></span></span><span class="hljs-function">) =&gt;</span></span> {     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random() &gt; <span class="hljs-number"><span class="hljs-number">0.95</span></span>) {        idx = idx + <span class="hljs-number"><span class="hljs-number">1</span></span>     }     <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> index = acc.length - <span class="hljs-number"><span class="hljs-number">1</span></span> === idx ? (idx - <span class="hljs-number"><span class="hljs-number">1</span></span> ) : idx     acc[index] = fn(val, index, arr);     <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> acc;  },[]);  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> arr2; }</code> </pre> <br>  Aquí redefinimos el método estándar <code>Array.prototype.map</code> para que, en general, funcione bien, pero en el 5% de los casos intercambia dos elementos de la matriz.  Esto es lo que puede obtener después de varias llamadas a este método: <br><br><pre> <code class="hljs powershell">let arr = [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">7</span></span>,<span class="hljs-number"><span class="hljs-number">8</span></span>,<span class="hljs-number"><span class="hljs-number">9</span></span>,<span class="hljs-number"><span class="hljs-number">10</span></span>,<span class="hljs-number"><span class="hljs-number">11</span></span>,<span class="hljs-number"><span class="hljs-number">12</span></span>,<span class="hljs-number"><span class="hljs-number">13</span></span>,<span class="hljs-number"><span class="hljs-number">14</span></span>,<span class="hljs-number"><span class="hljs-number">15</span></span>]; let square = x =&gt; x * x; console.log(arr.map(square)); // [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">9</span></span>,<span class="hljs-number"><span class="hljs-number">16</span></span>,<span class="hljs-number"><span class="hljs-number">25</span></span>,<span class="hljs-number"><span class="hljs-number">36</span></span>,<span class="hljs-number"><span class="hljs-number">49</span></span>,<span class="hljs-number"><span class="hljs-number">64</span></span>,<span class="hljs-number"><span class="hljs-number">100</span></span>,<span class="hljs-number"><span class="hljs-number">81</span></span>,<span class="hljs-number"><span class="hljs-number">121</span></span>,<span class="hljs-number"><span class="hljs-number">144</span></span>,<span class="hljs-number"><span class="hljs-number">169</span></span>,<span class="hljs-number"><span class="hljs-number">196</span></span>,<span class="hljs-number"><span class="hljs-number">225</span></span> <span class="hljs-type"><span class="hljs-type">console.log</span></span>(<span class="hljs-type"><span class="hljs-type">arr.map</span></span>(<span class="hljs-type"><span class="hljs-type">square</span></span>)); // [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">9</span></span>,<span class="hljs-number"><span class="hljs-number">16</span></span>,<span class="hljs-number"><span class="hljs-number">25</span></span>,<span class="hljs-number"><span class="hljs-number">36</span></span>,<span class="hljs-number"><span class="hljs-number">49</span></span>,<span class="hljs-number"><span class="hljs-number">64</span></span>,<span class="hljs-number"><span class="hljs-number">81</span></span>,<span class="hljs-number"><span class="hljs-number">100</span></span>,<span class="hljs-number"><span class="hljs-number">121</span></span>,<span class="hljs-number"><span class="hljs-number">144</span></span>,<span class="hljs-number"><span class="hljs-number">169</span></span>,<span class="hljs-number"><span class="hljs-number">196</span></span>,<span class="hljs-number"><span class="hljs-number">225</span></span>] <span class="hljs-type"><span class="hljs-type">console.log</span></span>(<span class="hljs-type"><span class="hljs-type">arr.map</span></span>(<span class="hljs-type"><span class="hljs-type">square</span></span>)); // [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">9</span></span>,<span class="hljs-number"><span class="hljs-number">16</span></span>,<span class="hljs-number"><span class="hljs-number">25</span></span>,<span class="hljs-number"><span class="hljs-number">36</span></span>,<span class="hljs-number"><span class="hljs-number">49</span></span>,<span class="hljs-number"><span class="hljs-number">64</span></span>,<span class="hljs-number"><span class="hljs-number">81</span></span>,<span class="hljs-number"><span class="hljs-number">100</span></span>,<span class="hljs-number"><span class="hljs-number">121</span></span>,<span class="hljs-number"><span class="hljs-number">144</span></span>,<span class="hljs-number"><span class="hljs-number">169</span></span>,<span class="hljs-number"><span class="hljs-number">196</span></span>,<span class="hljs-number"><span class="hljs-number">225</span></span>]</code> </pre> <br>  Aquí lo lanzamos tres veces.  Lo que sucedió cuando lo usó por primera vez es ligeramente diferente de los siguientes dos resultados de llamarlo.  Este es un cambio menor, no siempre causa algún tipo de falla.  Y la mejor parte es que es imposible comprender la causa de los errores que rara vez ocurren debido a este método sin leer su código fuente, que es la causa de estos errores.  Nuestra función no llama la atención cuando se trabaja con herramientas de desarrollador, no produce errores cuando se trabaja en modo estricto.  En general, con la ayuda de algo como esto, es completamente posible volver loco a alguien. <br><br><h2>  <font color="#3AC1EF">Nombres complicados</font> </h2><br>  Nombrar entidades, como saben, es una de las dos tareas más difíciles de la informática.  Por lo tanto, los malos nombres son inventados no solo por aquellos que buscan dañar a otros conscientemente.  Por supuesto, puede ser difícil creer en usuarios experimentados de Linux.  Tenían años a su disposición para asociar al intruso informático con el peor nombre (Microsoft) con las formas más profundas del mal.  Pero los nombres fallidos no perjudican directamente a los programas.  No hablaremos de cosas pequeñas como nombres engañosos y comentarios que han perdido relevancia.  Por ejemplo, sobre tales: <br><br><pre> <code class="hljs pgsql">//   let arrayOfNumbers = { userid: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Darth Vader'</span></span>};</code> </pre> <br>  Para profundizar en esto y comprender que hay algo mal con el comentario y con el nombre de la variable, aquellos que leen el código en el que esto ocurre tendrán que reducir la velocidad y pensar un poco.  Pero esto no tiene sentido.  Hablemos de cosas realmente interesantes.  ¿Sabía que la mayoría de los caracteres Unicode se pueden usar para nombrar variables en JavaScript?  Si usted, en el asunto de asignar nombres de variables, es positivo, le gustará la idea de usar nombres en forma de iconos ( <b>Habr cortó emoji, aunque en el original aquí después dejémoslo era emoji kakahi</b> ): <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> = { postid: <span class="hljs-number"><span class="hljs-number">123</span></span>, postName: <span class="hljs-string"><span class="hljs-string">'Evil JavaScript'</span></span>}</code> </pre> <br>  Sin embargo, estamos hablando de cosas realmente desagradables aquí, por lo que es mejor que recurramos a caracteres que son similares a los que generalmente se usan para nombrar variables, pero no lo son.  Por ejemplo, hagámoslo así: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> oｂj = {}; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(obj); <span class="hljs-comment"><span class="hljs-comment">// Error!</span></span></code> </pre> <br>  La letra <code>ｂ</code> en el nombre <code>oｂj</code> puede parecer casi normal, pero no es una letra latina minúscula b.  Esta es la llamada letra latina minúscula de ancho completo b.  Los símbolos son diferentes, por lo que cualquiera que intente ingresar el nombre de una variable de forma manual probablemente estará muy confundido. <br><br><h2>  <font color="#3AC1EF">Resumen</font> </h2><br>  A pesar de la historia de varias cosas desagradables que se pueden hacer usando JavaScript, este material está dirigido a advertir a los programadores que usen trucos como los descritos, y transmitirles el hecho de que esto puede causar un daño real.  El autor del material dice que siempre es útil saber qué problemas pueden aparecer en un código mal escrito.  Él cree que se puede encontrar algo similar en proyectos reales, pero espera que exista en una forma menos destructiva.  Sin embargo, el hecho de que el programador que escribió dicho código no haya tratado de dañar a otros no hace que sea más fácil trabajar con dicho código y depurarlo.  Al mismo tiempo, el conocimiento de los intentos intencionales de dañar puede ampliar los horizontes de un programador y ayudarlo a encontrar una fuente de errores similares.  Nadie puede estar completamente seguro de que no hay ningún error en el código con el que funciona.  Quizás alguien, sabiendo sobre su tendencia a sospechar demasiado, trate de tranquilizarse de que la ansiedad por tales errores es solo un producto de su imaginación.  Sin embargo, esto no evitará que tales errores, posiblemente introducidos en algún código intencionalmente, se prueben una vez. <br><br>  <b>Estimados lectores!</b>  ¿Has encontrado en la práctica algo similar a lo que se discutió en este artículo? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/xh/-2/n8/xh-2n8h-0cldicbple6-6dque3c.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es417263/">https://habr.com/ru/post/es417263/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es417249/index.html">La Cámara de Auditoría de EE. UU. Advierte: SpaceX y Boeing están esperando nuevas demoras, es posible la interrupción de EE. UU. En los vuelos a la EEI</a></li>
<li><a href="../es417251/index.html">Usando el ojo de pez en Raspberry Pi 3 con ROS - Parte 1</a></li>
<li><a href="../es417255/index.html">Reloj de cuco basado en tormentas mentales de Lego</a></li>
<li><a href="../es417259/index.html">Eventos digitales en Moscú del 16 al 22 de julio.</a></li>
<li><a href="../es417261/index.html">Uber después de un accidente que involucró a su automóvil robótico decidió reducir el personal de los operadores de máquinas inteligentes en Pittsburgh</a></li>
<li><a href="../es417265/index.html">Top 10: los mejores informes de DotNext 2017 Moscú</a></li>
<li><a href="../es417269/index.html">Dónde ir para un diseñador: prestigiosos premios internacionales</a></li>
<li><a href="../es417271/index.html">¿Puede un hacker bloquear el Canal de la Mancha?</a></li>
<li><a href="../es417273/index.html">Realización de una guía de voz basada en YandexSpeechKit</a></li>
<li><a href="../es417275/index.html">7 habilidades de diseñadores efectivos. Potentes herramientas de desarrollo profesional</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>