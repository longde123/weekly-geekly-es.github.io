<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äçüåæ üßùüèº ‚ö†Ô∏è API de Linux Administrar el almacenamiento en b√∫fer de E / S del archivo del n√∫cleo üïµüèº üöÅ üì≠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola habrozhiteli! Ya escribimos sobre el libro de Michael Kerrisk "API de Linux". Gu√≠a completa " . Ahora hemos decidido publicar un extracto del lib...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>API de Linux Administrar el almacenamiento en b√∫fer de E / S del archivo del n√∫cleo</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/436986/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/qk/pj/rf/qkpjrftqtsq-bnryowiwf_v88us.jpeg" align="left" alt="imagen"></a>  Hola habrozhiteli!  Ya escribimos sobre el libro de Michael Kerrisk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"API de Linux".</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Gu√≠a completa "</a> .  Ahora hemos decidido publicar un extracto del libro "Administraci√≥n del almacenamiento intermedio de E / S de archivos administrado en el n√∫cleo" <br><br>  Se puede forzar el restablecimiento de la memoria intermedia del n√∫cleo para los archivos de salida.  A veces, esto es necesario si la aplicaci√≥n, antes de continuar trabajando (por ejemplo, un proceso que registra cambios en la base de datos), debe garantizar que la salida se escriba realmente en el disco (o al menos en la cach√© del disco de hardware). <br><br>  Antes de considerar las llamadas al sistema utilizadas para controlar el almacenamiento en b√∫fer del kernel, valdr√≠a la pena considerar varias definiciones relacionadas de SUSv3. <br><a name="habracut"></a><br>  <b>E / S sincronizada con integridad de datos e archivos</b> <br><br>  En SUSv3, el concepto de finalizaci√≥n de E / S sincronizada significa "una operaci√≥n de E / S que condujo a una transferencia exitosa de datos [al disco] o fue diagnosticada como no exitosa". <br><br>  SUSv3 define dos tipos diferentes de terminaciones de E / S sincronizadas.  La diferencia entre los tipos se relaciona con los metadatos ("datos sobre datos") que describen el archivo.  El kernel los almacena junto con los datos del archivo mismo.  Los detalles de los metadatos del archivo se analizar√°n en la secci√≥n 14.4 al examinar los inodos de archivo.  Mientras tanto, ser√° suficiente tener en cuenta que los metadatos del archivo incluyen informaci√≥n como la informaci√≥n sobre el propietario del archivo y su grupo, los derechos de acceso al archivo, el tama√±o del archivo, la cantidad de enlaces duros al archivo, las marcas de tiempo que muestran la hora de la √∫ltima vez que se accedi√≥ al archivo, la hora en que se modific√≥ por √∫ltima vez y la hora del √∫ltimo cambio de metadatos, as√≠ como los punteros a los bloques de datos. <br><br>  El primer tipo de finalizaci√≥n de E / S sincronizada en SUSv3 es la finalizaci√≥n de integridad de datos.  Al actualizar los datos del archivo, se debe garantizar la transferencia de informaci√≥n suficiente para permitir una mayor extracci√≥n de estos datos para continuar trabajando. <br><br>  - para una operaci√≥n de lectura, esto significa que los datos del archivo solicitado se han transferido (desde el disco) al proceso.  Si hay operaciones de escritura pendientes que pueden afectar los datos solicitados, los datos se transferir√°n al disco antes de leerlos. <br><br>  - para una operaci√≥n de escritura, esto significa que los datos especificados en la solicitud de escritura se transfirieron (al disco), como todos los metadatos de archivo necesarios para extraer estos datos.  El punto clave a tener en cuenta: para garantizar que los datos se extraen del archivo modificado, no es necesario transferir todos los archivos medaten.  Un ejemplo del atributo de metadatos de un archivo modificado que debe migrarse es su tama√±o (si la operaci√≥n de escritura aumenta el tama√±o del archivo).  Por el contrario, las marcas de tiempo del archivo a modificar no necesitar√°n transferirse al disco antes de que ocurra la recuperaci√≥n de datos posterior. <br><br>  El segundo tipo de finalizaci√≥n de E / S sincronizada definida en SUSv3 es la finalizaci√≥n de integridad de archivo.  Esta es una opci√≥n avanzada para completar E / S sincronizadas con integridad de datos.  La diferencia entre este modo es que durante la actualizaci√≥n del archivo, todos sus metadatos se transfieren al disco, incluso si esto no es necesario para la extracci√≥n posterior de los datos del archivo. <br><br>  <b>El sistema llama para controlar el almacenamiento intermedio del kernel durante la E / S de archivo</b> <br><br>  La llamada al sistema fsync () restablece todos los datos almacenados en el b√∫fer y todos los metadatos que est√°n asociados con un archivo abierto que tiene un descriptor fd.  Llamar a fsync () coloca el archivo en un estado de integridad (archivo) despu√©s de completar la E / S sincr√≥nica. <br><br>  La llamada fsync () devuelve el control solo despu√©s de que se completa la transferencia de datos al dispositivo de disco (o al menos a su cach√©). <br><br><pre><code class="plaintext hljs">#include &lt;unistd.h&gt; int fsync(int fd);</code> </pre> <br>  Devuelve en caso de √©xito 0 o -1 en caso de error <br><br>  La llamada al sistema fdatasync () funciona exactamente como fsync (), pero coloca el archivo en un estado de integridad (datos) despu√©s de completar la E / S sincr√≥nica. <br><br><pre> <code class="plaintext hljs">#include &lt;unistd.h&gt; int fdatasync(int fd);</code> </pre> <br>  Devuelve en caso de √©xito 0 o -1 en caso de error <br><br>  El uso de fdatasync () reduce potencialmente la cantidad de operaciones de disco de dos requeridas por la llamada del sistema fsync () a una.  Por ejemplo, si los datos del archivo han cambiado, pero el tama√±o sigue siendo el mismo, llamar a fdatasync () solo obliga a actualizar los datos.  (Ya se ha se√±alado anteriormente que para completar una operaci√≥n de E / S s√≠ncrona con integridad de datos, no hay necesidad de transferir cambios a atributos como la √∫ltima vez que se modific√≥ el archivo). Por el contrario, llamar a fsync () tambi√©n forzar√° la transferencia de metadatos al disco. <br><br>  Tal reducci√≥n en el n√∫mero de operaciones de E / S de disco ser√° √∫til para aplicaciones individuales para las cuales el rendimiento y la actualizaci√≥n precisa de metadatos espec√≠ficos (por ejemplo, marcas de tiempo) juegan un papel decisivo.  Esto puede conducir a mejoras de rendimiento significativas para aplicaciones que producen m√∫ltiples actualizaciones de archivos a la vez.  Debido a que los datos y metadatos del archivo generalmente se encuentran en diferentes partes del disco, la actualizaci√≥n de ambos requerir√° b√∫squedas repetidas hacia adelante y hacia atr√°s en el disco. <br><br>  En Linux 2.2 y versiones anteriores, fdatasync () se implementa como una llamada a fsync (), por lo que no aumenta el rendimiento. <br><br><blockquote>  A partir de la versi√≥n del kernel 2.6.17, Linux proporciona una llamada de sistema no est√°ndar sync_file_range ().  Le permite controlar con mayor precisi√≥n el proceso de vaciado de datos de archivos al disco que fdatasync ().  Al llamar, puede especificar el √°rea que se colocar√° en el archivo y establecer marcas que establezcan las condiciones para bloquear esta llamada.  Consulte la p√°gina del manual sync_file_range (2) para obtener m√°s detalles. </blockquote><br>  La llamada al sistema sync () hace que todas las memorias intermedias del n√∫cleo que contienen informaci√≥n actualizada del archivo (es decir, bloques de datos, bloques de puntero, metadatos, etc.) se vac√≠en al disco. <br><br><pre> <code class="plaintext hljs">#include &lt;unistd.h&gt; void sync(void);</code> </pre> <br>  En la implementaci√≥n de Linux, la funci√≥n sync () devuelve el control solo despu√©s de que todos los datos se hayan transferido al dispositivo de disco (o al menos a su cach√©).  Pero en SUSv3, se permite que sync () simplemente introduzca la transferencia de datos para la operaci√≥n de E / S en el plan y devuelva el control hasta que se complete la transferencia. <br><br><blockquote>  Un subproceso de kernel ejecutado continuamente descarga los b√∫feres de kernel modificados en el disco si no se sincronizaron expl√≠citamente durante 30 segundos.  Esto se hace para evitar que los b√∫feres de datos no est√©n sincronizados con el archivo de disco correspondiente durante largos per√≠odos de tiempo (y no exponerlos al riesgo de p√©rdida en caso de una falla del sistema).  En Linux 2.6, esta tarea es realizada por el hilo del n√∫cleo pdflush.  (En Linux 2.4, fue ejecutado por el hilo del n√∫cleo kupdated). <br><br>  El per√≠odo (en cent√©simas de segundo) despu√©s del cual el b√∫fer modificado debe ser vaciado al disco por el c√≥digo de flujo pdflush se define en el archivo / proc / sys / vm / dirty_expire_centisecs.  Los archivos adicionales en el mismo directorio controlan otras caracter√≠sticas de la operaci√≥n realizada por la secuencia pdflush. <br></blockquote><br>  <b>Active el modo de sincronizaci√≥n para todos los registros: O_SYNC</b> <br><br>  Al especificar el indicador O_SYNC al llamar a open (), todas las operaciones de salida posteriores se realizan en modo s√≠ncrono: <br><br><pre> <code class="plaintext hljs">fd = open(pathname, O_WRONLY | O_SYNC);</code> </pre> <br>  Despu√©s de esta llamada a open (), cada operaci√≥n de escritura () realizada en un archivo vac√≠a autom√°ticamente los datos y metadatos del archivo en el disco (es decir, las escrituras se realizan como operaciones de escritura sincronizadas con integridad de archivo). <br><br><blockquote>  En versiones anteriores del sistema BSD, el indicador O_FSYNC se usaba para proporcionar la funcionalidad incluida con el indicador O_SYNC.  En glibc, el indicador O_FSYNC se define como sin√≥nimo de O_SYNC. </blockquote><br>  <b>Impacto en el rendimiento del indicador O_SYNC</b> <br><br>  El uso del indicador O_SYNC (o las llamadas frecuentes a fsync (), fdatasync () o sync ()) pueden afectar en gran medida el rendimiento.  En la mesa  La Figura 13.3 muestra el tiempo requerido para escribir 1 mill√≥n de bytes en un archivo que se acaba de crear (en el sistema de archivos ext2) para varios tama√±os de b√∫fer con el indicador O_SYNC establecido y sin marcar.  Los resultados se obtuvieron (usando el programa filebuff / write_bytes.c provisto en el c√≥digo fuente del libro) usando el kernel "vanilla" versi√≥n 2.6.30 y el sistema de archivos ext2 con un tama√±o de bloque de 4096 bytes.  Cada l√≠nea contiene el valor promedio obtenido despu√©s de 20 inicios para un tama√±o de b√∫fer dado. <br><br>  Tabla 13.3.  El efecto del indicador O_SYNC en una velocidad de escritura de 1 mill√≥n de bytes <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/_r/va/c0/_rvac0j3fu9affstt4_poiq5ybw.png" alt="imagen"></div><br>  Como puede ver, la especificaci√≥n de la bandera O_SYNC conduce a un aumento monstruoso en el tiempo dedicado al usar un b√∫fer de 1 byte m√°s de 1000 veces.  Tenga en cuenta tambi√©n la gran diferencia que se produce al ejecutar registros con el indicador O_SYNC entre el tiempo transcurrido y el tiempo de uso de la CPU.  Es una consecuencia del bloqueo de la ejecuci√≥n del programa cuando el contenido real de cada b√∫fer se vac√≠a en el disco. <br><br>  En los resultados que se muestran en la tabla.  13.3, otro factor que afecta el rendimiento cuando se usa O_SYNC no se tiene en cuenta.  Las unidades de disco modernas tienen una memoria cach√© interna grande y, de forma predeterminada, la configuraci√≥n del indicador O_SYNC simplemente transfiere datos a esta memoria cach√©.  Si deshabilita el almacenamiento en cach√© de disco (usando el comando hdparm ‚ÄìW0), el impacto en el rendimiento de O_SYNC ser√° a√∫n m√°s significativo.  Con un tama√±o de b√∫fer de 1 byte, el tiempo transcurrido aumentar√° de 1030 segundos a aproximadamente 16,000 segundos.  Con un tama√±o de b√∫fer de 4096 bytes, el tiempo transcurrido aumentar√° de 0,34 segundos a 4 segundos.  Como resultado, si necesita forzar que las memorias intermedias del kernel se vac√≠en en el disco, debe considerar si es posible dise√±ar la aplicaci√≥n utilizando memorias intermedias m√°s grandes para write () o considere usar llamadas peri√≥dicas fsync () o fdatasync () en lugar del indicador O_SYNC. <br><br>  <b>Banderas O_DSYNC y O_RSYNC</b> <br><br>  SUSv3 define dos indicadores de estado de archivo abierto adicionales relacionados con E / S sincronizada: O_DSYNC y O_RSYNC. <br><br>  El indicador O_DSYNC da como resultado operaciones de escritura sincronizadas posteriores con integridad de datos de E / S terminadas (similar al uso de fdatasync ()).  El efecto de su operaci√≥n es diferente del efecto causado por el indicador O_SYNC, cuyo uso conduce a operaciones de escritura sincronizadas posteriores con integridad de archivo (como fsync ()). <br><br>  El indicador O_RSYNC se especifica junto con O_SYNC o O_DSYNC y conduce a una extensi√≥n del comportamiento asociado con estos indicadores durante las operaciones de lectura.  Especificar los indicadores O_RSYNC y O_DSYNC al abrir el archivo da como resultado operaciones de lectura sincronizadas posteriores con integridad de datos (es decir, antes de que se complete la lectura, todas las entradas de archivo pendientes se completan debido a la presencia de O_DSYNC).  Especificar los indicadores O_RSYNC y O_SYNC al abrir el archivo conduce a operaciones de lectura sincronizadas posteriores con integridad del archivo (es decir, antes de que se complete la lectura, todas las entradas de archivo pendientes se completan debido a la presencia de O_SYNC). <br><br>  Antes del lanzamiento de la versi√≥n 2.6.33 del n√∫cleo, los indicadores O_DSYNC y O_RSYNC no se implementaron en Linux, y estas constantes se definieron en los archivos de encabezado glibc como la configuraci√≥n del indicador O_SYNC.  (En el caso de O_RSYNC, esto no era cierto, ya que O_SYNC no afecta ninguna caracter√≠stica funcional de las operaciones de lectura). <br><br>  A partir de la versi√≥n del kernel 2.6.33, Linux implementa el indicador O_DSYNC, y es probable que la implementaci√≥n del indicador O_RSYNC se agregue en futuras versiones del kernel. <br><br><blockquote>  Antes del lanzamiento del kernel 2.6.33 en Linux, no hab√≠a una implementaci√≥n completa de la sem√°ntica O_SYNC.  En cambio, el indicador O_SYNC se implement√≥ como O_DSYNC.  En aplicaciones vinculadas con versiones anteriores de la biblioteca GNU C para n√∫cleos anteriores, en las versiones de Linux 2.6.33 y posteriores, el indicador O_SYNC todav√≠a se comporta como O_DSYNC.  Esto se hace para mantener el comportamiento familiar de tales programas.  (Para preservar la compatibilidad binaria hacia atr√°s en el kernel 2.6.33, al indicador O_DSYNC se le asign√≥ el indicador O_SYNC anterior, y el nuevo indicador O_SYNC incluye el indicador O_DSYNC (04010000 y 010000 respectivamente en una de las m√°quinas). Esto permite que las aplicaciones se compilen con nuevos archivos de encabezado , obtenga al menos la sem√°ntica O_DSYNC en los n√∫cleos lanzados antes de la versi√≥n 2.6.33.) </blockquote><br><h3>  13.4  Descripci√≥n general del almacenamiento intermedio de E / S </h3><br>  En la fig.  La Figura 13.1 muestra el esquema de almacenamiento en b√∫fer utilizado (para archivos de salida) por la biblioteca stdio y el kernel, y tambi√©n muestra los mecanismos para controlar cada tipo de almacenamiento en b√∫fer.  Si baja el gr√°fico hasta el centro, ver√° la transferencia de datos del usuario por las funciones de la biblioteca stdio al b√∫fer stdio, que funciona en el espacio de memoria del usuario.  Cuando este b√∫fer est√° lleno, la biblioteca stdio recurre a la llamada al sistema write (), que transfiere datos al cach√© del b√∫fer del n√∫cleo (ubicado en la memoria del n√∫cleo).  Como resultado, el n√∫cleo inicia una operaci√≥n de disco para transferir datos al disco. <br><br>  En la parte izquierda del circuito en la fig.  13.1 muestra las llamadas que se pueden usar en cualquier momento para forzar expl√≠citamente el vaciado de cualquiera de las memorias intermedias.  La parte derecha muestra las llamadas que se pueden usar para realizar un restablecimiento autom√°tico, ya sea desactivando el almacenamiento en b√∫fer en la biblioteca stdio o activando la salida del archivo de un modo de ejecuci√≥n s√≠ncrono para las llamadas del sistema, de modo que cada llamada de escritura () se transfiera inmediatamente al disco. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cc/1f/of/cc1fofbz5pqtee-lktnypfahsac.png" alt="imagen"></div><br><br><h3>  13.5  Notificaci√≥n de E / S del n√∫cleo </h3><br>  La llamada al sistema posix_fadvise () permite que el proceso informe al n√∫cleo de su m√©todo preferido para acceder a los datos del archivo. <br><br>  El kernel puede (pero no tiene que) usar la informaci√≥n proporcionada por la llamada al sistema posix_fadvise () para optimizar su uso de la memoria cach√© del b√∫fer, aumentando as√≠ el rendimiento de E / S para el proceso y para el sistema en su conjunto.  Llamar a posix_fadvise () no afecta la sem√°ntica del programa. <br><br><pre> <code class="plaintext hljs">#define _XOPEN_SOURCE 600 #include &lt;fcntl.h&gt; int posix_fadvise(int fd, off_t offset, off_t len, int advice);</code> </pre> <br>  Devuelve el √©xito 0 o un n√∫mero de error positivo cuando ocurre <br><br>  El argumento fd es un descriptor de archivo que identifica el archivo para el que se debe contactar al n√∫cleo.  Los argumentos offset y len identifican el √°rea del archivo al que se refiere la notificaci√≥n: offset indica el desplazamiento inicial del √°rea, y len indica su tama√±o en bytes.  Establecer len en 0 significa que todos los bytes est√°n destinados, comenzando con desplazamiento y terminando con el final del archivo.  (En las versiones de kernel anteriores a 2.6.6, el valor 0 para len se interpretaba literalmente como 0 bytes). <br><br>  El argumento de asesoramiento muestra la naturaleza prevista del acceso del proceso al archivo.  Se define con uno de los siguientes valores. <br><br>  POSIX_FADV_NORMAL: el proceso no tiene una notificaci√≥n especial con respecto a los patrones de tratamiento.  Este es el comportamiento predeterminado si no se dan notificaciones para el archivo.  En Linux, esta operaci√≥n establece la ventana para leer proactivamente los datos de un archivo a su tama√±o original (128 KB). <br><br>  POSIX_FADV_SEQUENTIAL: el proceso implica la lectura secuencial de datos de compensaciones m√°s peque√±as a m√°s grandes.  En Linux, esta operaci√≥n establece la ventana para leer proactivamente los datos de un archivo para duplicar su valor original. <br><br>  POSIX_FADV_RANDOM: el proceso implica acceder a los datos en orden aleatorio.  En Linux, esta opci√≥n deshabilita la lectura proactiva de datos de un archivo. <br><br>  POSIX_FADV_WILLNEED: el proceso implica acceder al √°rea especificada del archivo en un futuro pr√≥ximo.  El n√∫cleo lee los datos de manera preventiva para llenar el cach√© del b√∫fer con datos de archivos en el rango especificado por los argumentos offset y len.  Las siguientes llamadas read () al archivo no bloquean las E / S del disco, sino que simplemente recuperan datos de la memoria cach√© del b√∫fer.  El n√∫cleo no garantiza el tiempo que los datos recuperados del archivo est√°n en la memoria cach√© del b√∫fer.  Si durante la operaci√≥n de otro proceso o n√∫cleo hay una necesidad especial de memoria, la p√°gina eventualmente se reutilizar√°.  En otras palabras, si la memoria tiene una gran demanda, debemos garantizar un peque√±o intervalo de tiempo entre la llamada a posix_fadvise () y la llamada posterior (o llamadas) para leer ().  (La llamada al sistema readahead () espec√≠fica de Linux proporciona una funcionalidad equivalente a la operaci√≥n POSIX_FADV_WILLNEED). <br><br>  POSIX_FADV_DONTNEED: el proceso no implica llamadas al √°rea de archivo especificada en un futuro pr√≥ximo.  De esta manera, se notifica al n√∫cleo que puede liberar las p√°ginas de cach√© correspondientes (si las hay).  En Linux, esta operaci√≥n se realiza en dos etapas.  Primero, si la cola de escritura en el dispositivo host no est√° llena de una serie de solicitudes, el n√∫cleo descarta cualquier p√°gina de cach√© modificada en el √°rea especificada.  El n√∫cleo luego intenta liberar todas las p√°ginas de cach√© del √°rea especificada.  Para las p√°ginas modificadas en esta √°rea, la segunda etapa se completar√° con √©xito solo si se grabaron en el dispositivo base durante la primera etapa, es decir, la cola de grabaci√≥n en el dispositivo no est√° llena.  Como la aplicaci√≥n no puede verificar el estado de la cola en el dispositivo, puede garantizar que las p√°ginas de cach√© se liberen llamando a fsync () o fdatasync () en el controlador fd antes de aplicar POSIX_FADV_DONTNEED. <br><br>  POSIX_FADV_NOREUSE: el proceso implica un acceso √∫nico a los datos en el √°rea especificada del archivo, sin reutilizarlo.  Por lo tanto, se notifica al n√∫cleo que puede liberar p√°ginas despu√©s de un solo acceso a ellas.  En Linux, esta operaci√≥n se est√° ignorando actualmente. <br><br>  La especificaci√≥n posix_fadvise () apareci√≥ solo en SUSv3, y esta interfaz no es compatible con todas las implementaciones de UNIX.  En Linux, la llamada posix_fadvise () se ha proporcionado desde la versi√≥n 2.6 del kernel. <br><br><h3>  13.6  Bypass de cach√© de b√∫fer: E / S directa </h3><br>  A partir de la versi√≥n 2.4 del kernel, Linux permite que una aplicaci√≥n omita la memoria cach√© del b√∫fer al realizar E / S de disco al mover datos directamente desde el espacio de memoria del usuario a un archivo o dispositivo de disco.  Algunas veces este modo se llama E / S directa o sin procesar. <br><br><blockquote>  La informaci√≥n proporcionada aqu√≠ es solo para Linux y no est√° estandarizada en SUSv3.  Sin embargo, algunas opciones de acceso directo de E / S para dispositivos o archivos son proporcionadas por la mayor√≠a de las implementaciones de UNIX. </blockquote><br>  A veces, la E / S directa no se entiende como un medio para lograr un alto rendimiento de E / S.  Pero para la mayor√≠a de las aplicaciones, el uso de E / S directa puede reducir significativamente el rendimiento.  El hecho es que el kernel realiza varias optimizaciones para mejorar el rendimiento de E / S mediante el uso de una memoria cach√© de b√∫fer, incluida la lectura secuencial proactiva de datos, la realizaci√≥n de E / S en grupos de bloques de disco y permitiendo que los procesos accedan al mismo volumen el mismo archivo, comparte buffers en el cach√©.  Todos estos tipos de optimizaci√≥n cuando se usa E / S directa se pierden.  Est√° destinado solo a aplicaciones con requisitos de E / S especializados, por ejemplo, sistemas de administraci√≥n de bases de datos que realizan su propio almacenamiento en cach√© y optimizaci√≥n de E / S, y que no necesitan que el kernel pierda tiempo y memoria de la CPU para realizar las mismas tareas. <br><br>  La entrada-salida directa se puede realizar en relaci√≥n con un solo archivo o en relaci√≥n con un dispositivo de bloque (por ejemplo, un disco).  Para hacer esto, al abrir un archivo o dispositivo usando la llamada open (), se especifica el indicador O_DIRECT. <br><br>  El indicador O_DIRECT funciona desde la versi√≥n del kernel 2.4.10.  El uso de este indicador no es compatible con todos los sistemas de archivos y versiones del kernel de Linux.  La mayor√≠a de los sistemas de archivos b√°sicos admiten el indicador O_DIRECT, pero muchos sistemas de archivos que no son UNIX (como VFAT) no.  Puede probar el soporte para esta caracter√≠stica probando el sistema de archivos seleccionado (si el sistema de archivos no es compatible con O_DIRECT, al abrir open () fallar√° con un error EINVAL) o al examinar el c√≥digo fuente del n√∫cleo para esto. <br><br><blockquote>  Si un proceso abri√≥ el archivo con el indicador O_DIRECT, y el otro de la manera habitual (es decir, utilizando el cach√© del b√∫fer), entonces no hay coherencia entre el contenido del cach√© del b√∫fer y los datos le√≠dos o escritos a trav√©s de E / S directa.  Tal desarrollo debe ser evitado. <br><br>  Puede encontrar informaci√≥n sobre el m√©todo desactualizado (ahora no recomendado) para obtener acceso sin formato a un dispositivo de disco en la p√°gina del manual sin formato (8). </blockquote><br>  <b>Restricciones de alineaci√≥n para E / S directas</b> <br><br>  Dado que la E / S directa (tanto en dispositivos de disco como en relaci√≥n con los archivos) implica el acceso directo al disco, se deben observar algunas limitaciones al realizar E / S. <br><br>  - el b√∫fer de datos port√°til debe estar alineado en el borde de la memoria, un m√∫ltiplo del tama√±o del bloque. <br><br>  - El desplazamiento en el archivo o en el dispositivo desde el que comienzan los datos transferidos debe ser un m√∫ltiplo del tama√±o del bloque. <br><br>  - La longitud de los datos transferidos debe ser un m√∫ltiplo del tama√±o del bloque. <br><br>  El incumplimiento de cualquiera de estas restricciones dar√° como resultado un error EINVAL.  En la lista anterior, el tama√±o del bloque se refiere al tama√±o del bloque f√≠sico del dispositivo (generalmente 512 bytes). <br><br><blockquote>  Al realizar E / S directa en Linux 2.4, se imponen m√°s restricciones que en Linux 2.6: la alineaci√≥n, la longitud y el desplazamiento deben ser m√∫ltiplos del tama√±o del bloque l√≥gico del sistema de archivos utilizado.  (Normalmente, los tama√±os de los bloques l√≥gicos en un sistema de archivos son 1024, 2048 o 4096 bytes). <br></blockquote><br>  <b>Programa ejemplo</b> <br><br>   13.1     O_DIRECT     .        ,  (  ) ,     ,     , ,     ,       ,    ,  read().               4096 . <br><br>   ,      : <br><br><pre> <code class="plaintext hljs">$ ./direct_read /test/x 512  512    0 Read 512 bytes  $ ./direct_read /test/x 256 ERROR [EINVAL Invalid argument] read    512 $ ./direct_read /test/x 512 1 ERROR [EINVAL Invalid argument] read    512 $ ./direct_read /test/x 4096 8192 512 Read 4096 bytes  $ ./direct_read /test/x 4096 512 256 ERROR [EINVAL Invalid argument] read    512</code> </pre> <br><blockquote>    13.1   ,    ,    ,      memalign().  memalign()    7.1.4. </blockquote><br><pre> <code class="plaintext hljs">#define _GNU_SOURCE /*   O_DIRECT  &lt;fcntl.h&gt; */ #include &lt;fcntl.h&gt; #include &lt;malloc.h&gt; #include "tlpi_hdr.h" int main(int argc, char *argv[]) { int fd; ssize_t numRead; size_t length, alignment; off_t offset; void *buf; if (argc &lt; 3 || strcmp(argv[1], "‚Äìhelp") == 0) usageErr("%s file length [offset [alignment]]\n", argv[0]); length = getLong(argv[2], GN_ANY_BASE, "length"); offset = (argc &gt; 3) ? getLong(argv[3], GN_ANY_BASE, "offset") : 0; alignment = (argc &gt; 4) ? getLong(argv[4], GN_ANY_BASE, "alignment") : 4096; fd = open(argv[1], O_RDONLY | O_DIRECT); if (fd == -1) errExit("open"); /*  memalign()   ,   ,    .     'buf'  ,  'alignment',     .    ,   ,  ,    ,  256 ,     ,     512- .    '(char *)'        (     'void *',   memalign(). */ buf = (char *) memalign(alignment * 2, length + alignment) + alignment; if (buf == NULL) errExit("memalign"); if (lseek(fd, offset, SEEK_SET) == -1) errExit("lseek"); numRead = read(fd, buf, length); if (numRead == -1) errExit("read"); printf("Read %ld bytes\n", (long) numRead); exit(EXIT_SUCCESS); } _______________________________________________________________filebuff/direct_read.c</code> </pre> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬ªSe puede encontrar m√°s informaci√≥n sobre el libro </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en el sitio web del editor</font></font></a> <br>  ¬ª <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Contenidos</a> <br>  ¬ª <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Extracto</a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">20% de descuento en cupones para </font><b><font style="vertical-align: inherit;">Linux</font></b><font style="vertical-align: inherit;"> - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linux</font></font></b> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/436986/">https://habr.com/ru/post/436986/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../436976/index.html">Integraci√≥n de verificaci√≥n de contrase√±a KeePass con base de datos de fugas</a></li>
<li><a href="../436978/index.html">Fichas TOTP programables en un factor de forma de llavero</a></li>
<li><a href="../436980/index.html">Inteligencia artificial: el d√≠a del juicio final o la edad de oro de la prosperidad global</a></li>
<li><a href="../436982/index.html">Semana de la seguridad 04: qu√© hacer con las contrase√±as</a></li>
<li><a href="../436984/index.html">Microsoft deja de admitir Windows 10 Mobile</a></li>
<li><a href="../436988/index.html">C√°mara, motor, Big Data: c√≥mo los estudios de cine buscan nuevas pel√≠culas usando IA</a></li>
<li><a href="../436990/index.html">Zimbra y Zextras Suite son totalmente compatibles con los sistemas operativos NTC IT ROSA</a></li>
<li><a href="../436992/index.html">Prueba y error al elegir HTTP Reverse Proxy</a></li>
<li><a href="../436994/index.html">Liquibase y Maven</a></li>
<li><a href="../436996/index.html">Curso final de especializaci√≥n en Python del grupo Mail.ru</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>