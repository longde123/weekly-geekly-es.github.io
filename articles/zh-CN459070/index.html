<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😻 ↙️ ⏱️ 在Unity中创建塔防：塔与射击敌人 👨🏻‍🎨 💅🏽 👨🏿‍🏫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="[教程的第一部分和第二部分] 



- 我们放在塔场上。 
- 我们在物理的帮助下瞄准敌人。 
- 我们会尽可能地跟踪它们。 
- 我们用激光束射击它们。 
 这是有关创建简单塔防类型的一系列教程的第三部分。 它描述了塔的创建，瞄准和射击敌人。 

 该教程是在Unity 2018.3.0f2中创...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>在Unity中创建塔防：塔与射击敌人</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459070/">  [教程<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的第一</a>部分和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第二</a>部分] <br><br><ul><li> 我们放在塔场上。 </li><li> 我们在物理的帮助下瞄准敌人。 </li><li> 我们会尽可能地跟踪它们。 </li><li> 我们用激光束射击它们。 </li></ul><br> 这是有关创建简单塔防类型的一系列教程的第三部分。 它描述了塔的创建，瞄准和射击敌人。 <br><br> 该教程是在Unity 2018.3.0f2中创建的。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/470/ceb/183/470ceb1832b49ee7372fb79b8425b567.jpg" width="512" height="256"></div><br>  <i>让我们加热敌人。</i> <br><br><h2> 塔楼创作 </h2><br> 城墙只会使敌人减速，增加他们走的路途。 但是游戏的目标是在敌人到达终点之前消灭他们。 通过将塔架放置在可向其射击的场上，可以解决此问题。 <br><a name="habracut"></a><br><h3> 平铺内容 </h3><br> 塔是平铺内容的另一种类型，因此<code>GameTileContent</code>在<code>GameTileContent</code>中<code>GameTileContent</code>添加一个条目。 <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> GameTileContentType { Empty, Destination, Wall, SpawnPoint, Tower€ }</code> </pre> <br> 在本教程中，我们将仅支持一种类型的塔，可以通过向<code>GameTileContentFactory</code>一个到塔预制件的链接来实现，也可以通过<code>Get</code>来创建其实例。 <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField</span></span>] GameTileContent towerPrefab = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTileContent </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTileContentType type</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (type) { … <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GameTileContentType.Tower€: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Get(towerPrefab); } … }</code> </pre> <br> 但是这些塔必须射击，因此它们的状况需要更新，并且需要自己的代码。 为此目的创建一个<code>Tower</code>类，以扩展<code>GameTileContent</code>类。 <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Tower</span></span> : <span class="hljs-title"><span class="hljs-title">GameTileContent</span></span> {}</code> </pre> <br> 您可以通过将工厂字段类型更改为<code>Tower</code>来使Tower预制件具有其自己的组件。 由于该类仍被视为<code>GameTileContent</code> ，因此无需更改其他任何内容。 <br><br><pre> <code class="cs hljs"> Tower towerPrefab = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;</code> </pre> <br><h3> 预制件 </h3><br> 为塔创建一个预制件。 您可以从复制墙壁预制件开始，然后将其<code>GameTileContent</code>组件替换为<code>Tower</code>组件，然后将其类型更改为<em>Tower</em> 。 为了使塔适合墙壁，请将立方体墙保存为塔的基础。 然后将另一个立方体放在其顶部。 我给他0.5分。 在其上放另一个立方体，表明是炮塔，该部分将瞄准并向敌人射击。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/392/e5d/633/392e5d63397672627c3b5ec018df0444.png" width="190" height="260"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d92/dec/c33/d92decc33036a1e973a7f20a3df2c00e.png" width="320" height="120"></div><br>  <i>形成塔的三个立方体。</i> <br><br> 炮塔将旋转，并且由于它具有对撞机，因此将由物理引擎跟踪。 但是我们不必如此精确，因为我们仅使用塔对撞机来选择像元。 这可以近似完成。 卸下转塔立方体​​对撞机，然后更换塔式立方体对撞机，使其覆盖两个立方体。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e01/11e/3b7/e0111e3b7221bbbe4e5b0d23373e4b3a.png" width="190" height="260"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a1f/857/09b/a1f85709bd504d176a18930240edea5a.png" width="320" height="152"></div><br>  <i>对撞机立方体塔。</i> <br><br> 塔将发射激光束。 它可以通过多种方式可视化，但是我们仅使用半透明的立方体，我们将其拉伸以形成光束。 每个塔必须有自己的梁，因此将其添加到塔的预制件中。 将其放置在转塔内，以便默认情况下将其隐藏，并为其设置较小的比例，例如0.2。 让我们将其作为预制根的子级，而不是转塔立方体​​。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/19a/1dc/29e/19a1dc29e70adb158e07f29653db2d66.png" width="190" height="260" alt="激光束"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/45a/273/081/45a273081365aa9e483f1aa97cbe39c8.png" width="226" height="108" alt="等级制"></div><br>  <i>激光束的隐藏立方体。</i> <br><br> 为激光束创建合适的材料。 我只是使用标准的半透明黑色材料并关闭了所有反射，还给了它红色的发光颜色。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2fb/e49/860/2fbe498604cc4cc4ed6ee60a45eea63d.png" width="320" height="284" alt="颜色"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0eb/b46/483/0ebb4648376a7fe68c96b7a16ce27db9.png" width="320" height="56" alt="没有思考"></div><br>  <i>激光束的材料。</i> <br><br> 检查激光束是否没有对撞机，并关闭其投射和阴影。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ecf/f21/0ad/ecff210ad75ef4b12cb0a74102365492.png" width="320" height="162"></div><br>  <i>激光束不与阴影相互作用。</i> <br><br> 完成塔式预制件的创建后，我们将其添加到工厂中。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/626/37c/935/62637c9353cf1e20e170e82bbefcdb11.png" width="320" height="114"></div><br>  <i>有塔的工厂。</i> <br><br><h3> 塔的位置 </h3><br> 我们将使用另一种切换方法添加和删除塔。 您可以通过更改方法名称和内容类型来简单地复制<code>GameBoard.ToggleWall</code> 。 <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToggleTower</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile tile</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Tower€) { tile.Content = contentFactory.Get(GameTileContentType.Empty); FindPaths(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Empty) { tile.Content = contentFactory.Get(GameTileContentType.Tower€); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!FindPaths()) { tile.Content = contentFactory.Get(GameTileContentType.Empty); FindPaths(); } } }</code> </pre> <br> 在<code>Game.HandleTouch</code> ，按住Shift键将切换塔楼而不是墙壁。 <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleTouch</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GameTile tile = board.GetTile(TouchRay); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetKey(KeyCode.LeftShift)) { board.ToggleTower(tile); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { board.ToggleWall(tile); } } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/926/804/2ac/9268042acc19a28d6ff1a6d74d83144f.png" width="230" height="230"></div><br>  <i>在球场上的塔。</i> <br><br><h3> 路径阻塞 </h3><br> 到目前为止，只有墙壁可以阻止寻找路径，因此敌人会穿过塔楼。 让我们向<code>GameTileContent</code>添加<code>GameTileContent</code>辅助属性，该属性指示内容是否阻塞路径。 如果路径是墙或塔，则将其阻塞。 <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> BlocksPath =&gt; Type == GameTileContentType.Wall || Type == GameTileContentType.Tower€;</code> </pre> <br> 在<code>GameTile.GrowPathTo</code>使用此属性，而不是检查内容类型。 <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GrowPathTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile neighbor, Direction direction</span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-comment"><span class="hljs-comment">//neighbor.Content.Type != GameTileContentType.Wall ? neighbor : null; neighbor.Content.BlocksPath ? null : neighbor; }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6fa/93f/eed/6fa93feedb4925ee12decb4233612a4c.png" width="230" height="230"></div><br>  <i>现在，这条路已被墙壁和高楼阻挡。</i> <br><br><h3> 更换墙壁 </h3><br> 玩家很可能会经常用塔代替墙壁。 首先要拆除墙对他来说很不方便，此外，敌人还可以穿透这个暂时出现的缝隙。 您可以通过强制<code>GameBoard.ToggleTower</code>检查墙当前是否在瓷砖<code>GameBoard.ToggleTower</code>实现直接替换。 如果是这样，请立即用塔更换它。 在这种情况下，我们不必寻找其他方式，因为图块仍会阻止它们。 <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToggleTower</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile tile</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Tower) { tile.Content = contentFactory.Get(GameTileContentType.Empty); FindPaths(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Empty) { … } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Wall) { tile.Content = contentFactory.Get(GameTileContentType.Tower); } }</code> </pre> <br><h2> 我们瞄准敌人 </h2><br> 塔只有找到敌人才能完成其任务。 找到敌人后，她必须决定将目标对准哪一部分。 <br><br><h3> 瞄准点 </h3><br> 为了检测目标，我们将使用物理引擎。 与塔对撞机一样，我们不需要敌方对撞机一定与其形状重合。 您可以选择最简单的对撞机，即球体。 在检测到敌人之后，我们将使用附着有对撞机的游戏对象的位置作为瞄准点。 <br><br> 我们无法将对撞机附加到敌人的根对象上，因为对撞机并不总是与模型的位置重合，而是会使塔对着地面。 也就是说，您需要将对撞机放置在模型上的某个位置。 物理引擎将为我们提供指向该对象的链接，我们可以使用该链接进行瞄准，但是我们仍然需要访问根对象的“ <code>Enemy</code>组件。 为了简化任务，让我们创建<code>TargetPoint</code>组件。 让我们为它提供一个属性以供私人分配和公开接收<code>Enemy</code>组件，以及另一个属性以获取其在世界上的地位。 <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">TargetPoint</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Enemy Enemy€ { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector3 Position =&gt; transform.position; }</code> </pre> <br> 让我们给它一个<code>Awake</code>方法，该方法建立到其<code>Enemy</code>组件的链接。 使用<code>transform.root</code>直接转到根对象。 如果“ <code>Enemy</code>组件不存在，那么我们在制造敌人时犯了一个错误，因此我们为此添加一个声明。 <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Enemy€ = transform.root.GetComponent&lt;Enemy&gt;(); Debug.Assert(Enemy€ != <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">"Target point without Enemy root!"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre> <br> 此外，对撞机必须附加到与<code>TargetPoint</code>附加到的同一游戏对象上。 <br><br><pre> <code class="cs hljs"> Debug.Assert(Enemy€ != <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">"Target point without Enemy root!"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); Debug.Assert( GetComponent&lt;SphereCollider&gt;() != <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">"Target point without sphere collider!"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> );</code> </pre> <br> 向敌人的预制立方体中添加组件和对撞机。 这将使塔对准立方体的中心。 我们使用半径为0.25的球形对撞机。 立方体的比例为0.5，因此对撞机的真实半径为0.125。 由于这个原因，敌人将不得不在视觉上越过塔的射程圆，并且只有一段时间后才可以实现真正的目标。 对撞机的大小也会受到敌人随机比例的影响，因此在游戏中它的大小也会略有不同。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/85e/5ca/5e4/85e5ca5e47b8d59fa4211c78126bd512.png" width="176" height="176"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7ae/a71/aec/7aea71aecbd64d4e045df141ecd1c711.png" width="320" height="176" alt="检查员"></div><br>  <i>一个具有瞄准点并在立方体上具有对撞机的敌人。</i> <br><br><h3> 敌人层 </h3><br> 塔只在乎敌人，它们不会瞄准其他任何东西，因此我们会将所有敌人放在单独的图层中。 我们将使用第9层。在“ <em>层和标签”</em>窗口中将其名称更改为<em>Enemy</em> ，可以通过<em>编辑</em>器右上角的“ <em>层”</em>下拉菜单中的“ <em>编辑层”</em>选项打开。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8e6/9a5/762/8e69a5762e8eb1856175f9d9dc1ab388.png" width="320" height="308"></div><br>  <i>第9层将用于敌人。</i> <br><br> 该层仅用于识别敌人，而无需进行物理交互。 让我们在项目参数的“ <em>物理”</em>面板中的“ <em>层碰撞矩阵”中</em>禁用它们来指出。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/876/06e/e7d/87606ee7dfc4777760d81219517125ce.png" width="200" height="200"></div><br>  <i>图层碰撞矩阵。</i> <br><br> 确保瞄准点的游戏对象在所需的图层上。 敌人的其他预制件可能在其他层上，但是协调所有内容并将整个预制件放置在<em>敌人</em>层会更容易。 如果更改根对象的层，将提示您更改其所有子对象的层。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6d1/f75/062/6d1f75062420abadb285e9efca1e1a5e.png" width="320" height="44"></div><br>  <i>右边的敌人。</i> <br><br> 让我们添加一下声明： <code>TargetPoint</code>确实在正确的图层上。 <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … Debug.Assert(gameObject.layer == <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-string"><span class="hljs-string">"Target point on wrong layer!"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre> <br> 此外，敌人的对撞机必须忽略玩家的行为。 这可以通过在<code>GameBoard.GetTile</code>向<code>Physics.Raycast</code>添加一个图层蒙版参数来实现。 此方法的形式采用到光束和图层蒙版的距离作为附加参数。 默认情况下，我们将为其提供最大距离和图层蒙版，即1。 <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetTile</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Ray ray</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(ray, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> RaycastHit hit, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>.MaxValue, <span class="hljs-number"><span class="hljs-number">1</span></span>)) { … } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">图层蒙版不应该为0吗？</b> <div class="spoiler_text"> 默认的图层索引为零，但是我们传递了图层蒙版。 如果需要打开图层，则掩码会将整数的各个位更改为1。 在这种情况下，您只需要设置第一位，即最低有效位，即2 <sup>0</sup> ，等于1。 </div></div><br><h3> 更新图块内容 </h3><br> 塔只有在状态更新时才能执行其任务。 整个图块的内容也是如此，尽管到目前为止，其余所有内容均不起作用。 因此，将<code>GameTileContent</code>虚拟方法添加到<code>GameUpdate</code> ，默认情况下不执行任何操作。 <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> {}</code> </pre> <br> 让我们重新定义<code>Tower</code> ，即使现在它只是简单地在控制台中显示它正在寻找目标。 <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Debug.Log(<span class="hljs-string"><span class="hljs-string">"Searching for target..."</span></span>); }</code> </pre> <br>  <code>GameBoard</code>处理图块及其内容，因此它还将跟踪需要更新哪些内容。 为此，将列表添加到其中，并添加公共<code>GameUpdate</code>方法，该方法将更新列表中的所有内容。 <br><br><pre> <code class="cs hljs"> List&lt;GameTileContent&gt; updatingContent = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;GameTileContent&gt;(); … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; updatingContent.Count; i++) { updatingContent[i].GameUpdate(); } }</code> </pre> <br> 在我们的教程中，您只需要更新塔。 更改<code>ToggleTower</code>以便在必要时添加和删除内容。 如果还需要其他内容，我们将需要一种更通用的方法，但是到目前为止，这已经足够了。 <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToggleTower</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile tile</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Tower) { updatingContent.Remove(tile.Content); tile.Content = contentFactory.Get(GameTileContentType.Empty); FindPaths(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Empty) { tile.Content = contentFactory.Get(GameTileContentType.Tower); <span class="hljs-comment"><span class="hljs-comment">//if (!FindPaths()) { if (FindPaths()) { updatingContent.Add(tile.Content); } else { tile.Content = contentFactory.Get(GameTileContentType.Empty); FindPaths(); } } else if (tile.Content.Type == GameTileContentType.Wall) { tile.Content = contentFactory.Get(GameTileContentType.Tower); updatingContent.Add(tile.Content); } }</span></span></code> </pre> <br> 为了完成这项工作，现在我们只需更新<code>Game.Update</code>的字段就<code>Game.Update</code> 。 我们将在敌人之后更新该领域。 因此，这些塔将能够准确瞄准敌人所在的位置。 如果我们不这样做，这些塔将瞄准敌人在最后一帧中的位置。 <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … enemies.GameUpdate(); board.GameUpdate(); }</code> </pre> <br><h3> 瞄准范围 </h3><br> 塔的瞄准半径有限。 让我们通过向<code>Tower</code>类添加一个字段来使其自定义。 该距离是从塔瓦的中心开始测量的，因此在0.5的范围内，它将仅覆盖自己的瓦。 因此，合理的最小和标准范围应为1.5，覆盖大多数相邻图块。 <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField, Range(1.5f, 10.5f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> targetingRange = <span class="hljs-number"><span class="hljs-number">1.5f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c38/ae4/ee8/c38ae4ee885cf5d89f24164b9c6bc5fe.png" width="320" height="74"></div><br>  <i>瞄准范围2.5。</i> <br><br> 让我们用Gizmo可视化范围。 我们不需要经常看到它，因此我们将创建仅对所选对象调用的<code>OnDrawGizmosSelected</code>方法。 我们绘制球体的黄色框，其半径等于距离并相对于塔为中心。 将其稍微放在地面上方，以便始终清晰可见。 <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnDrawGizmosSelected</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Gizmos.color = Color.yellow; Vector3 position = transform.localPosition; position.y += <span class="hljs-number"><span class="hljs-number">0.01f</span></span>; Gizmos.DrawWireSphere(position, targetingRange); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/674/6b7/3cd/6746b73cd2e015fd599b770bb89e1c8a.png" width="230" height="230"></div><br>  <i>Gizmo瞄准范围。</i> <br><br> 现在我们可以看到哪些敌人是每个塔楼可承受的目标。 但是在场景窗口中选择塔很不方便，因为我们必须选择一个子多维数据集，然后切换到塔的根对象。 其他类型的图块内容也遇到相同的问题。 通过将<code>SelectionBase</code>属性添加到<code>GameTileContent</code> ，可以在场景窗口中强制选择<code>GameTileContent</code>内容的根。 <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">SelectionBase</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">GameTileContent</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { … }</code> </pre> <br><h3> 目标捕获 </h3><br> 将一个<code>TargetPoint</code>字段添加到<code>Tower</code>类，以便它可以跟踪其捕获的目标。 然后，我们<code>GameUpdate</code>来调用新的<code>AquireTarget</code>方法，该方法返回有关是否找到目标的信息。 检测到后，它将在控制台中显示一条消息。 <br><br><pre> <code class="cs hljs"> TargetPoint target; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (AcquireTarget()) { Debug.Log(<span class="hljs-string"><span class="hljs-string">"Acquired target!"</span></span>); } }</code> </pre> <br> 在<code>AcquireTarget</code>我们通过调用<code>Physics.OverlapSphere</code>以塔的位置和范围作为参数来获取所有可用的目标。 结果将是一个<code>Collider</code>数组，其中包含所有与球体接触的碰撞体。 如果阵列的长度为正，则至少有一个瞄准点，我们只需选择第一个即可。 取其必须始终存在的<code>TargetPoint</code>组件，将其分配给目标字段并报告成功。 否则，我们将清除目标并报告故障。 <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AcquireTarget</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Collider[] targets = Physics.OverlapSphere( transform.localPosition, targetingRange ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (targets.Length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { target = targets[<span class="hljs-number"><span class="hljs-number">0</span></span>].GetComponent&lt;TargetPoint&gt;(); Debug.Assert(target != <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">"Targeted non-enemy!"</span></span>, targets[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } target = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br> 如果仅考虑敌人层上的对撞机，则可以确保获得正确的瞄准点。 这是第9层，因此我们将传递相应的图层蒙版。 <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> enemyLayerMask = <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">9</span></span>; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AcquireTarget</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Collider[] targets = Physics.OverlapSphere( transform.localPosition, targetingRange, enemyLayerMask ); … }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">该位掩码如何工作？</b> <div class="spoiler_text"> 由于敌方层的索引为9，因此位掩码的第十位应具有值1。这对应于整数2 <sup>9</sup> ，即512。但是这样的位掩码记录是不直观的。 我们还可以编写二进制文字，例如<code>0b10_0000_0000</code> ，但随后我们必须计算零。 在这种情况下，最方便的输入将是使用左移位运算符<code>&lt;&lt;</code> ，该运算符会将这些位向左移位。 对应于2的幂的数字。 </div></div><br> 您可以通过在塔筒和目标位置之间绘制一条Gizmo线来可视化捕获的目标。 <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnDrawGizmosSelected</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (target != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { Gizmos.DrawLine(position, target.Position); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a5/e99/4be/7a5e994be6b7d848c2d4bfe7d627c708.png" width="230" height="230"></div><br>  <i>目标的可视化。</i> <br><br><div class="spoiler">  <b class="spoiler_title">为什么不使用OnTriggerEnter之类的方法？</b> <div class="spoiler_text"> 手动检查跨领域目标的优势在于我们只能在必要时执行此操作。 如果塔楼已经有目标，则没有理由检查目标。 此外，通过一次获取所有潜在目标，我们不必处理不断变化的每座塔的潜在目标清单。 </div></div><br><h3> 目标锁 </h3><br> 选择捕获的目标取决于物理引擎表示它们的顺序，也就是说，实际上是任意的。 因此，似乎捕获的目标无缘无故地发生了变化。 塔楼接收到目标后，让她追踪她的目标而不是切换到另一个目标更为合乎逻辑。 添加一个<code>TrackTarget</code>方法，该方法实现这种跟踪并返回有关是否成功的信息。 首先，我们只会告诉您目标是否被捕获。 <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TrackTarget</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (target == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br> 我们将在<code>GameUpdate</code>调用此方法，只有返回false时，才调用<code>AcquireTarget</code> 。 如果该方法返回true，则我们有一个目标。 可以通过使用OR运算符将两个方法调用放入<code>if</code>检查中来完成，因为如果第一个操作数返回<code>true</code> ，则第二个操作数将不被检查，并且该调用将丢失。  AND运算符的行为类似。 <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (TrackTarget() || AcquireTarget()) { Debug.Log(<span class="hljs-string"><span class="hljs-string">"Locked on target!"</span></span>); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8ec/27c/0a2/8ec27c0a2201434cba3725621b68aaa1.png" width="230" height="230"></div><br>  <i>跟踪目标。</i> <br><br> 结果，塔被固定在目标上，直到到达终点并被破坏。 如果您反复使用敌人，则需要检查链接的正确性，就像在一系列“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">对象管理”</a>教程中处理的图形的链接一样。 <br><br> 要仅在目标在范围内时跟踪目标， <code>TrackTarget</code>必须跟踪塔架与目标之间的距离。 如果超出范围值，则必须重置目标并返回false。 您可以使用<code>Vector3.Distance</code>方法进行此检查。 <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TrackTarget</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (target == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } Vector3 a = transform.localPosition; Vector3 b = target.Position; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Vector3.Distance(a, b) &gt; targetingRange) { target = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br> 但是，此代码未考虑对撞机的半径。 因此，塔可能会失去目标，然后再次捕获它，只是在下一帧中停止跟踪它，依此类推。 我们可以通过在范围内添加对撞机半径来避免这种情况。 <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Vector3.Distance(a, b) &gt; targetingRange + <span class="hljs-number"><span class="hljs-number">0.125f</span></span>) { … }</code> </pre> <br> 这给了我们正确的结果，但前提是不改变敌人的规模。 由于我们给每个敌人一个随机的比例尺，因此在改变射程时必须将其考虑在内。 为此，我们需要记住<code>Enemy</code>给定的比例，并使用getter属性将其打开。 <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Scale { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> scale, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pathOffset</span></span></span><span class="hljs-function">)</span></span> { Scale = scale; … }</code> </pre> <br> 现在，我们可以在<code>Tower.TrackTarget</code>检查正确的范围。 <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Vector3.Distance(a, b) &gt; targetingRange + <span class="hljs-number"><span class="hljs-number">0.125f</span></span> * target.Enemy€.Scale) { … }</code> </pre> <br><h3> 我们同步物理学 </h3><br> 一切似乎都运行良好，但是可以对准视野中心的发射塔能够捕获应该超出范围的目标。 他们将无法跟踪这些目标，因此只能将它们固定在一帧上。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e91/0a1/836/e910a1836ef729d95ebee121a67c3f2c.png" width="230" height="230"></div><br>  <i>瞄准不正确。</i> <br><br> 发生这种情况是因为物理引擎的状态与游戏状态不完全同步。 所有敌人的实例都是在世界原点创建的，与世界的中心重合。 然后，我们将它们移至创建点，但是物理引擎并不立即知道这一点。 <br><br> 您可以通过将<code>Physics.autoSyncTransforms</code>设置为<code>true</code>来启用在更改对象转换时发生的瞬时同步。 但是默认情况下，它是禁用的，因为在必要时将所有内容同步到一起效率更高。 在我们的情况下，仅在更新塔的状态时才需要同步。 我们可以通过在<code>Game.Update</code>敌人和野外更新之间调用<code>Physics.SyncTransforms</code>来执行它。 <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … enemies.GameUpdate(); Physics.SyncTransforms(); board.GameUpdate(); }</code> </pre> <br><h3> 忽略身高 </h3><br> 实际上，我们的游戏玩法是以2D进行的。 因此，让我们更改<code>Tower</code>以便在瞄准和跟踪时仅考虑X和Z坐标物理引擎在3D空间中工作，但从本质上讲，我们可以在2D中执行<code>AcquireTarget</code> ：将球体向上拉伸，使其覆盖所有对撞机，无论从垂直位置开始。 这可以通过使用胶囊而不是球体来完成，该胶囊的第二点将在地面上方几个单位（例如三个）。 <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AcquireTarget</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Vector3 a = transform.localPosition; Vector3 b = a; <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> += <span class="hljs-number"><span class="hljs-number">3f</span></span>; Collider[] targets = Physics.OverlapCapsule( a, b, targetingRange, enemyLayerMask ); … }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不可能使用物理2D引擎吗？</font></font></b> <div class="spoiler_text">   ,       XZ,   2D-    XY.     ,     ,    2D-   .     3D-. </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">也有必要改变</font></font><code>TrackTarget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">当然，我们可以使用2D向量和</font></font><code>Vector2.Distance</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，但是让我们自己进行计算，而是比较距离的平方，这就足够了。</font><font style="vertical-align: inherit;">因此，我们摆脱了计算平方根的操作。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TrackTarget</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (target == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } Vector3 a = transform.localPosition; Vector3 b = target.Position; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x = ax - bx; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> z = az - bz; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> r = targetingRange + <span class="hljs-number"><span class="hljs-number">0.125f</span></span> * target.Enemy€.Scale; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x * x + z * z &gt; r * r) { target = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这些数学计算如何工作？</font></font></b> <div class="spoiler_text">     2D-   ,     .     ,       .  ,        ,    . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 避免分配内存 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用它的缺点</font></font><code>Physics.OverlapCapsule</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是它为每个调用分配一个新的数组。</font><font style="vertical-align: inherit;">可以通过分配一次数组并调用</font></font><code>OverlapCapsuleNonAlloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将数组作为附加参数</font><font style="vertical-align: inherit;">的替代方法来避免这种情况</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">传输数组的长度决定结果的数量。</font><font style="vertical-align: inherit;">阵列之外的所有潜在目标都将被丢弃。</font><font style="vertical-align: inherit;">相同的是，我们将只使用第一个元素，因此长度为1的数组足以满足我们的需要，</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">而不是数组，它</font></font><code>OverlapCapsuleNonAlloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">返回已发生的冲突数量，直到允许的最大数量，这是我们将检查的数量而不是数组的长度。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Collider[] targetsBuffer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Collider[<span class="hljs-number"><span class="hljs-number">1</span></span>]; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AcquireTarget</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Vector3 a = transform.localPosition; Vector3 b = a; <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> += <span class="hljs-number"><span class="hljs-number">2f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> hits = Physics.OverlapCapsuleNonAlloc( a, b, targetingRange, targetsBuffer, enemyLayerMask ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hits &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { target = targetsBuffer[<span class="hljs-number"><span class="hljs-number">0</span></span>].GetComponent&lt;TargetPoint&gt;(); Debug.Assert(target != <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">"Targeted non-enemy!"</span></span>, targetsBuffer[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } target = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 我们向敌人射击 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在我们有了一个真正的目标，是时候去实现它了。</font><font style="vertical-align: inherit;">射击包括瞄准，激光射击和造成伤害。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 瞄准塔 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要将炮塔指向目标，该类</font></font><code>Tower</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">需要链接到</font></font><code>Transform</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">炮塔</font><font style="vertical-align: inherit;">组件</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">为此添加一个配置字段，并将其连接到塔式预制件。</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField</span></span>] Transform turret = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e0f/3be/41b/e0f3be41b0936993268316b8f01e1f67.png" width="320" height="90"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">附属的炮塔。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果</font></font><code>GameUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有真实的目标，那么我们必须射击它。</font><font style="vertical-align: inherit;">将拍摄代码放在单独的方法中。</font><font style="vertical-align: inherit;">让他将炮塔向目标旋转</font></font><code>Transform.LookAt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，以瞄准点作为参数</font><font style="vertical-align: inherit;">调用他的方法</font><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (TrackTarget() || AcquireTarget()) { <span class="hljs-comment"><span class="hljs-comment">//Debug.Log("Locked on target!"); Shoot(); } } void Shoot () { Vector3 point = target.Position; turret.LookAt(point); }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/00e/5bb/e9d/00e5bbe9d98e739800bf47435ca574af.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">只是瞄准。</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 我们发射激光 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了定位激光束，班级</font></font><code>Tower</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">还需要一个链接。</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField</span></span>] Transform turret = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>, laserBeam = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/802/c9c/86e/802c9c86eac24112cb2b4f072fd0f410.png" width="320" height="110"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们连接了激光束。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要将立方体变成真实的激光束，您需要执行三个步骤。</font><font style="vertical-align: inherit;">首先，其方位应与转塔的方位相对应。</font><font style="vertical-align: inherit;">可以通过复制其旋转方式来完成。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Shoot</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Vector3 point = target.Position; turret.LookAt(point); laserBeam.localRotation = turret.localRotation; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">其次，我们对激光束进行缩放，以使其长度等于转塔原点与瞄准点之间的距离。</font><font style="vertical-align: inherit;">我们沿着Z轴（即指向目标的局部轴）缩放比例。</font><font style="vertical-align: inherit;">为了保留原始的XY标度，我们在唤醒Awake炮塔时记下原始标度。</font></font><br><br><pre> <code class="cs hljs"> Vector3 laserBeamScale; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { laserBeamScale = laserBeam.localScale; } … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Shoot</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Vector3 point = target.Position; turret.LookAt(point); laserBeam.localRotation = turret.localRotation; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> d = Vector3.Distance(turret.position, point); laserBeamScale.z = d; laserBeam.localScale = laserBeamScale; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 第三，我们将激光束放置在炮塔和瞄准点之间的中间位置。 </font></font><br><br><pre> <code class="cs hljs"> laserBeam.localScale = laserBeamScale; laserBeam.localPosition = turret.localPosition + <span class="hljs-number"><span class="hljs-number">0.5f</span></span> * d * laserBeam.forward;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/288/d96/438/288d96438354bd732fd7a3bb84ead491.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">激光射击。</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不可能使激光束成为炮塔的孩子吗？</font></font></b> <div class="spoiler_text">     ,         ,       forward.       ,     .     . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当转塔固定在目标上时，此方法有效。</font><font style="vertical-align: inherit;">但是，当没有目标时，激光保持激活状态。</font><font style="vertical-align: inherit;">我们可以通过</font></font><code>GameUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将</font><font style="vertical-align: inherit;">激光显示比例尺</font><font style="vertical-align: inherit;">设置</font><font style="vertical-align: inherit;">为</font><font style="vertical-align: inherit;">0 </font><font style="vertical-align: inherit;">来关闭激光显示</font><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (TrackTarget() || AcquireTarget()) { Shoot(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { laserBeam.localScale = Vector3.zero; } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/39b/8c8/c23/39b8c8c239e0936137c646f91a4197de.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">空闲的塔不会着火。</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 敌人健康 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">到目前为止，我们的激光束仅接触敌人，不再影响他们。</font><font style="vertical-align: inherit;">必须确保激光确实会伤害敌人。</font><font style="vertical-align: inherit;">我们不想立即消灭敌人，所以我们将给予</font></font><code>Enemy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">健康。</font><font style="vertical-align: inherit;">您可以选择任何值作为生命值，因此取100。但是，对于大型敌人来说，拥有更多生命值会更加合乎逻辑，因此我们将为此引入一个系数。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Health { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> scale, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pathOffset</span></span></span><span class="hljs-function">)</span></span> { … Health = <span class="hljs-number"><span class="hljs-number">100f</span></span> * scale; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要增加对造成损害的支持，请添加一个</font></font><code>ApplyDamage</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从健康中减去其参数</font><font style="vertical-align: inherit;">的公共方法</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">我们将假定损害为非负性，因此我们对此进行声明。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ApplyDamage</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> damage</span></span></span><span class="hljs-function">)</span></span> { Debug.Assert(damage &gt;= <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-string"><span class="hljs-string">"Negative damage applied."</span></span>); Health -= damage; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">敌人的生命值达到零时，我们不会立即摆脱它。</font><font style="vertical-align: inherit;">开始时将检查身体是否精疲力竭以及敌人是否被摧毁</font></font><code>GameUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Health &lt;= <span class="hljs-number"><span class="hljs-number">0f</span></span>) { OriginFactory.Reclaim(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 因此，所有的塔实际上都会同时射击，而不是依次射击，如果前一个塔摧毁了他们也瞄准的敌人，这将允许它们切换到其他目标。 </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 每秒伤害 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在我们需要确定激光会造成多大的损害。</font><font style="vertical-align: inherit;">为此，请添加到</font></font><code>Tower</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">配置字段。</font><font style="vertical-align: inherit;">由于激光束会造成持续的损坏，因此我们将其表示为每秒的损坏。</font><font style="vertical-align: inherit;">我们</font></font><code>Shoot</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将其</font></font><code>Enemy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">乘以增量时间</font><font style="vertical-align: inherit;">应用于</font><font style="vertical-align: inherit;">目标</font><font style="vertical-align: inherit;">组件</font><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField, Range(1f, 100f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> damagePerSecond = <span class="hljs-number"><span class="hljs-number">10f</span></span>; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Shoot</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … target.Enemy.ApplyDamage(damagePerSecond * Time.deltaTime); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/886/18f/199/88618f199c9c08e7eaeb89b16083f545.png" width="320" height="128" alt="检查员"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gk/vt/sf/gkvtsfa1ya4igbsjagqhtnzu0wq.gif"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">每座塔的伤害为每秒20个单位。</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 随机瞄准 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于我们总是选择第一个可用的目标，因此瞄准行为取决于物理引擎检查相交对撞机的顺序。这种依赖性不是很好，因为我们不知道细节，我们无法控制它，而且它看起来很奇怪而且前后不一致。通常，这种行为会导致火灾集中，但并非总是如此。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">让我们增加一些随机性，而不是完全依赖于物理引擎。这可以通过增加对撞机接收到的相交点的数量（例如最多100个）来完成。也许这不足以使一个敌人密集地包围着所有可能的目标，但这足以改善瞄准。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Collider[] targetsBuffer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Collider[<span class="hljs-number"><span class="hljs-number">100</span></span>];</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 现在，我们将从数组中选择一个随机元素，而不是选择第一个潜在目标。 </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AcquireTarget</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hits &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { target = targetsBuffer[Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, hits)].GetComponent&lt;TargetPoint&gt;(); … } target = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nv/lt/hi/nvlthij_ixh6lsxgwujtoipjwg4.gif"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">随机瞄准。</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以使用其他选择目标的标准吗？</font></font></b> <div class="spoiler_text"> , ,        .  ,      ,     .    .             . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因此，在我们的塔防游戏中，塔终于出现了。</font><font style="vertical-align: inherit;">在下一部分中，游戏将进一步发挥其最终形状。</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN459070/">https://habr.com/ru/post/zh-CN459070/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN459052/index.html">如何进行比较：市场调查和大数据中的“惊人的汽车”和“丑陋的小屋”</a></li>
<li><a href="../zh-CN459054/index.html">点击热图-用户在网站上的行为</a></li>
<li><a href="../zh-CN459062/index.html">＃305移动开发人员的有趣材料摘要（7月1日至7日）</a></li>
<li><a href="../zh-CN459066/index.html">数据库读写平衡</a></li>
<li><a href="../zh-CN459068/index.html">Windows Server 2008 R2-国王死了，国王万岁</a></li>
<li><a href="../zh-CN459074/index.html">小小快乐＃7：三者合一的价格-控制台动画，算法和调试</a></li>
<li><a href="../zh-CN459078/index.html">CERN切换到开源软件-为什么？</a></li>
<li><a href="../zh-CN459080/index.html">java.net的HttpUrlConnection功能</a></li>
<li><a href="../zh-CN459082/index.html">谁是思想家，错误的记忆是如何工作的以及关于记忆的三个流行神话</a></li>
<li><a href="../zh-CN459084/index.html">关于Google Home Hub的一些知识，或者我如何以130欧元的价格购买相框</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>