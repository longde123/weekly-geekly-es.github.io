<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèø‚Äç‚öñÔ∏è ‚òÑÔ∏è üçô ¬øQui√©n est√° robando tiempo de CPU virtual? üë®üèª‚Äçüîß üë∫ ü§öüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola En este art√≠culo, quiero explicar, en t√©rminos simples, c√≥mo aparece el robo en las m√°quinas virtuales y contarle sobre algunos de los artefactos...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>¬øQui√©n est√° robando tiempo de CPU virtual?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/453140/"><img src="https://habrastorage.org/getpro/habr/post_images/9d4/ede/bb8/9d4edebb8a0253cb1b973bd5df46a9a9.jpg"><br><br>  Hola  En este art√≠culo, quiero explicar, en t√©rminos simples, c√≥mo aparece el <i>robo</i> en las m√°quinas virtuales y contarle sobre algunos de los artefactos menos que obvios que encontramos durante la investigaci√≥n sobre el tema en el que estuve involucrado como CTO del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Correo.</a> plataforma de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">soluciones Cloud com</a> .  La plataforma ejecuta KVM. <br><a name="habracut"></a><br>  El tiempo de robo de la CPU es el tiempo durante el cual una VM no recibe los recursos necesarios para operar.  Este tiempo solo se puede calcular en un SO hu√©sped en entornos de virtualizaci√≥n.  No est√° muy claro d√≥nde se pierden los recursos asignados, como en situaciones de la vida real.  Sin embargo, decidimos resolverlo e incluso realizamos una serie de pruebas para hacerlo.  Eso no quiere decir que sepamos todo sobre el <i>robo,</i> pero hay algunas cosas fascinantes que nos gustar√≠a compartir con usted. <br><br><h2>  1. ¬øQu√© es <i>robar</i> ? </h2><br>  <i>Steal</i> es una m√©trica que indica una falta de tiempo de CPU para los procesos de VM.  Como se describe en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">parche del kernel KVM</a> , <i>robar</i> es el tiempo que un hipervisor pasa ejecutando otros procesos en un sistema operativo host, mientras que el proceso VM est√° en una cola de ejecuci√≥n.  En otras palabras, el <i>robo</i> se calcula como la diferencia entre el momento en que un proceso est√° listo para ejecutarse y el momento en que el tiempo de CPU se asigna al proceso. <br><br>  El kernel VM obtiene la m√©trica de <i>robo</i> del hipervisor.  El hipervisor no especifica qu√© procesos est√° ejecutando.  Simplemente dice: "Estoy ocupado y no puedo asignarle tiempo".  En un KVM, el c√°lculo de <i>robo</i> se admite en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">parches</a> .  Hay dos puntos principales con respecto a esto: <br><br><ul><li>  Una VM aprende sobre el <i>robo</i> del hipervisor.  Esto significa que, en t√©rminos de p√©rdidas, el <i>robo</i> es una medida indirecta que puede distorsionarse de varias maneras. <br></li><li>  El hipervisor no comparte con la VM informaci√≥n sobre con qu√© est√° ocupado.  El punto m√°s crucial es que no le asigna tiempo.  La VM en s√≠ misma, por lo tanto, no puede detectar distorsiones en la m√©trica de <i>robo</i> <i>, lo</i> que podr√≠a estimarse por la naturaleza de los procesos competitivos. <br></li></ul><br><h2>  2. ¬øQu√© afecta al <i>robo</i> ? </h2><br><h4>  2.1.  C√°lculo de <i>robo</i> </h4><br>  Esencialmente, el <i>robo</i> se calcula m√°s o menos de la misma manera que el tiempo de utilizaci√≥n de la CPU.  No hay mucha informaci√≥n sobre c√≥mo se calcula la utilizaci√≥n.  Eso es probablemente porque la mayor√≠a de los profesionales piensan que es obvio.  Sin embargo, hay algunas trampas.  El proceso se describe en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">un art√≠culo de Brendann Gregg</a> .  Analiza una gran cantidad de matices sobre c√≥mo calcular la utilizaci√≥n y los escenarios en los que el c√°lculo ser√° incorrecto: <br><br><ul><li>  CPU sobrecalentamiento y estrangulamiento. <br></li><li>  Activar / desactivar Turbo Boost, lo que resulta en un cambio en la velocidad del reloj de la CPU. </li><li> El cambio de intervalo de tiempo que ocurre cuando se utilizan tecnolog√≠as de ahorro de energ√≠a de la CPU, por ejemplo, SpeedStep. <br></li><li>  Problemas relacionados con el c√°lculo de promedios: medir la utilizaci√≥n durante un minuto al 80% de potencia podr√≠a ocultar un aumento del 100% a corto plazo. <br></li><li>  Un spinlock que da como resultado un escenario en el que se utiliza el procesador, pero el proceso del usuario no progresa.  Como resultado, la utilizaci√≥n calculada de la CPU ser√° del 100%, pero el proceso no consumir√° realmente el tiempo de la CPU. <br></li></ul><br>  No he encontrado ning√∫n art√≠culo que describa tales c√°lculos de <i>robo</i> (si conoce alguno, por favor comp√°rtalos en la secci√≥n de comentarios).  Como puede ver en el c√≥digo fuente, el mecanismo de c√°lculo es el mismo que para la utilizaci√≥n.  La √∫nica diferencia es que se agrega otro contador espec√≠ficamente para el proceso KVM (proceso VM), que calcula cu√°nto tiempo el proceso KVM ha estado esperando el tiempo de CPU.  El contador toma datos de la CPU de su especificaci√≥n y comprueba si el proceso de VM est√° utilizando todos sus ticks.  Si se utilizan todos los ticks, entonces la CPU solo estaba ocupada con el proceso de VM.  De lo contrario, sabemos que la CPU estaba haciendo otra cosa y aparece <i>robar</i> . <br><br>  El proceso por el cual se calcula el <i>robo</i> est√° sujeto a los mismos problemas que el c√°lculo regular de la utilizaci√≥n.  Estos problemas no son tan comunes, pero pueden parecer bastante confusos. <br><br><h4>  2.2.  Tipos de virtualizaci√≥n KVM </h4><br>  En general, hay tres tipos de virtualizaci√≥n, y todos son compatibles con un KVM.  El mecanismo por el cual ocurre el <i>robo</i> puede depender del tipo de virtualizaci√≥n. <br><br>  Traducci√≥n  En este caso, el sistema operativo VM funcionar√° con dispositivos de hipervisor f√≠sico de la siguiente manera: <br><br><ol><li>  El SO invitado env√≠a un comando a su dispositivo invitado. <br></li><li>  El controlador del dispositivo invitado acepta el comando, crea una solicitud de dispositivo BIOS y env√≠a el comando al hipervisor. <br></li><li>  El proceso del hipervisor traduce el comando en un comando de dispositivo f√≠sico, lo que lo hace m√°s seguro, entre otras cosas. <br></li><li>  El controlador del dispositivo f√≠sico acepta el comando modificado y lo reenv√≠a al propio dispositivo f√≠sico. <br></li><li>  Los resultados de ejecuci√≥n del comando vuelven siguiendo la misma ruta. <br></li></ol><br>  La ventaja de la traducci√≥n es que nos permite emular cualquier dispositivo y no requiere una preparaci√≥n especial del n√∫cleo del sistema operativo.  Pero esto viene a expensas del rendimiento. <br><br>  Virtualizaci√≥n de hardware.  En este caso, un dispositivo recibe comandos del sistema operativo en el nivel de hardware.  Este es el mejor m√©todo m√°s r√°pido y en general.  Desafortunadamente, no todos los dispositivos f√≠sicos, hipervisores y sistemas operativos invitados lo admiten.  Por ahora, los principales dispositivos que admiten la virtualizaci√≥n de hardware son las CPU. <br><br>  Paravirtualizaci√≥n.  La opci√≥n m√°s com√∫n para la virtualizaci√≥n de dispositivos en un KVM y el tipo de virtualizaci√≥n m√°s extendido para los SO invitados.  Su caracter√≠stica principal es que funciona con algunos subsistemas de hipervisor (por ejemplo, red o pila de unidades) y asigna p√°ginas de memoria usando una API de hipervisor sin traducir comandos de bajo nivel.  La desventaja de este m√©todo de virtualizaci√≥n es la necesidad de modificar el kernel del sistema operativo invitado para permitir la interacci√≥n con el hipervisor utilizando la misma API.  La soluci√≥n m√°s com√∫n a este problema es instalar controladores especiales en el sistema operativo invitado.  En un KVM, esta API se llama <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">virtio API</a> . <br><br>  Cuando se usa la paravirtualizaci√≥n, la ruta al dispositivo f√≠sico es mucho m√°s corta que en los casos en que se usa la traducci√≥n, porque los comandos se env√≠an directamente desde la VM al proceso del hipervisor en el host.  Esto acelera la ejecuci√≥n de todas las instrucciones dentro de la VM.  En un KVM, una API virtio es responsable de esto.  Solo funciona para algunos dispositivos como adaptadores de red y unidad.  Es por eso que los controladores virtio est√°n instalados en las m√°quinas virtuales. <br><br>  La otra cara de dicha aceleraci√≥n es que no todos los procesos ejecutados en una VM permanecen dentro de la VM.  Esto da como resultado una serie de efectos, que pueden causar <i>robo</i> .  Si desea obtener m√°s informaci√≥n, comience con <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">una API para E / S virtual: virtio</a> . <br><br><h4>  2.3.  Programaci√≥n justa </h4><br>  Una VM en un hipervisor es, de hecho, un proceso regular, que est√° sujeto a las leyes de programaci√≥n (distribuci√≥n de recursos entre procesos) en un kernel de Linux.  Echemos un vistazo m√°s de cerca a esto. <br><br>  Linux usa el llamado CFS, Completely Fair Scheduler, que se convirti√≥ en el predeterminado con el kernel 2.6.23.  Para conocer este algoritmo, lea Linux Kernel Architecture o el c√≥digo fuente.  La esencia de CFS radica en la distribuci√≥n del tiempo de CPU entre procesos, dependiendo de su tiempo de ejecuci√≥n.  Cuanto m√°s tiempo de CPU requiere un proceso, menos tiempo de CPU obtiene.  Esto garantiza la ejecuci√≥n "justa" de todos los procesos y ayuda a evitar que un proceso ocupe todos los procesadores, todo el tiempo y permite que otros procesos tambi√©n se ejecuten. <br><br>  Algunas veces este paradigma da como resultado artefactos interesantes.  Los usuarios de Linux de larga data sin duda recordar√°n c√≥mo un editor de texto normal en el escritorio se congelar√≠a al ejecutar aplicaciones de uso intensivo de recursos como un compilador.  Esto sucedi√≥ porque las tareas con pocos recursos, como las aplicaciones de escritorio, compet√≠an con tareas que usaban muchos recursos, como un compilador.  CFS considera que esto es injusto, por lo que detiene el editor de texto de vez en cuando y permite que la CPU procese las tareas del compilador.  Esto se solucion√≥ utilizando el mecanismo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">sched_autogroup</a> ;  Sin embargo, hay muchas otras peculiaridades de la distribuci√≥n del tiempo de la CPU.  Este art√≠culo no trata realmente sobre qu√© tan malo es el SFC.  Es m√°s bien un intento de llamar la atenci√≥n sobre el hecho de que la distribuci√≥n "justa" del tiempo de CPU no es la tarea m√°s trivial. <br><br>  Otro aspecto importante de un planificador es la preferencia.  Esto es necesario para liberar a la CPU de cualquier proceso excesivo y permitir que otros tambi√©n trabajen.  Esto se llama <i>cambio de contexto</i> .  Se retiene todo el contexto de la tarea: estado de la pila, registros, etc., despu√©s de lo cual el proceso se deja esperar y se reemplaza por otro proceso.  Esta es una operaci√≥n costosa para un sistema operativo.  Raramente se usa, pero en realidad no est√° nada mal.  El cambio de contexto frecuente puede ser un indicador de un problema del sistema operativo, pero generalmente ocurre continuamente y no es un signo de ning√∫n problema en particular. <br><br>  Este largo discurso fue necesario para explicar un hecho: en un planificador de Linux justo, cuantos m√°s recursos de CPU consume el proceso, m√°s r√°pido se detendr√° para permitir que otros procesos funcionen.  Si esto es correcto o no es una pregunta compleja, y la soluci√≥n es diferente dependiendo de la carga.  Hasta hace poco, el programador de Windows priorizaba las aplicaciones de escritorio, lo que resultaba en procesos en segundo plano m√°s lentos.  En Sun Solaris hab√≠a cinco clases de planificador diferentes.  Cuando se introdujo la virtualizaci√≥n, agregaron otro, el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">programador de reparto justo</a> , porque los dem√°s no se ejecutaban correctamente con la virtualizaci√≥n de Zonas de Solaris.  Para profundizar en esto, recomiendo comenzar con <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Solaris Internals: Solaris 10 y OpenSolaris Kernel Architecture</a> o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Comprender el kernel de Linux</a> . <br><br><h4>  2.4.  ¬øC√≥mo podemos monitorear el <i>robo</i> ? </h4><br>  Al igual que cualquier otra m√©trica de CPU, es f√°cil monitorear el <i>robo</i> dentro de una VM.  Puede usar cualquier herramienta de medici√≥n m√©trica de CPU.  Lo principal es que la VM debe estar en Linux.  Por alguna raz√≥n, Windows no proporciona dicha informaci√≥n al usuario.  :( <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fff/9f8/5b1/fff9f85b10523ddaecfc176f1fa18f33.png"><br>  <i>salida superior: especificaci√≥n de carga de CPU con robo en la columna derecha</i> <br><br>  Las cosas se complican cuando se trata de obtener esta informaci√≥n de un hipervisor.  Puede intentar pronosticar el <i>robo</i> en una m√°quina host, utilizando Load Average (LA), por ejemplo.  Este es el valor promedio de la cantidad de procesos en la cola de ejecuci√≥n.  El m√©todo de c√°lculo para este par√°metro no es simple, pero en general, si un LA que se ha estandarizado de acuerdo con el n√∫mero de subprocesos de la CPU es mayor que 1, significa que el servidor Linux est√° sobrecargado. <br><br>  Entonces, ¬øqu√© est√°n esperando todos estos procesos?  Obviamente, la CPU.  Sin embargo, esta respuesta no es del todo precisa, porque a veces la CPU es libre y la LA es demasiado alta.  Recuerde <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">que NFS cae y LA aumenta al mismo tiempo</a> .  Una situaci√≥n similar podr√≠a ocurrir con la unidad y otros dispositivos de entrada / salida.  De hecho, los procesos pueden estar esperando el final de un bloqueo: f√≠sico (relacionado con dispositivos de entrada / salida) o l√≥gico (un objeto mutex, por ejemplo).  Lo mismo es cierto para bloqueos a nivel de hardware (por ejemplo, respuesta de disco) o bloqueos a nivel l√≥gico (llamados "primitivas de bloqueo", que incluyen una serie de entidades, mutex adaptable y spin, sem√°foros, variables de condici√≥n, bloqueos rw, ipc locks ...). <br><br>  Otra caracter√≠stica de LA es que se calcula como un valor promedio dentro del sistema operativo.  Por ejemplo, si 100 procesos compiten por un archivo, el LA es 50. Este gran n√∫mero podr√≠a hacer que parezca que es malo para el sistema operativo.  Sin embargo, para un c√≥digo mal escrito, esto puede ser normal.  Solo ese c√≥digo espec√≠fico ser√≠a malo, y el resto del sistema operativo podr√≠a estar bien. <br><br>  Debido a este promedio (durante menos de un minuto), determinar cualquier cosa usando un LA no es la mejor idea, ya que puede producir resultados extremadamente ambiguos en algunos casos.  Si intenta obtener m√°s informaci√≥n al respecto, ver√° que Wikipedia y otros recursos disponibles solo describen los casos m√°s simples, y el proceso no se describe en detalle.  Si est√° interesado en esto, visite <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Brendann Gregg</a> y siga los enlaces. <br><br><h2>  3. Efectos especiales </h2><br>  Ahora veamos los principales casos de <i>robo</i> que encontramos.  Perm√≠tanme explicar c√≥mo resultan de lo anterior y c√≥mo se correlacionan con las m√©tricas del hipervisor. <br><br>  Sobreutilizaci√≥n  El caso m√°s simple y m√°s com√∫n: el hipervisor se est√° sobreutilizando.  De hecho, con una gran cantidad de m√°quinas virtuales que se ejecutan y consumen muchos recursos de la CPU, la competencia es alta y la utilizaci√≥n seg√∫n LA es mayor que 1 (estandarizada seg√∫n los hilos de la CPU).  Todo se retrasa dentro de todas las m√°quinas virtuales.  <i>El robo</i> enviado desde el hipervisor tambi√©n crece.  Tienes que redistribuir la carga o apagar algo.  En general, todo esto es l√≥gico y directo. <br><br>  Paravirtualizaci√≥n frente a instancias individuales.  Solo hay una VM en un hipervisor.  La VM consume una peque√±a parte, pero proporciona una alta carga de entrada / salida, por ejemplo, para una unidad.  Inesperadamente, aparece un peque√±o <i>robo</i> de menos del 10% (como muestran algunas de las pruebas que realizamos). <br><br>  Este es un caso curioso.  Aqu√≠, el <i>robo</i> aparece debido a bloqueos en el nivel de los dispositivos paravirtualizados.  Dentro de la VM, se crea un punto de interrupci√≥n.  El controlador lo procesa y va al hipervisor.  Debido al procesamiento del punto de interrupci√≥n en el hipervisor, la VM lo ve como una solicitud enviada.  Est√° listo para ejecutarse y espera a la CPU, pero no recibe tiempo de CPU.  El VM piensa que el tiempo ha sido robado. <br><br>  Esto sucede cuando se env√≠a el b√∫fer.  Va al espacio del kernel del hipervisor y lo esperamos.  Desde el punto de vista de la VM, deber√≠a regresar de inmediato.  Por lo tanto, de acuerdo con nuestro algoritmo de c√°lculo de <i>robo</i> , esta vez se considera robado.  Es probable que otros mecanismos puedan estar involucrados en esto (por ejemplo, el procesamiento de otras <i>llamadas del sistema</i> ), pero no deber√≠an diferir en ning√∫n grado significativo. <br><br>  Programador frente a m√°quinas virtuales altamente cargadas.  Cuando una VM sufre de <i>robo</i> m√°s que las otras, esto se conecta directamente con el planificador.  Cuanto mayor sea la carga que un proceso pone en una CPU, m√°s r√°pido lo lanzar√° un planificador, para permitir que otros procesos funcionen.  Si la VM consume poco, casi no experimentar√° <i>robo.</i>  Su proceso acaba de estar sentado y esperando, y se le debe dar m√°s tiempo.  Si la VM pone una carga m√°xima en todos los n√∫cleos, el proceso se descarta con m√°s frecuencia y se le otorga menos tiempo a la VM. <br><br>  Es a√∫n peor cuando los procesos dentro de la VM intentan obtener m√°s CPU, porque no pueden procesar los datos.  Luego, el sistema operativo en el hipervisor proporcionar√° menos tiempo de CPU debido a la optimizaci√≥n justa.  Esto procesa bolas de nieve y <i>roba</i> oleadas a gran altura, mientras que otras m√°quinas virtuales pueden ni siquiera notarlo.  Cuantos m√°s n√∫cleos haya, peor es para el desafortunado VM.  En resumen, las m√°quinas virtuales altamente cargadas con muchos n√∫cleos son las que m√°s sufren. <br><br>  Baja LA pero el <i>robo</i> est√° presente.  Si la LA es de aproximadamente 0.7 (lo que significa que el hipervisor parece estar subcargado), pero hay <i>robo</i> en algunas m√°quinas virtuales: <br><br><ul><li>  Se aplica el ejemplo de paravirtualizaci√≥n mencionado anteriormente.  La VM puede estar recibiendo m√©tricas que indican <i>robo</i> , mientras que el hipervisor no tiene problemas.  Seg√∫n los resultados de nuestras pruebas, dicho <i>robo</i> no tiende a exceder el 10% y no tiene un impacto significativo en el rendimiento de la aplicaci√≥n dentro de la VM. <br></li><li>  El par√°metro LA se ha calculado incorrectamente.  M√°s precisamente, se ha calculado correctamente en un momento espec√≠fico, pero al promediar, es m√°s bajo de lo que deber√≠a ser durante un minuto.  Por ejemplo, si una VM (un tercio del hipervisor) consume todas las CPU durante 30 segundos, la LA por un minuto ser√° 0.15.  Cuatro de esas m√°quinas virtuales, trabajando al mismo tiempo, dar√°n como resultado un valor de 0.6.  Seg√∫n el LA, no podr√≠a deducir que durante 30 segundos para cada uno de ellos, el <i>robo</i> fue casi del 25%. <br></li><li>  Nuevamente, esto sucedi√≥ debido al planificador, que decidi√≥ que alguien estaba "comiendo" demasiado y los hizo esperar.  Mientras tanto, cambiar√° de contexto, procesar√° puntos de interrupci√≥n y atender√° otros asuntos importantes del sistema.  Como resultado, algunas m√°quinas virtuales no experimentan problemas y otras sufren p√©rdidas de rendimiento significativas. <br></li></ul><br><h2>  4. Otras distorsiones </h2><br>  Hay un mill√≥n de posibles razones para la distorsi√≥n de la asignaci√≥n equitativa de tiempo de CPU en una VM.  Por ejemplo, hyperthreading y NUMA agregan complejidad a los c√°lculos.  Complican la elecci√≥n del n√∫cleo utilizado para ejecutar un proceso porque un planificador utiliza coeficientes;  es decir, los pesos, que complican los c√°lculos a√∫n m√°s que esto al cambiar de contexto. <br><br>  Hay distorsiones que surgen de tecnolog√≠as como Turbo Boost o su modo opuesto de ahorro de energ√≠a, que podr√≠an aumentar o disminuir artificialmente la velocidad del n√∫cleo de la CPU e incluso el intervalo de tiempo.  Activar Turbo Boost para disminuir la productividad de un subproceso de CPU debido a un aumento del rendimiento en otro.  En ese momento, la informaci√≥n sobre la velocidad actual del reloj de la CPU no se env√≠a a la VM, que cree que alguien est√° robando su tiempo (por ejemplo, solicit√≥ 2 GHz y obtuvo la mitad). <br><br>  De hecho, puede haber muchas razones para la distorsi√≥n.  Puede encontrar algo completamente diferente en cualquier sistema dado.  Recomiendo comenzar con los libros vinculados anteriormente y obtener estad√≠sticas del hipervisor utilizando herramientas como perf, sysdig, systemtap y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">docenas de otras</a> . <br><br><h2>  5. Conclusiones </h2><br><ol><li>  Puede aparecer algo de <i>robo</i> debido a la paravirtualizaci√≥n y esto puede considerarse normal.  Las fuentes en l√≠nea dicen que este valor puede ser del 5-10%.  Depende de la aplicaci√≥n dentro de una VM y la carga que la VM pone en sus dispositivos f√≠sicos.  Es importante prestar atenci√≥n a c√≥mo se sienten las aplicaciones dentro de una VM. <br></li><li>  La correlaci√≥n entre la carga en el hipervisor y el <i>robo</i> dentro de una VM no siempre es segura.  Ambos c√°lculos de <i>robo</i> pueden ser incorrectos en algunos casos y con diferentes cargas. <br></li><li>  El programador no favorece los procesos que solicitan muchos recursos.  Intenta dar menos a los que piden m√°s.  Las grandes instancias son malas. <br></li><li>  Un peque√±o <i>robo tambi√©n</i> puede ser normal sin paravirtualizaci√≥n (teniendo en cuenta la carga dentro de la VM, las particularidades de las cargas de los vecinos, la distribuci√≥n de la carga entre subprocesos y otros factores). <br></li><li>  Si desea calcular el <i>robo</i> en un sistema en particular, investigue las diversas posibilidades, recopile m√©tricas, anal√≠celas a fondo y piense en c√≥mo distribuir la carga de manera justa.  En cualquier caso, puede haber desviaciones, que deben verificarse mediante pruebas o verlas en un depurador de kernel. <br></li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/453140/">https://habr.com/ru/post/453140/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../453126/index.html">La apariencia de UIA no fue tan simple</a></li>
<li><a href="../453128/index.html">Resumen de telecomunicaciones: 15 materiales expertos sobre IPv6, IS, est√°ndares y legislaci√≥n en TI</a></li>
<li><a href="../453130/index.html">C√≥digos correctivos sistem√°ticos. C√≥digo de grupo lineal</a></li>
<li><a href="../453136/index.html">API escrita: rompi√≥ XML (dos)</a></li>
<li><a href="../453138/index.html">Arte y ciencia: proyecto VITAE: muchas impresiones de palmeras en una flor de luna</a></li>
<li><a href="../453146/index.html">C√≥mo aprovechar al m√°ximo una conferencia</a></li>
<li><a href="../453148/index.html">AirBnb descuida sus cuentas</a></li>
<li><a href="../453154/index.html">Historia de Internet: mejora de la interactividad</a></li>
<li><a href="../453156/index.html">General Motors dar√° alma a todos sus autos nuevos (carcasa digital)</a></li>
<li><a href="../453158/index.html">No sab√≠a c√≥mo funcionan los procesadores, as√≠ que escrib√≠ un simulador de software</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>