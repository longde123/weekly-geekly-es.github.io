<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßëüèø‚Äçü§ù‚Äçüßëüèº üö£üèº ‚ôëÔ∏è Como otimizamos os scripts no Unity ü•ê ü§üüèΩ üçä</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Existem muitos excelentes artigos e tutoriais sobre desempenho do Unity. N√£o estamos tentando substitu√≠-los ou aprimor√°-los com este artigo; este √© ap...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Como otimizamos os scripts no Unity</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/481980/"> Existem muitos excelentes artigos e tutoriais sobre desempenho do Unity.  N√£o estamos tentando substitu√≠-los ou aprimor√°-los com este artigo; este √© apenas um breve resumo das etapas que seguimos ap√≥s a leitura desses artigos, bem como as etapas que nos permitiram resolver nossos problemas.  Eu recomendo fortemente que voc√™ pelo menos estude os materiais em <a href="https://learn.unity.com/">https://learn.unity.com/</a> . <br><br>  No processo de desenvolvimento do nosso jogo, encontramos problemas que, de tempos em tempos, causavam inibi√ß√£o no processo do jogo.  Depois de passar algum tempo no Unity Profiler, encontramos dois tipos de problemas: <br><br><ul><li>  Shaders n√£o otimizados </li><li>  Scripts n√£o otimizados em C # </li></ul><br>  A maioria dos problemas foi causada pelo segundo grupo, por isso decidi me concentrar nos scripts C # deste artigo (provavelmente tamb√©m porque n√£o escrevi um √∫nico sombreador em minha vida). <br><br><h1>  Procure pontos fracos </h1><br>  O objetivo deste artigo n√£o √© escrever um tutorial sobre o uso de um criador de perfil;  Eu s√≥ queria falar sobre o que nos interessava principalmente durante o processo de cria√ß√£o de perfil. <br><br>  <strong>O Unity Profiler √© sempre a melhor maneira de</strong> encontrar as causas dos atrasos nos scripts.  Eu recomendo <strong>criar um perfil do jogo diretamente no dispositivo</strong> , e n√£o no editor.  Desde que nosso jogo foi criado para iOS, eu precisava conectar o dispositivo e usar as Configura√ß√µes de compila√ß√£o mostradas na imagem, ap√≥s as quais o criador de perfil se conectava automaticamente. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5c7/fad/0e0/5c7fad0e0596f91c183a80ea3d72d1ae.png"></div><br>  <em>Criar configura√ß√µes para cria√ß√£o de perfil</em> <br><br>  Se voc√™ tentar pesquisar no Google ‚ÄúAtraso aleat√≥rio no Unity‚Äù ou outro pedido semelhante, ver√° que a maioria das pessoas recomenda se <strong>concentrar na coleta de lixo</strong> , exatamente o que eu fiz.  O lixo √© gerado toda vez que voc√™ para de usar algum objeto (inst√¢ncia de classe), ap√≥s o qual o coletor de lixo do Unity inicia de tempos em tempos para limpar a bagun√ßa e liberar mem√≥ria, o que leva uma quantidade insana de tempo e leva a uma queda na taxa de quadros. <br><a name="habracut"></a><br><h2>  Como encontrar scripts indesejados no criador de perfil? </h2><br>  Basta selecionar Uso da CPU -&gt; Escolha a exibi√ß√£o Hierarquia -&gt; Classificar por aloca√ß√£o de GC <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/167/aed/605/167aed6059ad0276a4275d5edf2179db.png"></div><br>  <em>Op√ß√µes do criador de perfil para coleta de lixo</em> <br><br>  Sua tarefa √© conseguir alguns zeros na coluna de aloca√ß√£o do GC para a cena do jogo. <br><br>  Outra boa maneira √© <strong>classificar as entradas por Time ms</strong> (tempo de execu√ß√£o) e otimizar os scripts para que eles levem o m√≠nimo de tempo poss√≠vel.  Essa etapa teve um grande impacto para n√≥s, porque um de nossos componentes continha um <strong>loop for grande</strong> , que levou uma eternidade para ser conclu√≠do (sim, ainda n√£o encontramos uma maneira de nos livrar do loop), portanto, para n√≥s, era absolutamente necess√°rio otimizar o tempo de execu√ß√£o de todos os scripts, porque precis√°vamos economizar tempo de execu√ß√£o nesse loop for caro, mantendo uma frequ√™ncia est√°vel de 60 fps. <br><br>  Com base nos dados de cria√ß√£o de perfil, dividi a otimiza√ß√£o em duas partes: <br><br><ul><li>  Disposi√ß√£o de lixo </li><li>  Prazo de execu√ß√£o reduzido </li></ul><br><h1>  Parte 1: lutando contra o lixo </h1><br>  Nesta parte, vou contar o que fizemos para nos livrar do lixo.  Esse √© o conhecimento mais fundamental que qualquer desenvolvedor deve entender;  eles se tornaram uma parte importante de nossa an√°lise di√°ria em cada solicita√ß√£o de extra√ß√£o / mesclagem. <br><br><h2>  Primeira regra: nenhum novo objeto nos m√©todos de Atualiza√ß√£o </h2><br>  Idealmente, os <strong>m√©todos Update, FixedUpdate e LateUpdate n√£o devem conter as "novas" palavras-chave</strong> .  Voc√™ sempre deve usar o que voc√™ j√° tem. <br><br>  √Äs vezes, <strong>criar um novo objeto fica oculto</strong> em alguns m√©todos internos do Unity, portanto, n√£o √© t√£o √≥bvio.  Falaremos sobre isso mais tarde. <br><br><h2>  Segunda regra: crie uma vez e reutilize! </h2><br>  Em ess√™ncia, isso significa que voc√™ deve alocar mem√≥ria para tudo o que puder nos m√©todos Iniciar e Despertar.  Esta regra √© muito semelhante √† primeira.  Na verdade, essa √© apenas outra maneira de eliminar as ‚Äúnovas‚Äù palavras-chave dos m√©todos de atualiza√ß√£o. <br><br>  C√≥digo que: <br><br><ul><li>  cria novas inst√¢ncias </li><li>  procurando por qualquer objeto do jogo </li></ul><br>  Voc√™ sempre deve tentar passar dos m√©todos Update para Iniciar ou Despertar. <br><br>  Aqui est√£o exemplos de nossas altera√ß√µes: <br><br>  Aloca√ß√£o de mem√≥ria para listas no m√©todo Start, limpeza (Clear) e reutiliza√ß√£o, se necess√°rio. <br><br><pre><code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Bad code private List&lt;GameObject&gt; objectsList; void Update() { objectsList = new List&lt;GameObject&gt;(); objectsList.Add(......) } //Better Code private List&lt;GameObject&gt; objectsList; void Start() { objectsList = new List&lt;GameObject&gt;(); } void Update() { objectsList.Clear(); objectsList.Add(......) }</span></span></code> </pre> <br>  Armazenando links e reutilizando-os da seguinte maneira: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Bad code void Update() { var levelObstacles = FindObjectsOfType&lt;Obstacle&gt;(); foreach(var obstacle in levelObstacles) { ....... } } //Better code private Object[] levelObstacles; void Start() { levelObstacles = FindObjectsOfType&lt;Obstacle&gt;(); } void Update() { foreach(var obstacle in levelObstacles) { ....... } }</span></span></code> </pre> <br>  O mesmo se aplica ao m√©todo FindGameObjectsWithTag ou a qualquer outro m√©todo que retorne uma nova matriz. <br><br><h2>  A terceira regra: cuidado com as cordas e evite concaten√°-las </h2><br>  Quando se trata de criar lixo, as linhas s√£o terr√≠veis.  Mesmo as opera√ß√µes mais simples de strings podem criar muito lixo.  Porque  Strings s√£o apenas matrizes, e essas matrizes s√£o imut√°veis.  Isso significa que toda vez que voc√™ concatena duas linhas, uma nova matriz √© criada e a antiga se transforma em lixo.  Felizmente, o StringBuilder pode ser usado para evitar ou minimizar essa cria√ß√£o de lixo. <br><br>  Aqui est√° um exemplo de como voc√™ pode melhorar a situa√ß√£o: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Bad code void Start() { text = GetComponent&lt;Text&gt;(); } void Update() { text.text = "Player " + name + " has score " + score.toString(); } //Better code void Start() { text = GetComponent&lt;Text&gt;(); builder = new StringBuilder(50); } void Update() { //StringBuilder has overloaded Append method for all types builder.Length = 0; builder.Append("Player "); builder.Append(name); builder.Append(" has score "); builder.Append(score); text.text = builder.ToString(); }</span></span></code> </pre> <br>  Est√° tudo bem com o exemplo mostrado acima, mas ainda existem muitas possibilidades para melhorar o c√≥digo.  Como voc√™ pode ver, quase toda a cadeia pode ser considerada est√°tica.  Dividimos a sequ√™ncia em duas partes para dois objetos UI.Text.  Primeiro, um cont√©m apenas o texto est√°tico <strong>"Player" + nome + "possui pontua√ß√£o"</strong> , que pode ser atribu√≠do no m√©todo Start, e o segundo cont√©m o valor da pontua√ß√£o, que √© atualizado em cada quadro.  <strong>Sempre torne as linhas est√°ticas realmente est√°ticas e gere-as no m√©todo Iniciar ou Despertar</strong> .  Ap√≥s essa melhoria, quase tudo est√° em ordem, mas um pouco de lixo ainda √© gerado ao chamar Int.ToString (), Float.ToString (), etc. <br><br>  Resolvemos esse problema gerando e pr√©-alocando mem√≥ria para todas as linhas poss√≠veis.  Pode parecer um desperd√≠cio est√∫pido de mem√≥ria, mas essa solu√ß√£o atende perfeitamente √†s nossas necessidades e resolve completamente o problema.  Portanto, no final, obtivemos uma matriz est√°tica, cujo acesso pode ser acessado diretamente usando √≠ndices para obter a string desejada que denota um n√∫mero: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>[] NUMBERS_THREE_DECIMAL = { <span class="hljs-string"><span class="hljs-string">"000"</span></span>, <span class="hljs-string"><span class="hljs-string">"001"</span></span>, <span class="hljs-string"><span class="hljs-string">"002"</span></span>, <span class="hljs-string"><span class="hljs-string">"003"</span></span>, <span class="hljs-string"><span class="hljs-string">"004"</span></span>, <span class="hljs-string"><span class="hljs-string">"005"</span></span>, <span class="hljs-string"><span class="hljs-string">"006"</span></span>,..........</code> </pre> <br><h2>  Quarta regra: valores de cache retornados pelos m√©todos de acesso </h2><br>  Isso pode ser muito dif√≠cil, porque mesmo um m√©todo simples de acessador como o mostrado abaixo gera lixo: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Bad Code void Update() { gameObject.tag; //or gameObject.name; }</span></span></code> </pre> <br>  Tente evitar o uso de m√©todos de acesso no m√©todo Update.  Chame o m√©todo de acesso apenas uma vez no m√©todo Start e armazene em cache o valor de retorno. <br><br>  Em geral, eu recomendo <strong>N√ÉO chamar nenhum m√©todo de acesso de string ou m√©todo de acesso de matriz no m√©todo Update</strong> .  Na maioria dos casos, basta <strong>obter o link uma vez no m√©todo Start</strong> . <br><br>  Aqui est√£o dois exemplos mais comuns de outro c√≥digo de m√©todo de acesso n√£o otimizado: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Bad Code void Update() { //Allocates new array containing all touches Input.touches[0]; } //Better Code void Update() { Input.GetTouch(0); } //Bad Code void Update() { //Returns new string(garbage) and compare the two strings gameObject.Tag == "MyTag"; } //Better Code void Update() { gameObject.CompareTag("MyTag"); }</span></span></code> </pre> <br><h2>  Quinta regra: usar fun√ß√µes que n√£o alocam mem√≥ria </h2><br>  Para algumas fun√ß√µes do Unity, alternativas que n√£o s√£o de mem√≥ria podem ser encontradas.  No nosso caso, todas essas fun√ß√µes est√£o relacionadas √† f√≠sica.  Nosso reconhecimento de colis√£o √© baseado em <br><br><pre> <code class="cs hljs">Physics2D. CircleCast();</code> </pre> <br>  Nesse caso espec√≠fico, voc√™ pode encontrar uma fun√ß√£o que n√£o seja de mem√≥ria chamada <br><br><pre> <code class="cs hljs">Physics2D. CircleCastNonAlloc();</code> </pre> <br>  Muitas outras fun√ß√µes tamb√©m t√™m alternativas semelhantes; portanto, <strong>verifique sempre a documenta√ß√£o quanto √†s fun√ß√µes NonAlloc</strong> . <br><br><h2>  Sexta regra: n√£o use LINQ </h2><br>  Apenas n√£o fa√ßa isso.  Quero dizer, voc√™ n√£o precisa us√°-lo em nenhum c√≥digo que seja executado com frequ√™ncia.  Sei que ao usar o LINQ, o c√≥digo √© mais f√°cil de ler, mas em muitos casos o desempenho e a aloca√ß√£o de mem√≥ria desse c√≥digo s√£o terr√≠veis.  √â claro que √†s vezes pode ser usado, mas, para ser sincero, em nosso jogo n√£o usamos o LINQ. <br><br><h2>  S√©tima regra: crie uma vez e reutilize, parte 2 </h2><br>  Desta vez, estamos falando sobre agrupar objetos.  N√£o entrarei nos detalhes do pool, porque isso foi dito muitas vezes, por exemplo, estude este tutorial: <a href="https://learn.unity.com/tutorial/object-pooling">https://learn.unity.com/tutorial/object-pool</a> <br><br>  No nosso caso, o seguinte script de pool de objetos √© usado.  Temos um n√≠vel gerado cheio de obst√°culos que existem por um certo per√≠odo de tempo at√© que o jogador passe por essa parte do n√≠vel.  Inst√¢ncias de tais obst√°culos s√£o criadas a partir de pr√©-fabricados, se determinadas condi√ß√µes forem atendidas.  O c√≥digo est√° no m√©todo Update.  Este c√≥digo √© completamente ineficiente em termos de mem√≥ria e tempo de execu√ß√£o.  Resolvemos o problema gerando um conjunto de 40 obst√°culos: se necess√°rio, obtemos obst√°culos do conjunto e devolvemos o objeto de volta ao conjunto quando ele n√£o √© mais necess√°rio. <br><br><h2>  A oitava regra: mais atentamente com a transforma√ß√£o de embalagens (Boxe)! </h2><br>  Boxe gera lixo!  Mas o que √© boxe?  Na maioria das vezes, o boxe ocorre quando voc√™ passa um tipo de valor (int, float, bool, etc.) para uma fun√ß√£o que espera um objeto do tipo Object. <br><br>  Aqui est√° um exemplo de boxe que precisamos corrigir em nosso projeto: <br><br>  Implementamos nosso pr√≥prio sistema de mensagens no projeto.  Cada mensagem pode conter uma quantidade ilimitada de dados.  Os dados s√£o armazenados em um dicion√°rio definido da seguinte maneira: <br><br><pre> <code class="cs hljs">Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt; data;</code> </pre> <br>  Tamb√©m temos um setter que define valores neste dicion√°rio: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Action </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetAttribute</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> attribute, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span></span><span class="hljs-function">)</span></span> { data[attribute] = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; }</code> </pre> <br>  O boxe aqui √© bastante √≥bvio.  Voc√™ pode chamar a fun√ß√£o da seguinte maneira: <br><br><pre> <code class="cs hljs">SetAttribute(<span class="hljs-string"><span class="hljs-string">"my_int_value"</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>);</code> </pre> <br>  Em seguida, o valor "12" √© submetido ao boxe e isso gera lixo. <br><br>  Resolvemos o problema criando cont√™ineres de dados separados para cada tipo primitivo, e o cont√™iner Object anterior √© usado apenas para tipos de refer√™ncia. <br><br><pre> <code class="cs hljs">Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt; data; Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; dataBool; Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; dataInt; .......</code> </pre> <br>  Tamb√©m temos setters separados para cada tipo de dados: <br><br><pre> <code class="cs hljs">SetBoolAttribute(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> attribute, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) SetIntAttribute(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> attribute, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>)</code> </pre> <br>  E todos esses setters s√£o implementados de forma que eles chamam a mesma fun√ß√£o generalizada: <br><br><pre> <code class="cs hljs">SetAttribute&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, T&gt; dict, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> attribute, T <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>)</code> </pre> <br>  O problema do boxe foi resolvido! <br><br>  Leia mais sobre isso no artigo <a href="https://docs.microsoft.com/cs-cz/dotnet/csharp/programming-guide/types/boxing-and-unboxing">https://docs.microsoft.com/cs-cz/dotnet/csharp/programming-guide/types/boxing-and-unboxing</a> . <br><br><h2>  A nona regra: os ciclos est√£o sempre sob suspeita </h2><br>  Essa regra √© muito semelhante √† primeira e √† segunda.  Apenas tente remover todo o c√≥digo opcional dos loops por motivos de desempenho e mem√≥ria. <br><br>  Em geral, nos esfor√ßamos para nos livrar dos loops nos m√©todos Update, mas se n√£o pudermos ficar sem eles, pelo menos evitaremos qualquer aloca√ß√£o de mem√≥ria nesses loops.  Portanto, siga as <strong>regras de 1 a 8 e aplique-as aos loops</strong> em geral, n√£o apenas aos m√©todos de atualiza√ß√£o. <br><br><h2>  Regra 10: sem lixo nas bibliotecas externas </h2><br>  Caso aconte√ßa que parte do lixo seja gerada pelo c√≥digo baixado do armazenamento de ativos, esse problema ter√° muitas solu√ß√µes.  Mas antes de fazer engenharia reversa e depura√ß√£o, basta voltar ao armazenamento de ativos e atualizar a biblioteca.  No nosso caso, todos os ativos usados ‚Äã‚Äãainda eram suportados por autores que continuavam lan√ßando atualiza√ß√µes de melhoria de desempenho, portanto, isso resolveu todos os nossos problemas.  <strong>Depend√™ncias devem ser relevantes!</strong>  Prefiro me livrar da biblioteca do que ficar sem suporte. <br><br><h1>  Parte 2: maximizando o tempo de execu√ß√£o </h1><br>  Algumas das regras acima fazem uma diferen√ßa sutil se o c√≥digo raramente √© chamado.  H√° um grande loop em nosso c√≥digo que √© executado em cada quadro, portanto, mesmo essas pequenas altera√ß√µes tiveram um grande efeito. <br><br>  Algumas dessas altera√ß√µes, se usadas incorretamente ou na situa√ß√£o errada, podem levar a um tempo de execu√ß√£o ainda pior.  <strong>Sempre verifique o criador de perfil depois de inserir cada otimiza√ß√£o no c√≥digo para garantir que voc√™ esteja se movendo na dire√ß√£o certa</strong> . <br><br>  Honestamente, algumas <strong>dessas regras levam a um c√≥digo leg√≠vel muito pior</strong> e √†s vezes at√© <strong>violam as recomenda√ß√µes</strong> , por exemplo, a incorpora√ß√£o de c√≥digo mencionada em uma das regras abaixo. <br><br>  Muitas dessas regras se sobrep√µem √†s apresentadas na primeira parte do artigo.  Normalmente, o desempenho do c√≥digo de gera√ß√£o de lixo √© menor comparado ao c√≥digo sem a gera√ß√£o de lixo. <br><br><h2>  A primeira regra: a ordem de execu√ß√£o correta </h2><br>  <strong>Mova o c√≥digo dos m√©todos FixedUpdate, Update, LateUpdate para os m√©todos Start e Awake</strong> .  Sei que isso parece loucura, mas acredite, se voc√™ se aprofundar no seu c√≥digo, encontrar√° centenas de linhas de c√≥digo que podem ser movidas para m√©todos executados apenas uma vez. <br><br>  No nosso caso, esse c√≥digo geralmente est√° associado a <br><br><ul><li>  Chamadas para GetComponent &lt;&gt; </li><li>  C√°lculos que realmente retornam o mesmo resultado em cada quadro </li><li>  V√°rias inst√¢ncias dos mesmos objetos, geralmente listas </li><li>  Pesquisar GameObjects </li><li>  Obtendo links para o Transform e usando outros m√©todos de acesso </li></ul><br>  Aqui est√° uma lista de c√≥digos de exemplo que foram movidos dos m√©todos Update para os m√©todos Start: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//There must be a good reason to keep GetComponent in Update gameObject.GetComponent&lt;LineRenderer&gt;(); gameObject.GetComponent&lt;CircleCollider2D&gt;(); //Examples of calculations returning same result every frame Mathf.FloorToInt(Screen.width / 2); var width = 2f * mainCamera.orthographicSize * mainCamera.aspect; var castRadius = circleCollider.radius * transform.lossyScale.x; var halfSize = GetComponent&lt;SpriteRenderer&gt;().bounds.size.x / 2f; //Finding objects var levelObstacles = FindObjectsOfType&lt;Obstacle&gt;(); var levelCollectibles = FindGameObjectsWithTag("COLLECTIBLE"); //References objectTransform = gameObject.transform; mainCamera = Camera.main;</span></span></code> </pre> <br><h2>  Segunda regra: execute o c√≥digo somente quando necess√°rio </h2><br>  No nosso caso, isso est√° relacionado principalmente aos scripts de atualiza√ß√£o da interface do usu√°rio.  Aqui est√° um exemplo de como alteramos a implementa√ß√£o do c√≥digo que exibe o estado atual dos itens coletados no n√≠vel. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Bad code Text text; GameState gameState; void Start() { gameState = StoreProvider.Get&lt;GameState&gt;(); text = GetComponent&lt;Text&gt;(); } void Update() { text.text = gameState.CollectedCollectibles.ToString(); }</span></span></code> </pre> <br>  Como em cada n√≠vel h√° apenas alguns itens a serem coletados, n√£o faz sentido alterar o texto da interface do usu√°rio em cada quadro.  Portanto, alteramos o texto somente quando o n√∫mero muda. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Better code Text text; GameState gameState; int collectiblesCount; void Start() { gameState = StoreProvider.Get&lt;GameState&gt;(); text = GetComponent&lt;Text&gt;(); collectiblesCount = gameState.CollectedCollectibles; } void Update() { if(collectiblesCount != gameState.CollectedCollectibles) { //This code is ran only about 5 times each level collectiblesCount = gameState.CollectedCollectibles; text.text = collectiblesCount.ToString(); } }</span></span></code> </pre> <br>  Esse c√≥digo √© muito melhor, especialmente se as a√ß√µes forem muito mais complicadas do que apenas alterar a interface do usu√°rio. <br><br>  Se voc√™ estiver procurando por uma solu√ß√£o mais abrangente, recomendo implementar <a href="https://en.wikipedia.org/wiki/Observer_pattern">o modelo Observer</a> usando eventos C # ( <a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/events/">https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/events/</a> ). <br><br>  De qualquer forma, isso ainda n√£o era suficiente para n√≥s, e quer√≠amos implementar uma solu√ß√£o completamente generalizada, ent√£o criamos uma biblioteca que implementa o <a href="https://facebook.github.io/flux/">Flux</a> in Unity.  Isso levou a uma solu√ß√£o muito simples, na qual todo o estado do jogo √© armazenado no objeto Store e todos os elementos da interface do usu√°rio e outros componentes s√£o notificados quando o estado muda e reagem a essa altera√ß√£o sem c√≥digo no m√©todo Update. <br><br><h2>  A terceira regra: os ciclos est√£o sempre sob suspeita </h2><br>  Essa √© exatamente a mesma regra que mencionei na primeira parte do artigo.  Se houver um loop no c√≥digo que ignore iterativamente um grande n√∫mero de elementos, para melhorar o desempenho do loop, use as duas regras de ambas as partes do artigo. <br><br><h2>  Quarta Regra: Para Melhor que para Foreach </h2><br>  O loop Foreach √© muito f√°cil de escrever, mas "muito dif√≠cil" de executar.  Dentro do loop Foreach, o Enumerator √© usado para processar iterativamente o conjunto de dados e retornar o valor.  Isso √© mais complicado do que iterar sobre √≠ndices em um loop For simples. <br><br>  Portanto, em nosso projeto, sempre que poss√≠vel, substitu√≠mos os loops Foreach por For: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Bad code foreach (GameObject obstacle in obstacles) //Better code var count = obstacles.Count; for (int i = 0; i &lt; count; i++) { obstacles[i]; }</span></span></code> </pre> <br>  No nosso caso, com um loop for grande, essa altera√ß√£o √© muito significativa.  <strong>Um loop for simples acelera o c√≥digo duas vezes</strong> . <br><br><h2>  Quinta regra: matrizes s√£o melhores que listas </h2><br>  Em nosso c√≥digo, descobrimos que a maioria das listas tem comprimento constante ou podemos calcular o n√∫mero m√°ximo de elementos.  Portanto, n√≥s os reimplementamos com base em matrizes e, em alguns casos, isso levou a uma dupla acelera√ß√£o de itera√ß√µes sobre os dados. <br><br>  Em alguns casos, listas ou outras estruturas de dados complexas n√£o podem ser evitadas.  Acontece que voc√™ geralmente precisa adicionar ou remover elementos e, nesse caso, √© melhor usar listas.  Mas, em geral, as <strong>matrizes sempre devem ser usadas para listas de tamanho fixo</strong> . <br><br><h2>  Sexta regra: opera√ß√µes flutuantes s√£o melhores que opera√ß√µes vetoriais </h2><br>  Essa diferen√ßa √© quase impercept√≠vel se voc√™ n√£o realizar milhares dessas opera√ß√µes, como foi o caso em nosso caso, portanto, para n√≥s, o aumento da produtividade acabou sendo significativo. <br><br>  Fizemos altera√ß√µes semelhantes: <br><br><pre> <code class="cs hljs">Vector3 pos1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>); Vector3 pos2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>); <span class="hljs-comment"><span class="hljs-comment">//Bad code var pos3 = pos1 + pos2; //Better code var pos3 = new Vector3(pos1.x + pos2.x, pos1.y + pos2.y, ......); Vector3 pos1 = new Vector3(1,2,3); //Bad code var pos2 = pos1 * 2f; //Better code var pos2 = new Vector3(pos1.x * 2f, pos1.y * 2f, ......);</span></span></code> </pre> <br><h2>  S√©tima regra: procure objetos corretamente </h2><br>  Sempre pense se voc√™ realmente precisa usar o m√©todo GameObject.Find ().  Este m√©todo √© pesado e leva uma quantidade insana de tempo.  Voc√™ nunca deve usar esse m√©todo nos m√©todos de atualiza√ß√£o.  Descobrimos que a maioria das chamadas de localiza√ß√£o pode ser <strong>substitu√≠da por links diretos no editor</strong> , o que, √© claro, √© muito melhor. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Bad Code GameObject player; void Start() { player = GameObject.Find("PLAYER"); } //Better Code //Assign the reference to the player object in editor [SerializeField] GameObject player; void Start() { }</span></span></code> </pre> <br>  Se isso for imposs√≠vel, <strong>considere</strong> pelo menos <strong>usar tags (Tag) e procurar um objeto por seu r√≥tulo usando GameObject.FindWithTag</strong> . <br><br>  Portanto, no caso geral: <strong>Link direto&gt; GameObject.FindWithTag ()&gt; GameObject.Find ()</strong> <br><br><h2>  Oitava regra: trabalhar apenas com objetos relevantes </h2><br>  No nosso caso, isso foi importante para o reconhecimento de colis√µes usando RayCast-s (CircleCast, etc.).  Em vez de reconhecer colis√µes e decidir quais delas s√£o importantes no c√≥digo, <strong>movemos os objetos do jogo para as camadas apropriadas,</strong> para que possamos calcular colis√µes apenas para os objetos necess√°rios. <br><br>  Aqui est√° um exemplo <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Bad Code void DetectCollision() { var count = Physics2D.CircleCastNonAlloc( position, radius, direction, results, distance); for (int i = 0; i &lt; count; i++) { var obj = results[i].collider.transform.gameObject; if(obj.CompareTag("FOO")) { ProcessCollision(results[i]); } } } //Better Code //We added all objects with tag FOO into the same layer void DetectCollision() { //8 is number of the desired layer var mask = 1 &lt;&lt; 8; var count = Physics2D.CircleCastNonAlloc( position, radius, direction, results, distance, mask); for (int i = 0; i &lt; count; i++) { ProcessCollision(results[i]); } }</span></span></code> </pre> <br><h2>  A nona regra: use r√≥tulos corretamente </h2><br>  N√£o h√° d√∫vida de que os r√≥tulos s√£o muito √∫teis e podem melhorar o desempenho do c√≥digo, mas lembre-se de que <strong>existe apenas uma maneira correta de comparar os r√≥tulos dos objetos</strong> ! <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Bad Code gameObject.Tag == "MyTag"; //Better Code gameObject.CompareTag("MyTag");</span></span></code> </pre> <br><h2>  A d√©cima regra: cuidado com os truques com a c√¢mera! </h2><br>  √â t√£o f√°cil usar o <strong>Camera.main</strong> , mas o desempenho desta a√ß√£o √© muito baixo.  O motivo √© que, nos bastidores de cada chamada para Camera.main, o mecanismo do Unity realmente executa o resultado FindGameObjectsWithTag (), ent√£o j√° entendemos que voc√™ n√£o precisa cham√°-lo com frequ√™ncia e √© melhor resolver esse problema <strong>armazenando o link no m√©todo Iniciar.</strong> ou acordado. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Bad code void Update() { Camera.main.orthographicSize //Some operation with camera } //Better Code private Camera cam; void Start() { cam = Camera.main; } void Update() { cam.orthographicSize //Some operation with camera }</span></span></code> </pre> <br><h2>  D√©cima Primeira Regra: Posi√ß√£o Local √© Melhor que Posi√ß√£o </h2><br>  <strong>Sempre que poss√≠vel, use Transform.LocalPosition para getters e setters em vez de Transform.Position</strong> .  Dentro de cada chamada Transform.Position, muito mais opera√ß√µes s√£o executadas, por exemplo, calculando a posi√ß√£o global no caso de uma chamada getter ou calculando a posi√ß√£o local a partir da global no caso de uma chamada setter.  Em nosso projeto, descobriu-se que voc√™ pode usar LocalPositions em 99% dos casos usando Transform.Position e n√£o √© necess√°rio fazer outras altera√ß√µes no c√≥digo. <br><br><h2>  D√©cima segunda regra: n√£o use o LINQ </h2><br>  Isso j√° foi discutido na primeira parte.  S√≥ n√£o use, √© tudo. <br><br><h2>  D√©cima terceira regra: n√£o tenha medo (√†s vezes) de quebrar as regras </h2><br>  √Äs vezes, mesmo chamar uma fun√ß√£o simples pode ser muito caro.  Nesse caso, voc√™ deve sempre considerar a incorpora√ß√£o de c√≥digo (Code Inlining).  O que isso significa?  De fato, apenas pegamos o c√≥digo da fun√ß√£o e o copiamos diretamente para o local em que queremos usar a fun√ß√£o para evitar a chamada de m√©todos adicionais. <br><br>  Na maioria dos casos, isso n√£o ter√° nenhum efeito, porque a incorpora√ß√£o do c√≥digo √© realizada automaticamente no est√°gio de compila√ß√£o, mas existem certas regras pelas quais o compilador decide se deve incorporar o c√≥digo (por exemplo, m√©todos virtuais nunca s√£o incorporados; para obter mais detalhes, consulte <a href="https://docs.unity3d.com/Manual/BestPracticeUnderstandingPerformanceInUnity8.html">https: //docs.unity3d.com/Manual/BestPracticeUnderstandingPerformanceInUnity8.html</a> ).  Ent√£o, basta abrir o criador de perfil, iniciar o jogo no dispositivo de destino e ver se algo pode ser melhorado. <br><br>  No nosso caso, havia v√°rias fun√ß√µes que decidimos integrar para melhorar o desempenho, especialmente no loop for grande. <br><br><h1>  Conclus√£o </h1><br>  Aplicando as regras listadas no artigo, conseguimos facilmente 60 fps est√°veis ‚Äã‚Äãno jogo para iOS, mesmo no iPhone 5S.  Talvez algumas regras possam ser espec√≠ficas apenas ao nosso projeto, mas acho que a maioria delas deve ser lembrada ao escrever um c√≥digo ou verific√°-lo para evitar problemas no futuro.  √â sempre melhor escrever c√≥digo constantemente com base no desempenho do que depois para refatorar grandes partes de c√≥digo. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt481980/">https://habr.com/ru/post/pt481980/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt481960/index.html">2. Pilha el√°stica: an√°lise de logs de seguran√ßa. Logstash</a></li>
<li><a href="../pt481964/index.html">Como organizar uma libera√ß√£o</a></li>
<li><a href="../pt481970/index.html">‚ÄúFormatos e m√≠dias de √°udio esquecidos‚Äù: o in√≠cio da era do √°udio compacto ou ‚Äúprimeira mudan√ßa‚Äù para bobinas</a></li>
<li><a href="../pt481974/index.html">Teste de melancia usando redes neurais: desenvolvedor completo Ciclo de prototipagem para o aplicativo. no google play</a></li>
<li><a href="../pt481978/index.html">Como organizar o trabalho efetivo de uma equipe de layout distribu√≠do</a></li>
<li><a href="../pt481988/index.html">Por que Koji √© o recurso perfeito para criadores iniciantes de aplicativos KaiOS</a></li>
<li><a href="../pt481990/index.html">Dez anos de malware: as maiores botnets de 2010</a></li>
<li><a href="../pt481992/index.html">Pipeline Tekton - pipelines nativos de Kubernetes</a></li>
<li><a href="../pt481996/index.html">Detetive Habra no fim de semana 2. Novo n√≠vel</a></li>
<li><a href="../pt482000/index.html">Voc√™ gosta do seu neg√≥cio?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>