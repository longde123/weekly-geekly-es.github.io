<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ“… ğŸ“— ğŸ”› Semua yang perlu Anda ketahui tentang pemulung di Python ğŸ‘¨â€ğŸ‘¨â€ğŸ‘¦â€ğŸ‘¦ ğŸ›‘ ğŸ¦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Secara umum, Anda tidak perlu khawatir tentang pengumpul sampah dan bekerja dengan memori saat Anda menulis kode Python. Segera setelah objek tidak la...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Semua yang perlu Anda ketahui tentang pemulung di Python</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/417215/">  Secara umum, Anda tidak perlu khawatir tentang pengumpul sampah dan bekerja dengan memori saat Anda menulis kode Python.  Segera setelah objek tidak lagi diperlukan, Python secara otomatis membebaskan memori dari bawahnya.  Meskipun demikian, memahami cara kerja GC akan membantu Anda menulis kode yang lebih baik. <br><br><h4>  Manajer memori </h4><br>  Tidak seperti bahasa populer lainnya, Python tidak membebaskan semua memori kembali ke sistem operasi segera setelah menghapus suatu objek.  Sebagai gantinya, ia menggunakan manajer memori tambahan yang dirancang untuk objek kecil (yang ukurannya kurang dari 512 byte).  Untuk bekerja dengan objek-objek seperti itu, ia mengalokasikan blok memori yang besar, di mana banyak objek kecil akan disimpan di masa depan. <br><br>  Segera setelah salah satu objek kecil dihapus - memori dari bawahnya tidak masuk ke sistem operasi, Python meninggalkannya untuk objek baru dengan ukuran yang sama.  Jika tidak ada objek yang tersisa di salah satu blok memori yang dialokasikan, maka Python dapat melepaskannya ke sistem operasi.  Biasanya, blok dilepaskan ketika skrip menciptakan banyak objek sementara. <br><a name="habracut"></a><br>  Jadi, jika proses Python berumur panjang mulai mengkonsumsi lebih banyak memori dari waktu ke waktu, ini tidak berarti bahwa kode Anda memiliki masalah kebocoran memori.  Jika Anda ingin tahu lebih banyak tentang manajer memori dengan Python, Anda dapat membacanya di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel saya yang lain</a> . <br><br><h4>  Algoritma Pengumpulan Sampah </h4><br>  Interpreter python standar (CPython) menggunakan dua algoritma sekaligus, penghitungan referensi dan pengumpul sampah generasi (selanjutnya disebut GC), lebih dikenal sebagai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">modul gc</a> standar dari Python. <br><br>  Algoritma penghitungan tautan sangat sederhana dan efisien, tetapi memiliki satu kelemahan besar.  Dia tidak tahu bagaimana mendefinisikan referensi melingkar.  Karena inilah dalam python ada kolektor tambahan yang disebut GC generasi yang memantau objek dengan referensi melingkar yang potensial. <br><br>  Dalam Python, algoritma penghitungan referensi bersifat mendasar dan tidak dapat dinonaktifkan, sedangkan GC adalah opsional dan dapat dinonaktifkan. <br><br><h4>  Tautan Algoritma Penghitungan </h4><br>  Algoritma penghitungan tautan adalah salah satu teknik pengumpulan sampah yang paling mudah.  Objek dihapus segera setelah mereka tidak lagi direferensikan. <br><br>  Dalam Python, variabel tidak menyimpan nilai, tetapi bertindak sebagai referensi ke objek.  Yaitu, saat Anda menetapkan nilai ke variabel baru, pertama-tama sebuah objek dengan nilai ini dibuat, dan baru kemudian variabel tersebut mulai merujuk padanya.  Beberapa variabel dapat merujuk satu objek. <br><br>  Setiap objek di Python berisi bidang tambahan (referensi counter), yang menyimpan jumlah tautan ke sana.  Segera setelah seseorang merujuk ke objek, bidang ini bertambah satu.  Jika karena alasan tertentu tautannya hilang, maka bidang ini dikurangi satu. <br><br>  Contoh ketika jumlah tautan meningkat: <br><br><ul><li>  operator penugasan </li><li>  melewati argumen </li><li>  masukkan objek baru ke dalam sheet (jumlah tautan untuk objek bertambah) </li><li>  konstruksi form foo = bar (foo mulai merujuk ke objek yang sama dengan bar) </li></ul><br>  Segera setelah penghitung referensi untuk objek tertentu mencapai nol, penafsir memulai proses penghancuran objek.  Jika objek jauh berisi tautan ke objek lain, maka tautan ini juga dihapus.  Dengan demikian, penghapusan satu objek mungkin memerlukan penghapusan yang lain. <br><br>  Misalnya, jika daftar dihapus, maka jumlah referensi di semua elemennya dikurangi satu.  Jika semua objek dalam daftar tidak digunakan di tempat lain, maka mereka juga akan dihapus. <br><br>  Variabel yang dideklarasikan di luar fungsi, kelas, dan blok disebut global.  Biasanya, siklus hidup variabel tersebut sama dengan umur proses Python.  Dengan demikian, jumlah referensi ke objek yang dirujuk oleh variabel global tidak pernah turun ke nol. <br><br>  Variabel yang dideklarasikan di dalam blok (fungsi, kelas) memiliki visibilitas lokal (mis. Mereka hanya terlihat di dalam blok).  Segera setelah interpreter python keluar dari blok, ia menghancurkan semua tautan yang dibuat oleh variabel lokal di dalamnya. <br><br>  Anda selalu dapat memeriksa jumlah tautan menggunakan fungsi <code>sys.getrefcount</code> . <br><br>  Contoh penghitung tautan: <br><br><pre> <code class="python hljs">foo = [] <span class="hljs-comment"><span class="hljs-comment"># 2 ,    foo    getrefcount print(sys.getrefcount(foo)) def bar(a): # 4  #  foo,   (a), getrefcount       print(sys.getrefcount(a)) bar(foo) # 2 ,      print(sys.getrefcount(foo))</span></span></code> </pre><br>  Alasan utama bahwa juru bahasa standar (CPython) menggunakan penghitung referensi adalah historis.  Saat ini ada banyak perdebatan tentang pendekatan ini.  Beberapa orang percaya bahwa seorang pemulung dapat jauh lebih efisien tanpa algoritma penghitungan tautan.  Algoritma ini memiliki banyak masalah, seperti tautan sirkuler, blokir ulir, serta overhead tambahan untuk memori dan cpu. <br><br>  Keuntungan utama dari algoritma ini adalah bahwa objek dihapus segera setelah mereka tidak diperlukan. <br><br><h4>  Pengumpul sampah opsional </h4><br>  Mengapa kita perlu algoritma tambahan ketika kita sudah memiliki penghitungan referensi? <br><br>  Sayangnya, algoritma penghitungan tautan klasik memiliki satu kelemahan besar - ia tidak tahu cara menemukan tautan melingkar.  Loopback terjadi ketika satu atau lebih objek saling referensi. <br><br>  Dua contoh: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/46f/9b6/6ae/46f9b66aed851bb88c4c430a892e5670.svg" alt="gambar"><br><br>  Seperti yang Anda lihat, objek pertama mengacu pada dirinya sendiri, sedangkan <code>object1</code> dan <code>object2</code> merujuk.  Untuk objek seperti itu, jumlah referensi akan selalu 1. <br><br>  Demo python: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> gc <span class="hljs-comment"><span class="hljs-comment">#  ctypes        class PyObject(ctypes.Structure): _fields_ = [("refcnt", ctypes.c_long)] gc.disable() #   GC lst = [] lst.append(lst) #    lst lst_address = id(lst) #   lst del lst object_1 = {} object_2 = {} object_1['obj2'] = object_2 object_2['obj1'] = object_1 obj_address = id(object_1) #   del object_1, object_2 #          # gc.collect() #    print(PyObject.from_address(obj_address).refcnt) print(PyObject.from_address(lst_address).refcnt)</span></span></code> </pre><br>  Pada contoh di atas, instruksi del menghapus referensi ke objek kita (bukan objek itu sendiri).  Setelah Python mengeksekusi pernyataan del, objek-objek ini menjadi tidak dapat diakses dari kode Python.  Namun, dengan modul gc dimatikan, mereka masih akan tetap dalam memori, seperti  mereka memiliki referensi melingkar dan penghitung mereka masih satu.  Anda dapat secara visual menjelajahi hubungan tersebut menggunakan perpustakaan <code>objgraph</code> . <br><br>  Untuk memperbaiki masalah ini, algoritma tambahan yang dikenal sebagai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">modul gc</a> ditambahkan dengan Python 1.5.  Satu-satunya tugas yang merupakan penghapusan objek siklik yang tidak ada lagi akses dari kode. <br><br>  Loopback hanya dapat terjadi pada objek "wadah".  Yaitu  di objek yang dapat menyimpan objek lain, seperti daftar, kamus, kelas, dan tupel.  GC tidak melacak tipe sederhana dan tidak berubah, kecuali untuk tupel.  Beberapa tupel dan kamus juga dikecualikan dari daftar pelacakan ketika kondisi tertentu terpenuhi.  Dengan semua objek lain, algoritma penghitungan referensi dijamin untuk mengatasinya. <br><br><h4>  Ketika GC dipicu </h4><br>  Berbeda dengan algoritma penghitungan referensi, siklik GC tidak bekerja secara real time dan berjalan secara berkala.  Setiap proses kolektor menciptakan jeda mikro dalam kode, sehingga CPython (juru bahasa standar) menggunakan berbagai heuristik untuk menentukan frekuensi pengumpul sampah. <br><br>  Pengumpul sampah siklik membagi semua benda menjadi 3 generasi (generasi).  Benda-benda baru jatuh ke generasi pertama.  Jika fasilitas baru selamat dari proses pengumpulan sampah, maka pindah ke generasi berikutnya.  Semakin tinggi generasi, semakin jarang dipindai untuk mencari sampah.  Karena objek baru sering memiliki masa hidup yang sangat singkat (bersifat sementara), masuk akal untuk mewawancarai mereka lebih sering daripada yang telah melewati beberapa tahap pengumpulan sampah. <br><br>  Setiap generasi memiliki penghitung khusus dan ambang respons, setelah mencapai yang memicu proses pengumpulan sampah.  Setiap penghitung menyimpan jumlah alokasi dikurangi jumlah alokasi dalam satu generasi.  Segera setelah objek kontainer dibuat dengan Python, ia memeriksa penghitung ini.  Jika kondisinya berhasil, maka proses pengumpulan sampah dimulai. <br><br>  Jika beberapa generasi atau lebih telah melewati ambang pintu sekaligus, maka generasi paling senior yang dipilih.  Ini disebabkan oleh fakta bahwa generasi yang lebih tua juga memindai semua yang sebelumnya.  Untuk mengurangi jumlah pengumpulan sampah yang dijeda untuk objek yang berumur panjang, generasi tertua memiliki <a href="">serangkaian kondisi tambahan</a> . <br><br>  Ambang standar untuk generasi masing-masing diatur ke <code>700, 10  10</code> , tetapi Anda selalu dapat mengubahnya menggunakan fungsi <code>gc.get_threshold  gc.set_threshold</code> . <br><br><h4>  Algoritma Pencarian Lingkaran </h4><br>  Penjelasan lengkap tentang algoritma pencarian putaran akan membutuhkan artikel terpisah.  Singkatnya, GC mengulangi setiap objek dari generasi yang dipilih dan untuk sementara menghapus semua tautan dari satu objek (semua tautan yang dirujuk oleh objek ini).  Setelah lulus penuh, semua objek dengan jumlah tautan kurang dari dua dianggap tidak dapat diakses dari python dan dapat dihapus. <br><br>  Untuk pemahaman yang lebih dalam, saya sarankan membaca (catatan penerjemah: bahan bahasa Inggris) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">deskripsi asli dari algoritma dari Neil Schemenauer</a> dan fungsi <code>collect</code> dari <a href="">sumber CPython</a> .  Deskripsi dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Quora</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">postingan tentang pemulung</a> juga bisa bermanfaat. <br><br>  Perlu dicatat bahwa masalah dengan destruktor yang dijelaskan dalam deskripsi asli algoritma telah diperbaiki sejak Python 3.4 (lebih detail dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PEP 442</a> ). <br><br><h4>  Kiat Pengoptimalan </h4><br>  Loop sering terjadi dalam tugas-tugas kehidupan nyata, mereka dapat ditemukan dalam masalah dengan grafik, daftar tertaut, atau dalam struktur data di mana Anda perlu melacak hubungan antara objek.  Jika program Anda memiliki beban yang tinggi dan menuntut penundaan, maka, jika mungkin, loop sebaiknya dihindari. <br><br>  Di tempat-tempat di mana Anda secara sadar menggunakan tautan sirkuler, Anda dapat menggunakan tautan "lemah".  Lemah tautan diimplementasikan dalam modul <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lemahref</a> dan, tidak seperti tautan biasa, tidak mempengaruhi penghitung tautan dengan cara apa pun.  Jika objek dengan referensi lemah ternyata dihapus, maka tidak <code>None</code> dikembalikan. <br><br>  Dalam beberapa kasus, berguna untuk menonaktifkan pembangunan otomatis oleh modul gc dan memanggilnya secara manual.  Untuk melakukan ini, panggil saja <code>gc.disable()</code> lalu panggil <code>gc.collect()</code> secara manual. <br><br><h4>  Cara menemukan dan men-debug tautan melingkar </h4><br>  Debugging loop bisa menyakitkan, terutama jika kode Anda menggunakan banyak modul pihak ketiga. <br><br>  Modul gc menyediakan fungsi pembantu yang dapat membantu debugging.  Jika parameter GC diatur ke bendera <code>DEBUG_SAVEALL</code> , maka semua objek yang tidak dapat diakses akan ditambahkan ke daftar <code>gc.garbage</code> . <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> gc gc.set_debug(gc.DEBUG_SAVEALL) print(gc.get_count()) lst = [] lst.append(lst) list_id = id(lst) <span class="hljs-keyword"><span class="hljs-keyword">del</span></span> lst gc.collect() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> gc.garbage: print(item) <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> list_id == id(item)</code> </pre><br>  Setelah Anda mengidentifikasi tempat masalah - itu dapat divisualisasikan menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">objgraph</a> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3d8/355/be9/3d8355be99fea997cae6aff7fd7fb6b2.svg" alt="gambar"><br><br><h5>  Kesimpulan </h5><br>  Proses pengumpulan sampah utama dilakukan oleh algoritma penghitungan tautan, yang sangat sederhana dan tidak memiliki pengaturan.  Algoritme tambahan hanya digunakan untuk mencari dan menghapus objek dengan referensi melingkar. <br><br>  Anda tidak boleh terlibat dalam optimalisasi dini kode untuk pengumpul sampah, dalam praktiknya, masalah dengan pengumpulan sampah sangat jarang. <br><br>  PS: Saya penulis artikel ini, kamu bisa bertanya. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id417215/">https://habr.com/ru/post/id417215/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id417201/index.html">Alexey Zinoviev tentang BigData + ML di jug.msk.ru</a></li>
<li><a href="../id417203/index.html">Pecahkan tumpukan di STM8</a></li>
<li><a href="../id417207/index.html">Latar Belakang: Kereta peluru Hyperloop</a></li>
<li><a href="../id417209/index.html">Jaringan saraf dari awal. Ikhtisar kursus dan artikel dalam bahasa Rusia, gratis dan tanpa registrasi</a></li>
<li><a href="../id417211/index.html">Tabel untuk mempelajari dasar-dasar rangkaian listrik. Kenapa tidak</a></li>
<li><a href="../id417219/index.html">Lupakan Burger King! Ada bocoran dokumen yang jauh lebih berbahaya</a></li>
<li><a href="../id417221/index.html">3DTouch - Timbangan pada iPhone: Memulai</a></li>
<li><a href="../id417223/index.html">Jaringan Saraf Kapsul</a></li>
<li><a href="../id417225/index.html">Teorema Boshernitsan</a></li>
<li><a href="../id417227/index.html">Apa yang terjadi pada paradoks Fermi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>