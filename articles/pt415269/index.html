<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üõ∞Ô∏è ‚úäüèª üë®üèΩ‚Äç‚öñÔ∏è Como o JS funciona: √Årvores de sintaxe abstratas, an√°lise e sua otimiza√ß√£o ü•£ ‚úäüèæ üå¥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="[Leitura recomendada] As outras 19 partes do ciclo  Parte 1: Vis√£o geral do mecanismo, mecanismos de tempo de execu√ß√£o, pilha de chamadas 
 Parte 2: S...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Como o JS funciona: √Årvores de sintaxe abstratas, an√°lise e sua otimiza√ß√£o</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/415269/"><div class="spoiler">  <b class="spoiler_title">[Leitura recomendada] As outras 19 partes do ciclo</b> <div class="spoiler_text">  Parte 1: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Vis√£o geral do mecanismo, mecanismos de tempo de execu√ß√£o, pilha de chamadas</a> <br>  Parte 2: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Sobre os internos da V8 e otimiza√ß√£o de c√≥digo</a> <br>  Parte 3: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Gerenciando a mem√≥ria, quatro tipos de vazamentos de mem√≥ria e lidando com eles</a> <br>  Parte 4: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Loop de eventos, ass√≠ncrono e cinco maneiras de melhorar seu c√≥digo com async / waitit</a> <br>  Parte 5: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">WebSocket e HTTP / 2 + SSE.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O que escolher?</a> <br>  Parte 6: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Recursos e escopo do WebAssembly</a> <br>  Parte 7: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Trabalhadores da Web e cinco cen√°rios de uso</a> <br>  Parte 8: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Trabalhadores de Servi√ßo</a> <br>  Parte 9: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Notifica√ß√µes por push da Web</a> <br>  Parte 10: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">rastrear altera√ß√µes no DOM com MutationObserver</a> <br>  Parte 11: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mecanismos de renderiza√ß√£o de p√°ginas da Web e dicas para otimizar seu desempenho</a> <br>  Parte 12: O <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">subsistema de rede dos navegadores, otimizando seu desempenho e seguran√ßa</a> <br>  Parte 12: O <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">subsistema de rede dos navegadores, otimizando seu desempenho e seguran√ßa</a> <br>  Parte 13: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Anima√ß√£o com CSS e JavaScript</a> <br>  Parte 14: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Como o JS funciona: √Årvores de sintaxe abstratas, an√°lise e sua otimiza√ß√£o</a> <br>  Parte 15: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Como o JS funciona: classes e heran√ßa, transpila√ß√£o em Babel e TypeScript</a> <br>  Parte 16: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Como o JS funciona: armazenamento</a> <br>  Parte 17: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Como o JS funciona: Tecnologia Shadow DOM e componentes da Web</a> <br>  Parte 18: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Como o JS funciona: mecanismos de comunica√ß√£o WebRTC e P2P</a> <br>  Parte 19: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Como o JS funciona: elementos personalizados</a> </div></div><br>  Todos sabemos que o c√≥digo JavaScript para projetos da Web pode crescer em um tamanho enorme.  E quanto maior o c√≥digo, mais o navegador o carregar√°.  Mas o problema aqui n√£o √© apenas no momento da transmiss√£o de dados pela rede.  Ap√≥s o carregamento do programa, ele ainda precisa ser analisado, compilado no bytecode e finalmente executado.  Hoje, chamamos a aten√ß√£o para a tradu√ß√£o da parte 14 da s√©rie de ecossistemas JavaScript.  Nomeadamente, falaremos sobre a an√°lise do c√≥digo JS, como as √°rvores de sintaxe abstrata s√£o constru√≠das e como um programador pode influenciar esses processos, obtendo um aumento na velocidade de seus aplicativos. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/68b/b2c/231/68bb2c231dd5b82bd35e97ceb36becef.jpg" alt="imagem"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Como est√£o as linguagens de programa√ß√£o</font> </h2><br>  Antes de falar sobre √°rvores de sintaxe abstrata, vamos nos concentrar em como as linguagens de programa√ß√£o funcionam.  Independentemente de qual idioma voc√™ usa, voc√™ sempre precisa usar certos programas que pegam o c√≥digo-fonte e o convertem em algo que cont√©m comandos espec√≠ficos para as m√°quinas.  Int√©rpretes ou compiladores agem como tais programas.  N√£o importa se voc√™ escreve em uma linguagem interpretada (JavaScript, Python, Ruby) ou compilada (C #, Java, Rust), seu c√≥digo, que √© texto sem formata√ß√£o, sempre passar√° pelo est√°gio de an√°lise, ou seja, transformar texto sem formata√ß√£o em uma estrutura de dados chamado de √°rvore de sintaxe abstrata (AST). <br><br>  As √°rvores de sintaxe abstrata n√£o apenas fornecem uma representa√ß√£o estruturada do c√≥digo-fonte, mas tamb√©m desempenham um papel crucial na an√°lise sem√¢ntica, durante a qual o compilador verifica a corre√ß√£o das constru√ß√µes de software e o uso correto de seus elementos.  Ap√≥s formar o AST e executar verifica√ß√µes, essa estrutura √© usada para gerar c√≥digo de c√≥digo ou m√°quina. <br><br><h2>  <font color="#3AC1EF">Usando √°rvores de sintaxe abstrata</font> </h2><br>  √Årvores de sintaxe abstratas s√£o usadas n√£o apenas em int√©rpretes e compiladores.  Eles, no mundo dos computadores, s√£o √∫teis em muitas outras √°reas.  Uma das aplica√ß√µes mais comuns √© a an√°lise de c√≥digo est√°tico.  Os analisadores est√°ticos n√£o executam o c√≥digo passado para eles.  No entanto, apesar disso, eles precisam entender a estrutura dos programas. <br><br>  Suponha que voc√™ deseje desenvolver uma ferramenta que encontre estruturas que ocorrem com frequ√™ncia no seu c√≥digo.  Os relat√≥rios dessa ferramenta ajudar√£o na refatora√ß√£o e reduzir√£o a duplica√ß√£o de c√≥digo.  Isso pode ser feito usando a compara√ß√£o usual de cadeias, mas essa abordagem ser√° muito primitiva, seus recursos ser√£o limitados.  De fato, se voc√™ deseja criar uma ferramenta semelhante, n√£o precisa escrever seu pr√≥prio analisador para JavaScript.  Existem muitas implementa√ß√µes de c√≥digo aberto desses programas que s√£o totalmente compat√≠veis com a especifica√ß√£o ECMAScript.  Por exemplo - Esprima e Acorn.  Tamb√©m existem ferramentas que podem ajudar no trabalho com o que os analisadores geram, ou seja, no trabalho com √°rvores de sintaxe abstratas. <br><br>  Al√©m disso, as √°rvores de sintaxe abstrata s√£o amplamente utilizadas no desenvolvimento de transpilers.  Suponha que voc√™ decida desenvolver um transpiler que converta o c√≥digo Python em c√≥digo JavaScript.  Um projeto semelhante pode ser baseado na ideia de que um transpiler √© usado para criar uma √°rvore de sintaxe abstrata baseada no c√≥digo Python, que, por sua vez, √© convertido em c√≥digo JavaScript.  Provavelmente aqui voc√™ se perguntar√° como isso √© poss√≠vel.  O problema √© que as √°rvores de sintaxe abstrata s√£o apenas uma maneira alternativa de representar c√≥digo em alguma linguagem de programa√ß√£o.  Antes de o c√≥digo ser convertido para AST, ele se parece com texto comum, quando escrito, que segue certas regras que formam o idioma.  Ap√≥s a an√°lise, esse c√≥digo se transforma em uma estrutura em √°rvore que cont√©m as mesmas informa√ß√µes que o c√≥digo-fonte do programa.  Como resultado, √© poss√≠vel realizar n√£o apenas a transi√ß√£o do c√≥digo fonte para o AST, mas tamb√©m a transforma√ß√£o inversa, transformando a √°rvore da sintaxe abstrata em uma representa√ß√£o de texto do c√≥digo do programa. <br><br><h2>  <font color="#3AC1EF">Analisando JavaScript</font> </h2><br>  Vamos falar sobre como as √°rvores de sintaxe abstrata s√£o constru√≠das.  Como exemplo, considere uma fun√ß√£o JavaScript simples: <br><br><pre><code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function"> </span></span>{    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &gt; <span class="hljs-number"><span class="hljs-number">10</span></span>) {        <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-number"><span class="hljs-number">2</span></span>;        <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a * x;    }    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + <span class="hljs-number"><span class="hljs-number">10</span></span>; }</code> </pre> <br>  O analisador criar√° uma √°rvore de sintaxe abstrata, representada esquematicamente na figura a seguir. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/631/4f0/bc1/6314f0bc14439c74d13d0aa21f2e63c7.png"></div><br>  <i><font color="#999999">√Årvore de sintaxe abstrata</font></i> <br><br>  Observe que esta √© uma representa√ß√£o simplificada dos resultados do analisador.  Uma verdadeira √°rvore de sintaxe abstrata parece muito mais complicada.  Nesse caso, nosso principal objetivo √© ter uma id√©ia do que, em primeiro lugar, o c√≥digo fonte se transforma antes de ser executado.  Se voc√™ estiver interessado em ver como √© uma √°rvore de sintaxe abstrata real, use o site do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">AST Explorer</a> .  Para gerar um AST para um determinado fragmento de c√≥digo JS, basta coloc√°-lo no campo correspondente da p√°gina. <br><br>  Talvez aqui voc√™ tenha uma pergunta sobre por que o programador precisa saber como o analisador JS funciona.  No final, analisar e executar o c√≥digo √© uma tarefa do navegador.  De certa forma, voc√™ est√° certo.  A figura abaixo mostra o tempo necess√°rio para que alguns projetos da web conhecidos executem v√°rias etapas no processo de execu√ß√£o do c√≥digo JS. <br><br>  D√™ uma olhada neste desenho, talvez voc√™ veja algo interessante l√°. <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/5c5/448/f14/5c5448f14dc1ec31ed7b2e89bb5a48a4.png"></a> </div><br>  <i><font color="#999999">Tempo gasto na execu√ß√£o do c√≥digo JS</font></i> <br><br>  Est√° vendo?  Caso contr√°rio, olhe novamente.  Na verdade, estamos falando do fato de que, em m√©dia, os navegadores passam de 15 a 20% do tempo analisando o c√≥digo JS.  E isso n√£o √© alguns dados condicionais.  Aqui est√£o informa√ß√µes estat√≠sticas sobre o trabalho de projetos reais da Web que usam JavaScript de uma maneira ou de outra.  Talvez o n√∫mero de 15% possa n√£o parecer t√£o grande para voc√™, mas acredite, isso √© muito.  Um aplicativo t√≠pico de uma p√°gina carrega aproximadamente 0,4 MB de c√≥digo JavaScript e o navegador precisa de aproximadamente 370 ms para analisar esse c√≥digo.  Mais uma vez, voc√™ pode dizer que n√£o h√° com o que se preocupar.  E sim, isso por si s√≥ n√£o √© muito.  No entanto, n√£o esque√ßa que este √© apenas o tempo necess√°rio para analisar o c√≥digo e transform√°-lo em um AST.  Isso n√£o inclui o tempo necess√°rio para executar o c√≥digo ou o tempo necess√°rio para resolver outras tarefas que acompanham o carregamento da p√°gina, por exemplo, as tarefas de processamento de HTML e CSS e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">renderiza√ß√£o da p√°gina</a> .  Al√©m disso, estamos falando apenas de navegadores de desktop.  No caso de sistemas m√≥veis ainda √© pior.  Em particular, o tempo de an√°lise para o mesmo c√≥digo em dispositivos m√≥veis pode ser 2-5 vezes maior que no computador.  Veja a figura a seguir. <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/8ba/4e0/530/8ba4e0530a7420a96458b00963587380.jpg"></a> </div><br>  <i><font color="#999999">Tempo de an√°lise de 1 MB de c√≥digo JS em v√°rios dispositivos</font></i> <br><br>  Aqui est√° o tempo necess√°rio para analisar 1 MB de c√≥digo JS em v√°rios dispositivos m√≥veis e de desktop. <br><br>  Al√©m disso, os aplicativos da Web est√£o constantemente se tornando mais complexos e cada vez mais tarefas est√£o sendo transferidas para o lado do cliente.  Tudo isso visa melhorar a experi√™ncia do usu√°rio de trabalhar com sites, a fim de aproximar esses sentimentos daqueles que os usu√°rios experimentam ao interagir com aplicativos tradicionais.  √â f√°cil descobrir o quanto isso afeta os projetos da web.  Para fazer isso, basta abrir as ferramentas do desenvolvedor no navegador, acessar um site moderno e ver quanto tempo √© gasto na an√°lise do c√≥digo, compila√ß√£o e tudo o mais que acontece no navegador ao preparar a p√°gina para o trabalho. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/469/77c/26b/46977c26b690fe60b485f732f43afba8.jpg"></div><br>  <i><font color="#999999">An√°lise de site usando ferramentas de desenvolvedor em um navegador</font></i> <br><br>  Infelizmente, os navegadores m√≥veis n√£o possuem essas ferramentas.  No entanto, isso n√£o significa que as vers√µes m√≥veis dos sites n√£o possam ser analisadas.  Aqui ferramentas como o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">DeviceTiming</a> vir√£o em nosso aux√≠lio.  Com o DeviceTiming, voc√™ pode medir o tempo necess√°rio para analisar e executar scripts em ambientes gerenciados.  Isso funciona gra√ßas √† coloca√ß√£o de scripts locais no ambiente formado pelo c√≥digo auxiliar, o que leva ao fato de que toda vez que a p√°gina √© carregada de v√°rios dispositivos, temos a oportunidade de medir localmente o tempo de an√°lise e execu√ß√£o do c√≥digo. <br><br><h2>  <font color="#3AC1EF">Analisando otimiza√ß√£o e mecanismos JS</font> </h2><br>  Os mecanismos JS fazem muitas coisas √∫teis para evitar trabalho desnecess√°rio e otimizar os processos de processamento de c√≥digo.  Aqui est√£o alguns exemplos. <br><br>  O mecanismo V8 suporta scripts de streaming e cache de c√≥digo.  Nesse caso, streaming significa que o sistema analisa scripts carregados de forma ass√≠ncrona e scripts atrasados ‚Äã‚Äãem um encadeamento separado, come√ßando a fazer isso a partir do momento em que o c√≥digo come√ßa a ser carregado.  Isso leva ao fato de que a an√°lise termina quase simultaneamente com a conclus√£o do carregamento do script, o que reduz em cerca de 10% o tempo necess√°rio para preparar as p√°ginas para o trabalho. <br><br>  O c√≥digo JavaScript geralmente √© compilado no c√≥digo de bytes toda vez que uma p√°gina √© visitada.  Esse bytecode, no entanto, √© perdido depois que o usu√°rio navega para outra p√°gina.  Isso se deve ao fato de o c√≥digo compilado ser altamente dependente do estado e do contexto do sistema no momento da compila√ß√£o.  Para melhorar a situa√ß√£o, o Chrome 42 introduziu o suporte ao cache de bytecode.  Gra√ßas a essa inova√ß√£o, o c√≥digo compilado √© armazenado localmente; como resultado, quando o usu√°rio retorna √† p√°gina que j√° foi visitada, n√£o h√° necessidade de baixar, analisar e compilar scripts para prepar√°-lo para o trabalho.  Isso economiza o Chrome cerca de 40% do tempo analisando e compilando.  Al√©m disso, no caso de dispositivos m√≥veis, isso economiza energia da bateria. <br><br>  O mecanismo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Carakan</a> , que foi usado no navegador Opera e foi substitu√≠do pelo V8 por um longo tempo, poderia reutilizar os resultados da compila√ß√£o de scripts j√° processados.  N√£o era necess√°rio que esses scripts fossem conectados √† mesma p√°gina ou mesmo carregados do mesmo dom√≠nio.  Essa t√©cnica de armazenamento em cache, de fato, √© muito eficaz e permite que voc√™ abandone completamente a etapa de compila√ß√£o.  Ela se baseia em cen√°rios t√≠picos de comportamento do usu√°rio, em como as pessoas trabalham com recursos da Web.  Ou seja, quando o usu√°rio segue uma determinada sequ√™ncia de a√ß√µes, enquanto trabalha com um aplicativo Web, o mesmo c√≥digo √© carregado. <br><br>  O int√©rprete <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SpiderMonkey</a> usado pelo FireFox n√£o armazena em cache tudo em uma linha.  Ele suporta um sistema de monitoramento que conta o n√∫mero de chamadas para um script espec√≠fico.  Com base nesses indicadores, s√£o determinadas se√ß√µes do c√≥digo que precisam de otimiza√ß√£o, ou seja, aquelas com carga m√°xima. <br><br>  Obviamente, alguns desenvolvedores de navegadores podem decidir que seus produtos n√£o precisam ser armazenados em cache.  Portanto, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Masei Stachovyak</a> , desenvolvedor l√≠der do navegador Safari, diz que o Safari n√£o est√° envolvido no cache do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">c√≥digo de c√≥digo</a> compilado.  A possibilidade de armazenamento em cache foi considerada, mas ainda n√£o foi implementada, pois a gera√ß√£o de c√≥digo leva menos de 2% do tempo total de execu√ß√£o do programa. <br><br>  Essas otimiza√ß√µes n√£o afetam diretamente a an√°lise do c√≥digo-fonte em JS.  No curso de sua aplica√ß√£o, tudo √© feito para, em certos casos, pular completamente esta etapa.  N√£o importa a rapidez da an√°lise, ainda leva algum tempo, e a completa aus√™ncia de an√°lise talvez seja o exemplo de otimiza√ß√£o perfeita. <br><br><h2>  <font color="#3AC1EF">Reduza o tempo de prepara√ß√£o de aplicativos da web</font> </h2><br>  Como descobrimos acima, seria bom minimizar a necessidade de scripts de an√°lise, mas voc√™ n√£o pode se livrar completamente dele, ent√£o vamos falar sobre como reduzir o tempo necess√°rio para preparar aplicativos da Web para o trabalho.  De fato, muito pode ser feito para isso.  Por exemplo, voc√™ pode minimizar a quantidade de c√≥digo JS inclu√≠do no aplicativo.  Um pequeno c√≥digo que prepara uma p√°gina para o trabalho pode ser analisado mais rapidamente e provavelmente levar√° menos tempo para ser executado do que um c√≥digo mais volumoso. <br><br>  Para reduzir a quantidade de c√≥digo, voc√™ pode organizar o carregamento na p√°gina apenas do que ele realmente precisa, e n√£o um peda√ßo enorme de c√≥digo, que inclui absolutamente tudo o que √© necess√°rio para o projeto da web como um todo.  Assim, por exemplo, o padr√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">PRPL</a> promove exatamente essa abordagem para carregar c√≥digo.  Como alternativa, voc√™ pode verificar as depend√™ncias e verificar se h√° algo redundante nelas, de modo que isso leve apenas a um crescimento injustificado da base de c√≥digo.  De fato, aqui abordamos um grande t√≥pico digno de um material separado.  Voltar para a an√°lise. <br><br>  Portanto, o objetivo deste material √© discutir t√©cnicas que permitem que um desenvolvedor da Web ajude um analisador a realizar seu trabalho mais rapidamente.  Tais t√©cnicas existem.  Os analisadores JS modernos usam algoritmos heur√≠sticos para determinar se ser√° necess√°rio executar um determinado peda√ßo de c√≥digo o mais r√°pido poss√≠vel ou se ser√° necess√°rio execut√°-lo posteriormente.  Com base nessas previs√µes, o analisador analisa completamente o fragmento de c√≥digo usando o algoritmo de an√°lise ansioso ou usa o algoritmo de an√°lise lenta.  Com uma an√°lise completa, voc√™ entende as fun√ß√µes que precisa compilar o mais r√°pido poss√≠vel.  Durante esse processo, tr√™s tarefas principais s√£o resolvidas: criar um AST, criar uma hierarquia de √°reas de visibilidade e localizar erros de sintaxe.  A an√°lise pregui√ßosa, por outro lado, √© usada apenas para fun√ß√µes que ainda n√£o precisam ser compiladas.  Isso n√£o cria um AST e n√£o procura erros.  Com essa abordagem, apenas uma hierarquia de √°reas de visibilidade √© criada, o que economiza cerca de metade do tempo em compara√ß√£o com as fun√ß√µes de processamento que precisam ser executadas o mais r√°pido poss√≠vel. <br><br>  De fato, o conceito n√£o √© novo.  At√© navegadores desatualizados como o IE9 suportam essas abordagens de otimiza√ß√£o, embora, √© claro, os sistemas modernos tenham ido muito √† frente. <br><br>  Vamos examinar um exemplo que ilustra a opera√ß√£o desses mecanismos.  Suponha que tenhamos o seguinte c√≥digo JS: <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span></span> {       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + <span class="hljs-number"><span class="hljs-number">10</span></span>;   }   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">baz</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y)</span></span></span></span> {       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + y;   }   console.log(baz(<span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">200</span></span>)); }</code> </pre> <br>  Como no exemplo anterior, o c√≥digo cai no analisador, que executa sua an√°lise e forma o AST.  Como resultado, o analisador representa um c√≥digo que consiste nas seguintes partes principais (n√£o prestaremos aten√ß√£o √† fun√ß√£o <code>foo</code> ): <br><br><ul><li>  Declarando uma fun√ß√£o de <code>bar</code> que recebe um argumento ( <code>x</code> ).  Esta fun√ß√£o possui um comando de retorno, retorna o resultado da adi√ß√£o de <code>x</code> e 10. </li><li>  Declarando uma fun√ß√£o <code>baz</code> que recebe dois argumentos ( <code>x</code> e <code>y</code> ).  Ela tamb√©m tem um comando de retorno, ela retorna o resultado da adi√ß√£o de <code>y</code> . </li><li>  Fazer uma chamada para a fun√ß√£o <code>baz</code> com dois argumentos - 100 e 200. </li><li>  Fazer uma chamada para a fun√ß√£o <code>console.log</code> com um argumento, que √© o valor retornado pela fun√ß√£o chamada anteriormente. </li></ul><br>  Aqui est√° como fica. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6df/ba5/f7b/6dfba5f7b7e40d5067424ada6a1c9855.png"></div><br>  <i><font color="#999999">O resultado da an√°lise do c√≥digo de amostra sem aplicar a otimiza√ß√£o</font></i> <br><br>  Vamos falar sobre o que est√° acontecendo aqui.  O analisador v√™ a declara√ß√£o da fun√ß√£o <code>bar</code> , a declara√ß√£o da fun√ß√£o <code>baz</code> , a chamada para a fun√ß√£o <code>baz</code> e a chamada para a fun√ß√£o <code>console.log</code> .  Obviamente, analisando esse trecho de c√≥digo, o analisador encontrar√° uma tarefa cuja execu√ß√£o n√£o afetar√° os resultados deste programa.  √â sobre analisar a <code>bar</code> fun√ß√µes.  Por que a an√°lise dessa fun√ß√£o n√£o √© pr√°tica?  O fato √© que a fun√ß√£o <code>bar</code> , pelo menos no fragmento de c√≥digo apresentado, nunca √© chamada.  Este exemplo simples pode parecer absurdo, mas muitos aplicativos reais t√™m um grande n√∫mero de fun√ß√µes que nunca s√£o chamadas. <br><br>  Em tal situa√ß√£o, em vez de analisar a fun√ß√£o da <code>bar</code> , podemos simplesmente registrar que ela √© declarada, mas n√£o √© usada em nenhum lugar.  Ao mesmo tempo, a an√°lise real dessa fun√ß√£o √© feita quando se torna necess√°ria, imediatamente antes de sua execu√ß√£o.  Naturalmente, ao executar uma an√°lise lenta, voc√™ precisa detectar o corpo da fun√ß√£o e fazer um registro de sua declara√ß√£o, mas √© a√≠ que o trabalho termina.  Para essa fun√ß√£o, n√£o √© necess√°rio formar uma √°rvore de sintaxe abstrata, pois o sistema n√£o possui informa√ß√µes de que essa fun√ß√£o est√° planejada para ser executada.  Al√©m disso, a mem√≥ria heap n√£o √© alocada, o que geralmente requer recursos consider√°veis ‚Äã‚Äãdo sistema.  Em poucas palavras, a recusa em analisar fun√ß√µes desnecess√°rias leva a um aumento significativo no desempenho do c√≥digo. <br><br>  Como resultado, no exemplo anterior, o analisador real formar√° uma estrutura semelhante ao esquema a seguir. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3bb/202/a4d/3bb202a4de7b21c31cff3648403096ac.png"></div><br>  <i><font color="#999999">Resultado da an√°lise de c√≥digo de exemplo com otimiza√ß√£o</font></i> <br><br>  Observe que o analisador fez uma anota√ß√£o sobre a declara√ß√£o da <code>bar</code> fun√ß√µes, mas n√£o lidou com sua an√°lise adicional.  O sistema n√£o fez nenhum esfor√ßo para analisar o c√≥digo da fun√ß√£o.  Nesse caso, o corpo da fun√ß√£o era um comando para retornar o resultado de c√°lculos simples.  No entanto, na maioria dos aplicativos do mundo real, o c√≥digo de fun√ß√£o pode ser muito mais longo e mais complexo, contendo muitos comandos de retorno, condi√ß√µes, loops, comandos de declara√ß√£o vari√°vel e fun√ß√µes aninhadas.  Analisar tudo isso, desde que essas fun√ß√µes nunca sejam chamadas, √© uma perda de tempo. <br><br>  N√£o h√° nada complicado no conceito descrito acima, mas sua implementa√ß√£o pr√°tica n√£o √© uma tarefa f√°cil.  Aqui examinamos um exemplo muito simples e, de fato, ao decidir se um determinado peda√ßo de c√≥digo ser√° procurado em um programa, √© necess√°rio analisar fun√ß√µes, loops, operadores condicionais e objetos.  Em geral, podemos dizer que o analisador precisa processar e analisar absolutamente tudo o que est√° no programa. <br><br>  Aqui, por exemplo, √© um padr√£o muito comum para implementar m√≥dulos em JavaScript: <br><br><pre> <code class="hljs actionscript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myModule = (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{   <span class="hljs-comment"><span class="hljs-comment">//      //    })();</span></span></code> </pre> <br>  A maioria dos analisadores JS modernos reconhece esse padr√£o; para eles, √© um sinal de que o c√≥digo localizado dentro do m√≥dulo precisa ser totalmente analisado. <br><br>  Mas e se os analisadores sempre usassem a an√°lise lenta?  Infelizmente, isso n√£o √© uma boa ideia.  O fato √© que, com essa abordagem, se algum c√≥digo precisar ser executado o mais r√°pido poss√≠vel, encontraremos uma desacelera√ß√£o no sistema.  O analisador executar√° um passo de an√°lise lenta, ap√≥s o qual come√ßar√° imediatamente a analisar completamente o que precisa ser feito o mais r√°pido poss√≠vel.  Isso levar√° a uma desacelera√ß√£o de cerca de 50% em compara√ß√£o com a abordagem quando o analisador come√ßar imediatamente a analisar completamente o c√≥digo mais importante. <br><br><h2>  <font color="#3AC1EF">Otimiza√ß√£o de c√≥digo, levando em considera√ß√£o os recursos de sua an√°lise</font> </h2><br>  Agora que descobrimos um pouco sobre o que est√° acontecendo dentro dos analisadores, √© hora de pensar no que pode ser feito para ajud√°-los.  Podemos escrever c√≥digo para que a an√°lise das fun√ß√µes seja realizada no momento em que precisamos.  H√° um padr√£o que a maioria dos analisadores entende.  √â expresso no fato de que as fun√ß√µes est√£o entre colchetes.  Esse design quase sempre informa ao analisador que a fun√ß√£o precisa ser desmontada imediatamente.  Se o analisador detectar um colchete de abertura, imediatamente ap√≥s o qual a declara√ß√£o da fun√ß√£o segue, come√ßar√° imediatamente a analisar a fun√ß√£o.  Podemos ajudar o analisador aplicando esta t√©cnica ao descrever fun√ß√µes que precisam ser executadas o mais r√°pido poss√≠vel. <br><br>  Suponha que tenhamos uma fun√ß√£o <code>foo</code> : <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x * <span class="hljs-number"><span class="hljs-number">10</span></span>; }</code> </pre> <br>  Como n√£o h√° indica√ß√£o expl√≠cita nesse fragmento de c√≥digo de que esta fun√ß√£o est√° programada para ser executada imediatamente, o navegador executar√° apenas sua an√°lise lenta.  No entanto, estamos confiantes de que precisaremos dessa fun√ß√£o muito em breve, para que possamos recorrer ao pr√≥ximo truque. <br><br>  Primeiro, salve a fun√ß√£o em uma vari√°vel: <br><br><pre> <code class="hljs actionscript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> foo = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x * <span class="hljs-number"><span class="hljs-number">10</span></span>; };</code> </pre> <br>  Observe que deixamos o nome da fun√ß√£o inicial entre a palavra-chave da <code>function</code> e o colchete de abertura.  N√£o se pode dizer que isso √© absolutamente necess√°rio, mas √© recomend√°vel fazer exatamente isso, porque se uma exce√ß√£o for lan√ßada quando a fun√ß√£o estiver em execu√ß√£o, voc√™ poder√° ver o nome da fun√ß√£o nos dados de rastreamento da pilha, e n√£o <code>&lt;anonymous&gt;</code> . <br><br>  Ap√≥s a altera√ß√£o acima, o analisador continuar√° usando a an√°lise lenta.  Para mudar isso, basta um pequeno detalhe.  A fun√ß√£o deve estar entre colchetes: <br><br><pre> <code class="hljs actionscript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> foo = (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x * <span class="hljs-number"><span class="hljs-number">10</span></span>; });</code> </pre> <br>  Agora, quando o analisador encontrar um colchete de abertura na frente da palavra-chave <code>function</code> , ele come√ßar√° imediatamente a analisar essa fun√ß√£o. <br><br>  Pode n√£o ser f√°cil executar essas otimiza√ß√µes manualmente, pois para isso √© necess√°rio saber em quais casos o analisador executar√° a an√°lise lenta e em qual a completa.  Al√©m disso, para fazer isso, voc√™ precisa dedicar um tempo para decidir se uma fun√ß√£o espec√≠fica precisa estar pronta para o trabalho o mais r√°pido poss√≠vel ou n√£o. <br><br>  Os programadores, com certeza, n√£o v√£o querer arcar com todo esse trabalho adicional.  Al√©m disso, o que n√£o √© menos importante do que tudo o que j√° foi dito, o c√≥digo processado dessa maneira ser√° mais dif√≠cil de ler e entender.  Nessa situa√ß√£o, pacotes de software especiais como o Optimize.js est√£o prontos para nos ajudar.  Seu principal objetivo √© otimizar o tempo de inicializa√ß√£o inicial do c√≥digo-fonte JS.  Eles executam a an√°lise est√°tica do c√≥digo e a modificam para que as fun√ß√µes que precisam ser executadas o mais r√°pido poss√≠vel sejam colocadas entre colchetes, o que leva ao fato de que o navegador as analisa imediatamente e as prepara para execu√ß√£o. <br><br>  Portanto, suponha que programamos, sem realmente pensar em nada, e temos o seguinte fragmento de c√≥digo: <br><br><pre> <code class="hljs matlab">(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> {   </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">console</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">('Hello, World!')</span></span></span><span class="hljs-function">; })</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">;</span></span></code> </pre> <br>  Parece normal, funciona como esperado, √© executado rapidamente, pois o analisador encontra o colchete de abertura na frente da palavra-chave <code>function</code> .  At√© agora tudo bem. ,       ,     ,    : <br><br><pre> <code class="hljs matlab">!<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">{</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">console</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">('Hello, World!')</span></span></span><span class="hljs-function">}</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">;</span></span></code> </pre> <br>     ,    ,   .   ,   -        . <br><br>   ,      ,      .  ,     , ,         .  ,  ,    ,        .     ,        ,    .         Optimize.js.       Optimize.js,    : <br><br><pre> <code class="hljs matlab">!(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">{</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">console</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">('Hello, World!')</span></span></span><span class="hljs-function">})</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">;</span></span></code> </pre> <br>      ,   .    ,   .       ,   ,         ,   ‚Äî     . <br><br><h2> <font color="#3AC1EF"> </font> </h2><br>  ,  JS-   ‚Äî ,    .        ?   ,           ,  , ,          .   ,    ,  ,    ,    JS-      ,          .  ,    ,       ,   -,        .       -  .       ,   ,    .          ,     , , ,              .  , JS-     ,  ,   V8     ,   ,     .                 . <br><br><h2> <font color="#3AC1EF">  </font> </h2><br>   ,       -: <br><br><ul><li>   .    . </li><li>       ,       . </li><li> ,   ,   ,  JS-.          ,     ,   . </li><li>       DeviceTiming  ,      . </li><li>    Optimize.js  ,      ,         . </li></ul><br><h2>  <font color="#3AC1EF">Sum√°rio</font> </h2><br>    ,    ,     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SessionStack</a> ,      ,    -,       .     ,         .     ‚Äî       . ,     ‚Äî    ,      -,  ,       ,       . <br><br>  <b>Caros leitores!</b>     -        JavaScript-? <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt415269/">https://habr.com/ru/post/pt415269/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt415257/index.html">8 maneiras de melhorar a visualiza√ß√£o de dados</a></li>
<li><a href="../pt415259/index.html">select / poll / epoll: diferen√ßa pr√°tica</a></li>
<li><a href="../pt415261/index.html">Artista VFX em desenvolvimento de jogos: caracter√≠sticas, carreira, desenvolvimento</a></li>
<li><a href="../pt415263/index.html">Como adicionamos entradas ao mapa e reduzimos o tamanho das bases em 10%</a></li>
<li><a href="../pt415265/index.html">Procurando um sucessor para o KL-7: RACE e AROFLEX</a></li>
<li><a href="../pt415271/index.html">Como os gr√°ficos de Gantt simplificam o gerenciamento de projetos</a></li>
<li><a href="../pt415273/index.html">Aprendendo o b√°sico da programa√ß√£o</a></li>
<li><a href="../pt415275/index.html">O livro "C # 7 e .NET Core. Desenvolvimento multiplataforma para profissionais. 3¬™ edi√ß√£o</a></li>
<li><a href="../pt415277/index.html">Novidades do ARKit 2.0</a></li>
<li><a href="../pt415279/index.html">Por que martelar nas unhas com um microsc√≥pio se voc√™ possui o Alpine Linux?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>