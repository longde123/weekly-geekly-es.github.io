<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©‚Äçüë©‚Äçüëß‚Äçüëß üàÇÔ∏è üé∏ Node.js Entwicklertools Jobwarteschlange üî∂ üßóüèæ üèà</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bei der Implementierung der Sicherung von Webanwendungen und mobilen Anwendungen, auch der einfachsten, ist es √ºblich geworden, Tools wie Datenbanken,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Node.js Entwicklertools Jobwarteschlange</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/458608/"> Bei der Implementierung der Sicherung von Webanwendungen und mobilen Anwendungen, auch der einfachsten, ist es √ºblich geworden, Tools wie Datenbanken, Mail-Server (SMTP) und Redis-Server zu verwenden.  Der Werkzeugsatz wird st√§ndig erweitert.  Beispielsweise werden Nachrichtenwarteschlangen, gemessen an der Anzahl der Installationen des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">amqplib-</a> Pakets ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">650.000</a> Installationen pro Woche), zusammen mit relationalen Datenbanken verwendet ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MySQL-</a> Paket <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">460.000</a> Installationen pro Woche und S. 800.000 Installationen pro Woche). <br><br>  Heute m√∂chte ich √ºber Job-Warteschlangen sprechen, die bisher in fast allen realen Projekten um eine Gr√∂√üenordnung weniger genutzt werden, obwohl sie ben√∂tigt werden <br><a name="habracut"></a><br>  Mit Jobwarteschlangen k√∂nnen Sie also eine Aufgabe asynchron ausf√ºhren. Tats√§chlich k√∂nnen Sie eine Funktion mit den angegebenen Eingabeparametern und zur festgelegten Zeit ausf√ºhren. <br><br>  Abh√§ngig von den Parametern kann die Aufgabe ausgef√ºhrt werden: <br><br><ul><li>  unmittelbar nach dem Hinzuf√ºgen zur Jobwarteschlange; </li><li>  einmal zu einer festgelegten Zeit; </li><li>  viele Male im Zeitplan. </li></ul><br>  Mit Jobwarteschlangen k√∂nnen Sie Parameter an einen Job √ºbertragen, der ausgef√ºhrt wird, fehlgeschlagene Jobs verfolgen und erneut ausf√ºhren sowie die Anzahl der gleichzeitig ausgef√ºhrten Jobs begrenzen. <br><br>  Die √ºberwiegende Mehrheit der Anwendungen auf Node.js ist mit der Entwicklung einer REST-API f√ºr Web- und mobile Anwendungen verbunden.  Die Verk√ºrzung der Ausf√ºhrungszeit der REST-API ist wichtig f√ºr eine komfortable Arbeit des Benutzers mit der Anwendung.  Gleichzeitig kann ein Aufruf der REST-API langwierige und / oder ressourcenintensive Vorg√§nge ausl√∂sen.  Nach dem Kauf m√ºssen Sie dem Benutzer beispielsweise eine Push-Nachricht an die mobile Anwendung senden oder eine Anforderung zum Kauf √ºber die CRM REST-API senden.  Diese Abfragen k√∂nnen asynchron ausgef√ºhrt werden.  Wie mache ich es richtig, wenn Sie kein Tool zum Arbeiten mit Jobwarteschlangen haben?  Sie k√∂nnen beispielsweise eine Nachricht an die Nachrichtenwarteschlange senden, einen Mitarbeiter starten, der diese Nachrichten liest, und die erforderlichen Arbeiten basierend auf diesen Nachrichten ausf√ºhren. <br><br>  Genau das tun Jobwarteschlangen.  Wenn Sie genau hinschauen, unterscheiden sich die Jobwarteschlangen jedoch grundlegend von der Nachrichtenwarteschlange.  Erstens werden Nachrichten (statisch) in die Nachrichtenwarteschlange gestellt, und Jobwarteschlangen beinhalten irgendeine Art von Arbeit (Funktionsaufruf).  Zweitens impliziert die Jobwarteschlange das Vorhandensein eines Prozessors (Arbeiters), der die angegebene Arbeit ausf√ºhrt.  In diesem Fall wird zus√§tzliche Funktionalit√§t ben√∂tigt.  Die Anzahl der Prozessorprozessoren sollte bei erh√∂hter Auslastung transparent skaliert werden.  Andererseits ist es notwendig, die Anzahl der gleichzeitig ausgef√ºhrten Aufgaben auf einem Prozessor-Worker zu begrenzen, um Spitzenlasten auszugleichen und Denial-of-Service zu verhindern.  Dies zeigt, dass ein Tool erforderlich ist, das asynchrone Aufgaben durch Festlegen verschiedener Parameter ausf√ºhren kann, so einfach wie das Anfordern einer Anforderung mithilfe der REST-API (oder besser, wenn es noch einfacher ist). <br><br>  Mithilfe von Nachrichtenwarteschlangen ist es relativ einfach, eine Jobwarteschlange zu implementieren, die unmittelbar nach dem Einreihen eines Jobs ausgef√ºhrt wird.  Oft ist es jedoch erforderlich, die Aufgabe einmal zu einem festgelegten Zeitpunkt oder nach einem Zeitplan auszuf√ºhren.  F√ºr diese Aufgaben werden h√§ufig eine Reihe von Paketen verwendet, die die Cron-Logik unter Linux implementieren.  Um nicht unbegr√ºndet zu sein, werde ich sagen, dass das Node-Cron-Paket 480.000 Installationen pro Woche hat, Node-Schedule - 170.000 Installationen pro Woche. <br><br>  Die Verwendung von Node-Cron ist nat√ºrlich bequemer als das asketische setInterval (), aber ich pers√∂nlich habe bei der Verwendung eine Reihe von Problemen festgestellt.  Um einen allgemeinen Nachteil auszudr√ºcken, ist dies die mangelnde Kontrolle √ºber die Anzahl der gleichzeitig ausgef√ºhrten Aufgaben (dies stimuliert Spitzenlasten: Durch Erh√∂hen der Last wird die Arbeit der Aufgaben verlangsamt, durch Verlangsamen der Aufgaben wird die Anzahl der gleichzeitig ausgef√ºhrten Aufgaben erh√∂ht, was wiederum das System noch mehr belastet) und durch die Unf√§higkeit, Knoten auszuf√ºhren, um die Produktivit√§t zu steigern -cron auf mehreren Kernen (in diesem Fall werden alle Aufgaben unabh√§ngig auf jedem Kern ausgef√ºhrt) und das Fehlen von Tools zum Verfolgen und Neustarten abgeschlossener Aufgaben  Xia mit einem Fehler. <br><br>  Ich hoffe, dass ich gezeigt habe, dass der Bedarf an einem Tool wie der Jobwarteschlange mit Tools wie Datenbanken vergleichbar ist.  Und solche Mittel sind erschienen, obwohl sie noch nicht weit verbreitet sind.  Ich werde die beliebtesten auflisten: <br><br><div class="scrollable-table"><table><tbody><tr><th>  Paketname </th><th>  Anzahl der Installationen pro Woche </th><th>  Anzahl der Likes </th></tr><tr><td>  kue </td><td>  29190 </td><td>  8753 </td></tr><tr><td>  Bienenschlange </td><td>  keine Informationen </td><td>  1431 </td></tr><tr><td>  Tagesordnung </td><td>  25459 </td><td>  5488 </td></tr><tr><td>  Stier </td><td>  56232 </td><td>  5909 </td></tr></tbody></table></div><br><br>  Heute werde ich √ºber die Verwendung des Bullenpakets nachdenken, das ich mit mir selbst arbeite.  Warum habe ich dieses spezielle Paket gew√§hlt (obwohl ich meine Wahl nicht anderen auferlege)?  In diesem Moment, als ich nach einer bequemen Implementierung der Nachrichtenwarteschlange suchte, wurde das Bienenwarteschlangenprojekt bereits gestoppt.  Die kue-Implementierung blieb gem√§√ü den im Bienenwarteschlangen-Repository angegebenen Benchmarks weit hinter anderen Implementierungen zur√ºck und enthielt au√üerdem nicht die Mittel zum Ausf√ºhren periodisch ausgef√ºhrter Aufgaben.  Das Agenda-Projekt implementiert Warteschlangen mit Speicherung in der Mongodb-Datenbank.  Dies ist in einigen F√§llen ein gro√ües Plus, wenn Sie beim Platzieren von Aufgaben in der Warteschlange eine hohe Zuverl√§ssigkeit ben√∂tigen.  Dies ist jedoch nicht nur ein entscheidender Faktor.  Nat√ºrlich habe ich alle Ausdaueroptionen der Bibliothek getestet, eine gro√üe Anzahl von Aufgaben in der Warteschlange generiert und konnte trotzdem keine ununterbrochene Arbeit von der Tagesordnung streichen.  Bei √úberschreitung einer bestimmten Anzahl von Aufgaben wurde die Agenda angehalten und die Ausf√ºhrung von Aufgaben eingestellt. <br><br>  Aus diesem Grund habe ich mich f√ºr bull entschieden, das eine praktische API mit ausreichender Geschwindigkeit und Skalierbarkeit implementiert, da das bull-Paket einen Redis-Server als Backend verwendet.  Insbesondere k√∂nnen Sie einen Cluster von Redis-Servern verwenden. <br><br>  Beim Erstellen einer Warteschlange ist es sehr wichtig, die optimalen Parameter f√ºr die Jobwarteschlange auszuw√§hlen.  Es gibt viele Parameter, und der Wert einiger von ihnen hat mich nicht sofort erreicht.  Nach zahlreichen Experimenten habe ich mich auf folgende Parameter festgelegt: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Bull = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'bull'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> redis = { <span class="hljs-attr"><span class="hljs-attr">host</span></span>: <span class="hljs-string"><span class="hljs-string">'localhost'</span></span>, <span class="hljs-attr"><span class="hljs-attr">port</span></span>: <span class="hljs-number"><span class="hljs-number">6379</span></span>, <span class="hljs-attr"><span class="hljs-attr">maxRetriesPerRequest</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-attr"><span class="hljs-attr">connectTimeout</span></span>: <span class="hljs-number"><span class="hljs-number">180000</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> defaultJobOptions = { <span class="hljs-attr"><span class="hljs-attr">removeOnComplete</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">removeOnFail</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> limiter = { <span class="hljs-attr"><span class="hljs-attr">max</span></span>: <span class="hljs-number"><span class="hljs-number">10000</span></span>, <span class="hljs-attr"><span class="hljs-attr">duration</span></span>: <span class="hljs-number"><span class="hljs-number">1000</span></span>, <span class="hljs-attr"><span class="hljs-attr">bounceBack</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> settings = { <span class="hljs-attr"><span class="hljs-attr">lockDuration</span></span>: <span class="hljs-number"><span class="hljs-number">600000</span></span>, <span class="hljs-comment"><span class="hljs-comment">// Key expiration time for job locks. stalledInterval: 5000, // How often check for stalled jobs (use 0 for never checking). maxStalledCount: 2, // Max amount of times a stalled job will be re-processed. guardInterval: 5000, // Poll interval for delayed jobs and added jobs. retryProcessDelay: 30000, // delay before processing next job in case of internal error. drainDelay: 5, // A timeout for when the queue is in drained state (empty waiting for jobs). }; const bull = new Bull('my_queue', { redis, defaultJobOptions, settings, limiter }); module.exports = { bull };</span></span></code> </pre> <br>  In trivialen F√§llen m√ºssen nicht viele Warteschlangen erstellt werden, da Sie in jeder Warteschlange Namen f√ºr verschiedene Aufgaben angeben und jedem Namen einen Prozessorarbeiter zuordnen k√∂nnen: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { bull } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'../bull'</span></span>); bull.process(<span class="hljs-string"><span class="hljs-string">'push:news'</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${__dirname}</span></span></span><span class="hljs-string">/push-news.js`</span></span>); bull.process(<span class="hljs-string"><span class="hljs-string">'push:status'</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${__dirname}</span></span></span><span class="hljs-string">/push-status.js`</span></span>); ... bull.process(<span class="hljs-string"><span class="hljs-string">'some:job'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...args</span></span></span><span class="hljs-function">) </span></span>{ ... });</code> </pre><br>  Ich nutze die Gelegenheit, die der Bulle "out of the box" bietet - um Prozessorarbeiter auf mehreren Kernen zu parallelisieren.  Dazu legt der zweite Parameter die Anzahl der Kerne fest, auf denen der Prozessor-Worker gestartet wird, und im dritten Parameter den Dateinamen mit der Definition der Jobverarbeitungsfunktion.  Wenn eine solche Funktion nicht ben√∂tigt wird, k√∂nnen Sie einfach eine R√ºckruffunktion als zweiten Parameter √ºbergeben. <br><br>  Die Aufgabe wird durch einen Aufruf der add () -Methode in die Warteschlange gestellt, an die der Warteschlangenname und das Objekt in den Parametern √ºbergeben werden, die anschlie√üend an den Aufgabenhandler √ºbergeben werden.  In einem ORM-Hook kann ich beispielsweise nach dem Erstellen eines Eintrags mit neuen Nachrichten asynchron eine Push-Nachricht an alle Clients senden: <br><br><pre> <code class="javascript hljs"> afterCreate(instance) { bull.add(<span class="hljs-string"><span class="hljs-string">'push:news'</span></span>, _.pick(instance, <span class="hljs-string"><span class="hljs-string">'id'</span></span>, <span class="hljs-string"><span class="hljs-string">'title'</span></span>, <span class="hljs-string"><span class="hljs-string">'message'</span></span>), options); }</code> </pre><br>  Der Ereignishandler akzeptiert in den Parametern das Task-Objekt mit den an die add () -Methode und die done () -Funktion √ºbergebenen Parametern, die aufgerufen werden m√ºssen, um zu best√§tigen, dass die Task abgeschlossen ist, oder um zu informieren, dass die Task mit einem Fehler beendet wurde: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-attr"><span class="hljs-attr">firebase</span></span>: { admin } } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'../firebase'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { makePayload } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./makePayload'</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">job, done</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { id, title, message } = job.data; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> data = { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>(id), <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'news'</span></span>, }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> payloadRu = makePayload(title.ru, message.ru, data); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> payloadEn = makePayload(title.en, message.en, data); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all([ admin.messaging().send({ ...payloadRu, <span class="hljs-attr"><span class="hljs-attr">condition</span></span>: <span class="hljs-string"><span class="hljs-string">"'news' in topics &amp;&amp; 'ru' in topics"</span></span> }), admin.messaging().send({ ...payloadEn, <span class="hljs-attr"><span class="hljs-attr">condition</span></span>: <span class="hljs-string"><span class="hljs-string">"'news' in topics &amp;&amp; 'en' in topics"</span></span> }), ]) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response</span></span></span><span class="hljs-function"> =&gt;</span></span> done(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, response)) .catch(done); };</code> </pre><br>  Um den Status der Jobwarteschlange anzuzeigen, k√∂nnen Sie das Arena-Bull-Tool verwenden: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Arena = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'bull-arena'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> redis = { <span class="hljs-attr"><span class="hljs-attr">host</span></span>: <span class="hljs-string"><span class="hljs-string">'localhost'</span></span>, <span class="hljs-attr"><span class="hljs-attr">port</span></span>: <span class="hljs-number"><span class="hljs-number">6379</span></span>, <span class="hljs-attr"><span class="hljs-attr">maxRetriesPerRequest</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-attr"><span class="hljs-attr">connectTimeout</span></span>: <span class="hljs-number"><span class="hljs-number">180000</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arena = Arena({ <span class="hljs-attr"><span class="hljs-attr">queues</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'my_gueue'</span></span>, <span class="hljs-attr"><span class="hljs-attr">hostId</span></span>: <span class="hljs-string"><span class="hljs-string">'My Queue'</span></span>, redis, }, ], }, { <span class="hljs-attr"><span class="hljs-attr">basePath</span></span>: <span class="hljs-string"><span class="hljs-string">'/'</span></span>, <span class="hljs-attr"><span class="hljs-attr">disableListen</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, }); <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = { arena };</code> </pre><br>  Und zum Schluss noch ein kleiner Life-Hack.  Wie gesagt, bull verwendet einen Redis-Server als Backend.  Wenn der Redis-Server neu gestartet wird, ist die Wahrscheinlichkeit, dass der Job verschwindet, sehr gering.  Da ich jedoch wusste, dass Systemadministratoren manchmal nur den Rettich-Cache leeren k√∂nnen, w√§hrend sie insbesondere alle Aufgaben l√∂schen, war ich in erster Linie besorgt √ºber die regelm√§√üige Ausf√ºhrung von Aufgaben, die in diesem Fall f√ºr immer gestoppt wurden.  In dieser Hinsicht fand ich eine Gelegenheit, solche periodischen Aufgaben wieder aufzunehmen: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> cron = <span class="hljs-string"><span class="hljs-string">'*/10 * * * * *'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { bull } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./app/services/bull'</span></span>); bull.getRepeatableJobs() .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">jobs</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all(_.map(jobs, (job) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [name, cron] = job.key.split(<span class="hljs-regexp"><span class="hljs-regexp">/:{2,}/</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bull.removeRepeatable(name, { cron }); }))) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> bull.add(<span class="hljs-string"><span class="hljs-string">'check:status'</span></span>, {}, { <span class="hljs-attr"><span class="hljs-attr">priority</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">repeat</span></span>: { cron } })); setInterval(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> bull.add(<span class="hljs-string"><span class="hljs-string">'check:status'</span></span>, {}, { <span class="hljs-attr"><span class="hljs-attr">priority</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">repeat</span></span>: { cron } }), <span class="hljs-number"><span class="hljs-number">60000</span></span>);</code> </pre><br>  Das hei√üt, die Aufgabe wird zuerst aus der Warteschlange ausgeschlossen und dann erneut festgelegt, und dies alles (leider) durch setInterval ().  Ohne einen solchen Life-Hack h√§tte ich mich wahrscheinlich nicht entschieden, regelm√§√üige Aufgaben f√ºr Bullen zu verwenden. <br><br>  apapacy@gmail.com <br>  3. Juli 2019 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de458608/">https://habr.com/ru/post/de458608/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de458596/index.html">Kleine Freude # 6: OpenAI Gym - Spiele spielen und Roboter steuern</a></li>
<li><a href="../de458600/index.html">Was sind Elektrofahrr√§der (Gruppenbewertung in zwei Teilen von f√ºnf Modellen zweier Hersteller), Teil 1</a></li>
<li><a href="../de458602/index.html">Wie wir die Great Chinese Firewall durchbohrt haben (Teil 1)</a></li>
<li><a href="../de458604/index.html">Warum sich die beiden gr√∂√üten Elektronikhersteller zu einem neuen GPU-Projekt zusammengeschlossen haben</a></li>
<li><a href="../de458606/index.html">F√ºhren Sie OpenVPN in Docker in 2 Sekunden aus</a></li>
<li><a href="../de458612/index.html">Kosmos. 7 Jahre</a></li>
<li><a href="../de458614/index.html">Erstellen eines Reactive UsePosition () - Hooks zum Abrufen und Verfolgen von Browserkoordinaten</a></li>
<li><a href="../de458622/index.html">Automatisierung f√ºr die Kleinsten. Teil eins (der nach Null liegt). Netzwerkvirtualisierung</a></li>
<li><a href="../de458624/index.html">Wie wir gelernt haben, Texte auf Leinwand zu zeichnen</a></li>
<li><a href="../de458626/index.html">StealthWatch: Grundkonzepte und Mindestanforderungen. Teil 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>