<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ•“ ğŸš˜ ğŸ½ï¸ La validation en deux phases et l'avenir des systÃ¨mes distribuÃ©s ğŸ‘¨â€ğŸ¤ ğŸ‘©ğŸ¿â€ğŸ¤â€ğŸ‘©ğŸ¾ â›ˆï¸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans cet article, nous simulons et examinons un protocole de validation en deux phases Ã  l'aide de TLA +. 

 Le protocole de validation en deux phases...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>La validation en deux phases et l'avenir des systÃ¨mes distribuÃ©s</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/434496/">  Dans cet article, nous simulons et examinons un protocole de validation en deux phases Ã  l'aide de TLA +. <br><br>  Le protocole de validation en deux phases est pratique et est utilisÃ© aujourd'hui dans de nombreux systÃ¨mes distribuÃ©s.  Elle est nÃ©anmoins assez courte.  Par consÃ©quent, nous pouvons rapidement le modÃ©liser et en apprendre beaucoup.  En fait, avec cet exemple, nous allons illustrer quel rÃ©sultat dans des systÃ¨mes distribuÃ©s est <i>fondamentalement impossible</i> . <br><br><h3>  Le problÃ¨me de commit biphasÃ© </h3><br>  La transaction passe par <b>les gestionnaires de ressources (RM)</b> .  Tous les MR doivent convenir si la transaction sera <i>terminÃ©e</i> ou <i>abandonnÃ©e</i> . <br><br>  Le gestionnaire de transactions (TM) prend la dÃ©cision finale: <b>valider</b> ou <b>annuler</b> .  La condition pour la validation est la volontÃ© de valider tous les RM.  Sinon, la transaction doit Ãªtre annulÃ©e. <br><a name="habracut"></a><br><h3>  Quelques notes sur la modÃ©lisation </h3><br>  Par souci de simplicitÃ©, nous effectuons des simulations dans un modÃ¨le de mÃ©moire partagÃ©e, pas dans un systÃ¨me de messagerie.  Il fournit Ã©galement une validation rapide du modÃ¨le.  Mais nous ajouterons la non-atomicitÃ© aux actions Â«lecture depuis le nÅ“ud voisin et mise Ã  jour de l'Ã©tatÂ» afin de capturer un comportement intÃ©ressant lors de l'envoi de messages. <br><br>  RM ne peut lire que l'Ã©tat TM et lire / mettre Ã  jour son propre Ã©tat.  Il ne peut pas lire l'Ã©tat d'un autre gestionnaire de ressources.  Une MT peut lire l'Ã©tat de tous les nÅ“uds RM et lire / mettre Ã  jour son propre Ã©tat. <br><br><h3>  DÃ©finitions </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/d93/803/abe/d93803abea49766a0fbd7bb1d168c2c1.png"><br><br>  Les lignes 9-10 dÃ©finissent le <code>rmState</code> initial pour chaque RM sur <code>working</code> , et TM sur <code>init</code> . <br><br>  Le prÃ©dicat <code>canCommit</code> est <code>true</code> si tous les RM sont Â«prÃ©parÃ©sÂ» (prÃªts Ã  Ãªtre validÃ©s).  Si RM existe Ã  l'Ã©tat final, le prÃ©dicat <code>canAbort</code> devient <code>canAbort</code> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f2a/8a9/11c/f2a8a911c47b672d4f95b1eb59d11e60.png"><br><br>  La modÃ©lisation TM est simple.  Le gestionnaire de transactions vÃ©rifie la possibilitÃ© d'un commit ou d'une annulation - et met Ã  jour en consÃ©quence <code>tmState</code> . <br><br>  Il est possible que TM ne puisse pas rendre <code>tmState</code> "inaccessible", mais uniquement si la constante <code>TMMAYFAIL</code> dÃ©finie sur <code>true</code> avant la validation du modÃ¨le.  Dans les Ã©tiquettes TLA +, dÃ©terminez le degrÃ© d'atomicitÃ©, c'est-Ã -dire sa granularitÃ©.  Par les Ã©tiquettes F1 et F2, nous indiquons que les opÃ©rateurs correspondants sont exÃ©cutÃ©s de maniÃ¨re non anatomique (aprÃ¨s un certain temps indÃ©fini) par rapport aux opÃ©rateurs prÃ©cÃ©dents. <br><br><h3>  ModÃ¨le RM </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/425/42e/e7a/42542ee7a105be00451a28460cafc502.png"><br><br>  Le modÃ¨le RM est Ã©galement simple.  Ã‰tant donnÃ© que les Ã©tats Â«de travailÂ» et Â«prÃ©parÃ©Â» ne sont pas dÃ©finitifs, RM choisit de maniÃ¨re non dÃ©terministe parmi les actions jusqu'Ã  ce qu'il atteigne l'Ã©tat final.  Un RM Â«fonctionnelÂ» peut entrer dans un Ã©tat Â«interrompuÂ» ou Â«prÃ©parÃ©Â».  Â«PreparedÂ» RM attend une validation / annulation de la part de TM - et agit en consÃ©quence.  La figure ci-dessous montre les transitions d'Ã©tat possibles pour un RM.  Mais notez que nous avons plusieurs RM, chacun passant par ses Ã©tats Ã  son propre rythme sans connaÃ®tre l'Ã©tat des autres RM. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8d9/b25/0bd/8d9b250bd8aeeba4807f08e1d52a2675.png"><br><br><h3>  ModÃ¨le de validation en deux phases </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/62d/4e6/b1c/62d4e6b1c2046535daddbeeba285c7ac.png"><br><br>  Nous devons vÃ©rifier la cohÃ©rence de notre validation en deux phases: afin qu'il n'y ait pas de MR diffÃ©rent, dont l'un dit Â«commitÂ» et l'autre Â«avortementÂ». <br><br>  Le prÃ©dicat <code>Completed</code> vÃ©rifie que le protocole ne se bloque pas indÃ©finiment: Ã  la fin, chaque RM atteint l'Ã©tat final de <code>committed</code> ou <code>aborted</code> . <br><br>  Nous sommes maintenant prÃªts Ã  tester le modÃ¨le de protocole.  Initialement, nous avons dÃ©fini <code>TMMAYFAIL=FALSE, RM=1..3</code> pour dÃ©marrer le protocole avec trois RM et une TM, c'est-Ã -dire dans une configuration fiable.  Le test du modÃ¨le prend 15 secondes et indique qu'il n'y a pas d'erreur.  La <code>Consistency</code> et l' <code>Completed</code> satisfaits de toute exÃ©cution de protocole possible avec toute alternance d'actions RM et d'actions TM. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c25/c9e/ed0/c25c9eed093f51eb577cbbb97a4775b2.png"><br><br>  Maintenant, dÃ©finissez <code>TMMAYFAIL=TRUE</code> et redÃ©marrez la vÃ©rification.  Le programme produit rapidement le rÃ©sultat inverse, oÃ¹ RM est restÃ© coincÃ© en attente d'une rÃ©ponse d'une MT indisponible. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/652/e12/7ec/652e127ec391fae452f651c27f2855db.png"><br><br>  On voit qu'Ã  <code>State=4</code> transitions RM2 sont interrompues, Ã  <code>State=7</code> transitions RM3 sont interrompues, Ã  <code>State=8</code> TM passe Ã  l'Ã©tat "raccrocher" et tombe Ã  <code>State=9</code> .  Ã€ <code>State=10</code> systÃ¨me se bloque car RM1 reste Ã  jamais dans un Ã©tat prÃ©parÃ©, en attente d'une dÃ©cision d'une MT tombÃ©e. <br><br><h3>  Simulation BTM </h3><br>  Pour Ã©viter les gels de transaction, nous ajoutons une sauvegarde TM (BTM), qui prend rapidement le contrÃ´le si la MT principale n'est pas disponible.  BTM utilise la mÃªme logique que TM pour prendre des dÃ©cisions.  Et pour simplifier, nous supposons que le BTM ne plante jamais. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/43b/96f/842/43b96f8421fe04f10b8adbc573507c36.png"><br><br>  Lorsque nous testons le modÃ¨le avec le processus BTM ajoutÃ©, nous obtenons un nouveau message d'erreur. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/369/151/826/369151826a6dbe641acb2ae81340b1ea.png"><br><br>  BTM ne peut pas accepter un commit car notre condition d'origine, <code>canCommit</code> stipule que tous les <code>RMstates</code> doivent Ãªtre Â«prÃ©parÃ©sÂ» et ne prend pas en compte la condition selon laquelle certains RMs ont dÃ©jÃ  reÃ§u une dÃ©cision de commit du TM original avant que le TMB prenne le contrÃ´le.  Il est nÃ©cessaire de rÃ©Ã©crire les conditions de <code>canCommit</code> en tenant compte d'une telle situation. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9ed/4cf/bd5/9ed4cfbd55de80c58a7068b246c2375b.png"><br><br>  SuccÃ¨s!  Lorsque nous testons le modÃ¨le, nous atteignons Ã  la fois la cohÃ©rence et l'exhaustivitÃ©, puisque le BTM prend le contrÃ´le et termine la transaction si le TM tombe.  <a href="">Voici le modÃ¨le 2PCwithBTM en TLA +</a> (BTM et la deuxiÃ¨me ligne de canCommit sont initialement non commentÃ©s) et le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pdf correspondant</a> . <br><br><h3>  Et si RM Ã©choue aussi? </h3><br>  Nous avons supposÃ© que RM Ã©tait fiable.  Maintenant, annulez cette condition et voyez comment le protocole se comporte lorsque RM Ã©choue.  Ajoutez l'Ã©tat Â«inaccessibleÂ» au modÃ¨le de dÃ©faillance.  Afin d'Ã©tudier le comportement et de simuler une perte de disponibilitÃ© intermittente, laissez le RM d'urgence rÃ©cupÃ©rer et continuer Ã  travailler en lisant son Ã©tat dans le journal.  Voici un autre diagramme de transition d'Ã©tat RM avec l'Ã©tat Â«inaccessibleÂ» ajoutÃ© et les transitions marquÃ©es en rouge.  Et ci-dessous est le modÃ¨le rÃ©visÃ© pour RM. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ff1/f05/b6c/ff1f05b6cd817bb0d4050de4e30f37b6.png"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/94d/91f/8da/94d91f8da2aa4674044a71330da06d4e.png"><br><br>  Il est Ã©galement nÃ©cessaire d'affiner <code>canAbort</code> en tenant compte de l'Ã©tat d'indisponibilitÃ©.  TM peut prendre la dÃ©cision de Â«raccrocherÂ» si l'un des services est dans un Ã©tat interrompu ou inaccessible.  Si cette condition est omise, un RM tombÃ© et non restaurÃ© interrompra la progression de la transaction.  Bien sÃ»r, encore une fois, vous devez considÃ©rer les RM qui ont appris la dÃ©cision de finaliser la transaction Ã  partir de la MT source. <br><br><h3>  VÃ©rification du modÃ¨le </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/bf7/973/f0f/bf7973f0fd5815dfec816ff93dc03f3c.png"><br><br>  Lorsque nous testons le modÃ¨le, il y a un problÃ¨me d'incohÃ©rence!  Comment cela a-t-il pu arriver?  On trace la trace. <br><br>  Avec <code>State=6</code> tous les RM sont dans un Ã©tat prÃ©parÃ©, TM a pris la dÃ©cision de finaliser la transaction, RM1 a vu cette dÃ©cision et est passÃ© Ã  l'Ã©tiquette RC, ce qui signifie qu'il est prÃªt Ã  changer son Ã©tat en Â«terminÃ©Â».  (Rappelez-vous RM1, ce pistolet tirera au dernier acte).  Malheureusement, le TM tombe Ã  <code>State=7</code> , et RM2 devient indisponible Ã  <code>State=8</code> .  Dans la neuviÃ¨me Ã©tape, le BTM de sauvegarde prend le contrÃ´le et lit le statut des trois RM comme Â«prÃ©parÃ©, inaccessible, prÃ©parÃ©Â» - et dÃ©cide d'annuler la transaction Ã  la dixiÃ¨me Ã©tape.  Rappelez-vous RM1?  Il dÃ©cide de finaliser la transaction car il a reÃ§u une telle dÃ©cision de la part de la MT d'origine et entre dans l'Ã©tat <code>committed</code> Ã  l'Ã©tape 11.  Dans <code>State=13</code> RM3 remplit la dÃ©cision d'annuler la transaction de BTM et entre dans l'Ã©tat <code>aborted</code> - et maintenant nous avons rompu la coordination avec RM1. <br><br>  Dans ce cas, le BTM a pris une dÃ©cision qui violait la <b>cohÃ©rence</b> .  D'un autre cÃ´tÃ©, si vous faites attendre le BTM que le RM quitte l'Ã©tat inaccessible, il peut geler pour toujours en cas d'accident au niveau du nÅ“ud, et cela violera la condition de <b>rÃ©alisation</b> (progression). <br><br>  <a href="">Un fichier de modÃ¨le TLA + mis Ã  jour est disponible ici</a> , ainsi que le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pdf correspondant</a> . <br><br><h3>  ImpossibilitÃ© FLP </h3><br>  Que s'est-il donc passÃ©?  Nous sommes tombÃ©s sur le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">thÃ©orÃ¨me de Fisher, Lynch, Paterson (FLP)</a> sur l'impossibilitÃ© d'un consensus dans un systÃ¨me asynchrone avec Ã©checs. <br><br>  Dans notre exemple, BTM ne peut pas dÃ©cider correctement si RM2 est en Ã©tat d'Ã©chec ou non - et dÃ©cide incorrectement d'annuler la transaction.  Si seule la MT d'origine prenait la dÃ©cision, une telle inexactitude dans la reconnaissance d'un Ã©chec ne serait pas un problÃ¨me.  RM obÃ©ira Ã  toute dÃ©cision TM, afin que la cohÃ©rence et les progrÃ¨s soient maintenus. <br><br>  Le problÃ¨me est que nous avons deux objets qui prennent des dÃ©cisions: TM et BTM, ils regardent l'Ã©tat de RM Ã  diffÃ©rents moments et prennent des dÃ©cisions diffÃ©rentes.  Une telle asymÃ©trie d'information est Ã  l'origine de tout mal dans les systÃ¨mes distribuÃ©s. <br><br>  Le problÃ¨me ne disparaÃ®t pas mÃªme avec l'extension Ã  un commit en trois phases.  <a href="">Voici un commit en trois phases modÃ©lisÃ© en TLA +</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">version pdf</a> ), et ci-dessous est une trace d'erreur qui montre que cette fois la progression a Ã©tÃ© violÃ©e (sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la page Wikipedia Ã  propos d'un commit en trois phases</a> , une situation est dÃ©crite lorsque RM1 se bloque aprÃ¨s avoir reÃ§u une dÃ©cision avant le commit, et RM2 et RM3 commit commit, ce qui viole la cohÃ©rence). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0d3/6d8/06d/0d36d806d38003f3cd995bbefbc0802d.png"><br><br><h3>  Paxos essaie de rendre le monde meilleur. </h3><br><img src="https://habrastorage.org/webt/q-/o_/wq/q-o_wq_jdl14y0ulz-nud8k4idw.jpeg"><br><br>  Mais tout n'est pas perdu, l'espoir n'est pas mort.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Nous avons Paxos</a> .  Il agit parfaitement dans le cadre du thÃ©orÃ¨me FLP.  L'innovation de Paxos est qu'il est <b>toujours sÃ»r</b> (mÃªme avec des dÃ©tecteurs inexacts, une exÃ©cution asynchrone et des pannes), et <b>finalise la transaction</b> lorsqu'un consensus devient possible. <br><br>  Vous pouvez Ã©muler TM sur un cluster avec trois nÅ“uds Paxos, et cela rÃ©soudra le problÃ¨me d'incohÃ©rence TM / BTM.  Ou, comme Gray et Lampport l'ont montrÃ© dans un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article scientifique sur le consensus dans la</a> validation <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">de transaction</a> , si RM utilise le conteneur Paxos pour stocker leurs dÃ©cisions simultanÃ©ment avec la rÃ©ponse TM, cela Ã©limine une Ã©tape supplÃ©mentaire dans l'algorithme de protocole standard. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr434496/">https://habr.com/ru/post/fr434496/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr434480/index.html">Nouvel an, gadgets, feu</a></li>
<li><a href="../fr434482/index.html">Une autre annÃ©e de notre blog: rÃ©sultats de 2018</a></li>
<li><a href="../fr434486/index.html">Cartes de fidÃ©litÃ©. API Google Pay pour les passes dans ASP.NET</a></li>
<li><a href="../fr434490/index.html">Comment nous avons vu le haut-parleur par dÃ©coupe au jet d'eau</a></li>
<li><a href="../fr434494/index.html">Que lire. Liste des fictions de langue russe pour 2017 et 2018</a></li>
<li><a href="../fr434498/index.html">MVP et Dagger 2 - Squelette d'application Android - Partie 1</a></li>
<li><a href="../fr434500/index.html">Swindler nommÃ© Jeanne ou Watch Your Ears</a></li>
<li><a href="../fr434502/index.html">Comment les archÃ©ologues numÃ©riques ont dÃ©couvert une SimCity perdue pour NES</a></li>
<li><a href="../fr434504/index.html">20 ans de rapports rapides "Le produit a Ã©tÃ© crÃ©Ã© en un souffle, juste haut ..."</a></li>
<li><a href="../fr434506/index.html">ExpÃ©rience de publication d'une application de montage vidÃ©o dans le Microsoft Store</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>