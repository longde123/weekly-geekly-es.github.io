<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌲 🧠 ✡️ إكسير كهدف لتطوير بيثون المتزامن 👍🏻 🙅🏿 📆</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="في كتاب "بيثون. إلى آفاق التميز "يصف لوسيانو رامالو قصة واحدة. في عام 2000 ، تلقى لوسيانو دورات تدريبية ، وبمجرد أن نظر غيدو فان روسوم إلى الجمهور. بم...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>إكسير كهدف لتطوير بيثون المتزامن</h1><div class="post__body post__body_full" style=";text-align:right;direction:rtl"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/476112/" style=";text-align:right;direction:rtl">  في كتاب "بيثون.  إلى آفاق التميز "يصف لوسيانو رامالو قصة واحدة.  في عام 2000 ، تلقى لوسيانو دورات تدريبية ، وبمجرد أن نظر غيدو فان روسوم إلى الجمهور.  بمجرد ظهور مثل هذا الحدث ، بدأ الجميع في طرح الأسئلة عليه.  عندما سئل عن الوظائف التي اقترضتها بايثون من لغات أخرى ، أجاب غويدو: "كل ما هو جيد في بيثون سرق من لغات أخرى." <br><br>  انها حقا.  عاشت بايثون منذ فترة طويلة في سياق لغات البرمجة الأخرى وتمتص المفاهيم من بيئتها: تم استعارة التزامن ، وذلك بفضل تعبيرات Lisp lambda ، وتم نسخ تورنادو من libevent.  ولكن إذا كان يجب على أي شخص أن يستعير الأفكار ، فهو إرلانج.  تم إنشاؤه قبل 30 عامًا ، وجميع المفاهيم الموجودة في بيثون التي يتم تنفيذها حاليًا أو التي تم تحديدها للتو كانت تعمل في إرلانج لفترة طويلة: متعددة النواة ، الرسائل كأساس للتواصل ومكالمات الطريقة والتأمل داخل نظام الإنتاج المباشر.  هذه الأفكار ، بشكل أو بآخر ، تجد التعبير عنها في أنظمة مثل <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">Seastar.io</a> . <br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/fb/0x/mf/fb0xmfg8afpsrhs7js423v4bvjy.jpeg" width="500"></div><br>  إذا لم تأخذ في الاعتبار "علوم البيانات" ، حيث أصبحت Python خارج المنافسة الآن ، فسيتم بالفعل تنفيذ كل شيء آخر في Erlang: العمل مع شبكة ، والتعامل مع HTTP ومآخذ الويب ، والعمل مع قواعد البيانات.  لذلك ، من المهم لمطوري Python أن يفهموا أين ستنتقل اللغة: على طريق مرت بالفعل منذ 30 عامًا. <br><br>  لفهم تاريخ تطور اللغات الأخرى وفهم تقدم التقدم ، قمنا بدعوة <strong>Maxim Lapshin</strong> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=" class="user_link">erlyvideo</a> ) ، مؤلف مشروع Erlyvideo.ru ، إلى <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">Moscow Python Conf ++</a> . <br><br>  في الأسفل ، توجد نسخة نصية من هذا التقرير ، وهي: في أي اتجاه يُجبر النظام على التطوير ، والذي يستمر في الانتقال من رمز خطي بسيط إلى libevent وما بعده ، وهو أمر شائع وما هي الاختلافات بين Elixir و Python.  سنولي اهتمامًا خاصًا لكيفية إدارة مآخذ التوصيل والخيوط والبيانات بلغات ومنصات برمجة مختلفة. <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/RAZ0sHpPrZE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  يحتوي Erlyvideo.ru على نظام مراقبة فيديو يتم فيه كتابة التحكم في الوصول للكاميرات في Python.  هذه مهمة كلاسيكية لهذه اللغة.  هناك مستخدمون وكاميرات ومقاطع فيديو يمكنهم مشاهدتها: يرى شخص ما بعض الكاميرات ، بينما يرى آخرون موقعًا منتظمًا. <br><br>  تم اختيار Python لأنها ملائمة لكتابة مثل هذه الخدمة عليها: هناك أطر عمل ، ORMs ، مبرمجون ، بعد كل شيء.  يتم حزم البرامج المتقدمة وبيعها للمستخدمين.  Erlyvideo.ru هي شركة تبيع البرامج ، ولا تقدم الخدمة فقط. <br><br>  ما هي المشاكل مع بيثون أريد حلها. <br><br>  <strong>لماذا هناك مثل هذه المشاكل مع multicore؟</strong>  ركضنا Flussonic على أجهزة الكمبيوتر الملاعب حتى قبل أن تفعل.  لكن بيثون تواجه صعوبات في هذا: لماذا لا تزال لا تستخدم جميع النوى الـ 80 لخوادمنا للعمل؟ <br><br>  <strong>كيف لا تعاني من مآخذ مفتوحة؟</strong>  مراقبة عدد مآخذ مفتوحة مشكلة كبيرة.  عندما يصل إلى الحد ، أغلق وقم بمنع التسرب أيضًا. <br><br>  <strong>هل لدى المتغيرات العالمية المنسية حلاً؟</strong>  تسريب المتغيرات العامة هو الجحيم لأي لغة تجميع للقمامة مثل Java أو C #. <br><br>  <strong>كيفية استخدام الحديد دون هدر الموارد؟</strong>  كيفية الحصول على دون تشغيل 40 عاملا Jung و 64 جيجابايت من ذاكرة الوصول العشوائي إذا كنا نريد استخدام الخوادم بكفاءة وعدم رمي مئات الآلاف من الدولارات شهريا على الأجهزة غير الضرورية؟ <br><br><h3 style=";text-align:right;direction:rtl">  لماذا هناك حاجة متعددة النواة </h3><br>  <strong>ولكي يتم استخدام جميع النوى بالكامل ،</strong> هناك حاجة إلى عمال أكثر من النوى.  على سبيل المثال ، بالنسبة لـ 40 مركزًا للمعالجات ، هناك حاجة إلى 100 عامل: ذهب عامل واحد إلى قاعدة البيانات ، والآخر مشغول بشيء آخر. <br><br>  <strong>عامل واحد يمكن أن تستهلك 300-400 ميغابايت</strong> .  ما زلنا نكتب هذا في Python ، وليس في Ruby on Rails ، التي يمكن أن تستهلك عدة مرات أكثر ، وسوف يضيع 40 جيجابايت من ذاكرة الوصول العشوائي بسهولة ويسر.  أنها ليست مكلفة للغاية ، ولكن لماذا شراء الذاكرة حيث لا يمكنك شراء. <br><br>  <strong>متعدد النواة يساعد على تبخير البيانات المشتركة وتقليل استهلاك الذاكرة</strong> ، وتشغيل مريح وآمن العديد من العمليات المستقلة.  من الأسهل بكثير البرمجة ، ولكنها أكثر تكلفة من الذاكرة. <br><br><h3 style=";text-align:right;direction:rtl">  إدارة المقبس </h3><br>  على مقبس الويب ، نقوم باستطلاع بيانات وقت تشغيل الكاميرات من الجهة الخلفية.  يتصل برنامج Python بـ Flussonic ويستطلع بيانات حالة الكاميرات: سواء كانت تعمل أم لا ، هل توجد أي أحداث جديدة. <br><br>  من ناحية أخرى ، يتصل العميل ، ومن خلال مقبس الويب ، نرسل هذه البيانات إلى المستعرض.  نريد نقل بيانات العميل في الوقت الحقيقي: الكاميرا قيد التشغيل وإيقاف التشغيل ، أكلت القط ، نمت ، تمزيق أريكة ، الضغط على الزر ودفع القط بعيدا. <br><br>  ولكن ، على سبيل المثال ، حدث نوع من المشكلة: قاعدة البيانات لم تستجب للطلب ، سقطت جميع الشفرات ، وكان هناك مآخذان مفتوحان.  بدأنا إعادة التحميل ، وفعلنا شيئًا ، مرة أخرى هذه المشكلة - كان هناك مآخذ.  تم معالجة خطأ DB بشكل غير صحيح وتم تعليق اتصالين مفتوحين.  مع مرور الوقت ، وهذا يؤدي إلى تسرب مأخذ التوصيل. <br><br><h3 style=";text-align:right;direction:rtl">  متغيرات عالمية منسية </h3><br>  قدمت إملاء عالمي لقائمة المتصفحات المتصلة عبر مقبس الويب.  يقوم شخص بتسجيل الدخول إلى الموقع ، نفتح له مقبس ويب له.  ثم نضع مقبس الويب بمعرفه في نوع ما من الإملاء العام ، ويتبين أن هناك نوعًا من الأخطاء يحدث. <br><br>  على سبيل المثال ، سجلوا رابط اتصال في dict لإرسال البيانات.  <strong>حدث استثناء ، نسيت حذف الرابط وتعليق البيانات</strong> .  لذلك بعد مرور بعض الوقت ، بدأ تفويت 64 جيجا بايت ، وأريد مضاعفة الذاكرة على الخادم.  هذا ليس حلاً ، لأن البيانات سوف تتسرب على أي حال. <br><blockquote style=";text-align:right;direction:rtl">  نرتكب دائمًا أخطاء - نحن أشخاص ولا يمكننا تتبع كل شيء. </blockquote>  والسؤال هو أن بعض الأخطاء تحدث ، حتى تلك التي لم نتوقع رؤيتها. <br><br><h2 style=";text-align:right;direction:rtl">  رحلة تاريخية </h2><br>  للوصول إلى الموضوع الرئيسي ، دعونا نتعمق في القصة.  كل ما نتحدث عن Python و Go و Erlang عنه الآن ، ذهب أشخاص آخرون بهذه الطريقة منذ حوالي 30 عامًا.  نحن في بيثون نقطع شوطًا طويلًا ونملأ المطبات التي مرت بالفعل منذ عقود.  يكرر المسار بطريقة مذهلة. <br><br><h3 style=";text-align:right;direction:rtl">  DOS </h3><br>  أولاً ، دعنا ننتقل إلى DOS ، إنه الأقرب.  قبله كانت هناك أشياء مختلفة تمامًا وليس الجميع على قيد الحياة الذي يتذكر أجهزة الكمبيوتر قبل DOS. <br><br>  <strong>احتل برنامج DOS الكمبيوتر (تقريبًا) بشكل حصري</strong> .  أثناء تشغيل لعبة ، على سبيل المثال ، لا يتم تنفيذ أي شيء آخر.  لن تستخدم الإنترنت - لم تصل بعد ، ولن تصل إلى أي مكان.  كان حزينا ، لكن ذكرياته دافئة ، لأنه مرتبط بالشباب. <br><br><h3 style=";text-align:right;direction:rtl">  تعدد المهام التعاونية </h3><br>  نظرًا لأنه كان مؤلمًا بالفعل مع DOS ، ظهرت تحديات جديدة ، وأصبحت أجهزة الكمبيوتر أكثر قوة.  <strong>منذ عقود ، طوروا مفهوم تعدد المهام التعاوني</strong> ، حتى قبل Windows 3.11. <br><br>  <strong>يتم فصل البيانات عن طريق العمليات ، ويتم تنفيذ كل عملية على حدة:</strong> فهي محمية بطريقة أو بأخرى من بعضها البعض.  لن تتمكن الشفرة السيئة في إحدى العمليات من إفساد الشفرة في المستعرض (ثم ظهرت المتصفحات الأولى بالفعل). <br><br>  السؤال التالي هو: كيف سيتم توزيع وقت الحوسبة بين العمليات المختلفة؟  ثم لم يكن هناك أكثر من نواة ، بل كان هناك نظام مزدوج المعالج.  كان هذا المخطط: في حين ذهبت عملية واحدة ، على سبيل المثال ، إلى قرص للبيانات ، فإن العملية الثانية تتلقى السيطرة من نظام التشغيل.  الأولى ستكون قادرة على السيطرة عندما يعطي الثاني نفسه طوعا.  أبسط الموقف إلى حد كبير ، لكن <strong>العملية سمحت طوعًا بطريقة ما بإزالته من المعالج</strong> . <br><br><h3 style=";text-align:right;direction:rtl">  تعدد المهام الاستباقية </h3><br>  أدت المهام المتعددة التعاونية إلى المشكلة التالية: يمكن أن تتوقف العملية لأنها مكتوبة بشكل سيء.  <strong>إذا استغرق المعالج وقتًا طويلاً في المعالجة ، فإنه يحظر الباقي</strong> .  في هذه الحالة ، تعطل جهاز الكمبيوتر ، ولا يمكن القيام بأي شيء ، على سبيل المثال ، تبديل النافذة. <br><br>  استجابة لهذه المشكلة ، تم اختراع المهام المتعددة الوقائية.  يعمل نظام التشغيل الآن على تشغيل محركات الأقراص بشكل صارم: يزيل العمليات من التنفيذ ويفصل بياناتها تمامًا ويحمي ذاكرة العملية من بعضها البعض ويمنح الجميع قدراً من الوقت الحسابي.  <strong>يخصص نظام التشغيل الفواصل الزمنية نفسها لكل عملية</strong> . <br><br>  مسألة الوقت sheduling لا يزال مفتوحا.  اليوم ، ما زال مطورو نظام التشغيل يتوصلون إلى ما هو صحيح ، وبأي ترتيب ، ولمن ، وكم من الوقت لمنح للإدارة.  اليوم نرى تطور هذه الأفكار. <br><br><h3 style=";text-align:right;direction:rtl">  تيارات </h3><br>  لكن هذا لم يكن كافيا.  تحتاج العمليات إلى تبادل البيانات: من خلال الشبكة مكلفة ، بطريقة ما لا تزال معقدة.  لذلك ، اخترع <strong>مفهوم التدفقات</strong> . <br><blockquote style=";text-align:right;direction:rtl">  مؤشرات الترابط هي عمليات خفيفة الوزن تشترك في ذاكرة مشتركة. <br></blockquote>  تم إنشاء تيارات على أمل أن يكون كل شيء سهلًا وبسيطًا وممتعًا.  الآن <strong>تعتبر البرمجة متعددة الخيوط antipattern</strong> .  إذا كان منطق العمل مكتوبًا في سلاسل الرسائل ، فمن المرجح أن يتم التخلص من هذا الرمز ، لأنه من المحتمل وجود أخطاء فيه.  إذا بدا لك أنه لا توجد أخطاء ، فأنت ببساطة لم تعثر عليها بعد. <br><br>  البرمجة متعددة مؤشرات الترابط أمر معقد للغاية.  هناك عدد قليل من الناس الذين كرسوا أنفسهم حقًا للقدرة على الكتابة على سلاسل الرسائل ويحصلون على شيء مفيد حقًا. <br><br>  وفي الوقت نفسه ، ظهرت <strong>أجهزة الكمبيوتر متعددة النواة</strong> .  لقد أحضروا معهم أشياء فظيعة.  لقد اتبعت طريقة مختلفة تمامًا للبيانات ، فقد نشأت أسئلة حول مكان البيانات ، والآن عليك أن تفهم من أي نواة تذهب إليها. <br><br>  يحتاج أحد النوى إلى وضع البيانات هنا ، والآخر هناك ، ولا يخلط بين هذه الأشياء بأي حال من الأحوال ، لأن المجموعات ظهرت بالفعل داخل الكمبيوتر.  داخل الكمبيوتر الحديث ، هناك كتلة عندما يتم لحام جزء من الذاكرة بنواة واحدة والأخرى إلى أخرى.  يمكن أن يختلف وقت العبور بين هذه البيانات حسب أوامر الحجم. <br><br><h2 style=";text-align:right;direction:rtl">  أمثلة بيثون </h2><br>  فكر في مثال بسيط على "الخدمة لمساعدة العميل".  إنه يختار أفضل سعر للبضائع على العديد من المنصات: نحن نقود باسم البضائع ونبحث عن الأرضيات التجارية بأقل سعر ممكن. <br><br>  هذا هو الكود الموجود في جانغو القديمة ، بيثون 2. اليوم ، لا تحظى بشعبية كبيرة ، حيث يبدأ عدد قليل من الناس في تنفيذ مشاريع. <br><br><pre style=";text-align:right;direction:rtl"><code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@api_view(['GET']) def best_price(request): name = request.GET['name'] price1 = http_fetch_price('market.yandex.ru', name) price2 = http_fetch_price('ebay.com', name) price3 = http_fetch_price('taobao.com', name) return Response(min([price1,price2,price3]))</span></span></code> </pre> <br>  يصل الطلب ، نذهب إلى خلفية واحدة ، ثم إلى أخرى.  في الأماكن التي يتم فيها <code>http_fetch_price</code> ، يتم حظر <code>http_fetch_price</code> .  في هذه اللحظة ، يشرع العامل بأكمله في رحلة إلى Yandex.Market ، ثم إلى eBay ، ثم إلى مهلة في تاوباو ، وفي النهاية يعطي إجابة.  <strong>كل هذا الوقت يقف العامل بأكمله</strong> . <br><br>  من الصعب للغاية استطلاع آراء متعددة في نفس الوقت.  هذا وضع سيئ: يتم استهلاك الذاكرة وإطلاق عدد كبير من العمال ومراقبة الخدمة بأكملها.  من الضروري أن ننظر إلى مدى تكرار هذه الطلبات ، هل ما زلت بحاجة إلى إدارة العمال أو هل هناك طلبات إضافية مرة أخرى.  هذه هي المشاكل ذاتها التي تحدثت عنها.  <strong>من الضروري استجواب العديد من الوصلات الخلفية بدورها</strong> . <br><br>  ماذا نرى في بايثون؟  <strong>عملية واحدة لكل مهمة ،</strong> في بيثون لا يوجد حتى الآن multicore.  الموقف واضح: في لغات هذا الفصل ، يصعب إنشاء مولتيكوري آمن بسيط ، لأنه <strong>سيقتل الأداء</strong> . <br><br>  إذا ذهبت إلى الإملاء من تدفقات مختلفة ، فيمكنك الوصول إلى البيانات على هذا النحو: الغراء حالتان من بيثون في الذاكرة حتى يقوما بتفتيش البيانات - إنهما ببساطة يكسرانها.  على سبيل المثال ، للذهاب إلى الإملاء وليس كسر أي شيء ، تحتاج إلى وضع المزامير أمامه.  إذا كان هناك كائن مزيف قبل كل أمر ، فسيتباطأ النظام حوالي 1000 مرة - سيكون ببساطة غير مريح.  من الصعب جرها إلى متعددة النواة. <br><br>  لدينا <strong>مؤشر ترابط واحد فقط من التنفيذ</strong> <strong>والعمليات فقط يمكن أن نطاق</strong> .  في الواقع ، قمنا بإعادة اختراع DOS داخل العملية - لغة البرمجة النصية لعام 2010.  يوجد داخل العملية شيء يشبه DOS: بينما نقوم بعمل ما ، فإن جميع العمليات الأخرى لا تعمل.  لا أحد يحب التجاوزات الضخمة في التكلفة والاستجابة البطيئة. <br><br>  ظهرت <b>مفاعلات المقبس</b> في بيثون منذ بعض الوقت ، على الرغم من أن الفكرة نفسها ولدت منذ فترة طويلة.  الآن يمكنك أن تتوقع استعداد عدة مآخذ في وقت واحد. <br><br>  في البداية ، أصبح المفاعل في الطلب على خوادم مثل nginx.  بما في ذلك الاستخدام الصحيح لهذه التكنولوجيا ، فقد أصبحت شائعة.  ثم زحف المفهوم إلى لغات البرمجة النصية مثل بيثون وروبي. <br><blockquote style=";text-align:right;direction:rtl">  فكرة المفاعل هي أننا انتقلنا إلى البرمجة الموجهة نحو الحدث. </blockquote><br><h2 style=";text-align:right;direction:rtl">  الحدث الموجه البرمجة </h2><br>  سياق تنفيذ واحد ينتج طلب.  أثناء انتظار الإجابة ، يتم تنفيذ سياق مختلف.  من الجدير بالذكر أننا مررنا تقريبًا بمرحلة التطور نفسها التي مرت بها عملية الانتقال من DOS إلى Windows 3.11.  لم يفعل ذلك إلا قبل 20 عامًا ، وفي بيثون وروبي ظهر قبل 10 سنوات. <br><br><h3 style=";text-align:right;direction:rtl">  ملفوف </h3><br>  هذا هو إطار شبكة يحركها الحدث.  ظهرت في عام 2002 وكتبت في بيثون.  أخذت المثال أعلاه وأعد كتابته على Twisted. <br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">render_GET</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, request)</span></span></span><span class="hljs-function">:</span></span> price1 = deferred_fetch_price(<span class="hljs-string"><span class="hljs-string">'market.yandex.ru'</span></span>, name) price2 = deferred_fetch_price(<span class="hljs-string"><span class="hljs-string">'ebay.com'</span></span>, name) price3 = deferred_fetch_price(<span class="hljs-string"><span class="hljs-string">'taobao.com'</span></span>, name) dl = defer.DeferredList([price1,price2,price3]) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(prices)</span></span></span><span class="hljs-function">:</span></span> request.write(<span class="hljs-string"><span class="hljs-string">'%d'</span></span>.format(min(prices))) request.finish() dl.addCallback(reply) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> server.NOT_DONE_YET</code> </pre> <br>  قد تكون هناك أخطاء ، وعدم الدقة ، ومعالجة الأخطاء سيئة السمعة ليست كافية.  لكن المخطط التقريبي هو هذا: نحن لا نقدم طلبًا ، ولكن نطلب الذهاب لهذا الطلب في وقت لاحق ، عندما يكون هناك وقت.  في السطر مع <code>defer.DeferredList</code> نريد أن نجمع ردودًا من عدة استعلامات معًا. <br><br>  في الواقع ، يتكون الكود من جزأين.  في الجزء الأول ، ماذا حدث قبل الطلب ، وفي الجزء الثاني ، ماذا بعد. <br><blockquote style=";text-align:right;direction:rtl">  إن التاريخ الكامل للبرمجة الموجهة نحو الحدث مشبع بألم كسر الشفرة الخطية على "قبل الطلب" و "بعد الطلب". </blockquote>  هذا مؤلم لأن أجزاء الكود مختلطة: لا يزال يتم تنفيذ الأسطر الأخيرة في الطلب الأصلي ، وسيتم استدعاء وظيفة <code>reply</code> بعد. <br><br>  ليس من السهل أن نضع في اعتبارنا على وجه التحديد لأننا اخترقنا الكود الخطي ، لكن يجب القيام به.  دون الخوض في التفاصيل ، فإن الكود الذي أعيد كتابته من جانغو إلى تويستيد <strong>سوف ينتج تسارعًا زائفًا لا يصدق تمامًا</strong> . <br><br><h3 style=";text-align:right;direction:rtl">  فكرة ملتوية </h3><blockquote style=";text-align:right;direction:rtl">  يمكن تنشيط كائن عندما يكون المقبس جاهزًا. </blockquote>  نأخذ الكائنات التي نجمع فيها البيانات اللازمة من السياق ونربط تنشيطها بالمقبس.  يعد توفر المقبس الآن أحد أهم عناصر التحكم للنظام بأكمله.  الكائنات ستكون سياقاتنا. <br><br>  ولكن في الوقت نفسه ، لا تزال اللغة تفصل مفهوم سياق التنفيذ الذي تعيش فيه الاستثناءات.  <strong>يعيش سياق التنفيذ بشكل منفصل عن الكائنات ويتم ربطه بشكل فضفاض</strong> .  تكمن المشكلة هنا في حقيقة أننا نحاول جمع البيانات داخل الكائنات: لا توجد طريقة بدونها ، لكن اللغة لا تدعمها. <br><br>  كل هذا يؤدي إلى الجحيم رد الاتصال الكلاسيكية.  لماذا ، على سبيل المثال ، يحبون Node.js - حتى وقت قريب ، لم تكن هناك طرق أخرى على الإطلاق ، ولكن لا يزال يظهر في بيثون.  المشكلة هي أن هناك <strong>فواصل للكود عند نقاط IO الخارجية</strong> التي تؤدي إلى معاودة الاتصال. <br><br>  هناك العديد من الأسئلة.  هل من الممكن "الغراء" حواف الفجوة في الكود؟  هل من الممكن العودة إلى الكود البشري العادي؟  ماذا تفعل إذا كان هناك كائن منطقي يعمل بمقبسين وأغلق أحدهما؟  كيف لا تنسى أن تغلق الثانية؟  هل من الممكن استخدام كل النوى بطريقة أو بأخرى؟ <br><br><h3 style=";text-align:right;direction:rtl">  غير متزامن IO </h3><br>  الإجابة الجيدة على هذه الأسئلة هي Async IO.  هذه خطوة كبيرة للأمام ، رغم أنها ليست سهلة.  Async IO شيء معقد ، يوجد أسفل الغطاء العديد من الفروق الدقيقة المؤلمة. <br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">best_price</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(request)</span></span></span><span class="hljs-function">:</span></span> name = request.GET[<span class="hljs-string"><span class="hljs-string">'name'</span></span>] price1 = async_http_fetch_price(<span class="hljs-string"><span class="hljs-string">'market.yandex.ru'</span></span>, name) price2 = async_http_fetch_price(<span class="hljs-string"><span class="hljs-string">'ebay.com'</span></span>, name) price3 = async_http_fetch_price(<span class="hljs-string"><span class="hljs-string">'taobao.com'</span></span>, name) prices = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.wait([price1,price2,price3]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> min(prices)</code> </pre> <br>  فجوة الشفرة مخفية تحت بناء الجملة <code>async/await</code> .  أخذنا كل ما كان من قبل ، لكننا لم نذهب إلى الشبكة في هذا الرمز.  لقد أزلنا <code>Callback(reply)</code> ، والذي كان في المثال السابق ، وأخفاه في <code>await</code> - المكان الذي سيتم فيه قص الشفرة بالمقص.  سيتم تقسيمها إلى قسمين: الجزء المتصل وجزء رد الاتصال ، والذي يعالج النتائج. <br><br>  هذا هو <strong>السكر النحوي الكبير</strong> .  هناك طرق لصق توقعات متعددة في واحد.  هذا رائع ، لكن هناك فارق بسيط: <strong>يمكن كسر كل شيء بواسطة مقبس "كلاسيكي"</strong> .  في Python ، لا يزال هناك عدد كبير من المكتبات التي تذهب إلى المقبس بشكل متزامن ، وتقوم بإنشاء <code>timer library</code> وتدمير كل شيء لك.  كيفية تصحيح هذا ، أنا لا أعرف. <br><br>  لكن <strong>عدم التزامن لا يساعد في التسريبات والمتعددة</strong> .  لذلك ، لا توجد تغييرات أساسية ، رغم أنها أصبحت أفضل. <br><br>  لا يزال لدينا جميع المشاكل التي تحدثنا عنها في البداية: <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  من السهل أن تسرب مع مآخذ. </li><li style=";text-align:right;direction:rtl">  من السهل ترك الروابط في المتغيرات العالمية ؛ </li><li style=";text-align:right;direction:rtl">  معالجة الأخطاء المضنية للغاية ؛ </li><li style=";text-align:right;direction:rtl">  ما زال من الصعب القيام به متعدد النواة. </li></ul><br><h3 style=";text-align:right;direction:rtl">  ما يجب القيام به </h3><br>  ما إذا كان هذا سيتطور جميعًا ، لا أعرف ، لكنني سأعرض التنفيذ بلغات ومنصات أخرى. <br><br>  <strong>سياقات التنفيذ المعزولة.</strong>  في سياقات التنفيذ ، يتم تجميع النتائج ، يتم الاحتفاظ بالمآخذ: كائنات منطقية نقوم فيها عادةً بتخزين جميع البيانات حول عمليات الاسترجاعات والمقابس.  أحد المفاهيم: خذ سياقات التنفيذ ، وقم بإلصاقها بخيوط التنفيذ ، وعزلها تمامًا عن بعضها البعض. <br><br>  <strong>نموذج التحول من الأشياء.</strong>  دعنا نربط السياق بخيط التنفيذ.  هناك نظائرها ، وهذا ليس شيئا جديدا.  إذا حاول شخص ما تحرير شفرة مصدر Apache وكتابة وحدات لهم ، فهو يعلم أن هناك مجموعة Apache.  <strong>لا يسمح الروابط</strong> بين تجمع اباتشي.  توجد بيانات من تجمع Apache واحد - التجمع المقترن بالطلبات ، بداخله ، ولا يمكنك الحصول على أي شيء منه. <br><br>  من الناحية النظرية ، يكون ذلك ممكنًا ، ولكن إذا قمت بذلك ، إما أن يوبخ أحدهم ، أو لن يقبل التصحيح ، أو سيكون لديه تصحيح طويل ومؤلمة للإنتاج.  بعد ذلك ، لن يقوم أحد بذلك وسيسمح للآخرين بالقيام بمثل هذه الأشياء.  من المستحيل ببساطة الرجوع إلى البيانات بين السياقات بعد الآن ، هناك حاجة لعزل كامل. <br><br>  كيفية تبادل النشاط؟  ما نحتاج إليه ليس الموناديات الصغيرة ، التي يتم إغلاقها داخلها ولا تتواصل مع بعضها البعض.  نحن بحاجة لهم للتواصل.  نهج واحد هو الرسائل.  هذا هو المسار الذي سلكه Windows تقريبًا عند تبادل الرسائل بين العمليات.  في نظام التشغيل العادي ، لا يمكنك إعطاء رابط لذاكرة عملية أخرى ، لكن يمكنك الإشارة عبر الشبكة ، كما في نظام UNIX ، أو من خلال الرسائل ، كما في نظام Windows. <br><br>  <strong>جميع الموارد داخل العملية والسياق تصبح خيط التنفيذ</strong> .  نحن لصقها معا: <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  بيانات وقت التشغيل في جهاز ظاهري تحدث فيه استثناءات ؛ </li><li style=";text-align:right;direction:rtl">  مؤشر ترابط التنفيذ ، مثل ما يتم تنفيذه على المعالج ؛ </li><li style=";text-align:right;direction:rtl">  كائن يتم فيه تجميع كل البيانات بطريقة منطقية. </li></ul><br>  تهانينا - لقد اخترعنا UNIX داخل لغة برمجة!  تم اختراع هذه الفكرة حوالي عام 1969.  حتى الآن ، لم يكن في بيثون حتى الآن ، ولكن بيثون من المرجح أن يأتي إلى هذا.  وربما لن تأتي - لا أعرف. <br><br><h3 style=";text-align:right;direction:rtl">  ماذا يعطي </h3><br>  بادئ ذي <strong>بدء</strong> ، <strong>التحكم التلقائي في الموارد</strong> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">قالوا</a> في Moscow Python Conf ++ 2019 أنه يمكنك كتابة برنامج على Go ومعالجة جميع الأخطاء.  سوف يقف البرنامج وكأنه قفاز ويعمل لعدة أشهر.  هذا صحيح ، لكننا لا نتعامل مع جميع الأخطاء. <br><br>  نحن أشخاص أحياء ، ولدينا دائمًا مواعيد نهائية ، والرغبة في القيام بشيء مفيد ، وعدم معالجة الخطأ 535 لهذا اليوم.  لا تتسبب الشفرة المليئة بمعالجة الأخطاء في الشعور بالمشاعر الدافئة لدى أي شخص. <br><br>  لذلك ، نكتب جميعًا "طريقًا سعيدًا" ، ومن ثم سنكتشفه في الإنتاج.  لنكن صادقين: فقط عندما تحتاج إلى معالجة شيء ما ، فإننا نبدأ في المعالجة.  البرمجة الدفاعية مختلفة قليلاً ، وليست تنمية تجارية. <br><br>  لذلك ، <strong>عندما يكون لدينا تحكم تلقائي عن الأخطاء - فهذا جيد</strong> .  لكن أنظمة التشغيل جاءت قبل 50 عامًا: إذا ماتت بعض العمليات ، فسيتم إغلاق كل شيء يفتح تلقائيًا.  اليوم لا يحتاج أي شخص إلى كتابة التعليمات البرمجية التي من شأنها تنظيف الملفات وراء العملية التي تم قتلها.  لم يكن هذا موجودًا منذ 50 عامًا في أي نظام تشغيل ، ولكن في بيثون لا تزال بحاجة إلى اتباع هذا بعناية وبعناية بيديك.  هذا غريب. <br><br>  <strong>يمكنك أن تأخذ الحوسبة الثقيلة في سياق مختلف</strong> ، ولكن يمكن بالفعل الانتقال إلى نواة أخرى.  شاركنا البيانات ، لم نعد نحتاج إلى مزاعم.  يمكنك إرسال البيانات في سياق مختلف ، قل: "ستقوم بذلك في مكان ما ، ثم أخبرني أنك قد انتهيت من القيام بشيء ما." <br><br>  <strong>تطبيق غير متزامن دون عبارة "async / تنتظر"</strong> .  مزيد من المساعدة قليلا من الجهاز الظاهري ، من وقت التشغيل.  هذا ما تحدثنا عنه مع <code>async/await</code> : يمكنك أيضًا التحويل إلى الرسائل وإزالة <code>async/await</code> والحصول عليها على مستوى الجهاز الظاهري. <br><br><h2 style=";text-align:right;direction:rtl">  عمليات إرلانج </h2><br>  تم ابتكار Erlang قبل 30 عامًا.  نظر الرجال الملتحون ، الذين لم يكونوا ملتحين جدًا في ذلك الوقت ، إلى UNIX ونقلوا جميع المفاهيم إلى لغة البرمجة.  لقد قرروا أن لديهم الآن ما ينامون به ليلاً وأن يذهبوا بصيد السمك بدون كمبيوتر.  ثم لم تكن هناك أجهزة كمبيوتر محمولة بعد ، لكن الرجال الملتحيين عرفوا بالفعل أنه ينبغي التفكير في ذلك مسبقًا. <br><br>  <strong>حصلنا على Erlang (Elixir) - سياقات نشطة تُنفذ نفسها</strong> .  كذلك مثالي على Erlang.  في Elixir ، تبدو متشابهة ، مع بعض الاختلافات. <br><br><pre style=";text-align:right;direction:rtl"> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">best_price</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Name)</span></span></span><span class="hljs-function"> -&gt;</span></span> Price1 = spawn_price_fetcher('market.yandex.ru', Name), Price2 = spawn_price_fetcher('ebay.com', Name), Price3 = spawn_price_fetcher('taobao.com', Name), lists:min(wait4([Price1,Price2,Price3])).</code> </pre> <br>  نطلق العديد من أدوات جلب - هذه هي العديد من السياقات الجديدة المنفصلة التي ننتظرها.  انتظروا وجمعوا البيانات وأعادوا النتيجة كحد أدنى للسعر.  كل هذا يشبه <code>async/await</code> ، ولكن بدون عبارة "المزامنة / الانتظار". <br><br><h3 style=";text-align:right;direction:rtl">  ملامح إكسير </h3><br>  يقع Elixir في قاعدة Erlang ، ويتم نقل جميع مفاهيم اللغة بهدوء إلى Elixir.  ما هي معالمه؟ <br><br>  <strong>حظر الروابط عبر المعالج.</strong>  أعني العملية عملية خفيفة الوزن داخل سياق افتراضي للجهاز.  المبسطة ، إذا تم نقلها إلى Python ، فإن ارتباطات البيانات داخل كائن آخر محظورة في Erlang.  يمكن أن يكون لديك رابط للكائن بالكامل كمربع مغلق ، لكن لا يمكنك الرجوع إلى البيانات الموجودة داخله.  لا يمكنك حتى الحصول على مؤشر إلى البيانات الموجودة داخل كائن آخر.  يمكنك فقط معرفة الكائن نفسه. <br><br>  <strong>لا توجد عمليات مزامنة داخل العمليات (الكائنات).</strong>  هذا أمر مهم - شخصيًا ، لا أريد أبدًا أن أتقاطع في حياتي مع تاريخ تصحيح أخطاء الرحلات المتعددة الخيوط إلى الإنتاج.  لا أتمنى هذا لأي شخص. <br><br>  <strong>يمكن أن تتحرك العمليات حول النوى ، إنها آمنة.</strong>  لم نعد بحاجة لتجاوز ، كما في Java ، مجموعة من <code>pointer</code> الأخرى وإعادة كتابتها عند نقل البيانات من مكان إلى آخر: ليس لدينا بيانات مشتركة وروابط داخلية.  على سبيل المثال ، من أين تأتي مشكلة نعومة الورك؟  بسبب حقيقة أن شخصا ما يشير إلى هذه البيانات. <br><br>  إذا قمنا بنقل البيانات داخل الكومة إلى موقع آخر للضغط ، فنحن بحاجة إلى المرور عبر النظام بأكمله.  يمكن أن تشغل عشرات الجيجابايت وتحديث جميع المؤشرات - وهذا مجنون. <br><br>  <strong>سلامة الخيط الكامل</strong> ، ويرجع ذلك إلى حقيقة أن كل الاتصالات يمر الرسائل.  عند استسلام كل هذا ، حصلنا <strong>على عملية إزالة مزاحمة</strong> .  لقد حصل عليها بسهولة ورخيصة. <br><br>  <strong>الرسائل كأساس للتواصل.</strong>  كائنات داخلية ومكالمات الوظائف العادية وبين كائنات الرسالة.  وصول البيانات من الشبكة هو رسالة ، واستجابة كائن آخر هي رسالة ، وشيء آخر في الخارج هو أيضًا رسالة في قائمة انتظار واردة.  هذا ليس على UNIX لأنه لم يتجذر. <br><br>  <strong>يدعو الأسلوب.</strong>  لدينا الكائنات التي نسميها العمليات.  يتم استدعاء أساليب العمليات من خلال الرسائل. <br><br>  <strong>طرق الاتصال هي أيضا إرسال رسالة.</strong>  انه لشيء رائع أنه الآن يمكن القيام به مع مهلة.  إذا كان هناك شيء يجيب علينا ببطء ، فإننا نسمي الأسلوب على كائن آخر.  لكن في الوقت نفسه ، نقول إننا على استعداد للانتظار أكثر من 60 ثانية ، لأن لدي عميل به مهلة 70 ثانية.  سأحتاج للذهاب وأقول له "503" - تعال غدًا ، والآن لا ينتظرونك. <br><br>  علاوة على ذلك ، <strong>يمكن تأجيل الرد على المكالمة</strong> .  داخل الكائن ، يمكنك قبول طلب الاتصال بالطريقة ، وقول: "نعم ، نعم ، سوف أضعك الآن ، أعود لنصف ساعة ، سأجيب عليك."  لا يمكنك التحدث ، ولكن بصمت جانبا.  نستخدمها في بعض الأحيان. <br><br><h3 style=";text-align:right;direction:rtl">  كيفية العمل مع الشبكة؟ </h3><br>  يمكنك كتابة التعليمات البرمجية الخطية أو عمليات الاسترجاعات أو بأسلوب <code>asyncio.gather</code> .  مثال على كيف سيبدو هذا. <br><br><pre style=";text-align:right;direction:rtl"> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wait4</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([ ])</span></span></span><span class="hljs-function"> -&gt;</span></span> [ ]; wait4(List) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">receive</span></span> {reply, Pid, Price} -&gt; [Price] ++ wait4(List -- [Pid]) <span class="hljs-keyword"><span class="hljs-keyword">after</span></span> <span class="hljs-number"><span class="hljs-number">60000</span></span> -&gt; [] <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>.</code> </pre> <br>  في دالة <code>wait4</code> من المثال السابق ، <code>wait4</code> على قائمة الأشخاص الذين ما زلنا في انتظار الإجابات.  في حالة استخدام طريقة <code>receive</code> نحصل على رسالة من تلك العملية ، نكتبها إلى القائمة.  إذا انتهت القائمة ، فإننا نرجع كل ما كان وجمع القائمة.  لقد طلبنا في الوقت نفسه ثلاثة أشياء لدفع البيانات إلينا.  إذا لم يتمكنوا من الإدارة معًا في 60 ثانية ، ولم يرد واحد منهم على الأقل على "موافق" ، فستكون لدينا قائمة فارغة.  ولكن من المهم أن يكون لدينا مهلة عامة لطلب فورًا لمجموعة كاملة من الكائنات. <br><br>  قد يقول شخص ما ، "فكر ، libcurl لديه نفس الشيء."  ولكن من المهم هنا أنه من ناحية أخرى ، لا يمكن أن يكون هناك فقط رحلة HTTP ، ولكن أيضًا رحلة DB ، وكذلك بعض العمليات الحسابية ، على سبيل المثال ، حساب نوع ما من الرقم الأمثل للعميل. <br><br><h3 style=";text-align:right;direction:rtl">  خطأ في التعامل </h3><br>  <strong>لقد مرت الأخطاء من الدفق إلى الكائن ، والتي هي الآن واحدة واحدة</strong> .  الآن يصبح الخطأ نفسه مرفقًا ليس بسلسلة الرسائل ، ولكن بالكائن الذي تم تنفيذه فيه. <br><br>  هذا هو أكثر منطقية بكثير.  عادة ، عندما نرسم جميع أنواع المربعات والدوائر الصغيرة على السبورة على أمل أن تعود إلى الحياة وتبدأ في جلب النتائج والمال ، فنحن عادةً ما نرسم كائنات ، وليس التدفقات التي سيتم تنفيذ هذه الأشياء فيها.  على سبيل المثال ، عند التسليم ، يمكننا استلام رسالة تلقائية <strong>حول وفاة كائن آخر</strong> . <br><br><h3 style=";text-align:right;direction:rtl">  التأمل أو التصحيح في الإنتاج </h3><br>  ما الذي يمكن أن يكون أجمل من الذهاب إلى المنتج والخصم ، لا سيما إذا كان الخطأ يحدث فقط تحت الحمل خلال ساعات الذروة.  في ساعة الذروة نقول: <br><br>  <em>- هيا ، سأعود الآن!</em> <br>  <em>- اخرج من الباب وهناك إعادة تشغيل لشخص آخر!</em> <br><br>  هنا يمكننا أن نذهب داخل نظام المعيشة الذي يعمل الآن وليس على استعداد لهذا الغرض.  للقيام بذلك ، لا تحتاج إلى إعادة تشغيله مع منشئ ملفات التعريف ، مع مصحح الأخطاء ، إعادة الإنشاء. <br><br>  <strong>بدون أي خسارة في الأداء في نظام الإنتاج المباشر ،</strong> يمكننا أن نرى قائمة من العمليات: ما بداخلها ، وكيف يعمل كل شيء ، ونفاياتها ، والتحقق مما يحدث لهم.  كل هذا مجاني من خارج منطقة الجزاء. <br><br><h3 style=";text-align:right;direction:rtl">  المكافآت </h3><br>  <strong>الكود هو السوبر موثوقة.</strong>  على سبيل المثال ، لدى Python هشاشة مع عدم <code>old vs async</code> ، وستبقى لمدة خمس سنوات ، وليس أقل.  بالنظر إلى السرعة التي تم بها تطبيق Python 3 ، يجب ألا تأمل أن تكون سريعة. <br><br>  <strong>قراءة وتتبع الرسائل أسهل من تصحيح عمليات الاسترجاعات</strong> .  هذا مهم.  يبدو أنه إذا كان لا يزال لدينا عمليات رد اتصال لمعالجة الرسائل التي يمكننا رؤيتها ، فما الأفضل؟  من خلال حقيقة أن الرسائل هي جزء من البيانات في الذاكرة.  يمكنك أن تنظر إليها بعيون وتفهم ما قد جاء هنا.  يمكن إضافته إلى التتبع ، والحصول على قائمة الرسائل في ملف نصي.  هذا هو أكثر ملاءمة من عمليات الاسترجاعات. <br><br>  <strong>رائع متعدد النواة</strong> ، وإدارة الذاكرة <strong>والتأمل داخل نظام</strong> الإنتاج <strong>المباشر</strong> . <br><br><h3 style=";text-align:right;direction:rtl">  المشاكل </h3><br>  بطبيعة الحال ، Erlang لديه أيضا مشاكل. <br><br>  <strong>فقد الأداء الأقصى</strong> بسبب حقيقة أنه لم يعد بإمكاننا الرجوع إلى البيانات في عملية أو كائن آخر.  يجب أن نتحرك ، لكن هذا ليس مجانيًا. <br><br>  <strong>مقدار الحمل لنسخ البيانات بين العمليات.</strong>  يمكننا أن نكتب برنامجًا في C يعمل على جميع المراكز الثمانين ويعالج صفيف بيانات واحدًا ، وسنفترض أنه يقوم بذلك بشكل صحيح وصحيح.  في Erlang ، لا يمكنك القيام بذلك: تحتاج إلى قطع البيانات بعناية ، وتوزيعها على مجموعة من العمليات ، وتتبع كل شيء.  هذا الاتصال يكلف الموارد - دورات المعالج. <br><br>  <strong>ما مدى سرعة أو بطء؟</strong>  نكتب كود Erlang منذ 10 سنوات.  المنافس الوحيد الذي نجا من هذه السنوات العشر هو مكتوب بلغة جافا.  معه ، لدينا تكافؤ شبه كامل في الأداء: يقول شخص ما أننا أسوأ ، شخص ما هو عليه.  لكن لديهم Java بكل مشاكله ، بدءًا من JIT. <br><br>  نكتب برنامجًا يخدم عشرات الآلاف من المقابس ويضخ عشرات غيغابايت من البيانات من خلال نفسه.  اتضح فجأة أنه في هذه الحالة ، تعد <strong>صحة الخوارزميات والقدرة على تصحيح كل هذا في الإنتاج أكثر أهمية من الكعك المحتمل لجافا</strong> .  لقد تم استثمار مليارات الدولارات فيها ، لكن هذا لا يمنح Java JIT أي مزايا سحرية. <br><br>  ولكن إذا أردنا قياس معايير غبية وغير منطقية ، مثل "حساب أرقام فيبوناتشي" ، فمن المحتمل أن يكون إرلانج هنا أسوأ من بيثون أو ما يمكن مقارنته. <br><br>  <strong>الحمل من تخصيص الرسالة.</strong>  في بعض الأحيان يضر.  على سبيل المثال ، لدينا بعض القطع في C في الشفرة ، وفي هذه الأماكن لم تنجح على الإطلاق مع Erlang.     ,      ,   . <br><br>    Erlang <strong>     </strong> ,   ,     .  ,    ,   <code>receive</code>  <code>send receive</code> .     —   ,   .   <strong> ,   ,    </strong> . <br><br><h2 style=";text-align:right;direction:rtl">      Python </h2><br> <strong>   </strong> .        .       ,       Python  -     . <br><br> ,  <strong>   </strong> .  -     Python,      ,    20 ,   40. <br><br> , <strong>   </strong>  . - , ,     Elixir,   ,      . <br><br><blockquote style=";text-align:right;direction:rtl">       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">Moscow Python Conf++</a> . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="></a>  ,         6      4   .  ,   ,  )     ) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="> </a>  . Call for Papers   13 ,     27 . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/ar476112/">https://habr.com/ru/post/ar476112/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar476102/index.html">اكتب العمل الآمن مع صفائف PHP</a></li>
<li><a href="../ar476104/index.html">لا تستخدم MTProxy مجانًا وأنواع أخرى من الوكلاء المجانية ...</a></li>
<li><a href="../ar476106/index.html">"بروتوكولات التشفير": Diffie - Hellman، El-Gamal، MTI / A (0)، STS</a></li>
<li><a href="../ar476108/index.html">الدماغ قابلة للتغيير</a></li>
<li><a href="../ar476110/index.html">لماذا تحتاج تقنية المعلومات إلى علامة تجارية شخصية؟</a></li>
<li><a href="../ar476114/index.html">ماذا لو بدون بيثون؟ جوليا للتعلم الآلي وعموما</a></li>
<li><a href="../ar476118/index.html">تصميم واجهة اللعبة ، ارسم خاتم Havel من Dark Souls 3</a></li>
<li><a href="../ar476122/index.html">"اسمع" الكون: من المادة المظلمة إلى المذنب Churyumov - Gerasimenko</a></li>
<li><a href="../ar476126/index.html">كيفية اختبار أداء الخادم: مجموعة مختارة من عدة معايير مفتوحة المصدر</a></li>
<li><a href="../ar476128/index.html">إيفان أوسيبوف ويوري أرتامونوف عن Kotlin والإضافات لـ IntelliJ IDEA في اجتماع jug.msk.ru</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>