<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçì üïë üë©üèº‚Äçüî¨ Kodein. Dasar-dasarnya ü§∏üèæ üå∞ üî°</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saya tidak menemukan panduan yang dapat dimengerti bagi mereka yang Kodein untuk pertama kalinya, dan dokumentasinya tidak transparan dan konsisten di...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kodein. Dasar-dasarnya</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/431696/"> Saya tidak menemukan panduan yang dapat dimengerti bagi mereka yang <code>Kodein</code> untuk pertama kalinya, dan dokumentasinya tidak transparan dan konsisten di semua tempat, jadi saya ingin berbagi fitur utama perpustakaan dengan Anda.  Beberapa fitur perpustakaan akan dirilis, tetapi ini pada dasarnya adalah bagian lanjutan.  Di sini Anda akan menemukan segalanya untuk memulai secara normal dan mulai menerapkan dependensi dengan <code>Kodein</code> saat Anda membaca artikel.  Artikel ini didasarkan pada <code>Kodein 5.3.0</code> , karena <code>Kodein 6.0.0</code> memerlukan <code>Support Library 28</code> atau <code>AndroidX</code> dan tidak berarti semua orang akan beralih ke mereka karena banyak perpustakaan pihak ketiga belum menawarkan versi yang kompatibel. <br><img src="https://habrastorage.org/webt/uj/ve/am/ujveamkhrxko4wle8mcfugfzjvc.png"><br><a name="habracut"></a><br>  <code>Kodein</code> adalah pustaka untuk mengimplementasikan injeksi ketergantungan (DI).  Jika Anda tidak terbiasa dengan konsep ini, maka bacalah bagian awal <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel tentang Dagger2</a> , di mana penulis secara singkat menjelaskan aspek teoritis dari DI. <br><br>  Pada artikel ini, kami akan mempertimbangkan semuanya dengan contoh Android, tetapi, menurut pengembang, Kodein berlaku sama pada semua platform yang didukung oleh Kotlin (JVM, Android, JS, Native). <br><br><h3>  Instalasi </h3><br>  Karena fakta bahwa Java memiliki <code>type erasure</code> , muncul masalah - kompiler menghapus tipe generik.  Pada level bytecode, <code>List&lt;String&gt;</code> dan <code>List&lt;Date&gt;</code> hanyalah <code>List</code> .  Meski begitu, masih ada cara untuk mendapatkan informasi tentang tipe generik, tetapi biayanya akan banyak dan hanya berfungsi pada JVM dan Android.  Dalam hal ini, pengembang <code>Kodein</code> menyarankan untuk menggunakan salah satu dari dua dependensi: satu menerima informasi tentang tipe umum ( <code>kodein-generic</code> ) saat bekerja, dan yang lainnya tidak ( <code>kodein-erased</code> ).  Misalnya, ketika menggunakan <code>List&lt;String&gt;</code> <code>kodein-erased</code> <code>List&lt;String&gt;</code> dan <code>List&lt;Date</code> &gt; akan disimpan sebagai <code>List&lt;*&gt;</code> , dan ketika menggunakan <code>kodein-generic</code> semuanya akan disimpan bersama dengan tipe yang ditentukan, yaitu, seperti <code>List&lt;String&gt;</code> dan <code>List&lt;Date&gt;</code> masing-masing. <br><br>  Bagaimana memilih? <br><br>  Tulis <b>tidak di</b> bawah JVM - gunakan <code>kodein-erased</code> , kalau tidak, tidak mungkin. <br>  Tulis di bawah JVM dan masalah kinerja sangat penting bagi Anda - Anda dapat menggunakan <code>kodein-erased</code> , tetapi hati-hati, pengalaman ini mungkin tidak terduga dalam arti buruk dari kata-kata ini.  Jika Anda membuat aplikasi reguler tanpa persyaratan kinerja khusus, gunakan <code>kodein-generic</code> . <br><br>  Pada akhirnya, jika Anda memikirkan dampak DI terhadap kinerja, maka paling sering sebagian besar dependensi dibuat satu kali, atau dependensi dibuat untuk digunakan kembali berulang kali, kecil kemungkinannya dengan tindakan seperti itu Anda dapat sangat mempengaruhi kinerja aplikasi Anda. <br><br>  Jadi, instal: <br><br>  Pertama - di build.gradle di antara repositori harus jcenter (), jika tidak ada - tambahkan. <br><br><pre> <code class="plaintext hljs">buildscript { repositories { jcenter() } }</code> </pre><br>  Selanjutnya, di blok dependensi, tambahkan salah satu dependensi dasar yang disebutkan di atas: <br><br><pre> <code class="plaintext hljs">implementation "org.kodein.di:kodein-di-generic-jvm:$version"</code> </pre><br><pre> <code class="plaintext hljs">implementation "org.kodein.di:kodein-di-erased-jvm:$version"</code> </pre><br>  Karena kita berbicara tentang Android, akan ada lebih banyak ketergantungan.  Anda tentu saja dapat melakukannya tanpa itu, Kodein akan berfungsi secara normal, tetapi mengapa menolak fitur tambahan yang berguna untuk Android (saya akan membicarakannya di akhir artikel)?  Pilihan ada di tangan Anda, tetapi saya ingin menambahkan. <br><br>  Ada juga opsi di sini. <br><br>  Pertama, Anda tidak menggunakan <code>SupportLibrary</code> <br><br><pre> <code class="plaintext hljs">implementation "org.kodein.di:kodein-di-framework-android-core:$version"</code> </pre><br>  Yang kedua - gunakan <br><br><pre> <code class="plaintext hljs">implementation "org.kodein.di:kodein-di-framework-android-support:$version"</code> </pre><br>  Ketiga - Anda menggunakan AndroidX <br><br><pre> <code class="plaintext hljs">implementation "org.kodein.di:kodein-di-framework-android-x:$version"</code> </pre><br><h3>  Kami mulai membuat dependensi </h3><br>  Menggunakan <code>Dagger2</code> , saya terbiasa membuat dan menginisialisasi dependensi saat startup aplikasi, di kelas Aplikasi. <br><br>  Dengan Kodein, ini dilakukan seperti ini: <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyApp</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Application</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein = Kodein { <span class="hljs-comment"><span class="hljs-comment">/*  */</span></span> } }</code> </pre><br>  Deklarasi ketergantungan selalu dimulai dengan <br><br><pre> <code class="kotlin hljs">bind&lt;TYPE&gt;() with</code> </pre><br><h4>  Tag </h4><br>  Penandaan ketergantungan kodein adalah fitur yang serupa dalam fungsionalitas dengan <code>Qualifier</code> dari <code>Dagger2</code> .  Di <code>Dagger2</code> Anda harus melakukan <code>Qualifier</code> terpisah atau menggunakan <code>@Named("someTag")</code> , yang sebenarnya juga merupakan <code>Qualifier</code> .  Intinya sederhana - dengan cara ini Anda membedakan dua dependensi dari tipe yang sama.  Misalnya, Anda perlu mendapatkan <code>ontext</code> aplikasi atau <code>Activity</code> tertentu tergantung pada situasinya, oleh karena itu Anda perlu menentukan tag untuk ini ketika mendeklarasikan dependensi.  <code>Kodein</code> memungkinkan <code>Kodein</code> untuk mendeklarasikan satu dependensi tanpa tag, itu akan menjadi base satu dan jika Anda tidak menentukan tag ketika menerima dependensi, kami akan mendapatkannya, yang lain harus ditandai dan ketika dependensi diterima, tag perlu ditentukan. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein = Kodein { bind&lt;Context&gt;() with ... bind&lt;Context&gt;(tag = <span class="hljs-string"><span class="hljs-string">"main_activity"</span></span>) with ... bind&lt;Context&gt;(tag = <span class="hljs-string"><span class="hljs-string">"sale_activity"</span></span>) with ... }</code> </pre><br>  Parameter <code>tag</code> bertipe <code>Any</code> , jadi Anda bisa menggunakan lebih dari sekadar string.  Tapi ingat bahwa kelas yang digunakan sebagai tag harus mengimplementasikan metode <code>equals</code> dan <code>hashCode</code> .  Selalu diperlukan untuk meneruskan tag ke fungsi sebagai argumen bernama, terlepas dari apakah Anda membuat ketergantungan atau menerimanya. <br><br><h3>  Jenis Injeksi Ketergantungan </h3><br>  Ada beberapa cara untuk menyediakan dependensi dalam <code>Kodein</code> , <code>Kodein</code> dengan hal-hal penting - membuat singletones.  Singleton akan hidup dalam kerangka instancein <code>Kodein</code> dibuat. <br><br><h4>  Memperkenalkan singleton </h4><br>  Mari kita mulai dengan sebuah contoh: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein = Kodein { bind&lt;IMyDatabase&gt;() with singleton { RoomDb() } }</code> </pre><br>  Dengan demikian kami menyediakan (menyediakan) <code>IMyDatabase</code> , di belakangnya sebuah instance dari <code>RoomDb</code> akan disembunyikan.  Sebuah instance dari <code>RoomDb</code> akan dibuat atas permintaan dependensi pertama, itu tidak akan <code>Kodein</code> sampai instance <code>Kodein</code> baru <code>Kodein</code> .  Singleton dibuat tersinkronisasi, tetapi jika diinginkan, ia dapat dibuat tidak disinkronkan.  Ini akan meningkatkan produktivitas, tetapi Anda harus memahami risiko yang mengikutinya. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein = Kodein { bind&lt;IMyDatabase&gt;() with singleton(sync = <span class="hljs-literal"><span class="hljs-literal">false</span></span>) { RoomDb() } }</code> </pre><br>  Jika Anda perlu membuat instance dependensi bukan pada panggilan pertama, tetapi segera setelah membuat instance <code>Kodein</code> , gunakan fungsi lain: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein = Kodein { bind&lt;IMyDatabase&gt;() with eagerSingleton { RoomDb() } }</code> </pre><br><h4>  Secara terus-menerus menciptakan contoh baru ketergantungan </h4><br>  Dimungkinkan untuk membuat bukan singletones, tetapi secara konstan ketika mengakses dependensi untuk mendapatkan instance baru darinya.  Untuk ini, fungsi <code>provider</code> digunakan: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein = Kodein { bind&lt;IMainPresenter&gt;() with provider { QuantityPresenter() } }</code> </pre><br>  Dalam hal ini, setiap kali kami meminta ketergantungan <code>IMainPresenter</code> , instance baru dari <code>QuantityPresenter</code> akan dibuat. <br><br><h4>  Secara konstan membuat instance baru dependensi dan meneruskan parameter ke konstruktor dependensi </h4><br>  Anda bisa mendapatkan instance baru setiap kali Anda menambahkan dependensi, seperti pada contoh sebelumnya, tetapi tentukan parameter untuk membuat dependensi.  Parameter bisa maksimal <b>5</b> .  Untuk perilaku ini, gunakan metode <code>factory</code> . <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein = Kodein { bind&lt;IColorPicker&gt;() with factory { r: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, g: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, b: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, a: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> -&gt; RgbColorPicker(r, g, b, a) } }</code> </pre><br><h4>  Setiap kali kami membuat contoh cache tergantung pada parameter </h4><br>  Membaca paragraf sebelumnya, Anda mungkin berpikir bahwa akan lebih baik untuk menerima bukan instance baru setiap kali sesuai dengan parameter yang diteruskan, tetapi untuk menerima instance ketergantungan yang sama pada parameter yang sama. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein = Kodein { bind&lt;IRandomIntGenerator&gt;() with multiton { from: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, to: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> -&gt; IntRandom(from, to) } }</code> </pre><br>  Pada contoh di atas, ketika kita pertama kali mendapatkan dependensi dengan parameter <code>5</code> dan <code>10</code> kita akan membuat instance baru dari <code>IntRandom(5, 10)</code> , ketika kita memanggil dependensi lagi dengan parameter yang sama, kita akan mendapatkan instance yang dibuat sebelumnya.  Dengan demikian, <code>map</code> dari singleton dengan inisialisasi malas diperoleh.  Argumen, seperti dalam kasus <code>factory</code> maksimum <b>5</b> . <br><br>  Seperti halnya singletones, Anda dapat menonaktifkan sinkronisasi di sini. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein = Kodein { bind&lt;IRandomIntGenerator&gt;() with multiton(sync = <span class="hljs-literal"><span class="hljs-literal">false</span></span>) { from: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, to: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> -&gt; IntRandom(from, to) } }</code> </pre><br><h4>  Menggunakan Tautan Lunak dan Lemah pada Kodein </h4><br>  Saat memberikan dependensi menggunakan <code>singleton</code> atau <code>multiton</code> Anda dapat menentukan jenis referensi ke instance tersimpan.  Dalam kasus biasa, yang kami pertimbangkan di atas - ini akan menjadi tautan <code>strong</code> biasa.  Namun dimungkinkan untuk menggunakan tautan <code>soft</code> dan <code>weak</code> .  Jika Anda baru mengenal konsep-konsep ini, silakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lihat di sini</a> . <br><br>  Dengan demikian, lajang Anda dapat diciptakan kembali sebagai bagian dari siklus hidup aplikasi, atau mungkin juga tidak. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein = Kodein { bind&lt;IMyMap&gt;() with singleton(ref = softReference) { WorldMap() } bind&lt;IClient&gt;() with singleton(ref = weakReference) { id -&gt; clientFromDB(id) } }</code> </pre><br><h4>  Pisahkan singleton untuk setiap aliran </h4><br>  Ini adalah singleton yang sama, tetapi untuk setiap utas yang meminta ketergantungan, singleton akan dibuat.  Untuk melakukan ini, gunakan <code>ref</code> parameter yang dikenal. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein = Kodein { bind&lt;Cache&gt;() with singleton(ref = threadLocal) { LRUCache(<span class="hljs-number"><span class="hljs-number">16</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>) } }</code> </pre><br><h4>  Konstanta sebagai Ketergantungan yang Dapat Disematkan </h4><br>  Anda dapat memberikan konstanta sebagai dependensi.  Dokumentasi menarik perhatian pada fakta bahwa dengan <code>Kodein</code> Anda harus <code>Kodein</code> konstanta tipe sederhana tanpa pewarisan atau antarmuka, misalnya kelas primitif atau data. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein = Kodein { constant(tag = <span class="hljs-string"><span class="hljs-string">"maxThread"</span></span>) with <span class="hljs-number"><span class="hljs-number">8</span></span> constant(tag = <span class="hljs-string"><span class="hljs-string">"serverURL"</span></span>) with <span class="hljs-string"><span class="hljs-string">"https://my.server.url"</span></span></code> </pre><br><h4>  Buat dependensi tanpa mengubah jenisnya </h4><br>  Misalnya, Anda ingin memberikan dependensi sebagai singleton, tetapi jangan menyembunyikannya di belakang antarmuka.  Anda tidak bisa menentukan jenisnya saat memanggil <code>bind</code> dan menggunakan <code>from</code> alih-alih <code>with</code> . <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein = Kodein { bind() from singleton { Gson() }</code> </pre><br>  Ketergantungan pada contoh di atas akan memiliki tipe kembalinya fungsi, yaitu, ketergantungan tipe <code>Gson</code> akan <code>Gson</code> . <br><br><h4>  Buat dependensi subclass dari superclass atau antarmuka </h4><br>  <code>Kodein</code> memungkinkan <code>Kodein</code> untuk memberikan ketergantungan dengan cara yang berbeda untuk keturunan dari kelas atau kelas tertentu yang mengimplementasikan antarmuka tunggal. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein = Kodein { bind&lt;Animal&gt;().subTypes() with { animalType -&gt; <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (animalType.jvmType) { Dog::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">eagerSingleton</span></span></span><span class="hljs-class"> </span></span>{ Dog() } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; provider { WildAnimal(animalType) } } }</code> </pre><br>  Kelas <code>Animal</code> dapat berupa superclass atau antarmuka, dengan menggunakan <code>.subtypes</code> kita mendapatkan <code>animalType</code> tipe <code>TypeToken&lt;*&gt;</code> , dari mana kita bisa mendapatkan kelas Java dan, tergantung padanya, memberikan ketergantungan dengan berbagai cara.  Fitur ini dapat berguna jika Anda menggunakan <code>TypeToken</code> atau turunannya sebagai parameter konstruktor untuk sejumlah kasus.  Juga dengan cara ini Anda dapat menghindari kode yang tidak perlu dengan pembuatan dependensi yang sama untuk berbagai jenis. <br><br><h4>  Buat dependensi yang membutuhkan dependensi lain sebagai parameter </h4><br>  Paling sering, kita tidak hanya membuat kelas tanpa parameter sebagai dependensi, tetapi membuat kelas yang kita perlukan untuk meneruskan parameter ke konstruktor. <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProductGateway</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> api: IProductApi, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> dispatchers: IDispatchersContainer) : IProductGateway</code> </pre><br>  Untuk membuat kelas dengan dependensi yang sebelumnya dibuat dalam <code>Kodein</code> cukup untuk melewati fungsi panggilan instance () sebagai parameter.  Dalam hal ini, urutan penciptaan tidak penting. <br><br><pre> <code class="kotlin hljs">bind&lt;IDispatchersContainer&gt;() with singleton { DispatchersContainer() } bind&lt;IProductGateway&gt;() with singleton { ProductGateway(instance(), instance()) } bind&lt;IProductApi&gt;() with singleton { ProductApi() }</code> </pre><br>  Alih-alih <code>instance()</code> mungkin ada panggilan ke <code>provider()</code> atau <code>factory()</code> ; kami akan melihat lebih dekat pada metode ini di bagian tentang memperoleh dan mengimplementasikan dependensi. <br><br><h4>  Buat ketergantungan dengan memanggil metode ketergantungan yang dibuat sebelumnya </h4><br>  Kedengarannya tidak terlalu bagus, tetapi Anda dapat memanggil <code>instance&lt;TYPE&gt;</code> untuk mendapatkan kelas yang sudah kami sediakan di suatu tempat dan memanggil metode kelas ini untuk mendapatkan ketergantungan baru. <br><br><pre> <code class="kotlin hljs">bind&lt;DataSource&gt;() with singleton { MySQLDataSource() } bind&lt;Connection&gt;() with provider { instance&lt;DataSource&gt;().openConnection() }</code> </pre><br><h3>  Modul </h3><br>  Menggunakan <code>Dagger2</code> , saya terbiasa <code>Dagger2</code> dependensi <code>Dagger2</code> .  Dalam <code>Kodein</code> , pada pandangan pertama, semuanya tidak terlihat sangat bagus.  Anda perlu membuat banyak dependensi tepat di kelas <code>Application</code> , dan saya pribadi tidak begitu menyukainya.  Tapi ada solusinya, <code>Kodein</code> juga memungkinkan Anda membuat modul, dan kemudian menghubungkannya di tempat-tempat yang diperlukan. <br><br><pre> <code class="kotlin hljs"> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> appModule = Kodein.Module(<span class="hljs-string"><span class="hljs-string">"app"</span></span>) { bind&lt;Gson&gt;() with singleton { provideGson() } bind&lt;HttpClient&gt;() with singleton { provideHttpClient() } } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein = Kodein { <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(appModule) bind&lt;ISchedulersContainer&gt;() with singleton { SchedulersContainer() } <span class="hljs-comment"><span class="hljs-comment">//   }</span></span></code> </pre><br>  Tapi hati-hati, modul hanyalah wadah yang menyatakan metode untuk mendapatkan dependensi, mereka sendiri tidak membuat kelas.  Oleh karena itu, jika Anda mendeklarasikan penerimaan ketergantungan sebagai singleton dalam modul, dan kemudian mengimpor modul ini ke dalam dua contoh berbeda dari <code>Kodein</code> , maka Anda akan mendapatkan dua singlet yang berbeda, satu per instance dari <code>Kodein</code> . <br><br>  Juga, nama setiap modul harus unik.  Namun, jika Anda perlu mengimpor modul dari proyek lain, sulit untuk menjamin keunikan nama, karena ini, Anda dapat mengganti nama modul atau menambahkan awalan ke namanya. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(apiModule.copy(name = <span class="hljs-string"><span class="hljs-string">"firstAPI"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(secondApiModule.copy(prefix = <span class="hljs-string"><span class="hljs-string">"secondAPI-"</span></span>))</code> </pre><br>  Saya terbiasa bekerja ketika modul-modul saling bergantung satu sama lain dan membentuk semacam hierarki.  <code>Kodein</code> dapat mengimpor setiap modul ke dalam <code>Kodein</code> sekali, oleh karena itu, jika Anda mencoba mengimpor dua modul yang memiliki modul dependen yang sama ke dalam satu <code>Kodein</code> , aplikasi akan macet.  Solusinya sederhana - Anda perlu menggunakan <code>importOnce(someModule)</code> untuk mengimpor, yang akan memeriksa apakah modul dengan nama yang sama sebelumnya diimpor, dan kemudian impor jika perlu. <br><br>  Misalnya, dalam kasus seperti itu, aplikasi akan macet: <br><br><pre> <code class="kotlin hljs"> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> appModule = Kodein.Module(<span class="hljs-string"><span class="hljs-string">"app"</span></span>) { bind&lt;Gson&gt;() with singleton { provideGson() } } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> secondModule = Kodein.Module(<span class="hljs-string"><span class="hljs-string">"second"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(appModule) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> thirdModule = Kodein.Module(<span class="hljs-string"><span class="hljs-string">"third"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(appModule) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein = Kodein { <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(secondModule) <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(thirdModule) }</code> </pre><br><pre> <code class="kotlin hljs"> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> appModule = Kodein.Module(<span class="hljs-string"><span class="hljs-string">"app"</span></span>) { bind&lt;Gson&gt;() with singleton { provideGson() } } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> secondModule = Kodein.Module(<span class="hljs-string"><span class="hljs-string">"second"</span></span>) { importOnce(appModule) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> thirdModule = Kodein.Module(<span class="hljs-string"><span class="hljs-string">"third"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(appModule) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein = Kodein { <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(secondModule) <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(thirdModule) }</code> </pre><br>  Tetapi jika panggilan <code>importOnce</code> melakukan upaya koneksi kedua, maka semuanya akan berfungsi.  Berhati-hatilah. <br><br><pre> <code class="kotlin hljs"> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> appModule = Kodein.Module(<span class="hljs-string"><span class="hljs-string">"app"</span></span>) { bind&lt;Gson&gt;() with singleton { provideGson() } } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> secondModule = Kodein.Module(<span class="hljs-string"><span class="hljs-string">"second"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(appModule) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> thirdModule = Kodein.Module(<span class="hljs-string"><span class="hljs-string">"third"</span></span>) { importOnce(appModule) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein = Kodein { <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(secondModule) <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(thirdModule) }</code> </pre><br><h4>  Warisan </h4><br>  Jika Anda menggunakan modul yang sama dua kali, dependensi yang berbeda akan dibuat, tetapi bagaimana dengan pewarisan dan perilaku implementasi yang mirip dengan <code>Subcomponents</code> di <code>Dagger2</code> ?  Semuanya sederhana, Anda hanya perlu mewarisi dari instance <code>Kodein</code> dan Anda akan mendapatkan akses ke semua dependensi induk dalam pewarisnya. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein = Kodein { bind&lt;ISchedulersContainer&gt;() with singleton { SchedulersContainer() } <span class="hljs-comment"><span class="hljs-comment">//   } val subKodein = Kodein { extend(kodein) //   }</span></span></code> </pre><br><h4>  Redefinisi </h4><br>  Secara default, Anda tidak bisa mengesampingkan dependensi, jika tidak, pengguna akan menjadi gila mencari alasan agar aplikasi tidak berfungsi dengan benar.  Tetapi dimungkinkan untuk melakukan ini menggunakan parameter tambahan dari fungsi <code>bind</code> .  Fungsi ini akan bermanfaat, misalnya, untuk mengatur pengujian. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein = Kodein { bind&lt;Api&gt;() with singleton { ApiImpl() } <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> bind&lt;Api&gt;(overrides = <span class="hljs-literal"><span class="hljs-literal">true</span></span>) with singleton { OtherApiImpl() } }</code> </pre><br>  Secara default, modul dan dependensinya tidak dapat mengesampingkan dependensi yang sudah dideklarasikan dalam objek <code>Kodein</code> , tetapi ketika mengimpor modul, Anda dapat menentukan bahwa dependensinya dapat ditimpa oleh yang sudah ada, dan di dalam modul ini Anda sudah dapat menentukan dependensi yang dapat ditimpa oleh orang lain. <br><br>  Kedengarannya tidak terlalu jelas, mari kita gunakan contoh.  Dalam kasus ini, aplikasi akan macet: <br><br><pre> <code class="kotlin hljs"> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> appModule = Kodein.Module(<span class="hljs-string"><span class="hljs-string">"app"</span></span>) { bind&lt;Gson&gt;() with singleton { provideGson() } } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein = Kodein { bind&lt;Gson&gt;() with singleton { provideGson() } <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(appModule) }</code> </pre><br><pre> <code class="kotlin hljs"> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> appModule = Kodein.Module(<span class="hljs-string"><span class="hljs-string">"app"</span></span>) { bind&lt;Gson&gt;() with singleton { provideGson() } } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein = Kodein { bind&lt;Gson&gt;() with singleton { provideGson() } <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(appModule, allowOverride = <span class="hljs-literal"><span class="hljs-literal">true</span></span>) }</code> </pre><br>  Dan dalam hal ini, dependensi modul menimpa dependensi yang dideklarasikan dalam objek <code>Kodein</code> . <br><br><pre> <code class="kotlin hljs"> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> appModule = Kodein.Module(<span class="hljs-string"><span class="hljs-string">"app"</span></span>) { bind&lt;Gson&gt;(overrides = <span class="hljs-literal"><span class="hljs-literal">true</span></span>) with singleton { provideGson() } } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein = Kodein { bind&lt;Gson&gt;() with singleton { provideGson() } <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(appModule, allowOverride = <span class="hljs-literal"><span class="hljs-literal">true</span></span>) }</code> </pre><br>  Tetapi jika Anda benar-benar ingin dan Anda mengerti apa yang Anda lakukan, maka Anda dapat membuat modul itu, jika ada dependensi identik dengan objek <code>Kodein</code> akan mendefinisikannya kembali dan aplikasi tidak akan crash.  Kami menggunakan parameter <code>allowSilentOverride</code> untuk modul. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> testModule = Kodein.Module(name = <span class="hljs-string"><span class="hljs-string">"test"</span></span>, allowSilentOverride = <span class="hljs-literal"><span class="hljs-literal">true</span></span>) { bind&lt;EmailClient&gt;() with singleton { MockEmailClient() } }</code> </pre><br>  Dokumentasi membahas situasi yang lebih kompleks dengan pewarisan dan pendefinisian ulang dependensi, serta dengan menyalin ketergantungan pada ahli waris, tetapi situasi ini tidak akan dipertimbangkan di sini. <br><br><h3>  Mengambil dan menyuntikkan dependensi </h3><br>  Akhirnya, kami menemukan cara mendeklarasikan dependensi dalam banyak cara, saatnya mencari cara untuk mendapatkannya di kelas mereka. <br><br>  Pengembang <code>Kodein</code> berbagi dua cara untuk mendapatkan dependensi - <code>injection</code> dan <code>retieval</code> .  Singkatnya, <code>injection</code> adalah ketika kelas menerima semua dependensi ketika dibuat, yaitu, di konstruktor, dan <code>retrieval</code> adalah ketika kelas itu sendiri bertanggung jawab untuk mendapatkan dependensinya. <br><br>  Saat menggunakan <code>injection</code> kelas Anda tidak tahu apa-apa tentang <code>Kodein</code> dan kode di kelas lebih bersih, tetapi jika Anda menggunakan <code>retrieval</code> , maka Anda memiliki kesempatan untuk mengelola dependensi secara lebih fleksibel.  Dalam hal <code>retrieval</code> semua dependensi diperoleh dengan malas, hanya pada saat banding pertama terhadap dependensi. <br><br><h4>  Metode <code>Kodein</code> untuk Menggunakan Dependensi </h4><br>  Sebuah instance dari kelas <code>Kodein</code> memiliki tiga metode yang mengembalikan dependensi, pabrik dependensi, atau penyedia dependensi - <code>instance()</code> , <code>factory()</code> dan <code>provider()</code> masing-masing.  Jadi, jika Anda memberikan ketergantungan menggunakan <code>factory</code> atau <code>provider</code> , maka Anda tidak hanya dapat menerima hasil dari eksekusi fungsi, tetapi juga fungsi itu sendiri.  Ingatlah bahwa Anda dapat menggunakan tag di semua variasi. <br><br><pre> <code class="kotlin hljs"> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein = Kodein { bind&lt;BigDecimal&gt;() with factory { value: String -&gt; BigDecimal(value) } bind&lt;Random&gt;() with provider { Random() } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> number: BigDecimal <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> instance(arg = <span class="hljs-string"><span class="hljs-string">"23.87"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> numberFactory: (value: String) -&gt; BigDecimal <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> factory() <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> random: Random <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> instance() <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> randomProvider: () -&gt; Random <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> provider()</code> </pre><br><h4>  Ketergantungan injeksi melalui konstruktor </h4><br>  Seperti yang sudah Anda pahami, ini tentang <code>injection</code> .  Untuk mengimplementasikan, Anda harus terlebih dahulu mengambil semua dependensi kelas ke dalam konstruktornya, dan kemudian membuat instance kelas dengan memanggil <code>kodein.newInstance</code> <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProductApi</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> client: HttpClient, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> gson: Gson) : IProductApi <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Application</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Application</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein = Kodein { bind&lt;Gson&gt;() with singleton { provideGson() } bind&lt;HttpClient&gt;() with singleton { provideHttpClient() } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> productApi: IProductApi <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> kodein.newInstance { ProductApi(instance(), instance()) } }</code> </pre><br><h4>  Ketergantungan injeksi dalam sifat yang dapat dibatalkan </h4><br>  Mungkin Anda tidak tahu apakah dependensi telah diumumkan.  Jika dependensi tidak dideklarasikan dalam instance <code>Kodein</code> , maka kode dari contoh di atas akan menghasilkan <code>Kodein.NotFoundException</code> .  Jika Anda ingin mendapatkan <code>null</code> sebagai hasilnya, jika tidak ada ketergantungan, maka ada tiga fungsi tambahan untuk ini: <code>instanceOrNull()</code> , <code>factoryOrNull()</code> dan <code>providerOrNull()</code> . <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProductApi</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> client: HttpClient?, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> gson: Gson) : IProductApi <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Application</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Application</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein = Kodein { bind&lt;Gson&gt;() with singleton { provideGson() } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> productApi: IProductApi <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> kodein.newInstance { ProductApi(instanceOrNull(), instance()) } }</code> </pre><br><h4>  Dapatkan dependensi di dalam kelas. </h4><br>  Seperti yang telah disebutkan, dalam kasus ketika kita menggunakan <code>retrieval</code> , inisialisasi semua dependensi secara default malas.  Ini memungkinkan Anda untuk mendapatkan dependensi hanya saat dibutuhkan, dan mendapatkan dependensi di kelas yang dibuat oleh sistem. <br><br>  <code>Activity</code> , <code>Fragment</code> dan kelas-kelas lain dengan siklus hidup mereka sendiri, semua tentang mereka. <br><br>  Untuk menerapkan dependensi dalam <code>Activity</code> kita hanya perlu tautan ke instance Kodein, setelah itu kita dapat menggunakan metode yang terkenal.  Bahkan, Anda telah melihat contoh <code>retrieval</code> atas, Anda hanya perlu mendeklarasikan properti dan mendelegasikannya ke salah satu fungsi: <code>instance()</code> , <code>factory()</code> atau <code>provider()</code> <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> number: BigDecimal <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> kodein.instance(arg = <span class="hljs-string"><span class="hljs-string">"23.87"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> numberFactory: (value: String) -&gt; BigDecimal <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> kodein.factory() <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> random: Random? <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> kodein.instanceOrNull() <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> randomProvider: (() -&gt; Random)? <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> kodein.providerOrNull()</code> </pre><br><h4>  Melewati parameter ke pabrik </h4><br>  Anda telah melihat bahwa untuk mengirimkan parameter ke pabrik, cukup menggunakan parameter <code>arg</code> dari fungsi <code>instance</code> .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tetapi bagaimana jika ada beberapa parameter (saya katakan sebelumnya bahwa bisa ada hingga </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> parameter di pabrik </font><font style="vertical-align: inherit;">)? </font><font style="vertical-align: inherit;">Anda hanya perlu meneruskan </font></font><code>arg</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kelas </font><font style="vertical-align: inherit;">ke parameter </font></font><code>M</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang memiliki konstruktor kelebihan beban dan dapat mengambil dari 2 hingga 5 argumen.</font></font><br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein = Kodein { bind&lt;IColorPicker&gt;() with factory { r: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, g: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, b: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, a: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> -&gt; RgbColorPicker(r, g, b, a) } } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> picker: IColorPicker <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> kodein.instance(arg = M(<span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">211</span></span>, <span class="hljs-number"><span class="hljs-number">175</span></span>, <span class="hljs-number"><span class="hljs-number">215</span></span>))</code> </pre><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Inisialisasi dependensi ketergantungan </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seperti yang mereka katakan - secara default, inisialisasi malas, tetapi Anda dapat membuat pemicu, mengikatnya ke properti, beberapa properti atau seluruh instance </font></font><code>Kodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, setelah menarik pemicu ini dan dependensi akan diinisialisasi.</font></font><br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> myTrigger = KodeinTrigger() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> gson: Gson <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> kodein.on(trigger = myTrigger).instance() <span class="hljs-comment"><span class="hljs-comment">/*...*/</span></span> myTrigger.trigger() <span class="hljs-comment"><span class="hljs-comment">//     Gson</span></span></code> </pre><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> myTrigger = KodeinTrigger() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodeinWithTrigger = kodein.on(trigger = myTrigger) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> gson: Gson <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> kodeinWithTrigger.instance() <span class="hljs-comment"><span class="hljs-comment">/*...*/</span></span> myTrigger.trigger() <span class="hljs-comment"><span class="hljs-comment">//        kodeinWithTrigger</span></span></code> </pre><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lazy Kodein misalnya pembuatan </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sebelum itu, kami secara konstan membuat instance </font></font><code>Kodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, tetapi dimungkinkan untuk menunda inisialisasi properti ini menggunakan kelas </font></font><code>LazyKodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang mengambil fungsi dalam konstruktor yang harus mengembalikan objek </font></font><code>Kodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pendekatan ini dapat berguna jika, misalnya, tidak diketahui apakah dependensi dari instance Kodein tertentu diperlukan.</font></font><br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein = LazyKodein { Kodein { bind&lt;BigDecimal&gt;() with factory { value: String -&gt; BigDecimal(value) } bind&lt;Random&gt;() with provider { Random() } } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> number: BigDecimal <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> kodein.instance(arg = <span class="hljs-string"><span class="hljs-string">"13.4"</span></span>) <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> number.toPlainString() <span class="hljs-comment"><span class="hljs-comment">//     kodein   </span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Panggilan ke Kodein.lazy akan menghasilkan hasil yang serupa. </font></font><br><br><pre> <code class="kotlin hljs"> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein = Kodein.lazy { bind&lt;BigDecimal&gt;() with factory { value: String -&gt; BigDecimal(value) } bind&lt;Random&gt;() with provider { Random() } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> number: BigDecimal <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> kodein.instance(arg = <span class="hljs-string"><span class="hljs-string">"13.4"</span></span>) <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> number.toPlainString() <span class="hljs-comment"><span class="hljs-comment">//     kodein   </span></span></code> </pre><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Inisialisasi Kodein Tertunda </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk inisialisasi tertunda, </font></font><code>Kodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ada objek </font></font><code>LateInitKodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Anda bisa membuat objek ini, mendelegasikan pembuatan properti padanya, dan setelah Anda menginisialisasi objek itu sendiri, atur properti itu </font></font><code>baseKodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, setelah itu Anda sudah bisa mengakses dependensi.</font></font><br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein = LateInitKodein() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> gson: Gson <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> kodein.instance() <span class="hljs-comment"><span class="hljs-comment">/*...*/</span></span> kodein.baseKodein = <span class="hljs-comment"><span class="hljs-comment">/*     Kodein */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*...*/</span></span> gson.fromJson(someStr)</code> </pre><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dapatkan semua contoh dari tipe yang ditentukan </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anda dapat meminta Kodein untuk instance dari tipe yang ditentukan dan semua turunannya dalam formulir </font></font><code>List</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Semuanya hanya dalam tag yang ditentukan. </font><font style="vertical-align: inherit;">Untuk melakukan hal ini, ada metode </font></font><code>allInstances</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>allProviders</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>allFactories</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="kotlin hljs"> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein = Kodein { bind&lt;Number&gt;() with singleton { <span class="hljs-built_in"><span class="hljs-built_in">Short</span></span>.MAX_VALUE } bind&lt;<span class="hljs-built_in"><span class="hljs-built_in">Double</span></span>&gt;() with singleton { <span class="hljs-number"><span class="hljs-number">12.46</span></span> } bind&lt;<span class="hljs-built_in"><span class="hljs-built_in">Double</span></span>&gt;(<span class="hljs-string"><span class="hljs-string">"someTag"</span></span>) with singleton { <span class="hljs-number"><span class="hljs-number">43.89</span></span> } bind&lt;<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>&gt;() with singleton { <span class="hljs-number"><span class="hljs-number">4562</span></span> } bind&lt;<span class="hljs-built_in"><span class="hljs-built_in">Float</span></span>&gt;() with singleton { <span class="hljs-number"><span class="hljs-number">136.88f</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> numbers: List&lt;Number&gt; <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> kodein.allInstances()</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika Anda mencetak ke log, Anda akan melihat di sana [32767, 136,88, 4562, 12,46]. </font><font style="vertical-align: inherit;">Ketergantungan dengan tag tidak ada dalam daftar.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sederhanakan akuisisi ketergantungan menggunakan antarmuka KodeinAware </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Antarmuka ini mewajibkan Anda untuk mengganti properti tipe </font></font><code>Kodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dan sebagai gantinya memberikan akses ke semua fungsi yang tersedia untuk instance </font></font><code>Kodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyApplication</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Application</span></span></span></span>(), KodeinAware { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein = Kodein { bind&lt;Number&gt;() with singleton { <span class="hljs-built_in"><span class="hljs-built_in">Short</span></span>.MAX_VALUE } bind&lt;<span class="hljs-built_in"><span class="hljs-built_in">Double</span></span>&gt;() with singleton { <span class="hljs-number"><span class="hljs-number">12.46</span></span> } bind&lt;<span class="hljs-built_in"><span class="hljs-built_in">Double</span></span>&gt;(<span class="hljs-string"><span class="hljs-string">"someTag"</span></span>) with singleton { <span class="hljs-number"><span class="hljs-number">43.89</span></span> } bind&lt;<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>&gt;() with singleton { <span class="hljs-number"><span class="hljs-number">4562</span></span> } bind&lt;<span class="hljs-built_in"><span class="hljs-built_in">Float</span></span>&gt;() with singleton { <span class="hljs-number"><span class="hljs-number">136.88f</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> numbers: List&lt;Number&gt; <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> allInstances() }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seperti yang Anda lihat, sekarang Anda bisa menulis </font></font><code>by allInstances()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">alih-alih </font></font><code>by kodein.allInstances()</code> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sebelumnya, kami sudah berbicara tentang pemicu untuk menerima dependensi. </font><font style="vertical-align: inherit;">Di antarmuka, </font></font><code>KodeinAware</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anda bisa mengganti pemicu dan mendapatkan semua dependensi yang dideklarasikan saat pemicu ini dipanggil.</font></font><br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyApplication</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Application</span></span></span></span>(), KodeinAware { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein = Kodein { bind&lt;Number&gt;() with singleton { <span class="hljs-built_in"><span class="hljs-built_in">Short</span></span>.MAX_VALUE } bind&lt;<span class="hljs-built_in"><span class="hljs-built_in">Double</span></span>&gt;() with singleton { <span class="hljs-number"><span class="hljs-number">12.46</span></span> } bind&lt;<span class="hljs-built_in"><span class="hljs-built_in">Double</span></span>&gt;(<span class="hljs-string"><span class="hljs-string">"someTag"</span></span>) with singleton { <span class="hljs-number"><span class="hljs-number">43.89</span></span> } bind&lt;<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>&gt;() with singleton { <span class="hljs-number"><span class="hljs-number">4562</span></span> } bind&lt;<span class="hljs-built_in"><span class="hljs-built_in">Float</span></span>&gt;() with singleton { <span class="hljs-number"><span class="hljs-number">136.88f</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodeinTrigger = KodeinTrigger() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> numbers: List&lt;Number&gt; <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> allInstances() <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onCreate() kodeinTrigger.trigger() } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena akses ke dependensi dan instance </font></font><code>Kodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">malas, Anda dapat mendelegasikan inisialisasi instance </font></font><code>Kodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ke fungsi yang dibangun di Kotlin </font></font><code>lazy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Pendekatan semacam itu mungkin berguna di kelas tergantung pada konteksnya, misalnya di </font></font><code>Activity</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CategoriesActivity</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Activity</span></span></span></span>(), KodeinAware { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> lazy { (application <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> MyApplication).kodein } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> myFloat: <span class="hljs-built_in"><span class="hljs-built_in">Float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> instance()</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk alasan yang sama, Anda dapat menggunakan pengubah </font></font><code>lateinit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CategoriesActivity</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Activity</span></span></span></span>(), KodeinAware { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> kodein: Kodein <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> myFloat: <span class="hljs-built_in"><span class="hljs-built_in">Float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> instance() <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(savedInstanceState: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Bundle</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onCreate(savedInstanceState) kodein = (application <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> MyApplication).kodein }</code> </pre><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Akses ke dependensi tanpa mendelegasikan properti </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika karena alasan tertentu Anda tidak ingin menggunakan delegasi properti, maka Anda dapat menggunakan akses langsung melalui </font></font><code>DKodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(dari langsung). </font><font style="vertical-align: inherit;">Perbedaan utama adalah bahwa tidak akan ada inisialisasi malas lagi, ketergantungan akan diperoleh segera pada saat panggilan </font></font><code>instance</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan fungsi serupa. </font><font style="vertical-align: inherit;">Anda </font></font><code>DKodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bisa </font><font style="vertical-align: inherit;">mendapatkannya </font><font style="vertical-align: inherit;">dari instance Kodein yang ada atau membangun dari awal.</font></font><br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyApplication</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Application</span></span></span></span>(), KodeinAware { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein = Kodein { bind&lt;BigDecimal&gt;() with singleton { BigDecimal.TEN } } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> directKodein: DKodein = kodein.direct <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> directKodein2: DKodein = Kodein.direct { bind&lt;BigDecimal&gt;() with singleton { BigDecimal.ONE } } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> someNumber:BigDecimal = directKodein.instance() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> someNumber2:BigDecimal = directKodein2.instance()</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kodein dapat digunakan dalam framework </font></font><code>KodeinAware</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dan </font></font><code>DKodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dalam framework </font></font><code>DKodeinAware</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, Anda bisa bereksperimen.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dapatkan dependensi dalam konteks apa pun </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk mendapatkan </font></font><code>Kodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">beberapa dependensi dengan tipe yang sama </font><font style="vertical-align: inherit;">dari satu objek, </font><font style="vertical-align: inherit;">kami telah memeriksa opsi untuk menggunakan tag dan pabrik dengan argumen, tetapi ada satu hal lagi - menggunakan konteks (dan ini bukan konteks yang ada di Android). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perbedaan dari ketergantungan dengan tag:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tag tidak dapat digunakan di dalam fungsi tempat kami membuat dependensi </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Saat menggunakan konteks, kami memiliki akses ke instance konteks dalam fungsi pembuatan dependensi </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seringkali, alih-alih konteks, Anda dapat menggunakan pabrik dengan argumen, dan pengembang </font></font><code>Kodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menyarankan melakukan ini jika Anda tidak yakin apa yang harus digunakan. Tapi konteksnya bisa bermanfaat, misalnya, ketika Anda tidak bisa melemparkan dua argumen ke tipe yang sama. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Misalnya, Anda memiliki </font></font><code>Activity</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>Presenter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dan Anda ingin, menggunakan satu objek </font></font><code>Kodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, untuk menyediakan beberapa dependensi dari berbagai jenis dengan cara yang berbeda, tergantung pada kelas apa mereka diterima. Untuk memimpin </font></font><code>Activity</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>Presenter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk satu jenis - Anda perlu sebuah antarmuka opsional, dan pabrik harus memeriksa jenis argumen yang dihasilkan. Skema ini sangat tidak nyaman. Oleh karena itu, kami melihat cara menggunakan konteks:</font></font><br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyApplication</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Application</span></span></span></span>(), KodeinAware { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein = Kodein { bind&lt;BigDecimal&gt;() with contexted&lt;CategoriesActivity&gt;().provider { context.getActivityBigDecimal() } bind&lt;BigDecimal&gt;() with contexted&lt;CategoriesPresenter&gt;().factory { initialValue:BigDecimal -&gt; context.getPresenterBigDecimal(initialValue) } } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CategoriesActivity</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Activity</span></span></span></span>(), AppKodeinAware { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getActivityBigDecimal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = BigDecimal(<span class="hljs-string"><span class="hljs-string">"16.34"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> activityBigDecimal: BigDecimal <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> kodein.on(context = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>).instance() } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CategoriesPresenter</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AppKodeinAware { fun getPresenterBigDecimal</span></span></span></span>(initialValue: BigDecimal) = initialValue * BigDecimal.TEN <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> presenterBigDecimal: BigDecimal <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> kodein.on(context = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>).instance(arg = BigDecimal(<span class="hljs-string"><span class="hljs-string">"31.74"</span></span>)) }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contoh, tentu saja, akan ditarik ke telinga dan dalam praktik nyata tidak mungkin Anda akan menghadapi situasi seperti itu, tetapi contoh ini menunjukkan bagaimana konteksnya bekerja. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk mendeklarasikan dependensi, Anda tidak menentukan </font></font><code>with provider()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, tetapi </font></font><code>with contexted&lt;OurContextClass&gt;().provider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, di mana </font></font><code>OurContextClass</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">adalah tipe kelas, sebuah instance yang akan bertindak sebagai konteks. </font></font><code>contexted</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hanya dapat penyedia atau pabrik. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Akses ke konteks ini dalam fungsi yang mengembalikan ketergantungan dilakukan melalui variabel bernama </font></font><code>context</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk mendapatkan dependensi yang dilampirkan ke konteks, Anda harus terlebih dahulu menentukan konteks untuk objek </font></font><code>Kodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">melalui fungsi </font></font><code>on()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dan kemudian meminta dependensi. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Demikian pula, konteks digunakan dalam kasus </font></font><code>injection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> productApi: IProductApi <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> kodein.on(context = someContext).newInstance { ProductApi(instance(), instance()) } }</code> </pre><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ekstensi Android </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di awal artikel, saya berjanji untuk mempertimbangkan opsi ekspansi </font></font><code>Android</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tidak ada yang menghalangi Anda untuk menggunakannya </font></font><code>Kodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">seperti yang telah kita bahas di atas, tetapi Anda dapat membuat semuanya menjadi lebih mudah.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kodein bawaan untuk Android </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Suatu hal yang sangat berguna adalah modul yang disiapkan untuk Android. </font><font style="vertical-align: inherit;">Untuk menghubungkannya, kelas perlu </font></font><code>Application</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mengimplementasikan </font></font><code>KodeinAware</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan menginisialisasi properti dengan </font></font><code>Kodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">malas (untuk mengakses instance </font></font><code>Application</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font><font style="vertical-align: inherit;">Sebagai gantinya, Anda mendapatkan sejumlah besar dependensi yang dideklarasikan yang bisa Anda dapatkan dari kelas </font></font><code>Application</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, termasuk semua yang Anda butuhkan </font></font><code>Context</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Cara menghubungkan - lihat contoh.</font></font><br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyApplication</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Application</span></span></span></span>(), KodeinAware { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein = Kodein.lazy { <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(androidModule(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span><span class="hljs-symbol"><span class="hljs-symbol">@MyApplication</span></span>)) <span class="hljs-comment"><span class="hljs-comment">//  } val inflater: LayoutInflater by instance() }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seperti yang Anda lihat - Anda bisa mendapatkan, misalnya </font></font><code>LayoutInflater</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Untuk daftar lengkap dependensi yang dideklarasikan dalam modul - </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lihat di sini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika Anda ingin mendapatkan dependensi ini di luar kelas Android yang mengetahui konteksnya, tentukan konteksnya secara eksplisit.</font></font><br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> inflater: LayoutInflater <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> kodein.on(context = getActivity()).instance()</code> </pre><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dapatkan kode induk dengan cepat melalui terdekatKodein () </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sederhana saja, di Android, beberapa objek bergantung pada yang lain. </font><font style="vertical-align: inherit;">Di tingkat atas ada Aplikasi, yang di bawahnya adalah Aktivitas, lalu Fragmen. </font><font style="vertical-align: inherit;">Anda dapat menerapkan dalam Aktivitas </font></font><code>KodeinAware</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dan sebagai inisialisasi, panggil </font></font><code>closestKodein()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan dapatkan instance </font></font><code>Kodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dari </font></font><code>Application</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyActivity</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Activity</span></span></span></span>(), KodeinAware { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> closestKodein() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> ds: DataSource <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> instance() }</code> </pre><br> <code>closestKodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anda juga bisa mendapatkannya di luar kelas Android, tetapi Anda membutuhkan konteks Android tempat Anda dapat memanggil fungsinya. </font><font style="vertical-align: inherit;">Jika Anda menggunakannya </font></font><code>KodeinAware</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, tentukan juga konteksnya (ganti properti yang sesuai dan berikan konteks Android ke fungsi </font></font><code>kcontext()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">).</font></font><br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyController</span></span></span></span>(androidContext: Context) : KodeinAware { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> androidContext.closestKodein() <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodeinContext = kcontext(androidContext) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> inflater: LayoutInflater <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> instance() }</code> </pre><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Buat Kodein terpisah di Activity </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mungkin perlu untuk mewarisi dari induk Kodein dalam Kegiatan dan mengembangkannya. </font><font style="vertical-align: inherit;">Solusinya cukup sederhana.</font></font><br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyActivity</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Activity</span></span></span></span>(), KodeinAware { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> parentKodein <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> closestKodein() <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> Kodein.lazy { extend(parentKodein) <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> } }</code> </pre><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kodein yang sedang mengalami perubahan konfigurasi </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ya kamu bisa. </font><font style="vertical-align: inherit;">Ada fungsi untuk ini </font></font><code>retainedKodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Saat menggunakannya, objek </font></font><code>Kodein</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tidak akan dibuat ulang setelah perubahan konfigurasi.</font></font><br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyActivity</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Activity</span></span></span></span>(), KodeinAware { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> parentKodein <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> closestKodein() <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kodein: Kodein <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> retainedKodein { extend(parentKodein) } }</code> </pre><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Apa yang tidak dikatakan dalam artikel itu? </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya tidak berpura-pura menjadi lengkap, dan saya sendiri tidak memahami beberapa hal dengan cukup baik untuk mencoba menyatakannya. </font><font style="vertical-align: inherit;">Berikut adalah daftar apa yang dapat Anda pelajari sendiri, mengetahui prinsip-prinsip dasar:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lingkup </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Penjilidan instan </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mengikat multi </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Callback yang sudah ada </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sumber eksternal </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hapus perangkap versi </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kodein yang dapat dikonfigurasi </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> JSR-330 Compability </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Baik dan tautan ke dokumentasi: </font></font><br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inti 5.3</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Android 5.3</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Halaman awal</font></font></a> </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Terima kasih sudah membaca, semoga artikel ini bermanfaat bagi Anda! </font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id431696/">https://habr.com/ru/post/id431696/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id431686/index.html">Kecuali IoT: Mirai botnet meluncurkan serangan pada mesin Linux</a></li>
<li><a href="../id431688/index.html">Bagaimana dentang mengkompilasi suatu fungsi</a></li>
<li><a href="../id431690/index.html">Memecahkan crackme dari Kaspersky Lab</a></li>
<li><a href="../id431692/index.html">Kemajuan dalam imunoterapi dalam pengobatan multiple sclerosis</a></li>
<li><a href="../id431694/index.html">Sortir "Menara Hanoi"</a></li>
<li><a href="../id431698/index.html">Analisis pertanyaan di stand hh.ru di # HolyJS18</a></li>
<li><a href="../id431700/index.html">Multimeter rumah tangga yang tidak pernah saya temukan di pasar</a></li>
<li><a href="../id431702/index.html">Soviet HI-FI dan pembuatnya: headphone untuk satu catatan atau kisah yang terlupakan Electronics TDK-3 "Quad"</a></li>
<li><a href="../id431704/index.html">Bacaan akhir pekan: bagaimana tidak merusak pendengaran Anda dan melarikan diri dari kebisingan kota - 17 artikel dan panduan praktis</a></li>
<li><a href="../id431706/index.html">Teori kebahagiaan. Kecelakaan tidak disengaja?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>