<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêΩ ü§∞üèæ üßòüèΩ Geheimnisse des unm√∂glichen GPU-Computing üëÉüèø ‚ñ™Ô∏è üè∑Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Unsere Erfahrung in der Verwendung eines Computerclusters von 480 AMD RX 480 GPUs zur L√∂sung mathematischer Probleme. Als Problem haben wir den Beweis...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Geheimnisse des unm√∂glichen GPU-Computing</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/combox/blog/425731/"> Unsere Erfahrung in der Verwendung eines Computerclusters von 480 AMD RX 480 GPUs zur L√∂sung mathematischer Probleme.  Als Problem haben wir den Beweis des Theorems einem Artikel von Professor A. Chudnov entnommen  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zyklische Zerlegung von S√§tzen, die Digraphen und zyklische Spielklassen mit garantierter Auszahlung trennen</a> ."  Die Aufgabe besteht darin, die Mindestanzahl von Teilnehmern an einer Koalition in Koalitionsspielen vom Typ Nim zu finden, was den Gewinn einer der Parteien garantiert. <br><br><img src="https://habrastorage.org/webt/jc/gm/wj/jcgmwjouxeywvjyjlxa8vec5s5c.jpeg"><br><a name="habracut"></a><br><h3>  CPU-Entwicklung </h3><br>  Der erste Prozessor, der wirklich Massenverteilung bekam, ist 8086 von Intel, der 1978 entwickelt wurde.  Die Taktrate von 8086 betrug nur 8 MHz.  Einige Jahre sp√§ter erschienen die ersten Prozessoren, in denen sich 2, 4 und sogar 8 Kerne befanden.  Jeder Kern erlaubte es, seinen Code unabh√§ngig von den anderen auszuf√ºhren.  Zum Vergleich: Der moderne Intel Core i9-7980XE-Prozessor arbeitet mit einer Frequenz von 2,6 GHz und enth√§lt 18 Kerne.  Wie Sie sehen, steht der Fortschritt nicht still! <br><br><h3>  GPU-Entwicklung </h3><br>  Gleichzeitig mit der Entwicklung von Zentralprozessoren wurden auch Grafikkarten entwickelt.  Grunds√§tzlich sind ihre Eigenschaften f√ºr Computerspiele wichtig, bei denen neue Technologien besonders farbenfroh sind und sich das Rendern von 3D-Bildern allm√§hlich der fotografischen Qualit√§t n√§hert.  Zu Beginn der Entwicklung von Computerspielen wurde die Berechnung des Bildes auf der CPU durchgef√ºhrt, aber der Erfindungsreichtum der 3D-Grafikentwickler wurde bald erreicht, die es schafften, selbst die offensichtlichen Dinge zu optimieren ( <i>InvSqrt () ist ein</i> gutes Beispiel).  Daher tauchten Coprozessoren mit speziellen Anweisungen zur Durchf√ºhrung von 3D-Berechnungen auf Grafikkarten auf.  Mit der Zeit wuchs die Anzahl solcher Teams, was einerseits eine flexiblere und effizientere Arbeit mit dem Image erm√∂glichte und andererseits den Entwicklungsprozess komplizierte. <br><br>  Seit 1996 wurden Grafikbeschleuniger S3 ViRGE, 3dfx Voodoo, Diamond Monster und andere produziert.  1999 ver√∂ffentlichte nVidia den GeForce 256-Prozessor und f√ºhrte den Begriff GPU ein - einen Grafikprozessor.  Es ist bereits universell, es kann sich mit geometrischen Berechnungen, Koordinatentransformation, Platzierung von Beleuchtungspunkten und Arbeiten mit Polygonen befassen.  Der Unterschied zwischen der GPU und anderen Grafikchips bestand darin, dass es neben speziellen Befehlen eine Reihe von Standardbefehlen gab, mit denen Sie Ihren eigenen Rendering-Algorithmus implementieren konnten.  Dies bot einen erheblichen Vorteil, da Spezialeffekte hinzugef√ºgt werden konnten und nicht nur solche, die bereits in die Grafikkarte programmiert sind.  Beginnend mit der GeForce 8000/9000 wurden Stream-Prozessoren in der GPU angezeigt - bereits vollwertige Computer.  Ihre Anzahl lag je nach Modell zwischen 16 und 128. In der modernen Terminologie werden sie als einheitliche Shader-Einheiten oder einfach als Shader-Einheiten bezeichnet.  Die heute hergestellten AMD Vega 64-GPUs enthalten 4096 Shader-Einheiten, und die Taktfrequenz kann 1536 MHz erreichen! <br><br><h3>  Was enth√§lt eine GPU? </h3><br><img align="right" src="https://habrastorage.org/webt/my/rm/lc/myrmlcjalz2qiygw-qg-vdp4o18.png">  Die GPU-Architektur unterscheidet sich von der CPU durch eine gro√üe Anzahl von Kernen und einen minimalistischen Befehlssatz, der haupts√§chlich auf Vektor-Computing abzielt.  Auf Architekturebene wurden Probleme des Parallelbetriebs einer gro√üen Anzahl von Kernen und des gleichzeitigen Zugriffs auf den Speicher behoben.  Moderne GPUs enthalten 2 bis 4 Tausend Shader-Einheiten, die zu Recheneinheiten (Compute Unit) zusammengefasst werden.  Beim parallelen Rechnen ist das Problem des gleichzeitigen Zugriffs auf den Speicher besonders akut.  Wenn jeder der Stream-Prozessoren versucht, in die Speicherzelle zu schreiben, landen diese Befehle in der Sperre und m√ºssen in die Warteschlange gestellt werden, was die Leistung erheblich verringert.  Daher f√ºhren Stream-Prozessoren Anweisungen in kleinen Gruppen aus: W√§hrend eine Gruppe die Berechnungen durchf√ºhrt, l√§dt die andere die Register usw.  Sie k√∂nnen die Kerne auch zu Arbeitsgruppen mit gemeinsamem Speicher und internen Synchronisationsmechanismen kombinieren. <br><br>  Ein weiteres wichtiges Merkmal der GPU ist das Vorhandensein von Vektorregistern und Vektor-ALUs, die Operationen gleichzeitig f√ºr mehrere Komponenten des Vektors ausf√ºhren k√∂nnen.  Dies ist haupts√§chlich f√ºr 3D-Grafiken erforderlich, aber da unsere Welt dreidimensional ist, hindert uns nichts daran, sie f√ºr viele physikalische Berechnungen zu verwenden.  In Gegenwart von freien Vektor-ALUs k√∂nnen sie auch zur Berechnung skalarer Gr√∂√üen verwendet werden. <br><br><h3>  Sie sind so unterschiedlich, CPU und GPU </h3><br>  F√ºr den vollen Betrieb des Computersystems sind beide Ger√§tetypen wichtig.  Zum Beispiel f√ºhren wir ein Schritt-f√ºr-Schritt-Programm aus, einen bestimmten sequentiellen Algorithmus.  Es gibt keine M√∂glichkeit, den f√ºnften Schritt des Algorithmus auszuf√ºhren, daher werden die Daten daf√ºr in Schritt vier berechnet.  In diesem Fall ist es effizienter, eine CPU mit gro√üem Cache und hoher Taktrate zu verwenden.  Es gibt jedoch ganze Klassen von Aufgaben, die sich gut f√ºr die Parallelisierung eignen.  In diesem Fall ist die Wirksamkeit der GPU offensichtlich.  Das h√§ufigste Beispiel ist die Berechnung der Pixel eines gerenderten Bildes.  Die Vorgehensweise f√ºr jedes Pixel ist nahezu gleich, Daten zu 3D-Objekten und Texturen befinden sich im RAM der Grafikkarte, und jeder Stream-Prozessor kann unabh√§ngig seinen eigenen Teil des Bildes berechnen. <br><br>  Hier ist ein Beispiel f√ºr eine moderne Aufgabe - das Training eines neuronalen Netzwerks.  Eine gro√üe Anzahl identischer Neuronen muss trainiert werden, dh um die Gewichtskoeffizienten jedes Neurons zu √§ndern.  Nach solchen √Ñnderungen ist es notwendig, Testsequenzen zum Training durch das neuronale Netzwerk zu leiten und Fehlervektoren zu erhalten.  Solche Berechnungen sind f√ºr die GPU gut geeignet.  Jeder Stream-Prozessor kann sich wie ein Neuron verhalten, und w√§hrend der Berechnung muss die L√∂sung nicht sequentiell erstellt werden. Alle unsere Berechnungen werden gleichzeitig ausgef√ºhrt.  Ein weiteres Beispiel ist die Berechnung aerodynamischer Str√∂mungen.  Es ist notwendig, das m√∂gliche Verhalten der entworfenen Br√ºcke unter dem Einfluss von Wind herauszufinden, ihre aerodynamische Stabilit√§t zu simulieren, die optimalen Installationsorte f√ºr Verkleidungen zu finden, um den Luftstrom anzupassen oder den Widerstand gegen Windresonanz zu berechnen.  Erinnern Sie sich an die ber√ºhmte ‚ÄûTanzbr√ºcke‚Äú in Wolgograd?  Ich denke, dass niemand in diesem Moment auf der Br√ºcke sein m√∂chte ... <br><br>  Das Verhalten des Luftstroms an jedem Punkt kann durch dieselben mathematischen Gleichungen beschrieben werden und diese Gleichungen parallel auf einer gro√üen Anzahl von Kernen l√∂sen. <br><br><h3>  GPU in den H√§nden von Programmierern </h3><br>  Um Berechnungen auf der GPU durchzuf√ºhren, werden eine spezielle Sprache und ein Compiler verwendet.  Es gibt verschiedene Frameworks f√ºr die Durchf√ºhrung allgemeiner GPU-Berechnungen: OpenCL, CUDA, C ++ AMP, OpenACC.  Die ersten beiden waren weit verbreitet, aber die Verwendung von CUDA ist nur durch die GPUs von nVidia begrenzt. <br><br>  OpenCL wurde 2009 von Apple ver√∂ffentlicht.  Sp√§ter traten Intel, IBM, AMD, Google und nVidia der Khronos-Gruppe bei und k√ºndigten ihre Unterst√ºtzung f√ºr den gemeinsamen Standard an.  Seitdem erscheint alle anderthalb bis zwei Jahre eine neue Version des Standards, die jeweils immer ernsthaftere Verbesserungen bringt. <br><br>  Bisher entspricht die Sprache OpenCL C ++ Version 2.2 dem C ++ 14-Standard, unterst√ºtzt die gleichzeitige Ausf√ºhrung mehrerer Programme innerhalb des Ger√§ts, die Interaktion zwischen ihnen √ºber interne Warteschlangen und Pipelines und erm√∂glicht die flexible Verwaltung von Puffern und virtuellem Speicher. <br><br><h3>  Echte Aufgaben </h3><br>  Ein interessantes Problem aus der Spieltheorie, an dessen L√∂sung wir teilgenommen haben, ist der Beweis des Satzes aus einem Artikel von Professor A. Chudnov  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zyklische Zerlegung von S√§tzen, die Digraphen und zyklische Spielklassen mit garantierter Auszahlung trennen</a> ."  Die Aufgabe besteht darin, die Mindestanzahl von Teilnehmern an einer Koalition in Koalitionsspielen vom Typ Nim zu finden, was den Gewinn einer der Parteien garantiert. <br><br>  Aus mathematischer Sicht ist dies eine Suche nach einer unterst√ºtzenden zyklischen Sequenz.  Wenn Sie die Sequenz in Form einer Liste von Nullen und Einsen darstellen, kann die √úberpr√ºfung auf Unterst√ºtzung durch logische bitweise Operationen implementiert werden.  Aus programmtechnischer Sicht ist eine solche Sequenz ein langes Register, beispielsweise 256 Bit.  Der zuverl√§ssigste Weg, um dieses Problem zu l√∂sen, besteht darin, alle Optionen au√üer den aus offensichtlichen Gr√ºnden unm√∂glichen zu sortieren. <br><br>  Die Ziele der Probleml√∂sung sind Probleme einer effektiven Signalverarbeitung (Erkennung, Synchronisation, Koordinatenmessung, Codierung usw.). <br><br>  Die Komplexit√§t der L√∂sung dieses Problems besteht darin, eine Vielzahl von Optionen zu sortieren.  Wenn wir beispielsweise nach einer L√∂sung f√ºr n = 25 suchen, sind dies 25 Bits, und wenn n = 100, dann sind dies bereits 100 Bits.  Wenn wir die Anzahl aller m√∂glichen Kombinationen nehmen, dann ist es f√ºr n = 25 2 ^ 25 = 33 554 432 und f√ºr n = 100 sind es bereits 2 ^ 100 = 1 267 650 600 228 229 401 496 703 205 376 Kombinationen.  Die Zunahme der Komplexit√§t ist einfach kolossal! <br><br>  Diese Aufgabe ist gut parallelisiert, was bedeutet, dass sie ideal f√ºr unseren GPU-Cluster ist. <br><br><h3>  Programmierer gegen Mathematik </h3><br>  Urspr√ºnglich l√∂sten Mathematiker dieses Problem in Visual Basic in Excel, sodass es ihnen gelang, prim√§re L√∂sungen zu erhalten, aber die geringe Leistung von Skriptsprachen erm√∂glichte es uns nicht, weit voranzukommen.  Die Entscheidung f√ºr n = 80 dauerte anderthalb Monate ... Wir neigen unsere K√∂pfe vor diesen geduldigen Menschen. <br><br>  In der ersten Phase haben wir den Task-Algorithmus in C implementiert und auf der CPU gestartet.  Dabei stellte sich heraus, dass beim Arbeiten mit Bitsequenzen vieles optimiert werden kann. <br>  Als n√§chstes haben wir den Suchbereich optimiert und Doppelarbeit vermieden.  Auch eine Analyse des vom Compiler generierten Assembler-Codes und die Optimierung des Codes f√ºr die Compiler-Funktionen ergab ein gutes Ergebnis.  All dies erm√∂glichte eine signifikante Steigerung der Berechnungsgeschwindigkeit. <br><br>  Die n√§chste Stufe der Optimierung war die Profilerstellung.  Die Messung der Ausf√ºhrungszeit verschiedener Abschnitte des Codes zeigte, dass in einigen Zweigen des Algorithmus die Belastung des Speichers signifikant anstieg und eine √ºberm√§√üige Verzweigung des Programms aufgedeckt wurde.  Aufgrund dieses ‚Äûkleinen‚Äú Fehlers wurde fast ein Drittel der CPU-Leistung nicht verbraucht. <br><br>  Ein sehr wichtiger Aspekt bei der L√∂sung solcher Probleme ist die Genauigkeit des Schreibens von Code.  Niemand kennt die richtigen Antworten auf dieses Problem und dementsprechend gibt es keine Testvektoren.  Es gibt nur den ersten Teil der L√∂sungspalette, die Mathematiker gefunden haben.  Die Zuverl√§ssigkeit neuer L√∂sungen kann nur durch die Genauigkeit des Schreibens von Code garantiert werden. <br><br>  Die Phase der Vorbereitung des Programms f√ºr die L√∂sung auf der GPU ist also gekommen und der Code wurde so ge√§ndert, dass er in mehreren Threads funktioniert.  Das Steuerprogramm ist nun damit besch√§ftigt, Aufgaben zwischen Threads zu verteilen.  In einer Umgebung mit mehreren Threads hat sich die Berechnungsgeschwindigkeit um das F√ºnffache erh√∂ht!  Dies wurde durch den gleichzeitigen Betrieb von 4 Threads und die Kombination von Funktionen erreicht. <br><br>  Zu diesem Zeitpunkt traf die Entscheidung die korrekten Berechnungen bis zu n = 80 in 10 Minuten, w√§hrend diese Berechnungen in Excel anderthalb Monate dauerten!  Kleiner Sieg! <br><br><h3>  GPU und OpenCL </h3><br>  Es wurde beschlossen, OpenCL Version 1.2 zu verwenden, um maximale Kompatibilit√§t zwischen verschiedenen Plattformen zu gew√§hrleisten.  Das erste Debugging wurde auf der Intel-CPU und dann auf der Intel-GPU durchgef√ºhrt.  Dann wechselten sie von AMD zur GPU. <br><br>  Der OpenCL 1.2-Standard unterst√ºtzt ganzzahlige Variablen mit 64 Bit.  Die 128-Bit-Dimension wird von AMD nur eingeschr√§nkt unterst√ºtzt, wird jedoch in zwei 64-Bit-Zahlen kompiliert.  Aus Kompatibilit√§tsgr√ºnden und um die Leistung zu optimieren, wurde beschlossen, eine 256-Bit-Nummer als Gruppe von 32-Bit-Nummern darzustellen, logische bitweise Operationen, die so schnell wie m√∂glich auf der internen ALU-GPU ausgef√ºhrt werden. <br>  Ein OpenCL-Programm enth√§lt einen Kernel - eine Funktion, die den Einstiegspunkt eines Programms darstellt.  Daten zur Verarbeitung werden von der CPU in den RAM der Grafikkarte heruntergeladen und in Form von Puffern - Zeigern auf ein Array von Eingabe- und Ausgabedaten - an den Kernel √ºbertragen.  Warum ein Array?  Wir f√ºhren Hochleistungsrechnen durch, wir ben√∂tigen viele Aufgaben, die gleichzeitig ausgef√ºhrt werden.  Der Kernel wird in mehreren Instanzen auf dem Ger√§t ausgef√ºhrt.  Jeder Kern kennt seine Kennung und nimmt seine eigene Eingabe aus einem gemeinsam genutzten Puffer.  Der Fall, wenn die einfachste L√∂sung die effektivste ist.  OpenCL ist nicht nur eine Sprache, sondern auch ein umfassender Rahmen, in dem alle Details des wissenschaftlichen und Game-Computing gr√ºndlich durchdacht sind.  Dies erleichtert dem Entwickler das Leben.  Sie k√∂nnen beispielsweise viele Threads starten, der Task-Manager platziert sie auf dem Ger√§t selbst.  Diejenigen Aufgaben, die nicht sofort ausgef√ºhrt wurden, werden in die Warteschlange gestellt und gestartet, sobald die Recheneinheiten frei werden.  Jede Kernelinstanz verf√ºgt √ºber einen eigenen Speicherplatz im Ausgabepuffer, in dem die Antwort nach Abschluss der Arbeit platziert wird. <br><br>  Die Hauptaufgabe des OpenCL-Managers besteht darin, die parallele Ausf√ºhrung mehrerer Kernelinstanzen sicherzustellen.  Hier wird die √ºber Jahrzehnte gesammelte wissenschaftliche und praktische Erfahrung angewendet.  W√§hrend einige Kerne Daten in Register laden, arbeitet ein anderer Teil zu diesem Zeitpunkt mit dem Speicher oder f√ºhrt Berechnungen durch. Infolgedessen ist der GPU-Kern immer vollst√§ndig geladen. <br>  Der OpenCL-Compiler leistet gute Optimierungsarbeit, aber f√ºr Entwickler ist es einfacher, die Leistung zu beeinflussen.  Die GPU-Optimierung erfolgt in zwei Richtungen: Beschleunigung der Codeausf√ºhrung und M√∂glichkeit der Parallelisierung.  Wie gut der Code vom Compiler parallelisiert wird, h√§ngt von mehreren Faktoren ab: der Anzahl der belegten Arbeitsregister (die sich im langsamsten GPU-Speicher befinden - global), der Gr√∂√üe des kompilierten Codes (Sie m√ºssen in 32 KB Cache passen), der Anzahl der verwendeten Vektor- und Skalarregister. <br><br><h3>  ComBox A-480 GPU oder eine Million Kerne </h3><br>  Dies ist der interessanteste Teil des Projekts, als wir von Excel zu einem Computercluster mit 480 AMD RX 480-Grafikkarten gewechselt sind. Gro√ü, schnell, effizient.  V√∂llig bereit, die Aufgabe zu erf√ºllen und die Ergebnisse zu erzielen, die die Welt noch nie zuvor gesehen hat. <br><br>  Ich m√∂chte darauf hinweisen, dass wir in allen Phasen der Verbesserung und Optimierung des Codes von Anfang an mit der Suche nach einer L√∂sung begonnen und die Antworten der neuen Version mit den vorherigen verglichen haben.  Dadurch konnten wir sicher sein, dass die Codeoptimierung und -verbesserungen keine Fehler in die L√∂sungen einbrachten.  Hier m√ºssen Sie verstehen, dass es am Ende des Lehrbuchs keine richtigen Antworten gibt und niemand auf der Welt sie kennt. <br>  Der Start des Clusters best√§tigte unsere Annahmen zur Geschwindigkeit der L√∂sungen: Die Suche nach Sequenzen f√ºr n&gt; 100 dauerte etwa eine Stunde.  Es war erstaunlich zu sehen, wie neue L√∂sungen auf dem ComBox A-480-Cluster in wenigen Minuten verf√ºgbar waren, w√§hrend es auf der CPU viele Stunden dauerte. <br><br>  In nur zwei Stunden des Computerclusters haben wir alle L√∂sungen bis zu n = 127 erhalten.  Eine √úberpr√ºfung der L√∂sungen ergab, dass die erhaltenen Antworten zuverl√§ssig sind und den im Artikel angegebenen Theoremen von Professor A. Chudnov entsprechen <br><br><h3>  Geschwindigkeitsentwicklung </h3><br>  Wenn Sie sich den Leistungsgewinn im Verlauf der Probleml√∂sung ansehen, sind die Ergebnisse ungef√§hr wie folgt: <br><br><ul><li>  eineinhalb Monate bis n = 80 in Excel; </li><li>  eine Stunde bis n = 80 auf Core i5 mit einem optimierten C ++ - Programm; </li><li>  10 Minuten bis n = 80 auf Core i5 mit Multithreading; </li><li>  10 Minuten bis n = 100 auf einer AMD RX 480 GPU; </li><li>  120 Minuten bis n = 127 auf der ComBox A-480. </li></ul><br><h3>  Perspektiven und Zukunft </h3><br>  Viele Aufgaben an der Schnittstelle von Wissenschaft und Praxis stehen noch aus, um unser Leben besser zu machen.  Der Markt f√ºr die Vermietung von Rechenleistung ist gerade im Entstehen begriffen, und der Bedarf an parallelem Rechnen w√§chst weiter. <br><br>  M√∂gliche Anwendungen des Parallel Computing: <br><br><ul><li>  Aufgaben der automatischen Steuerung von Fahrzeugen und Drohnen; </li><li>  Berechnungen der aerodynamischen und hydrodynamischen Eigenschaften; </li><li>  Spracherkennung und visuelle Bilder; </li><li>  neuronales Netzwerktraining; </li><li>  Aufgaben der Astronomie und Astronautik; </li><li>  statistische und Korrelationsanalyse von Daten; </li><li>  Faltung von Protein-Protein-Verbindungen; </li><li>  Fr√ºherkennung von Krankheiten mit AI. </li></ul><br>  Eine andere Richtung ist Cloud Computing auf der GPU.  Zum Beispiel vermieten Giganten wie Amazon, IBM und Google ihre Rechenleistung an die GPU.  Heute k√∂nnen wir mit Zuversicht sagen, dass die Zukunft des Hochleistungs-Parallel-Computing GPU-Clustern geh√∂ren wird. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de425731/">https://habr.com/ru/post/de425731/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de425719/index.html">Sellerie in gesch√§ftigen Projekten: ein wenig √úbung</a></li>
<li><a href="../de425723/index.html">Facebook entwickelt aktiv einen Dienst, um Arbeit zu finden und Mitarbeiter in einem sozialen Netzwerk einzustellen</a></li>
<li><a href="../de425725/index.html">Nintendo Patents Case - Game Boy</a></li>
<li><a href="../de425727/index.html">Bis zum n√§chsten Mal</a></li>
<li><a href="../de425729/index.html">Hackathon Pro Willkommen: Wie war der erste Charity SmartMail Hack?</a></li>
<li><a href="../de425737/index.html">Karten auf dem Tisch: Ausw√§hlen eines Kartenanbieters f√ºr eine mobile Anwendung</a></li>
<li><a href="../de425739/index.html">Microsoft k√ºndigt Project xCloud an - einen hochmodernen Gaming-Streaming-Dienst</a></li>
<li><a href="../de425741/index.html">Docotic.Pdf: Welche Probleme erkennt PVS-Studio in einem ausgereiften Projekt?</a></li>
<li><a href="../de425743/index.html">Psychotherapie Mars im Haus des Saturn und intrazerebrale Injektionen von hom√∂opathischem Psilocybin</a></li>
<li><a href="../de425747/index.html">Was ist mit "Timur und seinem Team" passiert oder Gedanken √ºber die Partnerschaft militanter Techniker?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>