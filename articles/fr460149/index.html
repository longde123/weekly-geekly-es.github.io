<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎊 🐦 🅱️ Typage correct: l'aspect sous-estimé du code propre 👩🏿‍🏫 👩🏾‍🎤 👨🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour chers collègues. 

 Il n'y a pas si longtemps, notre attention a été attirée par le livre presque terminé de la maison d'édition Manning «Prog...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Typage correct: l'aspect sous-estimé du code propre</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/460149/">  Bonjour chers collègues. <br><br>  Il n'y a pas si longtemps, notre attention a été attirée par le livre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">presque terminé</a> de la maison d'édition Manning «Programmation avec les types», qui détaille l'importance d'une bonne frappe et son rôle dans l'écriture de code propre et durable. <br><br><img src="https://habrastorage.org/webt/i9/d8/mp/i9d8mpulnbdmza0fjef3zfzutaa.png"><br><br>  Dans le même temps, sur le blog de l’auteur, nous avons trouvé un article écrit, apparemment, aux premiers stades du travail sur le livre et permettant de faire une impression de son contenu.  Nous suggérons de discuter de l’intérêt des idées de l’auteur et potentiellement de l’ensemble <br><a name="habracut"></a><br>  <b>Orbiteur climatique de Mars</b> <br><br>  Le vaisseau spatial Mars Climate Orbiter s'est écrasé lors de l'atterrissage et s'est effondré dans l'atmosphère martienne, car le composant logiciel Lockheed a donné la valeur de momentum, mesurée en livre-force sec., Tandis que l'autre composant développé par la NASA a pris la valeur de momentum en Newtons- sec <br><br>  Vous pouvez imaginer le composant développé par la NASA sous la forme suivante: <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    ,  &gt;= 2 N s void trajectory_correction(double momentum) { if (momentum &lt; 2 /* N s */) { disintegrate(); } /* ... */ }</span></span></code> </pre> <br>  Vous pouvez également imaginer que le composant Lockheed a appelé le code ci-dessus comme ceci: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ trajectory_correction(<span class="hljs-number"><span class="hljs-number">1.5</span></span> <span class="hljs-comment"><span class="hljs-comment">/* lbf s */</span></span>); }</code> </pre> <br>  La livre-force-seconde (lbfs) est d'environ 4,448222 newtons par seconde (Ns).  Ainsi, du point de vue de Lockheed, le passage de 1,5 lbf à <code>trajectory_correction</code> devrait être parfaitement normal: 1,5 lbf correspond à environ 6,672333 Ns, bien au-dessus du seuil de 2 Ns. <br><br>  Le problème est l'interprétation des données.  En conséquence, le composant NASA compare lbfs avec Ns sans conversion et interprète par erreur l'entrée en lbfs comme entrée en Ns.  Puisque 1,5 est inférieur à 2, l'orbiteur s'est effondré.  C'est un contre-motif bien connu appelé obsession primitive. <br><br>  <b>Obsession des primitifs</b> <br><br>  Une fixation sur les primitives se manifeste lorsque nous utilisons un type de données primitif pour représenter une valeur dans un domaine problématique et autoriser des situations telles que celles décrites ci-dessus.  Si vous représentez les codes postaux sous forme de nombres, les numéros de téléphone sous forme de chaînes, Ns et lbfs sous forme de nombres à double précision, c'est exactement ce qui se produit. <br><br>  Il serait beaucoup plus sûr de définir un type simple de <code>Ns</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Ns</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> value; }; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Ns&amp; a, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Ns&amp; b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a.value &lt; b.value; }</code> </pre> <br>  De même, vous pouvez définir un type simple de <code>lbfs</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lbfs</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> value; }; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> lbfs&amp; a, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> lbfs&amp; b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a.value &lt; b.value; }</code> </pre> <br>  Vous pouvez maintenant implémenter une variante sécurisée de <code>trajectory_correction</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  ,   &gt;= 2 N s void trajectory_correction(Ns momentum) { if (momentum &lt; Ns{ 2 }) { disintegrate(); } /* ... */ }</span></span></code> </pre> <br>  Si vous appelez cela avec <code>lbfs</code> , comme dans l'exemple ci-dessus, le code ne compile tout simplement pas en raison d'une incompatibilité de type: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ trajectory_correction(lbfs{ <span class="hljs-number"><span class="hljs-number">1.5</span></span> }); }</code> </pre> <br>  Remarquez comment les informations sur le type de valeur, qui sont généralement indiquées dans les commentaires, ( <code>2 /*Ns */, /* lbfs */</code> ) sont maintenant dessinées dans le système de type et exprimées dans le code: ( <code>Ns{ 2 }, lbfs{ 1.5 }</code> ) . <br><br>  Bien sûr, il est possible de fournir une réduction de <code>lbfs</code> à <code>Ns</code> sous la forme d'un opérateur explicite: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lbfs</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> value; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">operator</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Ns</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value * <span class="hljs-number"><span class="hljs-number">4.448222</span></span>; } };</code> </pre> <br>  Armé de cette technique, vous pouvez appeler <code>trajectory_correction</code> aide d'un transtypage statique: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ trajectory_correction(<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Ns&gt;(lbfs{ <span class="hljs-number"><span class="hljs-number">1.5</span></span> })); }</code> </pre> <br>  Ici, l'exactitude du code est obtenue en multipliant par un coefficient.  Un cast peut également être effectué implicitement (en utilisant le mot clé implicite), auquel cas le cast sera appliqué automatiquement.  En règle générale, vous pouvez utiliser l'un des chargements Python ici: <br><blockquote>  Explicite vaut mieux qu'implicite </blockquote>  La morale de cette histoire est que, bien que nous ayons aujourd'hui des mécanismes de vérification de type très intelligents, ils doivent encore fournir suffisamment d'informations pour détecter ce type d'erreur.  Ces informations entrent dans le programme si nous déclarons des types en tenant compte des spécificités de notre domaine. <br><br>  <b>Espace d'état</b> <br><br>  Des problèmes surviennent lorsqu'un programme se termine dans un <i>mauvais état</i> .  Les types aident à réduire le champ de leur occurrence.  Essayons de traiter le type comme l'ensemble des valeurs possibles.  Par exemple, bool est l'ensemble <code>{true, false}</code> , où une variable de ce type peut prendre l'une de ces deux valeurs.  De même, <code>uint32_t</code> est l'ensemble <code>{0 ...4294967295}</code> .  En considérant les types de cette manière, nous pouvons définir l'espace d'état de notre programme comme le produit des types de toutes les variables vivantes à un certain moment. <br><br>  Si nous avons une variable de type <code>bool</code> et une variable de type <code>uint32_t</code> , alors notre espace d'état sera <code>{true, false} X {0 ...4294967295}</code> .  Cela signifie simplement que les deux variables peuvent être dans tous les états possibles pour elles, et puisque nous avons deux variables, le programme peut se retrouver dans n'importe quel état combiné de ces deux types. <br><br>  Tout devient beaucoup plus intéressant si l'on considère les fonctions qui initialisent les valeurs: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_momentum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Ns&amp; momentum)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!some_condition()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; momentum = Ns{ <span class="hljs-number"><span class="hljs-number">3</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  Dans l'exemple ci-dessus, nous prenons Ns par référence et initialisons si une condition est remplie.  La fonction renvoie <code>true</code> si la valeur a été correctement initialisée.  Si la fonction, pour une raison quelconque, ne peut pas définir la valeur, elle renvoie <code>false</code> . <br><br>  Considérant cette situation du point de vue de l'espace d'état, nous pouvons dire que l'espace d'état est un produit de <code>bool X Ns</code> .  Si la fonction retourne vrai, cela signifie que l'impulsion a été définie, et est l'une des valeurs possibles de <code>Ns</code> .  Le problème est le suivant: si la fonction retourne <code>false</code> , cela signifie que l'impulsion n'a pas été définie.  D'une manière ou d'une autre, l'élan appartient à l'ensemble des valeurs possibles de Ns, mais ce n'est pas une valeur valide.  Il existe souvent des bogues dans lesquels l'état inacceptable suivant commence accidentellement à se propager: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">example</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Ns momenum; get_momentum(momentum); trajectory_correction(momentum); }</code> </pre><br>  Au lieu de cela, nous devons simplement le faire: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">example</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Ns momentum; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (get_momentum(momentum)) { trajectory_correction(momentum); } }</code> </pre> <br>  Cependant, il existe une meilleure façon de procéder de force: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::optional&lt;Ns&gt; get_momentum() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!some_condition()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::nullopt; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_optional(Ns{ <span class="hljs-number"><span class="hljs-number">3</span></span> }); }</code> </pre> <br>  Si vous utilisez <code>optional</code> , l'espace d'état de cette fonction diminuera considérablement: au lieu de <code>bool X Ns</code> nous obtenons <code>Ns + 1</code> .  Cette fonction renverra une <code>nullopt</code> <code>Ns</code> valide ou <code>nullopt</code> pour indiquer aucune valeur.  Maintenant, nous ne pouvons tout simplement pas avoir un <code>Ns</code> invalide qui se propagerait dans le système.  De plus, il devient désormais impossible d'oublier de vérifier la valeur de retour, car l'option ne peut pas être implicitement convertie en <code>Ns</code> - nous devrons la décompresser spécialement: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">example</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> maybeMomentum = get_momentum(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (maybeMomentum) { trajectory_correction(*maybeMomentum); } }</code> </pre> <br>  Fondamentalement, nous nous efforçons pour que nos fonctions retournent un résultat ou une erreur, plutôt qu'un résultat et une erreur.  Ainsi, nous excluons les conditions dans lesquelles nous avons des erreurs, et nous sommes également à l'abri de résultats inacceptables, qui pourraient ensuite s'infiltrer dans d'autres calculs. <br><br>  De ce point de vue, lever des exceptions est normal, car il correspond au principe décrit ci-dessus: une fonction retournera un résultat ou lèvera une exception. <br><br>  <b>RAII</b> <br><br>  RAII signifie que l'acquisition des ressources est l'initialisation, mais dans une plus large mesure, ce principe est associé à la libération des ressources.  Le nom est apparu pour la première fois en C ++, cependant, ce modèle peut être implémenté dans n'importe quel langage (voir, par exemple, <code>IDisposable</code> de .NET).  RAII fournit un nettoyage automatique des ressources. <br><br>  Quelles sont les ressources?  Voici quelques exemples: mémoire dynamique, connexions à la base de données, descripteurs de système d'exploitation.  En principe, une ressource est quelque chose qui vient du monde extérieur et qui peut revenir après que nous n'en ayons plus besoin.  Nous retournons la ressource en utilisant l'opération appropriée: la libérer, la supprimer, la fermer, etc. <br><br>  Ces ressources étant externes, elles ne sont pas explicitement exprimées dans notre système de types.  Par exemple, si nous sélectionnons un fragment de mémoire dynamique, nous aurons un pointeur par lequel nous devrons appeler <code>delete</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">example</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Foo* foo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Foo(); <span class="hljs-comment"><span class="hljs-comment">/*  foo */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> foo; }</code> </pre><br>  Mais que se passe-t-il si nous oublions de le faire ou si quelque chose nous empêche d'appeler <code>delete</code> ? <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">example</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Foo* foo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Foo(); <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::exception(); <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> foo; }</code> </pre> <br>  Dans ce cas, nous n'appelons plus <code>delete</code> et obtenons une fuite de ressources.  En principe, un tel nettoyage manuel des ressources n'est pas souhaitable.  Pour la mémoire dynamique, nous avons <code>unique_ptr</code> pour nous aider à le gérer: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">example</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> foo = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_unique&lt;Foo&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::exception(); }</code> </pre> <br>  Notre <code>unique_ptr</code> est un objet de pile, par conséquent, s'il <code>unique_ptr</code> portée (lorsque la fonction lève une exception ou lorsque la pile se déroule lorsqu'une exception a été levée), son destructeur est appelé.  C'est ce destructeur qui implémente l'appel de <code>delete</code> .  En conséquence, nous n'avons plus à gérer la ressource mémoire - nous transférons ce travail à l'encapsuleur, qui en est propriétaire et est responsable de sa publication. <br><br>  Des wrappers similaires existent (ou peuvent être créés) pour toutes les autres ressources (par exemple, OS HANDLE de Windows peut être encapsulé dans un type, auquel cas son destructeur appellera <code>CloseHandle</code> ). <br><br>  La principale conclusion dans ce cas est de ne jamais faire de nettoyage manuel des ressources;  Soit utiliser le wrapper existant, soit s'il n'y a pas de wrapper approprié pour votre scénario spécifique, nous l'implémenterons nous-mêmes. <br><br>  <b>Conclusion</b> <br><br>  Nous avons commencé cet article avec un exemple bien connu qui montre l'importance de la frappe, puis nous avons examiné trois aspects importants de l'utilisation des types pour aider à écrire du code plus sécurisé: <br><br><ul><li>  Déclarer et utiliser des types plus forts (par opposition à l'obsession des primitives). </li><li>  Réduire l'espace d'état, renvoyer un résultat ou une erreur, pas un résultat ou une erreur. </li><li>  RAII et gestion automatique des ressources. </li></ul><br>  Ainsi, les types aident beaucoup à rendre le code plus sûr et à l'adapter pour une réutilisation. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr460149/">https://habr.com/ru/post/fr460149/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr460137/index.html">Test du Fujitsu LIFEBOOK U939X: performances légères et 2 en 1</a></li>
<li><a href="../fr460139/index.html">Championnat de programmation: analyse des tâches pour les développeurs front-end</a></li>
<li><a href="../fr460141/index.html">Pas un autre langage de programmation. Partie 2: Logique de représentation</a></li>
<li><a href="../fr460143/index.html">Module dis de Python et convolution de constantes</a></li>
<li><a href="../fr460147/index.html">Framework de microservices PHP - Swoft 2.0.3 publié</a></li>
<li><a href="../fr460151/index.html">Conception orientée modèle. Moteur CC sans balais</a></li>
<li><a href="../fr460153/index.html">Les aventures des signatures électroniques en Russie</a></li>
<li><a href="../fr460155/index.html">ReactiveX Redux</a></li>
<li><a href="../fr460157/index.html">Comment les réponses «correctes» des répondants peuvent fausser les résultats de l'enquête au-delà de la reconnaissance</a></li>
<li><a href="../fr460159/index.html">Méthode de surveillance de l'état actuel des routes russes par les smartphones des utilisateurs</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>