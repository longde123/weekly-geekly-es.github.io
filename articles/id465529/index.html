<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üê≤ üê¢ üíç Penangguhan lebih dari pemblokiran üßíüèΩ üç∂ üí≥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Artikel ini bertujuan untuk menunjukkan cara menggunakan Kotlin Coroutines dan menghapus Reaxtive eXtensions (Rx) . 
 Manfaat 


 Untuk memulai, mari ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Penangguhan lebih dari pemblokiran</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/465529/"><p>  Artikel ini bertujuan untuk menunjukkan cara menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kotlin Coroutines</a> dan menghapus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Reaxtive eXtensions (Rx)</a> . </p><br><h2 id="benefits">  Manfaat </h2><br><p>  Untuk memulai, mari pertimbangkan empat manfaat Coroutine daripada Rx: </p><br><h3 id="suspending-over-blocking">  Penangguhan lebih dari pemblokiran </h3><br><p>  Untuk menjalankan kode non-pemblokiran menggunakan Rx Anda akan menulis sesuatu seperti ini: </p><br><pre><code class="kotlin hljs">Observable.interval(<span class="hljs-number"><span class="hljs-number">1</span></span>, TimeUnit.SECONDS) .subscribe { textView.text = <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$it</span></span></span><span class="hljs-string"> seconds have passed"</span></span> }</code> </pre> <br><p>  Yang secara efektif membuat utas baru.  Utas adalah benda berat dalam hal memori dan kinerja. </p><br><p>  Keduanya sangat penting dalam dunia pengembangan ponsel. </p><br><p>  Anda dapat mencapai perilaku yang sama menggunakan cuplikan berikut: </p><br><pre> <code class="kotlin hljs">launch { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>){ textView.text = <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${it++}</span></span></span><span class="hljs-string"> seconds have passed"</span></span> delay(<span class="hljs-number"><span class="hljs-number">1000</span></span>) } }</code> </pre> <br><p>  Intinya, Coroutine adalah utas yang ringan tapi kami tidak membuat utas nyata. <br>  Di sini kita menggunakan fungsi non-blocking delay (), yang merupakan fungsi penangguhan khusus yang tidak memblokir utas tetapi menangguhkan Coroutine. <a name="habracut"></a></p><br><h3 id="natural-backpressure-handling-over-manual">  Penanganan backpressure alami melalui manual </h3><br><p>  Backpressure adalah ketika barang yang diamati menghasilkan barang lebih cepat daripada pengamat mereka mengonsumsinya. <br>  Saat menggunakan Rx Anda harus secara eksplisit menentukan bagaimana Anda akan berurusan dengan tekanan balik. <br>  Ada 2 pendekatan dasar: </p><br><ul><li>  Gunakan throttling, buffer atau operator windows </li><li>  Model tarik reaktif </li></ul><br><p>  Sedangkan Coroutine dapat ditangguhkan mereka memberikan jawaban alami untuk menangani tekanan balik. <br>  Dengan demikian, tidak diperlukan tindakan tambahan. </p><br><h3 id="sync-code-style-over-async">  Sinkronkan gaya kode melalui async </h3><br><p>  Sifat dasar aplikasi seluler adalah bereaksi terhadap tindakan pengguna.  Itulah sebabnya tegangan reaktif akan menjadi pilihan yang baik. </p><br><p>  Namun, Anda harus menulis kode dengan gaya fungsional.  Jika Anda terbiasa menulis dengan gaya imperatif, itu bisa agak sulit. </p><br><p>  Sedangkan Coroutines memungkinkan Anda untuk menulis kode async seolah-olah itu fungsi sinkronisasi biasa.  Misalnya, </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">showTextFromRemote</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> text = remote.getText() textView.text = text }</code> </pre> <br><p>  Bahkan saya bekerja dengan gaya fungsional untuk waktu yang lama masih lebih mudah untuk membaca dan men-debug kode penting. </p><br><h3 id="native-over-3rd-party-lib">  Asli lebih dari 3 lib pihak </h3><br><p>  Coroutine adalah fitur bawaan asli Kotlin. </p><br><p>  Anda tidak perlu menambahkan dependensi tambahan.  Saat ini, semua perpustakaan utama dapat menangani coroutine. </p><br><p>  Misalnya, </p><br><p>  Retrofit </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Api</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Get(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"users"</span></span></span><span class="hljs-meta">)</span></span> <span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loadUsers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> : List&lt;User&gt; }</code> </pre> <br><p>  Kamar </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Dao</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Update</span></span> <span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(user: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">UserEntity</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> }</code> </pre> <br><p>  Jadi, Anda dapat membangun aplikasi yang menangguhkan - mulai lapisan UI, melalui domain dan berakhir di lapisan data. </p><br><h2 id="app">  Aplikasi </h2><br><p>  Mari kita turun ke bisnis.  Kami akan membuat aplikasi master detail klasik. <br>  Halaman pertama akan berisi daftar pengiriman yang tak terbatas. <br>  Pada klik item, kami akan membuka halaman detail. <br>  Kami juga akan mendukung mode offline - semua data akan di-cache. <br>  Selain itu, saya akan menggunakan arsitektur MVVM di mana peran ViewModel dimainkan oleh Fragment alih-alih ViewModel dari AAC.  Ada beberapa alasan: <br>  Fragmen biasanya sangat botak - hanya mengikat viewModel ke XML. </p><br><p>  Fitur seperti pengaturan warna bilah status tidak dapat dilakukan di AAC ViewModel - Anda harus memicu metode fragmen.  Menggunakan fragmen sebagai ViewModel akan memungkinkan kita untuk menyimpan semua fungsi terkait (mengelola satu layar yang diberikan) dalam satu kelas. </p><br><p>  Pertama, mari kita buat BaseViewModel: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseViewModel</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">B : BaseBindings, V : ViewDataBinding</span></span></span><span class="hljs-class">&gt; : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Fragment</span></span></span></span>(), CoroutineScope <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> CoroutineScope(Dispatchers.IO){ <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> layoutId: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> bindings: B <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> viewBinding: V <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(savedInstanceState: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Bundle</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onCreate(savedInstanceState) retainInstance = <span class="hljs-literal"><span class="hljs-literal">true</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreateView</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(inflater: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">LayoutInflater</span></span></span></span><span class="hljs-function"><span class="hljs-params">, container: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">ViewGroup</span></span></span></span><span class="hljs-function"><span class="hljs-params">?, savedInstanceState: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Bundle</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span>: View? { viewBinding = DataBindingUtil.inflate(inflater, layoutId, container, <span class="hljs-literal"><span class="hljs-literal">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> viewBinding.root } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onViewCreated</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(view: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">View</span></span></span></span><span class="hljs-function"><span class="hljs-params">, savedInstanceState: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Bundle</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onViewCreated(view, savedInstanceState) viewBinding.lifecycleOwner = viewLifecycleOwner viewBinding.setVariable(BR.bindings, bindings) } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onDestroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { cancel() <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onDestroy() } }</code> </pre> <br><p>  Kami menandai ViewModel kami sebagai CoroutineScope sehingga kami dapat memulai coroutine di dalam model tampilan dan setiap coroutine yang diluncurkan akan terbatas pada siklus hidup sebuah fragmen. </p><br><p>  Kita harus secara eksplisit menentukan metode <code>cancel()</code> siklus hidup siklus panggilan untuk membatalkan semua permintaan yang berjalan untuk menghindari kebocoran memori. </p><br><p>  Kami menetapkan <code>retainInstance = true</code> sehingga dalam konfigurasi perubahan fragmen tidak akan dibuat kembali sehingga kami dapat menyelesaikan semua permintaan yang sudah berjalan lama. </p><br><p>  Selain itu, kita harus mengatur lifecycleOwner ke pengikatan untuk mengaktifkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pengikatan data dua arah</a> . </p><br><h2 id="exception-handling">  Penanganan pengecualian </h2><br><p>  Menurut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi</a> Coroutines: </p><br><pre> <code class="plaintext hljs">Coroutine builders come in two flavors: propagating exceptions automatically (launch and actor) or exposing them to users (async and produce). The former treat exceptions as unhandled, similar to Java's Thread.uncaughtExceptionHandler</code> </pre> <br><p>  Karena kami menggunakan launcher builder dalam kebanyakan kasus, kami harus menentukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CoroutineExceptionHandler</a> <br>  CoroutineExceptionHandler adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CoroutineContext.Element</a> yang dapat digunakan untuk membangun konteks coroutine menggunakan operator plus. <br>  Saya akan mendeklarasikan pengendali statis sebagai berikut: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> exceptionHandler = CoroutineExceptionHandler { _, throwable -&gt; Timber.e(throwable) }</code> </pre> <br><p>  Dan ubah BaseViewModel: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseViewModel</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">B : BaseBindings, V : ViewDataBinding</span></span></span><span class="hljs-class">&gt; : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Fragment</span></span></span></span>(), CoroutineScope <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> CoroutineScope(Dispatchers.IO + exceptionHandler)</code> </pre> <br><p>  Dari sini, pengecualian apa pun yang terjadi di coroutine yang diluncurkan di dalam ruang lingkup ViewModel akan dikirimkan ke handler yang diberikan. <br>  Selanjutnya, saya perlu mendeklarasikan API dan DAO saya: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DeliveriesApi</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@GET(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"deliveries"</span></span></span><span class="hljs-meta">)</span></span> <span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getDeliveries</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-meta"><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta">@Query(</span></span></span><span class="hljs-meta-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta"><span class="hljs-meta-string">"offset"</span></span></span></span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta">)</span></span></span></span><span class="hljs-function"><span class="hljs-params"> offset: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-meta"><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta">@Query(</span></span></span><span class="hljs-meta-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta"><span class="hljs-meta-string">"limit"</span></span></span></span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta">)</span></span></span></span><span class="hljs-function"><span class="hljs-params"> limit: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: List&lt;DeliveryResponse&gt; } <span class="hljs-meta"><span class="hljs-meta">@Dao</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DeliveryDao</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Query(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SELECT * FROM </span></span><span class="hljs-subst"><span class="hljs-meta"><span class="hljs-meta-string"><span class="hljs-subst">${DeliveryEntity.TABLE_NAME}</span></span></span></span><span class="hljs-meta"><span class="hljs-meta-string">"</span></span></span><span class="hljs-meta">)</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: DataSource.Factory&lt;<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>, DeliveryEntity&gt; <span class="hljs-meta"><span class="hljs-meta">@Insert(onConflict = OnConflictStrategy.REPLACE)</span></span> <span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">insert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(delivery: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">DeliveryEntity</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> }</code> </pre> <br><p>  Seperti yang Anda lihat, saya menandai metode sebagai ditangguhkan sehingga kami dapat mendeklarasikan objek respons yang diharapkan.  Selain itu, pembatalan coroutine induk juga akan membatalkan panggilan jaringan. <br>  Hal yang sama untuk DAO. <br>  Satu-satunya perbedaan adalah bahwa kami ingin memberikan kemampuan untuk mengamati basis data. <br>  Cara termudah adalah dengan menggunakan dukungan data langsung bawaan.  Tetapi jika kita akan menandai getAll () sebagai ditangguhkan itu akan menyebabkan kesalahan kompilasi <br>  kesalahan: </p><br><pre> <code class="plaintext hljs">Not sure how to convert a Cursor to this method's return type ...</code> </pre> <br><p>  Di sini kita tidak perlu menunda karena: </p><br><ul><li>  Permintaan Db dilakukan di latar belakang secara default </li><li>  LiveData yang dihasilkan adalah siklus hidup yang sadar sehingga kita tidak perlu membatalkannya secara manual </li></ul><br><p>  Kami harus menggabungkan sumber data jarak jauh dan lokal. <br>  Layak untuk diingat - harus ada satu-satunya titik kebenaran. <br>  Menurut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">desain offline-pertama</a> , itu akan menjadi penyimpanan lokal.  Jadi, kami akan mengamati status basis data.  Ketika tidak ada yang dapat diambil, kami akan meminta data dari jarak jauh dan memasukkannya ke database. <br>  Kami akan memperkenalkan kelas Daftar </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Listing</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">&gt;</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> pagedList: LiveData&lt;PagedList&lt;T&gt;&gt;, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> dataState: LiveData&lt;DataState&gt;, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> refreshState: LiveData&lt;DataState&gt;, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> refresh: () -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> retry: () -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> )</code> </pre> <br><p>  Mari kita pergi val demi val: </p><br><ul><li>  pagedList - data utama yang dibangun sebagai PagedList untuk mengaktifkan pengguliran tak terbatas dan dibungkus dengan LiveData untuk memungkinkan pengamatan data </li><li>  dataState - salah satu dari tiga negara di mana data kita bisa: Sukses, Berjalan, Kesalahan.  Juga dibungkus dengan LiveData untuk mengamati perubahan </li><li>  refreshState - saat kami memicu penyegaran data melalui swipe-to-refresh, kami memerlukan beberapa alat yang dengannya kami akan membedakan antara umpan balik permintaan menyegarkan dan umpan balik permintaan halaman berikutnya.  Untuk yang pertama, kami ingin menunjukkan kesalahan di akhir daftar tetapi untuk kesalahan penyegaran, kami ingin menampilkan pesan roti panggang dan menyembunyikan loader. </li><li>  refresh () - callback untuk memicu swipe-to-refresh </li><li><p>  coba lagi () - panggil balik untuk memicu kesalahan pemuatan pagedList <br>  Selanjutnya, model tampilan daftar: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DeliveryListViewModel</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">BaseViewModel</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DeliveryListBindings, DeliveryListBinding</span></span></span><span class="hljs-class">&gt;</span></span>(), DeliveryListBindings, DeliveryListItemBindings, DeliveryListErrorBindings { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> layoutId: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = R.layout.delivery_list <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> bindings: DeliveryListBindings = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> deliveryGateway: DeliveryGateway <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> inject { parametersOf(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> listing = deliveryGateway.getDeliveries() <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> dataState = listing.dataState <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> isRefreshing = Transformations.switchMap(listing.refreshState) { MutableLiveData(it == DataState.Loading) } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onViewCreated</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(view: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">View</span></span></span></span><span class="hljs-function"><span class="hljs-params">, savedInstanceState: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Bundle</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onViewCreated(view, savedInstanceState) setupList() setupRefresh() } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setupList</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> adapter = DeliveriesAdapter(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) viewBinding.deliveries.adapter = adapter viewBinding.deliveries.setHasFixedSize(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) listing.pagedList.observe(viewLifecycleOwner, Observer { adapter.submitList(it) }) listing.dataState.observe(viewLifecycleOwner, Observer { adapter.updateDataState(it) }) } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setupRefresh</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { listing.refreshState.observe(viewLifecycleOwner, Observer { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (it <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> DataState.Error) { Toast.makeText(context, it.message, LENGTH_SHORT).show() } }) } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">refresh</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { listing.refresh() } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onDeliveryClicked</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(delivery: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Delivery</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { view?.findNavController()?.navigate(DeliveryListViewModelDirections.toDetails(delivery)) } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onRetryClicked</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { listing.retry() } }</code> </pre> <br><p>  Mari kita mulai dari deklarasi kelas. </p><br></li></ul><br><p>  Pertama-tama, DeliveryListBindings dan DeliveryListBinding.  Pertama adalah antarmuka yang dinyatakan untuk merekatkan model tampilan dengan tampilan XML.  Kedua adalah kelas autogenerated berdasarkan XML.  Kita membutuhkan yang kedua untuk mengatur antarmuka binding dan siklus hidup kita ke XML. </p><br><p>  Selain itu, adalah praktik yang baik untuk mereferensikan pandangan menggunakan pengikatan autogenerated ini daripada menggunakan sintetik kotlin. </p><br><p>  Mungkin ada kasus ketika dirujuk melalui tampilan sintetis tidak ada dalam tampilan saat ini.  Dengan pengikatan data, Anda akan gagal dengan cepat bahkan pada tahap kompilasi. </p><br><p>  Berikutnya, tiga antarmuka: DeliveryListBindings, DeliveryListItemBindings, DeliveryListErrorBindings. </p><br><ol><li>  <em>DeliveryListBindings</em> - binding untuk layar itu sendiri.  Misalnya, ini berisi metode refresh () yang dipanggil dengan gesekan vertikal. </li><li>  <em>DeliveryListItemBindings</em> - binding untuk item dalam daftar.  Misalnya, onClicked () </li><li>  <em>DeliveryListErrorBindings</em> - binding untuk tampilan kesalahan yang juga merupakan item daftar yang ditunjukkan pada status kesalahan.  Misalnya, ini berisi metode coba lagi () </li></ol><br><p>  Dengan demikian, kami menangani semuanya dalam model tampilan tunggal karena ini adalah layar tunggal tetapi juga mengikuti prinsip <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Segregasi Antarmuka</a> </p><br><p>  Mari kita mengalihkan perhatian khusus ke baris ini: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> deliveryGateway: DeliveryGateway <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> inject { parametersOf(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) }</code> </pre> <br><p>  <em>DeliveryGateway</em> perlu melakukan permintaan dari utas utama.  Jadi, perlu mendeklarasikan metode sebagai ditangguhkan atau CoroutineScope untuk meluncurkan coroutine baru pada ruang lingkup ini.  Kami akan memilih pendekatan kedua karena kami membutuhkan LiveData kami dari awal dan kemudian kami hanya akan menunggu pembaruan darinya.  Ini sangat mirip dengan berlangganan ke instance liveData ketika kita melewati lifecycleOwner (yang sering merujuk pada 'ini').  Berikut adalah cara yang sama kita melewati 'ini' sebagai CoroutineScope </p><br><p>  Antarmuka CoroutineScope terdiri dari bidang tunggal - CoroutineContext.  Intinya, ruang lingkup dan konteks adalah hal yang sama.  Perbedaan antara konteks dan ruang lingkup adalah dalam tujuan yang dimaksudkan. </p><br><p>  Untuk mempelajari lebih lanjut tentang ini, saya akan merekomendasikan sebuah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> oleh Roman Elizarov.  Jadi, menyediakan ruang lingkup untuk <em>DeliveryGateway</em> juga akan menghasilkan penggunaan konteks yang sama.  Khususnya penangan utas, pekerjaan, dan pengecualian. <br>  Sekarang mari kita lihat DeliveryGateway itu sendiri: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DeliveryBoundGateway</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> db: DataBase, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> api: DeliveriesApi, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> deliveryDao: DeliveryDao, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> coroutineScope: CoroutineScope ) : DeliveryGateway { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> boundaryCallback = DeliveriesBoundaryCallback( api = api, coroutineScope = coroutineScope, handleResponse = { insertIntoDatabase(it) } ) <span class="hljs-meta"><span class="hljs-meta">@MainThread</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getDeliveries</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: Listing&lt;Delivery&gt; { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> refreshTrigger = MutableLiveData&lt;<span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>&gt;() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> refreshState = Transformations.switchMap(refreshTrigger) { refresh() } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> pagingConfig = Config( initialLoadSizeHint = PAGE_SIZE, pageSize = PAGE_SIZE, prefetchDistance = PAGE_SIZE ) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> deliveries = deliveryDao.getAll() .toLiveData( config = pagingConfig, boundaryCallback = boundaryCallback ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Listing( pagedList = deliveries, dataState = boundaryCallback.dataState, retry = { boundaryCallback.helper.retryAllFailed() }, refresh = { refreshTrigger.value = <span class="hljs-literal"><span class="hljs-literal">null</span></span> }, refreshState = refreshState ) } <span class="hljs-comment"><span class="hljs-comment">/** * When refresh is called, we simply run a fresh network request and when it arrives, clear * the database table and insert all new items in a transaction. * &lt;p&gt; * Since the PagedList already uses a database bound data source, it will automatically be * updated after the database transaction is finished. */</span></span> <span class="hljs-meta"><span class="hljs-meta">@MainThread</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">refresh</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: LiveData&lt;DataState&gt; { boundaryCallback.refresh() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> dataState = MutableLiveData&lt;DataState&gt;() dataState.value = DataState.Loading coroutineScope.launch { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> deliveries = api.getDeliveries(<span class="hljs-number"><span class="hljs-number">0</span></span>, PAGE_SIZE) db.withTransaction { deliveryDao.clear() insertIntoDatabase(deliveries) } dataState.postValue(DataState.Loaded) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (throwable: Throwable) { Timber.w(throwable) dataState.postValue(DataState.Error(throwable.message)) } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dataState } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">insertIntoDatabase</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(deliveries: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">DeliveryResponse</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> { deliveries.forEach { delivery -&gt; <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> entity = deliveryConverter.fromNetwork(delivery) deliveryDao.insert(entity) } } <span class="hljs-keyword"><span class="hljs-keyword">companion</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> PAGE_SIZE = <span class="hljs-number"><span class="hljs-number">20</span></span> } }</code> </pre> <br><p>  Di sini kita sedang membangun struktur LiveData dari awal dan kemudian menggunakan coroutines memuat data dan mempostingnya ke LiveData.  Kami juga menggunakan implementasi <em>PagedList.BoundaryCallback () untuk merekatkan basis data lokal dan API jarak jauh.</em>  <em>Ketika kita mencapai akhir <em>batas</em> daftar <em>pagedCallback</em> dipicu dan memuat potongan data berikutnya.</em> <br></p><p>  Seperti yang Anda lihat, kami menggunakan coroutineScope untuk meluncurkan coroutine baru. </p><br><p>  Karena ruang lingkup ini sama dengan siklus hidup fragmen - semua permintaan yang tertunda akan dibatalkan pada panggilan balik <code>onDestroy()</code> fragmen. </p><br><p>  Halaman detail pengiriman cukup mudah - kami hanya melewatkan objek Pengiriman sebagai Parcelable dari layar utama menggunakan komponen navigasi, simpan plugin args.  Pada layar detail cukup ikat diberi objek ke XML. </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DeliveryViewModel</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">BaseViewModel</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DeliveryBindings, DeliveryBinding</span></span></span><span class="hljs-class">&gt;</span></span>(), DeliveryBindings { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> layoutId: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = R.layout.delivery <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> bindings: DeliveryBindings = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> args: DeliveryViewModelArgs <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> navArgs() <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onViewCreated</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(view: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">View</span></span></span></span><span class="hljs-function"><span class="hljs-params">, savedInstanceState: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Bundle</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onViewCreated(view, savedInstanceState) viewBinding.delivery = args.delivery viewBinding.image.clipToOutline = <span class="hljs-literal"><span class="hljs-literal">true</span></span> } }</code> </pre> <br><h2 id="contact-me">  Hubungi saya </h2><br><p>  Berikut ini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tautan</a> ke kode sumber github. </p><br><p>  Anda dipersilakan untuk meninggalkan komentar dan masalah terbuka. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id465529/">https://habr.com/ru/post/id465529/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id465519/index.html">Pameran PRO // Movement.Expo</a></li>
<li><a href="../id465521/index.html">Fly-fly-petal ... atau kisah tentang bagaimana desainer UX mempromosikan produknya di Instagram</a></li>
<li><a href="../id465523/index.html">Namun ular Android lainnya dengan Kivy, Python</a></li>
<li><a href="../id465525/index.html">Laporan seluler tentang Oracle BI EE 12c - satu, dua, tiga. Metodologi dari Kursus Oracle BI EE 12c CAD</a></li>
<li><a href="../id465527/index.html">Perjalanan panjang dari RFC 4357 ke RFC 8645 atau cara mengelola kunci enkripsi</a></li>
<li><a href="../id465531/index.html">Membongkar daftar bersarang dari kedalaman yang tidak terbatas</a></li>
<li><a href="../id465535/index.html">Siapa yang mengimplementasikan IPv6, dan apa yang menghambat perkembangannya</a></li>
<li><a href="../id465537/index.html">Yandex: rumah pintar dewasa</a></li>
<li><a href="../id465539/index.html">766 km - rekor jangkauan baru untuk LoRaWAN</a></li>
<li><a href="../id465541/index.html">Dari Perusahaan ke SMB: Kami berbagi pengalaman kami dalam mengadaptasi solusi perusahaan untuk usaha kecil dan menengah dengan monetisasi menggunakan model SaaS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>