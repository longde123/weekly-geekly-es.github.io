<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚¨ÜÔ∏è üñåÔ∏è ‚¨úÔ∏è Reine Tests in PHP und PHPUnit üë©‚Äçüëß üé£ ‚öïÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Es gibt viele Tools im PHP-√ñkosystem, die bequemes PHP-Testen erm√∂glichen. Eines der bekanntesten ist PHPUnit , was beinahe ein Synonym f√ºr das Testen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Reine Tests in PHP und PHPUnit</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/485124/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/jx/3y/zg/jx3yzg2jnznn0kwnk6oe6ikvlzw.jpeg" width="400"></div><br>  Es gibt viele Tools im PHP-√ñkosystem, die bequemes PHP-Testen erm√∂glichen.  Eines der bekanntesten ist <a href="https://github.com/sebastianbergmann/phpunit">PHPUnit</a> , was beinahe ein Synonym f√ºr das Testen in dieser Sprache ist.  √úber gute Testmethoden wird jedoch nicht viel geschrieben.  Es gibt viele M√∂glichkeiten, warum und wann man Tests schreibt, welche Art von Tests und so weiter.  <b>Um</b> ehrlich zu sein, macht es <b>keinen Sinn, einen Test zu schreiben, wenn Sie ihn sp√§ter nicht lesen k√∂nnen</b> . <br><br>  Tests sind eine besondere Art der Dokumentation.  Wie <a href="https://thephp.website/en/issue/real-life-tdd-php/">ich bereits in PHP √ºber TDD geschrieben habe</a> , wird im Test immer (oder zumindest sollte) klar angegeben, welche Aufgabe ein bestimmtes St√ºck Code hat. <br><br>  Wenn ein Test diese Idee nicht ausdr√ºcken kann, ist der Test schlecht. <br><br>  Ich habe eine Reihe von Techniken vorbereitet, mit denen PHP-Entwickler gute, lesbare und n√ºtzliche Tests schreiben k√∂nnen. <br><a name="habracut"></a><br><h2>  Beginnen wir mit den Grundlagen </h2><br>  Es gibt eine Reihe von Standardtechniken, denen viele ohne Fragen folgen.  Ich werde viele von ihnen erw√§hnen und versuchen zu erkl√§ren, warum sie gebraucht werden. <br><br><h3>  1. Tests sollten keine Eingabe-Ausgabe-Operationen enthalten </h3><br>  <b>Der Hauptgrund</b> : E / A-Vorg√§nge sind langsam und unzuverl√§ssig. <br><br>  <b>Langsam</b> : Auch wenn Sie √ºber die beste Hardware der Welt verf√ºgen, ist die E / A-Verarbeitung langsamer als der Speicherzugriff.  Tests sollten immer schnell funktionieren, sonst werden sie zu selten ausgef√ºhrt. <br><br>  <b>Unzuverl√§ssig</b> : Einige Dateien, Bin√§rdateien, Sockets, Ordner und DNS-Eintr√§ge sind m√∂glicherweise auf einigen Computern, auf denen Sie testen, nicht verf√ºgbar.  Je mehr Sie sich auf das Testen von E / A verlassen, desto st√§rker sind Ihre Tests an die Infrastruktur gebunden. <br><br>  Welche Operationen beziehen sich auf I / O: <br><br><ul><li>  Dateien lesen und schreiben. <br></li><li>  Netzwerkanrufe. <br></li><li> Aufrufe an externe Prozesse (mit <code>exec</code> , <code>proc_open</code> usw.). <br></li></ul><br>  Es gibt Situationen, in denen das Vorhandensein von Eingabe- / Ausgabeoperationen es Ihnen erm√∂glicht, Tests schneller zu schreiben.  Aber seien Sie vorsichtig: Vergewissern Sie sich, dass diese Vorg√§nge bei der Entwicklung, Montage und Bereitstellung auf Ihren Maschinen gleich funktionieren, da Sie sonst m√∂glicherweise ernsthafte Probleme haben. <br><br>  Isolieren Sie die Tests so, dass sie keine E / A-Vorg√§nge ben√∂tigen: Im Folgenden finden Sie eine Architekturl√∂sung, die verhindert, dass Tests E / A-Vorg√§nge ausf√ºhren, indem die Verantwortung zwischen den Schnittstellen aufgeteilt wird. <br><br>  Ein Beispiel: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPeople</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">array</span></span></span><span class="hljs-function"> </span></span>{ $rawPeople = file_get_contents( <span class="hljs-string"><span class="hljs-string">'people.json'</span></span> ) ?? <span class="hljs-string"><span class="hljs-string">'[]'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> json_decode( $rawPeople, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> ); }</code> </pre><br>  Wenn Sie mit dem Testen mit dieser Methode beginnen, wird eine lokale Datei erstellt und von Zeit zu Zeit werden Snapshots erstellt: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testGetPeopleReturnsPeopleList</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span></span>{ $people = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;peopleService -&gt;getPeople(); <span class="hljs-comment"><span class="hljs-comment">// assert it contains people }</span></span></code> </pre> <br>  Dazu m√ºssen die Voraussetzungen f√ºr die Ausf√ºhrung der Tests konfiguriert werden.  Auf den ersten Blick sieht alles vern√ºnftig aus, aber in Wirklichkeit ist es schrecklich. <br><br>  Das √úberspringen eines Tests, weil die Voraussetzungen nicht erf√ºllt sind, garantiert nicht die Qualit√§t unserer Software.  Dies wird nur Fehler verbergen! <br><br>  <b>Wir beheben die Situation</b> : Wir isolieren E / A-Operationen, indem wir die Verantwortung auf die Schnittstelle verlagern. <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// extract the fetching // logic to a specialized // interface interface PeopleProvider { public function getPeople(): array; } // create a concrete implementation class JsonFilePeopleProvider implements PeopleProvider { private const PEOPLE_JSON = 'people.json'; public function getPeople(): array { $rawPeople = file_get_contents( self::PEOPLE_JSON ) ?? '[]'; return json_decode( $rawPeople, true ); } } class PeopleService { // inject via __construct() private PeopleProvider $peopleProvider; public function getPeople(): array { return $this-&gt;peopleProvider -&gt;getPeople(); } }</span></span></code> </pre> <br>  Jetzt wei√ü ich, dass <code>JsonFilePeopleProvider</code> auf jeden Fall I / O verwenden wird. <br><br>  Anstelle von <code>file_get_contents()</code> Sie eine Abstraktionsebene wie <a href="https://flysystem.thephpleague.com/docs/adapter/local/">das Flysystem-Dateisystem verwenden</a> , f√ºr das es einfach ist, Stubs zu <a href="https://flysystem.thephpleague.com/docs/adapter/local/">erstellen</a> . <br><br>  Und warum brauchen wir dann <code>PeopleService</code> ?  Gute Frage.  Dazu sind Tests erforderlich: um die Architektur herauszufordern und nutzlosen Code zu entfernen. <br><br><h3>  2. Tests sollten bewusst und aussagekr√§ftig sein. </h3><br>  <b>Der Hauptgrund</b> : Tests sind eine Form der Dokumentation.  Halten Sie sie klar, pr√§zise und lesbar. <br><br>  <b>Klarheit und K√ºrze</b> : kein Durcheinander, keine tausend Stichleitungen, keine Abfolge von Aussagen. <br><br>  <b>Lesbarkeit</b> : Tests sollten eine Geschichte erz√§hlen.  Die gegebene, wann, dann-Struktur ist daf√ºr hervorragend. <br><br>  Merkmale eines guten und lesbaren Tests: <br><br><ul><li>  Enth√§lt nur die erforderlichen Aufrufe der <code>assert</code> Methode (vorzugsweise eine). <br></li><li>  Er erkl√§rt sehr deutlich, was unter gegebenen Bedingungen geschehen soll. <br></li><li>  Es wird nur ein Zweig der Methodenausf√ºhrung getestet. <br></li><li>  Um einer Aussage willen macht er keinen Stummel f√ºr das ganze Universum. <br></li></ul><br>  Es ist wichtig zu beachten, dass, wenn Ihre Implementierung bedingte Ausdr√ºcke, √úbergangsoperatoren oder Schleifen enth√§lt, diese alle explizit durch Tests abgedeckt werden sollten.  Zum Beispiel, damit fr√ºhe Antworten immer einen Test enthalten. <br><br>  Ich wiederhole: Es geht nicht um Berichterstattung, sondern um Dokumentation. <br><br>  Hier ist ein Beispiel f√ºr einen verwirrenden Test: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testCanFly</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span></span>{ $noWings = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Person(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;assertEquals( <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, $noWings-&gt;canFly() ); $singleWing = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Person(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;assertTrue( !$singleWing-&gt;canFly() ); $twoWings = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Person(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;assertTrue( $twoWings-&gt;canFly() ); }</code> </pre> <br>  Passen wir das Format "gegeben wann, dann" an und sehen, was passiert: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testCanFly</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Given $person = $this-&gt;givenAPersonHasNoWings(); // Then $this-&gt;assertEquals( false, $person-&gt;canFly() ); // Further cases... } private function givenAPersonHasNoWings(): Person { return new Person(0); }</span></span></code> </pre> <br>  Wie im Abschnitt "Given" k√∂nnen "when" und "then" auf private Methoden √ºbertragen werden.  Dadurch wird Ihr Test besser lesbar. <br><br>  <code>assertEquals</code> sinnloses Durcheinander.  Die Person, die dies liest, muss die Aussage verfolgen, um zu verstehen, was es bedeutet. <br><br>  Durch die Verwendung bestimmter Anweisungen wird Ihr Test viel lesbarer.  <code>assertTrue()</code> sollte eine Boolesche Variable erhalten, keinen Ausdruck wie <code>canFly() !== true</code> . <br><br>  Im vorherigen Beispiel ersetzen wir <code>assertEquals</code> zwischen <code>false</code> und <code>$person-&gt;canFly()</code> durch eine einfache <code>assertFalse</code> : <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// ... $person = $this-&gt;givenAPersonHasNoWings(); $this-&gt;assertFalse( $person-&gt;canFly() ); // Further cases...</span></span></code> </pre> <br>  Jetzt ist alles sehr klar!  Wenn ein Mensch keine Fl√ºgel hat, darf er nicht fliegen k√∂nnen!  Lesen Sie wie ein Gedicht <br><br>  Nun ist der Abschnitt ‚ÄûWeitere F√§lle‚Äú, der in unserem Text zweimal vorkommt, ein klares Indiz daf√ºr, dass der Test zu viele Aussagen macht.  Die <code>testCanFly()</code> -Methode ist v√∂llig nutzlos. <br><br>  Lassen Sie uns den Test noch einmal verbessern: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testCanFlyIsFalsyWhenPersonHasNoWings</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span></span>{ $person = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;givenAPersonHasNoWings(); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;assertFalse( $person-&gt;canFly() ); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testCanFlyIsTruthyWhenPersonHasTwoWings</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span></span>{ $person = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;givenAPersonHasTwoWings(); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;assertTrue( $person-&gt;canFly() ); } <span class="hljs-comment"><span class="hljs-comment">// ...</span></span></code> </pre> <br>  Wir k√∂nnen die <code>testPersonCantFlyWithoutWings</code> sogar so umbenennen, dass sie mit dem tats√§chlichen Szenario √ºbereinstimmt, z. B. in <code>testPersonCantFlyWithoutWings</code> , aber mir passt <code>testPersonCantFlyWithoutWings</code> alles. <br><br><h3>  3. Der Test sollte nicht von anderen Tests abh√§ngen </h3><br>  <b>Der Hauptgrund</b> : Tests sollten in beliebiger Reihenfolge erfolgreich ausgef√ºhrt werden. <br><br>  Ich sehe keine ausreichenden Gr√ºnde, um Verbindungen zwischen Tests herzustellen.  K√ºrzlich wurde ich gebeten, einen Login-Funktionstest durchzuf√ºhren, den ich hier als gutes Beispiel geben werde. <br><br>  Der Test sollte: <br><br><ul><li>  Generieren Sie ein JWT-Token f√ºr die Anmeldung. <br></li><li>  F√ºhren Sie die Login-Funktion aus. <br></li><li>  Genehmigen Sie die Status√§nderung. <br></li></ul><br>  Es war so: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testGenerateJWTToken</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... $token $this-&gt;token = $token; } // @depends testGenerateJWTToken public function testExecuteAnAmazingFeature(): void { // Execute using $this-&gt;token } // @depends testExecuteAnAmazingFeature public function testStateIsBlah(): void { // Poll for state changes on // Logged-in interface }</span></span></code> </pre> <br>  Das ist aus mehreren Gr√ºnden schlecht: <br><br><ul><li>  PHPUnit kann diese Ausf√ºhrungsreihenfolge nicht garantieren. <br></li><li>  Tests m√ºssen unabh√§ngig voneinander ausgef√ºhrt werden k√∂nnen. <br></li><li>  Parallele Tests k√∂nnen zuf√§llig fehlschlagen. <br></li></ul><br>  Der einfachste Weg, dies zu umgehen, besteht darin, das gegebene when then-Schema zu verwenden.  Damit die Tests nachdenklicher werden, werden sie eine Geschichte erz√§hlen, ihre Abh√§ngigkeiten klar demonstrieren und die getestete Funktion erkl√§ren. <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testAmazingFeatureChangesState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Given $token = $this-&gt;givenImAuthenticated(); // When $this-&gt;whenIExecuteMyAmazingFeature( $token ); $newState = $this-&gt;pollStateFromInterface( $token ); // Then $this-&gt;assertEquals( 'my-state', $newState ); }</span></span></code> </pre> <br>  Wir m√ºssen auch Tests f√ºr die Authentifizierung usw. hinzuf√ºgen. Diese Struktur ist so gut, dass <a href="https://behat.org/en/latest/quick_start.html">standardm√§√üig Behat verwendet wird</a> . <br><br><h3>  4. Implementieren Sie immer Abh√§ngigkeiten </h3><br>  <b>Der Hauptgrund</b> : ein sehr schlechter Ton - um einen Stummel f√ºr den globalen Staat zu schaffen.  Die Unf√§higkeit, Stubs f√ºr Abh√§ngigkeiten zu erstellen, erm√∂glicht es nicht, die Funktion zu testen. <br><br>  N√ºtzlicher Hinweis: <b>Vergessen Sie statische stateful-Klassen und Singleton-Instanzen</b> .  Wenn Ihre Klasse von etwas abh√§ngt, machen Sie es so, dass es implementiert werden kann. <br><br>  Hier ist ein trauriges Beispiel: <br><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FeatureToggle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isActive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Id $feature )</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span><span class="hljs-function"> </span></span>{ $cookieName = $feature-&gt;getCookieName(); <span class="hljs-comment"><span class="hljs-comment">// Early return if cookie // override is present if (Cookies::exists( $cookieName )) { return Cookies::get( $cookieName ); } // Evaluate feature toggle... } }</span></span></code> </pre> <br>  Wie kann ich diese fr√ºhe Antwort testen? <br><br>  Alles ist richtig.  Auf keinen Fall. <br><br>  Um dies zu testen, m√ºssen wir das Verhalten der Klasse " <code>Cookies</code> verstehen und sicherstellen, dass wir alle damit verbundenen Umgebungen reproduzieren k√∂nnen, was zu bestimmten Antworten f√ºhrt. <br><br>  Mach das nicht. <br><br>  Die Situation kann korrigiert werden, wenn Sie eine Instanz von <code>Cookies</code> als Abh√§ngigkeit implementieren.  Der Test sieht folgenderma√üen aus: <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// Test class... private Cookies $cookieMock; private FeatureToggle $service; // Preparing our service and dependencies public function setUp(): void { $this-&gt;cookieMock = $this-&gt;prophesize( Cookies::class ); $this-&gt;service = new FeatureToggle( $this-&gt;cookieMock-&gt;reveal() ); } public function testIsActiveIsOverriddenByCookies(): void { // Given $feature = $this-&gt;givenFeatureXExists(); // When $this-&gt;whenCookieOverridesFeatureWithTrue( $feature ); // Then $this-&gt;assertTrue( $this-&gt;service-&gt;isActive($feature) ); // additionally we can assert // no other methods were called } private function givenFeatureXExists(): Id { // ... return $feature; } private function whenCookieOverridesFeatureWithTrue( Id $feature ): void { $cookieName = $feature-&gt;getCookieName(); $this-&gt;cookieMock-&gt;exists($cookieName) -&gt;shouldBeCalledOnce() -&gt;willReturn(true); $this-&gt;cookieMock-&gt;get($cookieName) -&gt;shouldBeCalledOnce() -&gt;willReturn(true); }</span></span></code> </pre> <br>  Gleiches gilt f√ºr Singletones.  Wenn Sie also ein Objekt eindeutig machen m√∂chten, konfigurieren Sie den Abh√§ngigkeitsinjektor korrekt, anstatt das (Anti) Singleton-Muster zu verwenden.  Andernfalls schreiben Sie Methoden, die nur f√ºr F√§lle wie <code>reset()</code> oder <code>setInstance()</code> n√ºtzlich sind.  Meiner Meinung nach ist das verr√ºckt. <br><br>  Es ist v√∂llig normal, die Architektur zu √§ndern, um das Testen zu vereinfachen.  Und Methoden zu entwickeln, die das Testen erleichtern, ist nicht normal. <br><br><h3>  5. Testen Sie niemals gesch√ºtzte / private Methoden </h3><br>  <b>Der Hauptgrund</b> : Sie beeinflussen die Art und Weise, in der wir Funktionen testen, indem sie die Signatur des Verhaltens bestimmen. Unter einer solchen Bedingung erwarte ich, dass ich bei Eingabe von A B erhalte. <b>Private / gesch√ºtzte Methoden sind nicht Teil der Funktionssignaturen</b> . <br><br>  Ich m√∂chte nicht einmal einen Weg zeigen, um private Methoden zu "testen", aber ich gebe einen Hinweis: Sie k√∂nnen dies nur mit der <a href="https://www.php.net/manual/en/book.reflection.php">Reflection-</a> API tun. <br><br>  Bestrafen Sie sich immer irgendwie, wenn Sie daran denken, private Methoden mit Reflektion zu testen!  Schlechter, schlechter Entwickler! <br><br>  Private Methoden werden per Definition nur intern aufgerufen.  Das hei√üt, sie sind nicht √∂ffentlich verf√ºgbar.  Dies bedeutet, dass nur √∂ffentliche Methoden derselben Klasse solche Methoden aufrufen k√∂nnen. <br><br>  <b>Wenn Sie alle Ihre √∂ffentlichen Methoden getestet haben, haben Sie auch alle privaten / gesch√ºtzten Methoden getestet</b> .  Ist dies nicht der Fall, entfernen Sie private / gesch√ºtzte Methoden frei, sie werden von niemandem verwendet. <br><br><h2>  Fortgeschrittene Tipps </h2><br>  Ich hoffe dir ist noch nicht langweilig.  Trotzdem musste ich √ºber die Grundlagen sprechen.  Jetzt teile ich meine Meinung zum Schreiben sauberer Tests und Entscheidungen, die sich auf meinen Entwicklungsprozess auswirken. <br><br>  Das Wichtigste, das ich beim Schreiben von Tests nicht vergesse: <br><br><ul><li>  Studie. <br></li><li>  Schnelles Feedback. <br></li><li>  Dokumentation <br></li><li>  Refactoring <br></li><li>  Design w√§hrend des Testens. <br></li></ul><br><h3>  1. Tests am Anfang, nicht am Ende </h3><br>  <b>Werte</b> : Studie, schnelles Feedback, Dokumentation, Umgestaltung, Design w√§hrend des Tests. <br><br>  Das ist die Basis von allem.  Der wichtigste Aspekt, der alle aufgelisteten Werte beinhaltet.  Wenn Sie Tests im Voraus schreiben, k√∂nnen Sie zun√§chst nachvollziehen, wie das Schema ‚ÄûGegeben, Wann, Dann‚Äú aufgebaut sein sollte.  Dabei dokumentieren Sie zun√§chst Ihre Anforderungen und legen sie vor allem als wichtigste Aspekte fest. <br><br>  Ist es seltsam, Tests vor der Implementierung zu schreiben?  Und stellen Sie sich vor, wie seltsam es ist, etwas zu implementieren, und wenn Sie testen, um herauszufinden, ob all Ihre Ausdr√ºcke "gegeben, wenn, dann" keinen Sinn ergeben. <br><br>  Dieser Ansatz √ºberpr√ºft auch Ihre Erwartungen alle zwei Sekunden.  Sie erhalten so schnell wie m√∂glich eine R√ºckmeldung.  Egal wie gro√ü oder klein das Feature aussieht. <br><br>  Gr√ºne Tests sind ein idealer Bereich f√ºr die Umgestaltung.  Die Grundidee: keine Tests - kein Refactoring.  Refactoring ohne Tests ist einfach gef√§hrlich. <br><br>  Wenn Sie schlie√ülich die Struktur auf "gegeben, wann" setzen, wird Ihnen klar, welche Schnittstellen Ihre Methoden haben sollten und wie sie sich verhalten sollten.  Wenn Sie den Test sauber halten, m√ºssen Sie auch st√§ndig andere architektonische Entscheidungen treffen.  Dies zwingt Sie dazu, Fabriken zu erstellen, Schnittstellen zu erstellen, die Vererbung zu unterbrechen usw. Und ja, das Testen wird einfacher! <br><br>  Wenn es sich bei Ihren Tests um Live-Dokumente handelt, in denen die Funktionsweise der Anwendung erl√§utert wird, muss dies unbedingt deutlich gemacht werden. <br><br><h3>  2. Besser ohne Tests als mit schlechten Tests </h3><br>  <b>Werte</b> : Studie, Dokumentation, Refactoring. <br><br>  Viele Entwickler denken √ºber Tests folgenderma√üen: Ich werde ein Feature schreiben, das Testframework so lange ansteuern, bis die Tests eine bestimmte Anzahl neuer Zeilen abdecken, und sie in Betrieb nehmen. <br><br>  Es scheint mir, dass Sie der Situation mehr Aufmerksamkeit schenken m√ºssen, wenn ein neuer Entwickler anf√§ngt, mit dieser Funktion zu arbeiten.  <b>Was sagen die Tests dieser Person?</b> <br><br>  Tests sind oft verwirrend, wenn die Namen nicht detailliert genug sind.  Was ist klarer: <code>testCanFly</code> oder <code>testCanFlyReturnsFalseWhenPersonHasNoWings</code> ? <br><br>  Wenn Ihre Tests nur chaotischer Code sind, der das Framework mehr Zeilen abdeckt, mit Beispielen, die keinen Sinn ergeben, ist es Zeit, anzuhalten und dar√ºber nachzudenken, ob diese Tests √ºberhaupt geschrieben werden sollen. <br><br>  Sogar Unsinn wie das Zuweisen von <code>$a</code> und <code>$b</code> Variablen oder das Zuweisen von Namen, die sich nicht auf eine bestimmte Verwendung beziehen. <br><br>  <b>Denken</b> Sie <b>daran</b> : Bei Ihren Tests handelt es sich um Live-Dokumente, in denen das Verhalten Ihrer Anwendung erl√§utert wird.  <code>assertFalse($a-&gt;canFly())</code> dokumentiert nicht viel.  Und <code>assertFalse($personWithNoWings-&gt;canFly())</code> ist schon ziemlich viel. <br><br><h3>  3. F√ºhren Sie die Tests intrusiv durch </h3><br>  <b>Werte</b> : Studie, schnelles Feedback, Refactoring. <br><br>  F√ºhren Sie die Tests aus, bevor Sie mit der Arbeit an Features beginnen.  Wenn sie fehlschlagen, bevor Sie sich an die Arbeit machen, werden Sie dar√ºber informiert, <i>bevor</i> Sie den Code schreiben, und Sie m√ºssen keine kostbaren Minuten damit verbringen, fehlerhafte Tests zu debuggen, die Sie nicht einmal interessiert haben. <br><br>  F√ºhren Sie nach dem Speichern der Datei die Tests aus.  Je fr√ºher Sie feststellen, dass etwas kaputt ist, desto schneller k√∂nnen Sie es reparieren und weitermachen.  Wenn eine Unterbrechung des Workflows zur L√∂sung eines Problems f√ºr Sie unproduktiv erscheint, stellen Sie sich vor, dass Sie sp√§ter viele Schritte zur√ºckgehen m√ºssen, wenn Sie das Problem nicht kennen. <br><br>  F√ºhren Sie die Tests aus, nachdem Sie sich f√ºnf Minuten mit Kollegen unterhalten oder Benachrichtigungen von Github √ºberpr√ºft haben.  Wenn sie rot werden, wissen Sie, wo Sie aufgeh√∂rt haben.  Wenn die Tests gr√ºn sind, k√∂nnen Sie weiterarbeiten. <br>  F√ºhren Sie nach jedem Refactoring, auch nach Variablennamen, die Tests durch. <br><br>  Im Ernst, f√ºhren Sie die verdammten Tests durch.  So oft Sie die Speichertaste dr√ºcken. <br>  <a href="https://github.com/spatie/phpunit-watcher">PHPUnit Watcher</a> kann dies f√ºr Sie tun und sogar Benachrichtigungen senden! <br><br><h3>  4. Gro√üe Tests - gro√üe Verantwortung </h3><br>  <b>Werte</b> : Studie, Umgestaltung, Design w√§hrend des Testens. <br><br>  Im Idealfall sollte jede Klasse einen Test haben.  Dieser Test sollte alle √∂ffentlichen Methoden in dieser Klasse sowie alle bedingten Ausdr√ºcke oder √úbergangsoperatoren abdecken ... <br><br>  Sie k√∂nnen so etwas nehmen: <br><br><ul><li>  Eine Klasse = ein Testfall. <br></li><li>  Eine Methode = ein oder mehrere Tests. <br></li><li>  Ein alternativer Zweig (if / switch / try-catch / exception) = ein Test. <br></li></ul><br>  F√ºr diesen einfachen Code ben√∂tigen Sie also vier Tests: <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// class Person public function eatSlice(Pizza $pizza): void { // test exception if ([] === $pizza-&gt;slices()) { throw new LogicException('...'); } // test exception if (true === $this-&gt;isFull()) { throw new LogicException('...'); } // test default path (slices = 1) $slices = 1; // test alternative path (slices = 2) if (true === $this-&gt;isVeryHungry()) { $slices = 2; } $pizza-&gt;removeSlices($slices); }</span></span></code> </pre> <br>  Je mehr √∂ffentliche Methoden Sie haben, desto mehr Tests werden ben√∂tigt. <br><br>  Niemand liest gerne lange Dokumentationen.  Da es sich bei Ihren Tests auch um Dokumente handelt, erh√∂hen die geringe Gr√∂√üe und Aussagekraft nur deren Qualit√§t und N√ºtzlichkeit. <br><br>  Es ist auch ein wichtiges Signal daf√ºr, dass Ihre Klasse Verantwortung ansammelt, und es ist an der Zeit, sie neu zu strukturieren, indem Sie eine Reihe von Funktionen auf andere Klassen √ºbertragen oder das System neu gestalten. <br><br><h3>  5. Unterst√ºtzen Sie eine Reihe von Tests, um Regressionsprobleme zu l√∂sen </h3><br>  <b>Werte</b> : Studie, Dokumentation, schnelles Feedback. <br><br>  Betrachten Sie die Funktion: <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findById</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string $id)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">object</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fromDb((int) $id); }</code> </pre> <br>  Sie denken, dass jemand "10" √ºbertr√§gt, aber tats√§chlich "10 Bananen" √ºbertragen werden.  Das hei√üt, zwei Werte kommen, aber einer ist √ºberfl√ºssig.  Du hast einen Bug. <br><br>  Was wirst du zuerst tun?  Schreiben Sie einen Test, der ein solches Verhalten als fehlerhaft markiert !!! <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testFindByIdAcceptsOnlyNumericIds</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;expectException(InvalidArgumentException::class); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;expectExceptionMessage( <span class="hljs-string"><span class="hljs-string">'Only numeric IDs are allowed.'</span></span> ); findById(<span class="hljs-string"><span class="hljs-string">"10 bananas"</span></span>); }</code> </pre> <br>  Tests √ºbertragen nat√ºrlich nichts.  Aber jetzt wissen Sie, was zu tun ist, damit sie senden.  Korrigieren Sie den Fehler, machen Sie die Tests gr√ºn, stellen Sie die Anwendung bereit und seien Sie zufrieden. <br><br>  Behalten Sie diesen Test bei sich.  Wann immer m√∂glich, in einer Reihe von Tests, um Probleme mit der Regression zu l√∂sen. <br><br>  Das ist alles!  Schnelles Feedback, Fehlerkorrekturen, Dokumentation, regressionsresistenter Code und Zufriedenheit. <br><br><h2>  Letztes Wort </h2><br>  Vieles davon ist nur meine pers√∂nliche Meinung, die ich w√§hrend meiner Karriere entwickelt habe.  Dies bedeutet nicht, dass der Rat wahr oder falsch ist, es ist nur eine Meinung. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de485124/">https://habr.com/ru/post/de485124/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de485108/index.html">Statistik der zertifizierten PMI-Spezialisten in Russland am 10.01.2020</a></li>
<li><a href="../de485110/index.html">Meine Erfahrung mit effektiver Fernarbeit</a></li>
<li><a href="../de485118/index.html">Clean Code von Robert Martin. Auszug. Wie schreibe ich klaren und sch√∂nen Code?</a></li>
<li><a href="../de485120/index.html">F√ºgen Sie unserer Anwendung eine sehr schnelle JSON-API hinzu.</a></li>
<li><a href="../de485122/index.html">Die √úberschrift "Artikel f√ºr Sie lesen." Oktober - Dezember 2019</a></li>
<li><a href="../de485126/index.html">Mu-mu, woof-woof, quack-quack: Evolution der akustischen Kommunikation</a></li>
<li><a href="../de485128/index.html">Sparen Sie bei Mikrotik CHR-Lizenzen</a></li>
<li><a href="../de485132/index.html">Nehmen Sie am Google Play Indie Games Festival teil</a></li>
<li><a href="../de485136/index.html">Istio Tracing and Monitoring: Microservices und das Unsicherheitsprinzip</a></li>
<li><a href="../de485138/index.html">Anwendungslokalisierung: Wie wir Freunde f√ºr die √úbersetzung und Entwicklung gewonnen haben</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>