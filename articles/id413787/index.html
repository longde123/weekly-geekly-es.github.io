<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏼‍⚖️ 🧀 👵🏻 Angular: ngx-terjemahkan. Meningkatkan infrastruktur dengan Webpack 🤛🏾 👸🏼 🤴🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hari yang baik 


 Sudah waktunya untuk ngx-menerjemahkan hacks kehidupan. Awalnya, saya merencanakan 3 bagian, tetapi karena bagian kedua sebenarnya ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Angular: ngx-terjemahkan. Meningkatkan infrastruktur dengan Webpack</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/413787/"><p>  Hari yang baik </p><br><p>  Sudah waktunya untuk ngx-menerjemahkan hacks kehidupan.  Awalnya, saya merencanakan 3 bagian, tetapi karena bagian kedua sebenarnya tidak terlalu informatif - dalam hal ini saya akan mencoba meringkas bagian ke-2 sesingkat mungkin. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1</a> </p><br><p> Pertimbangkan <code>AppTranslateLoader</code> untuk menggantikan <code>TranslateHttpLoader</code> .  <code>AppTranslateLoader</code> kami pertama-tama akan memperhatikan bahasa browser dan berisi logika mundur, mengimpor pelokalan MomentJs, dan memuat melalui APP_INITIALIZER.  Selain itu, sebagai hasil dari menggabungkan 2 bagian peretasan kehidupan, sepanjang perjalanan kita akan mempelajari penciptaan infrastruktur lokalisasi yang nyaman dan fleksibel dalam proyek ini. </p><br><p>  Tujuan utama bukanlah <code>AppTranslateLoader</code> (karena cukup sederhana dan tidak sulit dibuat), tetapi pembuatan infrastruktur. </p><br><p>  Saya mencoba menulis semudah mungkin diakses, tetapi karena artikel itu memiliki banyak hal yang dapat dijelaskan secara lebih rinci - itu akan memakan banyak waktu dan tidak akan menarik bagi mereka yang sudah tahu caranya).  Karena itu, artikel itu tidak terlalu ramah untuk pemula.  Di sisi lain, pada akhirnya ada tautan ke expample prodg. </p><a name="habracut"></a><br><p>  Sebelum memulai, saya ingin mencatat bahwa selain mengunduh bahasa melalui http, dimungkinkan untuk menulis loader sedemikian rupa sehingga memuat bahasa yang diperlukan ke dalam bundel kami pada tahap perakitan.  Dengan demikian, Anda tidak perlu menambahkan pemuat apa pun untuk http, tetapi di sisi lain, dengan pendekatan ini, Anda harus membangun kembali aplikasi setiap kali kami mengubah file kami dengan pelokalan, dan juga, ini dapat sangat meningkatkan ukuran bundel .js. </p><br><pre> <code class="hljs pgsql">// webpack-translate-loader.ts <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { TranslateLoader } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@ngx-translate/core'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Observable } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs/Observable'</span></span>; export <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> WebpackTranslateLoader implements TranslateLoader { getTranslation(lang: string): Observable&lt;<span class="hljs-keyword"><span class="hljs-keyword">any</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Observable.fromPromise(<span class="hljs-keyword"><span class="hljs-keyword">System</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(`../assets/i18n/${lang}.json`)); } }</code> </pre> <br><p>  Jika IDE bersumpah di <code>System</code> Anda perlu menambahkannya ke typings.d.ts: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">declare</span></span> var <span class="hljs-keyword"><span class="hljs-keyword">System</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">System</span></span>; interface <span class="hljs-keyword"><span class="hljs-keyword">System</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(request: string): Promise&lt;<span class="hljs-keyword"><span class="hljs-keyword">any</span></span>&gt;; }</code> </pre> <br><p>  Sekarang kita dapat menggunakan <code>WebpackTranslateLoader</code> di app.module: </p><br><pre> <code class="hljs powershell">@NgModule({ bootstrap: [<span class="hljs-type"><span class="hljs-type">AppComponent</span></span>], imports: [ <span class="hljs-type"><span class="hljs-type">TranslateModule.forRoot</span></span>({ <span class="hljs-type"><span class="hljs-type">loader</span></span>: { <span class="hljs-type"><span class="hljs-type">provide</span></span>: <span class="hljs-type"><span class="hljs-type">TranslateLoader</span></span>, <span class="hljs-type"><span class="hljs-type">useClass</span></span>: <span class="hljs-type"><span class="hljs-type">WebpackTranslateLoader</span></span> } }) ] }) export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppModule</span></span></span></span> { }</code> </pre> <cut></cut><br><h4 id="apptranslateloader">  AppTranslateLoader </h4><br><p>  Jadi, mari mulai menulis <code>AppTranslateLoader</code> kami.  Untuk mulai dengan, saya ingin mengidentifikasi beberapa masalah yang harus dihadapi menggunakan standar <code>TranslateHttpLoader</code> : </p><br><ul><li><p>  <strong>Terjemahkan berkedip.</strong>  <code>TranslateHttpLoader</code> tidak tahu bagaimana mengeksekusi sebagai bagian dari proses inisialisasi aplikasi dan kita dapat masuk ke dalam situasi ketika setelah inisialisasi kita melihat bahwa kita memiliki tempat untuk label yang benar dalam aplikasi - kunci (MY_BUTTON_KEY adalah tempat tombol Saya), yang setelah beberapa saat berubah ke teks yang benar. </p><br></li><li><p>  <strong>Tanggal</strong>  Akan menyenangkan untuk memiliki layanan yang mengubah lokalisasi tanggal.  Ketika datang ke pelokalan teks, kemungkinan besar Anda harus mengurus tanggal, waktu, dll.  Anda dapat menggunakan momentJs atau solusi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">i18n yang</a> terintegrasi ke Angular.  Kedua solusi baik, dan memiliki pipa Angular 2+ untuk memformat dalam pandangan. </p><br></li><li>  <strong>Caching.</strong>  menggunakan <code>TranslateHttpLoader</code> , Anda harus mengonfigurasi server FE Anda untuk melakukan cache json bundel dengan benar.  Jika tidak, pengguna akan melihat versi lokalisasi lama, lebih buruk lagi mereka akan melihat kunci lokalisasi (jika yang baru ditambahkan setelah caching oleh pengguna).  Saya tidak ingin repot setiap kali saya menggunakan server baru dengan saat menyiapkan caching.  Jadi kita akan membuat Webpack melakukan segalanya untuk kita seperti yang dilakukannya untuk bundel .js. </li></ul><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Draf AppTranslateLoader</a> </p><cut></cut><br><h5 id="resheniya-problem">  Solusi untuk masalah: </h5><br><h6 id="1-problema-translate-flickering---ispolzovat-apptranslateloaderv-ramkah-app_initializer">  1. terjemahkan masalah berkedip - gunakan <code>AppTranslateLoader</code> sebagai bagian dari <code>APP_INITIALIZER</code> </h6><br><p>  APP_INITIALIZER juga aktif terlibat dalam sebuah artikel tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penyegaran token</a> , jika tidak berselera tentang penginisialisasi - saya menyarankan Anda untuk membaca artikel terlepas dari kenyataan bahwa ini adalah tentang penyegaran token.  Sebenarnya, keputusan untuk menggunakan penginisialisasi sangat jelas (bagi mereka yang memiliki penginisialisasi), tetapi saya masih berharap ada orang yang berguna: </p><br><pre> <code class="hljs powershell">//app.module.ts export <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">translationLoader</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(loader: AppTranslateLoader)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> () =&gt; loader.loadTranslation(); } @NgModule({ bootstrap: [<span class="hljs-type"><span class="hljs-type">AppComponent</span></span>], providers: [ { <span class="hljs-type"><span class="hljs-type">provide</span></span>: <span class="hljs-type"><span class="hljs-type">APP_INITIALIZER</span></span>, <span class="hljs-type"><span class="hljs-type">useFactory</span></span>: <span class="hljs-type"><span class="hljs-type">translationLoader</span></span>, <span class="hljs-type"><span class="hljs-type">deps</span></span>: [<span class="hljs-type"><span class="hljs-type">AppTranslateLoader</span></span>], <span class="hljs-type"><span class="hljs-type">multi</span></span>: <span class="hljs-type"><span class="hljs-type">true</span></span> } ] }) export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppModule</span></span></span></span> { }</code> </pre> <br><h6 id="2-problema-dat-prosto-budem-pereklyuchat-yazyk-v-momentjs-vmeste-c-ngx-tranlate">  2. Masalah tanggal.  Kami hanya akan mengganti bahasa di momentJs bersama dengan ngx-tranlate. </h6><br><p>  Semuanya sederhana di sini - setelah json dengan pelokalan dimuat, kami hanya mengalihkan pelokalan ke momentJs (atau i18n). </p><br><p>  Perlu juga dicatat bahwa momentJs, seperti i18n, dapat mengimpor pelokalan secara terpisah, momentJs juga dapat mengimpor bundel, tetapi keseluruhan bundel pelokalan itu membutuhkan ~ 260KB, dan Anda hanya perlu 2 diantaranya. </p><br><p>  Dalam hal ini, Anda hanya dapat mengimpor 2 di antaranya secara langsung di file tempat <code>AppTranslateLoader</code> dideklarasikan. </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'moment/locale/en-gb'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'moment/locale/ru'</span></span>;</code> </pre> <br><p>  Sekarang lokalisasi en-gb dan ru akan ada dalam bundel aplikasi js.  Di <code>AppTranslateLoader</code> Anda dapat menambahkan penangan bahasa yang baru saja dimuat: </p><br><pre> <code class="hljs coffeescript"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> Class AppTranslateLoader { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> .... private onLangLoaded(newLang: string) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadedLang &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadedLang !== newLang) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.translate.resetLang(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadedLang); } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadedLang = newLang; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.selectedLang = newLang; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> TODO:       <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     ,       <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  en  ru,  momentJs   en. moment().locale(newLang); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  .  momentJs localStorage.setItem(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.storageKey, newLang); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   ls <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadSubj.complete(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   -      . }</code> </pre> <br><p>  !!!  pawang ini memiliki kekurangan: Jika dalam proyek kami hanya en lokalisasi disediakan untuk ngx-translate, tetapi sebagai contoh saat atau perlu menggunakan en atau en-gb, logika pawang harus diperluas, atau en-lokalisasi en-gb juga harus disediakan dalam ngx-terjemahkan. </p><br><p>  !!!  untuk saat ini dengan // TODO: kita dapat menulis plugin webpack, kita akan mempertimbangkan beberapa plugin nanti, tetapi saya belum memilikinya. </p><br><p>  Anda bertanya, mengapa tidak mungkin memuat lokalisasi tanggal dan waktu serta pelokalan teks dalam antarmuka (secara dinamis, melalui HTTP)?  Ini karena pelokalan tanggal mengandung logika mereka sendiri, dan oleh karena itu disajikan sebagai kode <a href="">javascript</a> . </p><br><p>  Namun terlepas dari ini, ada cara untuk memuat pelokalan seperti itu dengan menulis sedikit kode 'kotor'.  Saya tidak menggunakan kode ini dalam produksi, tetapi pelokalan ke-2 di dalam bundel saya tidak mengganggu saya.  Tetapi jika Anda memiliki banyak pelokalan, Anda ingin memuatnya secara dinamis dan tidak terlalu aman, perlu diingat: </p><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loadAngularCulture</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">locale</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> angularLocaleText = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.httpClient.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(`assets/angular-locales/${locale}.js`).toPromise(); <span class="hljs-comment"><span class="hljs-comment">// extracting the part of the js code before the data, // and i didn't need the plural so i just replace plural by null. const startPos = angularLocaleText.indexOf('export default '); angularLocaleText = 'return ' + angularLocaleText.substring(startPos + 15).replace('plural', null); // The trick is here : to read cldr data, i use a function const f = new Function(angularLocaleText); const angularLocale = f(); // console.log(angularLocale); // And now, just registrer the object you just created with the function registerLocaleData(angularLocale); }</span></span></code> </pre> <br><p>  Terakhir kali saya menguji metode ini dalam Angular 4. Kemungkinan besar itu berfungsi sekarang. </p><br><p>  Sayangnya, hack kehidupan kotor seperti itu tidak akan berfungsi dalam kasus c momentJs (hanya lokalisasi Angular).  Setidaknya saya tidak bisa menemukan cara untuk melakukan ini, tetapi jika Anda seorang programmer hacker yang sangat berjanggut, saya akan senang melihat solusi dalam komentar. </p><br><h6 id="3-keshirovanie-podobno-sborke-js-bandla-mozhno-dobavit-k-imeni-json-bandla-hesh">  3. Caching.  Mirip dengan membangun bundel .js, Anda bisa menambahkan hash ke nama bundel .json. </h6><br><p>  Itu semua tergantung pada bagaimana tepatnya Anda mengumpulkan semua json ke dalam satu file, mungkin Anda hanya memiliki semuanya dalam satu file.  Di Internet, Anda dapat menemukan sejumlah modul npm yang dapat mengumpulkan json kecil dalam satu file.  Saya tidak menemukan orang-orang yang dapat melampirkan hash dan mengumpulkan semuanya menjadi satu file.  Webpack sendiri juga tidak dapat menangani json seperti yang diminta oleh ngx-translate.  Karena itu, kami akan menulis plugin webpack kami. </p><br><p>  Singkatnya: kita perlu mengumpulkan semua json di proyek sesuai dengan pola tertentu, sementara kita perlu mengelompokkannya berdasarkan nama (en, ru, de, dll.) Karena, misalnya, en.json dapat berada di folder yang berbeda.  Kemudian, untuk setiap file yang dikumpulkan, Anda harus melampirkan hash. </p><br><p>  Ada masalah di sini.  Bagaimana <code>AppTranslateLoader</code> mengenali nama file jika setiap pelokalan memiliki namanya sendiri?  Misalnya, termasuk bundel di index.html, kami dapat menyertakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">HtmlWebpackPlugin</a> dan memintanya untuk menambahkan tag skrip dengan nama bundel sendiri. </p><br><p>  Untuk mengatasi masalah ini untuk pelokalan .json, plugin webpack kami akan membuat config.json, yang akan berisi asosiasi kode bahasa dengan nama file hash: </p><br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"en"</span></span>: <span class="hljs-string"><span class="hljs-string">"en.some_hash.json"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"ru"</span></span>: <span class="hljs-string"><span class="hljs-string">"ru.some_hash.json"</span></span> }</code> </pre> <br><p>  config.json juga akan di-cache oleh browser, tetapi itu akan memakan waktu sedikit dan kita dapat dengan mudah menentukan parameter queryString acak ketika GET ditumbuhi dengan file ini (sehingga terus memuatnya lagi).  Atau berikan ID acak ke config.json (saya akan menjelaskan metode ini, yang pertama dapat ditemukan di Google). </p><br><p>  Saya juga ingin sedikit menyederhanakan infrastruktur dan atomisasi lokalisasi.  json dengan pelokalan akan terletak di folder dengan komponennya.  Dan untuk menghindari kunci duplikat, struktur bundel json akan dibangun berdasarkan path ke file json tertentu.  Sebagai contoh, kita memiliki dua en.json, satu terletak pada path <code>src/app/article-component</code> , dan lainnya <code>src/app/comment-component</code> .  Saya ingin mendapatkan json berikut dalam output: </p><br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"article-component"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"TITLE"</span></span>: <span class="hljs-string"><span class="hljs-string">"Article title"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"comment-component"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"TITLE"</span></span>: <span class="hljs-string"><span class="hljs-string">"Comment title"</span></span> } }</code> </pre> <br><p>  Kita dapat membuang bagian dari jalan yang tidak kita butuhkan, sehingga kunci akan sesingkat mungkin dalam tampilan. </p><br><p>  !!!  Ada kekurangannya: ketika Anda menempatkan komponen di folder lain, kunci lokalisasi akan berubah. </p><br><p>  Nanti kita akan mempertimbangkan hack kehidupan lain yang akan memungkinkan kita untuk menunjukkan dalam komponen hanya bidang kunci terakhir, tidak peduli di mana dan seberapa dalam proyek kita dalam proyek, dan dengan demikian kita dapat mentransfernya sesuka kita dan ganti namanya sesuka kita. </p><br><p>  Pada dasarnya, saya ingin mencapai enkapsulasi dan bahkan sedikit polimorfisme lokalisasi ngx-translate.  Saya suka konsep enkapsulasi pandangan dalam Angular - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Angular View Encapsulation</a> , atau lebih tepatnya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Shadow DOM</a> .  Ya, ini meningkatkan ukuran aplikasi secara keseluruhan, tetapi saya akan mengatakan sebelumnya bahwa setelah ngx-translate menjadi lebih dienkapsulasi, bekerja dengan file lokalisasi menjadi jauh lebih menyenangkan.  Komponen mulai peduli hanya tentang pelokalan mereka, di samping itu, akan mungkin untuk mendefinisikan kembali pelokalan dalam komponen anak tergantung pada pelokalan dalam komponen induk.  Juga, sekarang Anda dapat mentransfer komponen dari proyek ke proyek, dan mereka sudah akan dilokalkan.  Tetapi seperti di tempat lain, ada nuansa, lebih lanjut tentang itu nanti. </p><br><p>  Jadi mari kita beralih ke plugin kita.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Apa itu dan bagaimana</a> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">gabungkan plugin pelokalan</a> . <br>  Kode sumber untuk loader dan plugin dapat ditemukan di tautan contoh di bagian bawah artikel (folder ./build-utils). </p><br><p>  Plugin melakukan segalanya tentang apa yang ditulis di atas, dan menerima opsi berikut: </p><br><ul><li>  hilangkan.  nama di jalur menuju pelokalan yang perlu diabaikan (inilah saat saya ingin menghapus bagian tambahan dari jalur ke file) </li><li>  fileInput.  biasa untuk mengambil file lokalisasi di prodge (seperti tes di webpack) </li><li>  rootDir.  di mana mulai mencari file dengan pola fileInput </li><li>  outputDir.  di mana file config dan pelokalan akan dibuat di folder dist </li><li>  configName.  dengan nama apa file konfigurasi akan dibuat. </li></ul><br><p>  Dalam proyek saya, plugin terhubung dengan cara ini: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// build-utils.js // part of METADATA { // ... translationsOutputDir: 'langs/', translationsFolder: '@translations', translationsConfig: `config.${Math.random().toString(36).substr(2, 9)}.json`, } //webpack.common.js new MergeLocalizationPlugin({ fileInput: [`**/${METADATA.translationsFolder}/*.json`, 'app-translations/**/*.json'], rootDir: 'src', omit: new RegExp(`app-translations|${METADATA.translationsFolder}|^app`, 'g'), outputDir: METADATA.translationsOutputDir, configName: METADATA.translationsConfig }),</span></span></code> </pre> <br><p>  Di dalam komponen yang perlu pelokalan ada folder <code>@translations</code> , yang berisi en.json, ru, dll. </p><br><p>  Akibatnya, ketika membalik, semuanya akan dikumpulkan menjadi satu file, dengan mempertimbangkan jalur ke folder <code>@translations</code> .  Bundel lokalisasi akan berada di dist / langs /, dan konfigurasi akan dinamai sebagai config. $ {Some-random} .json. </p><br><p>  Selanjutnya, kami akan memastikan bahwa bundel lokalisasi yang diinginkan dimuat ke dalam aplikasi.  Ada saat yang rapuh - hanya webpack yang tahu tentang lintasan ke lokasi dan nama file konfigurasi, mari kita pertimbangkan ini sehingga data terbaru masuk ke AppTranslateLoader dan tidak perlu mengubah nama di dua tempat. </p><br><pre> <code class="hljs powershell">// some inmports // ... // momentJs import * as moment from <span class="hljs-string"><span class="hljs-string">'moment'</span></span>; import <span class="hljs-string"><span class="hljs-string">'moment/locale/en-gb'</span></span>; import <span class="hljs-string"><span class="hljs-string">'moment/locale/ru'</span></span>; @Injectable() export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppTranslateLoader</span></span></span></span> { //            public additionalStorageKey: string = <span class="hljs-string"><span class="hljs-string">''</span></span>; private translationsDir: string; private translationsConfig: string; private selectedLang: string; private fallbackLang: string; private loadedLang: string; private config: { [<span class="hljs-type"><span class="hljs-type">key</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>]: string; } = null; private loadSubs = new Subscription(); private configSubs = new Subscription(); private loadSubj = new Subject(); private get storageKey(): string { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> this.additionalStorageKey ? `APP_LANG_<span class="hljs-variable"><span class="hljs-variable">$</span></span>{this.additionalStorageKey}` : <span class="hljs-string"><span class="hljs-string">'APP_LANG'</span></span>; } constructor(private http: HttpClient, private translate: TranslateService) { //   webpack       //     . this.translationsDir = `${process.env.TRANSLATE_OUTPUT}`; this.translationsConfig = `${process.env.TRANSLATE_CONFIG}`; this.fallbackLang = <span class="hljs-string"><span class="hljs-string">'en'</span></span>; const storedLang = this.getUsedLanguage(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (storedLang) { this.selectedLang = storedLang; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { this.selectedLang = translate.getBrowserLang() || this.fallbackLang; } } }</code> </pre> <br><p>  <code>process.env.TRANSLATE_OUTPUT</code> tidak akan berfungsi, kita perlu mendeklarasikan plugin lain di webpack (DefinePlugin atau EnvironmentPlugin): </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// METADATA declaration const METADATA = { translationsOutputDir: 'langs/', translationsFolder: '@translations', translationsConfig: `config. ${Math.random().toString(36).substr(2, 9)}.json`, }; // complex webpack config... // webpack plugins... new DefinePlugin({ 'process.env.TRANSLATE_OUTPUT': JSON.stringify(METADATA.translationsOutputDir), 'process.env.TRANSLATE_CONFIG': JSON.stringify(METADATA.translationsConfig), }),</span></span></code> </pre> <br><p>  Sekarang kita dapat mengubah jalur ke pelokalan dan nama konfigurasi hanya di satu tempat. <br>  Secara default, dari penjualan Angular default yang dihasilkan dalam rakitan webpack (misalnya), Anda tidak dapat menentukan <code>process.env.someValue</code> dari kode (bahkan jika Anda menggunakan DefinePlugin), kompiler dapat bersumpah.  Agar ini berfungsi, Anda harus memenuhi 2a kondisi: </p><br><ul><li>  di main.ts tambahkan baris pertama <code>/// &lt;reference types="node"/&gt;</code> </li><li>  package.json harus memiliki <code>@types/node</code> - <code>npm install --save-dev @types/node</code> . </li></ul><br><p>  Kami melanjutkan langsung ke proses boot. <br>  Jika Anda berniat menggunakan APP_INITIALIZER, pastikan untuk mengembalikan Janji, tidak Dapat Diamati.  Tugas kami adalah menulis rantai permintaan: </p><br><ul><li>  Pertama, Anda perlu mengunduh config.json (hanya jika tidak dimuat). </li><li>  coba muat bahasa, yang merupakan bahasa browser pengguna </li><li>  Berikan logika fallback dengan bahasa unduhan default. </li></ul><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> imports @Injectable() AppTranslateLoader { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> fields ... <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    ,         <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      ,   <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Subscription    unsubscribe    <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   private loadSubs = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Subscription(); private configSubs = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Subscription(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>       -   <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Subject       private loadSubj = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Subject(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> constructor ... <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  Promise! public loadTranslation(lang: string = <span class="hljs-string"><span class="hljs-string">''</span></span>): Promise&lt;any&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!lang) { lang = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.selectedLang; } <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (lang === <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadedLang) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.config) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.configSubs.unsubscribe(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.configSubs = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.http.get&lt;Response&gt;(`<span class="javascript"><span class="javascript">${</span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">this</span></span></span><span class="javascript">.translationsDir}${</span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">this</span></span></span><span class="javascript">.translationsConfig}</span></span>`) .subscribe(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(config: any)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.config = config; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadAndUseLang(lang); }); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadAndUseLang(lang); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadSubj.asObservable().toPromise(); } private loadAndUseLang(lang: string) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadSubs.unsubscribe(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadSubs = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.http.get&lt;Response&gt;(`<span class="javascript"><span class="javascript">${</span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">this</span></span></span><span class="javascript">.translationsDir}${</span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">this</span></span></span><span class="javascript">.config[lang] || </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">this</span></span></span><span class="javascript">.config[</span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">this</span></span></span><span class="javascript">.fallbackLang]}</span></span>`) .subscribe(res =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.translate.setTranslation(lang, res); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.translate.use(lang).subscribe(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.onLangLoaded(lang); }, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> fallback  ngx-translate   (err) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.onLoadLangError(lang, err)); }, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> fallback  http   (err) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.onLoadLangError(lang, err)); } private onLangLoaded(newLang: string) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadedLang &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadedLang !== newLang) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.translate.resetLang(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadedLang); } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadedLang = newLang; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.selectedLang = newLang; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> TODO:       <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     ,       <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  en  ru,  momentJs   en. moment().locale(newLang); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  .  momentJs localStorage.setItem(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.storageKey, newLang); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   ls <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadSubj.complete(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   -      . } private onLoadLangError(langKey: string, error: any) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   ,      <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadedLang) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.translate.use(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadedLang) .subscribe( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.onLangLoaded(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadedLang), <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadSubj.error(err)); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (langKey !== <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.fallbackLang) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      fallback  <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadAndUseLang(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.fallbackLang); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loadSubj.error(error); } }</code> </pre> <br><p>  Selesai </p><br><p>  Sekarang kembali ke masalah memindahkan komponen ke folder lain, enkapsulasi dan kemiripan polimorfisme. </p><br><p>  Faktanya, kita sudah memiliki semacam enkapsulasi.  Pelokalan didorong ke folder di sebelah komponen, semua jalur kunci unik, tetapi kita masih bisa melokalkan kunci komponen beberapa komponen1 di dalam beberapa komponen2 dan akan sulit untuk melacak semuanya, kita akan mengetahuinya nanti. </p><br><pre> <code class="hljs powershell">&lt;some<span class="hljs-literal"><span class="hljs-literal">-component1</span></span> [<span class="hljs-type"><span class="hljs-type">someLabel</span></span>]=<span class="hljs-string"><span class="hljs-string">"'components.some-component2.some_key' | tanslate"</span></span>&gt;&lt;/some<span class="hljs-literal"><span class="hljs-literal">-component1</span></span>&gt; // components.some<span class="hljs-literal"><span class="hljs-literal">-component2</span></span> -    </code> </pre> <br><p>  Mengenai pergerakan komponen: <br>  Sekarang kunci yang akan kita gunakan dalam tampilan terikat dengan kaku pada jalur relatif ke file pelokalan dan tergantung pada infrastruktur spesifik proyek. </p><br><p>  Saya akan memberikan kasus yang agak menyedihkan dari situasi ini: </p><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">translate</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"+lazy-module.components.article-component.article_title"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Tetapi bagaimana jika saya mengubah nama folder komponen ke post-komponen? <br>  Akan sangat sulit untuk memasukkan kunci ini di semua tempat yang diperlukan.  Tentu saja, tidak ada yang membatalkan copy-paste dan mencari-ganti, tetapi menulis ini tanpa diminta IDE juga membuat stres. </p><br><p>  Untuk mengatasi masalah ini, mari kita perhatikan apa yang dilakukan webpack tentang hal ini?  Webpack memiliki sesuatu yang disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">loader</a> , ada banyak loader yang tersedia yang beroperasi pada jalur file: misalnya, jalur sumber daya dalam css - berkat webpack kita dapat menentukan jalur gambar latar relatif: url (../ relative.png), dan sebagainya sisa jalur file dalam proyek ada di mana-mana! </p><br><p>  Siapa pun yang membuat build webpack mereka tahu bahwa loader menerima file pada input yang cocok dengan pola tertentu.  Tugas dari loader itu sendiri adalah bagaimana mengubah file input ini dan mengembalikannya, untuk perubahan lebih lanjut oleh loader lainnya. </p><br><p>  Karena itu, kita perlu menulis loader kita.  Pertanyaannya adalah jenis file apa yang akan kita ubah: tampilan atau komponen?  Di satu sisi, tampilan dapat langsung di komponen dan secara terpisah.  Tampilan bisa cukup besar dan sulit untuk diurai, bayangkan jika kita memiliki pandangan di mana 100 menerjemahkan arahan (bukan dalam satu lingkaran): </p><br><pre> <code class="hljs axapta">&lt;<span class="hljs-keyword"><span class="hljs-keyword">div</span></span> id=<span class="hljs-string"><span class="hljs-string">"1"</span></span>&gt;{{<span class="hljs-string"><span class="hljs-string">'./some_key_1'</span></span> | translate}}&lt;/<span class="hljs-keyword"><span class="hljs-keyword">div</span></span>&gt; ... &lt;<span class="hljs-keyword"><span class="hljs-keyword">div</span></span> id=<span class="hljs-string"><span class="hljs-string">"100"</span></span>&gt;{{<span class="hljs-string"><span class="hljs-string">'../another_key_!'</span></span> | translate}}&lt;/<span class="hljs-keyword"><span class="hljs-keyword">div</span></span>&gt;</code> </pre><br><p>  melalui loader, kami dapat mengganti jalur utama ke lokasi komponen di dekat setiap pipa atau arahan. </p><br><pre> <code class="hljs axapta">&lt;<span class="hljs-keyword"><span class="hljs-keyword">div</span></span> id=<span class="hljs-string"><span class="hljs-string">"1"</span></span>&gt;{{<span class="hljs-string"><span class="hljs-string">'app.some-component.some_key_1'</span></span> | translate}}&lt;/<span class="hljs-keyword"><span class="hljs-keyword">div</span></span>&gt; <span class="hljs-comment"><span class="hljs-comment">// app.some-component. -   loader'</span></span></code> </pre> <br><p>  kita bisa menambahkan bidang ke komponen yang menyediakan lokalisasi: </p><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@Component({ selector: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'app-some'</span></span></span><span class="hljs-meta">, template: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'&lt;div&gt;{{(localization + '</span></span></span><span class="hljs-meta">key</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">') | tanslate}}&lt;/div&gt;'</span></span></span><span class="hljs-meta"> })</span></span> export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeComponent</span></span></span><span class="hljs-class"> </span></span>{ localization = <span class="hljs-string"><span class="hljs-string">'./'</span></span> }</code> </pre> <br><p>  Itu juga buruk - Anda harus membuat kunci pelokalan di mana-mana. </p><br><p>  Karena opsi yang paling jelas terlihat buruk, coba gunakan dekorator dan simpan beberapa metadata dalam prototipe komponen (seperti yang dilakukan Angular). </p><br><p><img src="https://habrastorage.org/webt/gu/_4/vp/gu_4vpfjn_3ujxoh3tragj7wi2s.png" alt="gambar"></p><br><p>  <strong>anotasi</strong> - metadata untuk dekorator Angular <br>  __app_annotations__ - metadata yang akan kami simpan untuk kami sendiri </p><br><p>  Jalur ke folder lokalisasi relatif ke komponen dapat ditulis ke dekorator, dekorator yang sama dapat diperluas dengan opsi lain kecuali jalur. </p><br><pre> <code class="hljs powershell">//translate.service.ts const app_annotations_key = <span class="hljs-string"><span class="hljs-string">'__app_annotations__'</span></span>; export <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Localization</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(path: string)</span></span></span></span> { // tslint:<span class="hljs-built_in"><span class="hljs-built_in">disable-next</span></span><span class="hljs-literal"><span class="hljs-literal">-line</span></span>:only<span class="hljs-literal"><span class="hljs-literal">-arrow</span></span><span class="hljs-literal"><span class="hljs-literal">-functions</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(target: Function)</span></span></span></span> { const metaKey = app_annotations_key; Object.defineProperty(target, metaKey, { value: { //         path. path, name: <span class="hljs-string"><span class="hljs-string">'Translate'</span></span> } } as PropertyDescriptor); }; } //some.component.ts @Component({...}) @Localization({ path: <span class="hljs-string"><span class="hljs-string">'./'</span></span>, otherOptions: {...} }); export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeComponent</span></span></span></span> { }</code> </pre> <br><p>      webpack,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">loader</a>           ,      -    .          ,     (      styleUrls)      . loader,     npm .    . </p><br><p>        ,   -.       ,          -. </p><br><pre> <code class="hljs axapta">&lt;<span class="hljs-keyword"><span class="hljs-keyword">div</span></span>&gt;{{<span class="hljs-string"><span class="hljs-string">'just_key'</span></span> | translate}}&lt;/<span class="hljs-keyword"><span class="hljs-keyword">div</span></span>&gt;</code> </pre> <br><p>          .    ,      ,      ,           .    — Injector, .   ,       Injector,     ''  ,  translate       .      Injector,       (    ),         'get'. </p><br><p><img src="https://habrastorage.org/webt/jl/vw/0x/jlvw0xsep9o3valmkhc3uxblvdm.png" alt="gambar"></p><br><p>  ,  parent  ,     ,    Injector'a  ,      ,     ,   ,   ,        . </p><br><p>  ,     API,   forwarRef() (    Angular reactive forms,      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">control</a> ).  ,      .         . </p><br><pre> <code class="hljs powershell">// translate.service.ts export const TRANSLATE_TOKEN = new InjectionToken(<span class="hljs-string"><span class="hljs-string">'MyTranslateToken'</span></span>); // app.component.ts @Component({ selector: <span class="hljs-string"><span class="hljs-string">'app-root'</span></span>, templateUrl: <span class="hljs-string"><span class="hljs-string">'./app.component.html'</span></span>, styleUrls: [<span class="hljs-string"><span class="hljs-string">'./app.component.css'</span></span>], providers: [{<span class="hljs-type"><span class="hljs-type">provide</span></span>: <span class="hljs-type"><span class="hljs-type">TRANSLATE_TOKEN</span></span>, <span class="hljs-type"><span class="hljs-type">useExisting</span></span>: <span class="hljs-type"><span class="hljs-type">forwardRef</span></span>(() =&gt; <span class="hljs-type"><span class="hljs-type">AppComponent</span></span>)}] }) @Localization(<span class="hljs-string"><span class="hljs-string">'./'</span></span>) export <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppComponent</span></span></span></span> { title = <span class="hljs-string"><span class="hljs-string">'app'</span></span>; }</code> </pre> <br><p>        , ,         ,   forwardRef(). </p><br><p>  ,     Injector     forwardRef()        ,             .       ,        '' .     ,   ,   . </p><br><pre> <code class="hljs pgsql">// my-translate.directive.ts @Directive({ // tslint:<span class="hljs-keyword"><span class="hljs-keyword">disable</span></span>-next-<span class="hljs-type"><span class="hljs-type">line</span></span>:directive-selector selector: <span class="hljs-string"><span class="hljs-string">'[myTranslate]'</span></span> }) export <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> MyTranslateDirective extends TranslateDirective { @<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span>() <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> myTranslate(e: string) { this.translate = e; } private keyPath: string; constructor(private _translateService: TranslateService, private _element: ElementRef, _chRef: ChangeDetectorRef, //    forwardRef() @Inject(TRANSLATE_TOKEN) @Optional() protected cmp: <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>) { super(_translateService, _element, _chRef); //    const prototype = <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.getPrototypeOf(cmp || {}).constructor; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (prototype[app_annotations_key]) { //      this.keyPath = prototype[app_annotations_key].path; } } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> updateValue(key: string, node: <span class="hljs-keyword"><span class="hljs-keyword">any</span></span>, translations: <span class="hljs-keyword"><span class="hljs-keyword">any</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (this.keyPath) { //     ,   //   key = `${this.keyPath.replace(/\//, <span class="hljs-string"><span class="hljs-string">'.'</span></span>)}.${key}`; } super.updateValue(key, node, translations); } }</code> </pre> <br><p>      . </p><br><p>  -      : </p><br><pre> <code class="hljs django"><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{'just_this_component_key' | myTranslate}}</span></span><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> //  </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">myTranslate</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"just_this_component_key"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre> <br><p>    translate , .      ,       ,          -    : </p><br><pre> <code class="hljs pgsql">//en.bundle.json { "global_key": "Global key" "app-component": { "just_key": "Just key" } } //<span class="hljs-keyword"><span class="hljs-keyword">some</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">view</span></span>.html &lt;div translate="global_key"&gt;&lt;/div&gt;</code> </pre> <br><p> Research and improve! </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">full example</a> </p><br><p>       : </p><br><ol><li>     FE     node.js   stacktrace.js. </li><li>  Jest  Angular . </li><li> Web worker )      , ,  Angular  . </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id413787/">https://habr.com/ru/post/id413787/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id413775/index.html">Serangan permusuhan di Machines Can See 2018</a></li>
<li><a href="../id413777/index.html">Bacaan Akhir Pekan: Materi Pengantar IaaS, Keamanan Informasi dan Acara Regulasi TI</a></li>
<li><a href="../id413779/index.html">Pengatur waktu dan multitasking di Arduino</a></li>
<li><a href="../id413781/index.html">Bagaimana Mengiklankan Bloodhound Ikuti Jejak Anda di Internet</a></li>
<li><a href="../id413783/index.html">Bagaimana bintang paling masif mati: supernova, hipernova, atau kolaps langsung?</a></li>
<li><a href="../id413789/index.html">Di Florida, mereka tidak memeriksa pembeli senjata di markas FBI selama setahun karena mereka lupa kata sandi</a></li>
<li><a href="../id413791/index.html">Mekanika Kuantum Perhitungan dalam JS</a></li>
<li><a href="../id413793/index.html">Kaset audio dalam budaya pop: mengapa format rekaman suara yang usang dianggap modis</a></li>
<li><a href="../id413795/index.html">Mengapa industri hiburan pindah ke IaaS: studi kasus</a></li>
<li><a href="../id413797/index.html">EA memperkenalkan bagian baru C&C di E3. Dan secara fisik menyakitkan untuk melihatnya</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>