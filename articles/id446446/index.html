<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😡 🧘🏻 👨🏼‍🎤 Dasar-dasar mesin JavaScript: bentuk umum dan cache inline. Bagian 1 ✊🏾 🐻 🐕</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo teman-teman. Pada akhir April, kami meluncurkan kursus baru "Keamanan Sistem Informasi" . Dan sekarang kami ingin membagikan terjemahan artikel k...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Dasar-dasar mesin JavaScript: bentuk umum dan cache inline. Bagian 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/446446/">  Halo teman-teman.  Pada akhir April, kami meluncurkan kursus baru <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Keamanan Sistem Informasi"</a> .  Dan sekarang kami ingin membagikan terjemahan artikel kepada Anda, yang tentunya akan sangat berguna untuk kursus ini.  Artikel asli dapat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ditemukan di sini</a> . <br><br>  Artikel ini menjelaskan fondasi kunci, mereka umum untuk semua mesin JavaScript, dan bukan hanya untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V8</a> , yang sedang dikerjakan oleh penulis mesin ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Benedict</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Matias</a> ).  Sebagai pengembang JavaScript, saya dapat mengatakan bahwa pemahaman yang lebih dalam tentang cara kerja mesin JavaScript akan membantu Anda mengetahui cara menulis kode yang efisien. <br><br><img src="https://habrastorage.org/webt/14/ef/xe/14efxewawb3ttgslcsxyzicgjy0.png"><br><a name="habracut"></a><br><blockquote>  <b>Catatan</b> : jika Anda lebih suka menonton presentasi daripada membaca artikel, maka tonton <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">video</a> ini.  Jika tidak, lewatkan saja dan baca terus. </blockquote>  <b>Mesin pipeline (pipa) JavaScript</b> <br><br>  Semuanya dimulai dengan fakta bahwa Anda menulis kode JavaScript.  Setelah itu, mesin JavaScript memproses kode sumber dan menyajikannya sebagai pohon sintaksis abstrak (AST).  Berdasarkan AST yang dibangun, juru bahasa akhirnya bisa mulai bekerja dan mulai membuat bytecode.  Hebat!  Ini adalah saat mesin mengeksekusi kode JavaScript. <br><br><img src="https://habrastorage.org/webt/i6/8r/f2/i68rf23urqlxa20gzhubwz2-snq.jpeg"><br><br>  Untuk membuatnya berjalan lebih cepat, Anda dapat mengirim bytecode ke kompiler yang mengoptimalkan bersama dengan profiling data.  Kompilator pengoptimalisasi membuat asumsi tertentu berdasarkan pada profil data, kemudian menghasilkan kode mesin yang sangat optimal. <br><br>  Jika pada beberapa titik asumsi ternyata salah, kompiler pengoptimalisasi akan menonaktifkan kode dan kembali ke tahap penerjemah. <br><br>  <b>Jalur pipa / kompiler juru bahasa dalam mesin JavaScript</b> <br><br>  Sekarang mari kita melihat lebih dekat bagian-bagian dari pipa yang mengeksekusi kode JavaScript Anda, yaitu di mana kode ditafsirkan dan dioptimalkan, dan juga melihat beberapa perbedaan antara mesin JavaScript utama. <br><br>  Inti dari semuanya adalah pipeline yang berisi interpreter dan kompiler yang mengoptimalkan.  Interpreter dengan cepat menghasilkan bytecode yang tidak dioptimalkan, kompiler pengoptimal, pada gilirannya, bekerja lebih lama, tetapi hasilnya memiliki kode mesin yang sangat optimal. <br><br><img src="https://habrastorage.org/webt/gh/ap/o6/ghapo68sxzyqniyjqw0v0xewpry.jpeg"><br><br>  Selanjutnya adalah saluran pipa yang menunjukkan cara kerja V8, mesin JavaScript yang digunakan oleh Chrome dan Node.js. <br><br><img src="https://habrastorage.org/webt/8i/nu/0w/8inu0wkuzc8_enexkp8o7pn7jgi.jpeg"><br><br>  Penerjemah dalam V8 disebut Ignition, yang bertanggung jawab untuk menghasilkan dan mengeksekusi bytecode.  Itu mengumpulkan data profil yang dapat digunakan untuk mempercepat eksekusi pada langkah selanjutnya ketika bytecode sedang diproses.  Ketika suatu fungsi menjadi <i>panas</i> , misalnya, jika itu mulai sering, bytecode dan data profil yang dihasilkan ditransfer ke TurboFan, yaitu, ke kompiler yang mengoptimalkan untuk menghasilkan kode mesin yang sangat dioptimalkan berdasarkan pada data profil. <br><br><img src="https://habrastorage.org/webt/ww/n5/zi/wwn5zi7l8vzzcfaik86qwhdtprc.jpeg"><br><br>  Misalnya, mesin JavaScript SpiderMonkey Mozilla, yang digunakan di Firefox dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SpiderNode</a> , bekerja sedikit berbeda.  Ini bukan satu, tetapi dua kompiler yang mengoptimalkan.  Interpreter dioptimalkan menjadi kompiler dasar (Kompilator dasar), yang menghasilkan beberapa kode yang dioptimalkan.  Bersama dengan profiling data yang dikumpulkan selama eksekusi kode, kompiler IonMonkey dapat menghasilkan kode yang sangat dioptimalkan.  Jika optimasi spekulatif gagal, IonMonkey kembali ke kode Baseline. <br><br><img src="https://habrastorage.org/webt/gu/ek/ps/guekpsu0p1nqwv-pynj7ts8skdo.jpeg"><br><br>  Chakra - mesin JavaScript milik Microsoft, digunakan pada Edge dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Node-ChakraCore</a> , memiliki struktur yang sangat mirip dan menggunakan dua kompiler yang mengoptimalkan.  Interpreter dioptimalkan dalam SimpleJIT (di mana JIT adalah singkatan dari "Just-In-Time compiler", yang menghasilkan kode yang agak dioptimalkan. Bersama dengan data profil, FullJIT dapat membuat kode yang lebih dioptimalkan lebih tinggi. <br><br><img src="https://habrastorage.org/webt/z-/bl/0v/z-bl0va0qlsrvgandnxrb08q52g.jpeg"><br><br>  JavaScriptCore (disingkat JSC), mesin JavaScript Apple yang digunakan oleh Safari dan React Native, umumnya memiliki tiga kompiler pengoptimal yang berbeda.  LLInt adalah juru bahasa level rendah yang dioptimalkan ke kompiler basis, yang pada gilirannya dioptimalkan ke kompiler DFG (Data Flow Graph), dan sudah dioptimalkan untuk kompiler FTL (Faster Than Light). <br><br>  Mengapa beberapa engine memiliki kompiler yang lebih optimal daripada yang lain?  Ini semua tentang kompromi.  Interpreter dapat memproses bytecode dengan cepat, tetapi bytecode saja tidak terlalu efisien.  Sebaliknya, kompiler pengoptimal bekerja sedikit lebih lama, tetapi menghasilkan kode mesin yang lebih efisien.  Ini adalah kompromi antara cepat mendapatkan kode (juru bahasa) atau beberapa menunggu dan menjalankan kode dengan kinerja maksimum (mengoptimalkan kompiler).  Beberapa engine memilih untuk menambahkan beberapa kompiler yang mengoptimalkan dengan karakteristik waktu dan efisiensi yang berbeda, yang memungkinkan Anda untuk memberikan kontrol terbaik atas solusi kompromi ini dan memahami biaya komplikasi tambahan dari perangkat internal.  Pertukaran lainnya adalah penggunaan memori, lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> ini untuk pemahaman yang lebih baik. <br><br>  Kami baru saja memeriksa perbedaan utama antara pipa penyalur interpreter dan optimizer untuk berbagai mesin JavaScript.  Terlepas dari perbedaan tingkat tinggi ini, semua mesin JavaScript memiliki arsitektur yang sama: semuanya memiliki parser dan semacam pipa juru bahasa / penyusun. <br><br>  <b>Model objek JavaScript</b> <br><br>  Mari kita lihat kesamaan apa yang dimiliki mesin JavaScript dan trik apa yang mereka gunakan untuk mempercepat akses ke properti objek JavaScript?  Ternyata semua mesin utama melakukan ini dengan cara yang sama. <br><br>  Spesifikasi ECMAScript mendefinisikan semua objek sebagai kamus dengan kunci string yang cocok dengan atribut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">properti</a> . <br><br><img src="https://habrastorage.org/webt/7s/vv/qq/7svvqqqqfcqi2y-v88nlstidtik.jpeg"><br><br>  Selain <code>[[Value]]</code> , spesifikasi mendefinisikan properti berikut: <br><br><ul><li>  <code>[[Writable]]</code> menentukan apakah suatu properti dapat dipindahkan; </li><li>  <code>[[Enumerable]]</code> menentukan apakah properti ditampilkan dalam for-in loop; </li><li>  <code>[[Configurable]]</code> menentukan apakah suatu properti dapat dihapus. </li></ul><br>  Notasi <code>[[  ]]</code> terlihat aneh, tetapi begitulah spesifikasi menjelaskan properti di JavaScript.  Anda masih bisa mendapatkan atribut properti ini untuk objek dan properti apa pun yang diberikan dalam JavaScript menggunakan API <code>Object.getOwnPropertyDescriptor</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object = { <span class="hljs-attr"><span class="hljs-attr">foo</span></span>: <span class="hljs-number"><span class="hljs-number">42</span></span> }; <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getOwnPropertyDescriptor(object, <span class="hljs-string"><span class="hljs-string">'foo'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// → { value: 42, writable: true, enumerable: true, configurable: true }</span></span></code> </pre> <br>  Oke, jadi JavaScript mendefinisikan objek.  Bagaimana dengan array? <br><br>  Anda dapat membayangkan array sebagai objek khusus.  Satu-satunya perbedaan adalah array memiliki pemrosesan indeks khusus.  Di sini, indeks array adalah istilah khusus dalam spesifikasi skrip ECMAS.  JavaScript memiliki batasan jumlah elemen dalam array - hingga 2³² - 1.  Indeks array adalah indeks apa pun yang tersedia dari rentang ini, yaitu nilai integer dari 0 hingga 2³² - 2. <br><br>  Perbedaan lainnya adalah array memiliki properti ajaib yang <code>length</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> array = [<span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span>]; array.length; <span class="hljs-comment"><span class="hljs-comment">// → 2 array[2] = 'c'; array.length; // → 3</span></span></code> </pre> <br>  Dalam contoh ini, array memiliki panjang 2 pada saat pembuatan.  Kemudian kami menetapkan elemen lain untuk mengindeks 2 dan panjangnya bertambah secara otomatis. <br><br>  JavaScript mendefinisikan array serta objek.  Sebagai contoh, semua kunci, termasuk indeks array, direpresentasikan secara eksplisit sebagai string.  Elemen pertama array disimpan di bawah tombol '0'. <br><br><img src="https://habrastorage.org/webt/a0/nr/18/a0nr18etozy9wzmzzsd9zbykxt0.jpeg"><br><br>  Properti <code>length</code> hanyalah properti lain yang ternyata non-enumerable dan non-konfigurasi. <br><br>  Segera setelah elemen ditambahkan ke array, JavaScript secara otomatis memperbarui atribut properti <code>[[Value]]</code> properti <code>length</code> . <br><br><img src="https://habrastorage.org/webt/ws/hs/89/wshs896vflemplsrai-wqu5brkw.jpeg"><br><br>  Secara umum, kita dapat mengatakan bahwa array berperilaku mirip dengan objek. <br><br>  <b>Optimalisasi akses ke properti</b> <br><br>  Sekarang kita tahu bagaimana objek didefinisikan dalam JavaScript, mari kita lihat bagaimana mesin JavaScript memungkinkan Anda untuk bekerja dengan objek secara efisien. <br><br>  Dalam kehidupan sehari-hari, akses ke properti adalah operasi yang paling umum.  Sangat penting bagi mesin untuk melakukan ini dengan cepat. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object = { <span class="hljs-attr"><span class="hljs-attr">foo</span></span>: <span class="hljs-string"><span class="hljs-string">'bar'</span></span>, <span class="hljs-attr"><span class="hljs-attr">baz</span></span>: <span class="hljs-string"><span class="hljs-string">'qux'</span></span>, }; <span class="hljs-comment"><span class="hljs-comment">// Here, we're accessing the property `foo` on `object`: doSomething(object.foo); // ^^^^^^^^^^</span></span></code> </pre> <br>  <b>Bentuk</b> <br><br>  Dalam program JavaScript, cukup umum untuk menetapkan kunci properti yang sama ke banyak objek.  Mereka mengatakan bahwa benda-benda tersebut memiliki <i>bentuk yang</i> sama. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object1 = { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object2 = { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-number"><span class="hljs-number">4</span></span> }; <span class="hljs-comment"><span class="hljs-comment">// `object1` and `object2` have the same shape.</span></span></code> </pre> <br>  Juga mekanisme umum adalah akses ke properti benda dengan bentuk yang sama: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">logX</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">object</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(object.x); <span class="hljs-comment"><span class="hljs-comment">// ^^^^^^^^ } const object1 = { x: 1, y: 2 }; const object2 = { x: 3, y: 4 }; logX(object1); logX(object2);</span></span></code> </pre> <br>  Mengetahui hal ini, mesin JavaScript dapat mengoptimalkan akses ke properti objek berdasarkan bentuknya.  Lihat cara kerjanya. <br><br>  Misalkan kita memiliki objek dengan properti x dan y, ia menggunakan struktur data kamus, yang telah kita bicarakan sebelumnya;  itu berisi string kunci yang menunjuk ke atribut masing-masing. <br><br><img src="https://habrastorage.org/webt/ss/ne/v9/ssnev9md3jko58annrfjraz35ay.jpeg"><br><br>  Jika Anda mengakses properti, seperti <code>object.y,</code> mesin JavaScript mencari JSObject dengan kunci <code>'y'</code> , kemudian memuat atribut properti yang cocok dengan kueri ini dan akhirnya mengembalikan <code>[[Value]]</code> . <br><br>  Tetapi di mana atribut properti ini disimpan dalam memori?  Haruskah kita menyimpannya sebagai bagian dari JSObject?  Jika kita melakukan ini, kita akan melihat lebih banyak objek dari formulir ini nanti, dalam hal ini, buang-buang ruang untuk menyimpan kamus lengkap yang berisi nama properti dan atribut di JSObject itu sendiri, karena nama properti diulang untuk semua objek dengan bentuk yang sama.  Ini menyebabkan banyak duplikasi dan menyebabkan kesalahan alokasi memori.  Untuk optimasi, mesin menyimpan bentuk objek secara terpisah. <br><br><img src="https://habrastorage.org/webt/mc/yr/mt/mcyrmt9jarqodgtvnwoxzatiwyy.jpeg"><br><br>  <code>Shape</code> ini berisi semua nama dan atribut properti kecuali <code>[[Value]]</code> .  Sebagai gantinya, formulir berisi nilai offset di dalam JSObject, jadi mesin JavaScript tahu ke mana harus mencari nilai.  Setiap JSObject dengan bentuk umum menunjukkan contoh spesifik dari formulir.  Sekarang setiap JSObject harus menyimpan hanya nilai yang unik untuk objek. <br><br><img src="https://habrastorage.org/webt/-0/-q/t5/-0-qt5an58iyuoeskzaibbtgcno.jpeg"><br><br>  Keuntungan menjadi jelas segera setelah kami memiliki banyak objek.  Jumlah mereka tidak masalah, karena jika mereka memiliki satu formulir, kami menyimpan informasi tentang formulir dan properti hanya sekali. <br><br>  Semua mesin JavaScript menggunakan formulir sebagai alat optimasi, tetapi mereka tidak menamainya secara langsung sebagai <code>shapes</code> : <br><br><ol><li>  Dokumentasi Akademik menyebutnya Kelas Tersembunyi (mirip dengan kelas JavaScript); </li><li>  V8 menyebutnya Peta; </li><li>  Chakra menyebut mereka Jenis; </li><li>  JavaScriptCore menyebutnya Struktur; </li><li>  SpiderMonkey memanggil mereka Shapes. </li></ol><br>  Dalam artikel ini, kami terus menyebutnya <code>shapes</code> . <br><br>  <b>Rantai transisi dan pohon</b> <br><br>  Apa yang terjadi jika Anda memiliki objek dengan bentuk tertentu, tetapi Anda menambahkan properti baru ke dalamnya?  Bagaimana cara mesin JavaScript mendefinisikan bentuk baru? <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object = {}; object.x = <span class="hljs-number"><span class="hljs-number">5</span></span>; object.y = <span class="hljs-number"><span class="hljs-number">6</span></span>;</code> </pre> <br>  Formulir membuat apa yang disebut rantai transisi di mesin JavaScript.  Berikut ini sebuah contoh: <br><br><img src="https://habrastorage.org/webt/tm/tz/np/tmtznpiuyzkz9vpxqe6byhw2x-k.jpeg"><br><br>  Objek pada awalnya tidak memiliki properti, itu sesuai dengan formulir kosong.  Ekspresi berikut menambahkan properti <code>'x'</code> dengan nilai 5 ke objek ini, kemudian mesin pergi ke bentuk yang berisi properti <code>'x'</code> dan nilai 5 ditambahkan ke JSObject pada offset pertama 0. Baris berikutnya menambahkan properti <code>'y'</code> , kemudian mesin menuju ke properti berikutnya formulir yang sudah berisi <code>'x'</code> dan <code>'y'</code> , dan juga menambahkan nilai 6 ke JSObject di offset 1. <br><blockquote>  <b>Catatan</b> : Urutan di mana properti ditambahkan mempengaruhi formulir.  Misalnya, {x: 4, y: 5} akan menghasilkan bentuk yang berbeda dari {y: 5, x: 4}. <br></blockquote>  Kami bahkan tidak perlu menyimpan seluruh tabel properti untuk setiap formulir.  Sebaliknya, setiap formulir hanya perlu mengetahui properti baru yang mereka coba sertakan di dalamnya.  Misalnya, dalam hal ini, kita tidak perlu menyimpan informasi tentang 'x' dalam bentuk yang terakhir, karena dapat ditemukan sebelumnya dalam rantai.  Agar ini berfungsi, formulir bergabung dengan bentuk sebelumnya. <br><br><img src="https://habrastorage.org/webt/ks/ou/pv/ksoupve8bep3jsp0v7u2ahyv9jg.jpeg"><br><br>  Jika Anda menulis <code>ox</code> dalam kode JavaScript Anda, JavaScript akan mencari properti <code>'x'</code> sepanjang rantai transisi hingga mendeteksi bentuk yang sudah memiliki properti <code>'x'</code> di dalamnya. <br><br>  Tetapi apa yang terjadi jika tidak mungkin membuat rantai transisi?  Misalnya, apa yang terjadi jika Anda memiliki dua objek kosong dan Anda menambahkan properti yang berbeda padanya? <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object1 = {}; object1.x = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object2 = {}; object2.y = <span class="hljs-number"><span class="hljs-number">6</span></span>;</code> </pre> <br>  Dalam kasus ini, cabang muncul, dan alih-alih rantai transisi kita mendapatkan pohon transisi: <br><br><img src="https://habrastorage.org/webt/bc/ga/ax/bcgaaxeskfqwqt8geu_pxmqwdou.jpeg"><br><br>  Kami membuat objek kosong <code>a</code> dan menambahkan properti <code>'x'</code> .  Akibatnya, kami memiliki <code>JSObject</code> berisi nilai tunggal dan dua formulir: kosong dan formulir dengan properti <code>'x'</code> tunggal. <br><br>  Contoh kedua dimulai dengan fakta bahwa kita memiliki objek kosong <code>b</code> , tetapi kemudian kita menambahkan properti lain <code>'y'</code> .  Hasilnya, di sini kita mendapatkan dua rantai bentuk, tetapi pada akhirnya kita mendapatkan tiga rantai. <br><br>  Apakah ini berarti kita selalu mulai dengan formulir kosong?  Belum tentu.  Mesin menggunakan beberapa optimasi objek literal, yang sudah mengandung properti.  Katakanlah kita menambahkan x, dimulai dengan objek kosong literal, atau kita memiliki objek literal yang sudah berisi <code>x</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object1 = {}; object1.x = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object2 = { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">6</span></span> };</code> </pre> <br>  Pada contoh pertama, kita mulai dengan formulir kosong dan pergi ke rantai yang juga berisi <code>x</code> , seperti yang kita lihat sebelumnya. <br><br>  Dalam kasus <code>object2</code> masuk akal untuk secara langsung membuat objek yang sudah memiliki x dari awal, daripada memulai dengan objek kosong dan transisi. <br><br><img src="https://habrastorage.org/webt/qv/_0/l-/qv_0l-f5eekqflfmto7lfd-awwq.jpeg"><br><br>  Literal dari objek yang berisi properti <code>'x'</code> dimulai dengan bentuk yang mengandung <code>'x'</code> sejak awal, dan bentuk kosong dilewati secara efektif.  Inilah (setidaknya) yang dilakukan V8 dan SpiderMonkey.  Optimalisasi memperpendek rantai transisi dan membuatnya lebih mudah untuk mengumpulkan objek dari literal. <br><br>  Posting blog Benedict tentang polimorfisme aplikasi yang menakjubkan tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">React</a> berbicara tentang bagaimana seluk-beluk seperti itu dapat memengaruhi kinerja. <br><br>  Selanjutnya Anda akan melihat contoh titik-titik objek tiga dimensi dengan properti <code>'x'</code> , <code>'y'</code> , <code>'z'</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> point = {}; point.x = <span class="hljs-number"><span class="hljs-number">4</span></span>; point.y = <span class="hljs-number"><span class="hljs-number">5</span></span>; point.z = <span class="hljs-number"><span class="hljs-number">6</span></span>;</code> </pre> <br>  Seperti yang Anda pahami sebelumnya, kami membuat objek dengan tiga bentuk dalam memori (tidak termasuk bentuk kosong).  Untuk mengakses properti <code>'x'</code> dari objek ini, misalnya, jika Anda menulis <code>point.x</code> di program Anda, mesin JavaScript harus mengikuti daftar tertaut: mulai dari formulir di bagian paling bawah, dan kemudian secara bertahap bergerak ke atas ke bentuk yang memiliki <code>'x'</code> di bagian paling atas. <br><br><img src="https://habrastorage.org/webt/tv/rn/mp/tvrnmp1s5p25dseplockgifr6x0.jpeg"><br><br>  Ternyata sangat lambat, terutama jika Anda sering melakukannya dan dengan banyak properti objek.  Waktu tinggal properti adalah <code>O(n)</code> , yaitu, itu adalah fungsi linier yang berkorelasi dengan jumlah properti objek.  Untuk mempercepat pencarian properti, mesin JavaScript menambahkan struktur data ShapeTable.  ShapeTable adalah kamus tempat kunci dipetakan dengan cara tertentu dengan formulir dan menghasilkan properti yang diinginkan. <br><br><img src="https://habrastorage.org/webt/y8/vh/40/y8vh40rwdlx99jdv-rpumbe1u3u.jpeg"><br><br>  Tunggu sebentar, sekarang kita kembali ke pencarian kamus ... Ini adalah apa yang kita mulai dengan ketika kita meletakkan formulir di tempat pertama!  Jadi mengapa kita peduli dengan formulir? <br>  Faktanya adalah bahwa formulir berkontribusi pada pengoptimalan lain yang disebut <i>Cache Inline.</i> <br><br>  Kami akan berbicara tentang konsep cache inline atau IC di bagian <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kedua</a> artikel, dan sekarang kami ingin mengundang Anda ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">webinar terbuka gratis</a> , yang akan dipegang oleh analis virus terkenal dan guru paruh waktu, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Alexander Kolesnikov</a> , pada 9 April. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id446446/">https://habr.com/ru/post/id446446/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id446434/index.html">Zimbra Collaboration Suite Scaling</a></li>
<li><a href="../id446436/index.html">Cara menghasilkan hipotesis tentang kebutuhan konsumen potensial produk masa depan Anda</a></li>
<li><a href="../id446438/index.html">Pengalaman Pembuatan API Gateway Kami</a></li>
<li><a href="../id446440/index.html">Buku Bereaksi Cepat. Aplikasi web dalam React, JSX, Redux dan GraphQL »</a></li>
<li><a href="../id446444/index.html">Dari Skype ke WebRTC: Bagaimana Kami Mengatur Komunikasi Video Web</a></li>
<li><a href="../id446448/index.html">5 aturan dasar untuk melakukan wawancara masalah untuk mengidentifikasi kebutuhan konsumen</a></li>
<li><a href="../id446452/index.html">Misi Lunar "Bereshit" - 4 April 2019, transisi ke orbit bulan selesai, 7 hari penerbangan di depan, 6 manuver dan 1 pendaratan</a></li>
<li><a href="../id446454/index.html">Pengembangan Server Web Golang - Dari Mudah ke Kompleks</a></li>
<li><a href="../id446456/index.html">Substitusi impor dalam praktek. Bagian 1. Opsi</a></li>
<li><a href="../id446458/index.html">DRO universal berdasarkan Arduino Nano - shDRO. Bagian 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>