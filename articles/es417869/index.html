<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üïäÔ∏è ‚¨áÔ∏è üåÉ C√≥mo depurar WebRTC üß§ üëßüèº üë©üèæ‚Äçü§ù‚Äçüë©üèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En Voximplant, hemos estado usando WebRTC desde su inicio: primero como una alternativa a Flash para llamadas de voz y video, y luego como un reemplaz...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C√≥mo depurar WebRTC</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/Voximplant/blog/417869/">  En Voximplant, hemos estado usando WebRTC desde su inicio: primero como una alternativa a Flash para llamadas de voz y video, y luego como un reemplazo completo.  La tecnolog√≠a ha recorrido un largo y doloroso camino de desarrollo, solo recientemente todos los principales navegadores han comenzado a admitirla, existen dificultades con la transferencia de pantalla, varias transmisiones de video y, a veces, el navegador se bloquea simplemente si apaga y enciende la transmisi√≥n de video.  La experiencia acumulada nos permite traducir art√≠culos interesantes para Habr, y hoy le pasamos la voz a Lee Sylvester de Xirsys, quien hablar√° sobre depuraci√≥n de llamadas (video) en Chrome, Firefox, Safari y Edge.  La depuraci√≥n de WebRTC no es f√°cil, incluso tenemos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">instrucciones</a> especiales para eliminar registros en navegadores populares.  Y lo que Lee tiene: lo descubrir√° debajo del corte (spoiler: mucho de todo, incluido WireShark). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cf/yz/h0/cfyzh02gdgxjvmew9ifyv8p9iju.jpeg"></div><a name="habracut"></a><br><h2>  El lado oscuro de WebRTC </h2><br>  Mientras trabajaba en Xirsys, vi algunas aplicaciones realmente geniales que usaban WebRTC.  Pero mientras un peque√±o grupo de desarrolladores crea cosas de alta tecnolog√≠a, la mayor√≠a de los programadores ni siquiera pueden comenzar a usar WebRTC.  Por qu√©  Y todo es simple.  Es complicado <br><br>  Muchos de nosotros estamos familiarizados con una aplicaci√≥n web t√≠pica.  Dicha aplicaci√≥n tiene un cliente que env√≠a solicitudes y un servidor que responde a estas solicitudes.  Un proceso simple, lineal y f√°cilmente predecible.  Si algo sale mal, generalmente sabemos d√≥nde mirar los registros y qu√© podr√≠a suceder.  Pero con WebRTC, no todo es tan simple. <br><br><h2>  Asincron√≠a </h2><br>  Si alguna vez ha escrito una aplicaci√≥n multiproceso, entonces probablemente conozca el dolor de cabeza que genera este desarrollo.  Vuelos, mala memoria, pero a menudo solo errores que son dif√≠ciles de encontrar. <br><br>  WebRTC es de naturaleza as√≠ncrona.  Y esto no es en absoluto la simple asincron√≠a AJAX.  Para establecer una analog√≠a, estas son varias solicitudes AJAX lanzadas simult√°neamente que intentan conciliar datos en dos computadoras.  Eso sigue siendo entretenimiento. <br><br><h2>  Campo de minas de derivaci√≥n NAT </h2><br>  La creaci√≥n de aplicaciones web se reduce al desarrollo de algo que se ejecuta en el servidor y responde a las solicitudes.  Lo peor que puede pasar es el puerto que no est√° abierto en IPTables.  Se trata en 2 minutos.  No se puede decir sobre WebRTC. <br><br>  Los servidores web, ni siquiera su software, sino su hardware, son dispositivos con direcciones IP p√∫blicas.  Est√°n hechos para ser accesibles desde cualquier lugar.  Y WebRTC est√° hecho para enviar y recibir datos de las computadoras de los usuarios.  Que suelen tener una direcci√≥n IP de 192.168. Algo y no se queman con el deseo de responder a las solicitudes de red. <br><br>  Los autores de WebRTC lo saben, por lo que el motor clasificar√° los diferentes m√©todos de conexi√≥n, en un intento de establecer una conexi√≥n entre dos computadoras que no est√°n muy dise√±adas para ello. <br><br><h2>  D√≥nde comenzar a depurar </h2><br>  En este art√≠culo hablo sobre las herramientas b√°sicas para resolver los problemas m√°s populares.  Pero antes de eso, veamos c√≥mo WebRTC generalmente establece una conexi√≥n. <br><br><h2>  C√≥mo WebRTC establece una conexi√≥n </h2><br>  Todas las conexiones WebRTC requieren un poco de ayuda del protocolo de se√±alizaci√≥n.  "Peque√±a ayuda" es su propio servidor y protocolo con el que la persona que llama podr√° comunicarse con la persona a la que llama antes de establecer una conexi√≥n punto a punto. <br><br>  WebRTC utilizar√° el protocolo de se√±alizaci√≥n para transmitir informaci√≥n sobre direcciones IP, la capacidad de capturar y reproducir voz y video, topolog√≠a de red y datos transmitidos. <br><br>  El protocolo de uso com√∫n es COMET (o SIP - nota del traductor) y sockets web.  WebRTC no limita a los desarrolladores a nada, por lo que puede usar lo que quiera, al menos transferir datos a trav√©s del Bloc de notas y copiar y pegar (hecho en uno de los talleres, funciona, nuevamente un traductor).  La se√±alizaci√≥n conectada a ambas computadoras le permite iniciar una conexi√≥n ya a trav√©s de WebRTC. <br><br><h4>  Oferta y respuesta </h4><br>  Las conexiones WebRTC usan "oferta" y "respuesta": <br><br><ol><li>  El iniciador de la conexi√≥n crea y pasa al otro lado "oferta". </li><li>  La otra parte recibe una "oferta", crea una "respuesta" y la devuelve. </li><li>  El iniciador de la conexi√≥n recibe una "respuesta". </li></ol><br>  Esto es en teor√≠a.  En la pr√°ctica, el intercambio de cortes√≠as no parece tan simple. <br><br><ol><li>  Antes de transmitir la "oferta", el iniciador de conexi√≥n crea una instancia de <b>RTCPeerConnection</b> y recibe de √©l el paquete de texto "SDP" (Protocolo de descripci√≥n de sesi√≥n) usando <b>rtcPeerConnection.createOffer ()</b> ;  Este paquete describe la capacidad de recibir / transmitir voz y video para el navegador. </li><li>  El contenido del paquete SDP se establece como "descripci√≥n del lado local de la conexi√≥n" utilizando <b>rtcPeerConnection.setLocalDescription ()</b> . </li><li>  El paquete se env√≠a al otro lado, donde su contenido se establece como "la descripci√≥n del otro lado de la conexi√≥n" mediante <b>rtcPeerConnection.setRemoteDescription ()</b> . </li><li>  En el otro lado de la conexi√≥n, su propio paquete SDP se crea usando <b>rtcPeerConnection.createAnswer ()</b> , su contenido se establece como la "descripci√≥n del lado local de la conexi√≥n". </li><li>  El paquete se pasa al iniciador de la conexi√≥n, que establece su contenido como "una descripci√≥n del otro lado de la conexi√≥n". </li></ol><br>  Y solo despu√©s de todas las acciones, ambas partes conectadas conocen las capacidades del otro para recibir y enviar voz / video. <br><br><h4>  Candidatos de ICE </h4><br>  Pero la capacidad de trabajar con los medios no es suficiente.  Despu√©s de todo, las partes contratantes a√∫n no han dicho nada sobre el estado de la red. <br><br>  Puede averiguar qu√© c√≥decs de video admite el navegador y si hay una c√°mara en la computadora port√°til casi al instante.  Toma tiempo encontrar su direcci√≥n IP externa y la l√≥gica de la operaci√≥n NAT, y la informaci√≥n sobre el estado de la red se intercambia a medida que se recibe esta informaci√≥n. <br><br>  Gracias a la tecnolog√≠a Trickle ICE (no es compatible con todos los navegadores - nota del traductor), la conexi√≥n entre dos dispositivos WebRTC se puede establecer en cualquier momento, tan pronto como se encuentre un "candidato" adecuado. <br><br>  El desarrollador debe suscribirse al evento <b>onicecandidate</b> (¬°todo en min√∫sculas!) Y pasar los paquetes SDP recibidos al otro lado, donde deben ser transmitidos por WebRTC utilizando el m√©todo <b>addIceCandidate</b> (y aqu√≠, sorpresa, may√∫scula).  Funciona en ambos sentidos. <br><br><h2>  Conexi√≥n </h2><br>  WebRTC utiliza cosas como STUN (Utilidades transversales de sesi√≥n para NAT) y TURN (Transversal mediante retransmisi√≥n alrededor de NAT) para establecer una conexi√≥n.  Suena aterrador, pero en realidad solo hay dos protocolos de red. <br><br><h4>  Servidor STUN </h4><br>  El primero de los dos protocolos es un poco m√°s complicado que el servidor echo.  Cuando los participantes que se conectan desean describir c√≥mo conectarse a ellos, necesitan su direcci√≥n IP p√∫blica.  Y lo m√°s probable es que no sea la direcci√≥n IP de la computadora, los dispositivos p√∫blicos rara vez se asignan a los dispositivos de los usuarios.  Toda la tecnolog√≠a NAT fue inventada para no aislar.  Para averiguar a√∫n su direcci√≥n p√∫blica, el navegador realiza una solicitud al servidor STUN.  Al pasar por NAT, el paquete de red cambia su direcci√≥n de retorno a p√∫blico.  Una vez recibido el paquete con la solicitud, el servidor STUN copia la direcci√≥n de retorno del paquete a su carga √∫til y lo devuelve.  Al pasar por NAT en la direcci√≥n opuesta, el paquete pierde su direcci√≥n IP p√∫blica, pero una copia de esta direcci√≥n permanece en la carga √∫til, donde WebRTC puede leerlo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qh/vo/8r/qhvo8rafhc4akmapxnb7vtni2pe.png"></div><br><h2>  Servidor TURN </h2><br>  El servidor TURN usa la extensi√≥n de protocolo STUN.  Los mismos paquetes, encabezados, m√°s una cosa nueva: <b>comando</b> .  El servidor es un proxy: ambos clientes se conectan a √©l a trav√©s del puerto de <b>asignaci√≥n</b> UDP y transmiten sus datos a trav√©s del servidor. <br><br>  Los servidores TURN est√°n dise√±ados de tal manera que el iniciador de la conexi√≥n tiene m√°s funciones que el otro lado.  Esto lleva a un efecto interesante cuando una llamada a trav√©s de un servidor TURN es exitosa o no, dependiendo de qui√©n llama a qui√©n (recuerde todo el traductor de notas de Skype). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/07/j6/qq/07j6qqsbyc7fod_yx2vuk_9zctu.png"></div><br><h2>  Depuraci√≥n </h2><br>  Entonces, le√≠ste este p√°rrafo.  Estamos contentos con el traductor y recordamos que el art√≠culo trata sobre la depuraci√≥n de WebRTC.  Pero todo lo anterior es un m√≠nimo necesario, sin el cual ni siquiera puede comenzar.  Pero si comienzas y no tienes suerte inhumana, entonces se romper√°. <br><br>  Se romper√° de muchas maneras diferentes.  El primero es la falta de conectividad.  Pas√≥ la configuraci√≥n del servidor STUN y TURN a ambos WebRTC, los ayud√≥ a intercambiar ofertas, respuestas y candidatos de ICE, pero no hay video ni voz.  Por donde empezar  Con problemas de reproducci√≥n local. <br><br><h2>  Depuraci√≥n local de WebRTC </h2><br>  Como escrib√≠ anteriormente, el trabajo principal de WebRTC ocurre en el lado del navegador.  Los servidores STUN y TURN son incre√≠blemente simples, por lo que la mayor√≠a de los problemas ocurren en su c√≥digo JavaScript, que se ejecuta en dos navegadores.  Triste pero cierto.  Por otro lado, si lo m√°s interesante sucede localmente en los navegadores, ¬°entonces tienes muchas oportunidades para depurar! <br><br>  Lo primero que debe verificar es su se√±alizaci√≥n.  Es su c√≥digo el que transmite la configuraci√≥n de audio con video (oferta, respuesta) e informaci√≥n sobre la configuraci√≥n de red (candidatos de hielo) entre los navegadores.  Debe verificar qu√© paquetes se enviaron, cu√°les recibieron y transmitieron WebRTC: <br><br><ul><li>  el otro lado de la conexi√≥n recibi√≥ una oferta?  ¬øEl iniciador de conexi√≥n ha recibido una respuesta?  No se establecer√° una conexi√≥n sin este intercambio m√≠nimo de servicios; </li><li>  ¬øWebRTC en ambos extremos de la conexi√≥n le pas√≥ paquetes con candidatos de ICE?  ¬øIntercambiaste estos paquetes y los <b>devolviste al</b> lado opuesto usando <b>addIceCandidate</b> ? </li><li>  si todo sali√≥ bien con el intercambio de paquetes, ¬øse <b>llam√≥ al</b> controlador de eventos <b>onaddstream</b> e instal√≥ el objeto resultante en un elemento HTML para reproducir video (o audio)? </li></ul><br>  Si el intercambio de paquetes no es sospechoso, puede profundizar en las entra√±as de la sesi√≥n. <br><br><h2>  Protocolo de descripci√≥n de sesi√≥n </h2><br>  WebRTC crea los paquetes de oferta, respuesta e ICE en formato de texto SDP.  A primera vista, el contenido de los paquetes parece aterrador, pero con un poco de preparaci√≥n puede obtener muchos beneficios durante la depuraci√≥n.  Wikipedia describe SDP bastante bien, pero encontr√© una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">mejor descripci√≥n</a> para ti. <br><br>  El campo m√°s importante en los paquetes candidatos de ICE SDP es el <b>t√≠pico</b> .  Para WebRTC, un campo puede tener uno de tres valores: <br><br><ul><li>  tipo host; </li><li>  Typ srflx; </li><li>  rel√© t√≠pico </li></ul><br><h4>  host t√≠pico </h4><br>  El tipo de <b>host</b> especifica el candidato ICE para una conexi√≥n de √°rea local (WebRTC enumera varios candidatos con la esperanza de establecer una conexi√≥n, no se sabe de antemano cu√°l resultar√° - nota del traductor).  Dicha conexi√≥n no requiere un servidor STUN o TURN, ya que los dispositivos en la red local a menudo pueden establecer conexiones de red directamente.  Al depurar desde la red local, solo necesita verificar y depurar la transmisi√≥n de paquetes de <b>host</b> y asegurarse de que los dispositivos puedan enviarse paquetes UDP entre s√≠.  Aunque hay excepciones, en la pr√°ctica he visto configuraciones de red en las que el navegador necesitaba un servidor TURN para conectarse ... a s√≠ mismo. <br><br><h4>  Typ srflx </h4><br>  La combinaci√≥n de letras "srflx" significa "Server Reflexive" y marca a los candidatos a la conexi√≥n utilizando una direcci√≥n IP externa, donde un servidor STUN es suficiente para la conexi√≥n (utilizando la tecnolog√≠a de penetraci√≥n NAT, que tiene √©xito en aproximadamente el 80% de los casos, tenga en cuenta el traductor). <br><br><h4>  rel√© t√≠pico </h4><br>  "Relay" marca la conexi√≥n a trav√©s de un servidor TURN, que casi siempre es exitoso.  Es importante recordar que WebRTC no est√° obligado a crear exactamente tres paquetes diferentes con el campo "t√≠pico";  c√≥mo se seleccionan los candidatos depende de la implementaci√≥n de WebRTC en una versi√≥n espec√≠fica del navegador. <br><br><h2>  Probar la conectividad del dispositivo </h2><br>  Google ofrece una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aplicaci√≥n web</a> dedicada para probar las conexiones WebRTC en su dispositivo.  Abra la p√°gina, haga clic en el bot√≥n "Inicio" y el c√≥digo JavaScript intentar√° establecer una conexi√≥n con el servidor de Google mediante la se√±alizaci√≥n, los servidores STUN y TURN de Google. <br><br><h2>  WebRTC Internals </h2><br>  ¬øExamin√≥ todos los paquetes, comprob√≥ el c√≥digo, todo parece correcto, pero no funciona?  Para tales casos, Google ha proporcionado a su navegador Chrome una secci√≥n especial que muestra los aspectos internos de WebRTC durante la configuraci√≥n de la conexi√≥n y algunos gr√°ficos hermosos en caso de una conexi√≥n exitosa.  Para usar, abra un enlace t√©cnico especial en el navegador: <br><br> <code>chrome://webrtc-internals</code> <br> <br>  Si ya tiene abierta una aplicaci√≥n que usa WebRTC, ver√° inmediatamente un mont√≥n de datos t√©cnicos.  De lo contrario, solo abra otra pesta√±a y hay algo en ella que usa WebRTC.  La pesta√±a muestra todas las llamadas al objeto <b>RTCPeerConnection</b> y le permite ver en tiempo real c√≥mo se establece la conexi√≥n. <br><br><h2>  Configuraci√≥n ICE </h2><br>  En la parte superior de la p√°gina est√° la cadena ICE que se us√≥ para inicializar la conexi√≥n.  Si se cometi√≥ un error durante su formaci√≥n, esto ser√° inmediatamente visible (por la "l√≠nea ICE" el autor se refiere a la configuraci√≥n del objeto RTCPeerConnection con una lista de servidores STUN y TURN (el objeto 'iceServers') - nota del traductor).  ¬øQuiz√°s no hay una lista de servidores?  Debe configurar el objeto RTCPeerConnection antes de realizar la primera llamada a <b>createOffer</b> o <b>createAnswer</b> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lo/hz/xo/lohzxoou7x8sbrhqfwuruhcwsw4.png"></div><br><h2>  RTCPeerConnection Events </h2><br>  La siguiente secci√≥n interna muestra las llamadas a los m√©todos <b>RTCPeerConnection</b> y los eventos recibidos del objeto en orden cronol√≥gico.  Los errores se resaltan cuidadosamente en rojo.  Tenga en cuenta que el <b>addIceCandidateFailed</b> rojo a menudo no es un signo de error y la conexi√≥n puede establecerse normalmente.  Si la conexi√≥n es exitosa, el √∫ltimo evento en la lista ser√° un evento <b>iceconnectionstatechange</b> con un valor de <b>complete</b> . <br><br><h2>  Secci√≥n 'estad√≠sticas' </h2><br>  La siguiente secci√≥n es relevante cuando la conexi√≥n se establece con √©xito.  Contiene estad√≠sticas de datos transmitidos y retrasos en la red.  Las dos opciones m√°s interesantes son: <b>ssrc</b> y <b>bweforvideo</b> . <br><br><ul><li>  <b>ssrc</b> , "Stream Source", marca cada una de sus pistas de audio y video.  Muestra estad√≠sticas de datos transmitidos y par√°metros como el <b>tiempo de ida y vuelta</b> ; </li><li>  <b>bweforvideo</b> , BandWidth Estimate, muestra el ancho del canal de red utilizado. </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/te/9e/wt/te9ewt2nl26jhbezdqj3_rkr8d4.png"></div><br><h2>  Funci√≥n GetStats </h2><br>  A menudo no podr√° acceder a la p√°gina interna.  Por ejemplo, cuando ocurre un problema con su usuario.  En este caso, puede obtener los mismos datos que muestra la p√°gina interna llamando al m√©todo <b>getStats</b> en el objeto <b>RTCPeerConnection</b> .  Este m√©todo configura una funci√≥n de devoluci√≥n de llamada que WebRTC llamar√° cada vez que ocurra algo interesante.  La funci√≥n llamada obtiene un objeto con los campos que muestra la p√°gina interna: <br><br><pre> <code class="javascript hljs">rtcPeerConnection.getStats(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">stats</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">"lostpackets"</span></span>).innerText = stats.packetsLost; });</code> </pre><br>  Otra herramienta √∫til es el evento <b>oniceconnectionstatechange</b> de un objeto <b>RTCPeerConnection</b> .  El controlador de eventos recibir√° informaci√≥n sobre el progreso de la conexi√≥n.  Posibles opciones: <br><br><ul><li>  <b>nuevo</b> : WebRTC espera candidatos del segundo lado de la conexi√≥n, que deben agregarse utilizando el m√©todo <b>addIceCandidate</b> ; </li><li>  <b>comprobaci√≥n</b> : WebRTC recibi√≥ candidatos del segundo lado de la conexi√≥n, los compara con los locales e itera sobre las opciones; </li><li>  <b>conectado</b> : se selecciona un par adecuado de candidatos y se establece la conexi√≥n.  Es de destacar que despu√©s de esto, los candidatos pueden continuar viniendo, de acuerdo con el protocolo Trickle ICE; </li><li>  <b>completado</b> : se reciben todos los candidatos y se establece la conexi√≥n. </li><li>  <b>desconectado</b> : la conexi√≥n est√° <b>desconectada</b> .  En canales inestables, WebRTC puede reconectarse, monitoreamos la bandera <b>conectada</b> ; </li><li>  <b>cerrado</b> : la conexi√≥n se desconecta y WebRTC ya no funciona con ella. </li></ul><br>  Si la conexi√≥n termin√≥ en estado <b>fallido</b> , entonces podemos examinar los candidatos recibidos en ambos lados y entender por qu√© fall√≥ la conexi√≥n.  Por ejemplo, si un lado proporcion√≥ <b>candidatos</b> <b>host</b> y <b>srflx</b> , el otro lado <b>host</b> y <b>retransmisi√≥n</b> , pero los dispositivos estaban en redes diferentes. <br><br><h2>  Rect√°ngulo negro en lugar de video </h2><br>  A menudo hay una situaci√≥n en la que se establece la conexi√≥n, se transmite el sonido, pero en lugar del video, uno o ambos participantes tienen un rect√°ngulo negro.  En la mayor√≠a de los casos, esto sucede si asigna el objeto de video recibido a un elemento HTML antes de que la conexi√≥n pase al estado <b>completado</b> . <br><br><h2>  C√≥mo meter una varita afuera </h2><br>  Adem√°s del objeto <b>RTCPeerConnection y</b> las <b>partes</b> internas que muestra el navegador, puede utilizar herramientas de an√°lisis de paquetes de red como Wireshark.  Estas herramientas pueden mostrar paquetes de protocolos WebRTC usados.  Por ejemplo, Wireshark le mostrar√° el contenido de los paquetes STUN en la ventana principal, y puede filtrarlos escribiendo la palabra clave "aturdir" en el campo de filtro: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/c4/89/jf/c489jf68awl5u25fah6xnv8piee.png"></div><br>  ¬øQu√© mirar en las respuestas del servidor?  Si solo ve respuestas con el tipo de <b>enlace</b> , esto significa que solo se admite STUN (conversaci√≥n de IP externa) y WebRTC solo puede ofrecer candidatos <b>srflx</b> .  Si las respuestas contienen la <b>asignaci√≥n de</b> paquetes espec√≠ficos de TURN y <b>CreatePermission</b> , WebRTC tendr√° la oportunidad de intentar conectarse a trav√©s de un servidor proxy.  El analizador de paquetes marca la <b>asignaci√≥n</b> exitosa y no exitosa.  Si no hay uno exitoso, lo m√°s probable es que se pasen los par√°metros de acceso incorrectos a los servidores TURN (que casi siempre protegen con un nombre de usuario y contrase√±a, la nota del traductor). <br><br>  Si hay un paquete <b>CreatePermission Success Response</b> en el registro, entonces podemos suponer que todo est√° bien con las configuraciones STUN y TURN.  Y si tambi√©n hay un paquete <b>ChannelBind</b> , entonces fue posible establecer una conexi√≥n con el servidor TURN a alta velocidad. <br><br><h2>  Problemas celulares </h2><br>  En mi pr√°ctica, muchas soluciones WebRTC que establecen una conexi√≥n WiFi no pueden conectarse a trav√©s de 3G / 4G.  Una aplicaci√≥n iniciada en un dispositivo m√≥vil es m√°s dif√≠cil de depurar: no tenemos un analizador de paquetes tan simple como Wireshark, y Safari no puede mostrar los elementos internos de WebRTC.  La l√≥gica sugiere que si la aplicaci√≥n funciona bien a trav√©s de WiFi, entonces el problema no est√° en la aplicaci√≥n en s√≠, sino en la comunicaci√≥n celular.  ¬øC√≥mo depurar?  Tome una computadora port√°til y con√©ctele un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">dongle 3G</a> .  Por lo tanto, tiene un analizador de paquetes y registros convenientes con los que puede encontrar la ra√≠z de todos los problemas en un tiempo razonable. <br><br><h2>  Conclusiones </h2><br>  La depuraci√≥n de WebRTC no es f√°cil, pero si busca bien en Internet, puede encontrar muchos art√≠culos y ejemplos.  Si trabaja en el campo de las comunicaciones en tiempo real, le recomiendo que lea las especificaciones de RFC para los protocolos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">STUN</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">TURN</a> y la tecnolog√≠a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">WebRTC</a> .  Los documentos son grandes, pero la informaci√≥n contenida en ellos ayuda a tomar decisiones confiables y responder la pregunta "por qu√© no suena". </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es417869/">https://habr.com/ru/post/es417869/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es417859/index.html">Integraci√≥n 3CX con Microsoft Dynamics 365</a></li>
<li><a href="../es417861/index.html">Patr√≥n principal sin fin</a></li>
<li><a href="../es417863/index.html">¬øNi√±os para ordenar pronto? El Consejo de √âtica del Reino Unido autoriza la ingenier√≠a gen√©tica de embriones humanos.</a></li>
<li><a href="../es417865/index.html">Accesibilidad de Android: ¬øun lobo con piel de cordero? Conferencia de Yandex</a></li>
<li><a href="../es417867/index.html">C√≥mo evaluar la duraci√≥n de un proyecto de TI y cu√°ndo no vale la pena hacerlo</a></li>
<li><a href="../es417871/index.html">En la meta del turismo suborbital</a></li>
<li><a href="../es417873/index.html">Formas de crear ventanas emergentes</a></li>
<li><a href="../es417875/index.html">Salir del Rabbit Hole SPA con rieles modernos</a></li>
<li><a href="../es417877/index.html">C√≥mo Tinder (ligeramente) oculta tu ubicaci√≥n</a></li>
<li><a href="../es417879/index.html">C√≥mo realizar ex√°menes de Microsoft de forma gratuita [por ejemplo, una competencia reciente]</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>