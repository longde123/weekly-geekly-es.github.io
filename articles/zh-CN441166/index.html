<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧚🏾 🤛🏿 🧛🏾 我们从锁定的密码管理器中获取主密码1密码4 👏🏽 👐🏼 👨🏻‍🏫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="新工具，旧方法。 我们进行逆向工程，发现1Password的致命缺陷。 

 每个人都喜欢密码管理器。 它们之所以出色，有很多原因。 就个人而言，我在经理中有200多个条目。 在一个地方拥有这么多机密数据的情况下，很重要的一点是，如果记录被盗用，无论是恶意软件，漏洞利用，还是仅是闲置几分钟的计算机，...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>我们从锁定的密码管理器中获取主密码1密码4</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/441166/">  <b>新工具，旧方法。</b>  <b>我们进行逆向工程，发现1Password的致命缺陷。</b> <br><br> 每个人都喜欢密码管理器。 它们之所以出色，有很多原因。 就个人而言，我在经理中有200多个条目。 在一个地方拥有这么多机密数据的情况下，很重要的一点是，如果记录被盗用，无论是恶意软件，漏洞利用，还是仅是闲置几分钟的计算机，都必须了解损坏的程度。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">《华盛顿邮报》</a>最近根据我们的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">研究</a>发表了一篇文章。 本文有助于使人们意识到并非所有密码管理器都是相同的。 <br><br> 我坚信锁定的密码管理器受到了很好的保护。 如果有人可以访问我的计算机，那么由于可以从内存中可靠地清除信息，因此最大值可以依靠一堆随机字节。 <br><a name="habracut"></a><br>  1Password 4确实如此（请注意，最新版本为今天的第七个）。 在几年前切换到此模式之前，我检查了当管理器处于锁定状态时，确实没有明文密码。 因此，在妥协的情况下，攻击者将不得不处理加密存储。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/527/994/2ed/5279942edfcbb8687d113731500b6953.png"></div><br>  <i><font color="gray">保险库已锁定！</font></i> <br><br> 在这种状态下，没有密码条目或主密码。 非常合理和正确，并且1Password 4通过了此测试。 还是不行 <br><br> 为了摆脱无聊的细节，我将立即说：我们能够从1Password 4中锁定的实例中恢复主密码，如下所示。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0ad/2c0/d81/0ad2c0d817dd2dc75a942e5b2bd5b974.gif"><br>  <i><font color="gray">解锁1密码4并恢复您的主密码</font></i> <br><br> 动画显示1Password 4首先以常规方式解锁，然后锁定。 之后，我们运行我们的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">multipass</a>实用程序，该实用程序成功恢复了密码。 该实用程序利用对1Password 4中的密码输入字段的不正确处理来还原经过混淆的主密码缓冲区，对其进行去模糊处理，自动解锁1Password 4，最后在控制台中显示主密码。 <br><br><h1> 无聊的细节 </h1><br> 评估密码管理器的第一步是检查内存中是否有清除的主密码。 在任何能够与过程存储空间进行交互的十六进制编辑器中，这都是可能的。 例如，免费的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">HxD</a>编辑器。 使用它来打开1Password 4内存空间。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/38d/87b/b48/38d87bb48b7c4b87f39e44a990cd3f74.png"></div><br><br> 我们立即进入1Password 4内存空间的第一个可读区域。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ef4/e95/f2d/ef4e95f2d092a6f236ba53fdfd090787.png"></div><br>  <i><font color="gray">HxD内存表示示例</font></i> <br><br> 没什么特别的。 但是您可以进行搜索。 例如，如果您在1Password 4解锁窗口中输入密码，但是没有单击“解锁”按钮，情况会怎样： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e6c/d9c/08b/e6cd9c08bee8130e7775a51bd7a91ad0.png"></div><br>  <i><font color="gray">在字段中输入了主密码的情况下锁定了保管库1密码4</font></i> <br><br> 密码肯定在内存中吗？ <br><br> 我们打开HxD，但是用主密码（“ Z3Superpass＃”）搜索一行不会产生结果。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b41/066/2c0/b410662c04b7e3d642f05ef94eacc7da.png"></div><br><br> 似乎1Password在输入时会以某种方式对表格进行加密或混淆。 如果该程序正常运行，则一切正常。 <br><br><h1> 潜水更深 </h1><br> 要了解为什么在解锁对话框中清楚地显示了主密码后，为什么无法在内存中找到主密码，您应该找到与其交互的代码。 有几种方法。 您可以通过本地化“ GetMessage”，“ PeekMessage”，“ GetWindowText”或其他通常用于处理用户输入的Windows API来跟踪键盘和鼠标事件的处理。 因此，我们找到了记录击键的缓冲区，并通过它们进入了加密/模糊处理例程。 但这是一个漫长且容易出错的过程，特别是对于有时管理内存的大型框架而言，因此，您必须进行许多复制和转换才能跟踪缓冲区。 <br><br> 相反，我们使用了自己的Thread Imager工具，该工具旨在在应用程序级别对“怪异”专有协议进行逆向工程。 它将帮助您确定1Password 4在内存中与我们的主密码进行交互的位置。 该工具“自动”识别1Password 4中与混淆密码交互的代码区域（它只是突出显示与感兴趣的数据交互的指令以进行进一步分析）。 结果看起来像这样： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b6b/c11/157/b6bc1115787869abc9ba25719b7c060a.gif"><br>  <i><font color="gray">Thread Imager找到与不专心的主密码交互的1Password 4代码</font></i> <br><br> 由于主密码以混淆形式存储在内存中，因此该工具应首先显示混淆发生的位置。 <br><br> 第一个结果的片段显示，主密码的首次出现伴随着从地址0x7707A75D到0x701CFA10的代码转换。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/49b/f32/d7a/49bf32d7a1f5b0bf01f12f7d47685dea.png"></div><br>  <i><font color="gray">Thread Imager中的详细条目突出显示了从0x7707A75D到0x701CFA10的代码过渡，而EAX和ECX寄存器使用主密码引用了缓冲区</font></i> <br><br> 在调试器（x64dbg）中检查此位置0x7707A75D证实了我们的理论。 确实，第一次，当来自ntdll.dll库的解码功能“ RtlRunDecodeUnicodeString”结束时，出现了字符串“ Z3superpass＃”。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/173/cd8/1bb/173cd81bba5c294f9e21c139610ee290.png"><br><br> 经过一点分析，很明显，这两个函数用于混淆密码：“ RtlRunEncodeUnicodeString”和“ RtlRunDecodeUnicodeString”。 因此，主密码对于从内存中的原始复制是隐藏的，这就是为什么我们以前无法在十六进制编辑器中找到它的原因。 <br><br> 如果您在RtlRunEncodeUnicodeString函数的末尾研究编码缓冲区，则带有主密码的加密行如下所示： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d47/547/aec/d47547aecf337b3c33206ddbe3bbad97.png"></div><br>  <i><font color="gray">加密的主密码</font></i> <br><br> 在RtlRunDecodeUnicodeString'之后被解码： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/204/85b/b2b/20485bb2b8b6f40b6509db04bcedf5b1.png"></div><br>  <i><font color="gray">解密的主密码</font></i> <br><br> 有趣的是，此区域保存在相同的地址0x00DFA790中，我们可以在1Password 4解锁窗口中输入密码时从字面上观察其变化： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3cf/d32/83f/3cfd3283fef38c3e5ef0a62630b4372b.gif"></div><br><br><h1> 脆弱性 </h1><br>  “ RtlRunEncodeUnicodeString”和“ RtlRunDecodeUnicodeString”是使用简单的XOR操作修改字符串的简单函数。 这还不错：它似乎是掩盖所有带有“ ES_PASSWORD”标志的本机Windows编辑控件的标准方法。 <br><br> 问题在于，在解锁1Password 4之后，不会从内存中清除加密的主密码。 <br><br> 更糟糕的是，即使在1Password 4锁定之后，它仍然保留在内存中，也就是说，我们有一个锁定的密码存储，但是在内存中具有加密的主密码。 <br><br> 甚至更糟糕的是，由于我们与主密码输入对话框进行了交互，因此相同的内存区域将以相同的XOR值重用，这使我们可以轻松访问编码缓冲区来创建漏洞利用。 <br><br><h1> 挑战赛 </h1><br> 要为1Password 4创建可靠的漏洞利用程序，您需要更清晰地了解程序的工作流程如何处理主密码。 使用上述工具，我们构建了输出数据图（请参见下图）。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/453/5e4/763/4535e476369c9114c5fd62f1ec7480c6.png"><br><br> 该图使您更容易理解在何处以及涉及哪些库，以便可靠地标识内存中可以检索主密码的区域。 <br><br><h1> 利用 </h1><br> 我们现在有什么？ 我们有一个锁定的存储空间，并且在内存中的某个位置存储了混淆的密码，因为该程序无法正确清理内存。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a77/ac0/8f1/a77ac08f195de46d8e546b1f43ab1415.png"></div><br><br> 要检索它，您需要调用1Password 4中的过程，该过程将启动'RtlRunEncodeUnicodeString'和'RtlRunDecodeUnicodeString'。 因此，它将显示带有编码主密码的存储缓冲区的位置。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d47/547/aec/d47547aecf337b3c33206ddbe3bbad97.png"></div><br>  <i><font color="gray">具有模糊主密码的存储区</font></i> <br><br> 没有此缓冲区，将不得不陷入内部过程，Windows控件和相关内存管理机制的深渊。 也许通过这种分析可以很容易地找到一个缓冲区，但是我们并没有这样做。 <br><br> 看来，调用“ RtlRunEncodeUnicodeString”和“ RtlRunDecodeUnicodeString”的唯一方法是在对话框的字符中输入主密码。 这样我们就得到了所需的缓冲区。 但是我们不知道密码的长度。 <br><br> 我们通过拦截访问缓冲区第一个字符的代码来解决此问题，从而阻止了更改尝试。 该例程位于comctl32的控制消息循环中，该循环处理相应元素的缓冲区控制。 调用偏移量为0x70191731的“ memmove”会用输入的字符覆盖缓冲区： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/676/8a9/351/6768a9351ed39fe85a98ca9d01368586.png"></div><br>  <i><font color="gray">（副作用：突出显示的行（黄色）将更新整个密码行）</font></i> <br><br> 现在，我们终于拥有了创建漏洞所需的一切。 以下步骤将使我们能够提取主密码： <br><br><ol><li> 钩“ memmove”以防止覆盖主密码的第一个字节。 <br></li><li> 钩“ RtlRunEncodeUnicodeString”以获取混淆的主密码缓冲区的位置。 <br></li><li> 挂钩“ RtlRunDecodeUnicodeString”以访问在上一步中获得的混淆缓冲区。 <br></li><li> 在密码输入字段中输入字符并拒绝步骤1（保存整个主密码），将步骤2重定向到步骤3以对混淆后的主密码进行解码。 </li></ol><br> 要执行所有这些操作，请为所有这些钩子使用处理程序代码创建一个DLL。 该库嵌入在1Password 4进程中，通过启动我们可以拦截的memmove，RtlRunEncodeUnicodeString和RtlRunDecodeUnicodeString步骤，并通过魔术恢复被混淆的主密码，将一个字符发送到主密码对话框。 大多数魔术都发生在DetourRtlRunEncodeUnicodeString中，这是'RtlRunEncodeUnicodeString'函数的钩子，如下所示： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2c5/652/36e/2c565236ec1efb158e586bd603d0a908.png"></div><br><br> 这带给我们最终结果：使用Windows API使用的错误程序解锁任何版本的锁定存储库1Password 4： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0ad/2c0/d81/0ad2c0d817dd2dc75a942e5b2bd5b974.gif"><br><br><h1> 总结 </h1><br> 当我们第一次深入研究1Password 4的内部时，我们期望会遇到某种复杂的安全系统，并且期望所有敏感信息都将从内存中清除，就像PBKDF2过程和使用主密码的其他区域中那样。 相应的条目也被清除。 但是，由于疏忽，密码字段被视为带有隐藏密码的标准Windows API控件，这会破坏1Password 4的安全性。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN441166/">https://habr.com/ru/post/zh-CN441166/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN441150/index.html">通过编写最简单的Java Web服务器首次介绍HTTP协议</a></li>
<li><a href="../zh-CN441152/index.html">与外部服务集成时如何最大程度地减少错误：在线经纪人的经验</a></li>
<li><a href="../zh-CN441154/index.html">Java 11的十一颗隐藏的珍珠</a></li>
<li><a href="../zh-CN441158/index.html">伦理如何成为最昂贵的硅谷问题，而哲学如何成为其最实际的解决方案</a></li>
<li><a href="../zh-CN441160/index.html">如何学习确定何时说不</a></li>
<li><a href="../zh-CN441168/index.html">QUIC数据通道：第一步</a></li>
<li><a href="../zh-CN441172/index.html">2018年3D打印市场如何增长以及对业务意味着什么</a></li>
<li><a href="../zh-CN441174/index.html">OOP死了，OOP万岁</a></li>
<li><a href="../zh-CN441180/index.html">多云，星空下有无障碍广告的机会</a></li>
<li><a href="../zh-CN441182/index.html">用于检测网络DDoS攻击的机器综合方法。 第二部分</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>