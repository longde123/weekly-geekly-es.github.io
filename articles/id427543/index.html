<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👇🏿 🤜🏽 🖱️ Validasi dalam Aplikasi Java 🤤 📒 💭</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Teks ini dikhususkan untuk berbagai pendekatan validasi data: perangkap apa yang mungkin muncul dalam suatu proyek dan metode serta teknologi apa yang...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Validasi dalam Aplikasi Java</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/haulmont/blog/427543/"><p>  <em>Teks ini dikhususkan untuk berbagai pendekatan validasi data: perangkap apa yang mungkin muncul dalam suatu proyek dan metode serta teknologi apa yang harus diikuti ketika memvalidasi data dalam aplikasi Java.</em> </p><br><p><img src="https://habrastorage.org/webt/cj/yc/yj/cjycyj3zf_l1ai9ch_vsgzisstk.png" alt="Validasi"></p><br><p>  Saya sering melihat proyek yang pembuatnya tidak repot-repot memilih pendekatan untuk validasi data.  Tim bekerja pada proyek di bawah tekanan luar biasa dalam bentuk tenggat waktu dan persyaratan yang tidak jelas, dan sebagai hasilnya, mereka tidak punya waktu untuk validasi yang akurat dan konsisten.  Oleh karena itu, kode validasinya tersebar di mana-mana: dalam cuplikan Javascript, pengontrol layar, dalam nampan logika bisnis, entitas domain, pemicu, dan batasan basis data.  Kode ini penuh dengan pernyataan if-else, ia mengeluarkan banyak pengecualian, dan mencoba mencari tahu di mana potongan data tertentu ini divalidasi di sana ... Akibatnya, ketika proyek berkembang, menjadi sulit dan mahal untuk memenuhi persyaratan (seringkali cukup membingungkan), dan keseragaman pendekatan validasi data. </p><br><p>  Jadi apakah ada cara sederhana dan elegan untuk memvalidasi data?  Adakah cara yang akan melindungi kita dari dosa ketidakterbacaan, cara yang akan menyatukan semua logika validasi, dan mana yang telah diciptakan untuk kita oleh pengembang kerangka Java yang populer? </p><br><p>  Ya, ada cara seperti itu. </p><a name="habracut"></a><br><p>  Bagi kami, pengembang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">platform CUBA</a> , sangat penting bagi Anda untuk menggunakan praktik terbaik.  Kami percaya bahwa kode validasi harus: </p><br><ol><li>  Dapat digunakan kembali dan ikuti prinsip KERING; </li><li>  Alami dan dapat dimengerti; </li><li>  Ditempatkan di tempat yang diharapkan pengembang untuk melihatnya; </li><li>  Mampu memverifikasi data dari berbagai sumber: antarmuka pengguna, panggilan SOAP, REST, dll. </li><li>  Bekerja di lingkungan multi-utas tanpa masalah; </li><li>  Dipanggil di dalam aplikasi secara otomatis, tanpa perlu menjalankan pemeriksaan secara manual; </li><li>  Untuk memberi pengguna pesan yang jelas dan dilokalkan dalam kotak dialog ringkas; </li><li>  Ikuti standar. </li></ol><br><p>  Mari kita lihat bagaimana ini dapat diimplementasikan menggunakan contoh aplikasi yang ditulis menggunakan kerangka Platform CUBA.  Namun, karena CUBA didasarkan pada Spring dan EclipseLink, sebagian besar teknik yang digunakan di sini akan bekerja pada platform Java lain yang mendukung spesifikasi JPA dan Validasi Bean. </p><br><h2 id="validaciya-s-ispolzovaniem-database-constraints">  Validasi menggunakan batasan basis data </h2><br><p> Mungkin cara yang paling umum dan jelas untuk memvalidasi data adalah dengan menggunakan batasan di tingkat basis data, misalnya, bendera yang diperlukan (untuk bidang yang nilainya tidak boleh kosong), panjang string, indeks unik, dll.  Metode ini paling cocok untuk aplikasi perusahaan, karena jenis perangkat lunak ini biasanya sangat fokus pada pemrosesan data.  Namun, bahkan di sini pengembang sering membuat kesalahan dengan menetapkan batas secara terpisah untuk setiap tingkat aplikasi.  Paling sering, alasannya terletak pada distribusi tanggung jawab antara pengembang. </p><br><p>  Pertimbangkan sebuah contoh yang sebagian besar dari kita tahu, beberapa bahkan dari pengalaman kita sendiri ... Jika spesifikasi mengatakan bahwa harus ada 10 karakter di bidang nomor paspor, sangat mungkin bahwa ini akan diperiksa oleh semua orang: arsitek DB di DDL, pengembang backend di Entitas terkait dan Layanan REST, dan akhirnya, pengembang UI langsung di sisi klien.  Kemudian persyaratan ini berubah, dan bidang bertambah menjadi 15 karakter.  Devops mengubah nilai kendala dalam database, tetapi tidak ada yang berubah bagi pengguna, karena di sisi klien batasannya sama ... </p><br><p>  Pengembang mana pun tahu cara menghindari masalah ini - validasi harus terpusat!  Dalam CUBA, validasi tersebut ditemukan dalam anotasi entitas JPA.  Berdasarkan meta-informasi ini, CUBA Studio akan menghasilkan skrip DDL yang benar dan menerapkan validator sisi klien yang sesuai. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/118/a16/f17/118a16f1705740a1676eb2c0ea164ef4.png" alt="Contoh transisi"></p><br><p>  Jika anotasi berubah, CUBA akan memperbarui skrip DDL dan menghasilkan skrip migrasi, sehingga saat berikutnya Anda menggunakan proyek, pembatasan berbasis JPA baru akan berlaku baik di antarmuka maupun di basis data aplikasi. </p><br><p> Terlepas dari kesederhanaan dan implementasi di tingkat basis data, yang memberikan keandalan mutlak untuk metode ini, ruang lingkup penjelasan JPA terbatas pada kasus paling sederhana yang dapat dinyatakan dalam standar DDL dan tidak termasuk pemicu basis data atau prosedur tersimpan.  Jadi, kendala berbasis JPA dapat membuat bidang entitas unik atau wajib atau menetapkan panjang kolom maksimum.  Anda bahkan dapat menetapkan batasan unik pada kombinasi kolom menggunakan anotasi <code>@UniqueConstraint</code> .  Tapi mungkin itu saja. </p><br><p>  Meskipun demikian, dalam kasus yang membutuhkan logika validasi yang lebih kompleks, seperti memeriksa bidang untuk nilai minimum / maksimum, memvalidasi dengan ekspresi reguler, atau melakukan pemeriksaan kustom khusus untuk aplikasi Anda saja, pendekatan yang dikenal sebagai <strong>"Validasi Bean"</strong> diterapkan . </p><br><h2 id="bean-validation">  Validasi kacang </h2><br><p>  Semua orang tahu bahwa praktik yang baik untuk mengikuti standar memiliki siklus hidup yang panjang, yang efektivitasnya telah terbukti di ribuan proyek.  Java Bean Validation adalah pendekatan yang didokumentasikan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JSR 380, 349, dan 303</a> dan aplikasinya: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Hibernate Validator</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Apache BVal</a> . </p><br><p>  Meskipun pendekatan ini akrab bagi banyak pengembang, ini sering dianggap remeh.  Ini adalah cara mudah untuk menanamkan validasi data bahkan dalam proyek lawas, yang memungkinkan Anda membangun validasi dengan jelas, sederhana, andal, dan sedekat mungkin dengan logika bisnis. </p><br><p>  Menggunakan Validasi Kacang memberikan banyak keuntungan bagi proyek: </p><br><ul><li>  Logika validasi terletak di sebelah area subjek: definisi pembatasan untuk bidang dan metode nampan terjadi secara alami dan benar-benar berorientasi objek. </li><li>  Standar Validasi Bean memberi kita puluhan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">anotasi validasi langsung dari kotak</a> , misalnya: <code>@NotNull</code> , <code>@Size</code> , <code>@Min</code> , <code>@Max</code> , <code>@Pattern</code> , <code>@Email</code> , <code>@Past</code> , tidak cukup standar <code>@URL</code> , <code>@Length</code> , <code>@Length</code> paling kuat dan banyak lainnya . </li><li>  Standar tidak membatasi kita pada anotasi siap pakai dan memungkinkan kita untuk membuat anotasi kita sendiri.  Kami juga dapat membuat anotasi baru dengan menggabungkan beberapa lainnya, atau mendefinisikannya menggunakan kelas Java yang terpisah sebagai validator. <br>  Misalnya, dalam contoh di atas, kita dapat mengatur anotasi tingkat kelas <code>@ValidPassportNumber</code> untuk memverifikasi bahwa nomor paspor cocok dengan format tergantung pada nilai bidang <code>country</code> . </li><li>  Kendala dapat diatur tidak hanya pada bidang atau kelas, tetapi juga pada metode dan parameternya.  Pendekatan ini disebut <strong>"validasi berdasarkan kontrak"</strong> dan akan dibahas sedikit kemudian. </li></ul><br><p>  Ketika pengguna mengirimkan informasi yang dimasukkan, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Platform CUBA</a> <em>(seperti beberapa kerangka kerja lainnya)</em> memulai Validasi Bean secara otomatis, sehingga secara instan memberikan pesan kesalahan jika validasi gagal, dan kami tidak perlu menjalankan validator bin secara manual. </p><br><p>  Mari kita kembali ke contoh dengan nomor paspor, tetapi kali ini kami akan menambahkannya dengan beberapa batasan entitas Orang: </p><br><ul><li>  Bidang <code>name</code> harus 2 karakter atau lebih dan harus valid.  (Seperti yang Anda lihat, regexp tidak sederhana, tetapi "Charles Ogier de Batz de Castelmore Comte d'Artagnan" akan lulus ujian, tetapi "R2D2" tidak akan); </li><li>  <code>height</code> (tinggi) harus dalam interval berikut: <code>0 &lt; height &lt;= 300</code> cm; </li><li>  Bidang <code>email</code> harus berisi string yang cocok dengan format email yang benar. </li></ul><br><p>  Dengan semua cek ini, kelas Person akan terlihat seperti ini: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Listeners</span></span>(<span class="hljs-string"><span class="hljs-string">"passportnumber_PersonEntityListener"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@NamePattern</span></span>(<span class="hljs-string"><span class="hljs-string">"%s|name"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@Table</span></span>(name = <span class="hljs-string"><span class="hljs-string">"PASSPORTNUMBER_PERSON"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@Entity</span></span>(name = <span class="hljs-string"><span class="hljs-string">"passportnumber$Person"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@ValidPassportNumber</span></span>(groups = {Default.class, UiCrossFieldChecks.class}) <span class="hljs-meta"><span class="hljs-meta">@FraudDetectionFlag</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StandardEntity</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> serialVersionUID = -<span class="hljs-number"><span class="hljs-number">9150857881422152651L</span></span>; <span class="hljs-meta"><span class="hljs-meta">@Pattern</span></span>(message = <span class="hljs-string"><span class="hljs-string">"Bad formed person name: ${validatedValue}"</span></span>, regexp = <span class="hljs-string"><span class="hljs-string">"^[AZ][az]*(\\s(([az]{1,3})|(([az]+\\')?[AZ][az]*)))*$"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@Length</span></span>(min = <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-meta"><span class="hljs-meta">@NotNull</span></span> <span class="hljs-meta"><span class="hljs-meta">@Column</span></span>(name = <span class="hljs-string"><span class="hljs-string">"NAME"</span></span>, nullable = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> String name; <span class="hljs-meta"><span class="hljs-meta">@Email</span></span>(message = <span class="hljs-string"><span class="hljs-string">"Email address has invalid format: ${validatedValue}"</span></span>, regexp = <span class="hljs-string"><span class="hljs-string">"^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@Column</span></span>(name = <span class="hljs-string"><span class="hljs-string">"EMAIL"</span></span>, length = <span class="hljs-number"><span class="hljs-number">120</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> String email; <span class="hljs-meta"><span class="hljs-meta">@DecimalMax</span></span>(message = <span class="hljs-string"><span class="hljs-string">"Person height can not exceed 300 centimeters"</span></span>, value = <span class="hljs-string"><span class="hljs-string">"300"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@DecimalMin</span></span>(message = <span class="hljs-string"><span class="hljs-string">"Person height should be positive"</span></span>, value = <span class="hljs-string"><span class="hljs-string">"0"</span></span>, inclusive = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) <span class="hljs-meta"><span class="hljs-meta">@Column</span></span>(name = <span class="hljs-string"><span class="hljs-string">"HEIGHT"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> BigDecimal height; <span class="hljs-meta"><span class="hljs-meta">@NotNull</span></span> <span class="hljs-meta"><span class="hljs-meta">@Column</span></span>(name = <span class="hljs-string"><span class="hljs-string">"COUNTRY"</span></span>, nullable = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> Integer country; <span class="hljs-meta"><span class="hljs-meta">@NotNull</span></span> <span class="hljs-meta"><span class="hljs-meta">@Column</span></span>(name = <span class="hljs-string"><span class="hljs-string">"PASSPORT_NUMBER"</span></span>, nullable = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, length = <span class="hljs-number"><span class="hljs-number">15</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> String passportNumber; ... }</code> </pre> <br><p>  <a href="">Person.java</a> </p><br><p>  Saya percaya penggunaan anotasi seperti <code>@NotNull</code> , <code>@DecimalMin</code> , <code>@Length</code> , <code>@Pattern</code> dan sejenisnya cukup jelas dan tidak memerlukan komentar.  Mari kita lihat lebih dekat implementasi dari anotasi <code>@ValidPassportNumber</code> . </p><br><p>  <code>@ValidPassportNumber</code> kami yang baru memeriksa apakah <code>Person#passportNumber</code> cocok dengan pola regexp untuk setiap negara yang ditentukan oleh bidang <code>Person#country</code> . </p><br><p>  Pertama, mari kita lihat dokumentasi (manual <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CUBA</a> atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Hibernate</a> baik-baik saja), sesuai dengan itu, kita perlu menandai kelas kita dengan anotasi baru ini dan meneruskan parameter <code>groups</code> ke sana, di mana <code>UiCrossFieldChecks.class</code> berarti bahwa validasi ini harus dijalankan di cross- validasi - setelah memeriksa semua bidang individual, dan <code>Default.class</code> menyimpan batasan dalam grup validasi default. </p><br><p>  Deskripsi anotasi terlihat seperti ini: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Target</span></span>(ElementType.TYPE) <span class="hljs-meta"><span class="hljs-meta">@Retention</span></span>(RetentionPolicy.RUNTIME) <span class="hljs-meta"><span class="hljs-meta">@Constraint</span></span>(validatedBy = ValidPassportNumberValidator.class) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-meta"><span class="hljs-meta">@interface</span></span> ValidPassportNumber { <span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">message</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">default</span></span></span><span class="hljs-function"> "Passport number is not valid"</span></span>; Class&lt;?&gt;[] groups() <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> {}; Class&lt;? extends Payload&gt;[] payload() <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> {}; }</code> </pre> <br><p>  <a href="">ValidPassportNumber.java</a> </p><br><p>  Di sini <code>@Target(ElementType.TYPE)</code> mengatakan bahwa tujuan dari anotasi runtime ini adalah kelas, dan <code>@Constraint(validatedBy = … )</code> menentukan bahwa validasi dilakukan oleh kelas <code>ValidPassportNumberValidator</code> yang mengimplementasikan antarmuka <code>ConstraintValidator&lt;...&gt;</code> .  Kode validasi itu sendiri dalam metode <code>isValid(...)</code> , yang melakukan verifikasi aktual dengan cara yang cukup mudah: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ValidPassportNumberValidator</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ConstraintValidator</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ValidPassportNumber</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initialize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ValidPassportNumber constraint)</span></span></span><span class="hljs-function"> </span></span>{ } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isValid</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Person person, ConstraintValidatorContext context)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (person == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (person.country == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || person.passportNumber == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> doPassportNumberFormatCheck(person.getCountry(), person.getPassportNumber()); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doPassportNumberFormatCheck</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CountryCode country, String passportNumber)</span></span></span><span class="hljs-function"> </span></span>{ ... } }</code> </pre> <br><p>  <a href="">ValidPassportNumberValidator.java</a> </p><br><p>  Itu saja.  Dengan Platform CUBA, kami tidak perlu menulis apa pun kecuali sebaris kode yang akan membuat validasi khusus kami berfungsi dan memberikan pesan kesalahan pengguna. <br>  Tidak ada yang rumit, bukan? </p><br><p>  Sekarang mari kita lihat bagaimana semuanya bekerja.  Di sini CUBA memiliki nishtyaki lainnya: tidak hanya menampilkan pesan kesalahan kepada pengguna, tetapi juga menyoroti di bidang merah yang tidak lulus validasi kacang: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/310/83d/b2b/31083db2b14d67d88de169542b59748a.png" alt="Representasi UI"></p><br><p>  Bukankah itu solusi yang elegan?  Anda mendapatkan tampilan kesalahan validasi yang memadai di UI dengan menambahkan hanya beberapa anotasi Java ke entitas area subjek. </p><br><p>  Untuk meringkas bagian ini, mari kita buat daftar singkat keuntungan Validasi Bean untuk entitas sekali lagi: </p><br><ol><li>  Itu bisa dimengerti dan dibaca; </li><li>  Memungkinkan Anda untuk mendefinisikan batasan nilai secara langsung di kelas entitas; </li><li>  Itu dapat disesuaikan dan ditambah; </li><li>  Diintegrasikan ke dalam ORM populer, dan cek dijalankan secara otomatis sebelum perubahan disimpan ke database; </li><li>  Beberapa kerangka kerja juga menjalankan validasi kacang secara otomatis ketika pengguna mengirim data ke UI (dan jika tidak, mudah untuk memanggil antarmuka <code>Validator</code> secara manual); </li><li>  Validasi Bean adalah standar yang diakui dan penuh dengan dokumentasi di Internet. </li></ol><br><p>  Tetapi bagaimana jika Anda perlu menetapkan batasan pada metode, konstruktor atau alamat REST untuk memvalidasi data yang berasal dari sistem eksternal?  Atau jika Anda perlu secara deklaratif memeriksa nilai-nilai parameter metode, tanpa menulis kode membosankan dengan banyak kondisi if-else di setiap metode yang diuji? </p><br><p>  Jawabannya sederhana: Validasi Bean juga berlaku untuk metode! </p><br><h2 id="validation-by-contract">  Validasi berdasarkan kontrak </h2><br><p>  Kadang-kadang perlu untuk melampaui validasi keadaan model data.  Banyak metode dapat mengambil manfaat dari validasi otomatis parameter dan nilai pengembalian.  Ini mungkin diperlukan tidak hanya untuk memeriksa data yang masuk ke alamat REST atau SOAP, tetapi juga dalam kasus-kasus ketika kita ingin menuliskan prasyarat dan postkondisi panggilan metode untuk memastikan bahwa data yang dimasukkan diverifikasi sebelum tubuh metode dieksekusi, atau bahwa nilai pengembalian ada dalam kisaran yang diharapkan, atau misalnya, kita hanya perlu secara deskriptif mendeskripsikan rentang nilai dari parameter input untuk meningkatkan keterbacaan kode. </p><br><p>  Menggunakan validasi kacang, pembatasan dapat diterapkan pada parameter input dan mengembalikan nilai metode dan konstruktor untuk memeriksa prasyarat dan postkondisi panggilan mereka di kelas Java apa pun.  Jalur ini memiliki beberapa keunggulan dibandingkan metode tradisional untuk memeriksa validitas parameter dan mengembalikan nilai: </p><br><ol><li>  Tidak perlu melakukan pemeriksaan secara manual dalam gaya imperatif (misalnya, dengan melempar <code>IllegalArgumentException</code> dan sejenisnya).  Anda dapat mendefinisikan batasan secara deklaratif, dan membuat kode lebih mudah dipahami dan ekspresif; </li><li>  Kendala dapat dikonfigurasi, digunakan kembali, dan dikonfigurasi: Anda tidak perlu menulis logika validasi untuk setiap pemeriksaan.  Lebih sedikit kode berarti lebih sedikit bug. </li><li>  Jika kelas, nilai pengembalian metode, atau parameternya ditandai dengan anotasi <code>@Validated</code> , maka pemeriksaan akan secara otomatis dilakukan oleh platform dengan setiap pemanggilan metode. </li><li>  Jika executable ditandai dengan anotasi <code>@Documented</code> , prekondisi dan postkondisinya akan dimasukkan dalam JavaDoc yang dihasilkan. </li></ol><br><p>  Menggunakan <strong>'validasi kontrak'</strong> kami mendapatkan kode yang jelas, ringkas dan mudah dipelihara. </p><br><p>  Sebagai contoh, mari kita lihat antarmuka pengontrol REST aplikasi CUBA.  Antarmuka <code>PersonApiService</code> memungkinkan Anda untuk mendapatkan daftar orang dari basis data menggunakan metode <code>getPersons()</code> dan menambahkan orang baru menggunakan <code>addNewPerson(...)</code> . </p><br><p>  Dan jangan lupa bahwa validasi kacang diwariskan!  Dengan kata lain, jika kita memberi anotasi pada kelas, atau bidang, atau metode tertentu, maka semua kelas yang mewarisi kelas ini atau mengimplementasikan antarmuka ini akan dikenakan anotasi validasi yang sama. </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Validated</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PersonApiService</span></span></span><span class="hljs-class"> </span></span>{ String NAME = <span class="hljs-string"><span class="hljs-string">"passportnumber_PersonApiService"</span></span>; <span class="hljs-meta"><span class="hljs-meta">@NotNull</span></span> <span class="hljs-meta"><span class="hljs-meta">@Valid</span></span> <span class="hljs-meta"><span class="hljs-meta">@RequiredView</span></span>(<span class="hljs-string"><span class="hljs-string">"_local"</span></span>) <span class="hljs-function"><span class="hljs-function">List&lt;Person&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPersons</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addNewPerson</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( @NotNull @Length(min = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span><span class="hljs-function"><span class="hljs-params">, max = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">255</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> @</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Pattern</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(message = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"Bad formed person name: ${validatedValue}"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, regexp = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"^[AZ][az]*(\\s(([az]{1,3})|(([az]+\\')?[AZ][az]*)))*$"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> String name, @</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DecimalMax</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(message = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"Person height can not exceed 300 cm"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, value = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"300"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> @</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DecimalMin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(message = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"Person height should be positive"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, value = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"0"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, inclusive = </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">false</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> BigDecimal height, @NotNull CountryCode country, @NotNull String passportNumber )</span></span>; }</code> </pre> <br><p>  <a href="">PersonApiService.java</a> </p><br><p>  Apakah kode ini cukup jelas? <br>  _ (Kecuali untuk anotasi <code>@RequiredView(“_local”)</code> , khusus untuk Platform CUBA dan memverifikasi bahwa objek <code>Person</code> dikembalikan berisi semua bidang dari tabel <code>PASSPORTNUMBER_PERSON</code> ) ._ </p><br><p>  <code>@Valid</code> menetapkan bahwa setiap objek koleksi yang dikembalikan oleh metode <code>getPersons()</code> juga harus divalidasi terhadap pembatasan kelas <code>Person</code> . </p><br><p>  Dalam aplikasi CUBA, metode ini tersedia di alamat berikut: </p><br><ul><li>  / app / rest / v2 / services / passportnumber_PersonApiService / getPersons </li><li>  / app / rest / v2 / services / passportnumber_PersonApiService / addNewPerson </li></ul><br><p>  Mari kita buka aplikasi Postman dan pastikan validasi berfungsi sebagaimana mestinya: </p><br><p><img src="https://habrastorage.org/webt/qg/ra/qj/qgraqjsxfyeqqa6qcjf2pkf7tcq.png" alt="Aplikasi tukang pos"></p><br><p>  Seperti yang mungkin telah Anda perhatikan, nomor paspor tidak divalidasi dalam contoh di atas.  Ini karena bidang ini memerlukan pemeriksaan silang parameter metode <code>addNewPerson</code> , karena pilihan templat ekspresi reguler untuk memvalidasi <code>passportNumber</code> tergantung pada nilai bidang <code>country</code> .  Validasi silang ini adalah analog lengkap dari pembatasan entitas tingkat kelas! </p><br><p>  Validasi silang parameter didukung oleh JSR 349 ​​dan 380. Anda dapat membaca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi hibernate</a> untuk mempelajari cara menerapkan validasi silang Anda sendiri atas metode kelas / antarmuka. </p><br><h2 id="za-predelami-bean-validation">  Validasi kacang luar </h2><br><p>  Tidak ada kesempurnaan di dunia, jadi validasi kacang memiliki kekurangan dan keterbatasannya: </p><br><ol><li>  Terkadang kita hanya perlu memeriksa keadaan grafik objek yang kompleks sebelum menyimpan perubahan ke database.  Misalnya, Anda perlu memastikan bahwa semua elemen pesanan pelanggan ditempatkan dalam satu paket.  Ini adalah operasi yang agak sulit, dan untuk melakukannya setiap kali pengguna menambahkan item baru ke pesanan bukanlah ide yang baik.  Oleh karena itu, pemeriksaan semacam itu mungkin diperlukan hanya sekali: sebelum menyimpan objek <code>Order</code> dan <code>OrderItem</code> dalam database. </li><li>  Beberapa cek perlu dilakukan dalam suatu transaksi.  Misalnya, sistem toko elektronik harus memeriksa apakah ada cukup banyak salinan barang untuk memenuhi pesanan sebelum memasukkannya ke database.  Cek semacam itu hanya dapat dilakukan di dalam transaksi, karena  Sistem ini multi-threaded dan jumlah barang dalam persediaan dapat berubah setiap saat. </li></ol><br><p>  Platform CUBA menawarkan dua mekanisme validasi data pra-komitmen yang disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">entitas pendengar</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pendengar transaksi</a> .  Mari kita pertimbangkan secara lebih detail. </p><br><h3 id="entity-listemers">  Listemer entitas </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pendengar entitas di CUBA</a> sangat mirip dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>PreInsertEvent</code> , <code>PreUpdateEvent</code> , dan <code>PredDeleteEvent</code></a> yang ditawarkan JPA kepada pengembang.  Kedua mekanisme memungkinkan Anda untuk memeriksa objek entitas sebelum dan sesudah mereka disimpan dalam database. </p><br><p>  Di CUBA, mudah untuk membuat dan menghubungkan pendengar entitas, untuk ini Anda perlu dua hal: </p><br><ol><li>  Buat kacang yang dikelola yang mengimplementasikan salah satu antarmuka pendengar entitas.  3 antarmuka penting untuk validasi: <br>  <code>BeforeDeleteEntityListener&lt;T&gt;</code> , <br>  <code>BeforeInsertEntityListener&lt;T&gt;</code> , <br> <code>BeforeUpdateEntityListener&lt;T&gt;</code> </li> <li>  Tambahkan anotasi <code>@Listeners</code> ke objek entitas yang ingin Anda lacak. </li></ol><br><p>  Dan itu saja. </p><br><p>  Dibandingkan dengan standar JPA (JSR 338, Bagian 3.5), antarmuka pendengar Platform CUBA diketik, sehingga Anda tidak perlu memberikan argumen tipe <code>Object</code> ke tipe entitas untuk mulai bekerja dengannya.  Platform CUBA menambahkan entitas terkait atau penelepon EntityManager kemampuan untuk memuat dan memodifikasi entitas lain.  Semua perubahan ini juga akan memanggil pendengar entitas yang sesuai. </p><br><p>  Platform CUBA juga mendukung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"penghapusan lunak"</a> , sebuah pendekatan di mana alih-alih menghapus catatan dari database, mereka hanya ditandai sebagai terhapus dan menjadi tidak dapat diakses untuk penggunaan normal.  Jadi, untuk penghapusan lunak, platform memanggil pendengar <code>AfterDeleteEntityListener</code> / <code>AfterDeleteEntityListener</code> , sementara implementasi standar akan memanggil <code>PostUpdate</code> <code>PreUpdate</code> / <code>PostUpdate</code> . </p><br><p>  Mari kita lihat sebuah contoh.  Di sini, kacang pendengar peristiwa terhubung ke kelas entitas dengan hanya satu baris kode: penjelasan <code>@Listeners</code> , yang mengambil nama kelas pendengar: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Listeners</span></span>(<span class="hljs-string"><span class="hljs-string">"passportnumber_PersonEntityListener"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@NamePattern</span></span>(<span class="hljs-string"><span class="hljs-string">"%s|name"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@Table</span></span>(name = <span class="hljs-string"><span class="hljs-string">"PASSPORTNUMBER_PERSON"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@Entity</span></span>(name = <span class="hljs-string"><span class="hljs-string">"passportnumber$Person"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@ValidPassportNumber</span></span>(groups = {Default.class, UiCrossFieldChecks.class}) <span class="hljs-meta"><span class="hljs-meta">@FraudDetectionFlag</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StandardEntity</span></span></span><span class="hljs-class"> </span></span>{ ... }</code> </pre> <br><p>  <a href="">Person.java</a> </p><br><p>  Implementasi pendengar itu sendiri terlihat seperti ini: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/** * Checks that there are no other persons with the same * passport number and country code * Ignores spaces in the passport number for the check. * So numbers "12 45 768007" and "1245 768007" and "1245768007" * are the same for the validation purposes. */</span></span> <span class="hljs-meta"><span class="hljs-meta">@Component</span></span>(<span class="hljs-string"><span class="hljs-string">"passportnumber_PersonEntityListener"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PersonEntityListener</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BeforeDeleteEntityListener</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class">&gt;, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BeforeInsertEntityListener</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class">&gt;, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BeforeUpdateEntityListener</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onBeforeDelete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Person person, EntityManager entityManager)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!checkPassportIsUnique(person.getPassportNumber(), person.getCountry(), entityManager)) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ValidationException( <span class="hljs-string"><span class="hljs-string">"Passport and country code combination isn't unique"</span></span>); } } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onBeforeInsert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Person person, EntityManager entityManager)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// use entity argument to validate the Person object // entityManager could be used to access database // if you need to check the data // throw ValidationException object if validation check failed if (!checkPassportIsUnique(person.getPassportNumber(), person.getCountry(), entityManager)) throw new ValidationException( "Passport and country code combination isn't unique"); } @Override public void onBeforeUpdate(Person person, EntityManager entityManager) { if (!checkPassportIsUnique(person.getPassportNumber(), person.getCountry(), entityManager)) throw new ValidationException( "Passport and country code combination isn't unique"); } ... }</span></span></code> </pre> <br><p>  <a href="">PersonEntityListener.java</a> </p><br><p>  Pendengar entitas adalah pilihan yang cocok jika: </p><br><ul><li>  Diperlukan untuk memeriksa data di dalam transaksi sebelum objek entitas disimpan dalam database; </li><li>  Diperlukan untuk memeriksa data dalam database selama proses validasi, misalnya, untuk memeriksa bahwa ada cukup stok produk untuk menerima pesanan; </li><li>  Anda perlu melihat tidak hanya pada objek entitas, seperti <code>Order</code> , tetapi juga pada entitas terkait, misalnya, <code>OrderItems</code> untuk entitas <code>Order</code> ; </li><li>  Kami ingin melacak operasi memasukkan, memperbarui, atau menghapus hanya untuk kelas entitas tertentu, misalnya, hanya untuk <code>OrderItem</code> <code>Order</code> dan <code>OrderItem</code> , dan kami tidak perlu memeriksa perubahan di kelas entitas lain selama transaksi. </li></ul><br><h3 id="transaction-listeners">  Pendengar transaksi </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pendengar transaksi CUBA</a> juga bertindak dalam konteks transaksi, tetapi, dibandingkan dengan pendengar entitas, mereka dipanggil untuk setiap transaksi basis data. </p><br><p>  Ini memberi mereka kekuatan super: </p><br><ul><li>  tidak ada yang bisa luput dari perhatian mereka. </li></ul><br><p>  Tetapi hal yang sama ditentukan oleh kekurangan mereka: </p><br><ul><li>  mereka lebih sulit untuk ditulis; </li><li>  mereka dapat secara signifikan mengurangi kinerja; </li><li>  Mereka harus ditulis dengan sangat hati-hati: bug di pendengar transaksi dapat mengganggu bahkan dengan pemuatan awal aplikasi. </li></ul><br><p>  Jadi, pendengar transaksi adalah solusi yang baik ketika Anda perlu memeriksa berbagai jenis entitas menggunakan algoritma yang sama, misalnya, memeriksa semua data untuk penipuan cyber dengan layanan tunggal yang melayani semua objek bisnis Anda. </p><br><p><img src="https://habrastorage.org/webt/km/v9/co/kmv9cougmokpc3opta_dfk4egqk.jpeg" alt="Anda tidak akan lulus!"></p><br><p>  Lihatlah contoh yang memeriksa untuk melihat apakah entitas memiliki anotasi <code>@FraudDetectionFlag</code> , dan, jika ada, memulai detektor penipuan.  Saya ulangi: perlu diingat bahwa metode ini dipanggil pada sistem <strong>sebelum melakukan setiap transaksi database</strong> , jadi kode harus mencoba memeriksa objek sesedikit mungkin. </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Component</span></span>(<span class="hljs-string"><span class="hljs-string">"passportnumber_ApplicationTransactionListener"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApplicationTransactionListener</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BeforeCommitTransactionListener</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Logger log = LoggerFactory.getLogger(ApplicationTransactionListener.class); <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">beforeCommit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(EntityManager entityManager, Collection&lt;Entity&gt; managedEntities)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Entity entity : managedEntities) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (entity <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> StandardEntity &amp;&amp; !((StandardEntity) entity).isDeleted() &amp;&amp; entity.getClass().isAnnotationPresent(FraudDetectionFlag.class) &amp;&amp; !fraudDetectorFeedAndFastCheck(entity)) { logFraudDetectionFailure(log, entity); String msg = String.format( <span class="hljs-string"><span class="hljs-string">"Fraud detection failure in '%s' with id = '%s'"</span></span>, entity.getClass().getSimpleName(), entity.getId()); <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ValidationException(msg); } } } ... }</code> </pre> <br><p>  <a href="">ApplicationTransactionListener.java</a> </p><br><p>  Untuk menjadi pendengar transaksi, kacang yang dikelola harus mengimplementasikan antarmuka <code>BeforeCommitTransactionListener</code> dan metode <code>beforeCommit</code> .  Pendengar transaksi mengikat secara otomatis ketika aplikasi dimulai.  CUBA mendaftarkan semua kelas yang menerapkan <code>BeforeCommitTransactionListener</code> atau <code>AfterCompleteTransactionListener</code> sebagai pendengar transaksi. </p><br><h2 id="zaklyuchenie">  Kesimpulan </h2><br><p>  Validasi Bean <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">(JPA 303, 349 dan 980)</a> adalah pendekatan yang dapat berfungsi sebagai dasar yang dapat diandalkan untuk 95% dari kasus validasi data yang dihadapi dalam proyek perusahaan.  Keuntungan utama dari pendekatan ini adalah bahwa sebagian besar logika validasi terkonsentrasi langsung di kelas model domain.  Karena itu, mudah ditemukan, mudah dibaca dan mudah dirawat.  Spring, CUBA, dan banyak perpustakaan lainnya mendukung standar-standar ini dan secara otomatis melakukan pemeriksaan validasi ketika menerima data pada lapisan UI, memanggil metode yang divalidasi, atau menyimpan data melalui ORM, sehingga validasi Bean sering terlihat seperti sulap dari sudut pandang pengembang. </p><br><p>  Beberapa pengembang perangkat lunak melihat validasi pada tingkat kelas model subjek sebagai tidak alami dan terlalu rumit, mereka mengatakan bahwa validasi data pada tingkat UI adalah strategi yang cukup efektif.  Namun, saya percaya bahwa banyak poin validasi dalam komponen dan pengontrol UI bukan pendekatan yang paling rasional.   ,  ,  ,    ,     ,       listener'        . </p><br><p>  ,  ,     : </p><br><ol><li> <strong>JPA </strong>   ,          ,        DDL. </li><li> <strong>Bean Validation</strong> — , , ,             .      ,       . </li><li> <strong>  </strong>  bean validation,    .        , ,   REST. </li><li> <strong>Entity listeners:</strong>      ,   Bean Validation,             . ,         .  Hibernate    . </li><li> <strong>Transaction listeners</strong> — ,   ,    .  ,      ,                    . </li></ol><br><p> <em>PS: ,              Java,      ,    ,    .</em> </p><br><hr><br><h2 id="poleznye-ssylki">  Tautan yang bermanfaat </h2><br><div class="spoiler">  <b class="spoiler_title">Teks tersembunyi</b> <div class="spoiler_text"><h3 id="standarty-i-ih-realizacii"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Standar dan implementasinya </font></font></h3><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JSR 303 - Validasi Bean 1.0</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JSR 349 ​​- Validasi Bean 1.1</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JSR 349, Spesifikasi Validasi Kacang</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JSR 380, Spesifikasi Validasi Kacang</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Referensi Hibernate Validator 5.4.2 (JSR 349)</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Referensi Hibernate Validator 6.10 (JSR 380)</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Hibernate Validator main page</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Hibernate validator 6.10 API docs</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">HV 6.10: Declaring and validating method constraints</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">HV 6.10: Cross parameter constraints</a> </li></ul><br><h3 id="biblioteki">  Perpustakaan </h3><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CUBA bean validation</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Validation cookbook for CUBA applications</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JavaFX with Bean Validation and CDI 2.0</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">OVal — non a JSR 303, 349, 380 compliant validation framework</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Spring, Java Bean Validation Basics</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Validation, Data Binding, and Type Conversion in Spring 4.1</a> </li></ul><br><h3 id="filosofiya-validacii-dannyh">    </h3><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Form validation best practices</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JavaFX Form Validation</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Blah vs Bean Validation: you missed the point like Mars Climate Orbiter</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Avoiding Many If Blocks For Validation Checking</a> </li></ul><br><h3 id="materialy-dlya-dalneyshego-chteniya">     </h3><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Validation cookbook for CUBA applications</a> </li></ul></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id427543/">https://habr.com/ru/post/id427543/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id427533/index.html">Jam tangan pintar yang tidak memerlukan pengisian daya. Apakah mereka banyak?</a></li>
<li><a href="../id427535/index.html">Kami meluncurkan pilihan solusi kolektif</a></li>
<li><a href="../id427537/index.html">Bagaimana menjadi manajer produk yang sukses: kursus di mana Anda dilatih sekarang</a></li>
<li><a href="../id427539/index.html">Eropa terakhir kali mengatur jam untuk waktu musim dingin</a></li>
<li><a href="../id427541/index.html">Amazon mendesak Bloomberg untuk membatalkan klaim profil tinggi dalam sebuah artikel tentang modul spyware Cina di server</a></li>
<li><a href="../id427545/index.html">Sistem informasi "diharapkan mendarat" untuk pendaftaran transportasi udara di Rusia</a></li>
<li><a href="../id427549/index.html">Laporan Club of Rome 2018, Bab 1.6: Wildcard Teknologi</a></li>
<li><a href="../id427551/index.html">Mengapa kita tidak bisa meninggalkan keyboard QWERTY</a></li>
<li><a href="../id427555/index.html">Hewan yang telah dipelajari manusia untuk dilacak menggunakan teknologi pengenalan wajah</a></li>
<li><a href="../id427557/index.html">Intisari acara TI pada bulan November (bagian satu)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>