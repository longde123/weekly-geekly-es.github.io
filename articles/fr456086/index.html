<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👏🏿 👨🏻‍⚖️ 🕴🏿 Storyboards iOS: analyse des avantages et des inconvénients, meilleures pratiques 🧗🏽 🚽 🌎</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Apple a créé des storyboards pour que les développeurs puissent visualiser les écrans des applications iOS et les relations entre eux. Tout le monde n...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Storyboards iOS: analyse des avantages et des inconvénients, meilleures pratiques</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mobileup/blog/456086/"><img src="https://habrastorage.org/webt/xx/gq/7w/xxgq7wvcgxjuew_bku55csqqvlu.png"><br><br>  Apple a créé des storyboards pour que les développeurs puissent visualiser les écrans des applications iOS et les relations entre eux.  Tout le monde n'a pas aimé cet outil, et pour cause.  J'ai rencontré de nombreux articles critiquant les storyboards, mais je n'ai pas trouvé d'analyse détaillée et impartiale de tous les avantages et inconvénients, en tenant compte des meilleures pratiques.  Finalement, j'ai décidé d'écrire moi-même un tel article. <br><a name="habracut"></a><br>  Je vais essayer d'analyser en détail les inconvénients et les avantages de l'utilisation de Storyboards.  Après les avoir pesés, vous pouvez prendre une décision significative s'ils sont nécessaires ou non dans le projet.  Cette décision n'a pas à être radicale.  Si, dans certaines situations, les storyboards créent des problèmes, dans d'autres, leur utilisation est justifiée: cela aide à résoudre efficacement les tâches et à écrire du code simple et facile à gérer. <br><br>  Commençons par les lacunes et analysons si toutes sont toujours pertinentes. <br><br><h2>  Inconvénients </h2><br><h3>  1. Les storyboards ont du mal à gérer les conflits lors de la fusion des modifications </h3><br>  Storyboard est un fichier XML.  Il est moins lisible que le code, il est donc plus difficile de résoudre les conflits.  Mais cette complexité dépend également de la façon dont nous travaillons avec le Storyboard.  Vous pouvez grandement simplifier votre tâche si vous suivez les règles ci-dessous: <br><br><ul><li> Ne mettez pas l'intégralité de l'interface utilisateur dans un seul Storyboard, divisez-le en plusieurs plus petits.  Cela permettra de répartir le travail sur les Storyboards entre les développeurs sans risque de conflits et, en cas d'inévitabilité, simplifiera la tâche de les résoudre. <br></li><li>  Si vous devez utiliser la même vue à plusieurs endroits, sélectionnez-la dans une sous-classe distincte avec son propre fichier Xib. <br></li><li>  Faites des commits plus souvent, car il est beaucoup plus facile de travailler avec des changements venant en petits morceaux. <br></li></ul><br>  L'utilisation de plusieurs storyboards au lieu d'un seul nous empêche de voir l'intégralité de la carte de l'application dans un seul fichier.  Mais souvent, cela n'est pas nécessaire - seule la partie spécifique sur laquelle nous travaillons en ce moment est suffisante. <br><br><h3>  2. Les storyboards empêchent la réutilisation du code </h3><br>  Si nous parlons d'utiliser uniquement des storyboards sans Xibs dans le projet, des problèmes se poseront sûrement.  Cependant, les Xibs, à mon avis, sont des éléments nécessaires lorsque vous travaillez avec des storyboards.  Grâce à eux, vous pouvez facilement créer des vues réutilisables, qui sont également pratiques pour travailler avec du code. <br><br>  Tout d'abord, créez la classe <code>XibView</code> base, qui est responsable du rendu de l' <code>UIView</code> créé dans Xib dans le Storyboard: <br><br><pre> <code class="swift hljs"><span class="hljs-meta"><span class="hljs-meta">@IBDesignable</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">XibView</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UIView</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> contentView: <span class="hljs-type"><span class="hljs-type">UIView?</span></span> }</code> </pre> <br>  <code>XibView</code> chargera l' <code>UIView</code> de Xib dans le <code>contentView</code> et l'ajoutera comme sa sous-vue.  Nous le faisons dans la méthode <code>setup()</code> : <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> view = loadViewFromNib() <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } view.frame = bounds view.autoresizingMask = [.flexibleWidth, .flexibleHeight] addSubview(view) contentView = view }</code> </pre> <br>  La méthode <code>loadViewFromNib()</code> ressemble à ceci: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loadViewFromNib</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">UIView?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> nibName = <span class="hljs-type"><span class="hljs-type">String</span></span>(describing: type(of: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> nib = <span class="hljs-type"><span class="hljs-type">UINib</span></span>(nibName: nibName, bundle: <span class="hljs-type"><span class="hljs-type">Bundle</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: <span class="hljs-type"><span class="hljs-type">XibView</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> nib.instantiate(withOwner: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, options: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>).first <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? <span class="hljs-type"><span class="hljs-type">UIView</span></span> }</code> </pre> <br>  La méthode <code>setup()</code> doit être appelée dans les initialiseurs: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(frame: <span class="hljs-type"><span class="hljs-type">CGRect</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(frame: frame) setup() } <span class="hljs-keyword"><span class="hljs-keyword">required</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>?(coder aDecoder: <span class="hljs-type"><span class="hljs-type">NSCoder</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(coder: aDecoder) setup() }</code> </pre> <br>  La classe <code>XibView</code> prête.  Les vues réutilisées, dont l'apparence est rendue dans un fichier Xib, seront héritées de <code>XibView</code> : <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RedView</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">XibView</span></span></span><span class="hljs-class"> </span></span>{ }</code> </pre><br><img src="https://habrastorage.org/webt/j8/ak/ny/j8aknyaa51sdpr6y8kbh7yjfwvs.png"><br>  Si vous ajoutez maintenant une nouvelle <code>UIView</code> au Storyboard et définissez sa classe sur <code>RedView</code> , alors tout sera affiché avec succès: <br><img src="https://habrastorage.org/webt/0l/a-/wa/0la-waqvswrxya3gc8clxvro2iw.png"><br>  La création d'une instance de <code>RedView</code> dans le code se produit de la manière habituelle: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> redView = <span class="hljs-type"><span class="hljs-type">RedView</span></span>()</code> </pre> <br>  Un autre détail utile que tout le monde ne peut connaître est la possibilité d'ajouter des couleurs au répertoire <b>.xcassets</b> .  Cela vous permet de les modifier globalement dans tous les Storyboards et Xibs où ils sont utilisés. <br><br>  Pour ajouter de la couleur, cliquez sur "+" en bas à gauche et sélectionnez "Nouveau jeu de couleurs": <br><img src="https://habrastorage.org/webt/zm/3u/qi/zm3uqiunozwu020zpfckzd_slbo.png"><br>  Spécifiez le nom et la couleur désirés: <br><img src="https://habrastorage.org/webt/4j/ve/lt/4jveltbjt7fiqalngh6zzg1otr4.png"><br>  La couleur créée apparaîtra dans la section "Couleurs nommées": <br><img src="https://habrastorage.org/webt/km/cl/ak/kmclakpy0pduyyudog1_daxmx8o.png"><br>  De plus, il peut être obtenu dans le code: <br><br><pre> <code class="swift hljs">innerView.backgroundColor = <span class="hljs-type"><span class="hljs-type">UIColor</span></span>(named: <span class="hljs-string"><span class="hljs-string">"BackgroundColor"</span></span>)</code> </pre><br><h3>  3. Vous ne pouvez pas utiliser des initialiseurs personnalisés pour <code>UIViewControllers</code> créés dans Storyboard </h3><br>  Dans le cas du Storyboard, nous ne pouvons pas passer de dépendances dans les initialiseurs des <code>UIViewControllers</code> .  Habituellement, cela ressemble à ceci: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">for</span></span></span></span><span class="hljs-function"><span class="hljs-params"> segue: UIStoryboardSegue, sender: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">Any</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> segue.identifier == <span class="hljs-string"><span class="hljs-string">"detail"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> detailVC = segue.destination <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? <span class="hljs-type"><span class="hljs-type">DetailViewController</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> object = <span class="hljs-type"><span class="hljs-type">Object</span></span>() detailVC.object = object }</code> </pre> <br>  Ce code peut être mieux fait en utilisant une sorte de constante pour représenter des identifiants ou des outils comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SwiftGen</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">R.swift</a> , ou peut-être même <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Perform</a> .  Mais de cette façon, nous nous débarrassons uniquement des littéraux de chaîne et ajoutons du sucre syntaxique, et ne résolvons pas les problèmes qui se posent: <br><br><ul><li>  Comment savoir comment le <code>DetailViewController</code> configuré dans l'exemple ci-dessus?  Si vous êtes nouveau dans le projet et n'avez pas cette connaissance, vous devrez ouvrir un fichier avec une description de ce contrôleur et l'étudier. <br></li><li>  Les propriétés <code>DetailViewController</code> définies après l'initialisation, ce qui signifie qu'elles doivent être facultatives.  Il est nécessaire de gérer les cas où une propriété est <code>nil</code> , sinon l'application peut se bloquer au moment le plus inopportun.  Vous pouvez marquer les propriétés comme facultatives implicitement développées ( <code>var object: Object!</code> ), Mais l'essence ne changera pas. <br></li><li>  Les propriétés doivent être marquées comme <code>var</code> et non <code>let</code> .  Une situation est donc possible lorsque quelqu'un de l'extérieur veut les changer.  <code>DetailViewController</code> doit gérer de telles situations. <br></li></ul><br>  Une solution est décrite dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cet article</a> . <br><br><h3>  4. À mesure que le Storyboard grandit, la navigation devient plus difficile </h3><br>  Comme nous l'avons noté précédemment, vous n'avez pas besoin de tout mettre dans un Storyboard, il est préférable de le diviser en plusieurs plus petits.  Avec l'avènement du <b>Storyboard Reference,</b> c'est devenu très simple. <br>  Ajoutez la référence du storyboard de la bibliothèque d'objets au storyboard: <br><img src="https://habrastorage.org/webt/m7/v4/wc/m7v4wcm7xu_chbm7n6j_mmy1ssq.png"><br>  Nous définissons les valeurs de champ requises dans l' <b>inspecteur d'attributs</b> - il s'agit du nom du fichier Storyboard et, si nécessaire, de l' <b>ID référencé</b> , qui correspond à l' <b>ID Storyboard de l'</b> écran souhaité.  Par défaut, le <b>contrôleur de vue initiale</b> se charge: <br><img src="https://habrastorage.org/webt/0j/2a/ee/0j2aeevobxwbcwd4impkwryj1ye.png"><br>  Si vous spécifiez un nom non valide dans le champ Storyboard ou faites référence à un ID Storyboard inexistant, Xcode vous en avertira lors de la compilation. <br><br><h3>  5. Xcode ralentit lors du chargement des story-boards </h3><br>  Si le Storyboard contient un grand nombre d'écrans avec de nombreuses contraintes, son chargement prendra vraiment un certain temps.  Mais là encore, il est préférable de diviser le grand Storyboard en plus petits.  Séparément, ils se chargent beaucoup plus rapidement et il devient plus pratique de travailler avec eux. <br><br><h3>  6. Les storyboards sont fragiles, un bug peut provoquer le plantage de l'application au moment de l'exécution </h3><br>  Les principaux points faibles: <br><br><ul><li>  Erreurs dans les <code>UICollectionViewCell</code> <code>UITableViewCell</code> et <code>UICollectionViewCell</code> . <br></li><li>  Erreurs dans les identifiants de séquence. <br></li><li>  Utilisation d'une sous-classe d' <code>UIView</code> qui n'existe plus. <br></li><li>  Synchronisation des <code>IBActions</code> et <code>IBOutlets</code> avec le code. <br></li></ul><br>  Tout cela et certains autres problèmes peuvent entraîner le blocage de l'application au moment de l'exécution, ce qui signifie qu'il est probable que de telles erreurs tombent dans la version.  Par exemple, lorsque nous définissons des identifiants de cellule ou des séquences dans le Storyboard, ils doivent être copiés dans le code où qu'ils soient utilisés.  En changeant l'identifiant à un endroit, il doit être changé dans tous les autres.  Il est possible que vous l'oublieriez simplement ou que vous fassiez une faute de frappe, mais que vous ne connaissiez l'erreur que lorsque l'application est en cours d'exécution. <br><br>  Vous pouvez réduire la probabilité d'erreurs en supprimant les littéraux de chaîne dans votre code.  Pour cela, les <code>UICollectionViewCell</code> <code>UITableViewCell</code> et <code>UICollectionViewCell</code> peuvent se voir attribuer les noms des classes de cellules: par exemple, l'identifiant <code>ItemTableViewCell</code> sera la chaîne «ItemTableViewCell».  Dans le code, nous obtenons la cellule comme ceci: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> cell = tableView.dequeueReusableCell(withIdentifier: <span class="hljs-type"><span class="hljs-type">String</span></span>(describing: <span class="hljs-type"><span class="hljs-type">ItemTableViewCell</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>! <span class="hljs-type"><span class="hljs-type">ItemTableViewCell</span></span></code> </pre> <br>  Vous pouvez ajouter la fonction générique correspondante à <code>UITableView</code> : <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UITableView</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">open</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dequeueReusableCell</span></span></span><span class="hljs-function">&lt;T&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">T</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-type"><span class="hljs-type">T</span></span>: <span class="hljs-type"><span class="hljs-type">UITableViewCell</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dequeueReusableCell(withIdentifier: <span class="hljs-type"><span class="hljs-type">String</span></span>(describing: <span class="hljs-type"><span class="hljs-type">T</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>! <span class="hljs-type"><span class="hljs-type">T</span></span> } }</code> </pre> <br>  Et puis il devient plus facile d'obtenir la cellule: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> cell: <span class="hljs-type"><span class="hljs-type">ItemTableViewCell</span></span> = tableView.dequeueReusableCell()</code> </pre> <br>  Si vous oubliez soudainement de spécifier la valeur de l'identifiant de cellule dans le Storyboard, Xcode affichera un avertissement, vous ne devez donc pas les ignorer. <br><br>  En ce qui concerne les identificateurs de séquences, vous pouvez utiliser des énumérations pour eux.  Créons un protocole spécial: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SegueHandler</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">associatedtype</span></span> <span class="hljs-type"><span class="hljs-type">SegueIdentifier</span></span>: <span class="hljs-type"><span class="hljs-type">RawRepresentable</span></span> }</code> </pre> <br>  <code>UIViewController</code> qui prend en charge ce protocole devra définir un type imbriqué avec le même nom.  Il répertorie tous les identifiants de séquence que ce <code>UIViewController</code> peut traiter: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StartViewController</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SegueHandler</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SegueIdentifier</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> signIn, signUp } }</code> </pre> <br>  De plus, dans l'extension de protocole <code>SegueHandler</code> , <code>SegueHandler</code> définissons deux fonctions: l'une accepte un <code>UIStoryboardSegue</code> et renvoie la valeur <code>SegueIdentifier</code> correspondante, et l'autre appelle simplement <code>performSegue</code> , en prenant l'entrée <code>SegueIdentifier</code> : <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SegueHandler</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">where</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Self</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UIViewController</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SegueIdentifier</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RawValue</span></span></span><span class="hljs-class"> == </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">performSegue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(withIdentifier segueIdentifier: SegueIdentifier, sender: AnyObject?)</span></span></span></span> { performSegue(withIdentifier: segueIdentifier.rawValue, sender: sender) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">segueIdentifier</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">for</span></span></span></span><span class="hljs-function"><span class="hljs-params"> segue: UIStoryboardSegue)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">SegueIdentifier</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> identifier = segue.identifier, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> identifierCase = <span class="hljs-type"><span class="hljs-type">SegueIdentifier</span></span>(rawValue: identifier) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">fatalError</span></span>(<span class="hljs-string"><span class="hljs-string">"Invalid segue identifier \(String(describing: segue.identifier))."</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> identifierCase } }</code> </pre> <br>  Et maintenant, dans un <code>UIViewController</code> qui prend en charge le nouveau protocole, vous pouvez travailler avec <code>prepare(for:sender:)</code> comme suit: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StartViewController</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SegueHandler</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SegueIdentifier</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> signIn, signUp } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">for</span></span></span></span><span class="hljs-function"><span class="hljs-params"> segue: UIStoryboardSegue, sender: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">Any</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> segueIdentifier(<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: segue) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .signIn: <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"signIn"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .signUp: <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"signUp"</span></span>) } } }</code> </pre> <br>  Et lancez la séquence comme ceci: <br><br><pre> <code class="swift hljs">performSegue(withIdentifier: .signIn, sender: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)</code> </pre> <br>  Si vous ajoutez un nouvel identifiant à <code>SegueIdentifier</code> , alors Xcode le forcera certainement à traiter dans <code>switch/case</code> . <br><br>  Une autre option pour se débarrasser des littéraux de chaîne comme les séquences d'identificateurs et autres consiste à utiliser des outils de génération de code comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">R.swift</a> . <br><br><h3>  7. Les storyboards sont moins flexibles que le code. </h3><br>  Oui, c'est vrai.  Si la tâche consiste à créer un écran complexe avec des animations et des effets que le Storyboard ne peut pas gérer, alors vous devez utiliser le code! <br><br><h3>  8. Les storyboards ne permettent pas de changer le type de <code>UIViewControllers</code> spéciaux </h3><br>  Par exemple, lorsque vous devez changer le type de <code>UITableViewController</code> en <code>UICollectionViewController</code> , vous devez supprimer l'objet, en ajouter un nouveau avec un autre type et le reconfigurer.  Bien que ce ne soit pas un cas fréquent, il convient de noter que ces modifications sont apportées plus rapidement dans le code. <br><br><h3>  9. Les storyboards ajoutent deux dépendances supplémentaires au projet.  Ils peuvent contenir des erreurs que le développeur ne peut pas corriger. </h3><br>  Il s'agit d'Interface Builder et de l'analyseur Storyboards.  De tels cas sont rares et peuvent souvent être contournés par d'autres solutions. <br><br><h3>  10. Revue de code sophistiquée </h3><br>  Gardez à l'esprit que la révision du code n'est pas vraiment une recherche de bogues.  Oui, ils se trouvent dans le processus de visualisation du code, mais l'objectif principal est d'identifier les faiblesses qui peuvent créer des problèmes à long terme.  Pour les storyboards, il s'agit principalement du travail de <b>mise en page automatique</b> .  Il ne devrait pas y avoir d' <b>ambiguïté</b> et de <b>malentendu</b> .  Pour les trouver, utilisez simplement la recherche dans le Storyboard XML pour les lignes "ambiguous =" YES "" et "misplaced =" YES "" ou ouvrez simplement le Storyboard dans Interface Builder et recherchez les points rouges et jaunes: <br><img src="https://habrastorage.org/webt/u4/bw/l5/u4bwl5psqejad5ziovb2bjxy1eq.png"><br>  Cependant, cela peut ne pas suffire.  Les conflits entre les contraintes peuvent également être détectés lorsque l'application est en cours d'exécution.  Si une situation similaire se produit, des informations à ce sujet s'affichent dans la console.  De tels cas ne sont pas rares, par conséquent, leur recherche doit également être prise au sérieux. <br><br>  Tout le reste - faire correspondre la position et la taille des éléments avec la conception, la liaison correcte des <code>IBOutlets</code> et <code>IBActions</code> - n'est pas pour la révision du code. <br><br>  De plus, il est important de faire des commits plus souvent, il sera alors plus facile pour le réviseur de visualiser les changements en petits morceaux.  Il sera plus en mesure de se plonger dans les détails sans rien manquer.  Cela, à son tour, aura un effet positif sur la qualité de la révision du code. <br><br><h3>  Résumé </h3><br>  Dans la liste des défauts de Storyboards, j'ai laissé 4 éléments (par ordre décroissant de leur valeur): <br><br><ol><li>  Les storyboards ont du mal à gérer les conflits lors de la fusion des modifications. <br></li><li>  Les storyboards sont moins flexibles que le code. <br></li><li>  Les storyboards sont fragiles, une erreur peut entraîner un plantage lors de l'exécution. <br></li><li>  Vous ne pouvez pas utiliser des initialiseurs personnalisés pour <code>UIViewControllers</code> créés dans le Storyboard. <br></li></ol><br><h2>  Les avantages </h2><br><h3>  1. Visualisation de l'interface utilisateur et des contraintes </h3><br>  Même si vous êtes débutant et que vous venez de démarrer un projet que vous ne connaissez pas, vous pouvez facilement trouver le point d'entrée de l'application et comment y accéder depuis l'écran souhaité.  Vous savez à quoi ressembleront chaque bouton, étiquette ou champ de texte, quelle position ils prendront, comment les contraintes les affectent, comment ils interagissent avec les autres éléments.  En quelques clics, vous pouvez facilement créer une nouvelle <code>UIView</code> , personnaliser son apparence et son comportement.  La mise en page automatique nous permet de travailler avec <code>UIView</code> naturellement, comme si nous disions: "Ce bouton devrait être à gauche de cette étiquette et avoir la même hauteur avec elle."  Cette expérience d'interface utilisateur est intuitive et efficace.  Vous pouvez essayer de donner des exemples où un code bien écrit fait gagner plus de temps lors de la création de certains éléments de l'interface utilisateur, mais globalement cela ne change pas grand-chose.  Le storyboard fait bien son travail. <br><br>  Séparément, notez Disposition automatique.  Il s'agit d'un outil très puissant et utile, sans lequel il serait difficile de créer une application qui prend en charge toutes les différentes tailles d'écran.  Interface Builder vous permet de voir le résultat du travail avec Auto Layout sans lancer l'application, et si certaines contraintes ne correspondent pas au schéma général, Xcode vous en avertira immédiatement.  Bien sûr, il y a des cas où Interface Builder n'est pas en mesure de fournir le comportement nécessaire d'une interface très dynamique et complexe, alors vous devez vous fier au code.  Mais même dans de telles situations, vous pouvez le faire dans Interface Builder et le compléter avec seulement quelques lignes de code. <br><br>  Regardons quelques exemples qui illustrent les fonctionnalités utiles d'Interface Builder. <br><br><h4>  Tables dynamiques basées sur <code>UIStackView</code> </h4><br>  Créez un nouveau <code>UIViewController</code> , ajoutez un plein écran <code>UIScrollView</code> : <br><img src="https://habrastorage.org/webt/oh/-g/c8/oh-gc88tyx_mhu5zm6iehrnpvrk.png"><br>  Dans <code>UIScrollView</code> ajoutez un <code>UIStackView</code> vertical, <code>UIStackView</code> -le aux bords et définissez la hauteur et la largeur égales à <code>UIScrollView</code> .  À cette hauteur, attribuez la <b>priorité = Faible (250)</b> : <br><img src="https://habrastorage.org/webt/hp/dv/v-/hpdvv-gg-hkeh_xy5k2vbbcznr0.png"><br>  Ensuite, créez toutes les cellules nécessaires et ajoutez-les à <code>UIStackView</code> .  Peut-être que ce sera <code>UIView</code> ordinaire en une seule copie, ou peut-être <code>UIView</code> , pour lequel nous avons créé notre propre fichier Xib.  Dans tous les cas, l'interface utilisateur entière de cet écran est dans le Storyboard, et grâce à la mise en page automatique correctement configurée, le défilement fonctionnera parfaitement, en s'adaptant au contenu: <br><br><img src="https://habrastorage.org/webt/vg/pr/dl/vgprdl652o0neubp6d87fvcyupk.gif" width="320" height="588"><br><br>  Nous pouvons également adapter les cellules à la taille de leur contenu.  Ajoutez <code>UILabel</code> à chaque cellule, liez-les aux bords: <br><img src="https://habrastorage.org/webt/ei/u0/if/eiu0ifpkzcudjmimrknducpg5f4.png"><br>  Il est déjà clair à quoi tout cela ressemblera au moment de l'exécution.  Vous pouvez associer des actions aux cellules, par exemple, passer à un autre écran.  Et tout cela sans une seule ligne de code. <br>  De plus, si vous définissez <code>hidden = true</code> pour un <code>UIView</code> partir d'un <code>UIStackView</code> , il ne se cachera pas seulement, mais ne prendra pas non plus d'espace.  <code>UIStackView</code> recalculera automatiquement ses tailles: <br><br><img src="https://habrastorage.org/webt/b8/cs/ch/b8cschy8jwotcb1fge4ew2ip43s.gif"><br><br><h4>  Cellules à dimensionnement automatique </h4><br>  Dans l' <b>inspecteur Taille du</b> tableau, définissez <b>Hauteur de ligne = Automatique</b> et <b>Estimation</b> - sur une valeur moyenne: <br><img src="https://habrastorage.org/webt/p2/tp/de/p2tpdecyxveakvtukce9maxkrbq.png"><br>  Pour que cela fonctionne, les contraintes doivent être correctement configurées dans les cellules elles-mêmes et permettre un calcul précis de la hauteur des cellules en fonction du contenu au moment de l'exécution.  Si ce n'est pas clair ce qui est en jeu, il y a une très bonne explication dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation officielle</a> . <br><br>  En conséquence, en démarrant l'application, nous verrons que tout est correctement affiché: <br><img src="https://habrastorage.org/webt/yi/mb/4q/yimb4q-qt5ydm3_3ynqavuvr4ga.png" width="432" height="702"><br><h4>  Table à dimensionnement automatique </h4><br>  Vous devez implémenter ce comportement de table: <br><br><img src="https://habrastorage.org/webt/6g/pp/bf/6gppbf-ma4zin0czafyjn3wfj08.gif" width="320" height="588"><br><br>  Comment réaliser un changement dynamique de hauteur similaire?  Contrairement à <code>UILabel</code> , <code>UIButton</code> et à d'autres sous-classes d' <code>UIView</code> , c'est un peu plus difficile à faire avec un tableau, car <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la taille du contenu intrinsèque</a> ne dépend pas de la taille des cellules à l'intérieur.  Elle ne peut pas calculer sa taille en fonction du contenu, mais il est possible de l'aider avec cela. <br><br>  Notez qu'à un moment donné de la vidéo, la hauteur de la table cesse de changer, atteignant une certaine valeur maximale.  Pour ce faire, définissez la <b>contrainte de hauteur de</b> table avec la valeur <b>Relation = Inférieur ou égal</b> : <br><img src="https://habrastorage.org/webt/xk/47/rc/xk47rcebixtr42k1ka4wqagftyy.png"><br>  À ce stade, Interface Builder ne sait pas encore quelle hauteur sera la table, il ne connaît que sa valeur maximale égale à 200 (à partir de la contrainte de hauteur).  Comme indiqué précédemment, la taille du contenu intrinsèque n'est pas égale au contenu du tableau.  Cependant, nous avons la possibilité de définir l'espace réservé dans le champ <b>Taille intrinsèque</b> : <br><img src="https://habrastorage.org/webt/tb/i7/eu/tbi7eut1jafonqjknoyabqyev_q.png"><br>  Cette valeur n'est valide que lorsque vous travaillez avec Interface Builder.  Bien sûr, la taille du contenu intrinsèque ne doit pas nécessairement être égale à cette valeur lors de l'exécution.  Nous venons de dire à Interface Builder que tout est sous contrôle. <br><br>  Ensuite, créez une nouvelle sous-classe de la table <code>CustomTableView</code> : <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CustomTableView</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UITableView</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> contentSize: <span class="hljs-type"><span class="hljs-type">CGSize</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">didSet</span></span> { invalidateIntrinsicContentSize() } } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> intrinsicContentSize: <span class="hljs-type"><span class="hljs-type">CGSize</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> contentSize } }</code> </pre> <br>  Un de ces cas où le code est nécessaire.  Ici, nous appelons <code>invalidateIntrinsicContentSize</code> chaque fois que <code>contentSize</code> la table change.  Cela permettra au système d'accepter la nouvelle taille de contenu intrinsèque.  À son tour, il renvoie <code>contentSize</code> , forçant le tableau à ajuster dynamiquement sa hauteur et à afficher un certain nombre de cellules sans défilement.  Le défilement apparaît au moment où nous atteignons la limite de contrainte de hauteur. <br><br>  Ces trois fonctionnalités d'Interface Builder peuvent être combinées entre elles.  Ils ajoutent plus de flexibilité aux options d'organisation du contenu sans avoir besoin de contraintes supplémentaires ou de toute <code>UIView</code> . <br><br><h3>  2. La capacité de voir instantanément le résultat de leurs actions </h3><br>  Si vous redimensionnez l' <code>UIView</code> , le <code>UIView</code> quelques points sur le côté ou modifiez la couleur d'arrière-plan, vous verrez immédiatement à quoi il ressemblera lors de l'exécution sans avoir à lancer l'application.  Pas besoin de se demander pourquoi certains boutons n'apparaissent pas à l'écran ou pourquoi le comportement de l' <code>UIView</code> pas celui souhaité. <br><br>  L'utilisation de <code>@IBInspectable</code> révèle cet avantage de manière encore plus intéressante.  Ajoutez deux <code>UILabel</code> et deux propriétés à <code>RedView</code> : <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RedView</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">XibView</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@IBOutlet</span></span> <span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> titleLabel: <span class="hljs-type"><span class="hljs-type">UILabel!</span></span> <span class="hljs-meta"><span class="hljs-meta">@IBOutlet</span></span> <span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> subtitleLabel: <span class="hljs-type"><span class="hljs-type">UILabel!</span></span> <span class="hljs-meta"><span class="hljs-meta">@IBInspectable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> title: <span class="hljs-type"><span class="hljs-type">String</span></span> = <span class="hljs-string"><span class="hljs-string">""</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">didSet</span></span> { titleLabel.text = title } } <span class="hljs-meta"><span class="hljs-meta">@IBInspectable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> subtitle: <span class="hljs-type"><span class="hljs-type">String</span></span> = <span class="hljs-string"><span class="hljs-string">""</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">didSet</span></span> { subtitleLabel.text = subtitle } } }</code> </pre> <br>  Deux nouveaux champs apparaîtront dans l' <b>inspecteur d'attributs</b> pour <code>RedView</code> - <code>Title</code> et <code>Subtitle</code> - <code>Subtitle</code> , que nous avons marqué comme <code>@IBInspectable</code> : <br><img src="https://habrastorage.org/webt/wv/rh/nn/wvrhnnegpjpyo7zrj7857dlujom.png"><br>  Si nous essayons d'entrer des valeurs dans ces champs, nous verrons immédiatement à quoi tout ressemblera lors de l'exécution: <br><br><img src="https://habrastorage.org/webt/hn/bd/6u/hnbd6urq0ebbpghnuiaueovz38i.gif"><br><br>  Vous pouvez contrôler n'importe quoi: <code>cornerRadius</code> , <code>borderWidth</code> , <code>borderColor</code> .  Par exemple, nous étendons la classe de base <code>UIView</code> : <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UIView</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@IBInspectable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cornerRadius: <span class="hljs-type"><span class="hljs-type">CGFloat</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { layer.cornerRadius = newValue } <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> layer.cornerRadius } } <span class="hljs-meta"><span class="hljs-meta">@IBInspectable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> borderWidth: <span class="hljs-type"><span class="hljs-type">CGFloat</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { layer.borderWidth = newValue } <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> layer.borderWidth } } <span class="hljs-meta"><span class="hljs-meta">@IBInspectable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> borderColor: <span class="hljs-type"><span class="hljs-type">UIColor?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { layer.borderColor = newValue?.cgColor } <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> layer.borderColor != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> ? <span class="hljs-type"><span class="hljs-type">UIColor</span></span>(cgColor: layer.borderColor!) : <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } } <span class="hljs-meta"><span class="hljs-meta">@IBInspectable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rotate: <span class="hljs-type"><span class="hljs-type">CGFloat</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { transform = <span class="hljs-type"><span class="hljs-type">CGAffineTransform</span></span>(rotationAngle: newValue * .pi/<span class="hljs-number"><span class="hljs-number">180</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> } } }</code> </pre> <br>  Nous voyons que l'inspecteur d'attributs de l'objet <code>RedView</code> acquis 4 nouveaux champs supplémentaires, avec lesquels vous pouvez désormais jouer: <br><br><img src="https://habrastorage.org/webt/gq/ib/bm/gqibbmd2an0a4zezig2iuifx5tm.gif"><br><br><h3>  3. Prévisualisez toutes les tailles d'écran à la fois </h3><br>  Nous avons donc jeté les éléments nécessaires à l'écran, ajusté leur apparence et ajouté les contraintes nécessaires.  Comment savoir si le contenu s'affichera correctement sur différentes tailles d'écran?  Bien sûr, vous pouvez exécuter l'application sur chaque simulateur, mais cela prendra beaucoup de temps.  Il y a une meilleure option: Xcode a un mode de prévisualisation, il vous permet de voir plusieurs tailles d'écran à la fois sans lancer l'application. <br><br>  Nous appelons l' <b>éditeur adjoint</b> , cliquez dessus sur le premier segment de la barre de transition, sélectionnez <b>Aperçu -&gt; Paramètres.toryboard</b> (à titre d'exemple): <br><img src="https://habrastorage.org/webt/aw/mg/nr/awmgnrb4ajxr49hrygbe70fz5is.png"><br>  Au début, nous ne voyons qu'un seul écran, mais nous pouvons en ajouter autant que nécessaire en cliquant sur «+» dans le coin inférieur gauche et en sélectionnant les appareils nécessaires dans la liste: <br><img src="https://habrastorage.org/webt/18/3f/eo/183feokkgdpycsxlcr3a1upo8jk.png"><br>  De plus, si le Storyboard prend en charge plusieurs langues, vous pouvez voir à quoi ressemblera l'écran sélectionné avec chacune d'entre elles: <br><img src="https://habrastorage.org/webt/hy/nf/6g/hynf6gc-nzhc30fxq0ir2a2uzcc.png"><br>  La langue peut être sélectionnée pour tous les écrans à la fois et pour chacun individuellement. <br><br><h3>  4. Suppression du code de l'interface utilisateur du modèle </h3><br>  La création d'une interface utilisateur sans Interface Builder s'accompagne soit d'une grande quantité de code standard, soit de superclasses et d'extensions qui nécessitent des travaux de maintenance supplémentaires.  Ce code peut s'infiltrer dans d'autres parties de l'application, ce qui rend sa lecture et sa recherche difficiles.  L'utilisation de Storyboards et de Xibs peut décharger du code, le rendant plus axé sur la logique. <br><br><h3>  5. Classes de taille </h3><br>  Chaque année, de nouveaux appareils apparaissent, pour lesquels vous devez adapter l'interface utilisateur.  Le concept de <b>variations</b> de <b>traits</b> et, en particulier, de <b>classes de taille</b> , qui vous permettent de créer une interface utilisateur pour n'importe quelle taille et orientation de l'écran, y contribue. <br><br>  Les classes de taille classent la hauteur (h) et la largeur (w) des écrans de l'appareil en termes de <b>compact</b> et <b>régulier</b> ( <b>C</b> et <b>R</b> ).  Par exemple, l'iPhone 8 a une classe de taille <b>(wC hR)</b> en orientation portrait et <b>(wC hC)</b> en paysage, et l'iPhone 8 Plus a <b>(wC hR)</b> et <b>(wR hC)</b> respectivement.  Les autres appareils peuvent être trouvés <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br>  Dans un Storyboard ou Xib pour chacune des classes de taille, vous pouvez stocker votre propre ensemble de données, et l'application utilisera celui approprié en fonction de l'appareil et de l'orientation de l'écran au moment de l'exécution, identifiant ainsi la classe de taille actuelle.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si certains paramètres de mise en page sont les mêmes pour toutes les classes de taille, ils peuvent être configurés dans la catégorie " </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tout</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ", qui est déjà sélectionnée par défaut. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Par exemple, configurez la taille de police en fonction de la classe de taille. Nous sélectionnons l'appareil iPhone 8 Plus pour l'affichage dans Storyboard en orientation portrait et ajoutons une nouvelle condition pour </font></font><code>font</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: si la </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">largeur est Régulière</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (définissez tout le reste sur «Tout»), alors la taille de la police doit être 37: </font></font><br><img src="https://habrastorage.org/webt/bd/bs/-7/bdbs-7i602wtlxemns-hm3jz3ps.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, si nous changeons l'orientation de l'écran, la taille de la police augmenter - une nouvelle condition fonctionnera, car en orientation paysage, l'iPhone 8 Plus a une classe de taille </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(wR hC)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Dans le Storyboard, selon la classe de taille, vous pouvez également masquer les vues, activer / désactiver les contraintes, changer leur valeur</font></font><code>constant</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et bien plus. En savoir plus sur la façon de faire tout cela </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans la capture d'écran ci-dessus, il convient de noter le panneau inférieur avec le choix de l'appareil pour afficher la disposition. Il vous permet de vérifier rapidement l'adaptabilité de l'interface utilisateur sur n'importe quel appareil et avec n'importe quelle orientation d'écran, et affiche également la classe de taille de la configuration actuelle (à côté du nom de l'appareil). Entre autres choses, il y a un bouton </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vary for Traits</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sur la droite </font><font style="vertical-align: inherit;">. Son but est de permettre des variations de traits uniquement pour une catégorie spécifique de largeur, hauteur ou largeur et hauteur en même temps. Par exemple, en sélectionnant un iPad avec une classe de taille </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(wR hR)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , cliquez sur «Varier pour les traits» et cochez la case à côté de la </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">largeur</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et de la </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hauteur</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Désormais, toutes les modifications de disposition ultérieures ne s'appliqueront qu'aux appareils avec </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(wR hR)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> jusqu'à ce que nous </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cliquions</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sur </font><b><font style="vertical-align: inherit;">Terminé</font></b><font style="vertical-align: inherit;"> .</font></font><br><br><h2>  Conclusion </h2><div class="scrollable-table"><table><tbody><tr><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> # </font></font><br></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Inconvénients </font></font><br></th><th>  Les avantages <br></th></tr><tr><td>  1 <br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Conflits difficiles à gouverner </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Visualisation et contraintes de l'interface utilisateur </font></font><br></td></tr><tr><td>  2 <br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pas aussi flexible que le code </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La possibilité de voir instantanément le résultat de vos actions </font></font><br></td></tr><tr><td>  3 <br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Une erreur peut entraîner un crash lors de l'exécution. </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Prévisualisez toutes les tailles d'écran à la fois </font></font><br></td></tr><tr><td>  4 <br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vous ne pouvez pas utiliser d'initialiseurs personnalisés pour </font></font><code>UIViewControllers</code> <br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Suppression du code de l'interface utilisateur du modèle </font></font><br></td></tr><tr><td>  5 <br></td><td></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Classes de taille </font></font><br></td></tr></tbody></table></div><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons vu que les storyboards ont leurs forces et leurs faiblesses. </font><font style="vertical-align: inherit;">À mon avis, vous ne devez pas refuser complètement de les utiliser. </font><font style="vertical-align: inherit;">Lorsqu'ils sont utilisés correctement, ils apportent de grands avantages et aident à résoudre efficacement les tâches. </font><font style="vertical-align: inherit;">Vous avez juste besoin d'apprendre à hiérarchiser et à oublier des arguments comme «Je n'aime pas les storyboards» ou «J'ai l'habitude de faire ça».</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr456086/">https://habr.com/ru/post/fr456086/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr456072/index.html">Dav1d - le décodeur AV1 le plus rapide maintenant dans Firefox par défaut</a></li>
<li><a href="../fr456076/index.html">Meetup PyDaCon au groupe Mail.ru: 22 juin</a></li>
<li><a href="../fr456078/index.html">Projection de conflit d'entreprise sur la connectivité réseau</a></li>
<li><a href="../fr456082/index.html">Comment nous développons des recommandations de produits personnalisées</a></li>
<li><a href="../fr456084/index.html">Kubernetes 1.15: Aperçu des faits saillants</a></li>
<li><a href="../fr456088/index.html">Problèmes d'analyse du Big Data</a></li>
<li><a href="../fr456090/index.html">Introduction aux tests unitaires dans Unity</a></li>
<li><a href="../fr456092/index.html">Sept signes troublants que vous dépendez des conditions météorologiques, même si vous ne le pensez pas</a></li>
<li><a href="../fr456094/index.html">Nous lisons les fiches techniques 2: SPI sur STM32; Temporisateurs et interruptions PWM sur le STM8</a></li>
<li><a href="../fr456096/index.html">Ce que fait le lecteur de geektimes moyen en planant dans les nuages</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>