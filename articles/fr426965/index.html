<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧑🏼‍🤝‍🧑🏼 🔃 🏉 Qu'adviendra-t-il de la gestion des erreurs en C ++ 2a 🚈 🔐 👆🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Il y a quelques semaines, la conférence principale du monde C ++ - CPPCON . 
 Cinq jours consécutifs de 8 heures à 22 heures, il y a eu des rapports. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Qu'adviendra-t-il de la gestion des erreurs en C ++ 2a</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/426965/"><p><img src="https://habrastorage.org/getpro/habr/post_images/47f/f1a/031/47ff1a031b06731d90b89bbedbb9de05.jpg" alt="image"></p><br><p>  Il y a quelques semaines, la conférence principale du monde C ++ - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CPPCON</a> . <br>  Cinq jours consécutifs de 8 heures à 22 heures, il y a eu des rapports.  Les programmeurs de toutes confessions ont discuté de l'avenir du C ++, des vélos empoisonnés et ont pensé comment rendre le C ++ plus facile. </p><br><p>  Étonnamment, de nombreux rapports ont été consacrés au traitement des erreurs.  Des approches bien établies ne vous permettent pas d'atteindre des performances maximales ou peuvent générer des feuilles de code. <br>  Quelles innovations nous attendent en C ++ 2a? </p><a name="habracut"></a><br><h2 id="nemnogo-teorii">  Un peu de théorie </h2><br><p>  Classiquement, toutes les situations erronées du programme peuvent être divisées en 2 grands groupes: </p><br><ul><li>  Erreurs fatales. </li><li>  Erreurs non fatales ou attendues. </li></ul><br><h2 id="fatalnye-oshibki">  Erreurs fatales </h2><br><p> Après eux, cela n'a aucun sens de poursuivre l'exécution. <br>  Par exemple, il s'agit de déréférencer un pointeur nul, de passer par la mémoire, de diviser par 0 ou de violer d'autres invariants dans le code.  Tout ce qui doit être fait lorsqu'ils surviennent est de fournir un maximum d'informations sur le problème et de terminer le programme. </p><br><p>  En c ++ <del>  trop </del>  il existe déjà suffisamment de moyens pour terminer le programme: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">std :: terminate</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">std :: avort</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">std :: exit</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">std :: quick_exit</a> </li></ul><br><p>  Les bibliothèques commencent même à apparaître pour collecter des données sur les plantages ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">2</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">3</a> ). </p><br><h2 id="ne-fatalnye-oshibki">  Erreurs non fatales </h2><br><p>  Ce sont des erreurs fournies par la logique du programme.  Par exemple, des erreurs lors de l'utilisation du réseau, de la conversion d'une chaîne non valide en nombre, etc.  L'apparition de telles erreurs dans le programme est dans l'ordre des choses.  Pour leur traitement, il existe plusieurs tactiques généralement acceptées en C ++. <br>  Nous en parlerons plus en détail à l'aide d'un exemple simple: </p><br><p> Essayons d'écrire une fonction <code>void addTwo()</code> utilisant différentes approches de gestion des erreurs. <br>  La fonction doit lire 2 lignes, les convertir en <code>int</code> et imprimer la somme.  Besoin de gérer les erreurs d'E / S, le débordement et la conversion en nombre.  Je vais omettre les détails d'implémentation sans intérêt.  Nous considérerons 3 approches principales. </p><br><h3 id="1-isklyucheniya">  1. Exceptions </h3><br><pre> <code class="hljs pgsql">//     //   IO  std::runtime_error std::string readLine(); //    <span class="hljs-type"><span class="hljs-type">int</span></span> //     std::invalid_argument <span class="hljs-type"><span class="hljs-type">int</span></span> parseInt(const std::string&amp; str); //  a  b //     std::overflow_error <span class="hljs-type"><span class="hljs-type">int</span></span> safeAdd(<span class="hljs-type"><span class="hljs-type">int</span></span> a, <span class="hljs-type"><span class="hljs-type">int</span></span> b); <span class="hljs-type"><span class="hljs-type">void</span></span> addTwo() { try { std::string aStr = readLine(); std::string bStr = readLine(); <span class="hljs-type"><span class="hljs-type">int</span></span> a = parseInt(aStr); <span class="hljs-type"><span class="hljs-type">int</span></span> b = parseInt(bStr); std::cout &lt;&lt; safeAdd(a, b) &lt;&lt; std::endl; } catch(const std::exeption&amp; e) { std::cout &lt;&lt; e.what() &lt;&lt; std::endl; } }</code> </pre> <br><p>  Les exceptions en C ++ vous permettent de gérer les erreurs de manière centralisée sans <code>  </code> inutiles <code>  </code> , <br>  mais vous devez payer pour cela avec tout un tas de problèmes. </p><br><ul><li>  les frais généraux impliqués dans la gestion des exceptions sont assez importants; vous ne pouvez pas souvent lever d'exceptions. </li><li>  il vaut mieux ne pas lever les exceptions des constructeurs / destructeurs et observer RAII. </li><li>  par la signature de la fonction, il est impossible de comprendre quelle exception peut sortir de la fonction. </li><li>  la taille du fichier binaire augmente en raison d'un code de support d'exception supplémentaire. </li></ul><br><h3 id="2-kody-vozvrata">  2. Codes retour </h3><br><p>  Approche classique héritée de C. </p><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readLine</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; str)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parseInt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; str, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; result)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">safeAdd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; result)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addTwo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> aStr; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ok = readLine(aStr); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!ok) { processError(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> bStr; ok = readLine(bStr); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!ok) { processError(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a = <span class="hljs-number"><span class="hljs-number">0</span></span>; ok = parseInt(aStr, a); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!ok) { processError(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b = <span class="hljs-number"><span class="hljs-number">0</span></span>; ok = parseInt(bStr, b); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!ok) { processError(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; ok = safeAdd(a, b, result); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!ok) { processError(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; result &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }</code> </pre> <br><p>  Ça n'a pas l'air très bien? </p><br><ol><li>  Vous ne pouvez pas renvoyer la valeur réelle d'une fonction. </li><li>  Il est très facile d'oublier de gérer l'erreur (la dernière fois que vous avez vérifié le code retour de printf?). </li><li>  Vous devez écrire du code de gestion des erreurs à côté de chaque fonction.  Ce code est plus difficile à lire. <br>  L'utilisation de C ++ 17 et C ++ 2a résoudra tous ces problèmes en séquence. </li></ol><br><h3 id="3-c17-i-nodiscard">  3. C ++ 17 et nodiscard </h3><br><p>  L' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>  nodiscard</code></a> en C ++ 17. <br>  Si vous le spécifiez avant la déclaration de fonction, l'absence de vérification de la valeur de retour provoquera un avertissement du compilateur. </p><br><pre> <code class="hljs cs">[<span class="hljs-meta"><span class="hljs-meta">[nodiscard</span></span>]] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doStuff</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> doStuff(); <span class="hljs-comment"><span class="hljs-comment">//  ! bool ok = doStuff(); // .</span></span></code> </pre> <br><p>  Vous pouvez également spécifier <code>nodiscard</code> pour une classe, une structure ou une classe enum. <br>  Dans ce cas, l'action d'attribut s'étend à toutes les fonctions qui renvoient des valeurs du type étiqueté <code>nodiscard</code> . </p><br><pre> <code class="hljs lua">enum class <span class="hljs-string"><span class="hljs-string">[[nodiscard]]</span></span> ErrorCode { Exists, PermissionDenied }; ErrorCode createDir(); /* ... */ createDir();</code> </pre> <br><p>  Je ne fournirai pas de code avec <code>nodiscard</code> . </p><br><h3 id="c17-stdoptional">  C ++ 17 std :: facultatif </h3><br><p>  En C ++ 17, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>std::optional&lt;T&gt;</code></a> . <br>  Voyons maintenant à quoi ressemble le code. </p><br><pre> <code class="hljs cpp"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::optional&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; readLine(); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::optional&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; parseInt(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp; str); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::optional&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; safeAdd(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addTwo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::optional&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; aStr = readLine(); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::optional&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; bStr = readLine(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (aStr == <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::nullopt || bStr == <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::nullopt){ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cerr</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Some input error"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::optional&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; a = parseInt(*aStr); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::optional&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; b = parseInt(*bStr); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!a || !b) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cerr</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Some parse error"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::optional&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; result = safeAdd(*a, *b); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!result) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cerr</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Integer overflow"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; *result &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }</code> </pre> <br><p>  Vous pouvez supprimer les arguments in-out des fonctions et le code deviendra plus propre. <br>  Cependant, nous perdons des informations d'erreur.  Il est devenu difficile de savoir quand et ce qui a mal tourné. <br>  Vous pouvez remplacer <code>std::optional</code> par <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>std::variant&lt;ResultType, ValueType&gt;</code></a> . <br>  La signification du code est la même que pour <code>std::optional</code> , mais plus lourde. </p><br><h3 id="c2a-i-stdexpected">  C ++ 2a et std :: attendus </h3><br><p>  <code>std::expected&lt;ResultType, ErrorType&gt;</code> - un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">type de modèle spécial</a> , il tombera probablement dans la norme incomplète la plus proche. <br>  Il a 2 paramètres. </p><br><ul><li>  <code>ReusltType</code> est la valeur attendue. </li><li>  <code>ErrorType</code> - type d'erreur. <br>  <code>std::expected</code> peut contenir la valeur attendue ou une erreur.  Travailler avec ce type sera quelque chose comme ceci: <br><pre> <code class="hljs cpp"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::expected&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; ok = <span class="hljs-number"><span class="hljs-number">0</span></span>; expected&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; notOk = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_unexpected(<span class="hljs-string"><span class="hljs-string">"something wrong"</span></span>);</code> </pre> </li></ul><br><p>  En quoi cela diffère-t-il de la <code>variant</code> habituelle?  Qu'est-ce qui le rend spécial? <br>  <code>std::expected</code> sera une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">monade</a> . <br>  Il est proposé de prendre en charge un tas d'opérations sur <code>std::expected</code> comme sur une monade: <code>map</code> , <code>catch_error</code> , <code>bind</code> , <code>unwrap</code> , <code>return</code> and <code>then</code> . <br>  En utilisant ces fonctions, vous pouvez enchaîner les appels de fonction dans une chaîne. </p><br><pre> <code class="hljs markdown">getInt().map([<span class="hljs-string"></span><span class="hljs-string"></span>](<span class="hljs-link"><span class="hljs-link">int i</span></span>)return i * 2;) .map(integer<span class="hljs-emphasis"><span class="hljs-emphasis">_divide_</span></span>by<span class="hljs-emphasis"><span class="hljs-emphasis">_2) .catch_</span></span>error([](auto e) return 0; );</code> </pre> <br><p>  Supposons que nous ayons des fonctions avec le retour de <code>std::expected</code> . </p><br><pre> <code class="hljs cpp"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::expected&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::runtime_error&gt; readLine(); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::expected&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::runtime_error&gt; parseInt(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp; str); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::expected&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::runtime_error&gt; safeAdd(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b);</code> </pre> <br><p>  <strong>Ci-dessous se trouve uniquement un pseudo-code; il ne peut être forcé de fonctionner dans aucun compilateur moderne.</strong> <br>  Vous pouvez essayer d'emprunter à Haskell la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">syntaxe do pour</a> enregistrer les opérations sur les monades.  Pourquoi ne pas lui permettre de le faire: </p><br><pre> <code class="hljs cpp"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::expected&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::runtime_error&gt; result = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> aStr &lt;- readLine(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> bStr &lt;- readLine(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> a &lt;- parseInt(aStr); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> b &lt;- parseInt(bStr); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> safeAdd(a, b) }</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Certains auteurs</a> suggèrent cette syntaxe: </p><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> aStr = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> readLine(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> bStr = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> readLine(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> a = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> parseInt(aStr); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> b = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> parseInt(bStr); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> result &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> safeAdd(a, b) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::runtime_error&amp; err) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cerr</span></span> &lt;&lt; err.what() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><p>  Le compilateur convertit automatiquement un tel bloc de code en une séquence d'appels de fonction.  Si à un moment donné, la fonction ne retourne pas ce que l'on attend d'elle, la chaîne de calcul se rompra.  Oui, et comme type d'erreur, vous pouvez utiliser les types d'exceptions déjà existants dans la norme: <code>std::runtime_error</code> , <code>std::out_of_range</code> , etc. </p><br><p>  Si vous pouvez bien concevoir la syntaxe, alors <code>std::expected</code> vous permettra d'écrire du code simple et efficace. </p><br><h3 id="zaklyuchenie">  Conclusion </h3><br><p>  Il n'y a pas de moyen idéal pour gérer les erreurs.  Jusqu'à récemment, en C ++, il y avait presque toutes les méthodes possibles de gestion des erreurs, sauf les monades. <br>  En C ++ 2a, toutes les méthodes possibles sont susceptibles d'apparaître. </p><br><h3 id="chto-pochitat-i-posmotret-po-teme">  Que lire et voir sur le sujet </h3><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Proposition réelle</a> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Discours sur std :: attendu avec CPPCON</a> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Andrei Alexandrescu à propos de std :: attendu en C ++ Russie</a> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Discussion plus ou moins récente de la proposition sur Reddit</a> . </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr426965/">https://habr.com/ru/post/fr426965/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr426953/index.html">Exemple d'archivage Linux et méthodes d'installation</a></li>
<li><a href="../fr426957/index.html">Introduction aux serveurs WSGI: première partie</a></li>
<li><a href="../fr426959/index.html">Installer kubernetes via kubespray (stockage local, installer Elasticsearch + Fluentd + Kibana, prometheus)</a></li>
<li><a href="../fr426961/index.html">Comment Microsoft a réécrit le compilateur C # en C # et l'a ouvert</a></li>
<li><a href="../fr426963/index.html">Les applications Flutter rêvent-elles de widgets basés sur une plateforme?</a></li>
<li><a href="../fr426967/index.html">Générateur de code ABAP en ligne</a></li>
<li><a href="../fr426969/index.html">Vigilant Lida: automatisation des tests de sécurité</a></li>
<li><a href="../fr426971/index.html">Fatalisme dans la gestion des erreurs</a></li>
<li><a href="../fr426973/index.html">Sandwichs d'entreprise</a></li>
<li><a href="../fr426975/index.html">Joker 2018: l'impossible est possible</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>