<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⏯️ 💎 👸🏼 Benutzerdefinierte Codeausführung auf GO 🤔 👧🏽 🈴</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hier geht es eigentlich nur um intelligente Verträge. 
 Wenn Sie sich jedoch nicht genau vorstellen können, was ein intelligenter Vertrag ist und im A...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Benutzerdefinierte Codeausführung auf GO</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425985/"><h2>  Hier geht es eigentlich nur um intelligente Verträge. </h2><br>  Wenn Sie sich jedoch nicht genau vorstellen können, was ein intelligenter Vertrag ist und im Allgemeinen weit von Krypto entfernt ist, können Sie sich vorstellen, was eine in einer Datenbank gespeicherte Prozedur ist.  Der Benutzer erstellt Codeteile, die dann auf unserem Server funktionieren.  Es ist für den Benutzer bequem, sie zu schreiben und zu veröffentlichen, und für uns ist es sicher, sie auszuführen. <br><a name="habracut"></a><br>  Leider haben wir noch keine Sicherheit entwickelt, daher werde ich sie jetzt nicht beschreiben, aber ich werde ein paar Hinweise geben. <br><br>  Wir schreiben auch auf Go, und seine Laufzeit unterliegt einigen sehr spezifischen Einschränkungen. Die wichtigste davon ist, dass wir im Großen und Ganzen keine Verknüpfung zu einem anderen Projekt herstellen können, das nicht unterwegs geschrieben wurde. Dadurch wird unsere Laufzeit jedes Mal gestoppt, wenn wir Code von Drittanbietern ausführen.  Im Allgemeinen haben wir die Möglichkeit, eine Art Dolmetscher zu verwenden, für den wir eine völlig gesunde Lua und eine völlig gesunde WASM gefunden haben, aber irgendwie möchte ich Lua keine Kunden hinzufügen, aber mit WASM gibt es jetzt mehr Probleme als Vorteile, es befindet sich in einem Entwurfszustand , die jeden Monat aktualisiert wird, also warten wir, bis sich die Spezifikation beruhigt hat.  Wir benutzen es als zweiten Motor. <br><br>  Aufgrund langwieriger Kämpfe mit seinem eigenen Gewissen wurde beschlossen, intelligente Verträge über GO abzuschließen.  Tatsache ist, dass Sie, wenn Sie die Architektur für die Ausführung von kompiliertem GO-Code erstellen, diese Ausführung aus Sicherheitsgründen auf einen separaten Prozess übertragen müssen, wie Sie sich erinnern, und die Übertragung auf einen separaten Prozess einen Leistungsverlust für IPC darstellt, obwohl wir in Zukunft das Volumen der ausführbaren Datei verstanden haben Code, es war sogar irgendwie angenehm, dass wir diese Lösung gewählt haben.  Die Sache ist, dass es skalierbar ist, obwohl es jedem einzelnen Anruf eine Verzögerung hinzufügt.  Wir können viele entfernte Laufzeiten erhöhen. <br><br>  Ein bisschen mehr über die Entscheidungen, die getroffen wurden, damit es klar ist.  Jeder Smart-Vertrag besteht aus zwei Teilen, ein Teil ist der Klassencode und der zweite Teil sind die Objektdaten. Mit demselben Code können wir nach Veröffentlichung des Codes viele Verträge erstellen, die sich im Wesentlichen gleich verhalten, jedoch unterschiedliche Einstellungen aufweisen und mit einem anderen Zustand.  Wenn wir weiter reden, dann geht es bereits um Blockchain und nicht um das Thema dieser Geschichte. <br><br><h2>  Und so führen wir GO aus </h2><br>  Wir haben uns für den Plugin-Mechanismus entschieden, der nicht nur fertig und gut ist.  Er führt Folgendes aus: Wir kompilieren ein Plugin auf besondere Weise in eine gemeinsam genutzte Bibliothek, laden es dann, suchen die darin enthaltenen Symbole und übergeben dort die Ausführung.  Aber der Haken ist, dass GO eine Laufzeit hat, und dies ist fast ein Megabyte Code, und standardmäßig geht diese Laufzeit auch in diese Bibliothek, und wir haben überall eine Raznipipenny-Laufzeit.  Aber jetzt haben wir uns entschlossen, es zu versuchen und sicher zu sein, dass wir es in Zukunft besiegen können. <br><br>  Alles ist einfach, wenn Sie Ihre Bibliothek erstellen. Sie erstellen sie mit dem Schlüssel - buildmode = plugin und erhalten die .so-Datei, die Sie dann öffnen. <br><br><pre><code class="go hljs">p, err := plugin.Open(path)</code> </pre> <br>  Auf der Suche nach dem Charakter, an dem Sie interessiert sind: <br><br><pre> <code class="go hljs">symbol, err := p.Lookup(Method)</code> </pre> <br>  Und jetzt, je nachdem, ob die Variable eine Funktion oder eine Funktion ist, rufen Sie sie entweder auf oder verwenden sie als Variable. <br><br>  Unter der Haube dieses Mechanismus befindet sich ein einfaches dlopen (3). Wir laden die Bibliothek, überprüfen, ob es sich um ein Plugin handelt, und geben den Wrapper darüber. Beim Erstellen des Wrappers werden alle exportierten Zeichen in die Schnittstelle {} eingeschlossen und gespeichert.  Wenn es sich um eine Funktion handelt, muss sie auf den richtigen Funktionstyp reduziert und einfach aufgerufen werden, wenn die Variable - dann wie eine Variable funktioniert. <br><br>  Das Wichtigste ist, dass ein Symbol, wenn es sich um eine Variable handelt, während des gesamten Prozesses global ist und Sie es nicht gedankenlos verwenden können. <br><br>  Wenn im Plugin ein Typ deklariert wurde, ist es sinnvoll, diesen Typ in ein separates Paket zu stellen, damit der Hauptprozess damit arbeiten kann, z. B. als Argumente an die Funktionen des Plugins übergeben.  Dies ist optional, Sie können nicht dämpfen und Reflexion verwenden. <br><br>  Unsere Verträge sind Objekte der entsprechenden „Klasse“, und zu Beginn wurde die Instanz dieses Objekts in unserer exportierten Variablen gespeichert, sodass wir eine weitere Variable erstellen können: <br><br><pre> <code class="go hljs">export, err := p.Lookup(<span class="hljs-string"><span class="hljs-string">"EXPORT"</span></span>) obj := reflect.New(reflect.ValueOf(export).Elem().Type()).Interface()</code> </pre> <br>  Deserialisieren Sie bereits in dieser lokalen Variablen des richtigen Typs den Status des Objekts.  Nachdem das Objekt wiederhergestellt wurde, können wir Methoden dafür aufrufen.  Danach wird das Objekt serialisiert und wieder zum Store hinzugefügt. Prost, wir haben die Methode für den Vertrag aufgerufen. <br><br>  Wenn Sie daran interessiert sind, wie, aber zu faul, um die Dokumentation zu lesen, dann: <br><br><pre> <code class="go hljs">method := reflect.ValueOf(obj).MethodByName(Method) res:= method.Call(in)</code> </pre> <br>  In der Mitte müssen Sie das In-Array auch mit leeren Schnittstellen füllen, die den richtigen Argumenttyp enthalten. Wenn Sie interessiert sind, sehen Sie selbst, wie es gemacht wurde. Die Quellen sind offen, obwohl es schwierig sein wird, diesen Ort in der <a href="">Geschichte</a> zu finden. <br><br>  Im Allgemeinen hat alles für uns funktioniert. Sie können Code mit einer Klasse schreiben, ihn in die Blockchain einfügen, einen Vertrag dieser Klasse erneut in der Blockchain erstellen, einen Methodenaufruf darauf ausführen und den neuen Status des Vertrags in die Blockchain zurückschreiben.  Großartig!  Wie erstelle ich einen neuen Vertrag mit dem vorliegenden Code?  Sehr einfach, wir haben Konstruktorfunktionen, die ein frisch erstelltes Objekt zurückgeben, nämlich den neuen Vertrag.  Bisher funktioniert alles durch Reflexion und der Benutzer muss schreiben: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> EXPORT ContractType</code> </pre> <br>  Damit wir wissen, welches Symbol eine Darstellung des Vertrags ist, und es tatsächlich als Vorlage verwenden. <br><br>  Wir mögen es nicht wirklich.  Und wir haben hart getroffen. <br><br><h2>  Parsen </h2><br>  Erstens sollte der Benutzer nichts Überflüssiges schreiben, und zweitens haben wir die Idee, dass die Interaktion des Vertrags mit dem Vertrag einfach sein und getestet werden sollte, ohne die Blockchain zu erhöhen. Blockchain ist langsam und schwierig. <br><br>  Aus diesem Grund haben wir uns entschlossen, den Vertrag in einen Wrapper zu verpacken, der auf der Grundlage des Vertrags und der Wrapper-Vorlage im Prinzip eine verständliche Lösung darstellt.  Erstens erstellt der Wrapper ein Exportobjekt für uns und zweitens ersetzt er die Bibliothek, mit der der Vertrag erfasst wird, wenn der Benutzer den Vertrag schreibt, die Grundlagenbibliothek wird mit den darin enthaltenen Mokas verwendet und wenn der Vertrag veröffentlicht wird, wird er durch ein Kampfobjekt ersetzt, das mit der Blockchain selbst funktioniert . <br><br>  Um zu beginnen, müssen Sie den Code analysieren und verstehen, was wir im Allgemeinen haben, und die Struktur finden, die von BaseContract geerbt wird, um einen Wrapper um ihn herum zu generieren. <br><br>  Dies geschieht ganz einfach. Wir lesen die Datei mit dem Code in [] Byte. Obwohl der Parser selbst die Dateien lesen kann, ist es gut, den Text an einer Stelle zu haben, auf die sich alle AST-Elemente beziehen. Sie beziehen sich auf die Bytenummer in der Datei und in Zukunft möchten wir sie erhalten Den Strukturcode so wie er ist, nehmen wir einfach so etwas. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pf *ParsedFile)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">codeOfNode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n ast.Node)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>(pf.code[n.Pos()<span class="hljs-number"><span class="hljs-number">-1</span></span> : n.End()<span class="hljs-number"><span class="hljs-number">-1</span></span>]) }</code> </pre> <br>  Wir analysieren die Datei tatsächlich und erhalten den obersten AST-Knoten, von dem aus wir die Datei crawlen. <br><br><pre> <code class="go hljs">fileSet = token.NewFileSet() node, err := parser.ParseFile(fileSet, name, code, parser.ParseComments)</code> </pre> <br>  Als nächstes gehen wir vom obersten Knoten aus um den Code herum und sammeln alles Interessante in einer separaten Struktur. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, decl := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> node.Decls { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> d := decl.(<span class="hljs-keyword"><span class="hljs-keyword">type</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> *ast.GenDecl: … <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> *ast.FuncDecl: … } }</code> </pre> <br>  Decls, es wurde bereits in ein Array analysiert, eine Liste aller in der Datei definierten Elemente. Es handelt sich jedoch um ein Array von Decl-Schnittstellen, die nicht beschreiben, was sich darin befindet. Daher muss jedes Element in einen bestimmten Typ konvertiert werden. Die Schnittstelle in go / ast ist eher eine Basisklasse. <br><br>  Wir interessieren uns für Knoten vom Typ GenDecl und FuncDecl.  GenDecl ist die Definition einer Variablen oder eines Typs. Sie müssen überprüfen, was genau der Typ darin ist, und ihn erneut in den TypeDecl-Typ umwandeln, mit dem Sie bereits arbeiten können.  FuncDecl ist einfacher - es ist eine Funktion, und wenn das Recv-Feld ausgefüllt ist, ist dies eine Methode der entsprechenden Struktur.  Wir sammeln all diese Dinge in einem praktischen Speicher, weil wir dann Text / Vorlage verwenden und es nicht viel Ausdruckskraft hat. <br><br>  Das einzige, woran wir uns separat erinnern müssen, ist der Name des Datentyps, der von BaseContract geerbt wird, und wir werden darum herum tanzen. <br><br><h2>  Codegenerierung </h2><br>  Daher kennen wir alle Typen und Funktionen, die in unserem Vertrag enthalten sind, und müssen in der Lage sein, einen Methodenaufruf für ein Objekt aus dem Namen der eingehenden Methode und dem serialisierten Array von Argumenten durchzuführen.  Zum Zeitpunkt der Codegenerierung kennen wir jedoch das gesamte Gerät des Vertrags. Daher stellen wir neben unsere Vertragsdatei neben eine andere Datei mit demselben Paketnamen, in die wir alle erforderlichen Importe einfügen. Die Typen sind bereits in der Hauptdatei definiert und nicht erforderlich. <br><br>  Und hier ist die Hauptsache, Wrapper über Funktionen.  Der Name des Wrappers wird durch eine Art Präfix ergänzt, und jetzt ist der Wrapper leicht zu finden. <br><br><pre> <code class="go hljs">symbol, err := p.Lookup(<span class="hljs-string"><span class="hljs-string">"INSMETHOD_"</span></span> + Method) wrapper, ok := symbol.(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ph proxyctx.ProxyHelper, object []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">, data []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(object []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">, result []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">, err error)</span></span></span><span class="hljs-function">)</span></span></code> </pre><br>  Jeder Wrapper hat dieselbe Signatur. Wenn wir ihn also vom Hauptprogramm aus aufrufen, benötigen wir keine zusätzlichen Überlegungen. Das einzige ist, dass sich die Funktions-Wrapper von den Methoden-Wrappern unterscheiden. Sie empfangen den Status des Objekts nicht und geben ihn nicht zurück. <br><br>  Was haben wir in der Hülle? <br><br>  Wir erstellen ein Array von leeren Variablen, die den Argumenten der Funktion entsprechen, fügen es in eine Variable vom Typ eines Arrays von Schnittstellen ein und deserialisieren die Argumente darin. Wenn wir eine Methode sind, müssen wir auch den Status des Objekts serialisieren, im Allgemeinen ungefähr so: <br><br><pre> <code class="go hljs">{{ <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> $method := .Methods }} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">INSMETHOD_</span></span></span></span>{{ $method.Name }}(ph proxyctx.ProxyHelper, object []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>, data []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) ([]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>, []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>, error) { self := <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>({{ $.ContractType }}) err := ph.Deserialize(object, self) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, err } {{ $method.ArgumentsZeroList }} err = ph.Deserialize(data, &amp;args) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, err } {{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> $method.Results }} {{ $method.Results }} := self.{{ $method.Name }}( {{ $method.Arguments }} ) {{ <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> }} self.{{ $method.Name }}( {{ $method.Arguments }} ) {{ end }} state := []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>{} err = ph.Serialize(self, &amp;state) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, err } {{ <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> $i := $method.ErrorInterfaceInRes }} ret{{ $i }} = ph.MakeErrorSerializable(ret{{ $i }}) {{ end }} ret := []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>{} err = ph.Serialize([]<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{} { {{ $method.Results }} }, &amp;ret) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> state, ret, err } {{ end }}</code> </pre><br>  Ein aufmerksamer Leser wird sich dafür interessieren, was ein Proxy-Helfer ist.  - Dies ist ein solches Kombinationsobjekt, das wir noch benötigen, aber im Moment nutzen wir seine Fähigkeit zum Serialisieren und Deserialisieren. <br><br>  Nun, jeder, der liest, wird fragen: "Aber das sind Ihre Argumente, woher kommen sie?"  Hier ist auch eine verständliche Antwort: Ja, Text / Vorlage, es gibt nicht genügend Sterne vom Himmel. Deshalb berechnen wir diese Zeilen im Code und nicht in der Vorlage. <br><br>  method.ArgumentsZeroList enthält so etwas wie <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> arg0 <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span> Var arg1 <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> = “” Var arg2 ackwardType = ackwardType{} Args := []<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}{&amp;arg0, &amp;arg1, &amp;arg2}</code> </pre> <br>  Und Argumente enthalten dementsprechend "arg0, arg1, arg2". <br><br>  So können wir mit jeder Unterschrift alles aufrufen, was wir wollen. <br><br>  Wir können jedoch keine Antwort serialisieren. Tatsache ist, dass Serialisierer mit Reflexion arbeiten und keinen Zugriff auf nicht exportierte Felder von Strukturen gewähren. Deshalb haben wir eine spezielle Proxy-Hilfsmethode, die ein Fehlerschnittstellenobjekt verwendet und daraus ein Objekt vom Typ Fundament erstellt. Fehler, der sich vom üblichen dadurch unterscheidet, dass sich der Fehlertext im exportierten Feld befindet und wir ihn serialisieren können, wenn auch mit einigem Verlust. <br><br>  Wenn wir jedoch einen sterilisierenden Sterilisator verwenden, brauchen wir ihn nicht einmal. Wir sind in demselben Paket kompiliert und haben Zugriff auf nicht exportierte Felder. <br><br><h2>  Aber was ist, wenn wir einen Vertrag von einem Vertrag abrufen wollen? </h2><br>  Sie verstehen die Tiefe des Problems nicht, wenn Sie der Meinung sind, dass es einfach ist, einen Vertrag von einem Vertrag abzurufen.  Tatsache ist, dass die Gültigkeit eines anderen Vertrags durch Konsens bestätigt werden muss und die Tatsache dieses Aufrufs in der Blockchain unterschrieben werden muss. Im Allgemeinen funktioniert es nicht, einfach mit einem anderen Vertrag zu kompilieren und dessen Methode aufzurufen, obwohl ich es wirklich möchte.  Aber wir sind Freunde von Programmierern, deshalb sollten wir ihnen die Möglichkeit geben, alles direkt zu tun und alle Tricks unter der Haube des Systems zu verstecken.  Die Vertragsentwicklung ist also wie bei direkten Anrufen, und die Verträge ziehen sich transparent aneinander. Wenn wir jedoch den Vertrag zur Veröffentlichung abholen, schieben wir einen Proxy anstelle eines anderen Vertrags, der nur dessen Adresse und Anrufsignaturen über den Vertrag kennt. <br><br>  Wie organisiert man das alles?  - Wir müssen andere Verträge in einem speziellen Verzeichnis speichern, damit unser Generator Proxys für jeden importierten Vertrag erkennen und erstellen kann. <br><br>  Das heißt, wenn wir uns trafen: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> “ContractsDir/ContractAddress<span class="hljs-string"><span class="hljs-string">"</span></span></code> </pre> <br>  Wir schreiben es in die Liste der importierten Verträge. <br><br>  Übrigens, dafür müssen Sie den Quellcode des Vertrags nicht kennen, Sie müssen nur die Beschreibung kennen, die wir bereits zusammengestellt haben. Wenn wir also irgendwo eine solche Beschreibung veröffentlichen und alle Anrufe über das Hauptsystem laufen, ist es uns egal, was Ein anderer Vertrag ist in der Sprache geschrieben. Wenn wir Methoden darauf aufrufen können, können wir auf Go einen Stub dafür schreiben, der wie ein Paket mit einem Vertrag aussieht, der direkt aufgerufen werden kann.  Napoleonische Pläne, fangen wir an. <br><br>  Grundsätzlich haben wir bereits eine Proxy-Helfer-Methode mit dieser Signatur: <br><br><pre> <code class="go hljs">RouteCall(ref Address, method <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, args []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) ([]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>, error)</code> </pre> <br>  Diese Methode kann direkt aus dem Vertrag aufgerufen werden. Sie ruft den Remote-Vertrag auf und gibt eine serialisierte Antwort zurück, die wir analysieren und zu unserem Vertrag zurückkehren müssen. <br><br>  Für den Benutzer muss jedoch alles so aussehen: <br><br><pre> <code class="go hljs">ret := contractPackage.GetObject(Address).Method(arg1,arg2, …)</code> </pre> <br>  Beginnen wir zunächst im Proxy. Sie müssen alle Typen auflisten, die in den Signaturen der Vertragsmethoden verwendet werden. Wie wir uns jedoch erinnern, können wir für jeden AST-Knoten seine Textdarstellung verwenden, und jetzt ist die Zeit für diesen Mechanismus gekommen. <br><br>  Als nächstes müssen wir eine Art Vertrag erstellen, im Prinzip kennt er seine Klasse bereits, nur eine Adresse wird benötigt. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> {{ .ContractType }} <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Reference Address }</code> </pre> <br>  Als nächstes müssen wir irgendwie die GetObject-Funktion implementieren, die an der Adresse in der Blockchain eine Proxy-Instanz zurückgibt, die weiß, wie man mit diesem Vertrag arbeitet, und für den Benutzer sieht sie wie eine Vertragsinstanz aus. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetObject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ref Address)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r *{{ .ContractType }})</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;{{ .ContractType }}{Reference: ref} }</code> </pre> <br>  Interessanterweise ist die GetObject-Methode im Benutzer-Debugging-Modus direkt eine BaseContract-Strukturmethode, aber nichts hindert uns daran, die SLA zu beachten, um das zu tun, was für uns bequem ist.  Jetzt können wir einen Proxy-Vertrag erstellen, dessen Methoden wir steuern.  Es bleibt tatsächlich Methoden zu erstellen. <br><br><pre> <code class="go hljs">{{ <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> $method := .MethodsProxies }} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r *{{ $.ContractType }})</span></span></span></span> {{ $method.Name }}( {{ $method.Arguments }} ) ( {{ $method.ResultsTypes }} ) { {{ $method.InitArgs }} <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> argsSerialized []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> err := proxyctx.Current.Serialize(args, &amp;argsSerialized) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">panic</span></span>(err) } res, err := proxyctx.Current.RouteCall(r.Reference, <span class="hljs-string"><span class="hljs-string">"{{ $method.Name }}"</span></span>, argsSerialized) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">panic</span></span>(err) } {{ $method.ResultZeroList }} err = proxyctx.Current.Deserialize(res, &amp;resList) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">panic</span></span>(err) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {{ $method.Results }} } {{ end }}</code> </pre> <br>  Hier die gleiche Geschichte mit der Konstruktion der Argumentliste, da wir faul sind und genau den ast.Node der Methode speichern, werden für Berechnungen viele Typkonvertierungen benötigt, die die Vorlagen nicht kennen, sodass alles im Voraus vorbereitet wird.  Mit Funktionen ist alles sehr viel komplizierter, und dies ist das Thema eines anderen Artikels. <br><br>  Die Funktionen, die wir haben, sind Objektkonstruktoren, und es wird viel Wert darauf gelegt, wie Objekte tatsächlich in unserem System erstellt werden. Die Tatsache der Erstellung wird auf einem Remote-Executor registriert, das Objekt wird auf einen anderen Executor übertragen, es wird dort überprüft und tatsächlich gespeichert, und es gibt viele Möglichkeiten, vergeblich zu speichern Dieser Wissensbereich wird Krypta genannt.  Und die Idee ist im Grunde einfach: ein Wrapper, in dem nur die Adresse gespeichert ist, und Methoden, die den Aufruf serialisieren und unseren Singleton-Prozessor ziehen, der den Rest erledigt.  Wir können den übertragenen Proxy-Helfer nicht verwenden, da der Benutzer ihn nicht an uns weitergegeben hat. Daher mussten wir ihn zu einem Singleton machen. <br><br>  Ein weiterer Trick: Tatsächlich verwenden wir immer noch den Aufrufkontext. Dies ist ein solches Objekt, das Informationen darüber speichert, wer, wann, warum, warum unser intelligenter Vertrag aufgerufen wurde. Auf der Grundlage dieser Informationen trifft der Benutzer eine Entscheidung, ob er überhaupt eine Ausführung geben möchte, und wenn möglich dann wie. <br><br>  Zuvor haben wir den Kontext einfach übergeben. Es war ein nicht ausdrückbares Feld im BaseContract-Typ mit einem Setter und einem Getter, und der Setter erlaubte, das Feld nur einmal festzulegen, sodass der Kontext festgelegt wurde, bevor der Vertrag ausgeführt wurde, und der Benutzer ihn nur lesen konnte. <br><br>  Aber hier ist das Problem: Der Benutzer liest diesen Kontext nur. Wenn er eine Systemfunktion aufruft, z. B. einen Proxy-Aufruf an einen anderen Vertrag, erhält dieser Proxy-Aufruf keinen Kontext, da ihn niemand weiterleitet.  Und dann betritt der lokale Goroutine-Speicher die Szene.  Wir haben uns entschieden, keine eigenen zu schreiben, sondern github.com/tylerb/gls zu verwenden. <br><br>  Hier können Sie den Kontext für die aktuelle Goroutine festlegen und übernehmen.  Wenn also innerhalb des Vertrags keine Goroutine erstellt wurde, setzen wir den Kontext nur in gls, bevor wir den Vertrag starten. Jetzt geben wir dem Benutzer keine Methode, sondern nur eine Funktion. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetContext</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">core</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LogicCallContext</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> gls.Get(<span class="hljs-string"><span class="hljs-string">"ctx"</span></span>).(*core.LogicCallContext) }</code> </pre> <br>  Und er verwendet es gerne, aber wir verwenden es beispielsweise in RouteCall (), um zu verstehen, welcher Vertrag gerade jemanden aufruft. <br><br>  Im Prinzip kann der Benutzer eine Goroutine erstellen. Wenn dies jedoch der Fall ist, geht der Kontext verloren. Daher müssen wir etwas damit tun. Wenn der Benutzer beispielsweise das Schlüsselwort go verwendet, müssen wir solche Aufrufe in unseren Wrapper einschließen, an den sich der Kontext erinnert und die er erstellt goroutine und stelle den Kontext darin wieder her, aber dies ist das Thema eines anderen Artikels. <br><br><h2>  Alle zusammen </h2><br>  Grundsätzlich gefällt uns, wie die GO-Sprach-Toolchain funktioniert. Tatsächlich sind es eine Reihe verschiedener Befehle, die eine Sache ausführen, die beispielsweise beim Erstellen zusammen ausgeführt werden.  Wir haben uns dazu entschlossen, ein Team legt eine Vertragsdatei in einem temporären Verzeichnis ab, das zweite legt einen Wrapper dafür ab und ruft ein drittes Mal auf, wodurch ein Proxy für jeden importierten Vertrag erstellt wird, das vierte kompiliert alles, das fünfte veröffentlicht es in der Blockchain.  Und es gibt einen Befehl, um sie alle in der richtigen Reihenfolge auszuführen. <br><br>  Hurra, wir haben jetzt eine Toolchain und eine Laufzeit zum Starten von GO from GO.  Es gibt immer noch viele Probleme, zum Beispiel müssen Sie nicht verwendeten Code irgendwie entladen, Sie müssen irgendwie feststellen, dass er hängt, und den angehaltenen Prozess neu starten, aber dies sind Aufgaben, die klar sind, wie man ihn löst. <br><br>  Ja, natürlich gibt der Code, den wir geschrieben haben, nicht vor, eine Bibliothek zu sein, er kann nicht direkt verwendet werden, aber das Lesen eines Beispiels für die Generierung von Arbeitscode ist immer großartig, einmal habe ich ihn verpasst.  Dementsprechend kann ein Teil der Codegenerierung im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Compiler</a> angezeigt werden, aber wie er im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Executor</a> startet. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de425985/">https://habr.com/ru/post/de425985/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de425973/index.html">Wie wir S3 DataLine-Speicher erstellt haben. Experimente, Tests und ein wenig über Flusspferde</a></li>
<li><a href="../de425975/index.html">Konvertieren Sie Wörter und Phrasen in Anagramme</a></li>
<li><a href="../de425977/index.html">Flexbox: Wie groß ist diese flexible Box?</a></li>
<li><a href="../de425981/index.html">Newbies Karriere bei LK: Springt und springt langsam vorwärts</a></li>
<li><a href="../de425983/index.html">Flugsicherheit</a></li>
<li><a href="../de425989/index.html">Unter der Haube von Graveyard Keeper: Wie grafische Effekte implementiert werden</a></li>
<li><a href="../de425991/index.html">Wie wir Hosting erstellt haben</a></li>
<li><a href="../de425993/index.html">Wie man die geschlechtsspezifische Kluft in der Technologie überbrückt</a></li>
<li><a href="../de425995/index.html">Visualisieren Sie FHIR - den IT-Standard für die Medizin</a></li>
<li><a href="../de425997/index.html">MIT-Kurs "Computer Systems Security". Vorlesung 11: Ur / Web-Programmiersprache, Teil 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>