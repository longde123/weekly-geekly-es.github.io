<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚èØÔ∏è üíé üë∏üèº Benutzerdefinierte Codeausf√ºhrung auf GO ü§î üëßüèΩ üà¥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hier geht es eigentlich nur um intelligente Vertr√§ge. 
 Wenn Sie sich jedoch nicht genau vorstellen k√∂nnen, was ein intelligenter Vertrag ist und im A...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Benutzerdefinierte Codeausf√ºhrung auf GO</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425985/"><h2>  Hier geht es eigentlich nur um intelligente Vertr√§ge. </h2><br>  Wenn Sie sich jedoch nicht genau vorstellen k√∂nnen, was ein intelligenter Vertrag ist und im Allgemeinen weit von Krypto entfernt ist, k√∂nnen Sie sich vorstellen, was eine in einer Datenbank gespeicherte Prozedur ist.  Der Benutzer erstellt Codeteile, die dann auf unserem Server funktionieren.  Es ist f√ºr den Benutzer bequem, sie zu schreiben und zu ver√∂ffentlichen, und f√ºr uns ist es sicher, sie auszuf√ºhren. <br><a name="habracut"></a><br>  Leider haben wir noch keine Sicherheit entwickelt, daher werde ich sie jetzt nicht beschreiben, aber ich werde ein paar Hinweise geben. <br><br>  Wir schreiben auch auf Go, und seine Laufzeit unterliegt einigen sehr spezifischen Einschr√§nkungen. Die wichtigste davon ist, dass wir im Gro√üen und Ganzen keine Verkn√ºpfung zu einem anderen Projekt herstellen k√∂nnen, das nicht unterwegs geschrieben wurde. Dadurch wird unsere Laufzeit jedes Mal gestoppt, wenn wir Code von Drittanbietern ausf√ºhren.  Im Allgemeinen haben wir die M√∂glichkeit, eine Art Dolmetscher zu verwenden, f√ºr den wir eine v√∂llig gesunde Lua und eine v√∂llig gesunde WASM gefunden haben, aber irgendwie m√∂chte ich Lua keine Kunden hinzuf√ºgen, aber mit WASM gibt es jetzt mehr Probleme als Vorteile, es befindet sich in einem Entwurfszustand , die jeden Monat aktualisiert wird, also warten wir, bis sich die Spezifikation beruhigt hat.  Wir benutzen es als zweiten Motor. <br><br>  Aufgrund langwieriger K√§mpfe mit seinem eigenen Gewissen wurde beschlossen, intelligente Vertr√§ge √ºber GO abzuschlie√üen.  Tatsache ist, dass Sie, wenn Sie die Architektur f√ºr die Ausf√ºhrung von kompiliertem GO-Code erstellen, diese Ausf√ºhrung aus Sicherheitsgr√ºnden auf einen separaten Prozess √ºbertragen m√ºssen, wie Sie sich erinnern, und die √úbertragung auf einen separaten Prozess einen Leistungsverlust f√ºr IPC darstellt, obwohl wir in Zukunft das Volumen der ausf√ºhrbaren Datei verstanden haben Code, es war sogar irgendwie angenehm, dass wir diese L√∂sung gew√§hlt haben.  Die Sache ist, dass es skalierbar ist, obwohl es jedem einzelnen Anruf eine Verz√∂gerung hinzuf√ºgt.  Wir k√∂nnen viele entfernte Laufzeiten erh√∂hen. <br><br>  Ein bisschen mehr √ºber die Entscheidungen, die getroffen wurden, damit es klar ist.  Jeder Smart-Vertrag besteht aus zwei Teilen, ein Teil ist der Klassencode und der zweite Teil sind die Objektdaten. Mit demselben Code k√∂nnen wir nach Ver√∂ffentlichung des Codes viele Vertr√§ge erstellen, die sich im Wesentlichen gleich verhalten, jedoch unterschiedliche Einstellungen aufweisen und mit einem anderen Zustand.  Wenn wir weiter reden, dann geht es bereits um Blockchain und nicht um das Thema dieser Geschichte. <br><br><h2>  Und so f√ºhren wir GO aus </h2><br>  Wir haben uns f√ºr den Plugin-Mechanismus entschieden, der nicht nur fertig und gut ist.  Er f√ºhrt Folgendes aus: Wir kompilieren ein Plugin auf besondere Weise in eine gemeinsam genutzte Bibliothek, laden es dann, suchen die darin enthaltenen Symbole und √ºbergeben dort die Ausf√ºhrung.  Aber der Haken ist, dass GO eine Laufzeit hat, und dies ist fast ein Megabyte Code, und standardm√§√üig geht diese Laufzeit auch in diese Bibliothek, und wir haben √ºberall eine Raznipipenny-Laufzeit.  Aber jetzt haben wir uns entschlossen, es zu versuchen und sicher zu sein, dass wir es in Zukunft besiegen k√∂nnen. <br><br>  Alles ist einfach, wenn Sie Ihre Bibliothek erstellen. Sie erstellen sie mit dem Schl√ºssel - buildmode = plugin und erhalten die .so-Datei, die Sie dann √∂ffnen. <br><br><pre><code class="go hljs">p, err := plugin.Open(path)</code> </pre> <br>  Auf der Suche nach dem Charakter, an dem Sie interessiert sind: <br><br><pre> <code class="go hljs">symbol, err := p.Lookup(Method)</code> </pre> <br>  Und jetzt, je nachdem, ob die Variable eine Funktion oder eine Funktion ist, rufen Sie sie entweder auf oder verwenden sie als Variable. <br><br>  Unter der Haube dieses Mechanismus befindet sich ein einfaches dlopen (3). Wir laden die Bibliothek, √ºberpr√ºfen, ob es sich um ein Plugin handelt, und geben den Wrapper dar√ºber. Beim Erstellen des Wrappers werden alle exportierten Zeichen in die Schnittstelle {} eingeschlossen und gespeichert.  Wenn es sich um eine Funktion handelt, muss sie auf den richtigen Funktionstyp reduziert und einfach aufgerufen werden, wenn die Variable - dann wie eine Variable funktioniert. <br><br>  Das Wichtigste ist, dass ein Symbol, wenn es sich um eine Variable handelt, w√§hrend des gesamten Prozesses global ist und Sie es nicht gedankenlos verwenden k√∂nnen. <br><br>  Wenn im Plugin ein Typ deklariert wurde, ist es sinnvoll, diesen Typ in ein separates Paket zu stellen, damit der Hauptprozess damit arbeiten kann, z. B. als Argumente an die Funktionen des Plugins √ºbergeben.  Dies ist optional, Sie k√∂nnen nicht d√§mpfen und Reflexion verwenden. <br><br>  Unsere Vertr√§ge sind Objekte der entsprechenden ‚ÄûKlasse‚Äú, und zu Beginn wurde die Instanz dieses Objekts in unserer exportierten Variablen gespeichert, sodass wir eine weitere Variable erstellen k√∂nnen: <br><br><pre> <code class="go hljs">export, err := p.Lookup(<span class="hljs-string"><span class="hljs-string">"EXPORT"</span></span>) obj := reflect.New(reflect.ValueOf(export).Elem().Type()).Interface()</code> </pre> <br>  Deserialisieren Sie bereits in dieser lokalen Variablen des richtigen Typs den Status des Objekts.  Nachdem das Objekt wiederhergestellt wurde, k√∂nnen wir Methoden daf√ºr aufrufen.  Danach wird das Objekt serialisiert und wieder zum Store hinzugef√ºgt. Prost, wir haben die Methode f√ºr den Vertrag aufgerufen. <br><br>  Wenn Sie daran interessiert sind, wie, aber zu faul, um die Dokumentation zu lesen, dann: <br><br><pre> <code class="go hljs">method := reflect.ValueOf(obj).MethodByName(Method) res:= method.Call(in)</code> </pre> <br>  In der Mitte m√ºssen Sie das In-Array auch mit leeren Schnittstellen f√ºllen, die den richtigen Argumenttyp enthalten. Wenn Sie interessiert sind, sehen Sie selbst, wie es gemacht wurde. Die Quellen sind offen, obwohl es schwierig sein wird, diesen Ort in der <a href="">Geschichte</a> zu finden. <br><br>  Im Allgemeinen hat alles f√ºr uns funktioniert. Sie k√∂nnen Code mit einer Klasse schreiben, ihn in die Blockchain einf√ºgen, einen Vertrag dieser Klasse erneut in der Blockchain erstellen, einen Methodenaufruf darauf ausf√ºhren und den neuen Status des Vertrags in die Blockchain zur√ºckschreiben.  Gro√üartig!  Wie erstelle ich einen neuen Vertrag mit dem vorliegenden Code?  Sehr einfach, wir haben Konstruktorfunktionen, die ein frisch erstelltes Objekt zur√ºckgeben, n√§mlich den neuen Vertrag.  Bisher funktioniert alles durch Reflexion und der Benutzer muss schreiben: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> EXPORT ContractType</code> </pre> <br>  Damit wir wissen, welches Symbol eine Darstellung des Vertrags ist, und es tats√§chlich als Vorlage verwenden. <br><br>  Wir m√∂gen es nicht wirklich.  Und wir haben hart getroffen. <br><br><h2>  Parsen </h2><br>  Erstens sollte der Benutzer nichts √úberfl√ºssiges schreiben, und zweitens haben wir die Idee, dass die Interaktion des Vertrags mit dem Vertrag einfach sein und getestet werden sollte, ohne die Blockchain zu erh√∂hen. Blockchain ist langsam und schwierig. <br><br>  Aus diesem Grund haben wir uns entschlossen, den Vertrag in einen Wrapper zu verpacken, der auf der Grundlage des Vertrags und der Wrapper-Vorlage im Prinzip eine verst√§ndliche L√∂sung darstellt.  Erstens erstellt der Wrapper ein Exportobjekt f√ºr uns und zweitens ersetzt er die Bibliothek, mit der der Vertrag erfasst wird, wenn der Benutzer den Vertrag schreibt, die Grundlagenbibliothek wird mit den darin enthaltenen Mokas verwendet und wenn der Vertrag ver√∂ffentlicht wird, wird er durch ein Kampfobjekt ersetzt, das mit der Blockchain selbst funktioniert . <br><br>  Um zu beginnen, m√ºssen Sie den Code analysieren und verstehen, was wir im Allgemeinen haben, und die Struktur finden, die von BaseContract geerbt wird, um einen Wrapper um ihn herum zu generieren. <br><br>  Dies geschieht ganz einfach. Wir lesen die Datei mit dem Code in [] Byte. Obwohl der Parser selbst die Dateien lesen kann, ist es gut, den Text an einer Stelle zu haben, auf die sich alle AST-Elemente beziehen. Sie beziehen sich auf die Bytenummer in der Datei und in Zukunft m√∂chten wir sie erhalten Den Strukturcode so wie er ist, nehmen wir einfach so etwas. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pf *ParsedFile)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">codeOfNode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n ast.Node)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>(pf.code[n.Pos()<span class="hljs-number"><span class="hljs-number">-1</span></span> : n.End()<span class="hljs-number"><span class="hljs-number">-1</span></span>]) }</code> </pre> <br>  Wir analysieren die Datei tats√§chlich und erhalten den obersten AST-Knoten, von dem aus wir die Datei crawlen. <br><br><pre> <code class="go hljs">fileSet = token.NewFileSet() node, err := parser.ParseFile(fileSet, name, code, parser.ParseComments)</code> </pre> <br>  Als n√§chstes gehen wir vom obersten Knoten aus um den Code herum und sammeln alles Interessante in einer separaten Struktur. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, decl := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> node.Decls { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> d := decl.(<span class="hljs-keyword"><span class="hljs-keyword">type</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> *ast.GenDecl: ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> *ast.FuncDecl: ‚Ä¶ } }</code> </pre> <br>  Decls, es wurde bereits in ein Array analysiert, eine Liste aller in der Datei definierten Elemente. Es handelt sich jedoch um ein Array von Decl-Schnittstellen, die nicht beschreiben, was sich darin befindet. Daher muss jedes Element in einen bestimmten Typ konvertiert werden. Die Schnittstelle in go / ast ist eher eine Basisklasse. <br><br>  Wir interessieren uns f√ºr Knoten vom Typ GenDecl und FuncDecl.  GenDecl ist die Definition einer Variablen oder eines Typs. Sie m√ºssen √ºberpr√ºfen, was genau der Typ darin ist, und ihn erneut in den TypeDecl-Typ umwandeln, mit dem Sie bereits arbeiten k√∂nnen.  FuncDecl ist einfacher - es ist eine Funktion, und wenn das Recv-Feld ausgef√ºllt ist, ist dies eine Methode der entsprechenden Struktur.  Wir sammeln all diese Dinge in einem praktischen Speicher, weil wir dann Text / Vorlage verwenden und es nicht viel Ausdruckskraft hat. <br><br>  Das einzige, woran wir uns separat erinnern m√ºssen, ist der Name des Datentyps, der von BaseContract geerbt wird, und wir werden darum herum tanzen. <br><br><h2>  Codegenerierung </h2><br>  Daher kennen wir alle Typen und Funktionen, die in unserem Vertrag enthalten sind, und m√ºssen in der Lage sein, einen Methodenaufruf f√ºr ein Objekt aus dem Namen der eingehenden Methode und dem serialisierten Array von Argumenten durchzuf√ºhren.  Zum Zeitpunkt der Codegenerierung kennen wir jedoch das gesamte Ger√§t des Vertrags. Daher stellen wir neben unsere Vertragsdatei neben eine andere Datei mit demselben Paketnamen, in die wir alle erforderlichen Importe einf√ºgen. Die Typen sind bereits in der Hauptdatei definiert und nicht erforderlich. <br><br>  Und hier ist die Hauptsache, Wrapper √ºber Funktionen.  Der Name des Wrappers wird durch eine Art Pr√§fix erg√§nzt, und jetzt ist der Wrapper leicht zu finden. <br><br><pre> <code class="go hljs">symbol, err := p.Lookup(<span class="hljs-string"><span class="hljs-string">"INSMETHOD_"</span></span> + Method) wrapper, ok := symbol.(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ph proxyctx.ProxyHelper, object []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">, data []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(object []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">, result []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">, err error)</span></span></span><span class="hljs-function">)</span></span></code> </pre><br>  Jeder Wrapper hat dieselbe Signatur. Wenn wir ihn also vom Hauptprogramm aus aufrufen, ben√∂tigen wir keine zus√§tzlichen √úberlegungen. Das einzige ist, dass sich die Funktions-Wrapper von den Methoden-Wrappern unterscheiden. Sie empfangen den Status des Objekts nicht und geben ihn nicht zur√ºck. <br><br>  Was haben wir in der H√ºlle? <br><br>  Wir erstellen ein Array von leeren Variablen, die den Argumenten der Funktion entsprechen, f√ºgen es in eine Variable vom Typ eines Arrays von Schnittstellen ein und deserialisieren die Argumente darin. Wenn wir eine Methode sind, m√ºssen wir auch den Status des Objekts serialisieren, im Allgemeinen ungef√§hr so: <br><br><pre> <code class="go hljs">{{ <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> $method := .Methods }} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">INSMETHOD_</span></span></span></span>{{ $method.Name }}(ph proxyctx.ProxyHelper, object []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>, data []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) ([]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>, []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>, error) { self := <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>({{ $.ContractType }}) err := ph.Deserialize(object, self) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, err } {{ $method.ArgumentsZeroList }} err = ph.Deserialize(data, &amp;args) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, err } {{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> $method.Results }} {{ $method.Results }} := self.{{ $method.Name }}( {{ $method.Arguments }} ) {{ <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> }} self.{{ $method.Name }}( {{ $method.Arguments }} ) {{ end }} state := []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>{} err = ph.Serialize(self, &amp;state) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, err } {{ <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> $i := $method.ErrorInterfaceInRes }} ret{{ $i }} = ph.MakeErrorSerializable(ret{{ $i }}) {{ end }} ret := []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>{} err = ph.Serialize([]<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{} { {{ $method.Results }} }, &amp;ret) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> state, ret, err } {{ end }}</code> </pre><br>  Ein aufmerksamer Leser wird sich daf√ºr interessieren, was ein Proxy-Helfer ist.  - Dies ist ein solches Kombinationsobjekt, das wir noch ben√∂tigen, aber im Moment nutzen wir seine F√§higkeit zum Serialisieren und Deserialisieren. <br><br>  Nun, jeder, der liest, wird fragen: "Aber das sind Ihre Argumente, woher kommen sie?"  Hier ist auch eine verst√§ndliche Antwort: Ja, Text / Vorlage, es gibt nicht gen√ºgend Sterne vom Himmel. Deshalb berechnen wir diese Zeilen im Code und nicht in der Vorlage. <br><br>  method.ArgumentsZeroList enth√§lt so etwas wie <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> arg0 <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span> Var arg1 <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> = ‚Äú‚Äù Var arg2 ackwardType = ackwardType{} Args := []<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}{&amp;arg0, &amp;arg1, &amp;arg2}</code> </pre> <br>  Und Argumente enthalten dementsprechend "arg0, arg1, arg2". <br><br>  So k√∂nnen wir mit jeder Unterschrift alles aufrufen, was wir wollen. <br><br>  Wir k√∂nnen jedoch keine Antwort serialisieren. Tatsache ist, dass Serialisierer mit Reflexion arbeiten und keinen Zugriff auf nicht exportierte Felder von Strukturen gew√§hren. Deshalb haben wir eine spezielle Proxy-Hilfsmethode, die ein Fehlerschnittstellenobjekt verwendet und daraus ein Objekt vom Typ Fundament erstellt. Fehler, der sich vom √ºblichen dadurch unterscheidet, dass sich der Fehlertext im exportierten Feld befindet und wir ihn serialisieren k√∂nnen, wenn auch mit einigem Verlust. <br><br>  Wenn wir jedoch einen sterilisierenden Sterilisator verwenden, brauchen wir ihn nicht einmal. Wir sind in demselben Paket kompiliert und haben Zugriff auf nicht exportierte Felder. <br><br><h2>  Aber was ist, wenn wir einen Vertrag von einem Vertrag abrufen wollen? </h2><br>  Sie verstehen die Tiefe des Problems nicht, wenn Sie der Meinung sind, dass es einfach ist, einen Vertrag von einem Vertrag abzurufen.  Tatsache ist, dass die G√ºltigkeit eines anderen Vertrags durch Konsens best√§tigt werden muss und die Tatsache dieses Aufrufs in der Blockchain unterschrieben werden muss. Im Allgemeinen funktioniert es nicht, einfach mit einem anderen Vertrag zu kompilieren und dessen Methode aufzurufen, obwohl ich es wirklich m√∂chte.  Aber wir sind Freunde von Programmierern, deshalb sollten wir ihnen die M√∂glichkeit geben, alles direkt zu tun und alle Tricks unter der Haube des Systems zu verstecken.  Die Vertragsentwicklung ist also wie bei direkten Anrufen, und die Vertr√§ge ziehen sich transparent aneinander. Wenn wir jedoch den Vertrag zur Ver√∂ffentlichung abholen, schieben wir einen Proxy anstelle eines anderen Vertrags, der nur dessen Adresse und Anrufsignaturen √ºber den Vertrag kennt. <br><br>  Wie organisiert man das alles?  - Wir m√ºssen andere Vertr√§ge in einem speziellen Verzeichnis speichern, damit unser Generator Proxys f√ºr jeden importierten Vertrag erkennen und erstellen kann. <br><br>  Das hei√üt, wenn wir uns trafen: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ‚ÄúContractsDir/ContractAddress<span class="hljs-string"><span class="hljs-string">"</span></span></code> </pre> <br>  Wir schreiben es in die Liste der importierten Vertr√§ge. <br><br>  √úbrigens, daf√ºr m√ºssen Sie den Quellcode des Vertrags nicht kennen, Sie m√ºssen nur die Beschreibung kennen, die wir bereits zusammengestellt haben. Wenn wir also irgendwo eine solche Beschreibung ver√∂ffentlichen und alle Anrufe √ºber das Hauptsystem laufen, ist es uns egal, was Ein anderer Vertrag ist in der Sprache geschrieben. Wenn wir Methoden darauf aufrufen k√∂nnen, k√∂nnen wir auf Go einen Stub daf√ºr schreiben, der wie ein Paket mit einem Vertrag aussieht, der direkt aufgerufen werden kann.  Napoleonische Pl√§ne, fangen wir an. <br><br>  Grunds√§tzlich haben wir bereits eine Proxy-Helfer-Methode mit dieser Signatur: <br><br><pre> <code class="go hljs">RouteCall(ref Address, method <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, args []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) ([]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>, error)</code> </pre> <br>  Diese Methode kann direkt aus dem Vertrag aufgerufen werden. Sie ruft den Remote-Vertrag auf und gibt eine serialisierte Antwort zur√ºck, die wir analysieren und zu unserem Vertrag zur√ºckkehren m√ºssen. <br><br>  F√ºr den Benutzer muss jedoch alles so aussehen: <br><br><pre> <code class="go hljs">ret := contractPackage.GetObject(Address).Method(arg1,arg2, ‚Ä¶)</code> </pre> <br>  Beginnen wir zun√§chst im Proxy. Sie m√ºssen alle Typen auflisten, die in den Signaturen der Vertragsmethoden verwendet werden. Wie wir uns jedoch erinnern, k√∂nnen wir f√ºr jeden AST-Knoten seine Textdarstellung verwenden, und jetzt ist die Zeit f√ºr diesen Mechanismus gekommen. <br><br>  Als n√§chstes m√ºssen wir eine Art Vertrag erstellen, im Prinzip kennt er seine Klasse bereits, nur eine Adresse wird ben√∂tigt. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> {{ .ContractType }} <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Reference Address }</code> </pre> <br>  Als n√§chstes m√ºssen wir irgendwie die GetObject-Funktion implementieren, die an der Adresse in der Blockchain eine Proxy-Instanz zur√ºckgibt, die wei√ü, wie man mit diesem Vertrag arbeitet, und f√ºr den Benutzer sieht sie wie eine Vertragsinstanz aus. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetObject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ref Address)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r *{{ .ContractType }})</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;{{ .ContractType }}{Reference: ref} }</code> </pre> <br>  Interessanterweise ist die GetObject-Methode im Benutzer-Debugging-Modus direkt eine BaseContract-Strukturmethode, aber nichts hindert uns daran, die SLA zu beachten, um das zu tun, was f√ºr uns bequem ist.  Jetzt k√∂nnen wir einen Proxy-Vertrag erstellen, dessen Methoden wir steuern.  Es bleibt tats√§chlich Methoden zu erstellen. <br><br><pre> <code class="go hljs">{{ <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> $method := .MethodsProxies }} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r *{{ $.ContractType }})</span></span></span></span> {{ $method.Name }}( {{ $method.Arguments }} ) ( {{ $method.ResultsTypes }} ) { {{ $method.InitArgs }} <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> argsSerialized []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> err := proxyctx.Current.Serialize(args, &amp;argsSerialized) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">panic</span></span>(err) } res, err := proxyctx.Current.RouteCall(r.Reference, <span class="hljs-string"><span class="hljs-string">"{{ $method.Name }}"</span></span>, argsSerialized) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">panic</span></span>(err) } {{ $method.ResultZeroList }} err = proxyctx.Current.Deserialize(res, &amp;resList) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">panic</span></span>(err) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {{ $method.Results }} } {{ end }}</code> </pre> <br>  Hier die gleiche Geschichte mit der Konstruktion der Argumentliste, da wir faul sind und genau den ast.Node der Methode speichern, werden f√ºr Berechnungen viele Typkonvertierungen ben√∂tigt, die die Vorlagen nicht kennen, sodass alles im Voraus vorbereitet wird.  Mit Funktionen ist alles sehr viel komplizierter, und dies ist das Thema eines anderen Artikels. <br><br>  Die Funktionen, die wir haben, sind Objektkonstruktoren, und es wird viel Wert darauf gelegt, wie Objekte tats√§chlich in unserem System erstellt werden. Die Tatsache der Erstellung wird auf einem Remote-Executor registriert, das Objekt wird auf einen anderen Executor √ºbertragen, es wird dort √ºberpr√ºft und tats√§chlich gespeichert, und es gibt viele M√∂glichkeiten, vergeblich zu speichern Dieser Wissensbereich wird Krypta genannt.  Und die Idee ist im Grunde einfach: ein Wrapper, in dem nur die Adresse gespeichert ist, und Methoden, die den Aufruf serialisieren und unseren Singleton-Prozessor ziehen, der den Rest erledigt.  Wir k√∂nnen den √ºbertragenen Proxy-Helfer nicht verwenden, da der Benutzer ihn nicht an uns weitergegeben hat. Daher mussten wir ihn zu einem Singleton machen. <br><br>  Ein weiterer Trick: Tats√§chlich verwenden wir immer noch den Aufrufkontext. Dies ist ein solches Objekt, das Informationen dar√ºber speichert, wer, wann, warum, warum unser intelligenter Vertrag aufgerufen wurde. Auf der Grundlage dieser Informationen trifft der Benutzer eine Entscheidung, ob er √ºberhaupt eine Ausf√ºhrung geben m√∂chte, und wenn m√∂glich dann wie. <br><br>  Zuvor haben wir den Kontext einfach √ºbergeben. Es war ein nicht ausdr√ºckbares Feld im BaseContract-Typ mit einem Setter und einem Getter, und der Setter erlaubte, das Feld nur einmal festzulegen, sodass der Kontext festgelegt wurde, bevor der Vertrag ausgef√ºhrt wurde, und der Benutzer ihn nur lesen konnte. <br><br>  Aber hier ist das Problem: Der Benutzer liest diesen Kontext nur. Wenn er eine Systemfunktion aufruft, z. B. einen Proxy-Aufruf an einen anderen Vertrag, erh√§lt dieser Proxy-Aufruf keinen Kontext, da ihn niemand weiterleitet.  Und dann betritt der lokale Goroutine-Speicher die Szene.  Wir haben uns entschieden, keine eigenen zu schreiben, sondern github.com/tylerb/gls zu verwenden. <br><br>  Hier k√∂nnen Sie den Kontext f√ºr die aktuelle Goroutine festlegen und √ºbernehmen.  Wenn also innerhalb des Vertrags keine Goroutine erstellt wurde, setzen wir den Kontext nur in gls, bevor wir den Vertrag starten. Jetzt geben wir dem Benutzer keine Methode, sondern nur eine Funktion. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetContext</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">core</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LogicCallContext</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> gls.Get(<span class="hljs-string"><span class="hljs-string">"ctx"</span></span>).(*core.LogicCallContext) }</code> </pre> <br>  Und er verwendet es gerne, aber wir verwenden es beispielsweise in RouteCall (), um zu verstehen, welcher Vertrag gerade jemanden aufruft. <br><br>  Im Prinzip kann der Benutzer eine Goroutine erstellen. Wenn dies jedoch der Fall ist, geht der Kontext verloren. Daher m√ºssen wir etwas damit tun. Wenn der Benutzer beispielsweise das Schl√ºsselwort go verwendet, m√ºssen wir solche Aufrufe in unseren Wrapper einschlie√üen, an den sich der Kontext erinnert und die er erstellt goroutine und stelle den Kontext darin wieder her, aber dies ist das Thema eines anderen Artikels. <br><br><h2>  Alle zusammen </h2><br>  Grunds√§tzlich gef√§llt uns, wie die GO-Sprach-Toolchain funktioniert. Tats√§chlich sind es eine Reihe verschiedener Befehle, die eine Sache ausf√ºhren, die beispielsweise beim Erstellen zusammen ausgef√ºhrt werden.  Wir haben uns dazu entschlossen, ein Team legt eine Vertragsdatei in einem tempor√§ren Verzeichnis ab, das zweite legt einen Wrapper daf√ºr ab und ruft ein drittes Mal auf, wodurch ein Proxy f√ºr jeden importierten Vertrag erstellt wird, das vierte kompiliert alles, das f√ºnfte ver√∂ffentlicht es in der Blockchain.  Und es gibt einen Befehl, um sie alle in der richtigen Reihenfolge auszuf√ºhren. <br><br>  Hurra, wir haben jetzt eine Toolchain und eine Laufzeit zum Starten von GO from GO.  Es gibt immer noch viele Probleme, zum Beispiel m√ºssen Sie nicht verwendeten Code irgendwie entladen, Sie m√ºssen irgendwie feststellen, dass er h√§ngt, und den angehaltenen Prozess neu starten, aber dies sind Aufgaben, die klar sind, wie man ihn l√∂st. <br><br>  Ja, nat√ºrlich gibt der Code, den wir geschrieben haben, nicht vor, eine Bibliothek zu sein, er kann nicht direkt verwendet werden, aber das Lesen eines Beispiels f√ºr die Generierung von Arbeitscode ist immer gro√üartig, einmal habe ich ihn verpasst.  Dementsprechend kann ein Teil der Codegenerierung im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Compiler</a> angezeigt werden, aber wie er im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Executor</a> startet. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de425985/">https://habr.com/ru/post/de425985/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de425973/index.html">Wie wir S3 DataLine-Speicher erstellt haben. Experimente, Tests und ein wenig √ºber Flusspferde</a></li>
<li><a href="../de425975/index.html">Konvertieren Sie W√∂rter und Phrasen in Anagramme</a></li>
<li><a href="../de425977/index.html">Flexbox: Wie gro√ü ist diese flexible Box?</a></li>
<li><a href="../de425981/index.html">Newbies Karriere bei LK: Springt und springt langsam vorw√§rts</a></li>
<li><a href="../de425983/index.html">Flugsicherheit</a></li>
<li><a href="../de425989/index.html">Unter der Haube von Graveyard Keeper: Wie grafische Effekte implementiert werden</a></li>
<li><a href="../de425991/index.html">Wie wir Hosting erstellt haben</a></li>
<li><a href="../de425993/index.html">Wie man die geschlechtsspezifische Kluft in der Technologie √ºberbr√ºckt</a></li>
<li><a href="../de425995/index.html">Visualisieren Sie FHIR - den IT-Standard f√ºr die Medizin</a></li>
<li><a href="../de425997/index.html">MIT-Kurs "Computer Systems Security". Vorlesung 11: Ur / Web-Programmiersprache, Teil 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>