<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèø‚Äçüé® üëÉ üîå Optimierung von Datenbankabfragen am Beispiel eines B2B-Service f√ºr Builder üåû üßñüèΩ ‚õ©Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wie kann man unter der Anzahl der Datenbankabfragen zehnmal wachsen, ohne auf einen effizienteren Server zu wechseln und das System am Laufen zu halte...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Optimierung von Datenbankabfragen am Beispiel eines B2B-Service f√ºr Builder</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/461071/"> Wie kann man unter der Anzahl der Datenbankabfragen zehnmal wachsen, ohne auf einen effizienteren Server zu wechseln und das System am Laufen zu halten?  Ich werde Ihnen sagen, wie wir mit dem Leistungsabfall unserer Datenbank zu k√§mpfen hatten, wie wir SQL-Abfragen optimiert haben, um so viele Benutzer wie m√∂glich zu bedienen und die Kosten f√ºr Computerressourcen nicht zu erh√∂hen. <br><a name="habracut"></a><br>  Ich mache einen Service f√ºr das Management von Gesch√§ftsprozessen in Bauunternehmen.  Rund dreitausend Unternehmen arbeiten mit uns zusammen.  T√§glich arbeiten mehr als 10.000 Menschen 4-10 Stunden mit unserem System.  Es l√∂st verschiedene Aufgaben der Planung, Warnungen, Warnungen, Validierungen ... Wir verwenden PostgreSQL 9.6.  Wir haben ungef√§hr 300 Tabellen in der Datenbank und jeden Tag werden bis zu 200 Millionen Anfragen (zehntausend verschiedene) an sie gesendet.  Im Durchschnitt haben wir 3-4.000 Anfragen pro Sekunde, in den aktivsten Momenten mehr als 10.000 Anfragen pro Sekunde.  Die meisten Anfragen sind OLAP.  Es gibt viel weniger Hinzuf√ºgungen, √Ñnderungen und L√∂schungen, dh die OLTP-Last ist relativ gering.  Ich habe all diese Zahlen angegeben, damit Sie den Umfang unseres Projekts bewerten und verstehen k√∂nnen, wie n√ºtzlich unsere Erfahrung f√ºr Sie sein kann. <br><br><h3>  Das erste Bild.  Lyrisch </h3><br>  Als wir mit der Entwicklung begannen, haben wir nicht wirklich dar√ºber nachgedacht, welche Art von Last in der Datenbank sein wird und was wir tun werden, wenn der Server nicht mehr zieht.  Beim Entwerfen der Datenbank haben wir die allgemeinen Empfehlungen befolgt und versucht, uns nicht in den Fu√ü zu schie√üen, aber √ºber allgemeine Tipps wie ‚ÄûVerwenden Sie nicht das Muster f√ºr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Entit√§tsattributwerte</a> , sind wir nicht gegangen.  Entwickelt nach den Prinzipien der Normalisierung, um Datenredundanz zu vermeiden, und k√ºmmerte sich nicht darum, bestimmte Abfragen zu beschleunigen.  Sobald die ersten Benutzer ankamen, stie√üen wir auf ein Leistungsproblem.  Darauf waren wir wie immer v√∂llig unvorbereitet.  Die ersten Probleme waren einfach.  In der Regel wurde alles durch Hinzuf√ºgen eines neuen Index entschieden.  Aber es kam eine Zeit, in der einfache Patches nicht mehr funktionierten.  Nachdem wir festgestellt haben, dass nicht gen√ºgend Erfahrung vorhanden ist und es immer schwieriger wird, die Ursache der Probleme zu verstehen, haben wir Spezialisten eingestellt, die uns bei der korrekten Einrichtung des Servers und der Verbindungs√ºberwachung halfen und zeigten, wo nach <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Statistiken gesucht werden muss</a> . <br><br><h3>  Das zweite Bild.  Statistisch </h3><br>  Wir haben also ungef√§hr 10.000 verschiedene Abfragen, die pro Tag in unserer Datenbank ausgef√ºhrt werden.  Von diesen 10 Tausend gibt es Monster, die 2-3 Millionen Mal mit einer durchschnittlichen Laufzeit von 0,1 bis 0,3 ms laufen, und es gibt Abfragen mit einer durchschnittlichen Laufzeit von 30 Sekunden, die 100 Mal am Tag aufgerufen werden. <br><br>  Es war nicht m√∂glich, alle 10.000 Abfragen zu optimieren. Daher haben wir uns entschlossen, herauszufinden, wohin die Bem√ºhungen gerichtet werden m√ºssen, um die Datenbankleistung korrekt zu verbessern.  Nach mehreren Iterationen begannen wir, Anforderungen in Typen zu unterteilen. <br><br><h4>  TOP-Anfragen </h4><br>  Dies sind die schwierigsten Abfragen, die am meisten Zeit in Anspruch nehmen (Gesamtzeit).  Dies sind Abfragen, die entweder sehr h√§ufig aufgerufen werden oder sehr lange dauern (lange und h√§ufige Abfragen wurden bereits bei den ersten Iterationen des Kampfes um Geschwindigkeit optimiert).  Infolgedessen verbringt der Server insgesamt die meiste Zeit mit seiner Ausf√ºhrung.  Dar√ºber hinaus ist es wichtig, die obersten Anforderungen nach der Gesamtausf√ºhrungszeit und getrennt nach der E / A-Zeit zu trennen.  Die M√∂glichkeiten zur Optimierung solcher Abfragen unterscheiden sich geringf√ºgig. <br><br>  Die √ºbliche Praxis aller Unternehmen besteht darin, mit TOP-Anfragen zu arbeiten.  Es gibt nur wenige davon. Durch die Optimierung einer einzigen Anfrage k√∂nnen 5-10% der Ressourcen freigesetzt werden.  Mit zunehmendem Alter des Projekts wird die Optimierung von TOP-Abfragen jedoch zu einer zunehmend nicht trivialen Aufgabe.  Alle einfachen Methoden wurden bereits ausgearbeitet, und selbst die ‚Äûschwierigste‚Äú Anfrage nimmt ‚Äûnur‚Äú 3-5% der Ressourcen weg.  Wenn TOP-Abfragen insgesamt weniger als 30-40% der Zeit in Anspruch nehmen, haben Sie h√∂chstwahrscheinlich bereits Anstrengungen unternommen, damit sie schnell funktionieren, und es ist an der Zeit, die Abfragen der n√§chsten Gruppe zu optimieren. <br>  Es bleibt die Frage zu beantworten, wie viele Top-Abfragen in diese Gruppe aufgenommen werden sollen.  Normalerweise nehme ich nicht weniger als 10, aber nicht mehr als 20. Ich versuche sicherzustellen, dass sich die Zeit des ersten und letzten in der TOP-Gruppe nicht mehr als 10 Mal unterscheidet.  Das hei√üt, wenn die Ausf√ºhrungszeit der Abfrage stark von 1 auf 10 sinkt, nehme ich TOP-10, wenn der Fall glatter ist, erh√∂he ich die Gruppengr√∂√üe auf 15 oder 20. <br><img src="https://habrastorage.org/webt/y5/j5/yx/y5j5yxa6u4kxlpahplsaprh07ro.png" alt="Bild"><br><br><h4>  Die mittleren Bauern (mittel) </h4><br>  Dies sind alles Anfragen, die unmittelbar nach TOP gehen, mit Ausnahme der letzten 5-10%.  In der Optimierung dieser speziellen Anforderungen liegt normalerweise die F√§higkeit, die Serverleistung erheblich zu steigern.  Diese Abfragen k√∂nnen bis zu 80% ‚Äûwiegen‚Äú.  Aber selbst wenn ihr Anteil 50% √ºberschritten hat, ist es Zeit, sie genauer zu betrachten. <br><br><h4>  Schwanz </h4><br>  Wie gesagt, diese Anfragen gehen am Ende und dauern 5-10% der Zeit.  Sie k√∂nnen sie nur vergessen, wenn Sie keine automatischen Abfrageanalyse-Tools verwenden. Ihre Optimierung kann auch kosteng√ºnstig sein. <br><br>  Wie bewerte ich jede Gruppe? <br><br>  Ich verwende eine SQL-Abfrage, mit deren Hilfe eine solche Bewertung f√ºr PostgreSQL vorgenommen werden kann (ich bin sicher, dass Sie f√ºr viele andere DBMS eine √§hnliche Abfrage schreiben k√∂nnen). <br><br><div class="spoiler">  <b class="spoiler_title">SQL-Abfrage zum Sch√§tzen der Gr√∂√üe von TOP-MEDIUM-TAIL-Gruppen</b> <div class="spoiler_text"><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>(time_top) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> sum_top, <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>(time_medium) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> sum_medium, <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>(time_tail) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> sum_tail <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> rn &lt;= <span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> tt_percent <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> time_top, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> rn &gt; <span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> rn &lt;= <span class="hljs-number"><span class="hljs-number">800</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> tt_percent <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> time_medium, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> rn &gt; <span class="hljs-number"><span class="hljs-number">800</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> tt_percent <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> time_tail <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> total_time / (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>(total_time) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_statements) * <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> tt_percent, <span class="hljs-keyword"><span class="hljs-keyword">query</span></span>, ROW_NUMBER () <span class="hljs-keyword"><span class="hljs-keyword">OVER</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> total_time <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> rn <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_statements <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> total_time <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> t ) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ts</code> </pre> <br></div></div><br>  Das Abfrageergebnis besteht aus drei Spalten, von denen jede einen Prozentsatz der Zeit enth√§lt, die f√ºr die Verarbeitung von Anforderungen aus dieser Gruppe aufgewendet wird.  Innerhalb der Abfrage gibt es zwei Nummern (in meinem Fall 20 und 800), die Anforderungen von einer Gruppe von einer anderen trennen. <br><br>  Auf diese Weise korrelieren die Anteile der Anforderungen zum Zeitpunkt des Beginns der Optimierungsarbeit nun grob. <br><br><img src="https://habrastorage.org/webt/db/at/i_/dbati_rdn49yulwdicigqdvrgew.png"><br><br>  Das Diagramm zeigt, dass der Anteil der TOP-Anfragen stark zur√ºckgegangen ist, die ‚ÄûMittelbauern‚Äú jedoch gewachsen sind. <br>  Anf√§nglich trafen TOP-Fehler auf TOP-Abfragen.  Im Laufe der Zeit verschwanden Kinderkrankheiten, der Anteil der TOP-Anfragen wurde reduziert, und es mussten weitere Anstrengungen unternommen werden, um schwierige Anfragen zu beschleunigen. <br><br><div class="spoiler">  <b class="spoiler_title">Um den Text der Anfragen zu erhalten, verwenden wir eine solche Anfrage</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> ROW_NUMBER () <span class="hljs-keyword"><span class="hljs-keyword">OVER</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> total_time <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> rn, total_time / (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>(total_time) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_statements) * <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> tt_percent, <span class="hljs-keyword"><span class="hljs-keyword">query</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_statements <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> total_time <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> T <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> rn &lt;= <span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-comment"><span class="hljs-comment">-- TOP -- rn &gt; 20 AND rn &lt;= 800 -- MEDIUM -- rn &gt; 800 -- TAIL</span></span></code> </pre><br></div></div><br>  Hier ist eine Liste der am h√§ufigsten verwendeten Tricks, die uns geholfen haben, TOP-Abfragen zu beschleunigen: <br><br><ul><li>  Neugestaltung von Systemen, z. B. Verarbeitung der Benachrichtigungslogik auf dem Nachrichtenbroker anstelle von regelm√§√üigen Datenbankabfragen </li><li>  Hinzuf√ºgen oder √Ñndern von Indizes </li><li>  Schreiben Sie ORM-Abfragen in reinem SQL neu </li><li>  Schreiben Sie die Logik zum Laden fauler Daten neu </li><li>  Caching durch Daten-Denormalisierung.  Zum Beispiel haben wir eine Verkn√ºpfung zwischen den Tabellen Lieferung -&gt; Rechnung -&gt; Anfrage -&gt; Anfrage.  Das hei√üt, jede Lieferung ist der Anwendung √ºber andere Tabellen zugeordnet.  Um nicht alle Tabellen in jeder Anforderung zu verkn√ºpfen, haben wir den Link zur Anwendung in der √úbermittlungstabelle dupliziert. </li><li>  Zwischenspeichern statischer Tabellen mit Verzeichnissen und seltenes √Ñndern von Tabellen im Programmspeicher. </li></ul><br>  Manchmal f√ºhrten die √Ñnderungen zu einer beeindruckenden Neugestaltung, aber sie machten 5-10% des Entladens des Systems aus und waren gerechtfertigt.  Mit der Zeit wurde der Auspuff immer weniger und die Neugestaltung musste immer ernster werden. <br><br>  Dann machten wir auf die zweite Gruppe von Anfragen aufmerksam - die Gruppe der Mittelbauern.  Es hat viel mehr Anfragen und es schien, als w√ºrde es viel Zeit in Anspruch nehmen, die gesamte Gruppe zu analysieren.  Die meisten Abfragen erwiesen sich jedoch als sehr einfach f√ºr die Optimierung, und viele Probleme wurden Dutzende Male in verschiedenen Variationen wiederholt.  Hier sind Beispiele f√ºr einige typische Optimierungen, die wir auf Dutzende √§hnlicher Abfragen angewendet haben, und jede Gruppe optimierter Abfragen hat die Datenbank um 3-5% entladen. <br><br><ul><li>  Anstatt mit COUNT und einem vollst√§ndigen Tabellenscan zu pr√ºfen, ob Datens√§tze vorhanden sind, wurde EXISTS verwendet. <br></li><li>  Wir haben DISTINCT losgeworden (es gibt kein allgemeines Rezept, aber manchmal k√∂nnen Sie es leicht loswerden, indem Sie die Anfrage 10-100 Mal beschleunigen). <br><br>  Anstatt beispielsweise abzufragen, alle Treiber in einer gro√üen Liefertabelle auszuw√§hlen (LIEFERUNG) <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DISTINCT</span></span> P.ID, P.FIRST_NAME, P.LAST_NAME <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> DELIVERY D <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> PERSON P <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> D.DRIVER_ID = P.ID</code> </pre><br>  beantragte einen relativ kleinen PERSON-Tisch <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> P.ID, P.FIRST_NAME, P.LAST_NAME <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> PERSON <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXISTS</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> D.ID <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> DELIVERY <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> D.DRIVER_ID = P.ID)</code> </pre><br>  Es scheint, dass wir eine korrelierende Unterabfrage verwendet haben, aber sie ergibt eine Beschleunigung von mehr als dem Zehnfachen. <br></li><li>  In vielen F√§llen z√§hlen COUNT und <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ersetzt durch die Berechnung des ungef√§hren Wertes</a> <br></li><li>  statt <br><br><pre> <code class="sql hljs">UPPER(s) LIKE JOHN%'</code> </pre><br>  verwenden <br><br><pre> <code class="sql hljs">s ILIKE ‚ÄúJohn%‚Äù</code> </pre><br></li></ul><br>  Jede spezifische Anfrage wurde manchmal um das 3-1000-fache beschleunigt.  Trotz der beeindruckenden Leistung schien es uns zun√§chst sinnlos, die Abfrage zu optimieren, die 10 ms lang ausgef√ºhrt wurde und in den dreihundert der schwersten Abfragen und in der gesamten Ladezeit der Datenbank Hundertstel Prozent dauerte.  Aber wenn wir dasselbe Rezept auf eine Gruppe √§hnlicher Anfragen anwenden, haben wir mehrere Prozent zur√ºckgewonnen.  Um keine Zeit damit zu verschwenden, alle Hunderte von Abfragen manuell anzuzeigen, haben wir mehrere einfache Skripte geschrieben, die mithilfe regul√§rer Ausdr√ºcke √§hnliche Abfragen fanden.  Die automatische Suche nach Abfragegruppen erm√∂glichte es uns daher, unsere Leistung durch bescheidene Anstrengungen weiter zu verbessern. <br><br>  Aus diesem Grund arbeiten wir seit drei Jahren an derselben Hardware.  Die durchschnittliche t√§gliche Belastung betr√§gt ca. 30%, bei Spitzenwerten 70%.  Die Anzahl der Anfragen sowie die Anzahl der Benutzer hat sich um das Zehnfache erh√∂ht.  Und das alles dank der st√§ndigen √úberwachung dieser Gruppen von TOP-MEDIUM-Abfragen.  Sobald eine neue Anfrage in der TOP-Gruppe erscheint, analysieren wir sie sofort und versuchen, sie zu beschleunigen.  Wir √ºberpr√ºfen die MEDIUM-Gruppe einmal pro Woche mithilfe von Abfrageanalyse-Skripten.  Wenn Sie auf neue Anforderungen sto√üen, die wir bereits optimieren k√∂nnen, √§ndern wir diese schnell.  Manchmal finden wir neue Optimierungsmethoden, die auf mehrere Abfragen gleichzeitig angewendet werden k√∂nnen. <br><br>  Nach unseren Prognosen wird der aktuelle Server einer Erh√∂hung der Benutzeranzahl um das weitere 3-5-fache standhalten.  Wir haben zwar noch einen Trumpf im √Ñrmel, aber wir haben SELECT-Abfragen noch nicht wie empfohlen in den Spiegel √ºbersetzt.  Dies tun wir jedoch nicht bewusst, da wir zun√§chst die M√∂glichkeiten der ‚Äûintelligenten‚Äú Optimierung vollst√§ndig aussch√∂pfen wollen, bevor wir die ‚Äûschwere Artillerie‚Äú einschalten. <br>  Ein kritischer Blick auf die geleistete Arbeit kann die Verwendung einer vertikalen Skalierung vorschlagen.  Kaufen Sie einen leistungsst√§rkeren Server, anstatt die Zeit von Spezialisten zu verschwenden.  Der Server kostet m√∂glicherweise nicht so viel, zumal die Grenzen der vertikalen Skalierung noch nicht ausgesch√∂pft sind.  Allerdings hat sich nur die Anzahl der Anfragen verzehnfacht.  Seit einigen Jahren hat die Funktionalit√§t des Systems zugenommen und jetzt gibt es mehr Arten von Anfragen.  Die Funktionalit√§t, die durch das Caching verursacht wurde, wird von weniger Anforderungen ausgef√ºhrt, au√üerdem von effizienteren Anforderungen.  Sie k√∂nnen also sicher mit weiteren 5 multiplizieren, um den tats√§chlichen Beschleunigungskoeffizienten zu erhalten.  Nach den konservativsten Sch√§tzungen k√∂nnen wir also sagen, dass die Beschleunigung das 50-fache oder mehr betrug.  Ein 50-maliges vertikales Sch√ºtteln des Servers w√ºrde mehr kosten.  Vor allem, wenn man bedenkt, dass die Optimierung immer durchgef√ºhrt wird und jeden Monat eine Rechnung f√ºr einen gemieteten Server ausgestellt wird. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de461071/">https://habr.com/ru/post/de461071/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de461059/index.html">Schreiben einer Android-App f√ºr Filmfans - Teil 1 (Prototyping)</a></li>
<li><a href="../de461061/index.html">Magnesiumlegierungen, Zwillingsgrenzen und Entmischung</a></li>
<li><a href="../de461063/index.html">Interaktion von R mit Datenbanken am Beispiel von Microsoft SQL Server und anderen DBMS</a></li>
<li><a href="../de461067/index.html">Die 65 wichtigsten SQL-Fragen aus Vorstellungsgespr√§chen, auf die Sie 2019 vorbereitet sein sollten. Teil I.</a></li>
<li><a href="../de461069/index.html">Nobel-IP-Au√üenkameras: Tests, Technologien und Funktionen von Ivideon-Video√ºberwachungssystemen</a></li>
<li><a href="../de461073/index.html">Wir verbinden Online-Karten mit dem Navigator auf dem Smartphone. Teil 3 - OverpassTurbo</a></li>
<li><a href="../de461075/index.html">Business Intelligence. IT-Objekte, Komponenten, Tools</a></li>
<li><a href="../de461077/index.html">Wie werden Pentester gekocht? Eingangstests f√ºr Praktikanten im Bereich digitale Sicherheit</a></li>
<li><a href="../de461079/index.html">Stadt ohne Stau</a></li>
<li><a href="../de461081/index.html">Der Tag, an dem Dodo aufgeh√∂rt hat. Asynchrones Skript</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>