<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏿‍🎨 👃 🔌 Optimierung von Datenbankabfragen am Beispiel eines B2B-Service für Builder 🌞 🧖🏽 ⛩️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wie kann man unter der Anzahl der Datenbankabfragen zehnmal wachsen, ohne auf einen effizienteren Server zu wechseln und das System am Laufen zu halte...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Optimierung von Datenbankabfragen am Beispiel eines B2B-Service für Builder</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/461071/"> Wie kann man unter der Anzahl der Datenbankabfragen zehnmal wachsen, ohne auf einen effizienteren Server zu wechseln und das System am Laufen zu halten?  Ich werde Ihnen sagen, wie wir mit dem Leistungsabfall unserer Datenbank zu kämpfen hatten, wie wir SQL-Abfragen optimiert haben, um so viele Benutzer wie möglich zu bedienen und die Kosten für Computerressourcen nicht zu erhöhen. <br><a name="habracut"></a><br>  Ich mache einen Service für das Management von Geschäftsprozessen in Bauunternehmen.  Rund dreitausend Unternehmen arbeiten mit uns zusammen.  Täglich arbeiten mehr als 10.000 Menschen 4-10 Stunden mit unserem System.  Es löst verschiedene Aufgaben der Planung, Warnungen, Warnungen, Validierungen ... Wir verwenden PostgreSQL 9.6.  Wir haben ungefähr 300 Tabellen in der Datenbank und jeden Tag werden bis zu 200 Millionen Anfragen (zehntausend verschiedene) an sie gesendet.  Im Durchschnitt haben wir 3-4.000 Anfragen pro Sekunde, in den aktivsten Momenten mehr als 10.000 Anfragen pro Sekunde.  Die meisten Anfragen sind OLAP.  Es gibt viel weniger Hinzufügungen, Änderungen und Löschungen, dh die OLTP-Last ist relativ gering.  Ich habe all diese Zahlen angegeben, damit Sie den Umfang unseres Projekts bewerten und verstehen können, wie nützlich unsere Erfahrung für Sie sein kann. <br><br><h3>  Das erste Bild.  Lyrisch </h3><br>  Als wir mit der Entwicklung begannen, haben wir nicht wirklich darüber nachgedacht, welche Art von Last in der Datenbank sein wird und was wir tun werden, wenn der Server nicht mehr zieht.  Beim Entwerfen der Datenbank haben wir die allgemeinen Empfehlungen befolgt und versucht, uns nicht in den Fuß zu schießen, aber über allgemeine Tipps wie „Verwenden Sie nicht das Muster für <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Entitätsattributwerte</a> , sind wir nicht gegangen.  Entwickelt nach den Prinzipien der Normalisierung, um Datenredundanz zu vermeiden, und kümmerte sich nicht darum, bestimmte Abfragen zu beschleunigen.  Sobald die ersten Benutzer ankamen, stießen wir auf ein Leistungsproblem.  Darauf waren wir wie immer völlig unvorbereitet.  Die ersten Probleme waren einfach.  In der Regel wurde alles durch Hinzufügen eines neuen Index entschieden.  Aber es kam eine Zeit, in der einfache Patches nicht mehr funktionierten.  Nachdem wir festgestellt haben, dass nicht genügend Erfahrung vorhanden ist und es immer schwieriger wird, die Ursache der Probleme zu verstehen, haben wir Spezialisten eingestellt, die uns bei der korrekten Einrichtung des Servers und der Verbindungsüberwachung halfen und zeigten, wo nach <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Statistiken gesucht werden muss</a> . <br><br><h3>  Das zweite Bild.  Statistisch </h3><br>  Wir haben also ungefähr 10.000 verschiedene Abfragen, die pro Tag in unserer Datenbank ausgeführt werden.  Von diesen 10 Tausend gibt es Monster, die 2-3 Millionen Mal mit einer durchschnittlichen Laufzeit von 0,1 bis 0,3 ms laufen, und es gibt Abfragen mit einer durchschnittlichen Laufzeit von 30 Sekunden, die 100 Mal am Tag aufgerufen werden. <br><br>  Es war nicht möglich, alle 10.000 Abfragen zu optimieren. Daher haben wir uns entschlossen, herauszufinden, wohin die Bemühungen gerichtet werden müssen, um die Datenbankleistung korrekt zu verbessern.  Nach mehreren Iterationen begannen wir, Anforderungen in Typen zu unterteilen. <br><br><h4>  TOP-Anfragen </h4><br>  Dies sind die schwierigsten Abfragen, die am meisten Zeit in Anspruch nehmen (Gesamtzeit).  Dies sind Abfragen, die entweder sehr häufig aufgerufen werden oder sehr lange dauern (lange und häufige Abfragen wurden bereits bei den ersten Iterationen des Kampfes um Geschwindigkeit optimiert).  Infolgedessen verbringt der Server insgesamt die meiste Zeit mit seiner Ausführung.  Darüber hinaus ist es wichtig, die obersten Anforderungen nach der Gesamtausführungszeit und getrennt nach der E / A-Zeit zu trennen.  Die Möglichkeiten zur Optimierung solcher Abfragen unterscheiden sich geringfügig. <br><br>  Die übliche Praxis aller Unternehmen besteht darin, mit TOP-Anfragen zu arbeiten.  Es gibt nur wenige davon. Durch die Optimierung einer einzigen Anfrage können 5-10% der Ressourcen freigesetzt werden.  Mit zunehmendem Alter des Projekts wird die Optimierung von TOP-Abfragen jedoch zu einer zunehmend nicht trivialen Aufgabe.  Alle einfachen Methoden wurden bereits ausgearbeitet, und selbst die „schwierigste“ Anfrage nimmt „nur“ 3-5% der Ressourcen weg.  Wenn TOP-Abfragen insgesamt weniger als 30-40% der Zeit in Anspruch nehmen, haben Sie höchstwahrscheinlich bereits Anstrengungen unternommen, damit sie schnell funktionieren, und es ist an der Zeit, die Abfragen der nächsten Gruppe zu optimieren. <br>  Es bleibt die Frage zu beantworten, wie viele Top-Abfragen in diese Gruppe aufgenommen werden sollen.  Normalerweise nehme ich nicht weniger als 10, aber nicht mehr als 20. Ich versuche sicherzustellen, dass sich die Zeit des ersten und letzten in der TOP-Gruppe nicht mehr als 10 Mal unterscheidet.  Das heißt, wenn die Ausführungszeit der Abfrage stark von 1 auf 10 sinkt, nehme ich TOP-10, wenn der Fall glatter ist, erhöhe ich die Gruppengröße auf 15 oder 20. <br><img src="https://habrastorage.org/webt/y5/j5/yx/y5j5yxa6u4kxlpahplsaprh07ro.png" alt="Bild"><br><br><h4>  Die mittleren Bauern (mittel) </h4><br>  Dies sind alles Anfragen, die unmittelbar nach TOP gehen, mit Ausnahme der letzten 5-10%.  In der Optimierung dieser speziellen Anforderungen liegt normalerweise die Fähigkeit, die Serverleistung erheblich zu steigern.  Diese Abfragen können bis zu 80% „wiegen“.  Aber selbst wenn ihr Anteil 50% überschritten hat, ist es Zeit, sie genauer zu betrachten. <br><br><h4>  Schwanz </h4><br>  Wie gesagt, diese Anfragen gehen am Ende und dauern 5-10% der Zeit.  Sie können sie nur vergessen, wenn Sie keine automatischen Abfrageanalyse-Tools verwenden. Ihre Optimierung kann auch kostengünstig sein. <br><br>  Wie bewerte ich jede Gruppe? <br><br>  Ich verwende eine SQL-Abfrage, mit deren Hilfe eine solche Bewertung für PostgreSQL vorgenommen werden kann (ich bin sicher, dass Sie für viele andere DBMS eine ähnliche Abfrage schreiben können). <br><br><div class="spoiler">  <b class="spoiler_title">SQL-Abfrage zum Schätzen der Größe von TOP-MEDIUM-TAIL-Gruppen</b> <div class="spoiler_text"><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>(time_top) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> sum_top, <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>(time_medium) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> sum_medium, <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>(time_tail) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> sum_tail <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> rn &lt;= <span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> tt_percent <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> time_top, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> rn &gt; <span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> rn &lt;= <span class="hljs-number"><span class="hljs-number">800</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> tt_percent <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> time_medium, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> rn &gt; <span class="hljs-number"><span class="hljs-number">800</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> tt_percent <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> time_tail <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> total_time / (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>(total_time) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_statements) * <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> tt_percent, <span class="hljs-keyword"><span class="hljs-keyword">query</span></span>, ROW_NUMBER () <span class="hljs-keyword"><span class="hljs-keyword">OVER</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> total_time <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> rn <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_statements <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> total_time <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> t ) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ts</code> </pre> <br></div></div><br>  Das Abfrageergebnis besteht aus drei Spalten, von denen jede einen Prozentsatz der Zeit enthält, die für die Verarbeitung von Anforderungen aus dieser Gruppe aufgewendet wird.  Innerhalb der Abfrage gibt es zwei Nummern (in meinem Fall 20 und 800), die Anforderungen von einer Gruppe von einer anderen trennen. <br><br>  Auf diese Weise korrelieren die Anteile der Anforderungen zum Zeitpunkt des Beginns der Optimierungsarbeit nun grob. <br><br><img src="https://habrastorage.org/webt/db/at/i_/dbati_rdn49yulwdicigqdvrgew.png"><br><br>  Das Diagramm zeigt, dass der Anteil der TOP-Anfragen stark zurückgegangen ist, die „Mittelbauern“ jedoch gewachsen sind. <br>  Anfänglich trafen TOP-Fehler auf TOP-Abfragen.  Im Laufe der Zeit verschwanden Kinderkrankheiten, der Anteil der TOP-Anfragen wurde reduziert, und es mussten weitere Anstrengungen unternommen werden, um schwierige Anfragen zu beschleunigen. <br><br><div class="spoiler">  <b class="spoiler_title">Um den Text der Anfragen zu erhalten, verwenden wir eine solche Anfrage</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> ROW_NUMBER () <span class="hljs-keyword"><span class="hljs-keyword">OVER</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> total_time <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> rn, total_time / (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>(total_time) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_statements) * <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> tt_percent, <span class="hljs-keyword"><span class="hljs-keyword">query</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_statements <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> total_time <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> T <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> rn &lt;= <span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-comment"><span class="hljs-comment">-- TOP -- rn &gt; 20 AND rn &lt;= 800 -- MEDIUM -- rn &gt; 800 -- TAIL</span></span></code> </pre><br></div></div><br>  Hier ist eine Liste der am häufigsten verwendeten Tricks, die uns geholfen haben, TOP-Abfragen zu beschleunigen: <br><br><ul><li>  Neugestaltung von Systemen, z. B. Verarbeitung der Benachrichtigungslogik auf dem Nachrichtenbroker anstelle von regelmäßigen Datenbankabfragen </li><li>  Hinzufügen oder Ändern von Indizes </li><li>  Schreiben Sie ORM-Abfragen in reinem SQL neu </li><li>  Schreiben Sie die Logik zum Laden fauler Daten neu </li><li>  Caching durch Daten-Denormalisierung.  Zum Beispiel haben wir eine Verknüpfung zwischen den Tabellen Lieferung -&gt; Rechnung -&gt; Anfrage -&gt; Anfrage.  Das heißt, jede Lieferung ist der Anwendung über andere Tabellen zugeordnet.  Um nicht alle Tabellen in jeder Anforderung zu verknüpfen, haben wir den Link zur Anwendung in der Übermittlungstabelle dupliziert. </li><li>  Zwischenspeichern statischer Tabellen mit Verzeichnissen und seltenes Ändern von Tabellen im Programmspeicher. </li></ul><br>  Manchmal führten die Änderungen zu einer beeindruckenden Neugestaltung, aber sie machten 5-10% des Entladens des Systems aus und waren gerechtfertigt.  Mit der Zeit wurde der Auspuff immer weniger und die Neugestaltung musste immer ernster werden. <br><br>  Dann machten wir auf die zweite Gruppe von Anfragen aufmerksam - die Gruppe der Mittelbauern.  Es hat viel mehr Anfragen und es schien, als würde es viel Zeit in Anspruch nehmen, die gesamte Gruppe zu analysieren.  Die meisten Abfragen erwiesen sich jedoch als sehr einfach für die Optimierung, und viele Probleme wurden Dutzende Male in verschiedenen Variationen wiederholt.  Hier sind Beispiele für einige typische Optimierungen, die wir auf Dutzende ähnlicher Abfragen angewendet haben, und jede Gruppe optimierter Abfragen hat die Datenbank um 3-5% entladen. <br><br><ul><li>  Anstatt mit COUNT und einem vollständigen Tabellenscan zu prüfen, ob Datensätze vorhanden sind, wurde EXISTS verwendet. <br></li><li>  Wir haben DISTINCT losgeworden (es gibt kein allgemeines Rezept, aber manchmal können Sie es leicht loswerden, indem Sie die Anfrage 10-100 Mal beschleunigen). <br><br>  Anstatt beispielsweise abzufragen, alle Treiber in einer großen Liefertabelle auszuwählen (LIEFERUNG) <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DISTINCT</span></span> P.ID, P.FIRST_NAME, P.LAST_NAME <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> DELIVERY D <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> PERSON P <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> D.DRIVER_ID = P.ID</code> </pre><br>  beantragte einen relativ kleinen PERSON-Tisch <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> P.ID, P.FIRST_NAME, P.LAST_NAME <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> PERSON <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXISTS</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> D.ID <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> DELIVERY <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> D.DRIVER_ID = P.ID)</code> </pre><br>  Es scheint, dass wir eine korrelierende Unterabfrage verwendet haben, aber sie ergibt eine Beschleunigung von mehr als dem Zehnfachen. <br></li><li>  In vielen Fällen zählen COUNT und <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ersetzt durch die Berechnung des ungefähren Wertes</a> <br></li><li>  statt <br><br><pre> <code class="sql hljs">UPPER(s) LIKE JOHN%'</code> </pre><br>  verwenden <br><br><pre> <code class="sql hljs">s ILIKE “John%”</code> </pre><br></li></ul><br>  Jede spezifische Anfrage wurde manchmal um das 3-1000-fache beschleunigt.  Trotz der beeindruckenden Leistung schien es uns zunächst sinnlos, die Abfrage zu optimieren, die 10 ms lang ausgeführt wurde und in den dreihundert der schwersten Abfragen und in der gesamten Ladezeit der Datenbank Hundertstel Prozent dauerte.  Aber wenn wir dasselbe Rezept auf eine Gruppe ähnlicher Anfragen anwenden, haben wir mehrere Prozent zurückgewonnen.  Um keine Zeit damit zu verschwenden, alle Hunderte von Abfragen manuell anzuzeigen, haben wir mehrere einfache Skripte geschrieben, die mithilfe regulärer Ausdrücke ähnliche Abfragen fanden.  Die automatische Suche nach Abfragegruppen ermöglichte es uns daher, unsere Leistung durch bescheidene Anstrengungen weiter zu verbessern. <br><br>  Aus diesem Grund arbeiten wir seit drei Jahren an derselben Hardware.  Die durchschnittliche tägliche Belastung beträgt ca. 30%, bei Spitzenwerten 70%.  Die Anzahl der Anfragen sowie die Anzahl der Benutzer hat sich um das Zehnfache erhöht.  Und das alles dank der ständigen Überwachung dieser Gruppen von TOP-MEDIUM-Abfragen.  Sobald eine neue Anfrage in der TOP-Gruppe erscheint, analysieren wir sie sofort und versuchen, sie zu beschleunigen.  Wir überprüfen die MEDIUM-Gruppe einmal pro Woche mithilfe von Abfrageanalyse-Skripten.  Wenn Sie auf neue Anforderungen stoßen, die wir bereits optimieren können, ändern wir diese schnell.  Manchmal finden wir neue Optimierungsmethoden, die auf mehrere Abfragen gleichzeitig angewendet werden können. <br><br>  Nach unseren Prognosen wird der aktuelle Server einer Erhöhung der Benutzeranzahl um das weitere 3-5-fache standhalten.  Wir haben zwar noch einen Trumpf im Ärmel, aber wir haben SELECT-Abfragen noch nicht wie empfohlen in den Spiegel übersetzt.  Dies tun wir jedoch nicht bewusst, da wir zunächst die Möglichkeiten der „intelligenten“ Optimierung vollständig ausschöpfen wollen, bevor wir die „schwere Artillerie“ einschalten. <br>  Ein kritischer Blick auf die geleistete Arbeit kann die Verwendung einer vertikalen Skalierung vorschlagen.  Kaufen Sie einen leistungsstärkeren Server, anstatt die Zeit von Spezialisten zu verschwenden.  Der Server kostet möglicherweise nicht so viel, zumal die Grenzen der vertikalen Skalierung noch nicht ausgeschöpft sind.  Allerdings hat sich nur die Anzahl der Anfragen verzehnfacht.  Seit einigen Jahren hat die Funktionalität des Systems zugenommen und jetzt gibt es mehr Arten von Anfragen.  Die Funktionalität, die durch das Caching verursacht wurde, wird von weniger Anforderungen ausgeführt, außerdem von effizienteren Anforderungen.  Sie können also sicher mit weiteren 5 multiplizieren, um den tatsächlichen Beschleunigungskoeffizienten zu erhalten.  Nach den konservativsten Schätzungen können wir also sagen, dass die Beschleunigung das 50-fache oder mehr betrug.  Ein 50-maliges vertikales Schütteln des Servers würde mehr kosten.  Vor allem, wenn man bedenkt, dass die Optimierung immer durchgeführt wird und jeden Monat eine Rechnung für einen gemieteten Server ausgestellt wird. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de461071/">https://habr.com/ru/post/de461071/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de461059/index.html">Schreiben einer Android-App für Filmfans - Teil 1 (Prototyping)</a></li>
<li><a href="../de461061/index.html">Magnesiumlegierungen, Zwillingsgrenzen und Entmischung</a></li>
<li><a href="../de461063/index.html">Interaktion von R mit Datenbanken am Beispiel von Microsoft SQL Server und anderen DBMS</a></li>
<li><a href="../de461067/index.html">Die 65 wichtigsten SQL-Fragen aus Vorstellungsgesprächen, auf die Sie 2019 vorbereitet sein sollten. Teil I.</a></li>
<li><a href="../de461069/index.html">Nobel-IP-Außenkameras: Tests, Technologien und Funktionen von Ivideon-Videoüberwachungssystemen</a></li>
<li><a href="../de461073/index.html">Wir verbinden Online-Karten mit dem Navigator auf dem Smartphone. Teil 3 - OverpassTurbo</a></li>
<li><a href="../de461075/index.html">Business Intelligence. IT-Objekte, Komponenten, Tools</a></li>
<li><a href="../de461077/index.html">Wie werden Pentester gekocht? Eingangstests für Praktikanten im Bereich digitale Sicherheit</a></li>
<li><a href="../de461079/index.html">Stadt ohne Stau</a></li>
<li><a href="../de461081/index.html">Der Tag, an dem Dodo aufgehört hat. Asynchrones Skript</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>