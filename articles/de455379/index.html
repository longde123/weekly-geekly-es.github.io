<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👊🏽 🏣 🈁 (Statisch) Auswahl optimaler Container in C ++ - Programmen 🗼 🙂 🗑️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Guten Tag. Heute möchte ich noch einmal über statische Analysen sprechen. Und nochmal zu C ++. Nur werden wir im Gegensatz zu PVS-Studio keine Fehler ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>(Statisch) Auswahl optimaler Container in C ++ - Programmen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455379/">  Guten Tag.  Heute möchte ich noch einmal über statische Analysen sprechen.  Und nochmal zu C ++.  Nur werden wir im Gegensatz zu PVS-Studio keine Fehler in unseren Programmen suchen (obwohl sie nicht nur nach Fehlern suchen), sondern auch nach Stellen, die nicht optimal genug geschrieben sind.  Und einer dieser Orte ist die Auswahl eines Containers für die Daten im Programm.  Wenn ich für Sie von Interesse bin, dann willkommen bei cat! <br><a name="habracut"></a><br><h3>  Das Problem </h3><br>  Auf der CoreHard 2018 Autumn (eine sehr gute Konferenz, komm) habe ich darüber gesprochen, wie C ++ - Compiler derzeit nicht gut optimieren.  Und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eine</a> meiner Beschwerden war, dass Compiler die Verwendung von Containern in unseren Programmen nicht optimieren können.  Schauen wir uns einige Codebeispiele an. <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; v(<span class="hljs-number"><span class="hljs-number">42</span></span>); }</code> </pre> <br>  In einem so einfachen Fall sollte der Compiler in der Lage sein, diese Funktion zu optimieren und einfach eine Variablendeklaration vom Typ std :: vector auszugeben, da der Compiler ab C ++ 14 dynamische Speicherzuordnungen entfernen darf, der Compiler jedoch nicht.  Der Grund dafür ist, dass derzeit nur ein C ++ - Compiler eine Optimierung zum Entfernen dynamischer Zuordnungen implementiert - Clang.  Alle anderen Compiler wissen bisher nicht, wie das geht.  Aber selbst Clang kann dies in einer begrenzten Anzahl von Fällen tun. <br><br>  In diesem Fall könnten wir std :: vector durch std :: array ersetzen, vorausgesetzt, die Größe des ausgewählten Vektors ist nicht zu groß, da wir möglicherweise nicht genügend Stapel für eine solche Ersetzung haben.  Ein solcher Ersatz entfernt eine ziemlich teure Speicherzuordnung zum Heap, und das Plus ist, dass der Compiler bei Verwendung von std :: array bereits std :: array aus der Funktion insgesamt werfen kann! <br><br>  Wenn wir über Leistungsoptimierung sprechen, schlagen wir vor, das folgende Beispiel zu betrachten: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; v; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">42</span></span>; ++i) { v.insert(v.begin(), <span class="hljs-number"><span class="hljs-number">42</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> val : v) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; val &lt;&lt; <span class="hljs-string"><span class="hljs-string">' '</span></span>; } }</code> </pre> <br>  In diesem Fall sehen wir die Verwendung einer äußerst ineffektiven Operation im Fall der Einfügung von std :: vector am Anfang des Containers.  Alle C ++ - Programmierer wissen, dass dies äußerst schlecht ist, da alle Elemente jedes Mal verschoben werden, was zu hohen Kosten für das Kopieren / Verschieben führt.  In diesem Fall wäre es viel schöner, es durch std :: list zu ersetzen, was nicht wichtig ist, wo das Einfügen stattfindet, oder std :: deque (obwohl Sie in diesem Fall deutlich sehen können, dass Sie nicht nur insert verwenden müssen. Dies ist jedoch nur ein Beispiel, nicht mehr :) <br><br>  Schauen wir uns einen anderen Beispielcode an: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">list</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; v; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>; ++i) { v.push_front(i); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> val : v) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; val &lt;&lt; <span class="hljs-string"><span class="hljs-string">' '</span></span>; } }</code> </pre> <br>  In diesem Fall können wir feststellen, dass wir std :: list (ja, ich weiß, dass nur wenige Leute es verwenden) schmerzlos durch std :: forward_list ersetzen können.  In diesem Fall verlieren wir in diesem Fall absolut nichts, aber wir erhalten Speichereinsparungen.  Natürlich führt der Compiler eine solche Optimierung jetzt nicht durch. <br><br>  Ein ähnlicher Trick kann im folgenden Beispiel ausgeführt werden: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">deque</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; v; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>; ++i) { v.push_back(i); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>; ++i) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; v.back() &lt;&lt; <span class="hljs-string"><span class="hljs-string">' '</span></span>; v.pop_back(); } }</code> </pre> <br>  Hier können wir sehen, dass wir nicht std :: deque, sondern std :: stack wirklich brauchen.  Dies kann nicht als Optimierung bezeichnet werden, da std :: stack ein Adapter ist und standardmäßig std :: deque verwendet (sofern der Benutzer nichts anderes angibt).  Hier können wir mehr über semantische Optimierung sprechen, d.h.  Vereinfachung des Codes zu verstehen.  Dies ist aus meiner Sicht auch wichtig.  Wenn Sie fragen: "Vielleicht bringt ein solcher Ersatz auch einen Leistungsgewinn?", Antworte ich: "Vielleicht.  Einzelheiten zur Implementierung finden Sie in Ihrer Version der Standardbibliothek. “ <br><br>  Ich denke, es gibt genug Beispiele.  Jeder von euch kann sich auch viele davon einfallen lassen. <br><br><h3>  Verwendete Mittel </h3><br>  Zur Implementierung des statischen Analysators habe ich Clang Static Analzyer (CSA) und Clang Tidy verwendet, die Teil des LLVM-Pakets sind.  Ich habe diese Tools ausgewählt, da ich sie als die vielversprechendsten unter den offenen Tools für die statische Analyse betrachte.  Darüber hinaus bietet Clang einen der hochwertigsten C ++ - Parser, mit denen andere statische Analysatoren nicht aufwarten können (es sei denn, sie verwenden natürlich libclang). <br><br>  Sowohl CSA als auch Clang Tidy sind statische Analysegeräte, die beide Teil von LLVM sind.  Was ist der Unterschied?  Der Unterschied besteht darin, dass Clang Tidy so konzipiert ist, dass einfache Überprüfungen geschrieben werden, die im Wesentlichen darin bestehen, ein Muster im abstrakten Syntaxbaum zu finden, eine Art Warnung anzuzeigen und es möglicherweise automatisch durch ein anderes zu ersetzen.  Mehr über Clang Tidy erfahren Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><br>  CSA wurde entwickelt, um "ernsthaftere" und ressourcenintensivere Prüfungen (sowohl unter dem Gesichtspunkt der Implementierung als auch unter dem Gesichtspunkt der Ausführungszeit / des aufgewendeten Speichers) zu schreiben.  Dort steht beispielsweise ein symbolischer Ausführungsmechanismus zur Verfügung. <br><br>  Ich habe mich entschlossen, den Check in CSA zu implementieren, da er mir nicht alltäglich erscheint. Außerdem wird er in Zukunft immer schwieriger.  Und es wurde beschlossen, Clang Tidy zu durchlaufen, da dieser statische Analysator <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">viele</a> Integrationen mit verschiedenen IDEs aufweist. <br><br><h3>  Wie wir versuchen werden, Probleme zu lösen </h3><br>  Zunächst lohnt es sich, einige ziemlich starke Einschränkungen einzuführen, die hauptsächlich damit zusammenhängen, dass dies bislang nur ein Prototyp ist: <br><br><ul><li>  Analyse nur auf Funktionsebene;  Diese Einschränkung bedeutet, dass keine Analyse zwischen Funktionen sowie zwischen Übersetzungseinheiten erfolgt.  Die Einschränkung der Analyse zwischen Funktionen wurde eingeführt, um die Implementierung dieser Analyse zu vereinfachen, und kann in Zukunft relativ einfach behoben werden, indem eine statische Analyse für die gesamte Übersetzungseinheit und nicht nur für jede Funktion durchgeführt wird.  Die Einschränkung der Analyse zwischen Übersetzungseinheiten wird durch die bestehenden Einschränkungen im CSA auferlegt, die in Kürze festgelegt werden (Commits fließen bereits in den Upstream). </li><li>  Unterstützung für nur eine begrenzte Anzahl von Containern.  Dies lässt sich in Zukunft relativ einfach beheben, indem neue Regeln für neue Container hinzugefügt werden. </li><li>  Verwenden Sie für die Analyse nur einen Baum mit abstrakter Syntax.  Da dies für das Prototyping die einfachste Art der Analyse ist.  Für genauere Ergebnisse können Sie natürlich versuchen, zumindest eine symbolische Ausführung zu verwenden, aber diese Methode hat ihre Nachteile.  Weitere Informationen zu Methoden finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . </li></ul><br>  Jetzt implementiert der Prototyp den folgenden einfachen Algorithmus: <br><br><ul><li>  Zunächst finden wir im abstrakten Syntaxbaum die Eckpunkte, die für die Deklaration der von uns unterstützten Containertypvariablen verantwortlich sind. </li><li>  Dann finden wir die Operationen, die sich auf diese Container beziehen, klassifizieren sie und speichern diese Informationen in einem temporären Cache. </li><li>  Nach Erreichen des Funktionsende analysieren wir die gesammelten Statistiken und geben basierend auf vordefinierten Regeln eine Empfehlung zur Verwendung eines Containers ab. </li></ul><br>  Die Klassifizierung der Containerbetriebe ist derzeit wie folgt (wird in Zukunft erweitert): <br><br><ul><li>  Fügen Sie einen Artikel oben im Container hinzu. </li><li>  Hinzufügen eines Elements zur Mitte des Containers. </li><li>  Hinzufügen eines Elements am Ende des Containers. </li><li>  Entfernen eines Elements vom Anfang des Containers. </li><li>  Entfernen eines Artikels aus der Mitte des Containers. </li><li>  Entfernen eines Elements vom Ende des Containers. </li></ul><br>  Die Klassifizierung ist derzeit unvollständig und funktioniert auch in dieser Liste nicht richtig.  Zum Beispiel klassifiziert der Einfügevorgang, selbst wenn er zu Beginn ausgeführt wird, den Einsteiger als Einfügen in die Mitte, obwohl dies tatsächlich überhaupt nicht der Fall ist. <br><br><h3>  Bekämpfung von Fehlalarmen </h3><br>  Bei jeder statischen Analyse sind falsch positive Ergebnisse die Hauptprobleme.  Wenn es zu viele davon gibt, gehen nützliche Nachrichten im Müll verloren.  Daher müssen Sie in diesem Fall sehr konservativ handeln und Warnungen nur dann ausgeben, wenn wir wirklich zuversichtlich in unsere Diagnose sind und durchaus sagen können, dass an einer Stelle im Code wirklich etwas nicht stimmt. <br><br>  Wenn wir über Compiler-Optimierung sprechen, ist es dort immer noch trauriger - eine ordnungsgemäße Optimierung kann das Verhalten des Programms gemäß dem C ++ - Standard nicht ändern (andernfalls ist ein solcher Optimierer wertlos).  Und Optimierung sollte auch keine Pessimisierung einführen :) Hier müssen Sie also bei Ihren Entscheidungen viel vorsichtiger sein. <br><br>  In diesem Analysator führte dieser Kampf dazu, dass die Analyse für diesen Container deaktiviert wird, wenn der Analysator feststellt, dass gerade eine nicht unterstützte Operation ausgeführt wird. <br><br><h3>  Nachteile und mögliche Lösungen </h3><br>  Bei dieser Methode gibt es mehrere Probleme. <br><br>  Das erste Problem ist, dass für den Analysator im Moment alle Zweige des Codes gleich wahrscheinlich sind.  Genauer gesagt kennt er nicht einmal verschiedene Zweige der Codeausführung. <br>  Dies führt zu Problemen bei der Analyse für so etwas wie diesen Code: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* ptr, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;&amp; v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(ptr == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>) { v.insert(v.begin(), <span class="hljs-number"><span class="hljs-number">42</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { v.push_back(<span class="hljs-number"><span class="hljs-number">84</span></span>); } }</code> </pre> <br>  In unserer Anwendung haben diese Codezweige höchstwahrscheinlich nicht die gleichen Ausführungswahrscheinlichkeiten, da in der realen Welt ein Zeiger normalerweise etwas Normales anzeigt und nicht nullptr.  In derselben LLVM gibt es statische Heuristiken für diese Punktzahl.  Beispielsweise wird der obige Fall beim Vergleichen von Zeigern mit nullptr und beim Vergleichen der Gleichheit von Werten zweier Variablen mit einem Gleitkomma und einiger anderer interessanter Fälle berücksichtigt.  Dies ähnelt jedoch immer mehr Krücken, und aus meiner Sicht besteht die eigentliche Lösung für dieses Problem darin, dynamische Analysen oder Instrumente hinzuzufügen. <br><br>  Das zweite Problem ist die mangelnde Unterstützung für benutzerdefinierte Container.  Wir leben in der Welt von C ++, sie fahren gerne hier (lassen wir die Diskussion über die Gründe für dieses nicht immer schlechte Phänomen außerhalb des Rahmens dieses Artikels) alles, einschließlich unserer Container.  Beispiele sind das gleiche LLVM, LibreOffice und viele andere.  In diesem Zusammenhang stellt sich die Frage, wie Container analysiert werden sollen, die nicht aus der STL-Bibliothek stammen.  Schließlich möchte ich die Analyse für so viele Container wie möglich einbeziehen. <br><br>  Es gibt verschiedene Möglichkeiten, das Problem zu lösen. <br><br>  Das erste ist, dass der Benutzer seine Container auf irgendeine Weise kommentiert (eine spezielle Art von Kommentar, C ++ - Attribute, etwas anderes).  Das Problem bei dieser Methode ist, dass wir verstehen müssen, wie man im Allgemeinen kommentiert, welche Informationen wir für eine qualitative Analyse benötigen.  Ein weiteres Problem kann die Codeänderung der Container selbst sein, die nicht immer möglich ist. <br><br>  Die zweite Methode bietet dem Benutzer einen Mechanismus zum Schreiben eigener Regeln.  Im Moment sind die Regeln im Analysator in den Quellcode des Analysators selbst eingenäht. Wenn der Benutzer seine eigenen Regeln hinzufügen möchte, muss er den Quellcode des Analysators herunterladen, zusammenstellen, herausfinden, wie Schecks geschrieben, geschrieben, neu erstellt usw. werden.  Sie können dem Benutzer eine Möglichkeit bieten, seine Überprüfungen für DSL festzulegen, wobei der Benutzer nur Überprüfungen für seine Container schreibt und der Analysator an der gesamten Routine beteiligt ist.  Ich halte diese Methode für vielversprechender als die vorherige. <br><br>  Der automatische Austausch von Containern wird ebenfalls nicht unterstützt, da diese Funktionalität nicht in der CSA enthalten ist (sondern in Clang Tidy).  In schwierigen Fällen ist die Durchführung der automatischen Korrektur jedoch nicht immer eine triviale Aufgabe, und der Analysator arbeitet eher im halbmanuellen Modus. <br><br><h3>  Mögliche Anwendungen </h3><br>  Ich sehe mehrere Anwendungen für diese Art der Analyse: <br><br><ol><li>  Wie ein statischer Analysator.  Hier ist alles einfach - ein weiterer Test der statischen Analyse, den Sie nach Herzenslust durchführen (mit Ihren Händen, in der IDE automatisch während der Entwicklung, auf CI usw.), wo Sie wahrscheinlich einen Hinweis erhalten, dass Sie irgendwo könnten nimm einen Behälter und besser. </li><li>  Wie die Optimierung im Compiler.  In einigen Fällen können wir garantieren, dass das Ersetzen des Containers die Leistung definitiv nicht beeinträchtigt.  Ersetzen Sie beispielsweise std :: vector für kleine Größen, die zur Kompilierungszeit bekannt sind, durch std :: array oder ersetzen Sie std :: list durch std :: forward_list, wenn wir keine doppelte Verbindung benötigen und die Größe nicht aus der Liste übernehmen.  Der Compiler könnte ohne unser Wissen Container durch optimalere ersetzen, wie dies bereits für eine sehr große Anzahl von Dingen der Fall ist. </li><li>  Wie ein dynamischer Analysator.  Dies ist die Richtung, die mir für diese Art der Analyse am vielversprechendsten erscheint.  In der Tat können wir mit Hilfe des Wissens über das Programmausführungsprofil beispielsweise so wichtige Informationen für uns erhalten, wie die Wahrscheinlichkeiten jeder Ausführung von Codezweigen.  Und dies ist für eine genauere Beurteilung notwendig.  Und mit einer solchen Analyse können Sie bereits in Richtung Integration mit PGO denken ... </li></ol><br>  Es ist auch erwähnenswert, dass diese Methode natürlich nicht nur für C ++ - Programme anwendbar ist.  Ich würde diese Art der statischen Analyse / Optimierung wirklich gerne im Compiler und für andere Programmiersprachen sehen.  Zum Beispiel weiß der SAP Static Analyzer für ABAP bereits, wie man eine statische Optimalitätsanalyse auf einer grundlegenden Ebene durchführt, was eine gute Nachricht ist.  Wenn Sie ähnliche Projekte für andere Programmiersprachen kennen - schreiben Sie in die Kommentare und ich werde den Artikel ergänzen! <br><br><h3>  Arbeiten Sie in ähnliche Richtungen </h3><br>  Für die C ++ - Welt habe ich solche Analysatoren nirgendwo gefunden.  Für die ABAP-Welt habe ich oben den Analysator erwähnt, der für einen Teil der Standardcontainer ineffiziente Operationen finden kann, aber soweit ich weiß, wird dort eine sehr einfache statische Analyse implementiert. <br><br>  Eine viel interessantere Arbeit ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Chameleon</a> - ein dynamischer Analysator für Java, der sehr geschickt gemacht wird.  Sie haben die JVM ein wenig optimiert und während des Betriebs verschiedene Statistiken über die Verwendung von Containern gesammelt. Abhängig vom aktuellen Lastprofil wählen sie bestimmte Container aus und ersetzen sie automatisch während des Betriebs.  Leider sind die Quellen geschlossen und es gibt keine Chance, sie zu bekommen (ich habe es versucht). <br><br>  Ich empfehle auch, verschiedene Werke (es gibt viele) auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SETL anzuschauen</a> .  In ihnen stellten die Autoren auch häufig Fragen zur automatischen Auswahl des Containers. <br><br><h3>  Referenzen </h3><br><ol><li>  Aktuelle Implementierung auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Github</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">C ++ Russland 2017: Yuri Efimochev, ordentlich: eine Reise in den abstrakten C ++ - Syntaxbaum</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Chamäleon: Adaptive Auswahl von Sammlungen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Clang Static Analyzer Guide</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Russischsprachiger Chat</a> zur Entwicklung von Compilern im Telegramm.  Wenn Sie interessiert sind, kommen Sie herein, es ist dort sehr interessant.  Sei einfach vorsichtig mit der Flut - sie werden ihn sofort bestrafen :) </li></ol><br>  Anstelle einer Schlussfolgerung möchte ich mich auf die Tatsache konzentrieren, dass es sich bisher nur um einen Prototyp handelt und zu viele „Lücken“ in der Implementierung aufweisen.  In diesem Artikel möchte ich Ihnen nur die Idee einer solchen Analyse und ihre Popularisierung mitteilen.  Nun, vielleicht interessiert sich jemand für dieses Thema und es besteht der Wunsch, sich mit dem Projekt zu verbinden - ich werde nur glücklich sein!  Darüber hinaus können Sie diesen Analysator jederzeit an Ihrem eigenen Ort sammeln, um ihn an Ihren Testbeispielen zu testen. <br><br>  Wenn Sie etwas zur Ergänzung des Materials haben, auf ein ähnliches Problem gestoßen sind oder einfach einige Informationen haben, die zu diesem Thema nützlich sein können, zögern Sie bitte nicht, diese Informationen in den Kommentaren zu teilen. <br><br>  Vielen Dank für Ihre Aufmerksamkeit! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de455379/">https://habr.com/ru/post/de455379/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de455369/index.html">Zertifizierung von Datenbankadministratoren und vielem mehr zum Jubiläum von DevConfX (21.-22. Juni in Moskau)</a></li>
<li><a href="../de455371/index.html">Stabile Stromquelle von 5 μA bis 20 mA</a></li>
<li><a href="../de455373/index.html">Wie kann man das Frühlingsgesetz so anpassen, dass es für kleine Anbieter zum Aufschwung wird? Abbrechen</a></li>
<li><a href="../de455375/index.html">UDR in Pascal schreiben</a></li>
<li><a href="../de455377/index.html">IoT-Architektur</a></li>
<li><a href="../de455381/index.html">Der technische Support von 3CX antwortet: Erfassen Sie den SIP-Verkehr auf dem PBX-Server</a></li>
<li><a href="../de455387/index.html">Grundlegendes zum maschinellen Lernen in Elastic Stack (auch bekannt als Elasticsearch, auch bekannt als ELK)</a></li>
<li><a href="../de455389/index.html">Haxe 4: Was ist neu?</a></li>
<li><a href="../de455391/index.html">Teil 1: RISC-V / RocketChip in einem unnatürlichen Lebensraum</a></li>
<li><a href="../de455393/index.html">Über die Verwendung parametrischer Methoden zur Spektralschätzung im Radar - die MUSIC-Methode. Ergänzung zum Artikel</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>