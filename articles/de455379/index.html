<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëäüèΩ üè£ üàÅ (Statisch) Auswahl optimaler Container in C ++ - Programmen üóº üôÇ üóëÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Guten Tag. Heute m√∂chte ich noch einmal √ºber statische Analysen sprechen. Und nochmal zu C ++. Nur werden wir im Gegensatz zu PVS-Studio keine Fehler ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>(Statisch) Auswahl optimaler Container in C ++ - Programmen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455379/">  Guten Tag.  Heute m√∂chte ich noch einmal √ºber statische Analysen sprechen.  Und nochmal zu C ++.  Nur werden wir im Gegensatz zu PVS-Studio keine Fehler in unseren Programmen suchen (obwohl sie nicht nur nach Fehlern suchen), sondern auch nach Stellen, die nicht optimal genug geschrieben sind.  Und einer dieser Orte ist die Auswahl eines Containers f√ºr die Daten im Programm.  Wenn ich f√ºr Sie von Interesse bin, dann willkommen bei cat! <br><a name="habracut"></a><br><h3>  Das Problem </h3><br>  Auf der CoreHard 2018 Autumn (eine sehr gute Konferenz, komm) habe ich dar√ºber gesprochen, wie C ++ - Compiler derzeit nicht gut optimieren.  Und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eine</a> meiner Beschwerden war, dass Compiler die Verwendung von Containern in unseren Programmen nicht optimieren k√∂nnen.  Schauen wir uns einige Codebeispiele an. <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; v(<span class="hljs-number"><span class="hljs-number">42</span></span>); }</code> </pre> <br>  In einem so einfachen Fall sollte der Compiler in der Lage sein, diese Funktion zu optimieren und einfach eine Variablendeklaration vom Typ std :: vector auszugeben, da der Compiler ab C ++ 14 dynamische Speicherzuordnungen entfernen darf, der Compiler jedoch nicht.  Der Grund daf√ºr ist, dass derzeit nur ein C ++ - Compiler eine Optimierung zum Entfernen dynamischer Zuordnungen implementiert - Clang.  Alle anderen Compiler wissen bisher nicht, wie das geht.  Aber selbst Clang kann dies in einer begrenzten Anzahl von F√§llen tun. <br><br>  In diesem Fall k√∂nnten wir std :: vector durch std :: array ersetzen, vorausgesetzt, die Gr√∂√üe des ausgew√§hlten Vektors ist nicht zu gro√ü, da wir m√∂glicherweise nicht gen√ºgend Stapel f√ºr eine solche Ersetzung haben.  Ein solcher Ersatz entfernt eine ziemlich teure Speicherzuordnung zum Heap, und das Plus ist, dass der Compiler bei Verwendung von std :: array bereits std :: array aus der Funktion insgesamt werfen kann! <br><br>  Wenn wir √ºber Leistungsoptimierung sprechen, schlagen wir vor, das folgende Beispiel zu betrachten: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; v; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">42</span></span>; ++i) { v.insert(v.begin(), <span class="hljs-number"><span class="hljs-number">42</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> val : v) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; val &lt;&lt; <span class="hljs-string"><span class="hljs-string">' '</span></span>; } }</code> </pre> <br>  In diesem Fall sehen wir die Verwendung einer √§u√üerst ineffektiven Operation im Fall der Einf√ºgung von std :: vector am Anfang des Containers.  Alle C ++ - Programmierer wissen, dass dies √§u√üerst schlecht ist, da alle Elemente jedes Mal verschoben werden, was zu hohen Kosten f√ºr das Kopieren / Verschieben f√ºhrt.  In diesem Fall w√§re es viel sch√∂ner, es durch std :: list zu ersetzen, was nicht wichtig ist, wo das Einf√ºgen stattfindet, oder std :: deque (obwohl Sie in diesem Fall deutlich sehen k√∂nnen, dass Sie nicht nur insert verwenden m√ºssen. Dies ist jedoch nur ein Beispiel, nicht mehr :) <br><br>  Schauen wir uns einen anderen Beispielcode an: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">list</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; v; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>; ++i) { v.push_front(i); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> val : v) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; val &lt;&lt; <span class="hljs-string"><span class="hljs-string">' '</span></span>; } }</code> </pre> <br>  In diesem Fall k√∂nnen wir feststellen, dass wir std :: list (ja, ich wei√ü, dass nur wenige Leute es verwenden) schmerzlos durch std :: forward_list ersetzen k√∂nnen.  In diesem Fall verlieren wir in diesem Fall absolut nichts, aber wir erhalten Speichereinsparungen.  Nat√ºrlich f√ºhrt der Compiler eine solche Optimierung jetzt nicht durch. <br><br>  Ein √§hnlicher Trick kann im folgenden Beispiel ausgef√ºhrt werden: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">deque</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; v; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>; ++i) { v.push_back(i); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>; ++i) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; v.back() &lt;&lt; <span class="hljs-string"><span class="hljs-string">' '</span></span>; v.pop_back(); } }</code> </pre> <br>  Hier k√∂nnen wir sehen, dass wir nicht std :: deque, sondern std :: stack wirklich brauchen.  Dies kann nicht als Optimierung bezeichnet werden, da std :: stack ein Adapter ist und standardm√§√üig std :: deque verwendet (sofern der Benutzer nichts anderes angibt).  Hier k√∂nnen wir mehr √ºber semantische Optimierung sprechen, d.h.  Vereinfachung des Codes zu verstehen.  Dies ist aus meiner Sicht auch wichtig.  Wenn Sie fragen: "Vielleicht bringt ein solcher Ersatz auch einen Leistungsgewinn?", Antworte ich: "Vielleicht.  Einzelheiten zur Implementierung finden Sie in Ihrer Version der Standardbibliothek. ‚Äú <br><br>  Ich denke, es gibt genug Beispiele.  Jeder von euch kann sich auch viele davon einfallen lassen. <br><br><h3>  Verwendete Mittel </h3><br>  Zur Implementierung des statischen Analysators habe ich Clang Static Analzyer (CSA) und Clang Tidy verwendet, die Teil des LLVM-Pakets sind.  Ich habe diese Tools ausgew√§hlt, da ich sie als die vielversprechendsten unter den offenen Tools f√ºr die statische Analyse betrachte.  Dar√ºber hinaus bietet Clang einen der hochwertigsten C ++ - Parser, mit denen andere statische Analysatoren nicht aufwarten k√∂nnen (es sei denn, sie verwenden nat√ºrlich libclang). <br><br>  Sowohl CSA als auch Clang Tidy sind statische Analyseger√§te, die beide Teil von LLVM sind.  Was ist der Unterschied?  Der Unterschied besteht darin, dass Clang Tidy so konzipiert ist, dass einfache √úberpr√ºfungen geschrieben werden, die im Wesentlichen darin bestehen, ein Muster im abstrakten Syntaxbaum zu finden, eine Art Warnung anzuzeigen und es m√∂glicherweise automatisch durch ein anderes zu ersetzen.  Mehr √ºber Clang Tidy erfahren Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><br>  CSA wurde entwickelt, um "ernsthaftere" und ressourcenintensivere Pr√ºfungen (sowohl unter dem Gesichtspunkt der Implementierung als auch unter dem Gesichtspunkt der Ausf√ºhrungszeit / des aufgewendeten Speichers) zu schreiben.  Dort steht beispielsweise ein symbolischer Ausf√ºhrungsmechanismus zur Verf√ºgung. <br><br>  Ich habe mich entschlossen, den Check in CSA zu implementieren, da er mir nicht allt√§glich erscheint. Au√üerdem wird er in Zukunft immer schwieriger.  Und es wurde beschlossen, Clang Tidy zu durchlaufen, da dieser statische Analysator <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">viele</a> Integrationen mit verschiedenen IDEs aufweist. <br><br><h3>  Wie wir versuchen werden, Probleme zu l√∂sen </h3><br>  Zun√§chst lohnt es sich, einige ziemlich starke Einschr√§nkungen einzuf√ºhren, die haupts√§chlich damit zusammenh√§ngen, dass dies bislang nur ein Prototyp ist: <br><br><ul><li>  Analyse nur auf Funktionsebene;  Diese Einschr√§nkung bedeutet, dass keine Analyse zwischen Funktionen sowie zwischen √úbersetzungseinheiten erfolgt.  Die Einschr√§nkung der Analyse zwischen Funktionen wurde eingef√ºhrt, um die Implementierung dieser Analyse zu vereinfachen, und kann in Zukunft relativ einfach behoben werden, indem eine statische Analyse f√ºr die gesamte √úbersetzungseinheit und nicht nur f√ºr jede Funktion durchgef√ºhrt wird.  Die Einschr√§nkung der Analyse zwischen √úbersetzungseinheiten wird durch die bestehenden Einschr√§nkungen im CSA auferlegt, die in K√ºrze festgelegt werden (Commits flie√üen bereits in den Upstream). </li><li>  Unterst√ºtzung f√ºr nur eine begrenzte Anzahl von Containern.  Dies l√§sst sich in Zukunft relativ einfach beheben, indem neue Regeln f√ºr neue Container hinzugef√ºgt werden. </li><li>  Verwenden Sie f√ºr die Analyse nur einen Baum mit abstrakter Syntax.  Da dies f√ºr das Prototyping die einfachste Art der Analyse ist.  F√ºr genauere Ergebnisse k√∂nnen Sie nat√ºrlich versuchen, zumindest eine symbolische Ausf√ºhrung zu verwenden, aber diese Methode hat ihre Nachteile.  Weitere Informationen zu Methoden finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . </li></ul><br>  Jetzt implementiert der Prototyp den folgenden einfachen Algorithmus: <br><br><ul><li>  Zun√§chst finden wir im abstrakten Syntaxbaum die Eckpunkte, die f√ºr die Deklaration der von uns unterst√ºtzten Containertypvariablen verantwortlich sind. </li><li>  Dann finden wir die Operationen, die sich auf diese Container beziehen, klassifizieren sie und speichern diese Informationen in einem tempor√§ren Cache. </li><li>  Nach Erreichen des Funktionsende analysieren wir die gesammelten Statistiken und geben basierend auf vordefinierten Regeln eine Empfehlung zur Verwendung eines Containers ab. </li></ul><br>  Die Klassifizierung der Containerbetriebe ist derzeit wie folgt (wird in Zukunft erweitert): <br><br><ul><li>  F√ºgen Sie einen Artikel oben im Container hinzu. </li><li>  Hinzuf√ºgen eines Elements zur Mitte des Containers. </li><li>  Hinzuf√ºgen eines Elements am Ende des Containers. </li><li>  Entfernen eines Elements vom Anfang des Containers. </li><li>  Entfernen eines Artikels aus der Mitte des Containers. </li><li>  Entfernen eines Elements vom Ende des Containers. </li></ul><br>  Die Klassifizierung ist derzeit unvollst√§ndig und funktioniert auch in dieser Liste nicht richtig.  Zum Beispiel klassifiziert der Einf√ºgevorgang, selbst wenn er zu Beginn ausgef√ºhrt wird, den Einsteiger als Einf√ºgen in die Mitte, obwohl dies tats√§chlich √ºberhaupt nicht der Fall ist. <br><br><h3>  Bek√§mpfung von Fehlalarmen </h3><br>  Bei jeder statischen Analyse sind falsch positive Ergebnisse die Hauptprobleme.  Wenn es zu viele davon gibt, gehen n√ºtzliche Nachrichten im M√ºll verloren.  Daher m√ºssen Sie in diesem Fall sehr konservativ handeln und Warnungen nur dann ausgeben, wenn wir wirklich zuversichtlich in unsere Diagnose sind und durchaus sagen k√∂nnen, dass an einer Stelle im Code wirklich etwas nicht stimmt. <br><br>  Wenn wir √ºber Compiler-Optimierung sprechen, ist es dort immer noch trauriger - eine ordnungsgem√§√üe Optimierung kann das Verhalten des Programms gem√§√ü dem C ++ - Standard nicht √§ndern (andernfalls ist ein solcher Optimierer wertlos).  Und Optimierung sollte auch keine Pessimisierung einf√ºhren :) Hier m√ºssen Sie also bei Ihren Entscheidungen viel vorsichtiger sein. <br><br>  In diesem Analysator f√ºhrte dieser Kampf dazu, dass die Analyse f√ºr diesen Container deaktiviert wird, wenn der Analysator feststellt, dass gerade eine nicht unterst√ºtzte Operation ausgef√ºhrt wird. <br><br><h3>  Nachteile und m√∂gliche L√∂sungen </h3><br>  Bei dieser Methode gibt es mehrere Probleme. <br><br>  Das erste Problem ist, dass f√ºr den Analysator im Moment alle Zweige des Codes gleich wahrscheinlich sind.  Genauer gesagt kennt er nicht einmal verschiedene Zweige der Codeausf√ºhrung. <br>  Dies f√ºhrt zu Problemen bei der Analyse f√ºr so etwas wie diesen Code: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* ptr, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;&amp; v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(ptr == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>) { v.insert(v.begin(), <span class="hljs-number"><span class="hljs-number">42</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { v.push_back(<span class="hljs-number"><span class="hljs-number">84</span></span>); } }</code> </pre> <br>  In unserer Anwendung haben diese Codezweige h√∂chstwahrscheinlich nicht die gleichen Ausf√ºhrungswahrscheinlichkeiten, da in der realen Welt ein Zeiger normalerweise etwas Normales anzeigt und nicht nullptr.  In derselben LLVM gibt es statische Heuristiken f√ºr diese Punktzahl.  Beispielsweise wird der obige Fall beim Vergleichen von Zeigern mit nullptr und beim Vergleichen der Gleichheit von Werten zweier Variablen mit einem Gleitkomma und einiger anderer interessanter F√§lle ber√ºcksichtigt.  Dies √§hnelt jedoch immer mehr Kr√ºcken, und aus meiner Sicht besteht die eigentliche L√∂sung f√ºr dieses Problem darin, dynamische Analysen oder Instrumente hinzuzuf√ºgen. <br><br>  Das zweite Problem ist die mangelnde Unterst√ºtzung f√ºr benutzerdefinierte Container.  Wir leben in der Welt von C ++, sie fahren gerne hier (lassen wir die Diskussion √ºber die Gr√ºnde f√ºr dieses nicht immer schlechte Ph√§nomen au√üerhalb des Rahmens dieses Artikels) alles, einschlie√ülich unserer Container.  Beispiele sind das gleiche LLVM, LibreOffice und viele andere.  In diesem Zusammenhang stellt sich die Frage, wie Container analysiert werden sollen, die nicht aus der STL-Bibliothek stammen.  Schlie√ülich m√∂chte ich die Analyse f√ºr so viele Container wie m√∂glich einbeziehen. <br><br>  Es gibt verschiedene M√∂glichkeiten, das Problem zu l√∂sen. <br><br>  Das erste ist, dass der Benutzer seine Container auf irgendeine Weise kommentiert (eine spezielle Art von Kommentar, C ++ - Attribute, etwas anderes).  Das Problem bei dieser Methode ist, dass wir verstehen m√ºssen, wie man im Allgemeinen kommentiert, welche Informationen wir f√ºr eine qualitative Analyse ben√∂tigen.  Ein weiteres Problem kann die Code√§nderung der Container selbst sein, die nicht immer m√∂glich ist. <br><br>  Die zweite Methode bietet dem Benutzer einen Mechanismus zum Schreiben eigener Regeln.  Im Moment sind die Regeln im Analysator in den Quellcode des Analysators selbst eingen√§ht. Wenn der Benutzer seine eigenen Regeln hinzuf√ºgen m√∂chte, muss er den Quellcode des Analysators herunterladen, zusammenstellen, herausfinden, wie Schecks geschrieben, geschrieben, neu erstellt usw. werden.  Sie k√∂nnen dem Benutzer eine M√∂glichkeit bieten, seine √úberpr√ºfungen f√ºr DSL festzulegen, wobei der Benutzer nur √úberpr√ºfungen f√ºr seine Container schreibt und der Analysator an der gesamten Routine beteiligt ist.  Ich halte diese Methode f√ºr vielversprechender als die vorherige. <br><br>  Der automatische Austausch von Containern wird ebenfalls nicht unterst√ºtzt, da diese Funktionalit√§t nicht in der CSA enthalten ist (sondern in Clang Tidy).  In schwierigen F√§llen ist die Durchf√ºhrung der automatischen Korrektur jedoch nicht immer eine triviale Aufgabe, und der Analysator arbeitet eher im halbmanuellen Modus. <br><br><h3>  M√∂gliche Anwendungen </h3><br>  Ich sehe mehrere Anwendungen f√ºr diese Art der Analyse: <br><br><ol><li>  Wie ein statischer Analysator.  Hier ist alles einfach - ein weiterer Test der statischen Analyse, den Sie nach Herzenslust durchf√ºhren (mit Ihren H√§nden, in der IDE automatisch w√§hrend der Entwicklung, auf CI usw.), wo Sie wahrscheinlich einen Hinweis erhalten, dass Sie irgendwo k√∂nnten nimm einen Beh√§lter und besser. </li><li>  Wie die Optimierung im Compiler.  In einigen F√§llen k√∂nnen wir garantieren, dass das Ersetzen des Containers die Leistung definitiv nicht beeintr√§chtigt.  Ersetzen Sie beispielsweise std :: vector f√ºr kleine Gr√∂√üen, die zur Kompilierungszeit bekannt sind, durch std :: array oder ersetzen Sie std :: list durch std :: forward_list, wenn wir keine doppelte Verbindung ben√∂tigen und die Gr√∂√üe nicht aus der Liste √ºbernehmen.  Der Compiler k√∂nnte ohne unser Wissen Container durch optimalere ersetzen, wie dies bereits f√ºr eine sehr gro√üe Anzahl von Dingen der Fall ist. </li><li>  Wie ein dynamischer Analysator.  Dies ist die Richtung, die mir f√ºr diese Art der Analyse am vielversprechendsten erscheint.  In der Tat k√∂nnen wir mit Hilfe des Wissens √ºber das Programmausf√ºhrungsprofil beispielsweise so wichtige Informationen f√ºr uns erhalten, wie die Wahrscheinlichkeiten jeder Ausf√ºhrung von Codezweigen.  Und dies ist f√ºr eine genauere Beurteilung notwendig.  Und mit einer solchen Analyse k√∂nnen Sie bereits in Richtung Integration mit PGO denken ... </li></ol><br>  Es ist auch erw√§hnenswert, dass diese Methode nat√ºrlich nicht nur f√ºr C ++ - Programme anwendbar ist.  Ich w√ºrde diese Art der statischen Analyse / Optimierung wirklich gerne im Compiler und f√ºr andere Programmiersprachen sehen.  Zum Beispiel wei√ü der SAP Static Analyzer f√ºr ABAP bereits, wie man eine statische Optimalit√§tsanalyse auf einer grundlegenden Ebene durchf√ºhrt, was eine gute Nachricht ist.  Wenn Sie √§hnliche Projekte f√ºr andere Programmiersprachen kennen - schreiben Sie in die Kommentare und ich werde den Artikel erg√§nzen! <br><br><h3>  Arbeiten Sie in √§hnliche Richtungen </h3><br>  F√ºr die C ++ - Welt habe ich solche Analysatoren nirgendwo gefunden.  F√ºr die ABAP-Welt habe ich oben den Analysator erw√§hnt, der f√ºr einen Teil der Standardcontainer ineffiziente Operationen finden kann, aber soweit ich wei√ü, wird dort eine sehr einfache statische Analyse implementiert. <br><br>  Eine viel interessantere Arbeit ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Chameleon</a> - ein dynamischer Analysator f√ºr Java, der sehr geschickt gemacht wird.  Sie haben die JVM ein wenig optimiert und w√§hrend des Betriebs verschiedene Statistiken √ºber die Verwendung von Containern gesammelt. Abh√§ngig vom aktuellen Lastprofil w√§hlen sie bestimmte Container aus und ersetzen sie automatisch w√§hrend des Betriebs.  Leider sind die Quellen geschlossen und es gibt keine Chance, sie zu bekommen (ich habe es versucht). <br><br>  Ich empfehle auch, verschiedene Werke (es gibt viele) auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SETL anzuschauen</a> .  In ihnen stellten die Autoren auch h√§ufig Fragen zur automatischen Auswahl des Containers. <br><br><h3>  Referenzen </h3><br><ol><li>  Aktuelle Implementierung auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Github</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">C ++ Russland 2017: Yuri Efimochev, ordentlich: eine Reise in den abstrakten C ++ - Syntaxbaum</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Cham√§leon: Adaptive Auswahl von Sammlungen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Clang Static Analyzer Guide</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Russischsprachiger Chat</a> zur Entwicklung von Compilern im Telegramm.  Wenn Sie interessiert sind, kommen Sie herein, es ist dort sehr interessant.  Sei einfach vorsichtig mit der Flut - sie werden ihn sofort bestrafen :) </li></ol><br>  Anstelle einer Schlussfolgerung m√∂chte ich mich auf die Tatsache konzentrieren, dass es sich bisher nur um einen Prototyp handelt und zu viele ‚ÄûL√ºcken‚Äú in der Implementierung aufweisen.  In diesem Artikel m√∂chte ich Ihnen nur die Idee einer solchen Analyse und ihre Popularisierung mitteilen.  Nun, vielleicht interessiert sich jemand f√ºr dieses Thema und es besteht der Wunsch, sich mit dem Projekt zu verbinden - ich werde nur gl√ºcklich sein!  Dar√ºber hinaus k√∂nnen Sie diesen Analysator jederzeit an Ihrem eigenen Ort sammeln, um ihn an Ihren Testbeispielen zu testen. <br><br>  Wenn Sie etwas zur Erg√§nzung des Materials haben, auf ein √§hnliches Problem gesto√üen sind oder einfach einige Informationen haben, die zu diesem Thema n√ºtzlich sein k√∂nnen, z√∂gern Sie bitte nicht, diese Informationen in den Kommentaren zu teilen. <br><br>  Vielen Dank f√ºr Ihre Aufmerksamkeit! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de455379/">https://habr.com/ru/post/de455379/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de455369/index.html">Zertifizierung von Datenbankadministratoren und vielem mehr zum Jubil√§um von DevConfX (21.-22. Juni in Moskau)</a></li>
<li><a href="../de455371/index.html">Stabile Stromquelle von 5 ŒºA bis 20 mA</a></li>
<li><a href="../de455373/index.html">Wie kann man das Fr√ºhlingsgesetz so anpassen, dass es f√ºr kleine Anbieter zum Aufschwung wird? Abbrechen</a></li>
<li><a href="../de455375/index.html">UDR in Pascal schreiben</a></li>
<li><a href="../de455377/index.html">IoT-Architektur</a></li>
<li><a href="../de455381/index.html">Der technische Support von 3CX antwortet: Erfassen Sie den SIP-Verkehr auf dem PBX-Server</a></li>
<li><a href="../de455387/index.html">Grundlegendes zum maschinellen Lernen in Elastic Stack (auch bekannt als Elasticsearch, auch bekannt als ELK)</a></li>
<li><a href="../de455389/index.html">Haxe 4: Was ist neu?</a></li>
<li><a href="../de455391/index.html">Teil 1: RISC-V / RocketChip in einem unnat√ºrlichen Lebensraum</a></li>
<li><a href="../de455393/index.html">√úber die Verwendung parametrischer Methoden zur Spektralsch√§tzung im Radar - die MUSIC-Methode. Erg√§nzung zum Artikel</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>