<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💅🏼 🌾 Ⓜ️ 编译的分布式系统配置 👌🏾 🚔 📸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="我想告诉您一种使用分布式系统配置的有趣机制。 使用安全类型以编译语言（Scala）直接显示配置。 在本文中，将分析这种配置的示例，并考虑将已编译的配置引入整个开发过程的各个方面。 





 （ 英文 ） 
 引言 


 构建可靠的分布式系统意味着所有节点都使用与其他节点同步的正确配置。 通常，...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>编译的分布式系统配置</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/primetalk/blog/447694/"><p> 我想告诉您一种使用分布式系统配置的有趣机制。 使用安全类型以编译语言（Scala）直接显示配置。 在本文中，将分析这种配置的示例，并考虑将已编译的配置引入整个开发过程的各个方面。 </p><br><p><img src="https://habrastorage.org/webt/71/bl/ax/71blaxtldz-ia4yftyebaxbam7c.png" alt="配置生命周期"></p><br><p>  （ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">英文</a> ） </p><a name="habracut"></a><br><h3 id="vvedenie"> 引言 </h3><br><p> 构建可靠的分布式系统意味着所有节点都使用与其他节点同步的正确配置。 通常，DevOps技术（terraform，ansible或类似的东西）用于自动生成配置文件（对于每个节点通常都是自己的）。 我们还要确保所有交互节点都使用相同的协议（包括相同的版本）。 否则，不兼容性将嵌入我们的分布式系统中。 在JVM世界中，此要求的一个后果是需要使用包含协议消息的库的相同版本。 </p><br><p> 分布式系统测试呢？ 当然，我们假定在进行集成测试之前为所有组件都提供了单元测试。  （为了使测试结果推断到运行时，我们还必须在测试阶段和运行时提供一组相同的库。） </p><br><p> 使用集成测试时，通常到处都容易在所有节点上使用单个类路径。 我们只需要确保运行时包含相同的类路径即可。  （尽管实际上有可能使用不同的类路径运行不同的节点，但这会导致整个配置复杂，并且难以进行部署和集成测试。）作为本文的一部分，我们假设所有节点上都将使用相同的类路径。 </p><br><p> 配置随应用程序而发展。 为了确定程序发展的各个阶段，我们使用版本。 识别配置的不同版本似乎很合逻辑。 并且配置本身应该放在版本控制系统中。 如果生产中只有一种配置，那么我们可以使用版本号。 如果使用了多个生产实例，那么我们需要几个 <br> 配置分支和版本以外的其他标签（例如，分支的名称）。 因此，我们可以唯一地标识确切的配置。 每个配置标识符唯一地对应于分布式节点，端口，外部资源，库版本的某种组合。 在本文的框架中，我们将从只有一个分支的事实出发，我们可以使用三个以点分隔的数字（1.2.3）以通常的方式识别配置。 </p><br><p> 在现代环境中，很少手动创建配置文件。 它们更多地是在部署期间生成的，并且不再受到影响（以免<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">破坏任何东西</a> ）。 出现一个逻辑问题，为什么我们仍然使用文本格式存储配置？ 完全可行的替代方法是使用常规代码进行配置并在编译时从检查中受益的能力。 </p><br><p> 在本文中，我们只是探讨在已编译工件内部表示配置的想法。 </p><br><h3 id="kompiliruemaya-konfiguraciya"> 编译配置 </h3><br><p> 本节描述静态编译配置的示例。 实现了两个简单的服务-回显服务和客户端回显服务。 基于这两个服务，将组装两个版本的系统。 在一个实施例中，两个服务都位于同一节点上，在另一实施例中，这两个服务位于不同节点上。 </p><br><p>通常，分布式系统包含几个节点。 可以使用某些<code>NodeId</code>类型的值来标识节点： </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NodeId</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Backend</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NodeId</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Frontend</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NodeId</span></span></span></span></code> </pre> <br><p> 或 </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NodeId</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">hostName: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span></span><span class="hljs-class">)</span></span></code> </pre> <br><p> 甚至 </p><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Singleton</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NodeId</span></span></span><span class="hljs-class"> </span></span>= <span class="hljs-type"><span class="hljs-type">Singleton</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">type</span></span></code> </pre> <br><p> 节点扮演各种角色，在它们上启动服务，并可以在它们之间建立TCP / HTTP通信。 </p><br><p> 为了描述TCP通信，我们至少需要一个端口号。 我们还想反映此端口支持的协议，以确保客户端和服务器使用相同的协议。 我们将使用此类描述连接： </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TcpEndPoint</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Protocol</span></span></span><span class="hljs-class">](</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">node: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">NodeId</span></span></span></span><span class="hljs-class"><span class="hljs-params">, port: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Port</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Protocol</span></span></span></span><span class="hljs-class"><span class="hljs-params">]</span></span></span><span class="hljs-class">)</span></span></code> </pre> <br><p> 其中<code>Port</code>只是一个整数<code>Int</code>具有一个有效值范围： </p><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PortNumber</span></span></span><span class="hljs-class"> </span></span>= <span class="hljs-type"><span class="hljs-type">Refined</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">Closed</span></span>[_0, <span class="hljs-type"><span class="hljs-type">W</span></span>.`<span class="hljs-number"><span class="hljs-number">65535</span></span>`.<span class="hljs-type"><span class="hljs-type">T</span></span>]]</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">精制类型</b> <div class="spoiler_text"><p> 请参阅<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">精炼</a>库和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">我的</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">报告</a> 。 简而言之，该库允许您将在编译时检查的约束添加到类型。 在这种情况下，有效的端口号值为16位整数。 对于已编译的配置，使用精炼库是可选的，但它可以提高编译器验证配置的能力。 </p></div></div><br><p> 对于HTTP（REST）协议，除了端口号，我们可能还需要服务的路径： </p><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UrlPathPrefix</span></span></span><span class="hljs-class"> </span></span>= <span class="hljs-type"><span class="hljs-type">Refined</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">MatchesRegex</span></span>[<span class="hljs-type"><span class="hljs-type">W</span></span>.`<span class="hljs-string"><span class="hljs-string">"[a-zA-Z_0-9/]*"</span></span>`.<span class="hljs-type"><span class="hljs-type">T</span></span>]] <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PortWithPrefix</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Protocol</span></span></span><span class="hljs-class">](</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">portNumber: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">PortNumber</span></span></span></span><span class="hljs-class"><span class="hljs-params">, pathPrefix: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">UrlPathPrefix</span></span></span></span></span><span class="hljs-class">)</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">幻影类型</b> <div class="spoiler_text"><p> 为了在编译阶段识别协议，我们使用在类内部未使用的类型参数。 该决定是由于以下事实：在运行时我们不使用协议实例，但是我们希望编译器检查协议兼容性。 由于该协议，我们将无法将不适当的服务作为依赖项进行传输。 </p></div></div><br><p> 一种常见的协议是带有Json序列化的REST API： </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JsonHttpRestProtocol</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RequestMessage</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ResponseMessage</span></span></span><span class="hljs-class">]</span></span></code> </pre> <br><p> 其中<code>RequestMessage</code>是请求的类型， <code>ResponseMessage</code>是<code>ResponseMessage</code>的类型。 <br> 当然，您可以使用其他协议描述来提供我们所需的准确性。 </p><br><p> 出于本文的目的，我们将使用该协议的简化版本： </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleHttpGetRest</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RequestMessage</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ResponseMessage</span></span></span><span class="hljs-class">]</span></span></code> </pre> <br><p> 这里，请求是添加到url中的字符串，响应是HTTP响应正文中返回的字符串。 </p><br><p> 服务配置由服务名称，端口和依赖项描述。 这些元素可以通过Scala的几种方式表示（例如， <code>HList</code> ，代数数据类型）。 出于本文的目的，我们将使用Cake Pattern并使用<code>trait</code>表示模块。  （“蛋糕模式”不是所描述方法的必要元素。它只是可能的实现之一。） </p><br><p> 服务之间的依赖关系可以表示为返回其他节点的<code>EndPoint</code>端口的方法： </p><br><pre> <code class="scala hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EchoProtocol</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">] </span></span>= <span class="hljs-type"><span class="hljs-type">SimpleHttpGetRest</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>, <span class="hljs-type"><span class="hljs-type">A</span></span>] <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EchoConfig</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">] </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ServiceConfig</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">portNumber</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">PortNumber</span></span> = <span class="hljs-number"><span class="hljs-number">8081</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">echoPort</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">PortWithPrefix</span></span>[<span class="hljs-type"><span class="hljs-type">EchoProtocol</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>]] = <span class="hljs-type"><span class="hljs-type">PortWithPrefix</span></span>[<span class="hljs-type"><span class="hljs-type">EchoProtocol</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>]](portNumber, <span class="hljs-string"><span class="hljs-string">"echo"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">echoService</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">HttpSimpleGetEndPoint</span></span>[<span class="hljs-type"><span class="hljs-type">NodeId</span></span>, <span class="hljs-type"><span class="hljs-type">EchoProtocol</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>]] = providedSimpleService(echoPort) }</code> </pre> <br><p> 要创建回显服务，仅端口号和此端口支持回显协议的指示就足够了。 我们无法指定特定的端口，因为 特质允许您声明没有实现的方法（抽象方法）。 在这种情况下，当创建特定配置时，编译器将要求我们提供抽象方法实现并提供端口号。 由于我们实现了该方法，因此在创建特定配置时，我们无法指定其他端口。 将使用默认值。 </p><br><p> 在客户端配置中，我们声明对echo服务的依赖： </p><br><pre> <code class="scala hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EchoClientConfig</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">] </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testMessage</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">String</span></span> = <span class="hljs-string"><span class="hljs-string">"test"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pollInterval</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">FiniteDuration</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">echoServiceDependency</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">HttpSimpleGetEndPoint</span></span>[_, <span class="hljs-type"><span class="hljs-type">EchoProtocol</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>]] }</code> </pre> <br><p> 依赖项与<code>echoService</code>导出的服务具有相同的类型。 特别是，在回显客户端中，我们需要相同的协议。 因此，在连接这两个服务时，我们可以确保一切正常。 </p><br><div class="spoiler">  <b class="spoiler_title">服务实施</b> <div class="spoiler_text"><p> 要启动和停止服务，需要一个功能。  （停止服务的能力对于测试至关重要。）同样，实现此功能有多种选择（例如，我们可以根据配置类型使用类型类）。 出于本文的目的，我们将使用蛋糕图案。 我们将使用<code>cats.Resource</code>类表示服务，因为 在此类中，已经提供了在出现问题时可以安全保证释放资源的方法。 为了获得资源，我们需要提供配置和就绪的运行时上下文。 启动服务的功能可能如下所示： </p><br><pre> <code class="scala hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ResourceReader</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">F</span></span></span><span class="hljs-class">[_], </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Config</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">] </span></span>= <span class="hljs-type"><span class="hljs-type">Reader</span></span>[<span class="hljs-type"><span class="hljs-type">Config</span></span>, <span class="hljs-type"><span class="hljs-type">Resource</span></span>[<span class="hljs-type"><span class="hljs-type">F</span></span>, <span class="hljs-type"><span class="hljs-type">A</span></span>]] <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ServiceImpl</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">F</span></span></span><span class="hljs-class">[_]] </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Config</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">def</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">resource</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params"> implicit resolver: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">AddressResolver</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">F</span></span></span></span><span class="hljs-class"><span class="hljs-params">], timer: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Timer</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">F</span></span></span></span><span class="hljs-class"><span class="hljs-params">], contextShift: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">ContextShift</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">F</span></span></span></span><span class="hljs-class"><span class="hljs-params">], ec: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">ExecutionContext</span></span></span></span><span class="hljs-class"><span class="hljs-params">, applicative: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Applicative</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">F</span></span></span></span><span class="hljs-class"><span class="hljs-params">] </span></span></span><span class="hljs-class">)</span></span>: <span class="hljs-type"><span class="hljs-type">ResourceReader</span></span>[<span class="hljs-type"><span class="hljs-type">F</span></span>, <span class="hljs-type"><span class="hljs-type">Config</span></span>, <span class="hljs-type"><span class="hljs-type">Unit</span></span>] }</code> </pre> <br><p> 在哪里 </p><br><ul><li>  <code>Config</code>此服务的配置类型 </li><li>  <code>AddressResolver</code>一个运行时对象，可让您查找其他节点的地址（请参见下文） </li></ul><br><p> 和其他来自<code>cats</code>库的类型： </p><br><ul><li>  <code>F[_]</code> -效果类型（在最简单的情况下， <code>F[A]</code>可以只是一个函数<code>() =&gt; A</code>在本文中，我们将使用<code>cats.IO</code> ） </li><li>  <code>Reader[A,B]</code> -或多或少地与函数<code>A =&gt; B</code> </li><li>  <code>cats.Resource</code>可以获取和释放的资源 </li><li>  <code>Timer</code> -计时器（允许您入睡一段时间并测量时间间隔） </li><li>  <code>ContextShift</code> - <code>ExecutionContext</code>类似物 </li><li>  <code>Applicative</code> -效果类型类，可让您组合各个效果（几乎是monad）。 在更复杂的应用程序中，使用<code>Monad</code> / <code>ConcurrentEffect</code>似乎更好。 </li></ul><br><p> 使用此功能签名，我们可以实现多种服务。 例如，什么都不做的服务： </p><br><pre> <code class="scala hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ZeroServiceImpl</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">F</span></span></span><span class="hljs-class">[_]] </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ServiceImpl</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">F</span></span></span><span class="hljs-class">] </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Config</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">&lt;</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Any</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resource</span></span></span></span>(...): <span class="hljs-type"><span class="hljs-type">ResourceReader</span></span>[<span class="hljs-type"><span class="hljs-type">F</span></span>, <span class="hljs-type"><span class="hljs-type">Config</span></span>, <span class="hljs-type"><span class="hljs-type">Unit</span></span>] = <span class="hljs-type"><span class="hljs-type">Reader</span></span>(_ =&gt; <span class="hljs-type"><span class="hljs-type">Resource</span></span>.pure[<span class="hljs-type"><span class="hljs-type">F</span></span>, <span class="hljs-type"><span class="hljs-type">Unit</span></span>](())) }</code> </pre> </div></div><br><p>  （请参阅其他服务的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">源代码</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">-echo service</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">echo client</a> <br> 和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">生命周期控制器</a> 。） </p><br><p> 节点是一个可以启动多个服务的对象（蛋糕模式可确保资源链的启动）： </p><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SingleNodeImpl</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ZeroServiceImpl</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IO</span></span></span><span class="hljs-class">] </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EchoServiceService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EchoClientService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FiniteDurationLifecycleServiceImpl</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Config</span></span></span><span class="hljs-class"> </span></span>= <span class="hljs-type"><span class="hljs-type">EchoConfig</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-type"><span class="hljs-type">EchoClientConfig</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-type"><span class="hljs-type">FiniteDurationLifecycleConfig</span></span> }</code> </pre> <br><p> 请注意，我们指出了此节点所需的确切配置类型。 如果我们忘记指定单独服务所需的一种配置类型，则会出现编译错误。 同样，如果我们没有为某些适当类型的对象提供所有必要的数据，我们将无法启动该节点。 </p><br><div class="spoiler">  <b class="spoiler_title">主机名解析</b> <div class="spoiler_text"><p> 要连接到远程主机，我们需要一个真实的IP地址。 地址可能比配置的其余部分晚知道。 因此，我们需要一个将节点标识符映射到地址的函数： </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NodeAddress</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NodeId</span></span></span><span class="hljs-class">](</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">host: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Uri</span></span></span></span><span class="hljs-class"><span class="hljs-params">.</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Host</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AddressResolver</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">F</span></span></span><span class="hljs-class">[_]] </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resolve</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">NodeId</span></span>](nodeId: <span class="hljs-type"><span class="hljs-type">NodeId</span></span>): <span class="hljs-type"><span class="hljs-type">F</span></span>[<span class="hljs-type"><span class="hljs-type">NodeAddress</span></span>[<span class="hljs-type"><span class="hljs-type">NodeId</span></span>]] }</code> </pre> <br><p> 您可以提供几种方法来实现此功能： </p><br><ol><li> 如果在部署之前我们已经知道地址，则可以使用以下命令生成Scala代码： <br> 地址，然后启动程序集。 这将编译并运行测试。 <br> 在这种情况下，该函数将是静态已知的，并且可以在代码中表示为地图显示<code>Map[NodeId, NodeAddress]</code> 。 </li><li> 在某些情况下，仅在节点启动后，才知道有效地址。 <br> 在这种情况下，我们可以实现“发现服务”（发现），该服务在其他节点之前运行，并且所有节点都将在此服务中注册并请求其他节点的地址。 </li><li> 如果我们可以修改<code>/etc/hosts</code> ，那么我们可以使用预定义的主机名（例如<code>my-project-main-node</code>和<code>echo-backend</code> ）并仅绑定这些名称 <br> 在部署期间使用IP地址。 </li></ol><br><p> 在本文的框架中，我们将不更详细地考虑这些情况。 为了我们 <br> 在一个玩具示例中，所有节点将具有一个IP地址<code>127.0.0.1</code> 。 </p></div></div><br><p> 接下来，我们考虑分布式系统的两个选项： </p><br><ol><li> 将所有服务放在一个节点上。 </li><li> 并将回显服务和回显客户端放置在不同的节点上。 </li></ol><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">单个节点的</a>配置： </p><br><div class="spoiler">  <b class="spoiler_title">单节点配置</b> <div class="spoiler_text"><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SingleNodeConfig</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EchoConfig</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">] </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EchoClientConfig</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">] </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FiniteDurationLifecycleConfig</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Singleton</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">//</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">identifier</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">of</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">the</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">single</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">node</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">//</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">configuration</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">of</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">server</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NodeId</span></span></span><span class="hljs-class"> </span></span>= <span class="hljs-type"><span class="hljs-type">Singleton</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">nodeId</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-type"><span class="hljs-type">Singleton</span></span> <span class="hljs-comment"><span class="hljs-comment">/** Type safe service port specification. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">portNumber</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">PortNumber</span></span> = <span class="hljs-number"><span class="hljs-number">8088</span></span> <span class="hljs-comment"><span class="hljs-comment">// configuration of client /** We'll use the service provided by the same host. */ def echoServiceDependency = echoService override def testMessage: UrlPathElement = "hello" def pollInterval: FiniteDuration = 1.second // lifecycle controller configuration def lifetime: FiniteDuration = 10500.milliseconds // additional 0.5 seconds so that there are 10 requests, not 9. }</span></span></code> </pre> </div></div><br><p> 该对象实现客户端和服务器的配置。 还使用生命周期的配置，以便在<code>lifetime</code>结束后结束程序。  （Ctrl-C也可以正常工作并正确释放所有资源。） </p><br><p> 可以使用相同的一组配置特征和实现来创建一个由<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">两个单独的节点</a>组成的系统： </p><br><div class="spoiler">  <b class="spoiler_title">两个节点的配置</b> <div class="spoiler_text"><pre> <code class="scala hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NodeServerConfig</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EchoConfig</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">] </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SigTermLifecycleConfig</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NodeId</span></span></span><span class="hljs-class"> </span></span>= <span class="hljs-type"><span class="hljs-type">NodeIdImpl</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">nodeId</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-type"><span class="hljs-type">NodeServer</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">portNumber</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">PortNumber</span></span> = <span class="hljs-number"><span class="hljs-number">8080</span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NodeClientConfig</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EchoClientConfig</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">] </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FiniteDurationLifecycleConfig</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// NB! dependency specification def echoServiceDependency = NodeServerConfig.echoService def pollInterval: FiniteDuration = 1.second def lifetime: FiniteDuration = 10500.milliseconds // additional 0.5 seconds so that there are 10 request, not 9. def testMessage: String = "dolly" }</span></span></code> </pre> </div></div><br><p> 重要！ 请注意如何执行服务绑定。 我们将一个节点实现的服务表示为另一节点的依赖方法的实现。 依赖项的类型由编译器检查，因为 包含协议的类型。 启动后，依赖项将包含目标节点的正确标识符。 由于采用了这种方案，我们只需一次指定端口号即可，始终保证可以引用正确的端口。 </p><br><div class="spoiler">  <b class="spoiler_title">实现两个系统节点</b> <div class="spoiler_text"><p> 对于此配置，我们使用相同的服务实现而不进行更改。 唯一的区别是，现在我们有两个实现不同服务集的对象： </p><br><pre> <code class="scala hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TwoJvmNodeServerImpl</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ZeroServiceImpl</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IO</span></span></span><span class="hljs-class">] </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EchoServiceService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SigIntLifecycleServiceImpl</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Config</span></span></span><span class="hljs-class"> </span></span>= <span class="hljs-type"><span class="hljs-type">EchoConfig</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-type"><span class="hljs-type">SigTermLifecycleConfig</span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TwoJvmNodeClientImpl</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ZeroServiceImpl</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IO</span></span></span><span class="hljs-class">] </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EchoClientService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FiniteDurationLifecycleServiceImpl</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Config</span></span></span><span class="hljs-class"> </span></span>= <span class="hljs-type"><span class="hljs-type">EchoClientConfig</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-type"><span class="hljs-type">FiniteDurationLifecycleConfig</span></span> }</code> </pre> <br><p> 第一个节点实现服务器，仅需要服务器配置。 第二个节点由客户端实现，并使用配置的另一部分。 两个节点还需要管理生存时间。 服务器节点无限期运行，直到它被<code>SIGTERM</code>停止，并且客户端节点在一段时间后终止。 请参阅<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">启动应用程序</a> 。 </p></div></div><br><h4 id="obschiy-process-razrabotki"> 总体开发过程 </h4><br><p> 让我们看看这种配置方法如何影响整个开发过程。 </p><br><p> 该配置将与其余代码一起编译，并将生成工件（.jar）。 显然，将配置放在单独的工件中很有意义。 这是由于这样的事实，我们可以基于同一代码进行许多配置。 同样，您可以生成对应于不同配置分支的工件。 每当我们决定部署此版本的配置时，连同配置一起，将保留对特定版本库的依赖关系，并将永久保留这些版本。 </p><br><p> 任何配置更改都将变成代码更改。 因此，每个这样的 <br> 更改将包含在常规质量保证流程中： </p><br><p>  Bugtracker中的票证-&gt; PR-&gt;评论-&gt;与相应的分支合并-&gt; <br> 集成-&gt;部署 </p><br><p> 实施编译配置的主要结果： </p><br><ol><li><p> 该配置将在分布式系统的所有节点上进行协调。 由于所有节点都从单一来源接收相同的配置。 </p><br></li><li><p> 仅在一个节点中更改配置是有问题的。 因此，“配置漂移”是不可能的。 </p><br></li><li><p> 进行小的配置更改变得更加困难。 </p><br></li><li><p> 大多数配置更改将在整个开发过程中发生，并将进行审查。 </p><br></li></ol><br><p> 我需要一个单独的存储库来存储生产配置吗？ 这样的配置可能包含密码和其他机密信息，我们希望限制其访问。 基于此，将最终配置存储在单独的存储库中似乎很有意义。 您可以将配置分为两部分-一部分包含公共配置设置，另一部分包含受限访问设置。 这将使大多数开发人员可以访问公用参数。 使用包含默认值的中间特征可以轻松实现这种分离。 </p><br><h3 id="vozmozhnye-variacii"> 可能的变化 </h3><br><p> 让我们尝试将编译后的配置与一些常见替代方案进行比较： </p><br><ol><li> 目标计算机上的文本文件。 </li><li> 键值集中存储（ <code>etcd</code> / <code>zookeeper</code> ）。 </li><li> 可以重新配置/重新启动而无需重新启动过程的过程组件。 </li><li> 在工件和版本控制之外存储配置。 </li></ol><br><p> 文本文件在小的更改方面提供了极大的灵活性。 系统管理员可以转到远程节点，对相应的文件进行更改，然后重新启动服务。 但是，对于大型系统，这种灵活性可能是不希望的。 根据所做的更改，其他系统中没有任何痕迹。 没有人评论更改。 很难确定谁进行了更改以及出于何种原因进行了更改。 更改未经测试。 如果系统是分布式的，则管理员可能会忘记在其他节点上进行相应的更改。 </p><br><p>  （还应注意，使用已编译的配置不会阻止将来使用文本文件的可能性。添加一个解析器和验证器以提供相同类型的<code>Config</code>作为输出就足够了，您可以使用文本文件。随之而来的是，具有已编译配置的系统的复杂性有所提高少于使用文本文件的系统的复杂性，因为文本文件需要其他代码。） </p><br><p> 集中式键值存储是一种用于分发分布式应用程序的元参数的好机制。 我们应该确定什么是配置参数，什么是数据。 假设我们有一个函数<code>C =&gt; A =&gt; B</code> ，其中参数<code>C</code>很少更改，而数据<code>A</code>经常更改。 在这种情况下，我们可以说<code>C</code>是配置参数，而<code>A</code>是数据。 似乎配置参数与数据的不同之处在于，配置参数的更改频率通常小于数据更改的频率。 同样，数据通常来自一个来源（来自用户），而配置参数来自另一个来源（来自系统管理员）。 </p><br><p> 如果很少更改的参数需要在不重新启动程序的情况下进行更新，则这通常会导致程序复杂化，因为我们将需要以某种方式传递参数，存储，解析和检查，处理不正确的值。 因此，从降低程序复杂性的角度来看，减少在程序期间可以更改的参数数量（或者根本不支持此类参数）是有意义的。 </p><br><p> 从这篇文章的角度来看，我们将区分静态参数和动态参数。 如果服务逻辑需要在程序中更改参数，则我们将这些参数称为动态参数。 否则，参数是静态的，可以使用编译配置进行配置。 对于动态重新配置，我们可能需要一种机制来使用新参数重新启动程序的各个部分，类似于重新启动操作系统的过程。  （我们认为，随着系统复杂性的增加，建议避免实时重新配置。如果可能的话，最好使用标准OS功能来重新启动进程。） </p><br><p> 使用静态配置迫使人们考虑动态重新配置的一个重要方面是配置更新（停机）后系统重新启动所花费的时间。 实际上，如果需要更改静态配置，则必须重新启动系统以使新值生效。 停机时间问题对于不同的系统具有不同的严重性。 在某些情况下，您可以在负载最小时安排重新启动时间。 如果要提供连续服务，则可以实施<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“排水连接”（AWS ELB连接排水）</a> 。 同时，当我们需要重新引导系统时，我们启动该系统的并行实例，将平衡器切换到该实例，然后等待直到旧的连接完成为止。 所有旧连接完成后，我们关闭旧系统实例。 </p><br><p> 现在让我们考虑将配置存储在工件内部或外部的问题。 如果我们将配置存储在工件中，那么至少在组装工件时我们有机会确保配置正确。 如果配置不在受控工件的范围内，则很难跟踪谁和为什么对此文件进行了更改。 这有多重要？ 我们认为，对于许多生产系统而言，拥有稳定且高质量的配置非常重要。 </p><br><p> 工件的版本使您可以确定它的创建时间，包含的值，启用/禁用的功能以及负责配置更改的人员。 当然，将配置存储在工件中需要付出一些努力，因此您需要做出明智的决定。 </p><br><h3 id="za-i-protiv"> 利弊 </h3><br><p> 我想详细介绍所提议技术的优缺点。 </p><br><h4 id="preimuschestva"> 好处 </h4><br><p> 以下是已编译的分布式系统配置的主要功能的列表： </p><br><ol><li> 静态配置检查。 让您确定 <br> 配置正确。 </li><li>   .         .   Scala      ,   . ,    <br> trait'    ,     ,    val',    (DRY)    .        ( <code>Seq</code> , <code>Map</code> ,  ). </li><li> DSL.  Scala    ,   DSL.        ,         , ,           .  , ,     . </li><li>     .    ,           ,       ,    ,   .        ,          .       ,       . </li><li>    .    ,    ,        . </li><li>   .          ,     . </li><li>  .     ,      .     . (  ,     ,     ,     ,     -.)       —    .  , ,    ,       ,    . </li><li>  .          ,         .   , ,        .                .        .       ,       production'. </li><li> .    ,            .  ,           ,    —   .      production- . </li><li> 测试。     mock-,     ,   . </li><li>  .                  .  , , ,     . </li></ol><br><h4 id="nedostatki-i-ogranicheniya">    </h4><br><p>               .    : </p><br><ol><li>  .       production',    .        .          .           . </li><li>  .  ,      ,        . </li><li> .      ,     ,    .    /      . </li><li>   .   DevOps    .             . </li><li>    .               (CI/CD).      . </li></ol><br><p>       ,      : </p><br><ol><li>      ,    ,        .    ,    Cake Pattern'     , , <code>HList</code>     (case class')   . </li><li>     ,     : ( <code>package</code> , <code>import</code> ,  ; <code>override def</code> '  ,    ).    ,    DSL.  ,    (, XML),       . </li><li>            . </li></ol><br><h3 id="zaklyuchenie"> 结论 </h3><br><p>                  Scala.                 xml-   .   ,      Scala,          (  Kotlin, C#, Swift, ...).         , ,  ,    ,    ,   . </p><br><p> ,      .       . </p><br><p>     : </p><br><ol><li>         . </li><li>   DSL        . </li><li>         . ,       ,  (1)      ; (2)       . </li></ol><br><h3 id="blagodarnosti">  </h3><br><p>     ,          . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN447694/">https://habr.com/ru/post/zh-CN447694/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN447682/index.html">太空数据中心：发射前24小时</a></li>
<li><a href="../zh-CN447684/index.html">如何在办公室中显示公司价值（没有海报和标语）</a></li>
<li><a href="../zh-CN447686/index.html">LED灯的一个非常重要的参数，很少有人知道</a></li>
<li><a href="../zh-CN447688/index.html">关于位集的问题</a></li>
<li><a href="../zh-CN447690/index.html">分布式系统的可编译配置</a></li>
<li><a href="../zh-CN447696/index.html">为什么城市反对第一家非现金商店Amazon Go</a></li>
<li><a href="../zh-CN447698/index.html">红霍格沃茨：没有文凭的院士</a></li>
<li><a href="../zh-CN447700/index.html">情绪上的灵活性是个人成长的关键。</a></li>
<li><a href="../zh-CN447702/index.html">理想的数学圈不存在</a></li>
<li><a href="../zh-CN447704/index.html">爬Elbrus-侦察战。 技术部分1.寄存器，堆栈和其他技术细节</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>