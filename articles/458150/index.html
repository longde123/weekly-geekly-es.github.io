<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏈 🈁 🐌 Microoptimización de mirilla en compiladores C ++ y C # 🛵 👸🏾 💡</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En la escuela, cuando resolvimos ecuaciones o consideramos fórmulas, intentamos reducirlas primero varias veces, por ejemplo, Z = X - (Y + X) reduce a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Microoptimización de mirilla en compiladores C ++ y C #</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/458150/"><p> En la escuela, cuando resolvimos ecuaciones o consideramos fórmulas, intentamos reducirlas primero varias veces, por ejemplo, <code>Z = X - (Y + X)</code> reduce a <code>Z = -Y</code> .  En los compiladores modernos, este es un subconjunto de las llamadas optimizaciones de mirilla, en las que, en términos generales, un conjunto de patrones reducimos expresiones, reemplazamos instrucciones por otras más rápidas para un procesador en particular, etc.  En este artículo, he compilado una colección de tales optimizaciones que se encontraron en las fuentes LLVM, GCC y .NET Core (CoreCLR). </p><br><p>  Comencemos con ejemplos simples: </p><br><pre> <code class="cpp hljs"> X * <span class="hljs-number"><span class="hljs-number">1</span></span> =&gt; X -X * -Y =&gt; X * Y -(X - Y) =&gt; Y - XX * Z - Y * Z =&gt; Z * (X - Y)</code> </pre> <br><p>  verifique el último ejemplo en C ++ y en C #: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x * z - y * z; <span class="hljs-comment"><span class="hljs-comment">// =&gt; z * (x - y) }</span></span></code> </pre> <br><p>  y mire el ensamblador de Clang (LLVM), GCC, MSVC y .NET Core: <br><img src="https://habrastorage.org/webt/up/xl/zo/upxlzopwz17gkq290kycswi4_qq.png"></p><a name="habracut"></a><br><p>  Los tres compiladores de C ++ (GCC, Clang y MSVC) redujeron una multiplicación (solo vemos una instrucción <code>imul</code> ).  C # no hizo esto con RyuJIT, pero no se apresure a regañarlo por eso, es solo que esta clase de optimizaciones está disponible en una composición limitada allí.  Para hacerle entender, la implementación de toda la transformación InstCombine en LLVM requiere más de 30k líneas de código (+ 20k líneas en DAGCombiner.cpp), además, esta transformación a menudo causa una larga compilación.  <a href="">Por cierto, el sitio</a> responsable de esta optimización está allí.  GCC tiene un DSL especial que describe el agujero de optimización, <a href="">aquí hay un fragmento</a> ). </p><br><p>  Decidí, por el bien del artículo, intentar implementar esta optimización en C # JIT (sostenga mi cerveza): </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/692/14c/c65/69214cc65fd41d79f8d53caf4021c9af.png" alt="imagen"></p><br><p>  La confirmación completa se puede ver aquí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">EgorBo / coreclr</a> .  Veamos mi mejora ahora (en Visual Studio 2019 + Disasmo: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/e53/e77/de9/e53e77de91d647f78f021d10fb57a8c9.png" alt="imagen"></p><br><p>  Funciona!  <code>lea</code> + <code>imul</code> lugar de <code>imul</code> , <code>imul</code> y <code>add</code> . </p><br><p>  Volvamos a C ++ y rastreemos esta optimización en Clang.  Para hacer esto, solicite a clang que nos dé el IR LLVM inicial a través de <code>-emit-llvm -g0</code> , y luego se lo entregue a LLVM al optimizador, usando los <code>-O2 -print-before-all -print-after-all</code> para capturar el momento exacto de la transformación elimina la multiplicación del conjunto <code>-O2</code> (todo esto se puede ver en el maravilloso recurso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">godbolt.org</a> ): </p><br><pre> <code class="plaintext hljs">; *** IR Dump Before Combine redundant instructions *** define dso_local i32 @_Z5Case1iii(i32, i32, i32) { %4 = mul nsw i32 %0, %2 %5 = mul nsw i32 %1, %2 %6 = sub nsw i32 %4, %5 ret i32 %6 } ; *** IR Dump After Combine redundant instructions *** define dso_local i32 @_Z5Case1iii(i32, i32, i32) { %4 = sub i32 %0, %1 %5 = mul i32 %4, %2 ret i32 %5 }</code> </pre> <br><p>  También puede divertirse en godbolt con las herramientas LLVM: opt (optimizador) y llc (para compilar LLVM IR en asm): </p><br><p><img src="https://habrastorage.org/webt/yr/x-/dw/yrx-dw9mx9tqbrp97ts3smndy0i.png"></p><br><p>  De vuelta a los ejemplos.  Encontré este muy buen ejemplo en GCC. </p><br><pre> <code class="cpp hljs">X == C - X =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> C is odd</code> </pre> <br><p>  Y es cierto: si <code></code> (constante, literal) es par entonces, por ejemplo, puede escribir <code>4 == 8 - 4</code> .  Pero si en lugar de 8 escribe uno extraño, entonces no puede encontrar una <code>X</code> tal que se cumpla la igualdad: </p><br><p><img src="https://habrastorage.org/webt/lt/qn/pq/ltqnpqgmnbcyszoj0dv7nawouk8.png"></p><br><h3 id="ieee754-nanosit-otvetnyy-udar">  IEEE754 contraataca </h3><br><p>  Muchas optimizaciones funcionan para diferentes tipos de datos, por ejemplo, <code>byte</code> , <code>int</code> , <code>unsigned</code> , <code>float</code> , <code>double</code> .  Con este último, las cosas no son tan simples y las optimizaciones son manejadas por la especificación IEEE754, que se volverá loca si reduce <code>A - B - A</code> a <code>-B</code> o <code>(A * B) * C</code> reorganiza a <code>A * (B * C)</code> t. a.  Las operaciones no son asociativas.  Pero hay un modo especial en los compiladores modernos que le permite descuidar las especificaciones y los valores límite (NaN, + -Inf, + -0.0) en tales casos y realizar optimizaciones de forma segura: esta es Fast Math (mi solicitud de PR para agregar dicho modo a C # se puede encontrar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> ) </p><br><p>  Como puede ver en <code>-ffast-math</code> no hay más dos <code>vsubss</code> : <br><img src="https://habrastorage.org/webt/s3/et/-9/s3et-9dc6vml6f-ous27z-1xlhm.png"></p><br><p>  Además de las expresiones, los optimizadores también tienen en cuenta el malabarismo con las funciones matemáticas de <code>math.h</code> , por ejemplo, el producto de los módulos del número X es igual al producto del número X: </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(X) * <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(X) =&gt; X * X</code> </pre> <br><p>  La raíz cuadrada siempre es positiva: </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(X) &lt; Y =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Y is negative. <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(X) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span></code> </pre> <br><p>  ¿Por qué calcular la raíz, si es posible en la etapa de compilación calcular el cuadrado de la constante a la derecha? </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(X) &gt; C =&gt; X &gt; C * C</code> </pre> <br><p><img src="https://habrastorage.org/getpro/habr/post_images/988/d7e/cbd/988d7ecbd50be253a6b3314760ed3348.png" alt="imagen"></p><br><p>  Más operaciones de root: </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(X) == <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(Y) =&gt; X == Y <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(X) * <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(X) =&gt; X <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(X) * <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(Y) =&gt; <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(X * Y) logN(<span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(X)) =&gt; <span class="hljs-number"><span class="hljs-number">0.5</span></span>*logN(X)</code> </pre> <br><p>  Un poco más de matemática escolar: </p><br><pre> <code class="cpp hljs">expN(X) * expN(Y) -&gt; expN(X + Y)</code> </pre> <br><p>  Y mi optimización favorita: </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(X) / <span class="hljs-built_in"><span class="hljs-built_in">cos</span></span>(X) =&gt; <span class="hljs-built_in"><span class="hljs-built_in">tan</span></span>(X)</code> </pre> <br><p><img src="https://habrastorage.org/getpro/habr/post_images/93a/875/4dd/93a8754dd42b07497f6a164bb60172af.png" alt="imagen"></p><br><p>  Muchas operaciones aburridas de bits y booleanos: </p><br><pre> <code class="cpp hljs">((a ^ b) | a) -&gt; (a | b) (a &amp; ~b) | (a ^ b) --&gt; a ^ b ((a ^ b) | a) -&gt; (a | b) (X &amp; ~Y) |^+ (~X &amp; Y) -&gt; X ^ Y A - (A &amp; B) into ~B &amp; A X &lt;= Y - <span class="hljs-number"><span class="hljs-number">1</span></span> equals to X &lt; Y A &lt; B || A &gt;= B -&gt; <span class="hljs-literal"><span class="hljs-literal">true</span></span> ...   !</code> </pre> <br><h3 id="nizkourovnevye-optimizacii">  Optimizaciones de bajo nivel </h3><br><p>  Hay un conjunto de optimizaciones que a primera vista no tienen sentido con  matemáticos, pero son más amigables con el hierro. </p><br><pre> <code class="cpp hljs">X / <span class="hljs-number"><span class="hljs-number">2</span></span> =&gt; X * <span class="hljs-number"><span class="hljs-number">0.5</span></span></code> </pre> <br><p>  reemplazar división por multiplicación: </p><br><p><img src="https://habrastorage.org/webt/1n/nz/d2/1nnzd2msn5lxzxlx5t3-hr680cc.png"></p><br><p>  La operación de multiplicación de flota generalmente tiene mejores características de latencia / rendimiento que la división.  Por ejemplo, aquí están las opciones para Intel Haswell: <br><img src="https://habrastorage.org/webt/i1/ej/l_/i1ejl__p9hfkduty-cn4vq0vzvu.png"></p><br><p>  En el modo matemático no rápido, solo se puede usar si la constante es una potencia de dos. <br>  Por cierto, recientemente intenté agregar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">dicha</a> optimización en C #.  Es decir  si, por ejemplo, necesita abrir un archivo con un modelo 3D y reducir todas las coordenadas 10 veces, entonces * 0.1 manejará esto 20-100% más rápido, lo que puede ser significativo. </p><br><p>  La misma razón para: </p><br><pre> <code class="cpp hljs">X * <span class="hljs-number"><span class="hljs-number">2</span></span> =&gt; X + X</code> </pre> <br><p>  Comparar con cero ( <code>test</code> ) es mejor que comparar con la unidad ( <code>cmp</code> ): mi PR para más detalles es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">dotnet / coreclr # 25458</a> : </p><br><pre> <code class="plaintext hljs">X &gt;= 1 =&gt; X &gt; 0 X &lt; 1 =&gt; X &lt;= 0 X &lt;= -1 =&gt; X &gt;= 0 X &gt; -1 =&gt; X &gt;= 0</code> </pre> <br><p>  Y como te gusta esto: </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(X, <span class="hljs-number"><span class="hljs-number">0.5</span></span>) =&gt; <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(x) <span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(X, <span class="hljs-number"><span class="hljs-number">0.25</span></span>) =&gt; <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(X)) <span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(X, <span class="hljs-number"><span class="hljs-number">2</span></span>) =&gt; X * X ; <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-function"><span class="hljs-function">mul </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(X, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">3</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>=&gt; X * X * X ; <span class="hljs-number"><span class="hljs-number">2</span></span> mul</code> </pre> <br><p><img src="https://habrastorage.org/webt/hd/ag/lm/hdaglmbx5f7zfibbpgzdre0swjo.png"></p><br><p>  ¿Qué piensas, cuántas operaciones de multiplicación necesitas para contar <code>mod(X, 4)</code> o <code>X * X * X * X</code> ? </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/f5d/118/3c0/f5d1183c005a7f72b6fbabdd18995d7e.png" alt="imagen"></p><br><p>  Dos!  Además de calcular el 3er grado, y en el caso 4 usamos solo un registro <code>xmm0</code> . </p><br><p>  Muchos procesadores admiten una instrucción especial (FMA), que le permite realizar multiplicaciones y sumas a la vez, manteniendo la precisión durante la multiplicación: </p><br><pre> <code class="cpp hljs">X * Y + Z =&gt; fmadd(X, Y, Z)</code> </pre> <br><p><img src="https://habrastorage.org/webt/jf/z5/nh/jfz5nh9fl6-wkx8cfmubntv7o4g.png"></p><br><p>  Dos de mis ejemplos favoritos más son doblar algunos algoritmos en una sola instrucción (si el procesador lo admite): <br><img src="https://habrastorage.org/webt/qj/pv/ya/qjpvya5-s-itzzxubosjpnwonkc.png"></p><br><h3 id="lovushki-dlya-optimizaciy">  Trampas de optimización </h3><br><p>  Creo que todos entienden que no puedes apresurarte y reducir las expresiones por tres razones: </p><br><ul><li>  Puede romper el código en algunos valores límite, desbordamiento, efectos secundarios ocultos, etc. ... Bugzilla LLVM contiene muchos errores de InstCombine. </li><li>  Idealmente, las optimizaciones deberían funcionar juntas en una secuencia específica. </li><li>  La expresión o partes de ella que desea reducir se pueden usar en otros lugares y su reducción conducirá a la degradación del rendimiento. </li></ul><br><p>  Veamos un ejemplo para el último párrafo (espiado en el artículo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Direcciones futuras para la optimización de compiladores</a> ). </p><br><p>  Imagina que tenemos este código: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> na = -a; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nb = -b; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> na + nb; }</code> </pre> <br><p>  necesitamos hacer tres operaciones: <code>0 - a</code> , <code>0 - b</code> , y <code>na + nb</code> .  Pero el optimizador para nosotros reduce esto a dos - <code>return -(a + b);</code>  : </p><br><pre> <code class="plaintext hljs">define dso_local i32 @_Z4Foo1ii(i32, i32) { %3 = add i32 %0, %1 ; a + b %4 = sub i32 0, %3 ; 0 - %3 ret i32 %4 }</code> </pre> <br><p>  Ahora imagine que necesitamos escribir valores intermedios <code>na</code> y <code>nb</code> en variables globales: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x, y; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> na = -a; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nb = -b; x = na; y = nb; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> na + nb; }</code> </pre> <br><p>  El optimizador aún encuentra este patrón y elimina las operaciones innecesarias (desde su punto de vista) <code>0 - b</code> , ¡pero de hecho resulta que son necesarias!  ¡Escribimos los resultados de estas operaciones "innecesarias" en variables globales!  Esto lleva a este código: </p><br><pre> <code class="cpp hljs">define dso_local i32 @_Z4Foo2ii(i32, i32) { %<span class="hljs-number"><span class="hljs-number">3</span></span> = sub nsw i32 <span class="hljs-number"><span class="hljs-number">0</span></span>, %<span class="hljs-number"><span class="hljs-number">0</span></span> ; <span class="hljs-number"><span class="hljs-number">0</span></span> - a %<span class="hljs-number"><span class="hljs-number">4</span></span> = sub nsw i32 <span class="hljs-number"><span class="hljs-number">0</span></span>, %<span class="hljs-number"><span class="hljs-number">1</span></span> ; <span class="hljs-number"><span class="hljs-number">0</span></span> - b store i32 %<span class="hljs-number"><span class="hljs-number">3</span></span>, i32* @x, align <span class="hljs-number"><span class="hljs-number">4</span></span>, !tbaa !<span class="hljs-number"><span class="hljs-number">2</span></span> store i32 %<span class="hljs-number"><span class="hljs-number">4</span></span>, i32* @y, align <span class="hljs-number"><span class="hljs-number">4</span></span>, !tbaa !<span class="hljs-number"><span class="hljs-number">2</span></span> %<span class="hljs-number"><span class="hljs-number">5</span></span> = add i32 %<span class="hljs-number"><span class="hljs-number">0</span></span>, %<span class="hljs-number"><span class="hljs-number">1</span></span> ; a + b %<span class="hljs-number"><span class="hljs-number">6</span></span> = sub i32 <span class="hljs-number"><span class="hljs-number">0</span></span>, %<span class="hljs-number"><span class="hljs-number">5</span></span> ; <span class="hljs-number"><span class="hljs-number">0</span></span> - %<span class="hljs-number"><span class="hljs-number">5</span></span> ret i32 %<span class="hljs-number"><span class="hljs-number">6</span></span> }</code> </pre> <br><p>  ¡Cuatro operaciones matemáticas en lugar de tres!  Nuestro optimizador nos falló y no estaba convencido de que alguien aún necesitara las expresiones intermedias que optimizó.  Ahora echemos un vistazo a la salida de C # RuyJIT, en el que no existe tal optimización inteligente: </p><br><p><img src="https://habrastorage.org/webt/fs/ar/jf/fsarjfwtbnpmp5hzbidevgo3eui.png"></p><br><p>  Tres operaciones en lugar de cuatro: ¡C # resultó ser más rápido que C ++ :-)! </p><br><h3 id="a-nuzhny-li-takie-optimizacii">  ¿Se necesitan tales optimizaciones? </h3><br><p>  Nunca se sabe cómo se verá el código después de que el compilador incorpore todo lo que puede y hace un plegado constante, propagación de copia, CSE, etc.  - Se abrirá una imagen completamente diferente para él.  LLVM IR y .NET IL no están vinculados a un lenguaje de programación específico, y no puede estar seguro de que un PL específico / nuevo pueda traducirse efectivamente a IR.  Bueno, ¿por qué hablar al respecto si puede probar el rendimiento de InstCombine de forma intermitente en una aplicación específica ;-).  Es poco probable que sea una diferencia impresionante, pero quién sabe. </p><br><h3 id="a-chto-na-schet-c">  ¿Qué hay de C #? </h3><br><p>  Como dije, las optimizaciones de las expresiones que examinamos están muy probablemente ausentes en C #.  Pero cuando digo C # quiero decir que el tiempo de ejecución más popular es CoreCLR y RyuJIT.  Pero además de CoreCLR hay otros tiempos de ejecución, incluidos los que usan LLVM como backend: Mono (vea mi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tweet</a> ), Unity Burst, IL2CPP (a través de clang) y LILLC: aquí puede comparar de manera segura los resultados de C ++ con clang.  Los chicos de Unity incluso reescriben el código interno de C ++ en C # sin ninguna pérdida de rendimiento, ¡ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">prueba</a> ! </p><br><p>  Aquí hay algunos pipholes de optimización que se pueden encontrar en el archivo <code>morph.cpp</code> en el código fuente de <code>morph.cpp</code> de los comentarios (claramente hay un poco más): </p><br><pre> <code class="cpp hljs">*(&amp;X) =&gt; X X % <span class="hljs-number"><span class="hljs-number">1</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">0</span></span> X / <span class="hljs-number"><span class="hljs-number">1</span></span> =&gt; X X % Y =&gt; X - (X / Y) * Y X ^ <span class="hljs-number"><span class="hljs-number">-1</span></span> =&gt; ~x X &gt;= <span class="hljs-number"><span class="hljs-number">1</span></span> =&gt; X &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> X &lt; <span class="hljs-number"><span class="hljs-number">1</span></span> =&gt; X &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span> X + <span class="hljs-number"><span class="hljs-number">1</span></span> == C2 =&gt; X == C2 - C1 ((X + C1) + C2) =&gt; (X + (C1 + C2)) ((X + C1) + (Y + C2)) =&gt; ((X + Y) + (C1 + C2))</code> </pre> <br><p>  Se pueden encontrar algunos más en <code>lowering.cpp</code> (bajo nivel), pero en general RyuJIT obviamente pierde aquí a los compiladores de C ++.  RyuJIT tiene prioridades ligeramente diferentes: antes del advenimiento de la compilación de niveles, necesitaba proporcionar una velocidad de compilación aceptable, lo que hace muy bien a diferencia de los compiladores de C ++ (recuerde sobre el pase InstCombine de 30 líneas en LLVM y lea la publicación interesante en general <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">" "Lamentaciones modernas de C ++"</a> ) y es mucho más útil desarrollar optimizaciones en el campo de la desvirtualización de llamadas, la eliminación del boxeo y las asignaciones (la misma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Asignación de pila de objetos</a> ); obviamente, todo esto es mucho más importante que minimizar las divisiones de seno a coseno por tangente. </p><br><p>  Quizás con el advenimiento de la compilación de niveles, con el tiempo habrá muchas optimizaciones nuevas que no son críticas para el tiempo de compilación para el nivel 1 o incluso el nivel 2.  Tal vez incluso con su API de complemento y DSL: acaba de leer este artículo, en él Prathamesh Kulkarni agregó optimización de expresión en GCC en solo un par de líneas DSL: </p><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">simplify</span></span> (<span class="hljs-name"><span class="hljs-name">plus</span></span> (<span class="hljs-name"><span class="hljs-name">mult</span></span> (<span class="hljs-name"><span class="hljs-name">SIN</span></span> @<span class="hljs-number"><span class="hljs-number">0</span></span>) (<span class="hljs-name"><span class="hljs-name">SIN</span></span> @<span class="hljs-number"><span class="hljs-number">0</span></span>)) (<span class="hljs-name"><span class="hljs-name">mult</span></span> (<span class="hljs-name"><span class="hljs-name">COS</span></span> @<span class="hljs-number"><span class="hljs-number">0</span></span>) (<span class="hljs-name"><span class="hljs-name">COS</span></span> @<span class="hljs-number"><span class="hljs-number">0</span></span>))) (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">flag_unsafe_math_optimizations</span></span>)<span class="hljs-number"><span class="hljs-number">1</span></span>. { build_one_cst (<span class="hljs-name"><span class="hljs-name">TREE_TYPE</span></span> (@<span class="hljs-number"><span class="hljs-number">0</span></span>))<span class="hljs-comment"><span class="hljs-comment">; }))</span></span></code> </pre> <br><p>  para esta expresión de un libro de texto de matemáticas ;-): </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">cos</span></span>^<span class="hljs-number"><span class="hljs-number">2</span></span>(X) + <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>^<span class="hljs-number"><span class="hljs-number">2</span></span>(X) equals to <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br><h3 id="poleznye-ssylki">  Enlaces utiles </h3><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Direcciones futuras para la optimización de compiladores"</a> , Nuno P. Lopes y John Regehr </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Cómo LLVM optimiza una función"</a> , John Regehr </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"La sorprendente inteligencia de los compiladores modernos"</a> , Daniel Lemire </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Agregar optimización de mirilla a GCC"</a> , Prathamesh Kulkarni </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"1. C ++, C # y Unity"</a> , Lucas Meijer </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Lamentaciones" modernas de C ++ "</a> , Aras Pranckevičius </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Optimizaciones de mirilla probadamente correctas con vida"</a> , Nuno P. Lopes, David Menéndez, Santosh Nagarakatte y John Regehr </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/458150/">https://habr.com/ru/post/458150/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../458130/index.html">“The Magic Word” para empleadores: experiencia de IIBS NITU “MISiS”</a></li>
<li><a href="../458136/index.html">Nuevo GitLab 12.0 con revisiones visuales y una lista de dependencias.</a></li>
<li><a href="../458142/index.html">Desarrollando Breakout en Svelte</a></li>
<li><a href="../458144/index.html">Noticias de la semana: Raspberry Pi 4 a la venta, Internet en el Examen de Estado Unificado, Roskomnadzor y servicios VPN, una red neuronal despoja a las personas</a></li>
<li><a href="../458146/index.html">Aplicación de contabilidad de comunicación de código abierto en la región.</a></li>
<li><a href="../458156/index.html">Evaluación comparativa de PostgreSQL en FreeBSD, CentOS, Ubuntu Debian y openSUSE</a></li>
<li><a href="../458158/index.html">Buscando asteroides - proyecto Hubble Asteroid Hunter</a></li>
<li><a href="../458164/index.html">Inteligencia artificial: se formulará una pregunta para cada respuesta</a></li>
<li><a href="../458170/index.html">Inmersión en redes neuronales convolucionales. Parte 5/10 - 18</a></li>
<li><a href="../458172/index.html">Métodos para emparejar conexiones eléctricas al rastrear pares diferenciales en placas de circuito impreso</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>