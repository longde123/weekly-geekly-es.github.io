<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèà üàÅ üêå Microoptimizaci√≥n de mirilla en compiladores C ++ y C # üõµ üë∏üèæ üí°</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En la escuela, cuando resolvimos ecuaciones o consideramos f√≥rmulas, intentamos reducirlas primero varias veces, por ejemplo, Z = X - (Y + X) reduce a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Microoptimizaci√≥n de mirilla en compiladores C ++ y C #</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/458150/"><p> En la escuela, cuando resolvimos ecuaciones o consideramos f√≥rmulas, intentamos reducirlas primero varias veces, por ejemplo, <code>Z = X - (Y + X)</code> reduce a <code>Z = -Y</code> .  En los compiladores modernos, este es un subconjunto de las llamadas optimizaciones de mirilla, en las que, en t√©rminos generales, un conjunto de patrones reducimos expresiones, reemplazamos instrucciones por otras m√°s r√°pidas para un procesador en particular, etc.  En este art√≠culo, he compilado una colecci√≥n de tales optimizaciones que se encontraron en las fuentes LLVM, GCC y .NET Core (CoreCLR). </p><br><p>  Comencemos con ejemplos simples: </p><br><pre> <code class="cpp hljs"> X * <span class="hljs-number"><span class="hljs-number">1</span></span> =&gt; X -X * -Y =&gt; X * Y -(X - Y) =&gt; Y - XX * Z - Y * Z =&gt; Z * (X - Y)</code> </pre> <br><p>  verifique el √∫ltimo ejemplo en C ++ y en C #: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x * z - y * z; <span class="hljs-comment"><span class="hljs-comment">// =&gt; z * (x - y) }</span></span></code> </pre> <br><p>  y mire el ensamblador de Clang (LLVM), GCC, MSVC y .NET Core: <br><img src="https://habrastorage.org/webt/up/xl/zo/upxlzopwz17gkq290kycswi4_qq.png"></p><a name="habracut"></a><br><p>  Los tres compiladores de C ++ (GCC, Clang y MSVC) redujeron una multiplicaci√≥n (solo vemos una instrucci√≥n <code>imul</code> ).  C # no hizo esto con RyuJIT, pero no se apresure a rega√±arlo por eso, es solo que esta clase de optimizaciones est√° disponible en una composici√≥n limitada all√≠.  Para hacerle entender, la implementaci√≥n de toda la transformaci√≥n InstCombine en LLVM requiere m√°s de 30k l√≠neas de c√≥digo (+ 20k l√≠neas en DAGCombiner.cpp), adem√°s, esta transformaci√≥n a menudo causa una larga compilaci√≥n.  <a href="">Por cierto, el sitio</a> responsable de esta optimizaci√≥n est√° all√≠.  GCC tiene un DSL especial que describe el agujero de optimizaci√≥n, <a href="">aqu√≠ hay un fragmento</a> ). </p><br><p>  Decid√≠, por el bien del art√≠culo, intentar implementar esta optimizaci√≥n en C # JIT (sostenga mi cerveza): </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/692/14c/c65/69214cc65fd41d79f8d53caf4021c9af.png" alt="imagen"></p><br><p>  La confirmaci√≥n completa se puede ver aqu√≠ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">EgorBo / coreclr</a> .  Veamos mi mejora ahora (en Visual Studio 2019 + Disasmo: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/e53/e77/de9/e53e77de91d647f78f021d10fb57a8c9.png" alt="imagen"></p><br><p>  Funciona!  <code>lea</code> + <code>imul</code> lugar de <code>imul</code> , <code>imul</code> y <code>add</code> . </p><br><p>  Volvamos a C ++ y rastreemos esta optimizaci√≥n en Clang.  Para hacer esto, solicite a clang que nos d√© el IR LLVM inicial a trav√©s de <code>-emit-llvm -g0</code> , y luego se lo entregue a LLVM al optimizador, usando los <code>-O2 -print-before-all -print-after-all</code> para capturar el momento exacto de la transformaci√≥n elimina la multiplicaci√≥n del conjunto <code>-O2</code> (todo esto se puede ver en el maravilloso recurso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">godbolt.org</a> ): </p><br><pre> <code class="plaintext hljs">; *** IR Dump Before Combine redundant instructions *** define dso_local i32 @_Z5Case1iii(i32, i32, i32) { %4 = mul nsw i32 %0, %2 %5 = mul nsw i32 %1, %2 %6 = sub nsw i32 %4, %5 ret i32 %6 } ; *** IR Dump After Combine redundant instructions *** define dso_local i32 @_Z5Case1iii(i32, i32, i32) { %4 = sub i32 %0, %1 %5 = mul i32 %4, %2 ret i32 %5 }</code> </pre> <br><p>  Tambi√©n puede divertirse en godbolt con las herramientas LLVM: opt (optimizador) y llc (para compilar LLVM IR en asm): </p><br><p><img src="https://habrastorage.org/webt/yr/x-/dw/yrx-dw9mx9tqbrp97ts3smndy0i.png"></p><br><p>  De vuelta a los ejemplos.  Encontr√© este muy buen ejemplo en GCC. </p><br><pre> <code class="cpp hljs">X == C - X =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> C is odd</code> </pre> <br><p>  Y es cierto: si <code></code> (constante, literal) es par entonces, por ejemplo, puede escribir <code>4 == 8 - 4</code> .  Pero si en lugar de 8 escribe uno extra√±o, entonces no puede encontrar una <code>X</code> tal que se cumpla la igualdad: </p><br><p><img src="https://habrastorage.org/webt/lt/qn/pq/ltqnpqgmnbcyszoj0dv7nawouk8.png"></p><br><h3 id="ieee754-nanosit-otvetnyy-udar">  IEEE754 contraataca </h3><br><p>  Muchas optimizaciones funcionan para diferentes tipos de datos, por ejemplo, <code>byte</code> , <code>int</code> , <code>unsigned</code> , <code>float</code> , <code>double</code> .  Con este √∫ltimo, las cosas no son tan simples y las optimizaciones son manejadas por la especificaci√≥n IEEE754, que se volver√° loca si reduce <code>A - B - A</code> a <code>-B</code> o <code>(A * B) * C</code> reorganiza a <code>A * (B * C)</code> t. a.  Las operaciones no son asociativas.  Pero hay un modo especial en los compiladores modernos que le permite descuidar las especificaciones y los valores l√≠mite (NaN, + -Inf, + -0.0) en tales casos y realizar optimizaciones de forma segura: esta es Fast Math (mi solicitud de PR para agregar dicho modo a C # se puede encontrar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> ) </p><br><p>  Como puede ver en <code>-ffast-math</code> no hay m√°s dos <code>vsubss</code> : <br><img src="https://habrastorage.org/webt/s3/et/-9/s3et-9dc6vml6f-ous27z-1xlhm.png"></p><br><p>  Adem√°s de las expresiones, los optimizadores tambi√©n tienen en cuenta el malabarismo con las funciones matem√°ticas de <code>math.h</code> , por ejemplo, el producto de los m√≥dulos del n√∫mero X es igual al producto del n√∫mero X: </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(X) * <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(X) =&gt; X * X</code> </pre> <br><p>  La ra√≠z cuadrada siempre es positiva: </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(X) &lt; Y =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Y is negative. <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(X) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span></code> </pre> <br><p>  ¬øPor qu√© calcular la ra√≠z, si es posible en la etapa de compilaci√≥n calcular el cuadrado de la constante a la derecha? </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(X) &gt; C =&gt; X &gt; C * C</code> </pre> <br><p><img src="https://habrastorage.org/getpro/habr/post_images/988/d7e/cbd/988d7ecbd50be253a6b3314760ed3348.png" alt="imagen"></p><br><p>  M√°s operaciones de root: </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(X) == <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(Y) =&gt; X == Y <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(X) * <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(X) =&gt; X <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(X) * <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(Y) =&gt; <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(X * Y) logN(<span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(X)) =&gt; <span class="hljs-number"><span class="hljs-number">0.5</span></span>*logN(X)</code> </pre> <br><p>  Un poco m√°s de matem√°tica escolar: </p><br><pre> <code class="cpp hljs">expN(X) * expN(Y) -&gt; expN(X + Y)</code> </pre> <br><p>  Y mi optimizaci√≥n favorita: </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(X) / <span class="hljs-built_in"><span class="hljs-built_in">cos</span></span>(X) =&gt; <span class="hljs-built_in"><span class="hljs-built_in">tan</span></span>(X)</code> </pre> <br><p><img src="https://habrastorage.org/getpro/habr/post_images/93a/875/4dd/93a8754dd42b07497f6a164bb60172af.png" alt="imagen"></p><br><p>  Muchas operaciones aburridas de bits y booleanos: </p><br><pre> <code class="cpp hljs">((a ^ b) | a) -&gt; (a | b) (a &amp; ~b) | (a ^ b) --&gt; a ^ b ((a ^ b) | a) -&gt; (a | b) (X &amp; ~Y) |^+ (~X &amp; Y) -&gt; X ^ Y A - (A &amp; B) into ~B &amp; A X &lt;= Y - <span class="hljs-number"><span class="hljs-number">1</span></span> equals to X &lt; Y A &lt; B || A &gt;= B -&gt; <span class="hljs-literal"><span class="hljs-literal">true</span></span> ...   !</code> </pre> <br><h3 id="nizkourovnevye-optimizacii">  Optimizaciones de bajo nivel </h3><br><p>  Hay un conjunto de optimizaciones que a primera vista no tienen sentido con  matem√°ticos, pero son m√°s amigables con el hierro. </p><br><pre> <code class="cpp hljs">X / <span class="hljs-number"><span class="hljs-number">2</span></span> =&gt; X * <span class="hljs-number"><span class="hljs-number">0.5</span></span></code> </pre> <br><p>  reemplazar divisi√≥n por multiplicaci√≥n: </p><br><p><img src="https://habrastorage.org/webt/1n/nz/d2/1nnzd2msn5lxzxlx5t3-hr680cc.png"></p><br><p>  La operaci√≥n de multiplicaci√≥n de flota generalmente tiene mejores caracter√≠sticas de latencia / rendimiento que la divisi√≥n.  Por ejemplo, aqu√≠ est√°n las opciones para Intel Haswell: <br><img src="https://habrastorage.org/webt/i1/ej/l_/i1ejl__p9hfkduty-cn4vq0vzvu.png"></p><br><p>  En el modo matem√°tico no r√°pido, solo se puede usar si la constante es una potencia de dos. <br>  Por cierto, recientemente intent√© agregar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">dicha</a> optimizaci√≥n en C #.  Es decir  si, por ejemplo, necesita abrir un archivo con un modelo 3D y reducir todas las coordenadas 10 veces, entonces * 0.1 manejar√° esto 20-100% m√°s r√°pido, lo que puede ser significativo. </p><br><p>  La misma raz√≥n para: </p><br><pre> <code class="cpp hljs">X * <span class="hljs-number"><span class="hljs-number">2</span></span> =&gt; X + X</code> </pre> <br><p>  Comparar con cero ( <code>test</code> ) es mejor que comparar con la unidad ( <code>cmp</code> ): mi PR para m√°s detalles es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">dotnet / coreclr # 25458</a> : </p><br><pre> <code class="plaintext hljs">X &gt;= 1 =&gt; X &gt; 0 X &lt; 1 =&gt; X &lt;= 0 X &lt;= -1 =&gt; X &gt;= 0 X &gt; -1 =&gt; X &gt;= 0</code> </pre> <br><p>  Y como te gusta esto: </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(X, <span class="hljs-number"><span class="hljs-number">0.5</span></span>) =&gt; <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(x) <span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(X, <span class="hljs-number"><span class="hljs-number">0.25</span></span>) =&gt; <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(X)) <span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(X, <span class="hljs-number"><span class="hljs-number">2</span></span>) =&gt; X * X ; <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-function"><span class="hljs-function">mul </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(X, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">3</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>=&gt; X * X * X ; <span class="hljs-number"><span class="hljs-number">2</span></span> mul</code> </pre> <br><p><img src="https://habrastorage.org/webt/hd/ag/lm/hdaglmbx5f7zfibbpgzdre0swjo.png"></p><br><p>  ¬øQu√© piensas, cu√°ntas operaciones de multiplicaci√≥n necesitas para contar <code>mod(X, 4)</code> o <code>X * X * X * X</code> ? </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/f5d/118/3c0/f5d1183c005a7f72b6fbabdd18995d7e.png" alt="imagen"></p><br><p>  Dos!  Adem√°s de calcular el 3er grado, y en el caso 4 usamos solo un registro <code>xmm0</code> . </p><br><p>  Muchos procesadores admiten una instrucci√≥n especial (FMA), que le permite realizar multiplicaciones y sumas a la vez, manteniendo la precisi√≥n durante la multiplicaci√≥n: </p><br><pre> <code class="cpp hljs">X * Y + Z =&gt; fmadd(X, Y, Z)</code> </pre> <br><p><img src="https://habrastorage.org/webt/jf/z5/nh/jfz5nh9fl6-wkx8cfmubntv7o4g.png"></p><br><p>  Dos de mis ejemplos favoritos m√°s son doblar algunos algoritmos en una sola instrucci√≥n (si el procesador lo admite): <br><img src="https://habrastorage.org/webt/qj/pv/ya/qjpvya5-s-itzzxubosjpnwonkc.png"></p><br><h3 id="lovushki-dlya-optimizaciy">  Trampas de optimizaci√≥n </h3><br><p>  Creo que todos entienden que no puedes apresurarte y reducir las expresiones por tres razones: </p><br><ul><li>  Puede romper el c√≥digo en algunos valores l√≠mite, desbordamiento, efectos secundarios ocultos, etc. ... Bugzilla LLVM contiene muchos errores de InstCombine. </li><li>  Idealmente, las optimizaciones deber√≠an funcionar juntas en una secuencia espec√≠fica. </li><li>  La expresi√≥n o partes de ella que desea reducir se pueden usar en otros lugares y su reducci√≥n conducir√° a la degradaci√≥n del rendimiento. </li></ul><br><p>  Veamos un ejemplo para el √∫ltimo p√°rrafo (espiado en el art√≠culo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Direcciones futuras para la optimizaci√≥n de compiladores</a> ). </p><br><p>  Imagina que tenemos este c√≥digo: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> na = -a; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nb = -b; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> na + nb; }</code> </pre> <br><p>  necesitamos hacer tres operaciones: <code>0 - a</code> , <code>0 - b</code> , y <code>na + nb</code> .  Pero el optimizador para nosotros reduce esto a dos - <code>return -(a + b);</code>  : </p><br><pre> <code class="plaintext hljs">define dso_local i32 @_Z4Foo1ii(i32, i32) { %3 = add i32 %0, %1 ; a + b %4 = sub i32 0, %3 ; 0 - %3 ret i32 %4 }</code> </pre> <br><p>  Ahora imagine que necesitamos escribir valores intermedios <code>na</code> y <code>nb</code> en variables globales: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x, y; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> na = -a; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nb = -b; x = na; y = nb; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> na + nb; }</code> </pre> <br><p>  El optimizador a√∫n encuentra este patr√≥n y elimina las operaciones innecesarias (desde su punto de vista) <code>0 - b</code> , ¬°pero de hecho resulta que son necesarias!  ¬°Escribimos los resultados de estas operaciones "innecesarias" en variables globales!  Esto lleva a este c√≥digo: </p><br><pre> <code class="cpp hljs">define dso_local i32 @_Z4Foo2ii(i32, i32) { %<span class="hljs-number"><span class="hljs-number">3</span></span> = sub nsw i32 <span class="hljs-number"><span class="hljs-number">0</span></span>, %<span class="hljs-number"><span class="hljs-number">0</span></span> ; <span class="hljs-number"><span class="hljs-number">0</span></span> - a %<span class="hljs-number"><span class="hljs-number">4</span></span> = sub nsw i32 <span class="hljs-number"><span class="hljs-number">0</span></span>, %<span class="hljs-number"><span class="hljs-number">1</span></span> ; <span class="hljs-number"><span class="hljs-number">0</span></span> - b store i32 %<span class="hljs-number"><span class="hljs-number">3</span></span>, i32* @x, align <span class="hljs-number"><span class="hljs-number">4</span></span>, !tbaa !<span class="hljs-number"><span class="hljs-number">2</span></span> store i32 %<span class="hljs-number"><span class="hljs-number">4</span></span>, i32* @y, align <span class="hljs-number"><span class="hljs-number">4</span></span>, !tbaa !<span class="hljs-number"><span class="hljs-number">2</span></span> %<span class="hljs-number"><span class="hljs-number">5</span></span> = add i32 %<span class="hljs-number"><span class="hljs-number">0</span></span>, %<span class="hljs-number"><span class="hljs-number">1</span></span> ; a + b %<span class="hljs-number"><span class="hljs-number">6</span></span> = sub i32 <span class="hljs-number"><span class="hljs-number">0</span></span>, %<span class="hljs-number"><span class="hljs-number">5</span></span> ; <span class="hljs-number"><span class="hljs-number">0</span></span> - %<span class="hljs-number"><span class="hljs-number">5</span></span> ret i32 %<span class="hljs-number"><span class="hljs-number">6</span></span> }</code> </pre> <br><p>  ¬°Cuatro operaciones matem√°ticas en lugar de tres!  Nuestro optimizador nos fall√≥ y no estaba convencido de que alguien a√∫n necesitara las expresiones intermedias que optimiz√≥.  Ahora echemos un vistazo a la salida de C # RuyJIT, en el que no existe tal optimizaci√≥n inteligente: </p><br><p><img src="https://habrastorage.org/webt/fs/ar/jf/fsarjfwtbnpmp5hzbidevgo3eui.png"></p><br><p>  Tres operaciones en lugar de cuatro: ¬°C # result√≥ ser m√°s r√°pido que C ++ :-)! </p><br><h3 id="a-nuzhny-li-takie-optimizacii">  ¬øSe necesitan tales optimizaciones? </h3><br><p>  Nunca se sabe c√≥mo se ver√° el c√≥digo despu√©s de que el compilador incorpore todo lo que puede y hace un plegado constante, propagaci√≥n de copia, CSE, etc.  - Se abrir√° una imagen completamente diferente para √©l.  LLVM IR y .NET IL no est√°n vinculados a un lenguaje de programaci√≥n espec√≠fico, y no puede estar seguro de que un PL espec√≠fico / nuevo pueda traducirse efectivamente a IR.  Bueno, ¬øpor qu√© hablar al respecto si puede probar el rendimiento de InstCombine de forma intermitente en una aplicaci√≥n espec√≠fica ;-).  Es poco probable que sea una diferencia impresionante, pero qui√©n sabe. </p><br><h3 id="a-chto-na-schet-c">  ¬øQu√© hay de C #? </h3><br><p>  Como dije, las optimizaciones de las expresiones que examinamos est√°n muy probablemente ausentes en C #.  Pero cuando digo C # quiero decir que el tiempo de ejecuci√≥n m√°s popular es CoreCLR y RyuJIT.  Pero adem√°s de CoreCLR hay otros tiempos de ejecuci√≥n, incluidos los que usan LLVM como backend: Mono (vea mi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tweet</a> ), Unity Burst, IL2CPP (a trav√©s de clang) y LILLC: aqu√≠ puede comparar de manera segura los resultados de C ++ con clang.  Los chicos de Unity incluso reescriben el c√≥digo interno de C ++ en C # sin ninguna p√©rdida de rendimiento, ¬° <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">prueba</a> ! </p><br><p>  Aqu√≠ hay algunos pipholes de optimizaci√≥n que se pueden encontrar en el archivo <code>morph.cpp</code> en el c√≥digo fuente de <code>morph.cpp</code> de los comentarios (claramente hay un poco m√°s): </p><br><pre> <code class="cpp hljs">*(&amp;X) =&gt; X X % <span class="hljs-number"><span class="hljs-number">1</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">0</span></span> X / <span class="hljs-number"><span class="hljs-number">1</span></span> =&gt; X X % Y =&gt; X - (X / Y) * Y X ^ <span class="hljs-number"><span class="hljs-number">-1</span></span> =&gt; ~x X &gt;= <span class="hljs-number"><span class="hljs-number">1</span></span> =&gt; X &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> X &lt; <span class="hljs-number"><span class="hljs-number">1</span></span> =&gt; X &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span> X + <span class="hljs-number"><span class="hljs-number">1</span></span> == C2 =&gt; X == C2 - C1 ((X + C1) + C2) =&gt; (X + (C1 + C2)) ((X + C1) + (Y + C2)) =&gt; ((X + Y) + (C1 + C2))</code> </pre> <br><p>  Se pueden encontrar algunos m√°s en <code>lowering.cpp</code> (bajo nivel), pero en general RyuJIT obviamente pierde aqu√≠ a los compiladores de C ++.  RyuJIT tiene prioridades ligeramente diferentes: antes del advenimiento de la compilaci√≥n de niveles, necesitaba proporcionar una velocidad de compilaci√≥n aceptable, lo que hace muy bien a diferencia de los compiladores de C ++ (recuerde sobre el pase InstCombine de 30 l√≠neas en LLVM y lea la publicaci√≥n interesante en general <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">" "Lamentaciones modernas de C ++"</a> ) y es mucho m√°s √∫til desarrollar optimizaciones en el campo de la desvirtualizaci√≥n de llamadas, la eliminaci√≥n del boxeo y las asignaciones (la misma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Asignaci√≥n de pila de objetos</a> ); obviamente, todo esto es mucho m√°s importante que minimizar las divisiones de seno a coseno por tangente. </p><br><p>  Quiz√°s con el advenimiento de la compilaci√≥n de niveles, con el tiempo habr√° muchas optimizaciones nuevas que no son cr√≠ticas para el tiempo de compilaci√≥n para el nivel 1 o incluso el nivel 2.  Tal vez incluso con su API de complemento y DSL: acaba de leer este art√≠culo, en √©l Prathamesh Kulkarni agreg√≥ optimizaci√≥n de expresi√≥n en GCC en solo un par de l√≠neas DSL: </p><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">simplify</span></span> (<span class="hljs-name"><span class="hljs-name">plus</span></span> (<span class="hljs-name"><span class="hljs-name">mult</span></span> (<span class="hljs-name"><span class="hljs-name">SIN</span></span> @<span class="hljs-number"><span class="hljs-number">0</span></span>) (<span class="hljs-name"><span class="hljs-name">SIN</span></span> @<span class="hljs-number"><span class="hljs-number">0</span></span>)) (<span class="hljs-name"><span class="hljs-name">mult</span></span> (<span class="hljs-name"><span class="hljs-name">COS</span></span> @<span class="hljs-number"><span class="hljs-number">0</span></span>) (<span class="hljs-name"><span class="hljs-name">COS</span></span> @<span class="hljs-number"><span class="hljs-number">0</span></span>))) (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">flag_unsafe_math_optimizations</span></span>)<span class="hljs-number"><span class="hljs-number">1</span></span>. { build_one_cst (<span class="hljs-name"><span class="hljs-name">TREE_TYPE</span></span> (@<span class="hljs-number"><span class="hljs-number">0</span></span>))<span class="hljs-comment"><span class="hljs-comment">; }))</span></span></code> </pre> <br><p>  para esta expresi√≥n de un libro de texto de matem√°ticas ;-): </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">cos</span></span>^<span class="hljs-number"><span class="hljs-number">2</span></span>(X) + <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>^<span class="hljs-number"><span class="hljs-number">2</span></span>(X) equals to <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br><h3 id="poleznye-ssylki">  Enlaces utiles </h3><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Direcciones futuras para la optimizaci√≥n de compiladores"</a> , Nuno P. Lopes y John Regehr </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"C√≥mo LLVM optimiza una funci√≥n"</a> , John Regehr </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"La sorprendente inteligencia de los compiladores modernos"</a> , Daniel Lemire </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Agregar optimizaci√≥n de mirilla a GCC"</a> , Prathamesh Kulkarni </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"1. C ++, C # y Unity"</a> , Lucas Meijer </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Lamentaciones" modernas de C ++ "</a> , Aras Pranckeviƒçius </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Optimizaciones de mirilla probadamente correctas con vida"</a> , Nuno P. Lopes, David Men√©ndez, Santosh Nagarakatte y John Regehr </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/458150/">https://habr.com/ru/post/458150/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../458130/index.html">‚ÄúThe Magic Word‚Äù para empleadores: experiencia de IIBS NITU ‚ÄúMISiS‚Äù</a></li>
<li><a href="../458136/index.html">Nuevo GitLab 12.0 con revisiones visuales y una lista de dependencias.</a></li>
<li><a href="../458142/index.html">Desarrollando Breakout en Svelte</a></li>
<li><a href="../458144/index.html">Noticias de la semana: Raspberry Pi 4 a la venta, Internet en el Examen de Estado Unificado, Roskomnadzor y servicios VPN, una red neuronal despoja a las personas</a></li>
<li><a href="../458146/index.html">Aplicaci√≥n de contabilidad de comunicaci√≥n de c√≥digo abierto en la regi√≥n.</a></li>
<li><a href="../458156/index.html">Evaluaci√≥n comparativa de PostgreSQL en FreeBSD, CentOS, Ubuntu Debian y openSUSE</a></li>
<li><a href="../458158/index.html">Buscando asteroides - proyecto Hubble Asteroid Hunter</a></li>
<li><a href="../458164/index.html">Inteligencia artificial: se formular√° una pregunta para cada respuesta</a></li>
<li><a href="../458170/index.html">Inmersi√≥n en redes neuronales convolucionales. Parte 5/10 - 18</a></li>
<li><a href="../458172/index.html">M√©todos para emparejar conexiones el√©ctricas al rastrear pares diferenciales en placas de circuito impreso</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>