<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèº‚Äçüåæ ‚ö°Ô∏è üàÅ Qu'est-ce que le pseudonyme strict et pourquoi devrions-nous nous en pr√©occuper? 2e partie ‚úçüèª üòÅ üî§</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="(OU dactylographie, comportement vague et alignement, oh mon Dieu!) 

 Amis, il reste tr√®s peu de temps avant le lancement d'un nouveau fil de discuss...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Qu'est-ce que le pseudonyme strict et pourquoi devrions-nous nous en pr√©occuper? 2e partie</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/443602/">  <b><i>(OU dactylographie, comportement vague et alignement, oh mon Dieu!)</i></b> <br><br>  Amis, il reste tr√®s peu de temps avant le lancement d'un nouveau fil de discussion sur le cours <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">"D√©veloppeur C ++"</a> .  Il est temps de publier une traduction de la deuxi√®me partie du mat√©riel, qui raconte ce qu'un jeu de mots tape. <br><br>  <b>Qu'est-ce qu'une typification de jeu de mots?</b> <br><br>  Nous avons atteint le point o√π nous pouvons nous demander pourquoi nous pourrions avoir besoin de pseudonymes?  Habituellement pour la mise en ≈ìuvre de la saisie de calembours, car  les m√©thodes fr√©quemment utilis√©es violent les r√®gles strictes d'alias. <br><br><img src="https://habrastorage.org/webt/dz/u-/cd/dzu-cdwp2tjct7bc-stnxfnptpe.png"><br><br>  Parfois, nous voulons contourner le syst√®me de types et interpr√©ter l'objet comme un autre type.  La r√©interpr√©tation d'un segment de m√©moire comme un autre type est appel√©e un <i>jeu de mots de</i> type <i>punning</i> .  Les jeux de mots sont utiles pour les t√¢ches qui n√©cessitent l'acc√®s √† la repr√©sentation de base d'un objet pour afficher, transporter ou manipuler les donn√©es fournies.  Domaines typiques o√π nous pouvons rencontrer l'utilisation de jeux de mots: compilateurs, s√©rialisation, code r√©seau, etc. <a name="habracut"></a><br>  Traditionnellement, cela a √©t√© r√©alis√© en prenant l'adresse de l'objet, en le moulant vers un pointeur sur le type auquel nous voulons interpr√©ter, puis en acc√©dant √† la valeur, ou en d'autres termes, en utilisant des alias.  Par exemple: <br><br><pre><code class="bash hljs">int x = 1 ; //   C <span class="hljs-built_in"><span class="hljs-built_in">float</span></span> *fp = (<span class="hljs-built_in"><span class="hljs-built_in">float</span></span>*)&amp;x ; //   //  C++ <span class="hljs-built_in"><span class="hljs-built_in">float</span></span> *fp = reinterpret_cast&lt;<span class="hljs-built_in"><span class="hljs-built_in">float</span></span>*&gt;(&amp;x) ; //   <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>( ‚Äú%f\n‚Äù, *fp ) ;</code> </pre> <br>  Comme nous l'avons vu pr√©c√©demment, il s'agit d'un alias inacceptable, cela entra√Ænera un comportement ind√©fini.  Mais traditionnellement, les compilateurs n'utilisaient pas de r√®gles d'aliasing strictes, et ce type de code fonctionnait g√©n√©ralement juste, et les d√©veloppeurs, malheureusement, sont habitu√©s √† autoriser de telles choses.  Une m√©thode alternative courante de frappe est d'utiliser l'union, qui est valide en C, mais provoquera un comportement ind√©fini en C ++ ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">voir l'exemple</a> ): <br><br><pre> <code class="bash hljs">union u1 { int n; <span class="hljs-built_in"><span class="hljs-built_in">float</span></span> f; } ; union u1 u; uf = 1.0f; <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>( <span class="hljs-string"><span class="hljs-string">"%d\n‚Äù, un ); // UB(undefined behaviour)  C++ ‚Äún is not the active member‚Äù</span></span></code> </pre> <br>  Ceci est inacceptable en C ++, et certains pensent que les unions sont uniquement destin√©es √† impl√©menter des types de variantes, et consid√®rent que l'utilisation des unions pour taper des jeux de mots est un abus. <br><br>  <b>Comment mettre en ≈ìuvre un jeu de mots?</b> <br><br>  La m√©thode b√©nie standard pour taper des jeux de mots en C et C ++ est memcpy.  Cela peut sembler un peu compliqu√©, mais l'optimiseur doit reconna√Ætre l'utilisation de memcpy pour le jeu de mots, l'optimiser et g√©n√©rer un registre pour enregistrer le mouvement.  Par exemple, si nous savons que int64_t a la m√™me taille que double: <br><br><pre> <code class="bash hljs">static_assert( sizeof( double ) == sizeof( int64_t ) ); // C++17   </code> </pre> <br>  Nous pouvons utiliser <code>memcpy</code> : <br><br><pre> <code class="bash hljs">void func1( double d ) { std::int64_t n; std::memcpy(&amp;n, &amp;d, sizeof d); //‚Ä¶</code> </pre><br>  Avec un niveau d'optimisation suffisant, tout compilateur moderne d√©cent g√©n√®re du code identique √† la m√©thode reinterpret_cast ou √† la m√©thode join pr√©c√©demment mentionn√©e pour obtenir un jeu de mots.  En √©tudiant le code g√©n√©r√©, nous voyons qu'il utilise uniquement le registre mov ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">exemple</a> ). <br><br>  <b>Types et tableaux de calembours</b> <br><br>  Mais que se passe-t-il si nous voulons impl√©menter le jeu de mots d'un tableau de caract√®res non sign√© dans une s√©rie d'int entier non sign√©, puis effectuer une op√©ration sur chaque valeur int non sign√©e?  Nous pouvons utiliser memcpy pour transformer un tableau de caract√®res non sign√© en un type int temporaire non sign√©.  L'optimiseur sera toujours en mesure de tout voir via memcpy et d'optimiser √† la fois l'objet temporaire et la copie, et de travailler directement avec les donn√©es sous-jacentes ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">exemple</a> ): <br><br><pre> <code class="bash hljs">//  ,    int foo( unsigned int x ) { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> x ; } // ,  len  sizeof(unsigned int) int bar( unsigned char *p, size_t len ) { int result = 0; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( size_t index = 0; index &lt; len; index += sizeof(unsigned int) ) { unsigned int ui = 0; std::memcpy( &amp;ui, &amp;p[index], sizeof(unsigned int) ); result += foo( ui ) ; } <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> result; }</code> </pre><br>  Dans cet exemple, nous prenons <code>char*p</code> , supposons qu'il pointe vers plusieurs fragments de taille de donn√©es <code>sizeof(unsigned int)</code> , interpr√©tons chaque fragment de donn√©es comme <code>unsigned int</code> , calculons <code>foo()</code> pour chaque fragment du jeu de mots, r√©sumons le r√©sultat et retournons la valeur finale . <br><br>  L'assemblage du corps de boucle montre que l'optimiseur transforme le corps en acc√®s direct au tableau de base de caract√®res <code>unsigned int</code> tant <code>unsigned int</code> , en l'ajoutant directement √† <code>eax</code> : <br><br><pre> <code class="bash hljs">add eax, dword ptr [rdi + rcx]</code> </pre> <br>  Le m√™me code, mais en utilisant <code>reinterpret_cast</code> pour impl√©menter un jeu de mots (viole l'aliasing strict): <br><br><pre> <code class="bash hljs">// ,  len  sizeof(unsigned int) int bar( unsigned char *p, size_t len ) { int result = 0; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( size_t index = 0; index &lt; len; index += sizeof(unsigned int) ) { unsigned int ui = *reinterpret_cast&lt;unsigned int*&gt;(&amp;p[index]); result += foo( ui ); } <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> result; }</code> </pre> <br>  <b>C ++ 20 et bit_cast</b> <br><br>  En C ++ 20, nous avons <code>bit_cast</code> , qui fournit un moyen facile et s√ªr d'interpr√©ter, et peut √©galement √™tre utilis√© dans le contexte de <code>constexpr</code> . <br><br>  Voici un exemple d'utilisation de <code>bit_cast</code> pour interpr√©ter un entier non sign√© dans un <code>float</code> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">exemple</a> ): <br><br><pre> <code class="bash hljs">std::cout &lt;&lt; bit_cast&lt;<span class="hljs-built_in"><span class="hljs-built_in">float</span></span>&gt;(0x447a0000) &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n"</span></span> ; //,  sizeof(<span class="hljs-built_in"><span class="hljs-built_in">float</span></span>) == sizeof(unsigned int)</code> </pre> <br>  Dans le cas o√π les types To et From n'ont pas la m√™me taille, cela nous oblige √† utiliser une structure interm√©diaire.  Nous utiliserons une structure contenant un tableau de caract√®res multiple de <code>sizeof(unsigned int)</code> (un <code>sizeof(unsigned int)</code> 4 octets est suppos√©) comme type From, et <code>unsigned int</code> comme To. Type: <br><br><pre> <code class="bash hljs">struct uint_chars { unsigned char arr[sizeof( unsigned int )] = {} ; //  sizeof( unsigned int ) == 4 }; //  len  4 int bar( unsigned char *p, size_t len ) { int result = 0; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( size_t index = 0; index &lt; len; index += sizeof(unsigned int) ) { uint_chars f; std::memcpy( f.arr, &amp;p[index], sizeof(unsigned int)); unsigned int result = bit_cast&lt;unsigned int&gt;(f); result += foo( result ); } <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> result ; }</code> </pre> <br>  Malheureusement, nous avons besoin de ce type interm√©diaire - c'est la limitation actuelle de <code>bit_cast</code> . <br><br>  <b>Alignement</b> <br><br>  Dans les exemples pr√©c√©dents, nous avons vu que la violation de r√®gles strictes d'alias peut entra√Æner l'exclusion du stockage lors de l'optimisation.  La violation d'un alias strict peut √©galement entra√Æner une violation des exigences d'alignement.  Les normes C et C ++ indiquent que les objets sont soumis √† des exigences d'alignement qui limitent l'endroit o√π les objets peuvent √™tre plac√©s (en m√©moire) et donc accessibles.  <i>C11 section 6.2.8 Alignement des objets indique</i> : <br><br>  Les types complets d'objets ont des exigences d'alignement qui imposent des restrictions sur les adresses auxquelles les objets de ce type peuvent √™tre plac√©s.  L'alignement est une valeur enti√®re d√©finie par l'impl√©mentation qui repr√©sente le nombre d'octets entre des adresses cons√©cutives auxquelles cet objet peut √™tre plac√©.  Le type de l'objet impose une exigence d'alignement √† chaque objet de ce type: un alignement plus strict peut √™tre demand√© √† l'aide du <code>_Alignas</code> . <br><br>  <b>La norme de projet C ++ 17 dans la section 1 [basic.align]</b> : <br><br>  Les types d'objets ont des exigences d'alignement (6.7.1, 6.7.2) qui imposent des restrictions sur les adresses auxquelles un objet de ce type peut √™tre plac√©.  L'alignement est une valeur enti√®re d√©finie par l'impl√©mentation qui repr√©sente le nombre d'octets entre des adresses cons√©cutives auxquelles un objet donn√© peut √™tre plac√©.  Un type d'objet impose une exigence d'alignement √† chaque objet de ce type;  Un alignement plus strict peut √™tre demand√© √† l'aide du sp√©cificateur d'alignement (10.6.2). <br><br>  C99 et C11 indiquent explicitement qu'une conversion qui aboutit √† un pointeur non align√© est un comportement ind√©fini, section 6.3.2.3.  <i>Pointeurs</i> dit: <br><blockquote>  Un pointeur vers un objet ou un type partiel peut √™tre converti en pointeur vers un autre objet ou type partiel.  Si le pointeur r√©sultant n'est pas correctement align√© pour le type de pointeur, le comportement n'est pas d√©fini.  ... <br></blockquote>  Bien que C ++ ne soit pas si √©vident, je pense que cette phrase du paragraphe 1 <code>[basic.align]</code> suffisante: <br><blockquote>  ... Le type d'objet impose une exigence d'alignement √† chaque objet de ce type;  ... </blockquote>  <i><b>Exemple</b></i> <br><br>  Supposons donc: <br><br><ul><li>  alignof (char) et alignof (int) sont respectivement 1 et 4 </li><li>  sizeof (int) est 4 </li></ul><br>  Ainsi, interpr√©ter un tableau de caract√®res de taille 4 comme <code>int</code> viole l'alias strict et peut √©galement violer les exigences d'alignement si le tableau a un alignement de 1 ou 2 octets. <br><br><pre> <code class="bash hljs">char arr[4] = { 0x0F, 0x0, 0x0, 0x00 }; //        1  2  int x = *reinterpret_cast&lt;int*&gt;(arr); // Undefined behavior  </code> </pre> <br>  Ce qui peut entra√Æner une baisse des performances ou une erreur de bus dans certaines situations.  Alors que l'utilisation d'alignas pour forcer le m√™me alignement pour un tableau dans int emp√™chera les exigences d'alignement de se casser: <br><br><pre> <code class="bash hljs">alignas(alignof(int)) char arr[4] = { 0x0F, 0x0, 0x0, 0x00 }; int x = *reinterpret_cast&lt;int*&gt;(arr);</code> </pre> <br>  <i><b>Atomicit√©</b></i> <br><br>  Une autre punition inattendue pour un acc√®s d√©s√©quilibr√© est qu'elle viole l'atomicit√© de certaines architectures.  Les magasins atomiques peuvent ne pas appara√Ætre atomiques pour les autres threads de x86 s'ils ne sont pas align√©s. <br><br>  <b>D√©tection des violations strictes d'alias</b> <br><br>  Nous n'avons pas beaucoup de bons outils pour suivre l'aliasing strict en C ++.  Les outils dont nous disposons permettront de d√©tecter certains cas de violations et certains cas de chargement et de stockage incorrects. <br><br>  gcc utilisant les <code>-fstrict-aliasing</code> et <code>-Wstrict-aliasing</code> peut <code>-Wstrict-aliasing</code> certains cas, mais pas sans faux positifs / probl√®mes.  Par exemple, les cas suivants g√©n√©reront un avertissement dans gcc ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">exemple</a> ): <br><br><pre> <code class="bash hljs">int a = 1; short j; <span class="hljs-built_in"><span class="hljs-built_in">float</span></span> f = 1.f; //   ,   TIS ,         <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%i\n"</span></span>, j = *(reinterpret_cast&lt;short*&gt;(&amp;a))); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%i\n"</span></span>, j = *(reinterpret_cast&lt;int*&gt;(&amp;f)));</code> </pre> <br>  bien qu'il n'attrape pas ce cas suppl√©mentaire ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">exemple</a> ): <br><br><pre> <code class="bash hljs">int *p; p=&amp;a; <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%i\n"</span></span>, j = *(reinterpret_cast&lt;short*&gt;(p)));</code> </pre><br>  Bien que <code>clang</code> r√©solve ces indicateurs, il ne semble pas r√©ellement impl√©menter l'avertissement. <br><br>  Un autre outil que nous avons est ASan, qui peut capturer un enregistrement et un stockage mal align√©s.  Bien qu'il ne s'agisse pas de violations directes d'un alias strict, il s'agit d'un r√©sultat assez courant.  Par exemple, les cas suivants g√©n√©reront des erreurs d'ex√©cution lors de l'assemblage √† l'aide de clang √† l'aide de <code>-fsanitize=address</code> <br><br><pre> <code class="bash hljs">int *x = new int[2]; // 8 : [0,7]. int *u = (int*)((char*)x + 6); //     x    *u = 1; //    [6-9] <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>( <span class="hljs-string"><span class="hljs-string">"%d\n"</span></span>, *u ); //    [6-9]</code> </pre> <br>  Le dernier outil que je recommande est sp√©cifique √† C ++ et, en fait, non seulement un outil, mais aussi une pratique de codage qui ne permet pas la <code>-Wold-style-cast</code> C. <code>gcc</code> et <code>clang</code> effectueront des diagnostics pour les <code>-Wold-style-cast</code> C √† l'aide de <code>-Wold-style-cast</code> .  Cela forcera tous les calembours de frappe non d√©finis √† utiliser reinterpret_cast.  En g√©n√©ral, <code>reinterpret_cast</code> devrait √™tre une balise pour une analyse plus approfondie du code. <br>  Il est √©galement plus facile de rechercher dans la base de code reinterpret_cast pour effectuer un audit. <br><br>  Pour C, nous avons tous les outils qui sont d√©j√† d√©crits, et nous avons √©galement <code>tis-interpreter</code> , un analyseur statique qui analyse de mani√®re exhaustive le programme pour un grand sous-ensemble de C. √âtant donn√© les versions C de l'exemple pr√©c√©dent, o√π l'utilisation de -fstrict-aliasing saute un cas ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">exemple</a> ) <br><br><pre> <code class="bash hljs">int a = 1; short j; <span class="hljs-built_in"><span class="hljs-built_in">float</span></span> f = 1.0 ; <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%i\n"</span></span>, j = *((short*)&amp;a)); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%i\n"</span></span>, j = *((int*)&amp;f)); int *p; p=&amp;a; <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%i\n"</span></span>, j = *((short*)p));</code> </pre><br>  L'interpr√©teur TIS peut intercepter les trois, l'exemple suivant appelle le noyau TIS en tant qu'interpr√©teur TIS (la sortie est modifi√©e par souci de concision): <br><br><pre> <code class="bash hljs">./bin/tis-kernel -sa example1.c ... example1.c:9:[sa] warning: The pointer (short *)(&amp; a) has <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> short *. It violates strict aliasing rules by accessing a cell with effective <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> int. ... example1.c:10:[sa] warning: The pointer (int *)(&amp; f) has <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> int *. It violates strict aliasing rules by accessing a cell with effective <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> <span class="hljs-built_in"><span class="hljs-built_in">float</span></span>. Callstack: main ... example1.c:15:[sa] warning: The pointer (short *)p has <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> short *. It violates strict aliasing rules by accessing a cell with effective <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> int.</code> </pre> <br>  Et enfin, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">TySan</a> , qui est en cours de d√©veloppement.  Cet assainisseur ajoute des informations de v√©rification de type au segment de m√©moire fant√¥me et v√©rifie les acc√®s pour d√©terminer s'ils violent les r√®gles d'alias.  L'outil devrait potentiellement √™tre en mesure de suivre toutes les violations d'alias, mais peut avoir une surcharge importante au moment de l'ex√©cution. <br><br>  <b>Conclusion</b> <br><br>  Nous avons appris les r√®gles d'alias en C et C ++, ce qui signifie que le compilateur attend de nous que nous suivions strictement ces r√®gles et acceptions les cons√©quences de ne pas les respecter.  Nous avons d√©couvert certains outils qui peuvent nous aider √† identifier certains abus de pseudonymes.  Nous avons vu que l'utilisation habituelle de l'aliasing est un jeu de mots de typification.  Nous avons √©galement appris √† l'impl√©menter correctement. <br><br>  Les optimiseurs am√©liorent progressivement l'analyse des alias bas√©s sur le type et cassent d√©j√† du code bas√© sur des violations strictes d'alias.  Nous pouvons nous attendre √† ce que les optimisations s'am√©liorent et cassent encore plus de code qui fonctionnait auparavant. <br><br>  Nous avons des m√©thodes compatibles pr√™tes √† l'emploi standard pour interpr√©ter les types.  Parfois, pour les versions de d√©bogage, ces m√©thodes doivent √™tre des abstractions libres.  Nous avons plusieurs outils pour d√©tecter les violations d'aliasing s√©v√®res, mais pour C ++ ils n'attraperont qu'une petite partie des cas, et pour C en utilisant le tis-interpreter, nous pouvons suivre la plupart des violations. <br><br>  Merci √† ceux qui ont comment√© cet article: JF Bastien, Christopher Di Bella, Pascal Quoc, Matt P. Dziubinski, Patrice Roy et Olafur Vaage <br>  Bien s√ªr, au final, toutes les erreurs appartiennent √† l'auteur. <br><br>  La traduction d'un document assez volumineux est donc termin√©e, dont la premi√®re partie peut √™tre lue <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> .  Et nous vous invitons traditionnellement √† <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la journ√©e portes ouvertes</a> , qui aura lieu le 14 mars par le chef du d√©partement de d√©veloppement technologique chez Rambler &amp; Co - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Dmitry Shebordaev.</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><br></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr443602/">https://habr.com/ru/post/fr443602/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr443590/index.html">Data Science: pr√©dire les √©v√©nements m√©tier pour am√©liorer le service</a></li>
<li><a href="../fr443592/index.html">Norme frontale RFID ISO 11785 provenant d'un ancien r√©cepteur FM et de d√©bris d'ascenseur</a></li>
<li><a href="../fr443594/index.html">Le carrefour des tests et de l'architecture: une entrevue avec Neil Ford</a></li>
<li><a href="../fr443598/index.html">Il y a une r√©vocation massive de certificats TLS d'une vari√©t√© d'autorit√©s de certification, g√©n√©r√©es par erreur sur un RNG 63 bits au lieu d'un 64 bits</a></li>
<li><a href="../fr443600/index.html">Les meilleures et les pires tendances du MWC 2019</a></li>
<li><a href="../fr443604/index.html">MOBILE FIRST: Hackathon √† OZON</a></li>
<li><a href="../fr443606/index.html">Jenkins pour Android build utilisant docker</a></li>
<li><a href="../fr443608/index.html">Smart Home / Mises √† jour chez Lazurite</a></li>
<li><a href="../fr443612/index.html">Nous utilisons de vieux mauvais disques durs</a></li>
<li><a href="../fr443614/index.html">YouTrack 2019.1: s√©lectionnez des cartes Agile, des champs de cartes personnalisables sur les cartes Agile, etc.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>