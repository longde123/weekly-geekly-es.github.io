<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏝️ 🐜 🙏🏿 Generando tipos de personajes sobre la marcha (o locos con Rust) 🙎🏼 💼 🕗</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En este artículo, nos burlaremos del lenguaje de programación Rust y, en particular, de los objetos de rasgos. 


 Cuando me familiaricé con Rust, uno...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Generando tipos de personajes sobre la marcha (o locos con Rust)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/432202/"><p>  En este artículo, nos burlaremos del lenguaje de programación Rust y, en particular, de los objetos de rasgos. </p><br><p> Cuando me familiaricé con Rust, uno de los detalles de la implementación de objetos tipo me pareció interesante.  Es decir, la tabla de funciones virtuales no se encuentra en los datos en sí, sino en el puntero "grueso".  Cada puntero a un objeto de tipo) contiene un puntero a los datos en sí, así como un enlace a una tabla virtual donde se ubicarán las direcciones de las funciones que implementan este objeto de tipo para una estructura dada (pero como se trata de un detalle de implementación, el comportamiento puede cambiar. </p><a name="habracut"></a><br><p>  Comencemos con un ejemplo simple que demuestra punteros gruesos.  El siguiente código saldrá en la arquitectura de 64 bits 8 y 16: </p><br><pre><code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-function"> </span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> v: &amp;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span> = &amp;<span class="hljs-string"><span class="hljs-string">"hello"</span></span>.into(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> disp: &amp;std::fmt::Display = v; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"  : {}"</span></span>, std::mem::size_of_val(&amp;v)); <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"   -: {}"</span></span>, std::mem::size_of_val(&amp;disp)); }</code> </pre> <br><p>  ¿Por qué es esto interesante?  Cuando estaba involucrado en Java empresarial, una de las tareas que surgía con bastante regularidad era la adaptación de los objetos existentes a las interfaces dadas.  Es decir, el objeto ya existe, emitido como un enlace, pero debe adaptarse a la interfaz especificada.  Y no puede cambiar el objeto de entrada, es lo que es. </p><br><p>  Tenía que hacer algo como esto: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">Person </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">adapt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Json value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ...- , , ,  "value"  //   Person return new PersonJsonAdapter(value); }</span></span></code> </pre> <br><p>  Hubo varios problemas con este enfoque.  Por ejemplo, si el mismo objeto se "adapta" dos veces, obtenemos dos <code>Person</code> diferentes (desde el punto de vista de la comparación de enlaces).  Y el hecho mismo de que tienes que crear nuevos objetos cada vez es de alguna manera feo. </p><br><p>  ¡Cuando vi objetos tipográficos en Rust, tuve la idea de que en Rust se podía hacer de manera mucho más elegante!  ¡También puede tomar y asignar otra tabla virtual a los datos y obtener un nuevo objeto de rasgo!  Y no asigne memoria para cada instancia.  Al mismo tiempo, toda la lógica de "pedir prestado" permanece en su lugar: nuestra función de adaptación se verá como algo así como <code>fn adapt&lt;'a&gt;(value: &amp;'a Json) -&gt; &amp;'a Person</code> (es decir, tomamos prestado de fuente de datos). </p><br><p>  Incluso más que eso, puede "forzar" el mismo tipo (por ejemplo, <code>String</code> ) para implementar nuestro objeto de tipo varias veces, con un comportamiento diferente.  Por qué  ¿Pero nunca sabes lo que se puede necesitar en la empresa? </p><br><p>  Intentemos implementar esto. </p><br><h2 id="postanovka-zadachi">  Declaración del problema. </h2><br><p>  Establecemos la tarea de esta manera: hacemos que la función de <code>annotate</code> , que "asigna" el siguiente objeto de tipo al tipo de <code>String</code> normal: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Object</span></span></span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">type_name</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">as_string</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; &amp;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>; }</code> </pre> <br><p>  Y la función de <code>annotate</code> sí misma: </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">///    - `Object`,   , ///   "" -- ,    `type_name`. fn annotate&lt;'a&gt;(input: &amp;'a String, type_name: &amp;str) -&gt; &amp;'a dyn Object { // ... }</span></span></code> </pre> <br><p>  Escribamos una prueba de inmediato.  Primero, asegúrese de que el tipo "asignado" coincida con el tipo esperado.  En segundo lugar, nos aseguraremos de que podamos obtener la línea original y será la misma línea (desde el punto de vista de los punteros): </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[test]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> input: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> = <span class="hljs-string"><span class="hljs-string">"hello"</span></span>.into(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> annotated1 = annotate(&amp;input, <span class="hljs-string"><span class="hljs-string">"Widget"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> annotated2 = annotate(&amp;input, <span class="hljs-string"><span class="hljs-string">"Gadget"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// -   ,    assert_eq!("Widget", annotated1.type_name()); assert_eq!("Gadget", annotated2.type_name()); let unwrapped1 = annotated1.as_string(); let unwrapped2 = annotated2.as_string(); //       --   assert_eq!(unwrapped1 as *const String, &amp;input as *const String); assert_eq!(unwrapped2 as *const String, &amp;input as *const String); }</span></span></code> </pre> <br><h2 id="podhod-1-a-posle-nas-hot-potop">  Enfoque número 1: ¡y después de nosotros al menos una inundación! </h2><br><p>  Primero, intentemos hacer una implementación completamente ingenua.  Simplemente envuelva nuestros datos en un "contenedor", que además contendrá <code>type_name</code> : </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Wrapper</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt; { value: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, type_name: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt; Object <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Wrapper&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">type_name</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span> { &amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.type_name } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">as_string</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; &amp;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.value } }</code> </pre> <br><p>  Nada especial todavía.  Todo es como en Java.  Pero no tenemos un recolector de basura, ¿dónde almacenaremos este envoltorio?  Necesitamos devolver el enlace, para que siga siendo válido después de llamar a la función de <code>annotate</code> .  Pondremos algo aterrador en el <code>Box</code> para que el <code>Wrapper</code> resaltado en el montón.  Y luego le devolveremos el enlace.  Y para que el contenedor permanezca vivo después de llamar a la función de <code>annotate</code> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"filtraremos"</a> este cuadro: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">annotate</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;(input: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, type_name: &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) -&gt; &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> dyn Object { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> b = <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::new(Wrapper { value: input, type_name: type_name.into(), }); <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::leak(b) }</code> </pre> <br><p>  ... y la prueba pasa! </p><br><p>  Pero esta es una decisión dudosa.  No solo seguimos asignando memoria con cada "anotación", sino que la memoria se pierde ( <code>Box::leak</code> devuelve un enlace a los datos almacenados en el montón, sino que al mismo tiempo "olvida" la caja en sí, es decir, no habrá liberación automática ) </p><br><h2 id="podhod-2-arena">  Enfoque 2: Arena! </h2><br><p>  Para comenzar, intentemos guardar estos envoltorios en algún lugar para que, sin embargo, se liberen en algún momento.  Pero al mismo tiempo conserva la firma de <code>annotate</code> tal como está.  Es decir, devolver un enlace con recuento de referencias (por ejemplo, <code>Rc&lt;Wrapper&gt;</code> ) no funciona. </p><br><p>  La opción más simple es crear una estructura auxiliar, un "sistema de tipos", que se encargará de almacenar estos contenedores.  Y cuando terminemos, lanzaremos esta estructura y todos los envoltorios con ella. </p><br><p>  Algo asi.  La biblioteca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>typed-arena</code></a> se usa para almacenar envoltorios, pero podría funcionar con el tipo <code>Vec&lt;Box&lt;Wrapper&gt;&gt;</code> , lo principal es garantizar que <code>Wrapper</code> no se mueva a ninguna parte (en la noche Rust puede usar el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">pin API</a> para esto): </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TypeSystem</span></span></span></span> { wrappers: typed_arena::Arena&lt;Wrapper&gt;, } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> TypeSystem { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span></span>() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span> { wrappers: typed_arena::Arena::new(), } } <span class="hljs-comment"><span class="hljs-comment">///     `input`,      , ///    (  ,    , ///        )! pub fn annotate&lt;'a: 'b, 'b&gt;( &amp;'a self, input: &amp;'b String, type_name: &amp;str ) -&gt; &amp;'b dyn Object { self.wrappers.alloc(Wrapper { value: input, type_name: type_name.into(), }) } }</span></span></code> </pre> <br><p>  Pero, ¿a dónde se fue el parámetro responsable de la vida útil del enlace para el tipo <code>Wrapper</code> ?  Tuvimos que deshacernos de él, ya que no podemos atribuir una vida útil fija en el tipo <code>typed_arena::Arena&lt;Wrapper&lt;'?&gt;&gt;</code> .  ¡Cada contenedor tiene un parámetro único, dependiendo de la <code>input</code> ! </p><br><p>  En cambio, rociamos un poco de óxido inseguro para deshacernos del parámetro de por vida: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Wrapper</span></span></span></span> { value: *<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, type_name: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Object <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Wrapper { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">type_name</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span> { &amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.type_name } <span class="hljs-comment"><span class="hljs-comment">///   -- ,     (  /// `annotate`),     (    - /// `&amp;Object`)  ,      (`String`). fn as_string(&amp;self) -&gt; &amp;String { unsafe { &amp;*self.value } } }</span></span></code> </pre> <br><p>  Y las pruebas pasan nuevamente, lo que nos da confianza en la exactitud de la decisión.  Además de sentirse incómodo con <code>unsafe</code> (como debería ser, ¡es mejor no bromear con óxido inseguro!). </p><br><p>  Pero aún así, ¿qué pasa con la opción prometida, que no requiere asignaciones de memoria adicionales para envoltorios? </p><br><h2 id="podhod-3-da-razverznutsya-vrata-ada">  Enfoque n. ° 3: dejar que se abran las puertas del infierno </h2><br><p>  Idea.  Para cada "tipo" único ("Widget", "Gadget"), crearemos una tabla virtual.  Manos durante la ejecución del programa.  Y lo asignamos al enlace que nos proporcionan los datos en sí (que, como recordamos, es simplemente <code>String</code> ). </p><br><p>  Primero, una breve descripción de lo que necesitamos obtener.  Entonces, una referencia a un objeto tipo, ¿cómo está organizado?  De hecho, estos son solo dos punteros, uno para los datos en sí y otro para la tabla virtual.  Entonces escribimos: </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[repr(C)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TraitObject</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> data: *<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> (), <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> vtable: *<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> (), }</code> </pre> <br><p>  ( <code>#[repr(C)]</code> necesitamos garantizar la ubicación correcta en la memoria). </p><br><p>  ¡Parece que todo es simple, generaremos una nueva tabla para los parámetros dados y "recopilaremos" un enlace al objeto tipo!  Pero, ¿en qué consiste esta tabla? </p><br><p>  La respuesta correcta a esta pregunta sería "este es un detalle de implementación".  Pero lo haremos;  cree un archivo de <code>rust-toolchain</code> en la raíz de nuestro proyecto y escríbalo allí: <code>nightly-2018-12-01</code> .  Después de todo, un conjunto fijo puede considerarse estable, ¿verdad? </p><br><p>  Ahora que hemos arreglado la versión Rust (de hecho, necesitaremos el ensamblaje nocturno para una de las bibliotecas a continuación). </p><br><p>  Después de una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">búsqueda en Internet</a> , descubrimos que el formato de la tabla es simple: primero hay un enlace al destructor, luego dos campos asociados con la asignación de memoria (tamaño de letra y alineación), y luego las funciones van una tras otra (el orden queda a discreción del compilador, pero tenemos solo dos funciones, por lo que la probabilidad de adivinar es bastante alta, 50%). </p><br><p>  Entonces escribimos: </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[repr(C)]</span></span> <span class="hljs-meta"><span class="hljs-meta">#[derive(Clone, Copy)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VirtualTableHeader</span></span></span></span> { destructor_fn: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span></span>(*<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> ()), size: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, align: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, } <span class="hljs-meta"><span class="hljs-meta">#[repr(C)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ObjectVirtualTable</span></span></span></span> { header: VirtualTableHeader, type_name_fn: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span></span>(*<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>) -&gt; *<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">str</span></span>, as_string_fn: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span></span>(*<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>) -&gt; *<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, }</code> </pre> <br><p>  De forma similar, <code>#[repr(C)]</code> necesita <code>#[repr(C)]</code> para garantizar la ubicación correcta en la memoria.  Me dividí en dos estructuras, un poco más tarde nos será útil. </p><br><p>  Ahora intentemos escribir nuestro sistema de tipos, que proporcionará la función de <code>annotate</code> .  Tendremos que almacenar en caché las tablas generadas, así que obtengamos el caché: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TypeInfo</span></span></span></span> { vtable: ObjectVirtualTable, } <span class="hljs-meta"><span class="hljs-meta">#[derive(Default)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TypeSystem</span></span></span></span> { infos: RefCell&lt;HashMap&lt;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, TypeInfo&gt;&gt;, }</code> </pre> <br><p>  Utilizamos el estado interno de <code>RefCell</code> para que nuestra función <code>TypeSystem::annotate</code> pueda recibir <code>&amp;self</code> como un enlace compartido.  Esto es importante, ya que "tomamos prestado" de <code>TypeSystem</code> para asegurarnos de que las tablas virtuales que generamos vivan más tiempo que la referencia al objeto de tipo que devolvemos de la <code>annotate</code> . </p><br><p>  Dado que queremos poder anotar muchas instancias, no podemos tomar prestado <code>&amp;mut self</code> como un enlace mutable. </p><br><p>  Y bosquejaremos este código: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> TypeSystem { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">annotate</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>: <span class="hljs-symbol"><span class="hljs-symbol">'b</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">'b</span></span>&gt;( &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, input: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'b</span></span> <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, type_name: &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span> ) -&gt; &amp;<span class="hljs-symbol"><span class="hljs-symbol">'b</span></span> dyn Object { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> type_name = type_name.to_string(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> infos = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.infos.borrow_mut(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> imp = infos.entry(type_name).or_insert_with(|| <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { <span class="hljs-comment"><span class="hljs-comment">//    ,  ? let vtable = unimplemented!(); TypeInfo { vtable } }); let object_obj = TraitObject { data: input as *const String as *const (), vtable: &amp;imp.vtable as *const ObjectVirtualTable as *const (), }; //       - unsafe { std::mem::transmute::&lt;TraitObject, &amp;dyn Object&gt;(object_obj) } } }</span></span></code> </pre> <br><p>  ¿De dónde sacamos esta mesa?  Las primeras tres entradas coincidirán con las entradas de cualquier otra tabla virtual para el tipo especificado.  Por lo tanto, solo tómalos y cópialos.  Primero, obtengamos este tipo: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Whatever</span></span></span></span> {} <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;T&gt; Whatever <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> T {}</code> </pre> <br><p>  Es útil para nosotros obtener esta "cualquier otra tabla virtual".  Y luego, copiamos estas tres entradas de él: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> whatever = input <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> &amp;dyn Whatever; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> whatever_obj = std::mem::transmute::&lt;&amp;dyn Whatever, TraitObject&gt;(whatever); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> whatever_vtable_header = whatever_obj.vtable <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> VirtualTableHeader; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> vtable = ObjectVirtualTable { <span class="hljs-comment"><span class="hljs-comment">//  ! header: *whatever_vtable_header, type_name_fn: unimplemented!(), as_string_fn: unimplemented!(), }; TypeInfo { vtable }</span></span></code> </pre> <br><p>  En principio, podríamos obtener el tamaño y la alineación a través de <code>std::mem::size_of::&lt;String&gt;()</code> y <code>std::mem::align_of::&lt;String&gt;()</code> .  Pero de dónde más puede ser "robado" el destructor, no lo sé. </p><br><p>  Ok, pero ¿de dónde obtenemos las direcciones de estas funciones, <code>type_name_fn</code> y <code>as_string_fn</code> ?  Puede notar que <code>as_string_fn</code> generalmente no es necesario, el puntero de datos siempre va como el primer registro en la representación del objeto tipo.  Es decir, esta función es siempre la misma: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Object <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ... fn as_string(&amp;self) -&gt; String { self } }</span></span></code> </pre> <br><p>  ¡Pero con la segunda función no es tan fácil!  También depende de nuestro nombre "tipo", <code>type_name</code> . </p><br><p>  No importa, solo podemos generar esta función en tiempo de ejecución.  Tomemos la biblioteca de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>dynasm</code></a> para esto (en este momento, requiere la construcción nocturna Rust).  Leer sobre <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">llamadas a funciones convenciones</a> . </p><br><p>  Para simplificar, supongamos que solo estamos interesados ​​en Mac OS y Linux (después de todas estas transformaciones divertidas, la compatibilidad ya no nos molesta, ¿verdad?).  Y, sí, exclusivamente x86-64, por supuesto. </p><br><p>  La segunda función, <code>as_string</code> , es fácil de implementar.  Se nos promete que el primer parámetro estará en el registro <code>RDI</code> .  Y devuelva el valor a <code>RAX</code> .  Es decir, el código de función será algo como: </p><br><pre> <code class="rust hljs">dynasm!(ops ; mov rax, rdi ; ret );</code> </pre> <br><p>  Pero la primera función es un poco más complicada.  Primero, necesitamos regresar <code>&amp;str</code> , que es un puntero grueso.  Su primera parte es un puntero a una cadena, y la segunda parte es la longitud del corte de cadena.  Afortunadamente, la convención anterior le permite devolver resultados de 128 bits utilizando el registro <code>EDX</code> para la segunda parte. </p><br><p>  Queda por llegar a algún lugar un enlace a un segmento de cadena que contiene nuestra cadena <code>type_name</code> .  No queremos confiar en <code>type_name</code> (aunque a través de anotaciones de la vida útil podemos garantizar que <code>type_name</code> vivirá más tiempo que el valor devuelto). </p><br><p>  Pero tenemos una copia de esta línea, que ponemos en la tabla hash.  Cruzando los dedos, <code>String::as_str</code> que la ubicación del segmento de cadena que <code>String::as_str</code> no <code>String::as_str</code> no cambia al mover la <code>String</code> (y la <code>String</code> moverá en el proceso de cambiar el tamaño del <code>HashMap</code> donde la cadena almacena esta cadena).  No sé si la biblioteca estándar garantiza este comportamiento, pero ¿lo estamos jugando fácilmente? </p><br><p>  Obtenemos los componentes necesarios: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> type_name_ptr = type_name.as_str().as_ptr(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> type_name_len = type_name.as_str().len();</code> </pre> <br><p>  Y escribe esta función: </p><br><pre> <code class="rust hljs">dynasm!(ops ; mov rax, QWORD type_name_ptr <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">i64</span></span> ; mov rdx, QWORD type_name_len <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">i64</span></span> ; ret );</code> </pre> <br><p>  Y finalmente, el código de <code>annotate</code> final: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">annotate</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>: <span class="hljs-symbol"><span class="hljs-symbol">'b</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">'b</span></span>&gt;(&amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, input: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'b</span></span> <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, type_name: &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) -&gt; &amp;<span class="hljs-symbol"><span class="hljs-symbol">'b</span></span> Object { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> type_name = type_name.to_string(); <span class="hljs-comment"><span class="hljs-comment">//       let type_name_ptr = type_name.as_str().as_ptr(); let type_name_len = type_name.as_str().len(); let mut infos = self.infos.borrow_mut(); let imp = infos.entry(type_name).or_insert_with(|| unsafe { let mut ops = dynasmrt::x64::Assembler::new().unwrap(); //     `type_name` let type_name_offset = ops.offset(); dynasm!(ops ; mov rax, QWORD type_name_ptr as i64 ; mov rdx, QWORD type_name_len as i64 ; ret ); //     `as_string` let as_string_offset = ops.offset(); dynasm!(ops ; mov rax, rdi ; ret ); let buffer = ops.finalize().unwrap(); //      let whatever = input as &amp;dyn Whatever; let whatever_obj = std::mem::transmute::&lt;&amp;dyn Whatever, TraitObject&gt;(whatever); let whatever_vtable_header = whatever_obj.vtable as *const VirtualTableHeader; let vtable = ObjectVirtualTable { header: *whatever_vtable_header, type_name_fn: std::mem::transmute(buffer.ptr(type_name_offset)), as_string_fn: std::mem::transmute(buffer.ptr(as_string_offset)), }; TypeInfo { vtable, buffer } }); assert_eq!(imp.vtable.header.size, std::mem::size_of::&lt;String&gt;()); assert_eq!(imp.vtable.header.align, std::mem::align_of::&lt;String&gt;()); let object_obj = TraitObject { data: input as *const String as *const (), vtable: &amp;imp.vtable as *const ObjectVirtualTable as *const (), }; unsafe { std::mem::transmute::&lt;TraitObject, &amp;dyn Object&gt;(object_obj) } }</span></span></code> </pre> <br><p>  Para fines de <code>dynasm</code> también necesitamos agregar el campo de <code>buffer</code> a nuestra estructura <code>TypeInfo</code> .  Este campo controla la memoria que almacena el código de nuestras funciones generadas: </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[allow(unused)]</span></span> buffer: dynasmrt::ExecutableBuffer,</code> </pre> <br><p>  ¡Y todas las pruebas pasan! </p><br><h2 id="gotovo-master">  Hecho, maestro! </h2><br><p>  ¡Tan fácil y naturalmente puede generar su propia implementación de objetos tipo en código Rust! </p><br><p>  La última solución se basa activamente en los detalles de implementación y, por lo tanto, no se recomienda su uso.  Pero en realidad, tienes que hacer lo que tienes que hacer.  ¡Los tiempos desesperados requieren medidas desesperadas! </p><br><p>  Sin embargo, hay una (más) característica en la que confío aquí.  A saber, que es seguro liberar la memoria ocupada virtualmente por la tabla después de que no haya referencias al objeto de tipo que la usa.  Por un lado, es lógico que pueda usar una tabla virtual solo a través de referencias de objetos de tipo.  Por otro lado, las tablas proporcionadas por Rust tienen una vida útil <code>'static</code> .  Es completamente posible asumir algún código que separe la tabla del enlace para algunos de sus propósitos ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">nunca se</a> sabe, por ejemplo, para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">algunos de sus trucos sucios</a> ). </p><br><p>  El código fuente se puede <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">encontrar aquí</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es432202/">https://habr.com/ru/post/es432202/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es432190/index.html">Predicción física del lado del cliente en Unity</a></li>
<li><a href="../es432192/index.html">4 señales de que no está listo para implementar una solución de gestión de proyectos</a></li>
<li><a href="../es432196/index.html">Acerca de la composición de funciones en JavaScript</a></li>
<li><a href="../es432198/index.html">Delivery Manager: un nuevo papel en el mundo ágil</a></li>
<li><a href="../es432200/index.html">Cómo Ivan investigó la conversión de stands</a></li>
<li><a href="../es432204/index.html">Seminario "20 pequeñas cosas que harán que el trabajo en el centro de datos sea realmente cómodo", 13 de diciembre, Moscú</a></li>
<li><a href="../es432206/index.html">Un análisis detallado de lo que Google mostró en la conferencia FlutterLive (y lo que significa para Dart y el mundo)</a></li>
<li><a href="../es432208/index.html">Kubernetes 1.13: Resumen de las innovaciones clave</a></li>
<li><a href="../es432210/index.html">Qualcomm presentó la plataforma Snapdragon 855 con soporte 5G</a></li>
<li><a href="../es432212/index.html">7 años de proyectos educativos Mail.Ru Group: compartir experiencias en las principales áreas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>