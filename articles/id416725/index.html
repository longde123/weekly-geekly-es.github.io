<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙋 📛 🤦 Kotlin DSL: Teori dan Praktek 👱 👨‍💼 🧙🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mengembangkan tes aplikasi bukan pengalaman yang menyenangkan. Proses ini membutuhkan waktu lama, membutuhkan banyak konsentrasi dan sangat diminati. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kotlin DSL: Teori dan Praktek</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/416725/">  Mengembangkan tes aplikasi bukan pengalaman yang menyenangkan.  Proses ini membutuhkan waktu lama, membutuhkan banyak konsentrasi dan sangat diminati.  Bahasa Kotlin menyediakan seperangkat alat yang membuatnya cukup mudah untuk membangun bahasa berorientasi masalah Anda sendiri (DSL).  Ada pengalaman ketika Kotlin DSL mengganti pembangun dan metode statis untuk menguji modul perencanaan sumber daya, yang membuat menambahkan tes baru dan mendukung yang lama dari rutinitas merupakan proses yang menyenangkan. <br><br>  Dalam perjalanan artikel, kami akan menganalisis semua alat utama dari gudang pengembang dan bagaimana mereka dapat digabungkan untuk menyelesaikan masalah pengujian.  Kami akan berusaha keras mulai dari merancang Tes Ideal hingga meluncurkan tes yang paling mendekati, bersih, dan mudah dipahami untuk sistem perencanaan sumber daya berbasis Kotlin. <br><br>  Artikel ini akan berguna untuk melatih para insinyur, mereka yang menganggap Kotlin sebagai bahasa untuk menulis tes ringkas dengan nyaman, dan mereka yang ingin meningkatkan proses pengujian dalam proyek mereka. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/q_UM1EY2S5g" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  Artikel ini didasarkan pada presentasi oleh Ivan Osipov ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">i_osipov</a> ) di konferensi JPoint.  Narasi lebih lanjut dilakukan atas namanya.  Ivan bekerja sebagai programmer di Haulmont.  Produk utama perusahaan adalah CUBA, sebuah platform untuk mengembangkan perusahaan dan berbagai aplikasi web.  Secara khusus, proyek-proyek outsourcing sedang dibuat pada platform ini, di antaranya ada baru-baru ini sebuah proyek di bidang pendidikan, di mana Ivan terlibat dalam membangun jadwal untuk sebuah lembaga pendidikan.  Kebetulan selama tiga tahun terakhir Ivan telah bekerja sama dengan para perencana, dan khususnya di Haulmont mereka telah menguji perencana ini selama setahun. <br><a name="habracut"></a><br>  Bagi mereka yang ingin menjalankan contoh - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">simpan tautan ke GitHub</a> .  Di bawah tautan Anda akan menemukan semua kode yang akan kami uraikan, jalankan, dan tulis hari ini.  Buka kodenya dan pergi! <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ec3/fa3/670/ec3fa3670fd1c8a3cf7222f7e746933c.jpg"><br><br>  Hari ini kita akan membahas: <br><br><ul><li>  apa bahasa yang berorientasi masalah; <br></li><li>  built-in bahasa berorientasi masalah; <br></li><li>  membangun jadwal untuk lembaga pendidikan; <br></li><li>  bagaimana semuanya diuji dengan Kotlin. <br></li></ul><br>  Hari ini saya akan berbicara secara rinci tentang alat-alat yang kami miliki dalam bahasa tersebut, menunjukkan kepada Anda beberapa demo, dan kami akan menulis seluruh tes dari awal hingga akhir.  Pada saat yang sama, saya ingin menjadi lebih objektif, jadi saya akan berbicara tentang beberapa kelemahan yang saya identifikasi untuk diri saya sendiri selama pengembangan. <br><br>  Mari kita mulai dengan berbicara tentang modul pembuatan jadwal.  Jadi, pembangunan jadwal berlangsung dalam beberapa tahap.  Setiap langkah ini perlu diuji secara terpisah.  Anda perlu memahami bahwa meskipun langkah-langkahnya berbeda, kami memiliki model data umum. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/031/be4/27d/031be427d58c5073a3bc619cbed65792.jpg"><br><br>  Proses ini dapat direpresentasikan sebagai berikut: pada input ada beberapa data dengan model umum, pada output ada jadwal.  Data divalidasi, disaring, kemudian dibangun kelompok pelatihan.  Ini mengacu pada bidang subjek dari jadwal untuk lembaga pendidikan.  Berdasarkan kelompok yang dibangun dan berdasarkan beberapa data lain, kami menempatkan pelajaran.  Hari ini kita hanya akan berbicara tentang tahap terakhir - tentang penempatan kelas. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f64/032/4b1/f640324b1a2ff556a4da892822847a9c.jpg"><br><br>  Sedikit tentang menguji penjadwal. <br><br>  Pertama, seperti yang sudah Anda pahami, tahapan yang berbeda harus diuji secara terpisah.  Seseorang dapat memilih proses pengujian pengujian yang kurang lebih standar: ada inisialisasi data, ada peluncuran scheduler, ada cek dari hasil scheduler itu sendiri.  Ada sejumlah besar kasus bisnis yang berbeda yang perlu dicakup dan berbagai situasi yang perlu dipertimbangkan sehingga ketika membuat jadwal, situasi ini juga tetap ada. <br><br>  Model kadang-kadang bisa berbobot, dan untuk membuat satu entitas, perlu menginisialisasi lima entitas tambahan, atau bahkan lebih.  Jadi, secara total, sejumlah besar kode diperoleh, yang kami tulis berulang-ulang untuk setiap tes.  Dukungan untuk tes semacam itu membutuhkan banyak waktu.  Jika Anda ingin memperbarui model, dan ini kadang terjadi, maka skala perubahan memengaruhi tes. <br><br>  Mari kita menulis tes: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fda/0f5/94d/fda0f594d14b8043054bcae7fe3315ad.jpg"><br><br>  Mari kita menulis tes paling sederhana sehingga Anda secara umum memahami gambarnya. <br>  Apa yang pertama kali terlintas dalam pikiran ketika Anda berpikir tentang pengujian?  Mungkin ini adalah beberapa tes primitif semacam ini: Anda membuat kelas, membuat metode di dalamnya, menandainya dengan <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">Tes</a></i> anotasi.  Akibatnya, kami menggunakan kemampuan JUnit, dan menginisialisasi beberapa data, nilai default, lalu nilai tes khusus, melakukan hal yang sama untuk sisa model, dan akhirnya membuat objek scheduler, mentransfer data kami ke sana, kami mulai, kami menerima hasil dan kami memeriksanya.  Kurang lebih proses standar.  Tapi jelas ada duplikasi kode di dalamnya.  Hal pertama yang terlintas dalam pikiran adalah kemampuan untuk memasukkan semuanya ke dalam metode statis.  Karena ada banyak nilai default, mengapa tidak menyembunyikannya? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/521/543/590/521543590a00c6101abd4fcefd345e04.jpg"><br><br>  Ini adalah langkah pertama yang baik untuk mengurangi duplikasi. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c7f/c57/11c/c7fc5711ccf2a4e9dfb626ea64cffb9b.jpg"><br><br>  Melihat ini, Anda mengerti bahwa saya ingin menjaga model lebih kompak.  Di sini kita memiliki pola pembangun di mana, di suatu tempat di bawah kap, nilai default diinisialisasi, dan nilai-nilai khusus tes diinisialisasi di sana.  Semakin baik, namun, kami masih menulis kode boilerplate, dan kami menulisnya lagi setiap waktu.  Bayangkan 200 tes - Anda harus menulis tiga baris ini 200 kali.  Jelas, saya ingin menyingkirkan ini entah bagaimana.  Mengembangkan ide, kami mencapai batas tertentu.  Jadi, misalnya, kita dapat membuat pembuat pola secara umum untuk semuanya. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/259/e9b/7a3/259e9b7a39e84a41466572b38afc280d.jpg"><br><br>  Anda dapat membuat penjadwal dari awal hingga akhir, mengatur semua nilai yang kita butuhkan, memulai penjadwalan dan semuanya hebat.  Jika Anda melihat detail pada contoh ini dan menganalisisnya secara terperinci, ternyata banyak kode yang tidak perlu sedang ditulis.  Saya ingin membuat tes lebih mudah dibaca sehingga Anda dapat melihatnya dan segera mengerti, tanpa mempelajari pola dan sebagainya. <br><br>  Jadi, kami memiliki beberapa kode yang tidak perlu.  Matematika sederhana menunjukkan bahwa ada 55% lebih banyak surat daripada yang kita butuhkan, dan saya ingin entah bagaimana menjauh darinya. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d55/610/ef7/d55610ef71d368b8d16c1fdef35cd2c5.jpg"><br><br>  Setelah beberapa waktu, dukungan untuk pengujian kami ternyata lebih mahal, karena Anda perlu mendukung lebih banyak kode.  Kadang-kadang, jika kita tidak melakukan upaya apa pun, keterbacaan meninggalkan banyak hal yang diinginkan, atau ternyata dapat diterima, tetapi kami ingin lebih baik.  Mungkin nanti kita akan mulai menambahkan semacam kerangka kerja, perpustakaan, untuk membuat tes lebih mudah untuk ditulis.  Karena ini, kami meningkatkan tingkat masuk ke pengujian aplikasi kami.  Di sini kami memiliki aplikasi yang sudah rumit, tingkat masuk ke dalam pengujiannya sangat signifikan, dan kami semakin meningkatkannya. <br><br><h2>  Tes sempurna </h2><br>  Sangat menyenangkan untuk mengatakan betapa buruknya semuanya, tetapi mari kita pikirkan bagaimana itu akan sangat baik.  Contoh ideal yang ingin kami dapatkan sebagai hasilnya: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e2b/7c5/f48/e2b7c5f48dbd065e95b1617ad10622ba.jpg"><br><br>  Bayangkan bahwa ada beberapa deklarasi di mana kita mengatakan bahwa ini adalah tes dengan nama tertentu, dan kami ingin menggunakan spasi untuk memisahkan kata-kata dalam nama, bukan CamelCase.  Kami sedang membuat jadwal, kami memiliki beberapa data, dan hasil perencana diperiksa.  Karena kami bekerja terutama dengan Java, dan semua kode aplikasi utama ditulis dalam bahasa ini, saya ingin memiliki kemampuan pengujian yang kompatibel.  Saya ingin menginisialisasi data sejelas mungkin kepada pembaca.  Saya ingin menginisialisasi beberapa data umum dan bagian dari model yang kita butuhkan.  Misalnya, buat siswa, guru, dan jelaskan kapan tersedia.  Ini adalah contoh sempurna kami. <br><br><h2>  Bahasa khusus domain </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/f81/c79/0a9/f81c790a921e43d645fc7380607cf8ea.jpg"><br><br>  Melihat semuanya, itu mulai tampak seperti semacam bahasa yang berorientasi masalah.  Anda perlu memahami apa itu dan apa bedanya.  Bahasa dapat dibagi menjadi dua jenis: bahasa tujuan umum (apa yang kami tulis terus-menerus, menyelesaikan semua tugas dan mengatasi semuanya) dan bahasa yang berorientasi masalah.  Jadi, misalnya, SQL membantu kita untuk menarik data dari database dengan sempurna, dan beberapa bahasa lain juga membantu menyelesaikan masalah spesifik lainnya. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2f8/e45/2f6/2f8e452f62f39f0f56a2c73e355dddcb.jpg"><br><br>  Salah satu cara untuk mengimplementasikan bahasa berorientasi masalah adalah bahasa yang disematkan, atau internal.  Bahasa-bahasa tersebut diimplementasikan berdasarkan bahasa tujuan umum.  Yaitu, beberapa konstruksi bahasa tujuan umum kami membentuk sesuatu seperti basis - itulah yang kami gunakan ketika bekerja dengan bahasa yang berorientasi masalah.  Dalam hal ini, tentu saja, peluang muncul dalam bahasa yang berorientasi masalah untuk menggunakan semua fitur dan fitur yang berasal dari bahasa tujuan umum. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/07f/4cb/57f/07f4cb57f84ba884bd558ee8e97202a2.jpg"><br><br>  Sekali lagi, lihat contoh sempurna kami dan pikirkan bahasa mana yang harus dipilih.  Kami memiliki tiga opsi. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d1d/b21/4b3/d1db214b39b5620875350b382622e662.jpg"><br><br>  Opsi pertama adalah Groovy.  Bahasa yang indah dan dinamis yang telah membuktikan dirinya dalam membangun bahasa yang berorientasi masalah.  Sekali lagi, Anda dapat memberikan contoh file build di Gradle, yang banyak dari kita gunakan.  Ada juga Scala, yang memiliki sejumlah besar peluang untuk implementasi sesuatu mereka sendiri.  Dan akhirnya, ada Kotlin, yang juga membantu kami membangun bahasa yang berorientasi masalah, dan hari ini akan dibahas.  Saya tidak ingin mengembangbiakkan perang dan membandingkan Kotlin dengan sesuatu yang lain, tetapi tetap pada hati nurani Anda.  Hari ini saya akan menunjukkan kepada Anda apa yang dimiliki Kotlin untuk mengembangkan bahasa yang berorientasi masalah.  Ketika Anda ingin membandingkan ini dan mengatakan bahwa beberapa bahasa lebih baik, Anda dapat kembali ke artikel ini dan dengan mudah melihat perbedaannya. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/050/2e7/29e/0502e729ebf030ea5e4d9f038a4b7cc6.jpg"><br><br>  Apa yang Kotlin berikan kepada kita untuk mengembangkan bahasa yang berorientasi masalah? <br><br>  Pertama, ini adalah pengetikan statis, dan semua yang terjadi kemudian.  Pada tahap kompilasi, sejumlah besar masalah terdeteksi, dan ini sangat menghemat, terutama dalam kasus ketika Anda tidak ingin mendapatkan masalah yang terkait dengan sintaks dan penulisan dalam tes. <br>  Lalu, ada sistem inferensi tipe besar yang berasal dari Kotlin.  Ini luar biasa, karena tidak perlu menulis jenis apa pun lagi dan lagi, semuanya ditampilkan oleh kompiler dengan keras. <br><br>  Ketiga, ada dukungan yang sangat baik untuk lingkungan pengembangan, dan ini tidak mengejutkan, karena perusahaan yang sama membuat lingkungan pengembangan utama untuk hari ini, dan itu memang Kotlin. <br>  Akhirnya di dalam DSL, jelas kita bisa menggunakan Kotlin.  Menurut pendapat subjektif saya, mendukung DSL jauh lebih mudah daripada mendukung kelas utilitas.  Seperti yang akan Anda lihat nanti, keterbacaan sedikit lebih baik daripada pembangun.  Yang saya maksud dengan "lebih baik": Anda mendapatkan sedikit sintaksis yang perlu Anda tulis - seseorang yang membaca bahasa Anda yang berorientasi masalah akan lebih cepat melakukannya.  Akhirnya, menulis sepeda Anda jauh lebih menyenangkan!  Tetapi pada kenyataannya, menerapkan bahasa yang berorientasi masalah jauh lebih mudah daripada mempelajari beberapa kerangka kerja baru. <br><br>  Saya akan mengingatkan sekali lagi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tautan ke GitHub</a> , jika Anda ingin menulis demo lebih lanjut, maka Anda dapat masuk dan mengambil kode dari tautan tersebut. <br><br><h2>  Merancang yang ideal di Kotlin </h2><br>  Mari kita lanjutkan merancang cita-cita kita, tetapi sudah ada di Kotlin.  Lihatlah contoh kami: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5e3/695/850/5e3695850435a204b9cbb3b94f6f7635.png"><br><br>  Dan secara bertahap kita akan mulai membangunnya kembali. <br><br>  Kami memiliki tes yang berubah menjadi fungsi di Kotlin, yang dapat dinamai menggunakan spasi. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/03d/699/a71/03d699a71ecf86e0e5c03b7a6de57995.png"><br><br>  Kami akan menandainya dengan anotasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">Tes</a> , yang tersedia bagi kami dari JUnit.  Di Kotlin, Anda bisa menggunakan formulir singkat untuk fungsi penulisan dan, melalui <i>=,</i> singkirkan kurung kurawal ekstra untuk fungsi itu sendiri. <br><br>  Jadwal kami berubah menjadi blok.  Hal yang sama terjadi dengan banyak desain, karena kami masih bekerja di Kotlin. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a7b/db9/656/a7bdb965641ca434f1eba5e7781b9b53.png"><br><br>  Mari kita beralih ke yang lain.  Kurung kurawal muncul lagi, kami tidak akan menyingkirkannya, tetapi setidaknya mencoba untuk lebih dekat dengan contoh kita.  Dengan membuat konstruksi dengan spasi, kami dapat memperbaiki diri dan membuatnya berbeda, tetapi bagi saya tampaknya lebih baik membuat metode biasa yang akan merangkum pemrosesan, tetapi secara umum hal ini akan jelas bagi pengguna . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/378/6e6/eaf/3786e6eafdb8ebd14c344af30698df56.png"><br><br>  Siswa kami berubah menjadi blok tempat kami bekerja dengan properti, dengan metode, dan kami akan terus menganalisis ini dengan Anda. <br><br><img width="600" src="https://habrastorage.org/getpro/habr/post_images/76b/a76/554/76ba76554585689a4c2562167fd26833.png"><br><br>  Akhirnya, para guru.  Di sini kita memiliki beberapa blok bersarang. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/deb/a5d/f0a/deba5df0a67a08566e07370bf2f70bc0.png"><br><br>  Dalam kode di bawah ini, kami beralih ke cek.  Kami perlu memeriksa kompatibilitas dengan bahasa Java - dan ya, Kotlin kompatibel dengan Java. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8aa/09d/a05/8aa09da05c7c48282e01b0ea409e0f3c.png"><br><br><h2>  Arsenal pengembangan DSL di Kotlin </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/5f6/113/6ef/5f61136ef41733e6fb88c5ff17d6975f.jpg"><br><br>  Mari kita beralih ke daftar alat yang kita miliki.  Di sini saya membawa tablet, mungkin daftar semua yang diperlukan untuk mengembangkan bahasa yang berorientasi masalah di Kotlin.  Anda dapat kembali kepadanya dari waktu ke waktu dan menyegarkan ingatannya. <br><br>  Tabel menunjukkan beberapa perbandingan sintaksis berorientasi masalah dan sintaksis biasa yang tersedia dalam bahasa. <br><br><h2>  Lambdas di Kotlin </h2><br> <code>val lambda: () -&gt; Unit = { }</code> <br> <br>  Mari kita mulai dengan batu bata paling dasar yang kita miliki di Kotlin - ini adalah lambdas. <br>  Hari ini, berdasarkan tipe lambda, maksud saya hanya tipe fungsional.  Lambdas dilambangkan sebagai berikut: <code>( ) -&gt;  </code> . <br><br>  Kami menginisialisasi lambda dengan bantuan kurung kurawal, di dalamnya kita dapat menulis beberapa kode yang akan dipanggil.  Yaitu, lambda, sebenarnya, menyembunyikan kode ini sendiri.  Menjalankan lambda seperti itu tampak seperti pemanggilan fungsi, hanya tanda kurung. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a48/f4d/d49/a48f4dd497c8aa6b93ab2043e014ca02.jpg"><br><br>  Jika kita ingin melewatkan beberapa jenis parameter, pertama, kita harus menggambarkannya dalam tipe. <br>  Kedua, kita memiliki akses ke pengenal default itu, yang dapat kita gunakan, namun, jika ini tidak cocok untuk kita, kita dapat mengatur nama parameter kita sendiri dan menggunakannya. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/194/fab/626/194fab62612fb71e6a5f148193ec1ff9.jpg"><br><br>  Pada saat yang sama, kita dapat melewati penggunaan parameter ini dan menggunakan garis bawah agar tidak menghasilkan pengidentifikasi.  Dalam hal ini, untuk mengabaikan pengenal, akan mungkin untuk menulis apa-apa, tetapi dalam kasus umum untuk beberapa parameter ada "_" yang disebutkan. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1ff/80e/de2/1ff80ede232393839186b9345065700c.jpg"><br><br>  Jika kita ingin melewatkan lebih dari satu parameter, kita perlu mendefinisikan pengidentifikasi mereka secara eksplisit. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c8d/d2b/952/c8dd2b952caa82b67157f41dc79535b0.jpg"><br><br>  Akhirnya, apa yang akan terjadi jika kita mencoba mengoper lambda ke beberapa fungsi dan menjalankannya di sana.  Itu terlihat dalam perkiraan awal sebagai berikut: kita memiliki fungsi yang kita lewati lambda dalam kurung keriting, dan jika di Kotlin lambda ditulis sebagai parameter terakhir, kita dapat mengurutkannya dari kurung ini. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b80/d7c/0d8/b80d7c0d814f3c51a91f2c224707a2d5.jpg"><br><br>  Jika tidak ada yang tersisa di tanda kurung, kita dapat menghapus tanda kurung.  Mereka yang akrab dengan Groovy harus terbiasa dengan ini. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/74b/5dd/a95/74b5dda953b1df973a8d893f7a615195.jpg"><br><br>  Di mana ini berlaku?  Di mana-mana.  Artinya, kawat gigi yang sangat keriting yang telah kita bicarakan, kita gunakan, ini adalah sangat lambda. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/69e/4bd/781/69e4bd781897ef0515384f81367899cc.jpg"><br><br>  Sekarang mari kita lihat salah satu varietas lambda, saya menyebutnya lambda dengan konteks.  Anda akan menemukan beberapa nama lain, misalnya, lambda dengan penerima, dan mereka berbeda dari lambda biasa ketika mendeklarasikan tipe sebagai berikut: di sebelah kiri, kami menambahkan beberapa kelas konteks, itu bisa berupa kelas apa saja. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8bd/375/5b1/8bd3755b1085f3049a7ea32c7cc41f79.jpg"><br><br>  Untuk apa ini?  Ini diperlukan agar di dalam lambda kita memiliki akses ke kata kunci ini - ini adalah kata kunci itu sendiri, itu memberi tahu kita konteks kita, yaitu, ke beberapa objek yang kita tautkan ke lambda kita.  Jadi, misalnya, kita dapat membuat lambda yang akan menampilkan beberapa string, secara alami, kita akan menggunakan kelas string untuk mendeklarasikan konteks dan panggilan lambda akan terlihat seperti ini: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d80/552/181/d80552181518f155fc596c1bb3ddf2aa.jpg"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/788/63d/b17/78863db1732d9b92bff62bf82060771a.jpg"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/770/a1b/038/770a1b0388cd2380c491cdf5ca8c344c.jpg"><br><br>  Jika Anda ingin melewatkan konteks sebagai parameter, Anda bisa melakukannya juga.  Namun, kita tidak dapat sepenuhnya menyampaikan konteksnya, yaitu, lambda dengan konteks membutuhkan perhatian!  - konteks, ya.  Apa yang terjadi jika kita mulai memberikan lambda dengan konteks ke beberapa metode?  Di sini kita melihat lagi pada metode exec kami: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/15b/f36/3d9/15bf363d94919f7c73d775c5d28c6c53.jpg"><br><br>  Ganti nama menjadi metode siswa - tidak ada yang berubah: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e12/4cc/e3b/e124cce3bd7bdb776c3e946edf8ec52c.jpg"><br><br>  Jadi kami secara bertahap pindah ke konstruksi kami, konstruksi siswa, yang di bawah kawat gigi menyembunyikan semua inisialisasi. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/eba/286/8b3/eba2868b306f476c35df51d8af500335.jpg"><br><br>  Mari kita cari tahu.  Kami memiliki semacam fungsi siswa yang mengambil lambda dengan konteks Siswa. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d3f/954/e2a/d3f954e2a7016ecf31a081559674d01f.jpg"><br><br>  Jelas, kita butuh konteks. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/362/4d8/3be/3624d83be81ee01223ad758e9e81c94d.jpg"><br><br>  Di sini kita membuat objek dan menjalankan lambda ini di atasnya. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cab/d4a/940/cabd4a940deacfcdcb680c4916b29eae.jpg"><br><br>  Sebagai hasilnya, kami juga dapat menginisialisasi beberapa nilai default sebelum meluncurkan lambda, jadi kami merangkum semua yang kami butuhkan untuk fungsi tersebut. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0b4/572/421/0b457242103fc70de806c9de62234135.jpg"><br><br>  Karena ini, di dalam lambda, kami mendapatkan akses ke kata kunci ini - itu sebabnya, mungkin, ada lambda dengan konteks. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b1b/819/fdb/b1b819fdb7488092550b2ac72265cd72.jpg"><br><br>  Secara alami, kami dapat menyingkirkan kata kunci ini dan kami mendapat kesempatan untuk menulis konstruksi semacam itu. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/50d/dbc/492/50ddbc4920ffb871918ce7c063a874a2.jpg"><br><br>  Sekali lagi, jika kita tidak hanya memiliki hak milik, tetapi juga beberapa metode, kita juga dapat memanggil mereka, itu terlihat sangat alami. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b72/155/316/b72155316d99a7e4816d1234644b761b.jpg"><br><br><h2>  Aplikasi </h2><br>  Semua lambda dalam kode ini adalah lambda konteks.  Ada sejumlah besar konteks, mereka berpotongan dalam satu dan lain cara dan memungkinkan kita untuk membangun bahasa berorientasi masalah kita. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/83a/f30/2ff/83af302ff3c0a85db220c70f0d567743.jpg"><br><br>  Meringkas lambda - kita memiliki lambda biasa, ada dengan konteksnya, dan itu dan yang lain dapat digunakan. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fcc/1ac/dfc/fcc1acdfc43284500c38884d88212877.jpg"><br><br><h2>  Operator </h2><br>  Kotlin memiliki seperangkat operator terbatas yang dapat Anda ganti menggunakan konvensi dan kata kunci operator. <br><br>  Mari kita lihat guru dan aksesibilitasnya.  Misalkan kita mengatakan bahwa guru bekerja pada hari Senin dari jam 8 pagi selama 1 jam.  Kami juga ingin mengatakan bahwa, selain satu jam ini, ia bekerja mulai pukul 13.00 selama 1 jam.  Saya ingin menyatakan ini menggunakan operator <b>+</b> .  Bagaimana ini bisa dilakukan? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/17b/360/9ab/17b3609ab2ebd28cf27f906934536e05.jpg"><br><br>  Ada beberapa metode ketersediaan yang menerima lambda dengan konteks <code>AvailabilityTable</code> .  Ini berarti bahwa ada beberapa kelas yang disebut itu, dan metode Senin dideklarasikan di kelas ini.  Metode ini mengembalikan <code>DayPointer</code> sejak  Anda perlu melampirkan operator kami ke sesuatu. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/721/aea/73d/721aea73d36a41cf3dbecd328b1f5ab5.jpg"><br><br>  Mari kita cari tahu apa itu DayPointer.  Ini adalah penunjuk ke tabel ketersediaan beberapa guru, dan harinya sesuai dengan jadwalnya.  Kami juga memiliki fungsi waktu yang entah bagaimana akan mengubah beberapa baris menjadi indeks integer: di Kotlin kami memiliki kelas <code>IntRange</code> untuk ini. <br><br>  Di sebelah kiri adalah <code>DayPointer</code> , di sebelah kanan adalah waktu, dan kami ingin menggabungkannya dengan operator <b>+</b> .  Untuk melakukan ini, Anda bisa membuat operator kami di kelas <code>DayPointer</code> .  Ini akan mengambil serangkaian nilai tipe Int dan mengembalikan <code>DayPointer</code> sehingga kami dapat <code>DayPointer</code> DSL kami berulang kali. <br>  Sekarang, mari kita lihat desain kunci yang dengannya semuanya dimulai, yang dengannya DSL kita mulai.  Implementasinya sedikit berbeda, dan sekarang kita akan mengetahuinya. <br>  Kotlin memiliki konsep tunggal yang dibangun langsung ke dalam bahasa.  Untuk melakukan ini, alih-alih kata kunci kelas, kata kunci <code>object</code> digunakan.  Jika kita membuat metode di dalam singleton, maka kita dapat mengaksesnya sedemikian rupa sehingga tidak perlu membuat instance dari kelas ini lagi.  Kami cukup menyebutnya sebagai metode statis di kelas. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d3d/226/065/d3d2260651fc4049ec8d3e6878a0cc51.jpg"><br><br>  Jika Anda melihat hasil dekompilasi (yaitu, di lingkungan pengembangan, klik Tools -&gt; Kotlin -&gt; Show Kotlin Bytecode -&gt; Decompile), Anda dapat melihat implementasi tunggal berikut: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3c6/8c9/577/3c68c957760612b06a5b008c734ddb33.jpg"><br><br>  Ini hanya kelas biasa, dan tidak ada supranatural yang terjadi di sini. <br>  Alat lain yang menarik adalah pernyataan <code>invoke</code> .  Bayangkan kita memiliki beberapa kelas A, kita memiliki instance-nya, dan kita ingin menjalankan instance ini, yaitu, memanggil tanda kurung pada objek kelas ini, dan kita dapat melakukan ini berkat operator yang <code>invoke</code> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/25f/3a1/f95/25f3a1f95c8c61dcb4937822bd9578e6.jpg"><br><br>  Bahkan, tanda kurung memungkinkan kita memanggil metode invoke dan memiliki pengubah operator.  Jika kita memberikan lambda dengan konteks ke operator ini, maka kita mendapatkan konstruksi seperti itu. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b6b/61d/675/b6b61d67518cb1dc730bce8e309ae0dc.jpg"><br><br>  Membuat instance setiap waktu adalah aktivitas lain, sehingga kami dapat menggabungkan pengetahuan sebelumnya dan saat ini. <br><br>  Mari kita buat singleton, sebut saja jadwalnya, di dalamnya kita akan mendeklarasikan operator yang dipanggil, di dalamnya kita akan membuat konteks, dan itu akan menerima lambda dengan konteks yang kita buat di sini.  Ternyata titik masuk tunggal ke DSL kami, dan, sebagai hasilnya, kami mendapatkan konstruksi yang sama - jadwal dengan kurung kurawal. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/53a/41f/7d8/53a41f7d8e9067b6ce850045e745fb4f.jpg"><br><br>  Ya, kami sudah membicarakan jadwal, mari kita lihat cek kami. <br>  Kami memiliki guru, kami telah membangun semacam jadwal, dan kami ingin memeriksa bahwa dalam jadwal guru ini pada hari tertentu dalam pelajaran tertentu ada beberapa objek yang akan kami gunakan. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/22d/0e3/9ef/22d0e39ef38ceb43fd60654de876691b.jpg"><br><br>  Saya ingin menggunakan tanda kurung siku dan mengakses jadwal kami dengan cara yang secara visual terlihat seperti akses ke array. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1e6/895/b9e/1e6895b9ed089ed99d4c2639e6e1f578.jpg"><br><br>  Ini dapat dilakukan dengan menggunakan operator: get / set: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/815/9f5/a86/8159f5a8628b6c5bb21d219e395ea32b.jpg"><br><br>  Di sini kita tidak melakukan sesuatu yang baru, cukup ikuti konvensi.  Dalam hal operator yang ditetapkan, kita perlu memberikan nilai-nilai tambahan ke metode kita: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4c8/03d/2f2/4c803d2f20ed8b7f79e308d47b734bd9.jpg"><br><br>  Jadi, tanda kurung siku untuk membaca berubah menjadi, dan tanda kurung siku tempat kita menetapkan berubah menjadi set. <br><br><h2>  Demo: objek, operator </h2><br>  Anda dapat membaca teks lebih lanjut atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menonton video di sini</a> .  Video memiliki waktu mulai yang jelas, tetapi tidak ada waktu akhir yang ditentukan - pada prinsipnya, setelah dimulai, Anda dapat menontonnya sebelum akhir artikel. <br><br>  Untuk kenyamanan, saya akan menguraikan esensi video secara langsung dalam teks. <br><br>  Mari kita menulis ujian.  Kami memiliki beberapa objek jadwal, dan jika kami pergi ke implementasinya melalui ctrl + b, maka kita akan melihat semua yang saya bicarakan sebelumnya. <br><br><img src="https://habrastorage.org/webt/uk/pg/0d/ukpg0djbwn_hfyq4a7g9usa65aa.png"><br><br>  Di dalam objek jadwal, kami ingin menginisialisasi data, lalu melakukan beberapa pemeriksaan, dan di dalam data, kami ingin mengatakan bahwa: <br><br><ul><li>  sekolah kami buka mulai jam 8 pagi; <br></li><li>  ada satu set item tertentu yang akan kami buat jadwal; <br></li><li>  ada beberapa guru yang menggambarkan semacam aksesibilitas; <br></li><li>  punya siswa; <br></li><li>  pada prinsipnya, untuk seorang siswa kita hanya perlu mengatakan bahwa dia sedang mempelajari mata pelajaran tertentu. <br></li></ul><br><img src="https://habrastorage.org/webt/v_/mq/ia/v_mqia50010hyrqza7zubejj62e.png"><br><br>  Dan di sini salah satu kelemahan Kotlin dan bahasa yang berorientasi masalah dimanifestasikan pada prinsipnya: cukup sulit untuk mengatasi beberapa objek yang kita buat sebelumnya.  Dalam demo ini, saya akan menunjukkan semuanya sebagai indeks, yaitu, rus adalah indeks 0, matematika adalah indeks 2. Dan guru secara alami juga memimpin sesuatu.  Dia tidak hanya pergi bekerja, tetapi terlibat dalam sesuatu.  Untuk pembaca artikel ini, saya ingin menawarkan satu opsi lagi untuk pengalamatan, Anda dapat membuat tag unik dan menyimpan entitas pada mereka di Peta, dan ketika Anda perlu mengakses salah satunya, Anda selalu dapat menemukannya dengan tag.  Terus membongkar DSL. <br><br>  Di sini, apa yang harus diperhatikan: pertama, kita memiliki operator +, yang untuk implementasinya kita juga dapat pergi dan melihat bahwa kita sebenarnya memiliki kelas DayPointer, yang membantu kita untuk mengikat semua ini dengan bantuan operator. <br><br>  Dan berkat kenyataan bahwa kami memiliki akses ke konteks, lingkungan pengembangan memberi tahu kami bahwa dalam konteks kami melalui kata kunci ini, kami memiliki akses ke beberapa koleksi, dan kami akan menggunakannya. <br><br><img src="https://habrastorage.org/webt/l_/3q/uw/l_3quwu2xaqlxikn71jhpnnero4.png"><br><br>  Artinya, kami memiliki koleksi acara.  Acara ini merangkum serangkaian properti, misalnya: bahwa ada seorang siswa, seorang guru, hari apa mereka bertemu pada pelajaran apa. <br><br><img src="https://habrastorage.org/webt/fn/1f/xa/fn1fxa5legi4mwszf5xbudchoi0.png"><br><br>  Kami terus menulis ujian lebih lanjut. <br><br><img src="https://habrastorage.org/webt/vj/bt/s9/vjbts9wb6fely-atqa-kr88i9qm.png"><br><br>  Di sini, sekali lagi, kami menggunakan operator get, tidak mudah untuk mencapai implementasinya, tetapi kami bisa melakukannya. <br><br><img src="https://habrastorage.org/webt/iz/gd/dv/izgddvy3bomaqjp_6yvbfrbcgpe.png"><br><br>  Bahkan, kami hanya mengikuti perjanjian, jadi kami mendapatkan akses ke desain ini. <br>  Mari kita kembali ke presentasi dan melanjutkan pembicaraan tentang Kotlin.  Kami ingin cek diterapkan di Kotlin, dan kami melewati acara-acara ini: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b4f/f23/a77/b4ff23a77974a299ecac5c1c3b5d984f.jpg"><br><br>  Suatu peristiwa pada dasarnya adalah kumpulan 4 properti yang dienkapsulasi.  Saya ingin menguraikan peristiwa ini menjadi serangkaian properti, seperti tuple.  Di Rusia, konstruksi semacam itu disebut <i>multi-deklarasi</i> (saya hanya menemukan terjemahan semacam itu), atau <i>deklarasi penataan</i> , dan berfungsi sebagai berikut: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f2c/185/5f1/f2c1855f1ee98b51a4bda6ce9cc0b0a8.jpg"><br><br>  Jika salah satu dari Anda tidak terbiasa dengan fitur ini, itu berfungsi seperti ini: Anda dapat mengambil acara, dan di tempat di mana ia digunakan, menggunakan tanda kurung, menguraikannya menjadi seperangkat properti. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/444/95f/0a3/44495f0a381b71a20578736f0cb491af.jpg"><br><br>  Ini berfungsi karena kita memiliki metode componentN, yaitu, itu adalah metode yang dihasilkan oleh kompiler berkat pengubah data yang kita tulis sebelum kelas. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/126/db9/d78/126db9d789acf9b3482f314d5a53261f.jpg"><br><br>  Seiring dengan ini, sejumlah besar metode lain terbang ke kami.  Kami tertarik pada metode componentN, yang dihasilkan berdasarkan pada properti yang tercantum dalam daftar parameter konstruktor utama. <br><br><img src="https://habrastorage.org/webt/hd/nf/ou/hdnfoutg14046a351gjyhodfprc.png"><br><br>  Jika kami tidak memiliki pengubah data, akan perlu untuk menulis secara manual operator yang akan melakukan hal yang sama. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e2b/37f/a2f/e2b37fa2fad7cd8e201987c32fbf572b.jpg"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/e59/bc7/479/e59bc7479e66cd96c4d0d5093ef33608.jpg"><br><br>  Jadi, kami memiliki beberapa metode componentN, dan mereka terurai menjadi panggilan seperti itu: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/96a/cae/aa9/96acaeaa91222d55c4a77b70c9b02903.jpg"><br><br>  Intinya, itu adalah gula sintaksis atas panggilan beberapa metode. <br><br>  Kami telah berbicara tentang beberapa tabel ketersediaan, dan, pada kenyataannya, saya menipu Anda.  Itu terjadi.  Tidak ada <code>avaiabilityTable</code> , tidak ada di alam, tetapi ada matriks nilai Boolean. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/393/d7d/5d7/393d7d5d739ea9cecedadff695ca6874.jpg"><br><br>  Tidak diperlukan kelas tambahan: Anda bisa mengambil matriks nilai Boolean dan menamainya ulang untuk lebih jelasnya.  Ini dapat dilakukan dengan menggunakan apa yang disebut <i>typealias</i> atau <i>tipe alias</i> .  Sayangnya, kami tidak mendapatkan bonus tambahan dari ini, itu hanya penamaan ulang.  Jika Anda mengambil ketersediaan dan menamainya kembali ke matriks nilai Boolean, tidak ada yang akan berubah sama sekali.  Kedua kode tersebut berfungsi dan akan berfungsi. <br><br>  Mari kita lihat ke guru, ini aksesibilitas yang tepat ini, dan bicarakan tentang dia: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/521/031/f59/521031f59a8e7b222c2614b32ba88abd.jpg"><br><br>  Kami memiliki guru, dan metode ketersediaannya disebut (apakah Anda belum kehilangan alur penalarannya? :-).  Dari mana asalnya?  Artinya, seorang guru adalah semacam entitas yang memiliki kelas, dan ini adalah kode bisnis.  Dan tidak ada metode tambahan. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/54e/044/683/54e0446838b2360d695b45e5bacec69d.jpg"><br><br>  Metode ini muncul karena fungsi ekstensi.  Kita ambil dan kencangkan ke kelas kita beberapa fungsi lain yang bisa kita jalankan pada objek kelas ini. <br>  Jika kita melewatkan beberapa lambda ke fungsi ini, dan kemudian menjalankannya di properti yang ada, maka semuanya baik-baik saja - metode ketersediaan dalam implementasinya menginisialisasi properti ketersediaan.  Anda dapat menyingkirkan ini.  Kita sudah tahu tentang operator yang dipanggil, yang dapat dilampirkan ke suatu jenis, dan pada saat yang sama menjadi fungsi ekstensi.  Jika Anda mengirimkan lambda ke operator ini, maka di sana, dengan kata kunci ini, kita dapat menjalankan lambda ini.  Akibatnya, ketika kami bekerja dengan seorang guru, aksesibilitas adalah milik guru, dan bukan metode tambahan, dan tidak ada rassynchron yang terjadi di sini. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4d6/1af/f71/4d61aff7169c403c75493790720c0e6e.jpg"><br><br>  Sebagai bonus, fungsi ekstensi dapat dibuat untuk jenis yang dapat dibatalkan.  Ini bagus, karena jika ada variabel dengan tipe nullable yang berisi nilai null, fungsi kami sudah siap untuk ini, dan tidak akan jatuh dari NullPointer.  Di dalam fungsi ini, ini bisa menjadi nol, dan ini perlu ditangani. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/59a/e33/1c5/59ae331c58bcd16003f51f870b89549e.jpg"><br><br>  Meringkas fungsi ekstensi: Anda perlu memahami bahwa hanya ada akses ke API publik dari kelas, dan kelas itu sendiri tidak dimodifikasi dengan cara apa pun.  Fungsi ekstensi ditentukan oleh tipe variabel, dan bukan oleh tipe aktual.  Selain itu, anggota kelas dengan tanda tangan yang sama akan diprioritaskan.  Anda dapat membuat fungsi ekstensi untuk satu kelas, tetapi menulisnya di kelas yang sama sekali berbeda, dan di dalam fungsi ekstensi ini akan ada akses ke dua konteks secara bersamaan.  Ternyata persimpangan konteks.  Dan akhirnya, ini adalah peluang besar untuk membawa dan mengencangkan operator secara umum ke tempat mana pun yang kita inginkan. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a04/1e8/610/a041e86102be21acf2c3170cf941d064.jpg"><br><br>  Alat selanjutnya adalah fungsi infiks.  Palu lain yang berbahaya di tangan pengembang.  Kenapa berbahaya?  Apa yang Anda lihat adalah kode.  Kode semacam itu dapat ditulis di Kotlin, dan jangan lakukan itu!  Tolong jangan lakukan itu.  Namun demikian, pendekatannya bagus.  Berkat ini, dimungkinkan untuk menghilangkan titik-titik, tanda kurung - dari semua sintaks yang berisik, dari mana kami mencoba untuk mendapatkan sejauh mungkin dan membuat kode kami sedikit lebih bersih. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/909/8c3/4a0/9098c34a06b09bac0597004c6fbf6b1a.jpg"><br><br>  Bagaimana cara kerjanya?  Mari kita ambil contoh sederhana - variabel integer.  Mari kita buat fungsi ekstensi untuknya, sebut saja shouldBeEqual, itu akan melakukan sesuatu, tapi ini tidak menarik.  Jika kami menambahkan pengubah infiks ke kiri, itu sudah cukup.  Anda dapat menghilangkan titik dan tanda kurung, tetapi ada beberapa nuansa. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/39e/fc2/31f/39efc231fb88cee1ef014a36fcb6cc73.jpg"><br><br>  Atas dasar ini, hanya konstruksi data dan pernyataan diimplementasikan, diikat bersama. <br><img src="https://habrastorage.org/getpro/habr/post_images/80f/6dd/126/80f6dd126255196fc538026ea28656c1.jpg"><br><br>  Mari kita cari tahu.  Kami memiliki Konteks Penjadwalan - konteks umum penjadwalan startup.  Ada fungsi data yang mengembalikan hasil perencanaan ini.  Pada saat yang sama, kami membuat fungsi ekstensi dan pada saat yang sama pernyataan fungsi infiks, yang akan meluncurkan lambda yang memeriksa nilai-nilai kami. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/449/74c/fe5/44974cfe559d94d17e6435557757af80.jpg"><br><br>  Ada subjek, objek dan tindakan, dan Anda perlu menghubungkannya entah bagaimana.  Dalam hal ini, hasil dari mengeksekusi data dengan kurung kurawal adalah subjek.  Lambda yang kita berikan ke metode asersi adalah sebuah objek, dan metode asersi itu sendiri adalah sebuah aksi.  Semua ini tampaknya tetap bersatu. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/518/aac/4e9/518aac4e9d92ca84a79e6cdb09fea773.jpg"><br><br>  Berbicara tentang fungsi infix, penting untuk dipahami bahwa ini adalah langkah untuk menghilangkan sintaks yang berisik.  Namun, kita harus memiliki subjek dan objek dari tindakan ini, dan kita perlu menggunakan pengubah infiks.  Mungkin ada satu parameter - yaitu, parameter nol tidak bisa, dua tidak bisa, tiga - yah, Anda mengerti.  Anda dapat meneruskan, misalnya, lambda ke fungsi ini, dan dengan cara ini konstruk yang belum Anda lihat sebelumnya diperoleh. <br><br>  Mari kita beralih ke demo berikutnya.  Lebih baik menonton video, dan tidak membaca teks. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/q_UM1EY2S5g" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  Sekarang semuanya tampak siap: infix fungsi yang Anda lihat, ekstensi fungsi yang Anda lihat, deklarasi perusakan siap. <br><br>  Mari kita kembali ke presentasi kita, dan di sini kita akan beralih ke satu poin yang agak penting ketika membangun bahasa yang berorientasi masalah - apa yang harus Anda pikirkan adalah kontrol konteks. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9ff/0d3/57a/9ff0d357a3e39d01bcb3d5d07d81d71e.jpg"><br><br>  Ada beberapa situasi ketika kita dapat menggunakan DSL dan menggunakannya kembali di dalamnya, tetapi kami tidak ingin melakukan ini.  Pengguna kami (mungkin pengguna yang tidak berpengalaman) menulis data di dalam data, dan itu tidak masuk akal.  Kami ingin melarangnya melakukan hal ini. <br><br>  Sebelum Kotlin versi 1.1, kami harus melakukan hal berikut: sebagai tanggapan terhadap fakta bahwa kami memiliki metode data dalam <code>SchedulingContext</code> , kami harus membuat metode data lain di <code>DataContext</code> , di mana kami menerima lambda (walaupun tanpa implementasi), kami harus menandai metode ini annotation <code>@Deprecated</code> dan beri tahu kompiler untuk tidak mengkompilasi ini.  Anda melihat bahwa metode ini dimulai - jangan dikompilasi.  Menggunakan pendekatan ini, kami bahkan mendapatkan beberapa pesan yang bermakna ketika kami menulis kode yang tidak berarti. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dfb/7a7/0b4/dfb7a70b4fba1c5cb0bf37715a4fe1bd.jpg"><br><br>  Setelah versi Kotlin 1.1, anotasi indah <code>@DslMarker</code> .  Anotasi ini diperlukan untuk menandai anotasi yang diturunkan.  Dengan mereka, pada gilirannya, kami akan menandai bahasa yang berorientasi masalah.  Untuk setiap bahasa yang berorientasi masalah, Anda bisa membuat satu anotasi yang Anda tandai <code>@DslMarker</code> dan menggantungnya di setiap konteks yang diperlukan.  Tidak perlu lagi menulis metode tambahan yang harus dilarang dikompilasi - semuanya berfungsi.  Tidak dikompilasi. <br><br>  Namun, ada satu kasus khusus ketika kami bekerja dengan model bisnis kami.  Biasanya ditulis dalam Java.  ,   ,    .  ,     ?  <code>Student</code> .  –   -,  Kotlin . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4c6/111/c5c/4c6111c5c80ab5c4856e68c06880ed4a.jpg"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/cc3/572/a05/cc3572a054dabbe4e32362d845b30cf8.jpg"><br><br>    -    ,         :    .        ,     ,  . <br><br><img width="100%" src="https://habrastorage.org/getpro/habr/post_images/2fd/77d/125/2fd77d1250c0677a24c1c9c358f11663.jpg"><br><br>     . <br><br><ol><li>   ,     .   StudentContext.    ,        .    –   , , ,   . <br></li><li>   –      ,    ,     .        .  StudentContext  ,      IStudent       .  ,       Student,        IStudent  StudentContext.   DslMarker  ,  . <br></li><li>  :   deprecated     .   ,   .       ,   .       extension-,     .       . <br></li></ol><br><img src="https://habrastorage.org/getpro/habr/post_images/9ea/10d/d6a/9ea10dd6af4495be38653339010e0a46.jpg"><br><br>  ,       ,    ,    . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1d7/9f9/53f/1d79f953fc755000013d44d15f56fb73.jpg"><br><br>    .     . ,       ,   ,      .  ,           .   @DslMarker,      .   ,       @DslMarker,   @Deprecated,      ,    . <br><br> ,   : <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/q_UM1EY2S5g" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><img src="https://habrastorage.org/getpro/habr/post_images/16c/690/f58/16c690f589bf90cc1547edc1ee985ae0.jpg"><br><br><h2>    </h2><br> -,   DSL.    ,      DSL    .  ,   ,      ,      . <br><br> ,     -  ,      , ,      , -   ,    .   ?    for —    .       DSL,       , ,        DSL.     this     it.  ,   Kotlin  1.2.20    ,      .    ,         it. <br><br>    .    DSL,     --,        ,  . ,      . ,    ,        ,   - ,       ,     .   . , -    ,     .. <br><br> , .    ,     -  –      DSL. ,     Kotlin-,   . ,   DSL   ,   ,   Kotlin-  .   -?     Gradle-,   ,   ,    ,   - .    - ,   ,    –    ,       DSL. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/13e/4e0/05a/13e4e005af12def0ee687b008ffc41ac.jpg"><br><br>   DSL'   , .    ,     .  ,   DSL ,  ,   . - –   . -, -      . ,       - . <br> ,  Kotlin.  ,     ,  ,       , , ,     .         (, - ,     ),      ,   DSL  , ,       ,     .      . <br><br>   «»,     .   ,       Kotlin   .     ,  ,    .    ,        —  ,     . <br> ,   DSL.      ,       - .    DSL,      ,     10   ,      ,   -      .    DSL –      ,     ,     . <br><br>  ,   .    , Telegram: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">@ivan_osipov</a> , Twitter: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">@_osipov_</a> , : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">i_osipov</a> .    . <br><br><blockquote>  Menit periklanan.        <b>JPoint</b> —  ,  19-20   -  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Joker 2018</a> —    Java-.       .    ,         . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id416725/">https://habr.com/ru/post/id416725/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id416711/index.html">Halaman sejarah Intel. Kebakaran pabrik Penang</a></li>
<li><a href="../id416713/index.html">Laporan Club of Rome 2018, Bab 3.14: “Bukan PDB tunggal ...”</a></li>
<li><a href="../id416719/index.html">Ekstensi PHP dan Kotlin Asli. Bagian Dua, Sadar</a></li>
<li><a href="../id416721/index.html">Rumah DIY: rumah boneka untuk dewasa</a></li>
<li><a href="../id416723/index.html">Aksesibilitas API: Antarmuka Bahasa Alami</a></li>
<li><a href="../id416727/index.html">Kursus MIT "Keamanan Sistem Komputer". Kuliah 2: "Kontrol serangan hacker", bagian 3</a></li>
<li><a href="../id416729/index.html">Program PYCON RUSSIA siap: 25 laporan dan 3 lokakarya dari para pembicara dari Google, Red Hat, Yelp, Yandex</a></li>
<li><a href="../id416731/index.html">Frost on glass: cara membuat plastik metglass tugas berat</a></li>
<li><a href="../id416737/index.html">A * Path Finding Algorithm dalam Voxel 3d Unity Game</a></li>
<li><a href="../id416739/index.html">ASUS baru di Computex 2018</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>