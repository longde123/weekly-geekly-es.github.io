<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëÄ üç£ üïù 5 formas de implementar c√≥digo PHP en condiciones de alta carga üë®üèª‚Äçüåæ ü§∑üèæ üòô</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Si se ense√±aran las carreteras en la escuela, el libro de texto sobre este tema tendr√≠a esa tarea. ‚ÄúLa red social N tiene 2,000 servidores, en los cua...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>5 formas de implementar c√≥digo PHP en condiciones de alta carga</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/449916/">  Si se ense√±aran las carreteras en la escuela, el libro de texto sobre este tema tendr√≠a esa tarea.  ‚ÄúLa red social N tiene 2,000 servidores, en los cuales 150,000 archivos de 900 MB cada c√≥digo PHP y un cl√∫ster provisional para 50 m√°quinas.  El c√≥digo se implementa 2 veces al d√≠a en los servidores, el c√≥digo se actualiza cada pocos minutos en el cl√∫ster provisional, y hay "revisiones" adicionales: peque√±os conjuntos de archivos que se distribuyen de forma alternada en todos o en la parte seleccionada de los servidores, sin esperar el c√°lculo completo.  Pregunta: ¬øse consideran tales condiciones de alta carga y c√≥mo implementarlas?  Escriba al menos 5 opciones de implementaci√≥n ".  Solo podemos so√±ar con el libro de problemas hyload, pero ya sabemos que <strong>Yuri Nasretdinov</strong> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">youROCK</a> ) definitivamente resolver√≠a este problema y obtendr√≠a los "cinco". <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/qMu4YHJV1Z8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Yuri no se detuvo en una soluci√≥n simple, sino que tambi√©n hizo un informe en el que revel√≥ el concepto del concepto de "implementaci√≥n de c√≥digo", habl√≥ de soluciones cl√°sicas y alternativas para implementaciones PHP a gran escala, analiz√≥ su rendimiento y present√≥ el sistema de implementaci√≥n MDK. <br><a name="habracut"></a><br><h2>  El concepto de "c√≥digo de implementaci√≥n" </h2><br>  En ingl√©s, el t√©rmino "despliegue" significa poner a las tropas en alerta, y en ruso a veces decimos "llene el c√≥digo en la batalla", lo que significa lo mismo.  Usted toma el c√≥digo en el ya compilado o en el original, si es PHP, lo descarga en los servidores que sirven al tr√°fico del usuario y luego, por arte de magia, cambia la carga de una versi√≥n del c√≥digo a otra.  Todo esto est√° incluido en el concepto de "implementaci√≥n de c√≥digo". <br><br>  El proceso de implementaci√≥n generalmente consta de varias etapas. <br><br><ul><li>  <strong>Obtener el c√≥digo del repositorio</strong> de la forma que desee: clonar, buscar, pagar. </li><li> <strong>Montaje - construcci√≥n</strong> .  Para el c√≥digo PHP, puede faltar la fase de compilaci√≥n.  En nuestro caso, esto es, por regla general, la generaci√≥n autom√°tica de archivos de traducci√≥n, la carga de archivos est√°ticos a CDN y algunas otras operaciones. </li><li>  <strong>Entrega a servidores finales</strong> : implementaci√≥n. </li></ul><br>  Despu√©s de ensamblar todo, comienza la fase de implementaci√≥n inmediata: el <strong>c√≥digo</strong> se <strong>vierte en los servidores de producci√≥n</strong> .  Es sobre esta fase que se discutir√° <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Badoo</a> . <br><br><h2>  Antiguo sistema de despliegue en Badoo </h2><br>  Si tiene un archivo con una imagen del sistema de archivos, ¬øc√≥mo montarlo?  En Linux, debe crear <strong>un dispositivo de bucle intermedio</strong> , adjuntarle un archivo y, despu√©s de eso, ya puede montar este dispositivo de bloque. <br><br>  Un dispositivo de bucle es una muleta que Linux necesita para montar una imagen del sistema de archivos.  Hay sistemas operativos en los que no se requiere esta muleta. <br><br><img src="https://habrastorage.org/webt/gd/ch/h6/gdchh68qpl5ikkpddsvxzwcwvlm.png"><br><br>  ¬øC√≥mo utiliza el proceso de implementaci√≥n los archivos, que tambi√©n llamamos "bucles" por simplicidad?  Hay un directorio en el que se encuentran el c√≥digo fuente y el contenido generado autom√°ticamente.  Tomamos una imagen vac√≠a del sistema de archivos; ahora es EXT2 y antes utilizamos ReiserFS.  Montamos una imagen vac√≠a del sistema de archivos en un directorio temporal, copiamos todo el contenido all√≠.  Si no necesitamos algo para entrar en producci√≥n, entonces no estamos copiando todo.  Despu√©s de eso, desmonte el dispositivo y obtenga la imagen del sistema de archivos en el que se encuentran los archivos necesarios.  A continuaci√≥n, <strong>archivamos la imagen y la cargamos en todos los servidores</strong> , all√≠ la descomprimimos y la montamos. <br><br><h2>  Otras soluciones existentes </h2><br>  Primero, agradezcamos a <strong>Richard Stallman</strong> : sin su licencia, la mayor√≠a de las utilidades que utilizamos no hubieran existido. <br><br><img src="https://habrastorage.org/webt/8h/oa/yh/8hoayhyyicam7izl-q7egj8bitq.png"><br><br>  Convencionalmente divid√≠ los m√©todos de implementaci√≥n de c√≥digo PHP en 4 categor√≠as. <br><br><ul><li>  <strong>Basado en el sistema de control de versiones</strong> : svn up, git pull, hg up. </li><li>  <strong>Basado en la utilidad rsync</strong> : a un nuevo directorio o "en la parte superior". </li><li>  <strong>Implemente un archivo</strong> , sin importar qu√©: phar, hhbc, loop. </li><li>  La forma especial que sugiri√≥ <strong>Rasmus Lerdorf</strong> es <strong>rsync, 2 directorios y realpath_root</strong> . </li></ul><br>  Cada m√©todo tiene ventajas y desventajas, por lo que los abandonamos.  Considere estos 4 m√©todos con m√°s detalle. <br><br><h3>  Implementaci√≥n basada en el sistema de control de versiones svn up </h3><br>  Eleg√≠ SVN no por casualidad; de acuerdo con mis observaciones, de esta forma el despliegue existe precisamente en el caso de SVN.  El sistema es bastante <strong>liviano</strong> , le permite implementarlo de manera <strong>r√°pida y f√°cil</strong> : simplemente ejecute svn up y listo. <br><br>  Pero este m√©todo tiene una gran desventaja: si lo hace, y en el proceso de actualizaci√≥n del c√≥digo fuente, cuando nuevas solicitudes provengan del repositorio, ver√°n el estado del sistema de archivos que no exist√≠a en el repositorio.  Tendr√° parte de los archivos nuevos y parte de los antiguos; este es un <strong>m√©todo de implementaci√≥n no at√≥mico</strong> que no es adecuado para cargas elevadas, sino solo para proyectos peque√±os.  A pesar de esto, conozco proyectos que todav√≠a se implementan de esta manera, y hasta ahora todo funciona para ellos. <br><br><h3>  Implementaci√≥n basada en la utilidad rsync </h3><br>  Hay dos opciones sobre c√≥mo hacer esto: cargar archivos usando la utilidad directamente al servidor y cargar "en la parte superior" - actualizar. <br><br><h4>  rsync a un nuevo directorio </h4><br>  Dado que primero vierte completamente todo el c√≥digo en un directorio que a√∫n no existe en el servidor, y solo luego cambia el tr√°fico, este m√©todo es <strong>at√≥mico</strong> : nadie ve un estado intermedio.  En nuestro caso, la creaci√≥n de 150,000 archivos y la eliminaci√≥n del directorio anterior, que tambi√©n tiene 150,000 archivos, crea una <strong>gran carga en el subsistema de disco</strong> .  Usamos discos duros muy activamente, y el servidor en alg√∫n lugar por un minuto no se siente muy bien despu√©s de tal operaci√≥n.  Como tenemos 2000 servidores, es necesario completar 900 MB 2000 veces. <br><br>  Este esquema se puede mejorar si primero carga a un cierto n√∫mero de servidores intermedios, por ejemplo, 50, y luego los agrega al resto.  Esto resuelve posibles problemas con la red, pero el problema de crear y eliminar una gran cantidad de archivos no desaparece en ning√∫n lado. <br><br><img src="https://habrastorage.org/webt/wj/c9/pt/wjc9ptyfin79_dn6jmnornudzt8.png"><br><br><h4>  rsync en la parte superior </h4><br>  Si us√≥ rsync, entonces sabe que esta utilidad no solo puede llenar directorios completos, sino tambi√©n actualizar los existentes.  Enviar solo cambios es una ventaja, pero como cargamos los cambios en el mismo directorio donde servimos el c√≥digo de batalla, tambi√©n habr√° alg√∫n tipo de estado intermedio, esto es un menos. <br><br>  Enviar cambios funciona as√≠.  Rsync crea listas de archivos en el lado del servidor desde el que se realiza la implementaci√≥n y en el lado de recepci√≥n.  Despu√©s de eso, cuenta las estad√≠sticas de todos los archivos y env√≠a la lista completa al lado receptor.  En el servidor del que procede la implementaci√≥n, se considera la diferencia entre estos valores y se determina qu√© archivos deben enviarse. <br><br>  En nuestras condiciones, este proceso requiere aproximadamente <strong>3 MB de tr√°fico y 1 segundo de tiempo de procesador</strong> .  Parece que esto no es mucho, pero tenemos 2.000 servidores, y todo resulta al menos un minuto de tiempo de procesador.  Este no es un m√©todo tan r√°pido, pero definitivamente es mejor que enviar todo a trav√©s de rsync.  Queda por resolver de alguna manera el problema de la atomicidad y ser√° casi perfecto. <br><br><h3>  Implementar un archivo </h3><br>  Cualquiera que sea el archivo que cargue, es relativamente sencillo hacerlo utilizando BitTorrent o la utilidad UFTP.  Un archivo es m√°s f√°cil de descomprimir, se puede reemplazar at√≥micamente en Unix, y es f√°cil verificar la integridad del archivo generado en el servidor de compilaci√≥n y entregado a las m√°quinas de destino calculando las cantidades MD5 o SHA-1 del archivo (en el caso de rsync, no sabe qu√© hay en los servidores de destino ) <br><br>  Para los discos duros, la grabaci√≥n secuencial es una gran ventaja: un archivo de 900 MB se escribir√° en un disco duro desocupado en aproximadamente 10 segundos.  Pero a√∫n necesita grabar estos mismos 900 MB y transferirlos a trav√©s de la red. <br><br><h4>  Digresi√≥n l√≠rica sobre UFTP </h4><br>  Esta utilidad de c√≥digo abierto se cre√≥ originalmente para transferir archivos a trav√©s de una red con largas demoras, por ejemplo, a trav√©s de una red basada en sat√©lites.  Pero UFTP result√≥ ser adecuado para cargar archivos a una gran cantidad de m√°quinas, ya que funciona utilizando el protocolo UDP basado en Multicast.  Se crea una direcci√≥n de multidifusi√≥n, todas las m√°quinas que desean recibir el archivo se suscriben y los conmutadores proporcionan la entrega de copias de paquetes a cada m√°quina.  Entonces cambiamos la carga de transmitir datos a la red.  Si su red puede manejar esto, entonces este m√©todo funciona mucho mejor que BitTorrent. <br><br>  Puede probar esta utilidad de c√≥digo abierto en su cl√∫ster.  A pesar de que funciona a trav√©s de UDP, tiene un mecanismo NACK: reconocimiento negativo, que obliga a reenviar los paquetes perdidos en la entrega.  <strong>Esta es una forma confiable de implementar</strong> . <br><br><h4>  Opciones de implementaci√≥n de un solo archivo </h4><br>  <strong>tar.gz</strong> <br><br>  Una opci√≥n que combina las desventajas de ambos enfoques.  No solo tiene que escribir 900 MB en el disco de forma secuencial, sino que tambi√©n debe volver a escribir los mismos 900 MB por lectura aleatoria y crear 150,000 archivos.  Este m√©todo es a√∫n peor en rendimiento que rsync. <br><br>  <strong>phar</strong> <br><br>  PHP admite archivos en formato phar (Archivo PHP), sabe c√≥mo dar sus contenidos e incluir archivos.  Pero no todos los proyectos son f√°ciles de poner en un solo faro: necesita la adaptaci√≥n del c√≥digo.  Solo porque el c√≥digo de este archivo no funciona.  Adem√°s, no puede cambiar un archivo en el archivo ( <em>Yuri del futuro: en teor√≠a, a√∫n puede</em> hacerlo), debe volver a cargar todo el archivo.  Adem√°s, a pesar del hecho de que los archivos phar funcionan con OPCache, cuando se implementa, el cach√© debe descartarse, porque de lo contrario habr√° basura en OPCache del antiguo archivo phar. <br><br>  <strong>hhbc</strong> <br><br>  Este m√©todo es nativo de HHVM - HipHop Virtual Machine y es utilizado por Facebook.  Esto es algo as√≠ como un archivo phar, pero no contiene los c√≥digos fuente, sino el c√≥digo de bytes compilado de la m√°quina virtual HHVM: el int√©rprete PHP de Facebook.  Est√° prohibido cambiar cualquier cosa en este archivo: no puede crear nuevas clases, funciones y algunas otras caracter√≠sticas din√°micas en este modo est√°n deshabilitadas.  Debido a estas limitaciones, la m√°quina virtual puede usar optimizaciones adicionales.  Seg√∫n Facebook, esto puede aumentar hasta un 30% la velocidad de ejecuci√≥n del c√≥digo.  Esta es probablemente una buena opci√≥n para ellos.  Tambi√©n es imposible cambiar un archivo aqu√≠ ( <em>Yuri del futuro: en realidad es posible, porque es una base sqlite</em> ).  Si desea cambiar una l√≠nea, debe volver a hacer todo el archivo nuevamente. <br><br>  Para este m√©todo, est√° <strong>prohibido utilizar eval e include din√°mico.</strong>  Esto es as√≠, pero no del todo.  Se puede usar Eval, pero si no crea nuevas clases o funciones, y la inclusi√≥n no se puede hacer desde directorios que est√°n fuera de este archivo. <br><br>  <strong>bucle</strong> <br><br>  Esta es nuestra versi√≥n anterior, y tiene dos grandes ventajas.  Primero, parece un directorio regular <strong>.</strong>  Monta el bucle y, para el c√≥digo, no importa: funciona con archivos, tanto en el entorno de desarrollo como en el entorno de producci√≥n.  El segundo bucle puede montarse en modo de lectura y escritura, y cambiar un archivo, si a√∫n necesita cambiar algo urgentemente para la producci√≥n. <br><br>  Pero loop tiene contras.  Primero, funciona de manera extra√±a con Docker.  Hablar√© de esto un poco m√°s tarde. <br><br>  En segundo lugar, si usa el enlace simb√≥lico en el √∫ltimo bucle como document_root, tendr√° problemas con OPCache.  No es muy bueno tener un enlace simb√≥lico en la ruta y comienza a confundir qu√© versiones de los archivos usar.  Por lo tanto, OPCache debe reiniciarse cuando se implementa. <br><br>  Otro problema es que <strong>se requieren privilegios de superusuario</strong> para montar sistemas de archivos.  Y no debe olvidarse de montarlos al inicio / reinicio de la m√°quina, porque de lo contrario habr√° un directorio vac√≠o en lugar de c√≥digo. <br><br><h4>  Problemas con la ventana acoplable </h4><br>  Si crea un contenedor acoplable y arroja dentro de √©l una carpeta en la que se montan "bucles" u otros dispositivos de bloque, surgen dos problemas a la vez: los nuevos puntos de montaje no caen en el contenedor acoplable y esos "bucles" que estaban en el momento de la creaci√≥n Un contenedor acoplable <strong>no se puede desmontar</strong> porque est√° ocupado por un contenedor acoplable. <br><br>  Naturalmente, esto generalmente es incompatible con la implementaci√≥n, porque la cantidad de dispositivos de bucle es limitada y no est√° claro c√≥mo el nuevo c√≥digo debe caer en el contenedor. <br><br>  Intentamos hacer cosas extra√±as, por ejemplo, generar un <strong>servidor NFS</strong> local o montar un directorio usando SSHFS, pero por alguna raz√≥n esto no se arraig√≥ con nosotros.  Como resultado, en cron, registramos rsync desde el √∫ltimo "bucle" en el directorio actual, y ejecut√≥ el comando una vez por minuto: <br><pre><code class="php hljs">rsync /<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>/loop/&lt;N&gt;/ /<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>/www/</code> </pre> <br>  Aqu√≠ <code>/var/www/</code> es el directorio que se promociona al contenedor.  Pero en las m√°quinas que tienen contenedores acoplables, no necesitamos ejecutar scripts PHP a menudo, por lo que rsync no era at√≥mico, lo que nos conven√≠a.  Pero a√∫n as√≠, este m√©todo es muy malo, por supuesto.  Me gustar√≠a hacer un sistema de implementaci√≥n que funcione bien con Docker. <br><br><h3>  rsync, 2 directorios y realpath_root </h3><br>  Este m√©todo fue propuesto por Rasmus Lerdorf, el autor de PHP, y √©l sabe c√≥mo implementarlo. <br><br>  ¬øC√≥mo hacer un despliegue at√≥mico y de alguna de las formas de las que habl√©?  Tome el enlace simb√≥lico y reg√≠strelo como document_root.  En cada momento, el enlace simb√≥lico apunta a uno de los dos directorios y convierte rsync en un directorio vecino, es decir, al que el c√≥digo no apunta. <br><br><img src="https://habrastorage.org/webt/x7/qh/49/x7qh49aslgwu3loufk6wixt8fcg.png"><br><br>  Pero surge el problema: el c√≥digo PHP no sabe en qu√© directorios se lanz√≥.  Por lo tanto, debe usar, por ejemplo, una variable que escribir√° en alg√∫n lugar al principio de la configuraci√≥n: fijar√° desde qu√© directorio se ejecut√≥ el c√≥digo y desde qu√© archivos nuevos deben incluirse.  En una diapositiva, se llama <code>ROOT_DIR</code> . <br><br>  Use esta constante cuando acceda a todos los archivos dentro del c√≥digo que usa en producci√≥n.  Entonces obtiene la propiedad de atomicidad: las solicitudes que vienen antes de cambiar el enlace simb√≥lico contin√∫an incluyendo archivos del directorio anterior en el que no cambi√≥ nada, y las solicitudes nuevas que vinieron despu√©s del cambio de enlace simb√≥lico comienzan a funcionar desde el nuevo directorio y se atienden nuevo c√≥digo <br><br><img src="https://habrastorage.org/webt/ny/o3/hh/nyo3hhqqs2iwthucxiquyf-org4.png"><br><br>  Pero esto debe escribirse en el c√≥digo.  No todos los proyectos est√°n listos para esto. <br><br><h3>  Estilo rasmus </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Rasmus sugiere en</a> lugar de modificar manualmente el c√≥digo y crear constantes para modificar ligeramente Apache o usar nginx. <br><br><img src="https://habrastorage.org/webt/8f/c3/xy/8fc3xyhs8rgmrtp45qeguvtzufi.png"><br><br>  Para document_root, especifique el enlace simb√≥lico a la √∫ltima versi√≥n.  Si tiene nginx, puede registrar <code>root $realpath_root</code> , para Apache necesitar√° un m√≥dulo separado con la configuraci√≥n que se puede ver en la diapositiva.  Funciona as√≠: cuando llega una solicitud, nginx o Apache de vez en cuando consideran realpath () de la ruta, la guardan de los enlaces simb√≥licos y pasan esta ruta como document_root.  En este caso, document_root siempre apuntar√° a un directorio normal sin enlaces simb√≥licos, y es posible que su c√≥digo PHP no tenga que pensar desde qu√© directorio se llama. <br><br>  Este m√©todo tiene ventajas interesantes: las rutas reales llegan a OPCache PHP, no contienen enlaces simb√≥licos.  Incluso el primer archivo al que lleg√≥ la solicitud ya estar√° lleno, y no habr√° problemas con OPCache.  Como se usa document_root, esto funciona con cualquier proyecto PHP.  No necesitas adaptar nada. <br><br>  No requiere la recarga de fpm, no es necesario restablecer OPCache durante la implementaci√≥n, raz√≥n por la cual el servidor del procesador est√° muy ocupado, ya que debe analizar todos los archivos nuevamente.  En mi experimento, restablecer OPCache en aproximadamente medio minuto aument√≥ el consumo del procesador en un factor de 2‚Äì3.  Ser√≠a bueno reutilizarlo y este m√©todo le permite hacerlo. <br><br>  Ahora los contras.  Como no reutiliza OPCache y tiene 2 directorios, debe almacenar una copia del archivo en la memoria para cada directorio; en OPCache, se requiere 2 veces m√°s memoria. <br><br>  Hay otra limitaci√≥n que puede parecer extra√±a: <strong>no se puede implementar m√°s de una vez cada max_execution_time</strong> .  De lo contrario, se producir√° el mismo problema, porque mientras rsync va a uno de los directorios, las solicitudes de este a√∫n pueden procesarse. <br><br>  Si usa Apache por alguna raz√≥n, entonces necesita un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">m√≥dulo de terceros</a> que Rasmus tambi√©n escribi√≥. <br><br>  Rasmus dice que el sistema es bueno y se lo recomiendo a usted tambi√©n.  Para el 99% de los proyectos, es adecuado, tanto para proyectos nuevos como para proyectos existentes.  Pero, por supuesto, no somos as√≠ y decidimos escribir nuestra propia decisi√≥n. <br><br><h2>  Nuevo sistema - MDK </h2><br>  B√°sicamente, nuestros requisitos no son diferentes de los requisitos para la mayor√≠a de los proyectos web.  Solo queremos una <strong>implementaci√≥n r√°pida</strong> en la preparaci√≥n y producci√≥n, <strong>bajo consumo de recursos</strong> , reutilizaci√≥n de OPCache y r√°pida reversi√≥n. <br><br>  Pero hay dos requisitos m√°s que pueden diferir del resto.  En primer lugar, es la capacidad de <strong>aplicar parches at√≥micamente</strong> .  Nos referimos a los parches como cambios en uno o varios archivos que gobiernan algo en la producci√≥n.  Queremos hacerlo r√°pido.  En principio, el sistema que ofrece Rasmus est√° haciendo frente a la tarea de parche. <br><br>  Tambi√©n tenemos <strong>scripts de CLI</strong> <strong>que pueden ejecutarse durante varias horas</strong> , y a√∫n deber√≠an funcionar con una versi√≥n coherente del c√≥digo.  En este caso, las soluciones anteriores, desafortunadamente, no nos convienen o debemos tener muchos directorios. <br><br>  Posibles soluciones: <br><br><ul><li>  bucle xN (-staging, -docker, -opcache); </li><li>  rsync xN (-producci√≥n, -opcache xN); </li><li>  SVN xN (-producci√≥n, -opcache xN). </li></ul><br>  Aqu√≠ N es el n√∫mero de c√°lculos que ocurren en unas pocas horas.  Podemos tener docenas de ellos, lo que significa la necesidad de gastar una gran cantidad de espacio para copias adicionales del c√≥digo. <br><br>  Por lo tanto, se nos ocurri√≥ un nuevo sistema y lo llamamos <strong>MDK.</strong>  Es sin√≥nimo de <strong>Multiversion Deployment Kit</strong> , una herramienta de implementaci√≥n de m√∫ltiples versiones.  Lo hicimos en base a los siguientes supuestos. <br><br>  <strong>Tomamos la arquitectura de almacenamiento en √°rbol de Git.</strong>  Necesitamos tener una versi√≥n coherente del c√≥digo en el que funciona el script, es decir, necesitamos instant√°neas.  Las instant√°neas son compatibles con LVM, pero all√≠ son implementadas de manera ineficiente por sistemas de archivos experimentales como Btrfs y Git.  Tomamos la implementaci√≥n de instant√°neas de Git. <br><br>  <strong>Renombrado todos los archivos de file.php a file.php. &lt;Versi√≥n&gt;.</strong>  Dado que todos los archivos que tenemos simplemente se almacenan en el disco, si queremos almacenar varias versiones del mismo archivo, debemos agregar un sufijo con la versi√≥n. <br><br>  <strong>Me encanta Go, as√≠ que para la velocidad escrib√≠ un sistema en Go.</strong> <br><br><h3>  C√≥mo funciona el kit de implementaci√≥n multiversion </h3><br>  Tomamos la idea de las instant√°neas de Git.  Lo simplifiqu√© un poco y te cuento c√≥mo se implementa en MDK. <br><br>  Hay dos tipos de archivos en MDK.  El primero son las <strong>cartas.</strong>  Las siguientes im√°genes est√°n marcadas en verde y corresponden a los directorios en el repositorio.  El segundo tipo es <strong>directamente los archivos,</strong> que se encuentran en el mismo lugar de siempre, pero con un sufijo en forma de versi√≥n de archivo.  Los archivos y mapas se versionan en funci√≥n de su contenido, en nuestro caso simplemente MD5. <br><br><img src="https://habrastorage.org/webt/-n/wz/1s/-nwz1str78y7hua15pfwxrrl14o.png"><br><br>  Supongamos que tenemos una jerarqu√≠a de archivos en la que el <strong>mapa ra√≠z se refiere a ciertas versiones de archivos de otros mapas</strong> y, a su vez, se refieren a otros archivos y mapas, y corrigen ciertas versiones.  Queremos cambiar alg√∫n tipo de archivo. <br><br><img src="https://habrastorage.org/webt/7d/up/_b/7dup_biyh7msgtsp7kejinaulwc.png"><br><br>  Tal vez ya haya visto una imagen similar: cambiamos el archivo en el segundo nivel de anidaci√≥n, y en el mapa correspondiente - mapa *, se actualiza la versi√≥n del archivo tres *, se modifica su contenido, se cambia la versi√≥n - y la versi√≥n tambi√©n cambia en el mapa ra√≠z.  Si cambiamos algo, siempre obtenemos un nuevo mapa ra√≠z, pero todos los archivos que no cambiamos se reutilizan. <br><br>  Los enlaces permanecen en los mismos archivos que estaban.  Esta es la idea principal de crear instant√°neas de cualquier manera, por ejemplo, en <strong>ZFS</strong> se implementa aproximadamente de la misma manera. <br><br><h3>  C√≥mo se encuentra MDK en un disco </h3><br><img src="https://habrastorage.org/webt/2r/vb/k4/2rvbk4ucmbe8upitkgczvy1dbns.png"><br><br>  Tenemos en el disco: <strong>enlace simb√≥lico al √∫ltimo mapa ra√≠z</strong> : el c√≥digo que se servir√° desde la web, varias versiones de mapas ra√≠z, varios archivos, posiblemente con diferentes versiones, y en los subdirectorios hay mapas para los directorios correspondientes. <br><br>  Preveo la pregunta: " <em>¬øY c√≥mo procesa esto la solicitud web? ¬øA qu√© archivos llegar√° el c√≥digo de usuario?</em> " <br><br>  S√≠, te enga√±√©, tambi√©n hay archivos sin versiones, porque si recibes una solicitud de index.php y no la tienes en el directorio, el sitio no funcionar√°. <br><br><img src="https://habrastorage.org/webt/-e/fl/9k/-efl9kqt3-go-tvg0qpu0lnvauo.png"><br><br>  Todos los archivos PHP tienen archivos, que llamamos <strong>stubs</strong> , porque contienen dos l√≠neas: requieren del archivo en el que se declara la funci√≥n que sabe c√≥mo trabajar con estas tarjetas, y requieren de la versi√≥n deseada del archivo. <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">require_once</span></span> <span class="hljs-string"><span class="hljs-string">"mdk.inc"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">require</span></span> mdk_resolve_path(<span class="hljs-string"><span class="hljs-string">"a.php"</span></span>);</code> </pre><br>  Esto se hace as√≠, y no se vincula a la √∫ltima versi√≥n, ya que si excluye <strong>b.php</strong> del archivo <strong>a.php</strong> sin una versi√≥n, entonces dado que require_once est√° escrito, el sistema recordar√° desde qu√© tarjeta ra√≠z comenz√≥, lo usar√° y Obtenga una versi√≥n consistente de los archivos. <br><br>  Para el resto de los archivos, solo tenemos un enlace simb√≥lico a la √∫ltima versi√≥n. <br><br><h3>  C√≥mo implementar usando MDK </h3><br>  El modelo es muy similar al git push. <br><br><ul><li>  Enviar el contenido del mapa ra√≠z. </li><li>  En el lado receptor, observamos qu√© archivos faltan.  Dado que la versi√≥n del archivo est√° determinada por el contenido, no necesitamos descargarlo por segunda vez ( <em>Yuri del futuro: excepto en el caso en que choca un MD5 acortado, que todav√≠a sucedi√≥ una vez en producci√≥n</em> ). </li><li>  Solicitar el archivo faltante. </li><li>  Pasamos al segundo punto y m√°s adelante en un c√≠rculo. </li></ul><br><h4>  Ejemplo </h4><br>  Supongamos que hay un archivo llamado "uno" en el servidor.  Env√≠ele un mapa ra√≠z. <br><br><img src="https://habrastorage.org/webt/_h/sz/h_/_hszh_rruyekpqegz6-blz5xkeq.png"><br><br>  En el mapa ra√≠z, las flechas punteadas indican enlaces a archivos que no tenemos.  Conocemos sus nombres y versiones porque est√°n en el mapa.  Los solicitamos al servidor.  El servidor env√≠a, y resulta que uno de los archivos tambi√©n es una tarjeta. <br><br><img src="https://habrastorage.org/webt/zp/--/ec/zp--ecfpdqqkgjq4zciljreqkk0.png"><br><br>  Buscamos, no tenemos un solo archivo en absoluto.  Nuevamente solicitamos los archivos que faltan.  El servidor los env√≠a.  No quedan m√°s tarjetas: el proceso de implementaci√≥n se ha completado. <br><br><img src="https://habrastorage.org/webt/mp/jk/tc/mpjktcmgb80dpamvqjkwp_ya1lg.png"><br><br>  Puede adivinar f√°cilmente qu√© suceder√° si los archivos son 150,000, pero uno ha cambiado.  Veremos en el mapa ra√≠z que falta un mapa, vamos por el nivel de anidamiento y obtengamos un archivo.  En t√©rminos de complejidad computacional, el proceso casi no es diferente de copiar archivos directamente, pero al mismo tiempo, se conserva la consistencia y las instant√°neas del c√≥digo. <br><br>  MDK no tiene inconvenientes :) Le permite <strong>implementar cambios peque√±os de forma r√°pida y at√≥mica</strong> , y los <strong>scripts funcionan durante d√≠as</strong> , porque podemos dejar todos los archivos que se implementaron en una semana.  Ocupar√°n una cantidad de espacio bastante adecuada.  Tambi√©n puede reutilizar OPCache, y la CPU no come casi nada. <br><br>  <strong>El monitoreo es bastante dif√≠cil, pero posible</strong> .  Todos los archivos est√°n versionados por contenido, y puede escribir cron, que revisar√° todos los archivos y verificar√° el nombre y el contenido.  Tambi√©n puede verificar que el mapa ra√≠z se refiere a todos los archivos, que no hay enlaces rotos en √©l.  Adem√°s, durante la implementaci√≥n se verifica la integridad. <br><br>  Puede <strong>revertir f√°cilmente los cambios</strong> , porque todas las tarjetas antiguas est√°n en su lugar.  Podemos lanzar la tarjeta, todo estar√° all√≠ de inmediato. <br><br>  Para m√≠, adem√°s del hecho de que <strong>MDK est√° escrito en Go</strong> significa que funciona r√°pidamente. <br><br>  Te enga√±√© de nuevo, todav√≠a hay contras.  Para que el proyecto funcione con el sistema, <strong>se requiere una modificaci√≥n significativa del c√≥digo,</strong> pero es m√°s simple de lo que parece a primera vista.  <strong>El sistema es muy complejo</strong> , no recomendar√≠a implementarlo si no tiene requisitos como Badoo.  Adem√°s, de todos modos, tarde o temprano el lugar termina, por lo que <strong>se requiere el recolector de basura</strong> . <br><br>  Escribimos utilidades especiales para editar archivos: reales, no stubs, por ejemplo, mdk-vim.  Usted especifica el archivo, encuentra la versi√≥n deseada y la edita. <br><br><h3>  MDK en n√∫meros </h3><br>  Tenemos 50 servidores en preparaci√≥n, en los que implementamos durante 3-5 s <strong>.</strong>  En comparaci√≥n con todo excepto rsync, es muy r√°pido.  En <strong>producci√≥n</strong> , implementamos unos <strong>2 minutos</strong> , parches peque√±os: <strong>5-10 s</strong> . <br><br>  Si por alguna raz√≥n ha perdido la carpeta completa con el c√≥digo en todos los servidores (lo que nunca deber√≠a suceder :)), el <strong>proceso de carga completa demora aproximadamente 40 minutos</strong> .  Nos sucedi√≥ una vez, aunque de noche con un m√≠nimo de tr√°fico.  Por lo tanto, nadie result√≥ herido.  El segundo archivo estuvo en un par de servidores durante 5 minutos, por lo que no vale la pena mencionarlo. <br><br>  El sistema no est√° en c√≥digo abierto, pero si est√° interesado, escriba los comentarios; puede ser presentado ( <em>Yuri del futuro: el sistema todav√≠a no est√° en c√≥digo abierto en el momento de escribir este art√≠culo</em> ). <br><br><h2>  Conclusi√≥n </h2><br>  <strong>Escucha a Rasmus, no est√° mintiendo</strong> .  En mi opini√≥n, su m√©todo rsync junto con realpath_root es el mejor, aunque los bucles tambi√©n funcionan bastante bien. <br><br>  <strong>Piensa con la cabeza</strong> : mira exactamente lo que necesita tu proyecto y no intentes crear una nave espacial donde haya suficiente "ma√≠z".  Pero si a√∫n tiene requisitos similares, entonces un sistema similar a MDK le conviene. <br><br><blockquote>  Decidimos volver a este tema, que se discuti√≥ en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">HighLoad ++</a> y, tal vez, no recibi√≥ la debida atenci√≥n, porque era solo uno de los muchos ladrillos para lograr un alto rendimiento.  Pero ahora tenemos una conferencia profesional independiente de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PHP Rusia</a> dedicada completamente a PHP.  Y aqu√≠ realmente salimos al m√°ximo.  Hablaremos a fondo sobre el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">rendimiento</a> , los <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">est√°ndares</a> y las <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">herramientas</a> , mucho sobre eso, incluida la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">refactorizaci√≥n</a> . <br><br>  Suscr√≠base al <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">canal Telegram</a> con actualizaciones del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">programa de la</a> conferencia y nos vemos el 17 de mayo. </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/449916/">https://habr.com/ru/post/449916/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../449902/index.html">Redes de TV por cable para los m√°s peque√±os. Parte 2: composici√≥n y forma de onda</a></li>
<li><a href="../449904/index.html">Creaci√≥n de una dll proxy para las verificaciones de operaci√≥n de secuestro de dll</a></li>
<li><a href="../449906/index.html">Servidor REST autodocumentado (Node.JS, TypeScript, Koa, Joi, Swagger)</a></li>
<li><a href="../449908/index.html">DDR3 o DDR4? ¬øPor qu√© ofrecemos el Dell R420 2x E5-2430 2.2Ghz 6C 128GB DDR3 2x960GB SSD 1Gbps por $ 99 en los Pa√≠ses Bajos?</a></li>
<li><a href="../449910/index.html">GitLab Shell Runner. Lanzamiento competitivo de servicios de prueba usando Docker Compose</a></li>
<li><a href="../449918/index.html">Term√≥metro infrarrojo con sensor MLX90614</a></li>
<li><a href="../449920/index.html">10 formas no est√°ndar de da√±ar el SEO al cambiar de CMS (bonificaci√≥n de +1)</a></li>
<li><a href="../449922/index.html">Test drive nanoCAD SPDS Metalwork 1.2. Parte 3</a></li>
<li><a href="../449926/index.html">El resumen de materiales frescos del mundo del front-end para la √∫ltima semana No. 362 (22-28 de abril de 2019)</a></li>
<li><a href="../449928/index.html">No solo procesamiento: c√≥mo hicimos una base de datos distribuida a partir de Kafka Streams y qu√© surgi√≥ de ella</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>