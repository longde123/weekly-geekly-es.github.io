<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💟 🐤 🤽🏿 Kurz über die Arbeit mit RabbitMQ aus Python 🧝🏾 🚴 👩🏿‍🤝‍👨🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="So kam es, dass man bei der Arbeit in MegaFon bei der Arbeit mit RabbitMQ vor denselben Aufgaben stehen muss. Es stellt sich natürlich die Frage: "Wie...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kurz über die Arbeit mit RabbitMQ aus Python</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/434510/"><p><img src="https://habrastorage.org/webt/wj/xp/kf/wjxpkfeg45pxv_pbpaiyykpj9jg.png" alt="KDPV"></p><br><p>  So kam es, dass man bei der Arbeit in MegaFon bei der Arbeit mit RabbitMQ vor denselben Aufgaben stehen muss.  Es stellt sich natürlich die Frage: "Wie kann die Implementierung solcher Aufgaben vereinfacht und automatisiert werden?" </p><br><p>  Die erste Lösung, die mir in den Sinn kommt, ist die Verwendung der HTTP-Schnittstelle. Natürlich verfügt RabbitMQ sofort über eine gute Weboberfläche und eine HTTP-API.  Trotzdem ist die Verwendung der HTTP-API nicht immer bequem und manchmal sogar unmöglich (sagen wir, Sie haben nicht genügend Zugriffsrechte, aber ich möchte wirklich eine Nachricht veröffentlichen). In solchen Zeiten ist es erforderlich, mit dem AMQP-Protokoll zu arbeiten </p><br><p>  Da auf den Freiflächen des Netzwerks keine für mich geeigneten Lösungen gefunden wurden, wurde beschlossen, eine kleine Anwendung für die Arbeit mit RabbitMQ unter Verwendung des AMQP-Protokolls zu schreiben <a name="habracut"></a>  mit der Fähigkeit, Startparameter über die Befehlszeile zu übertragen und die minimal erforderlichen Funktionen bereitzustellen, nämlich: </p><br><ul><li>  Posting </li><li>  Korrekturlesen von Nachrichten </li><li>  Erstellen und Bearbeiten grundlegender Routenelemente </li></ul><br><p>  Python wurde als einfachstes (und meiner Meinung nach schönes) Tool zur Implementierung einer solchen Aufgabe ausgewählt.  (Man kann hier streiten, aber was wird sich ändern?) </p><br><p>  Übersetzungen von offiziellen Leitfäden ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einmal</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zweimal</a> ) zu RabbitMQ werden auf dem Hub präsentiert, manchmal ist jedoch ein einfaches Beispiel aus der Praxis hilfreich.  In diesem Artikel werde ich versuchen, die grundlegenden Probleme, die bei der Arbeit mit Kaninchen über den AMQP-Kanal von Python auftreten, anhand eines Beispiels einer kleinen Anwendung zu veranschaulichen.  Die Anwendung selbst ist auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub</a> verfügbar. </p><br><h4 id="korotko-o-protokole-amqp-i-brokere-soobscheniy-rabbitmq">  Kurz über das AMQP-Protokoll und den RabbitMQ-Nachrichtenbroker </h4><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><strong>AMQP</strong></a> ist eines der häufigsten Messaging-Protokolle zwischen Komponenten eines verteilten Systems.  Das Hauptunterscheidungsmerkmal dieses Protokolls ist das Konzept der Erstellung einer Nachrichtenroute, die zwei Hauptstrukturelemente enthält: eine <strong>Warteschlange</strong> und <strong>einen Austauschpunkt</strong> .  Die Warteschlange sammelt Nachrichten, bis sie empfangen werden.  Ein Austauschpunkt ist ein Nachrichtenverteiler, der sie entweder an die gewünschte Warteschlange oder an einen anderen Austauschpunkt weiterleitet.  <strong>Verteilungsregeln (Bindungen)</strong> , anhand derer der Austauschpunkt bestimmt, wohin die Nachricht geleitet werden soll, basieren auf der Überprüfung <strong>des Routing-Schlüssels der Nachricht</strong> auf Übereinstimmung mit der angegebenen Maske.  Weitere Informationen zur Funktionsweise von AMQP finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><strong>RabbitMQ</strong></a> ist eine Open Source-Anwendung, die AMQP vollständig unterstützt und eine Reihe zusätzlicher Funktionen bietet.  Für die Arbeit mit RabbitMQ wurde eine große Anzahl von Bibliotheken in verschiedenen Programmiersprachen geschrieben, einschließlich Python. </p><br><h2 id="realizaciya-na-python">  Python-Implementierung </h2><br><p>  Sie können immer ein paar Skripte für den persönlichen Gebrauch werfen und die Probleme damit nicht kennen.  Wenn es darum geht, sie unter Kollegen zu verbreiten, wird alles komplizierter.  Jeder muss zeigen und sagen, wie und was zu starten ist, was und wo zu ändern ist, wo die neueste Version zu erhalten ist und was sich daran geändert hat ... Unwillkürlich kommen Sie zu dem Schluss, dass es einfacher ist, eine einfache Benutzeroberfläche einmal zu erarbeiten, um in Zukunft keine Zeit zu verschwenden.  Aus Gründen der Benutzerfreundlichkeit wurde beschlossen, die Anwendung in 4 Module zu unterteilen: </p><br><ol><li>  Das für die Buchung zuständige Modul </li><li>  Modul, das für das Subtrahieren von Nachrichten aus der Warteschlange verantwortlich ist </li><li>  Ein Modul, mit dem Änderungen an der Konfiguration des RabbitMQ-Brokers vorgenommen werden können </li><li>  Ein Modul, das Parameter und Methoden enthält, die früheren Modulen gemeinsam sind </li></ol><br><p>  Dieser Ansatz vereinfacht den Satz von Startparametern.  Wir haben das gewünschte Modul ausgewählt, einen seiner Betriebsmodi ausgewählt und die erforderlichen Parameter übergeben (weitere Informationen zu Betriebsmodi und Parametern in der Hilfe –help). </p><br><p>  Da die Struktur von „Kaninchen“ in MegaFon aus einer ausreichend großen Anzahl von Knoten besteht, werden die Daten für die Verbindung mit den Knoten zur Vereinfachung der Verwendung an ein Modul mit allgemeinen Parametern und Methoden <strong>rmq_common_tools.py übertragen</strong> </p><br><p>  Um an AMQP in Python zu arbeiten, verwenden wir die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pika-</a> Bibliothek. </p><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pika</code> </pre> <br><p>  Bei Verwendung dieser Bibliothek besteht die Arbeit mit RabbitMQ aus drei Hauptphasen: </p><br><ol><li>  Stellen Sie eine Verbindung her </li><li>  Erforderliche Operationen ausführen </li><li>  Verbindung schließen </li></ol><br><p>  Die erste und letzte Stufe sind für alle Module gleich und in <strong>rmq_common_tools.py</strong> implementiert </p><br><p>  So stellen Sie eine Verbindung her: </p><br><pre> <code class="python hljs">rmq_parameters = pika.URLParameters(rmq_url_connection_str) rmq_connection = pika.BlockingConnection(rmq_parameters) rmq_channel = rmq_connection.channel()</code> </pre> <br><p>  In der Pika-Bibliothek können Sie verschiedene Entwurfsoptionen für die Verbindung mit RabbitMQ verwenden.  In diesem Fall bestand die bequemste Option darin, die Parameter in Form einer URL-Zeichenfolge im folgenden Format zu übergeben: </p><br><pre> <code class="python hljs"><span class="hljs-string"><span class="hljs-string">'amqp://rabbit_user:rabbit_password@host:port/vhost'</span></span></code> </pre> <br><p>  So schließen Sie eine Verbindung: </p><br><pre> <code class="python hljs">rmq_connection.close()</code> </pre> <br><h4 id="publikaciya-soobscheniy">  Posting </h4><br><p>  Das Veröffentlichen einer Nachricht ist wahrscheinlich die einfachste, aber gleichzeitig die beliebteste Operation bei der Arbeit mit Kaninchen. </p><br><p>  In <strong>rmq_publish.py</strong> kompilierte Post-Publishing-Tools </p><br><p>  Verwenden Sie die Methode, um eine Nachricht zu veröffentlichen </p><br><pre> <code class="python hljs">rmq_channel.basic_publish(exchange = params.exch, routing_key = params.r_key, body = text)</code> </pre> <br><p>  wo: <br>  <strong>Austausch</strong> - Der Name des Austauschpunkts, an dem die Nachricht veröffentlicht wird <br>  <strong>routing_key</strong> - Routing-Schlüssel, mit dem die Nachricht veröffentlicht wird <br>  <strong>body</strong> - Nachrichtentext </p><br><p>  <strong>rmq_publish.py</strong> unterstützt zwei Nachrichteneingabemodi für die Veröffentlichung: </p><br><ol><li>  Die Nachricht wird als Parameter über die Befehlszeile (from_console) eingegeben. </li><li>  Die Nachricht wird aus der Datei gelesen (from_file) </li></ol><br><p>  Der zweite Modus ist meiner Meinung nach bequemer, wenn Sie mit großen Nachrichten oder Nachrichtenarrays arbeiten.  Mit der ersten Option können Sie eine Nachricht ohne zusätzliche Dateien senden. Dies ist praktisch, wenn Sie das Modul in andere Szenarien integrieren. </p><br><h4 id="poluchenie-soobscheniy">  Nachrichten empfangen </h4><br><p>  Das Problem des Empfangs von Nachrichten ist nicht mehr so ​​trivial wie das Veröffentlichen.  Wenn Sie Nachrichten lesen möchten, müssen Sie Folgendes verstehen: </p><br><ul><li>  Nachdem der Empfang der Nachricht bestätigt wurde, wird sie aus der Warteschlange entfernt.  Wenn wir also die Nachrichten aus der "Battle" -Linie lesen, "wählen" wir sie vom Hauptverbraucher aus.  Wenn wir den Nachrichtenfluss nicht verlieren möchten, sondern nur verstehen möchten, welche Nachrichten sich im "Kaninchen" bewegen, besteht die logischste Option darin, eine separate "Protokollierungs" -Warteschlange oder, wie sie auch genannt wird, "Trap-Warteschlange" zu erstellen. </li><li>  Gelesene Nachrichten erfordern in der Regel eine weitere Verarbeitung oder Analyse. Dies bedeutet, dass sie irgendwo gespeichert werden müssen, wenn eine Echtzeitverarbeitung nicht möglich oder nicht erforderlich ist. </li></ul><br><p>  Nachrichtenleser in der Datei <strong>rmq_consume.py</strong> implementiert </p><br><p>  Es stehen zwei Betriebsarten zur Verfügung: </p><br><ol><li>  Lesen Sie Nachrichten aus einer vorhandenen Warteschlange </li><li>  Erstellen einer Zeitwarteschlange und einer Route zum Lesen von Nachrichten aus dieser Warteschlange </li></ol><br><p>  Die Frage des Erstellens einer Warteschlange und von Routen wird unten behandelt. </p><br><p>  Das direkte Korrekturlesen wird wie folgt implementiert: </p><br><pre> <code class="python hljs">channel.basic_consume(on_message, queue=params.queue) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: channel.start_consuming() <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> KeyboardInterrupt: channel.stop_consuming() <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> Exception: channel.stop_consuming() rmq_tools.console_log(<span class="hljs-string"><span class="hljs-string">":\n"</span></span>, traceback.format_exc())</code> </pre> <br><p>  wo <br>  <strong>on_message</strong> - Nachrichtenbehandlungsprozedur <br>  <strong>params.queue</strong> - Der Name der Warteschlange, von der die <strong>Subtraktion durchgeführt</strong> wird </p><br><p>  Der Nachrichtenhandler muss eine Operation für die gelesene Nachricht ausführen und die Nachrichtenübermittlung bestätigen (oder nicht bestätigen, falls erforderlich). </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_message</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(channel, method_frame, header_frame, body)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> all_cnt, lim <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> all_cnt &gt;= lim: rmq_tools.console_log(<span class="hljs-string"><span class="hljs-string">'   .'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> KeyboardInterrupt body_str = body.decode(<span class="hljs-string"><span class="hljs-string">"utf-8"</span></span>)[:<span class="hljs-number"><span class="hljs-number">4000</span></span>] rk = method_frame.routing_key rmq_params.file.write(rk + <span class="hljs-string"><span class="hljs-string">'\n'</span></span>) rmq_params.file.write(body_str + <span class="hljs-string"><span class="hljs-string">'\n\n'</span></span>) all_cnt = all_cnt + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (lim != <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> (rmq_params.file == sys.stdout): sys.stdout.write(<span class="hljs-string"><span class="hljs-string">f'[</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{rmq_tools.time_now()}</span></span></span><span class="hljs-string">] - </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{all_cnt}</span></span></span><span class="hljs-string"> of </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{lim}</span></span></span><span class="hljs-string"> messages consumed.\r'</span></span>) channel.basic_ack(delivery_tag=method_frame.delivery_tag)</code> </pre> <br><p>  wo <br>  <strong>all_cnt</strong> - globaler Zähler <br>  <strong>lim</strong> - Die Anzahl der zu lesenden Nachrichten </p><br><p>  Bei einer solchen Implementierung des Handlers wird eine bestimmte Anzahl von Nachrichten subtrahiert und Informationen über den Fortschritt der Subtraktion werden an die Konsole ausgegeben, wenn die Aufzeichnung in einer Datei erfolgt. </p><br><p>  Es ist auch möglich, gelesene Nachrichten in die Datenbank zu schreiben.  In der aktuellen Implementierung wird eine solche Gelegenheit nicht angeboten, aber es ist nicht schwierig, sie hinzuzufügen. </p><br><div class="spoiler">  <b class="spoiler_title">Datensatz in einer DB</b> <div class="spoiler_text"><p>  Wir werden ein Beispiel für das Schreiben von Nachrichten in die Datenbank für die Oracle-Datenbank und die <strong>cx_oracle-</strong> Bibliothek betrachten. </p><br><p>  Stellen Sie eine Verbindung zur Datenbank her </p><br><pre> <code class="python hljs">ora_adress = <span class="hljs-string"><span class="hljs-string">'host:port/dbSID'</span></span> ora_creds = <span class="hljs-string"><span class="hljs-string">'user/pass'</span></span> connection_ora = cx_Oracle.connect(ora_creds + <span class="hljs-string"><span class="hljs-string">'@'</span></span> + ora_address) ora_cursor = connection_ora.cursor()</code> </pre> <br><p>  <strong>Fügen Sie im</strong> Handler <strong>on_message</strong> hinzu </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">global</span></span> cnt, commit_int insert_rec = <span class="hljs-string"><span class="hljs-string">'insert into '</span></span> + tab_name + <span class="hljs-string"><span class="hljs-string">'(routing_key, text) values (:rkey, :text)'</span></span> ora_cursor.execute(insert_rec, text = body_str, rkey = rk) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> cnt &gt; commit_int : ora_cursor.execute(<span class="hljs-string"><span class="hljs-string">'commit'</span></span>) cnt = <span class="hljs-number"><span class="hljs-number">1</span></span> cnt = cnt + <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br><p>  wo <br>  <strong>cnt</strong> ist ein weiterer Zähler <br>  <strong>commit_int</strong> - Die Anzahl der Einfügungen in die Datenbank, nach denen "commit" ausgeführt werden muss.  Das Vorhandensein eines solchen Parameters ist auf den Wunsch zurückzuführen, die Belastung der Datenbank zu verringern.  Die Installation ist jedoch nicht besonders groß, weil  Im Falle eines Fehlers besteht die Möglichkeit, dass nach dem letzten erfolgreichen Festschreiben gelesene Nachrichten verloren gehen. </p><br><p>  Und wie erwartet machen wir am Ende der Arbeit das endgültige Commit und schließen die Verbindung </p><br><pre> <code class="python hljs">ora_cursor.execute(<span class="hljs-string"><span class="hljs-string">'commit'</span></span>) connection_ora.close()</code> </pre> <br><p>  So etwas liest Nachrichten.  Wenn Sie die Beschränkung für die Anzahl der gelesenen Nachrichten aufheben, können Sie einen Hintergrundprozess zum kontinuierlichen Lesen von Nachrichten vom "Kaninchen" durchführen. </p></div></div><br><h4 id="konfigurirovanie">  Konfiguration </h4><br><p>  Trotz der Tatsache, dass das AMQP-Protokoll hauptsächlich zum Veröffentlichen und Lesen von Nachrichten vorgesehen ist, können Sie auch einfache Manipulationen bei der Konfiguration von Routen durchführen (wir sprechen nicht über das Konfigurieren von Netzwerkverbindungen und anderen RabbitMQ-Einstellungen als Anwendung). </p><br><p>  Die Hauptkonfigurationsvorgänge sind: </p><br><ol><li>  Erstellen einer Warteschlange oder eines Austauschpunkts </li><li>  Weiterleitungsregel erstellen (verbindlich) </li><li>  Löschen einer Warteschlange oder eines Austauschpunkts </li><li>  Weiterleitungsregel entfernen (verbindlich) </li><li>  Löschen der Warteschlange </li></ol><br><p>  Da es für jeden von ihnen eine vorgefertigte Prozedur in der Pika-Bibliothek gibt, werden sie zur Vereinfachung des Starts einfach in der Datei <strong>rmq_setup.py</strong> kompiliert.  Als nächstes listen wir die Prozeduren aus der Pika-Bibliothek mit einigen Kommentaren zu den Parametern auf. </p><br><p>  <strong>Eine Warteschlange erstellen</strong> </p><br><pre> <code class="python hljs">rmq_channel.queue_declare(queue=params.queue, durable = params.durable)</code> </pre> <br><p>  hier ist alles einfach <br>  <strong>Warteschlange</strong> - Name der zu erstellenden Warteschlange <br>  <strong>dauerhaft</strong> - ein logischer Parameter, ein Wert von True bedeutet, dass die Warteschlange beim Neustart des Kaninchens weiterhin besteht.  Bei False wird die Warteschlange beim Neustart gelöscht.  Die zweite Option wird normalerweise für temporäre Warteschlangen verwendet, die in Zukunft garantiert nicht mehr benötigt werden. </p><br><p>  <strong>Austauschpunkt erstellen (Austausch)</strong> </p><br><pre> <code class="python hljs">rmq_channel.exchange_declare(exchange=params.exch, exchange_type = params.type, durable = params.durable)</code> </pre> <br><p>  hier entsteht ein neuer Parameter <strong>exchange_type</strong> - die Art des Austauschpunktes.  Über welche Arten von Austauschpunkten lesen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br>  <strong>Austausch</strong> - Name des erstellten Austauschpunkts </p><br><p>  <strong>Löschen einer Warteschlange oder eines Austauschpunkts</strong> </p><br><pre> <code class="python hljs">rmq_channel.queue_delete(queue=params.queue) rmq_channel.exchange_delete(exchange=params.exch)</code> </pre> <br><p>  <strong>Weiterleitungsregel erstellen (verbindlich)</strong> </p><br><pre> <code class="python hljs">rmq_channel.queue_bind(exchange=params.exch, queue=params.queue, routing_key=params.r_key)</code> </pre> <br><p>  <strong>Austausch</strong> - Der Name des Austauschpunkts, von dem aus die Übertragung erfolgt <br>  <strong>Warteschlange</strong> - Der Name der Warteschlange, an die weitergeleitet werden soll <br>  <strong>routing_key</strong> - Maske des Routing-Schlüssels, der für die Weiterleitung verwendet wird. </p><br><p>  Folgende Einträge sind gültig: </p><br><ul><li>  <strong>rk.my_key. *</strong> - In dieser Maske bedeutet ein Sternchen einen nicht leeren Zeichensatz.  Mit anderen Worten, eine solche Maske überspringt jeden Schlüssel vom Typ <strong>rk.my_key.</strong>  + etwas anderes, aber den Schlüssel <strong>rk.my_key</strong> nicht verpassen </li><li>  <strong>rk.my_key. #</strong> - Diese Maske überspringt alles als vorherige + Taste <strong>rk.my_key</strong> </li></ul><br><p>  <strong>Weiterleitungsregel entfernen (verbindlich)</strong> </p><br><pre> <code class="python hljs">rmq_channel.queue_unbind(exchange=params.exch, queue=params.queue, routing_key=params.r_key)</code> </pre> <br><p>  Alles ähnelt dem Erstellen einer Weiterleitungsregel. </p><br><p>  <strong>Löschen der Warteschlange</strong> </p><br><pre> <code class="python hljs">rmq_channel.queue_purge(queue=params.queue)</code> </pre> <br><p>  <strong>Warteschlange</strong> - Der Name der Warteschlange, die gelöscht werden soll </p><br><div class="spoiler">  <b class="spoiler_title">Informationen zur Verwendung der Befehlszeilenschnittstelle in Python-Anwendungen</b> <div class="spoiler_text"><p>  Startoptionen erleichtern das Leben erheblich.  Um den Code nicht vor jedem Start zu bearbeiten, ist es logisch, einen Mechanismus zum Übergeben von Parametern beim Start bereitzustellen.  Zu diesem <strong>Zweck wurde</strong> die <strong>Argparse-</strong> Bibliothek ausgewählt.  Ich werde nicht näher auf die Feinheiten seiner Verwendung eingehen, es gibt genügend Anleitungen zu diesem Thema ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eins</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zwei</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">drei</a> ).  Ich stelle nur fest, dass dieses Tool mir geholfen hat, den Prozess der Verwendung der Anwendung erheblich zu vereinfachen (wenn Sie es so nennen können).  Selbst wenn Sie eine einfache Folge von Befehlen geworfen und in eine ähnliche Oberfläche eingebunden haben, erhalten Sie ein vollwertiges und benutzerfreundliches Tool. </p></div></div><br><h2 id="primenenie-v-povsednevnoy-zhizni-chto-prigodilos-bolshe-vsego">  Anwendung im Alltag.  Was sich am meisten als nützlich erwiesen hat. </h2><br><p>  Nun ein kleiner Eindruck über den Einsatz von AMQP im Alltag. </p><br><p>  Die am häufigsten nachgefragte Funktion war die Veröffentlichung der Nachricht.  Die Zugriffsrechte eines bestimmten Benutzers erlauben nicht immer die Verwendung einer Webschnittstelle, obwohl es manchmal einfach erforderlich ist, einen bestimmten Dienst zu testen.  Hier werden AMQP und die Autorisierung im Namen des Dienstes, der diesen Kanal verwendet, an die Hilfe weitergegeben. </p><br><p>  Am zweitbeliebtesten war die Möglichkeit, Nachrichten aus der Zeitwarteschlange zu lesen.  Diese Funktion ist nützlich, um neue Routen und Nachrichtenflüsse zu konfigurieren und Unfälle zu vermeiden. </p><br><p>  Andere Möglichkeiten fanden auch Anwendung in verschiedenen Aufgaben. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de434510/">https://habr.com/ru/post/de434510/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de434500/index.html">Betrüger namens Jeanne oder Watch Your Ears</a></li>
<li><a href="../de434502/index.html">Wie "Digitale Archäologen" eine verlorene Version von SimCity für NES entdeckten und wiederherstellten</a></li>
<li><a href="../de434504/index.html">20 Jahre Fast Reports "Das Produkt wurde in einem Atemzug erstellt, nur hoch ..."</a></li>
<li><a href="../de434506/index.html">Erleben Sie die Veröffentlichung einer Videobearbeitungsanwendung im Microsoft Store</a></li>
<li><a href="../de434508/index.html">Die dunkle Seite des Suchmaschinenmarketings: Wie und warum Google unsere persönlichen Daten sammelt</a></li>
<li><a href="../de434512/index.html">Corporate Corporate</a></li>
<li><a href="../de434514/index.html">"Geheimnisse" DPAPI oder DPAPI für Pentester</a></li>
<li><a href="../de434516/index.html">Eine einfache Möglichkeit, mit Ihren Karrierezielen umzugehen.</a></li>
<li><a href="../de434518/index.html">Applaus und Prost: sorgfältig kontrolliertes Drama in Apple Stores</a></li>
<li><a href="../de434522/index.html">Aufgabenbegründungsmuster und Antimuster</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>