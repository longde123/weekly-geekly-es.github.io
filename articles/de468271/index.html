<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßùüèæ üì¶ üíÖüèº Tests vs. Typen - Rostversion üñêüèæ üíÖüèº üë®üèΩ‚ÄçüöÄ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vor einigen Tagen hat 0xd34df00d die √úbersetzung des Artikels ver√∂ffentlicht , in der die m√∂glichen Informationen zu bestimmten Funktionen beschrieben...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tests vs. Typen - Rostversion</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/468271/"><p> Vor einigen Tagen hat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">0xd34df00d</a> die √úbersetzung des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikels ver√∂ffentlicht</a> , in der die m√∂glichen Informationen zu bestimmten Funktionen beschrieben werden, wenn wir sie als "Black Box" verwenden und nicht versuchen, ihre Implementierung zu lesen.  Nat√ºrlich sind diese Informationen von Sprache zu Sprache sehr unterschiedlich.  Im urspr√ºnglichen Artikel wurden vier F√§lle ber√ºcksichtigt: </p><br><ul><li>  Python - dynamische Typisierung, fast keine Informationen aus der Signatur, einige Hinweise werden durch die Tests gewonnen; </li><li>  C - schwache statische Typisierung, etwas mehr Information; </li><li>  Haskell - starke statische Typisierung, standardm√§√üig mit reinen Funktionen, viel mehr Informationen; </li><li>  Idris-abh√§ngige Eingabe, Compiler kann die Funktionskorrektheit beweisen. </li></ul><br><p>  "Hier ist C und da ist Haskell, und was ist mit Rust?"  - Dies war die erste Frage in der folgenden Diskussion.  Die Antwort ist hier. </p><a name="habracut"></a><br><p>  Erinnern wir uns zun√§chst an die Aufgabe: </p><br><blockquote>  Geben Sie bei einer Liste von Werten und einem Wert den Index des Werts in der Liste zur√ºck oder geben Sie an, dass er nicht in der Liste vorhanden ist. </blockquote><p>  Wenn jemand nicht alles lesen m√∂chte, werden die Codebeispiele auf dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rust-Spielplatz</a> bereitgestellt. <br>  Ansonsten fangen wir an! </p><br><h4 id="simple-search">  Einfache Suche </h4><br><p>  Der erste Ansatz wird die fast naive Signatur sein, die sich vom C-Code nur in einigen idiomatischen Elementen unterscheidet: </p><br><pre><code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(x: &amp;[<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>], y: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; { <span class="hljs-comment"><span class="hljs-comment">// Implementation elided }</span></span></code> </pre> <br><p>  Was wissen wir √ºber diese Funktion?  Nun, in der Tat - nicht sehr viel.  Nat√ºrlich ist <code>Option&lt;usize&gt;</code> als R√ºckgabewert eine gro√üe Verbesserung gegen√ºber dem, was von C bereitgestellt wird, aber es gibt keine Informationen √ºber die Funktionssemantik.  Insbesondere haben wir keine Garantie daf√ºr, dass die Nebenwirkungen fehlen, und keine M√∂glichkeit, das gew√ºnschte Verhalten irgendwie zu √ºberpr√ºfen. </p><br><p>  Kann ein Test dies verbessern?  Schau hier: </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[test]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(foo(&amp;[<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>], <span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(foo(&amp;[<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>], <span class="hljs-number"><span class="hljs-number">4</span></span>), <span class="hljs-literal"><span class="hljs-literal">None</span></span>); }</code> </pre> <br><p>  Nichts weiter, wie es scheint - all diese √úberpr√ºfungen k√∂nnen in Python genau gleich sein (und in Erwartung werden Tests f√ºr den gesamten Artikel wenig hilfreich sein). </p><br><h4 id="use-the-generics-luke">  Benutze die Generika, Luke! </h4><br><p>  Aber ist es gut, dass wir nur vorzeichenbehaftete 32-Bit-Zahlen verwenden m√ºssen?  Behebung: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>&lt;El&gt;(x: &amp;[El], y: El) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> El: <span class="hljs-built_in"><span class="hljs-built_in">PartialEq</span></span>, { <span class="hljs-comment"><span class="hljs-comment">// Implementation elided }</span></span></code> </pre> <br><p>  Nun, das ist etwas!  Jetzt k√∂nnen wir jede Scheibe nehmen, die aus Elementen eines vergleichbaren Typs besteht.  Expliziter Polymorphismus ist fast immer besser als implizit (Hallo, Python) und fast immer besser als gar kein Polymorphismus (Hallo, C), oder? </p><br><p>  Diese Funktion kann diesen Test jedoch unerwartet bestehen: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">refl</span></span></span></span>&lt;El: <span class="hljs-built_in"><span class="hljs-built_in">PartialEq</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">Copy</span></span>&gt;(el: El) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; { foo(&amp;[el], el) <span class="hljs-comment"><span class="hljs-comment">// should always return Some(0), right? } #[test] fn dont_find_nan() { assert_eq!(refl(std::f64::NAN), None); }</span></span></code> </pre> <br><p>  Dies deutet auf den einen fehlenden Punkt hin, da die Spezifikation m√∂chte, dass die <code>refl</code> Funktion tats√§chlich immer <code>Some(0)</code> <code>refl</code> .  Dies ist nat√ºrlich alles auf das spezifische Verhalten der teilweise √§quivalenten Typen im Allgemeinen und der Floats im Besonderen zur√ºckzuf√ºhren. <br>  Vielleicht wollen wir dieses Problem loswerden?  Also werden wir einfach die Grenze f√ºr den El-Typ versch√§rfen: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>&lt;El&gt;(x: &amp;[El], y: El) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> El: <span class="hljs-built_in"><span class="hljs-built_in">Eq</span></span>, { <span class="hljs-comment"><span class="hljs-comment">// Implementation elided }</span></span></code> </pre> <br><p>  Jetzt m√ºssen nicht nur die Typen vergleichbar sein, sondern auch die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√Ñquivalenzen</a> .  Dies schr√§nkt nat√ºrlich die m√∂glichen Typen ein, die mit dieser Funktion verwendet werden k√∂nnen, aber jetzt deuten sowohl die Signatur als auch die Tests darauf hin, dass das Verhalten in die Spezifikation passen sollte. </p><br><div class="spoiler">  <b class="spoiler_title">Randnotiz: Wir wollen generischer gehen!</b> <div class="spoiler_text"><p>  Dieser Fall hat nichts mit der urspr√ºnglichen Aufgabe zu tun, aber dies scheint ein gutes Beispiel f√ºr das bekannte Prinzip zu sein: "Sei liberal in dem, was du akzeptierst, sei konservativ in dem, was du tust".  Mit anderen Worten: Wenn Sie den Eingabetyp verallgemeinern k√∂nnen, ohne die Ergonomie und Leistung zu beeintr√§chtigen, sollten Sie dies wahrscheinlich tun. </p><br><p>  Jetzt werden wir dies √ºberpr√ºfen: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, El: <span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;(x: <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> <span class="hljs-built_in"><span class="hljs-built_in">IntoIterator</span></span>&lt;Item = &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> El&gt;, y: El) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> El: <span class="hljs-built_in"><span class="hljs-built_in">Eq</span></span>, { <span class="hljs-comment"><span class="hljs-comment">// Implementation elided }</span></span></code> </pre> <br><p>  Was wissen wir jetzt √ºber diese Funktion?  Im Allgemeinen trotzdem, aber jetzt akzeptiert es nicht nur das Slice oder die Liste, sondern auch ein beliebiges Objekt, das die Verweise auf den Typ El liefern kann, so dass wir es mit dem fraglichen Objekt vergleichen.  Wenn ich mich beispielsweise nicht irre, w√§re dieser Typ in Java <code>Iterable&lt;Comparable&gt;</code> . </p></div></div><br><h4 id="like-before-but-a-bit-more-strict">  Wie zuvor, aber etwas strenger </h4><br><p>  Aber jetzt brauchen wir vielleicht noch mehr Garantien.  Oder wir m√∂chten am Stack arbeiten (und k√∂nnen daher <code>Vec</code> nicht verwenden), m√ºssen aber unseren Code f√ºr jede m√∂gliche Arraygr√∂√üe verallgemeinern.  Oder wir m√∂chten die f√ºr jede konkrete Arraygr√∂√üe optimierte Funktion kompilieren. </p><br><p>  Wie auch immer, wir brauchen ein generisches Array - und es gibt eine Kiste in Rust, die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">genau das</a> bietet. </p><br><p>  Hier ist unser Code: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> generic_array::{GenericArray, ArrayLength}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>&lt;El, Size&gt;(x: GenericArray&lt;El, Size&gt;, y: El) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> El: <span class="hljs-built_in"><span class="hljs-built_in">Eq</span></span>, Size: ArrayLength&lt;El&gt;, { <span class="hljs-comment"><span class="hljs-comment">// Implementation elided }</span></span></code> </pre> <br><p>  Was wissen wir daraus?  Wir wissen, dass die Funktion das Array einer bestimmten Gr√∂√üe annimmt, die sich in seinem Typ widerspiegelt (und f√ºr jede dieser Gr√∂√üen unabh√§ngig kompiliert wird).  Im Moment ist dies fast nichts - die gleichen Garantien wurden zur Laufzeit von der vorherigen Implementierung bereitgestellt. </p><br><p>  Aber wir k√∂nnen weiter kommen. </p><br><h4 id="type-level-arithmetic">  Arithmetik auf Typebene </h4><br><p>  Der erste Artikel erw√§hnte mehrere Garantien von Idris, die aus anderen Sprachen nicht zu bekommen waren.  Einer von ihnen - und wahrscheinlich der einfachste, da er keine Beweise oder Tests enth√§lt, sondern nur eine kleine √Ñnderung der Typen - gibt an, dass der R√ºckgabewert, wenn er nicht <code>Nothing</code> , immer kleiner als die Listenl√§nge ist. </p><br><p>  Sieht so aus, als w√§ren die abh√§ngigen Typen - oder so √§hnlich - f√ºr eine solche Garantie notwendig, und wir k√∂nnen nicht dasselbe von Rust bekommen, oder? </p><br><p>  Treffen Sie den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Typenum</a> .  Mit ihm k√∂nnen wir unsere Funktion folgenderma√üen schreiben: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> generic_array::{ArrayLength, GenericArray}; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> typenum::{IsLess, Unsigned, B1}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UnsignedLessThan</span></span></span></span>&lt;T&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">as_usize</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;Less, More&gt; UnsignedLessThan&lt;More&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Less <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> Less: IsLess&lt;More, Output = B1&gt;, Less: Unsigned, { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">as_usize</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> { &lt;<span class="hljs-keyword"><span class="hljs-keyword">Self</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Unsigned&gt;::USIZE } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>&lt;El, Size&gt;(x: GenericArray&lt;El, Size&gt;, y: El) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;dyn UnsignedLessThan&lt;Size&gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> El: <span class="hljs-built_in"><span class="hljs-built_in">Eq</span></span>, Size: ArrayLength&lt;El&gt;, { <span class="hljs-comment"><span class="hljs-comment">// Implementation elided }</span></span></code> </pre> <br><p>  "Was ist das f√ºr schwarze Magie ?!"  - Du k√∂nntest fragen.  Und Sie haben Recht: Typenum <em>ist</em> eine schwarze Magie, und alle Versuche, es zu verwenden, sind noch magischer. <br><br>  Diese Funktionssignatur ist jedoch ziemlich konkret. </p><br><ul><li>  Es braucht ein Array von El's mit der L√§nge Size und ein weiteres El. </li><li>  Es gibt eine Option zur√ºck, die, wenn es sich um Some handelt, <br><ul><li>  enth√§lt ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Merkmalsobjekt</a> , das auf dem Merkmal <code>UnsignedLessThan&lt;Size&gt;</code> basiert; </li><li>  und <code>UnsignedLessThan&lt;T&gt;</code> wird √ºberall dort implementiert, wo <code>Unsigned</code> und <code>IsLess&lt;T&gt;</code> implementiert sind und <code>IsLess&lt;T&gt;</code> B1 zur√ºckgibt, d. <code>IsLess&lt;T&gt;</code> . true. </li></ul></li></ul><br><p>  Mit anderen Worten, diese Funktion gibt <em>garantiert</em> eine vorzeichenlose Ganzzahl zur√ºck, die <em>kleiner als</em> die Arraygr√∂√üe ist (genau genommen gibt sie das <code>as_usize</code> zur√ºck, aber wir k√∂nnen die Methode <code>as_usize</code> aufrufen und die Ganzzahl <code>as_usize</code> ). </p><br><p>  Ich kann jetzt von zwei wichtigen Vorbehalten sprechen: </p><br><ol><li>  Wir k√∂nnen einen Leistungsverlust bekommen.  Wenn sich diese Funktion irgendwie auf dem "hei√üen" Pfad des Programms befindet, k√∂nnen die konstanten dynamischen Versendungen den gesamten Prozess verlangsamen.  Dies ist zwar kein gro√ües Problem, aber es gibt noch ein anderes: </li><li>  Damit diese Funktion kompiliert werden kann, m√ºssen wir entweder den Beweis ihrer Richtigkeit direkt in sie schreiben oder das Typsystem mit etwas <code>unsafe</code> .  Ersteres ist ziemlich komplex und letzteres betr√ºgt nur. </li></ol><br><h4 id="conclusion">  Fazit </h4><br><p>  In der Praxis verwenden wir nat√ºrlich im Allgemeinen entweder den zweiten Ansatz (mit generischem Slice) oder den Ansatz im Spoiler (mit Iterator).  Alle nachfolgenden Diskussionen sind wahrscheinlich nicht von praktischem Interesse und dienen hier nur als √úbung mit Typen. </p><br><p>  Wie auch immer, die Tatsache, dass das Rust-Typ-System die Funktion des st√§rkeren Idris-Typ-Systems emulieren kann, ist f√ºr mich selbst ziemlich beeindruckend. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de468271/">https://habr.com/ru/post/de468271/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de468259/index.html">F√ºnf H√∂hepunkte des Helmgipfels 2019 in Amsterdam</a></li>
<li><a href="../de468261/index.html">Ein neues Spiel mit einer alten Atmosph√§re auf Three.js</a></li>
<li><a href="../de468263/index.html">Begr√º√üen Sie das neue Visual Studio-Terminal</a></li>
<li><a href="../de468265/index.html">Aus Vim S√º√üigkeiten machen</a></li>
<li><a href="../de468267/index.html">St√§rkung der UseCase-Methodik im Buch Alistair Coburn</a></li>
<li><a href="../de468277/index.html">Ist die Arbeit des Programmierers schwierig - eine Sicht aus Sicht der Psychophysiologie</a></li>
<li><a href="../de468285/index.html">Top-Softwareentwicklungsunternehmen f√ºr Unternehmen und Startups</a></li>
<li><a href="../de468287/index.html">C # -Attribute: √úber alle Aspekte</a></li>
<li><a href="../de468289/index.html">AM</a></li>
<li><a href="../de468291/index.html">Synopse aus Mark Gaulstons Buch "Ich kann dich durchh√∂ren"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>