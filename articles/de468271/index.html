<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧝🏾 📦 💅🏼 Tests vs. Typen - Rostversion 🖐🏾 💅🏼 👨🏽‍🚀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vor einigen Tagen hat 0xd34df00d die Übersetzung des Artikels veröffentlicht , in der die möglichen Informationen zu bestimmten Funktionen beschrieben...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tests vs. Typen - Rostversion</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/468271/"><p> Vor einigen Tagen hat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">0xd34df00d</a> die Übersetzung des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikels veröffentlicht</a> , in der die möglichen Informationen zu bestimmten Funktionen beschrieben werden, wenn wir sie als "Black Box" verwenden und nicht versuchen, ihre Implementierung zu lesen.  Natürlich sind diese Informationen von Sprache zu Sprache sehr unterschiedlich.  Im ursprünglichen Artikel wurden vier Fälle berücksichtigt: </p><br><ul><li>  Python - dynamische Typisierung, fast keine Informationen aus der Signatur, einige Hinweise werden durch die Tests gewonnen; </li><li>  C - schwache statische Typisierung, etwas mehr Information; </li><li>  Haskell - starke statische Typisierung, standardmäßig mit reinen Funktionen, viel mehr Informationen; </li><li>  Idris-abhängige Eingabe, Compiler kann die Funktionskorrektheit beweisen. </li></ul><br><p>  "Hier ist C und da ist Haskell, und was ist mit Rust?"  - Dies war die erste Frage in der folgenden Diskussion.  Die Antwort ist hier. </p><a name="habracut"></a><br><p>  Erinnern wir uns zunächst an die Aufgabe: </p><br><blockquote>  Geben Sie bei einer Liste von Werten und einem Wert den Index des Werts in der Liste zurück oder geben Sie an, dass er nicht in der Liste vorhanden ist. </blockquote><p>  Wenn jemand nicht alles lesen möchte, werden die Codebeispiele auf dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rust-Spielplatz</a> bereitgestellt. <br>  Ansonsten fangen wir an! </p><br><h4 id="simple-search">  Einfache Suche </h4><br><p>  Der erste Ansatz wird die fast naive Signatur sein, die sich vom C-Code nur in einigen idiomatischen Elementen unterscheidet: </p><br><pre><code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(x: &amp;[<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>], y: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; { <span class="hljs-comment"><span class="hljs-comment">// Implementation elided }</span></span></code> </pre> <br><p>  Was wissen wir über diese Funktion?  Nun, in der Tat - nicht sehr viel.  Natürlich ist <code>Option&lt;usize&gt;</code> als Rückgabewert eine große Verbesserung gegenüber dem, was von C bereitgestellt wird, aber es gibt keine Informationen über die Funktionssemantik.  Insbesondere haben wir keine Garantie dafür, dass die Nebenwirkungen fehlen, und keine Möglichkeit, das gewünschte Verhalten irgendwie zu überprüfen. </p><br><p>  Kann ein Test dies verbessern?  Schau hier: </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[test]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(foo(&amp;[<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>], <span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(foo(&amp;[<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>], <span class="hljs-number"><span class="hljs-number">4</span></span>), <span class="hljs-literal"><span class="hljs-literal">None</span></span>); }</code> </pre> <br><p>  Nichts weiter, wie es scheint - all diese Überprüfungen können in Python genau gleich sein (und in Erwartung werden Tests für den gesamten Artikel wenig hilfreich sein). </p><br><h4 id="use-the-generics-luke">  Benutze die Generika, Luke! </h4><br><p>  Aber ist es gut, dass wir nur vorzeichenbehaftete 32-Bit-Zahlen verwenden müssen?  Behebung: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>&lt;El&gt;(x: &amp;[El], y: El) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> El: <span class="hljs-built_in"><span class="hljs-built_in">PartialEq</span></span>, { <span class="hljs-comment"><span class="hljs-comment">// Implementation elided }</span></span></code> </pre> <br><p>  Nun, das ist etwas!  Jetzt können wir jede Scheibe nehmen, die aus Elementen eines vergleichbaren Typs besteht.  Expliziter Polymorphismus ist fast immer besser als implizit (Hallo, Python) und fast immer besser als gar kein Polymorphismus (Hallo, C), oder? </p><br><p>  Diese Funktion kann diesen Test jedoch unerwartet bestehen: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">refl</span></span></span></span>&lt;El: <span class="hljs-built_in"><span class="hljs-built_in">PartialEq</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">Copy</span></span>&gt;(el: El) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; { foo(&amp;[el], el) <span class="hljs-comment"><span class="hljs-comment">// should always return Some(0), right? } #[test] fn dont_find_nan() { assert_eq!(refl(std::f64::NAN), None); }</span></span></code> </pre> <br><p>  Dies deutet auf den einen fehlenden Punkt hin, da die Spezifikation möchte, dass die <code>refl</code> Funktion tatsächlich immer <code>Some(0)</code> <code>refl</code> .  Dies ist natürlich alles auf das spezifische Verhalten der teilweise äquivalenten Typen im Allgemeinen und der Floats im Besonderen zurückzuführen. <br>  Vielleicht wollen wir dieses Problem loswerden?  Also werden wir einfach die Grenze für den El-Typ verschärfen: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>&lt;El&gt;(x: &amp;[El], y: El) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> El: <span class="hljs-built_in"><span class="hljs-built_in">Eq</span></span>, { <span class="hljs-comment"><span class="hljs-comment">// Implementation elided }</span></span></code> </pre> <br><p>  Jetzt müssen nicht nur die Typen vergleichbar sein, sondern auch die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Äquivalenzen</a> .  Dies schränkt natürlich die möglichen Typen ein, die mit dieser Funktion verwendet werden können, aber jetzt deuten sowohl die Signatur als auch die Tests darauf hin, dass das Verhalten in die Spezifikation passen sollte. </p><br><div class="spoiler">  <b class="spoiler_title">Randnotiz: Wir wollen generischer gehen!</b> <div class="spoiler_text"><p>  Dieser Fall hat nichts mit der ursprünglichen Aufgabe zu tun, aber dies scheint ein gutes Beispiel für das bekannte Prinzip zu sein: "Sei liberal in dem, was du akzeptierst, sei konservativ in dem, was du tust".  Mit anderen Worten: Wenn Sie den Eingabetyp verallgemeinern können, ohne die Ergonomie und Leistung zu beeinträchtigen, sollten Sie dies wahrscheinlich tun. </p><br><p>  Jetzt werden wir dies überprüfen: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, El: <span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;(x: <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> <span class="hljs-built_in"><span class="hljs-built_in">IntoIterator</span></span>&lt;Item = &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> El&gt;, y: El) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> El: <span class="hljs-built_in"><span class="hljs-built_in">Eq</span></span>, { <span class="hljs-comment"><span class="hljs-comment">// Implementation elided }</span></span></code> </pre> <br><p>  Was wissen wir jetzt über diese Funktion?  Im Allgemeinen trotzdem, aber jetzt akzeptiert es nicht nur das Slice oder die Liste, sondern auch ein beliebiges Objekt, das die Verweise auf den Typ El liefern kann, so dass wir es mit dem fraglichen Objekt vergleichen.  Wenn ich mich beispielsweise nicht irre, wäre dieser Typ in Java <code>Iterable&lt;Comparable&gt;</code> . </p></div></div><br><h4 id="like-before-but-a-bit-more-strict">  Wie zuvor, aber etwas strenger </h4><br><p>  Aber jetzt brauchen wir vielleicht noch mehr Garantien.  Oder wir möchten am Stack arbeiten (und können daher <code>Vec</code> nicht verwenden), müssen aber unseren Code für jede mögliche Arraygröße verallgemeinern.  Oder wir möchten die für jede konkrete Arraygröße optimierte Funktion kompilieren. </p><br><p>  Wie auch immer, wir brauchen ein generisches Array - und es gibt eine Kiste in Rust, die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">genau das</a> bietet. </p><br><p>  Hier ist unser Code: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> generic_array::{GenericArray, ArrayLength}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>&lt;El, Size&gt;(x: GenericArray&lt;El, Size&gt;, y: El) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> El: <span class="hljs-built_in"><span class="hljs-built_in">Eq</span></span>, Size: ArrayLength&lt;El&gt;, { <span class="hljs-comment"><span class="hljs-comment">// Implementation elided }</span></span></code> </pre> <br><p>  Was wissen wir daraus?  Wir wissen, dass die Funktion das Array einer bestimmten Größe annimmt, die sich in seinem Typ widerspiegelt (und für jede dieser Größen unabhängig kompiliert wird).  Im Moment ist dies fast nichts - die gleichen Garantien wurden zur Laufzeit von der vorherigen Implementierung bereitgestellt. </p><br><p>  Aber wir können weiter kommen. </p><br><h4 id="type-level-arithmetic">  Arithmetik auf Typebene </h4><br><p>  Der erste Artikel erwähnte mehrere Garantien von Idris, die aus anderen Sprachen nicht zu bekommen waren.  Einer von ihnen - und wahrscheinlich der einfachste, da er keine Beweise oder Tests enthält, sondern nur eine kleine Änderung der Typen - gibt an, dass der Rückgabewert, wenn er nicht <code>Nothing</code> , immer kleiner als die Listenlänge ist. </p><br><p>  Sieht so aus, als wären die abhängigen Typen - oder so ähnlich - für eine solche Garantie notwendig, und wir können nicht dasselbe von Rust bekommen, oder? </p><br><p>  Treffen Sie den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Typenum</a> .  Mit ihm können wir unsere Funktion folgendermaßen schreiben: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> generic_array::{ArrayLength, GenericArray}; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> typenum::{IsLess, Unsigned, B1}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UnsignedLessThan</span></span></span></span>&lt;T&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">as_usize</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;Less, More&gt; UnsignedLessThan&lt;More&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Less <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> Less: IsLess&lt;More, Output = B1&gt;, Less: Unsigned, { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">as_usize</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> { &lt;<span class="hljs-keyword"><span class="hljs-keyword">Self</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Unsigned&gt;::USIZE } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>&lt;El, Size&gt;(x: GenericArray&lt;El, Size&gt;, y: El) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;dyn UnsignedLessThan&lt;Size&gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> El: <span class="hljs-built_in"><span class="hljs-built_in">Eq</span></span>, Size: ArrayLength&lt;El&gt;, { <span class="hljs-comment"><span class="hljs-comment">// Implementation elided }</span></span></code> </pre> <br><p>  "Was ist das für schwarze Magie ?!"  - Du könntest fragen.  Und Sie haben Recht: Typenum <em>ist</em> eine schwarze Magie, und alle Versuche, es zu verwenden, sind noch magischer. <br><br>  Diese Funktionssignatur ist jedoch ziemlich konkret. </p><br><ul><li>  Es braucht ein Array von El's mit der Länge Size und ein weiteres El. </li><li>  Es gibt eine Option zurück, die, wenn es sich um Some handelt, <br><ul><li>  enthält ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Merkmalsobjekt</a> , das auf dem Merkmal <code>UnsignedLessThan&lt;Size&gt;</code> basiert; </li><li>  und <code>UnsignedLessThan&lt;T&gt;</code> wird überall dort implementiert, wo <code>Unsigned</code> und <code>IsLess&lt;T&gt;</code> implementiert sind und <code>IsLess&lt;T&gt;</code> B1 zurückgibt, d. <code>IsLess&lt;T&gt;</code> . true. </li></ul></li></ul><br><p>  Mit anderen Worten, diese Funktion gibt <em>garantiert</em> eine vorzeichenlose Ganzzahl zurück, die <em>kleiner als</em> die Arraygröße ist (genau genommen gibt sie das <code>as_usize</code> zurück, aber wir können die Methode <code>as_usize</code> aufrufen und die Ganzzahl <code>as_usize</code> ). </p><br><p>  Ich kann jetzt von zwei wichtigen Vorbehalten sprechen: </p><br><ol><li>  Wir können einen Leistungsverlust bekommen.  Wenn sich diese Funktion irgendwie auf dem "heißen" Pfad des Programms befindet, können die konstanten dynamischen Versendungen den gesamten Prozess verlangsamen.  Dies ist zwar kein großes Problem, aber es gibt noch ein anderes: </li><li>  Damit diese Funktion kompiliert werden kann, müssen wir entweder den Beweis ihrer Richtigkeit direkt in sie schreiben oder das Typsystem mit etwas <code>unsafe</code> .  Ersteres ist ziemlich komplex und letzteres betrügt nur. </li></ol><br><h4 id="conclusion">  Fazit </h4><br><p>  In der Praxis verwenden wir natürlich im Allgemeinen entweder den zweiten Ansatz (mit generischem Slice) oder den Ansatz im Spoiler (mit Iterator).  Alle nachfolgenden Diskussionen sind wahrscheinlich nicht von praktischem Interesse und dienen hier nur als Übung mit Typen. </p><br><p>  Wie auch immer, die Tatsache, dass das Rust-Typ-System die Funktion des stärkeren Idris-Typ-Systems emulieren kann, ist für mich selbst ziemlich beeindruckend. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de468271/">https://habr.com/ru/post/de468271/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de468259/index.html">Fünf Höhepunkte des Helmgipfels 2019 in Amsterdam</a></li>
<li><a href="../de468261/index.html">Ein neues Spiel mit einer alten Atmosphäre auf Three.js</a></li>
<li><a href="../de468263/index.html">Begrüßen Sie das neue Visual Studio-Terminal</a></li>
<li><a href="../de468265/index.html">Aus Vim Süßigkeiten machen</a></li>
<li><a href="../de468267/index.html">Stärkung der UseCase-Methodik im Buch Alistair Coburn</a></li>
<li><a href="../de468277/index.html">Ist die Arbeit des Programmierers schwierig - eine Sicht aus Sicht der Psychophysiologie</a></li>
<li><a href="../de468285/index.html">Top-Softwareentwicklungsunternehmen für Unternehmen und Startups</a></li>
<li><a href="../de468287/index.html">C # -Attribute: Über alle Aspekte</a></li>
<li><a href="../de468289/index.html">AM</a></li>
<li><a href="../de468291/index.html">Synopse aus Mark Gaulstons Buch "Ich kann dich durchhören"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>