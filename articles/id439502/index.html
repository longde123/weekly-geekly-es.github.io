<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⚰️ 🤽🏿 👩🏾‍🤝‍👩🏽 Perilaku dan kebenaran yang tidak terdefinisi tidak didefinisikan 👨‍👧‍👦 🎡 👩🏻‍🔬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Istilah "perilaku tidak terbatas" dalam bahasa C dan C ++ menunjukkan situasi di mana secara harfiah "apa yang tidak terjadi". Secara historis, kasus-...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Perilaku dan kebenaran yang tidak terdefinisi tidak didefinisikan</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/439502/">  Istilah <b>"perilaku tidak terbatas"</b> dalam bahasa C dan C ++ menunjukkan situasi di mana secara harfiah "apa yang tidak terjadi".  Secara historis, kasus-kasus di mana kompiler C sebelumnya (dan arsitektur di atasnya) berperilaku dengan cara yang tidak sesuai dikaitkan dengan perilaku yang tidak terbatas, dan komite untuk mengembangkan standar, dalam kebijaksanaan tanpa batasnya, memutuskan untuk tidak memutuskan apa pun tentang hal ini (mis., Untuk tidak memberikan preferensi beberapa salah satu implementasi yang bersaing).  Perilaku tidak terbatas juga disebut situasi yang mungkin di mana standar, biasanya sangat lengkap, tidak meresepkan perilaku tertentu.  Istilah ini memiliki makna ketiga, yang pada zaman kita menjadi semakin relevan: perilaku yang tidak terbatas - ini adalah peluang untuk optimasi.  Dan pengembang di C dan C ++ <i>menyukai</i> optimasi;  mereka secara mendesak membutuhkan kompiler untuk melakukan segala upaya untuk mempercepat kode. <br><br>  <i>Artikel ini pertama kali <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><i>diterbitkan</i></a> di situs web Layanan Kriptografi.</i>  <i>Terjemahan diterbitkan dengan izin dari penulis Thomas Pornin.</i> <br><a name="habracut"></a><br>  Ini adalah contoh klasik: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *src, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *dst)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; i ++) { dst[i] = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)src[i]; } }</code> </pre> <br>  Kami akan mengkompilasi kode GCC ini pada platform x86 64-bit untuk Linux (saya bekerja pada versi terbaru Ubuntu 18.04, versi GCC - 7.3.0).  Kami mengaktifkan optimisasi penuh, dan kemudian melihat daftar assembler, yang kami gunakan tombol <i>"-Wall -O9 -S</i> " (argumen " <i>-O9</i> " menetapkan tingkat optimalisasi GCC maksimum, yang dalam praktiknya setara dengan " <i>-O3</i> ", meskipun dalam beberapa fork GCC ditentukan dan level lebih tinggi).  Kami mendapatkan hasil sebagai berikut: <br><br><pre> <code class="cpp hljs"> .file <span class="hljs-string"><span class="hljs-string">"zap.c"</span></span> .text .p2align <span class="hljs-number"><span class="hljs-number">4</span></span>,,<span class="hljs-number"><span class="hljs-number">15</span></span> .globl foo .type foo, @function foo: .LFB0: .<span class="hljs-function"><span class="hljs-function">cfi_startproc </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">movupd</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(%rdi)</span></span></span><span class="hljs-function">, %xmm0 movupd 16</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(%rdi)</span></span></span><span class="hljs-function">, %xmm1 cvttpd2dq %xmm0, %xmm0 cvttpd2dq %xmm1, %xmm1 punpcklqdq %xmm1, %xmm0 movups %xmm0, </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(%rsi)</span></span></span><span class="hljs-function"> ret .cfi_endproc .LFE0: .size foo, .-foo .ident "GCC: </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Ubuntu </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">7.3</span></span></span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">.0</span></span></span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">-27u</span></span></span></span><span class="hljs-function"><span class="hljs-params">buntu1~</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">18.04</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> 7.3.0" .section .note.GNU-</span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">stack</span></span></span><span class="hljs-function">,"",@progbits</span></span></code> </pre> <br>  Masing-masing dari dua instruksi <i>movupd</i> pertama memindahkan dua nilai <i>ganda</i> ke register SSE2 128-bit ( <i>ganda</i> memiliki ukuran 64 bit, sehingga register SSE2 dapat menyimpan dua nilai <i>ganda</i> ).  Dengan kata lain, empat nilai awal dibaca pertama, dan hanya kemudian mereka <i>dilemparkan</i> ke <i>int</i> (operasi <i>cvttpd2dq</i> ).  Operasi <i>punpcklqdq</i> memindahkan empat bilangan bulat 32-bit yang diterima menjadi satu register SSE2 <i>(% xmm0</i> ), yang isinya kemudian dituliskan ke RAM ( <i>movups</i> ).  Dan sekarang yang utama: program C kami secara resmi mengharuskan akses ke memori terjadi dalam urutan berikut: <br><br><ul><li>  Baca nilai <i>ganda</i> pertama dari <i>src [0]</i> . </li><li>  Tulis nilai pertama dari tipe <i>int</i> ke <i>dst [0]</i> . </li><li>  Baca nilai <i>ganda</i> kedua dari <i>src [1]</i> . </li><li>  Tulis nilai kedua dari tipe <i>int</i> ke <i>dst [1]</i> . </li><li>  Baca nilai <i>ganda</i> ketiga dari <i>src [2]</i> . </li><li>  Tulis nilai ketiga dari tipe <i>int</i> ke <i>dst [2]</i> . </li><li>  Baca nilai <i>ganda</i> keempat dari <i>src [3]</i> . </li><li>  Tulis nilai keempat dari tipe <i>int</i> ke <i>dst [3]</i> . </li></ul><br>  Namun, semua persyaratan ini hanya masuk akal dalam konteks mesin abstrak, yang didefinisikan oleh standar C;  prosedur pada mesin sungguhan dapat bervariasi.  Kompiler bebas untuk mengatur ulang atau memodifikasi operasi, asalkan hasilnya tidak bertentangan dengan semantik mesin abstrak (aturan yang disebut <i>as-jika</i> adalah "seolah-olah").  Dalam contoh kami, urutan tindakan hanya berbeda: <br><br><ul><li>  Baca nilai <i>ganda</i> pertama dari <i>src [0]</i> . </li><li>  Baca nilai <i>ganda</i> kedua dari <i>src [1]</i> . </li><li>  Baca nilai <i>ganda</i> ketiga dari <i>src [2]</i> . </li><li>  Baca nilai <i>ganda</i> keempat dari <i>src [3]</i> . </li><li>  Tulis nilai pertama dari tipe <i>int</i> ke <i>dst [0]</i> . </li><li>  Tulis nilai kedua dari tipe <i>int</i> ke <i>dst [1]</i> . </li><li>  Tulis nilai ketiga dari tipe <i>int</i> ke <i>dst [2]</i> . </li><li>  Tulis nilai keempat dari tipe <i>int</i> ke <i>dst [3]</i> . </li></ul><br>  Ini adalah bahasa C: semua isi memori pada akhirnya adalah byte (yaitu, slot dengan nilai tipe <i>unsigned char</i> , tetapi dalam praktiknya, grup delapan bit), dan operasi penunjuk sewenang-wenang diizinkan.  Secara khusus, <i>src</i> dan pointer <i>dst</i> dapat digunakan untuk mengakses bagian memori yang tumpang tindih ketika dipanggil (situasi ini disebut "aliasing").  Dengan demikian, urutan baca dan tulis mungkin penting jika byte ditulis dan kemudian dibaca lagi.  Agar perilaku aktual program sesuai dengan abstrak yang didefinisikan oleh standar C, kompiler harus bergantian antara operasi baca dan tulis, memberikan siklus penuh memori yang diakses pada setiap iterasi.  Kode yang dihasilkan akan lebih besar dan bekerja lebih lambat.  Untuk pengembang C, ini akan menjadi kesedihan. <br><br>  Di sini, untungnya, <i>perilaku tak terbatas</i> datang untuk menyelamatkan.  Standar C menyatakan bahwa nilai tidak dapat diakses melalui pointer yang tipenya tidak sesuai dengan tipe saat ini dari nilai-nilai ini.  Sederhananya, jika nilainya ditulis ke <i>dst [0]</i> , di mana <i>dst adalah</i> pointer <i>int</i> , maka byte yang sesuai tidak dapat dibaca melalui <i>src [1]</i> , di mana <i>src</i> adalah pointer <i>ganda</i> , karena dalam kasus ini kami akan mencoba mengakses nilai, yang sekarang bertipe <i>int</i> , menggunakan pointer dari tipe yang tidak kompatibel.  Dalam hal ini, perilaku yang tidak terdefinisi akan terjadi.  Ini dinyatakan dalam paragraf 7 bagian 6.5 standar ISO 9899: 1999 ("C99") (dalam edisi baru 9899: 2018, atau "C17", kata-katanya tidak berubah).  Persyaratan ini disebut aturan aliasing yang ketat.  Akibatnya, kompiler C diizinkan untuk bertindak dengan asumsi bahwa operasi akses memori yang mengarah ke perilaku tidak terdefinisi karena pelanggaran aturan aliasing yang ketat tidak terjadi.  Dengan demikian, kompiler dapat mengatur ulang operasi baca dan tulis dalam urutan apa pun, karena mereka tidak boleh mengakses bagian memori yang tumpang tindih.  Inilah yang dimaksud dengan optimasi kode. <br><br>  Arti dari perilaku tidak terdefinisi, singkatnya, adalah ini: kompilator dapat mengasumsikan bahwa tidak akan ada perilaku tidak terdefinisi, dan menghasilkan kode berdasarkan asumsi ini.  Dalam kasus aturan aliasing yang ketat - asalkan aliasing terjadi, perilaku tidak terbatas memungkinkan untuk optimasi penting yang jika tidak akan sulit untuk diterapkan.  Secara umum, setiap instruksi dalam prosedur pembuatan kode yang digunakan oleh kompiler memiliki dependensi yang membatasi algoritma perencanaan operasi: sebuah instruksi tidak dapat dijalankan sebelum instruksi yang bergantung padanya, atau setelah instruksi yang bergantung padanya.  Dalam contoh kami, perilaku tidak terdefinisi menghilangkan ketergantungan antara operasi tulis pada <i>dst []</i> dan operasi baca "berikutnya" dari <i>src []</i> : ketergantungan seperti itu hanya dapat ada dalam kasus ketika perilaku tidak terdefinisi terjadi ketika mengakses memori.  Demikian pula, konsep perilaku terdefinisi memungkinkan kompiler untuk menghapus kode yang tidak dapat dieksekusi tanpa memasukkan keadaan perilaku tidak terdefinisi. <br><br>  Semua ini, tentu saja, adalah baik, tetapi perilaku seperti itu kadang-kadang dianggap sebagai pengkhianatan berbahaya oleh kompiler.  Anda sering dapat mendengar frasa: "Kompilator menggunakan konsep perilaku tidak terbatas sebagai alasan untuk memecahkan kode saya."  Misalkan seseorang menulis sebuah program yang menambahkan bilangan bulat dan ketakutan meluap - ingat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kasus Bitcoin</a> .  Dia dapat berpikir seperti ini: untuk merepresentasikan bilangan bulat, prosesor menggunakan kode tambahan, yang berarti jika overflow terjadi, itu akan terjadi karena hasilnya akan dipotong ke ukuran tipe, mis.  32 bit  Ini berarti bahwa hasil luapan dapat diprediksi dan diperiksa dengan suatu pengujian. <br><br>  Pengembang bersyarat kami akan menulis ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; int add(int x, int y, int *z) { int r = x + y; if (x &gt; 0 &amp;&amp; y &gt; 0 &amp;&amp; r &lt; x) { return 0; } if (x &lt; 0 &amp;&amp; y &lt; 0 &amp;&amp; r &gt; x) { return 0; } *z = r; return 1; } int main(int argc, char *argv[]) { int x, y, z; if (argc != 3) { return EXIT_FAILURE; } x = atoi(argv[1]); y = atoi(argv[2]); if (add(x, y, &amp;z)) { printf("%d\n", z); } else { printf("overflow!\n"); } return 0; }</span></span></span></span></code> </pre><br>  Sekarang mari kita coba kompilasi kode ini menggunakan GCC: <br><br><pre> <code class="cpp hljs">$ gcc -W -Wall -O9 testadd.c $ ./a.out <span class="hljs-number"><span class="hljs-number">17</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span> <span class="hljs-number"><span class="hljs-number">59</span></span> $ ./a.out <span class="hljs-number"><span class="hljs-number">2000000000</span></span> <span class="hljs-number"><span class="hljs-number">1500000000</span></span> overflow!</code> </pre><br>  Ok, sepertinya berhasil.  Sekarang coba kompiler lain, misalnya, Dentang (saya punya versi 6.0.0): <br><br><pre> <code class="cpp hljs">$ clang -W -Wall -O3 testadd.c $ ./a.out <span class="hljs-number"><span class="hljs-number">17</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span> <span class="hljs-number"><span class="hljs-number">59</span></span> $ ./a.out <span class="hljs-number"><span class="hljs-number">2000000000</span></span> <span class="hljs-number"><span class="hljs-number">1500000000</span></span> <span class="hljs-number"><span class="hljs-number">-794967296</span></span></code> </pre><br>  Apa? <br><br>  Ternyata ketika operasi dengan tipe integer yang ditandatangani mengarah ke hasil yang tidak dapat diwakili oleh tipe target, kami memasuki wilayah perilaku yang tidak ditentukan.  Tetapi kompiler dapat berasumsi bahwa itu tidak terjadi.  Secara khusus, mengoptimalkan ekspresi <i>x&gt; 0 &amp;&amp; y&gt; 0 &amp;&amp; r &lt;x</i> , kompilator menyimpulkan bahwa karena nilai-nilai <i>x</i> dan <i>y</i> benar <i>-</i> benar positif, pemeriksaan ketiga tidak mungkin benar (jumlah dua nilai tidak boleh kurang dari salah satu dari mereka), dan Anda dapat melewati seluruh operasi ini.  Dengan kata lain, karena meluap adalah perilaku yang tidak terdefinisi, itu "tidak dapat terjadi" dari sudut pandang kompiler, dan semua instruksi yang bergantung pada keadaan ini dapat dihapus.  Mekanisme untuk mendeteksi perilaku tidak terdefinisi telah hilang begitu saja. <br><br>  Standar tidak pernah menetapkan asumsi bahwa "semantik yang ditandatangani" (yang sebenarnya digunakan dalam operasi prosesor) digunakan dalam perhitungan dengan tipe yang ditandatangani;  ini terjadi bukan karena tradisi - bahkan pada masa itu ketika kompiler tidak cukup pintar untuk mengoptimalkan kode, dengan fokus pada sejumlah nilai.  Anda dapat memaksa Dentang dan GCC untuk menerapkan semantik pembungkus untuk tipe yang ditandatangani menggunakan flag <i>-fwrapv</i> (di Microsoft Visual C, Anda dapat menggunakan <i>-d2UndefIntOverflow-,</i> seperti dijelaskan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> ).  Namun, pendekatan ini tidak dapat diandalkan, bendera mungkin hilang ketika kode ditransfer ke proyek lain atau ke arsitektur lain. <br><br>  Hanya sedikit orang yang tahu bahwa overflow tipe karakter melibatkan perilaku yang tidak terdefinisi.  Ini dinyatakan dalam paragraf 5 bagian 6.5 dari standar C99 dan C17: <br><br>  <i>Jika pengecualian terjadi ketika mengevaluasi ekspresi (mis., Jika hasilnya tidak didefinisikan secara matematis atau di luar kisaran nilai valid dari jenis yang diberikan), perilaku tersebut tidak terdefinisi.</i> <br><br>  Namun untuk tipe yang tidak ditandatangani, semantik modular dijamin.  Paragraf 9 bagian 6.2.5 mengatakan yang berikut: <br><br>  <i>Overflow tidak pernah terjadi dalam perhitungan dengan operan yang tidak ditandatangani, karena hasil yang tidak dapat diwakili oleh tipe integer yang tidak ditandatangani yang dihasilkan modulo bilangan yang satu lebih dari nilai maksimum yang diwakili oleh jenis yang dihasilkan.</i> <br><br>  Contoh lain dari perilaku tidak terdefinisi dalam operasi dengan tipe yang ditandatangani adalah operasi divisi.  Seperti semua orang tahu, hasil pembagian dengan nol tidak ditentukan secara matematis, oleh karena itu, menurut standar, operasi ini memerlukan perilaku yang tidak terdefinisi.  Jika pembagi nol dalam operasi <i>idiv</i> pada prosesor x86, pengecualian prosesor dilemparkan.  Seperti permintaan interupsi, pengecualian prosesor ditangani oleh sistem operasi.  Pada sistem mirip Unix, seperti Linux, pengecualian prosesor yang dipicu oleh operasi <i>idiv</i> diterjemahkan ke dalam sinyal <i>SIGFPE</i> , yang dikirim ke proses, dan diakhiri dengan pengendali default (jangan heran bahwa "FPE" adalah singkatan dari "pengecualian titik mengambang" (pengecualian dalam operasi floating point), sementara <i>idiv</i> bekerja dengan bilangan bulat).  Tetapi ada situasi lain yang mengarah pada perilaku yang tidak terdefinisi.  Pertimbangkan kode berikut: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main(int argc, char *argv[]) { int x, y; if (argc != 3) { return EXIT_FAILURE; } x = atoi(argv[1]); y = atoi(argv[2]); printf("%d\n", x / y); return 0; }  : $ gcc -W -Wall -O testdiv.c $ ./a.out 42 17 2 $ ./a.out -2147483648 -1 zsh: floating point exception (core dumped) ./a.out -2147483648 -1</span></span></span></span></code> </pre> <br>  Dan kebenarannya adalah: pada mesin ini (x86 yang sama untuk Linux), tipe <i>int</i> mewakili kisaran nilai dari -2,147.483.648 hingga +2.147.448.647. Jika Anda membagi -2.147.448.648 dengan -1, Anda harus mendapatkan +2.147.483.648 Tetapi angka ini tidak berada dalam kisaran nilai <i>int</i> .  Karena itu, perilaku tidak didefinisikan.  Apa pun bisa terjadi.  Dalam hal ini, proses dihentikan secara paksa.  Pada sistem lain, terutama dengan prosesor kecil yang tidak memiliki operasi divisi, hasilnya dapat bervariasi.  Dalam arsitektur seperti itu, divisi dilakukan secara terprogram - dengan bantuan prosedur yang biasanya disediakan oleh kompiler, dan sekarang dapat melakukan apa pun yang diinginkan dengan perilaku yang tidak terbatas, karena memang itulah yang sebenarnya. <br><br>  Saya perhatikan bahwa <i>SIGFPE</i> dapat diperoleh dalam kondisi yang sama dan dengan bantuan operator modulo ( <i>%</i> ).  Dan pada kenyataannya: di bawahnya terletak operasi <i>idiv yang</i> sama, yang menghitung hasil bagi dan sisanya, sehingga pengecualian prosesor yang sama dipicu.  Menariknya, standar C99 mengatakan bahwa ekspresi <i>INT_MIN% -1</i> tidak dapat mengarah pada perilaku yang tidak terdefinisi, karena hasilnya didefinisikan secara matematis (nol) dan dengan jelas memasuki kisaran nilai dari tipe target.  Dalam versi C17, teks paragraf 6 bagian 6.5.5 telah diubah, dan sekarang kasus ini juga diperhitungkan, yang membawa standar lebih dekat ke situasi nyata pada platform perangkat keras umum. <br><br>  Ada banyak situasi tidak jelas yang juga mengarah pada perilaku yang tidak terdefinisi.  Lihatlah kode ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; unsigned short mul(unsigned short x, unsigned short y) { return x * y; } int main(int argc, char *argv[]) { int x, y; if (argc != 3) { return EXIT_FAILURE; } x = atoi(argv[1]); y = atoi(argv[2]); printf("%d\n", mul(x, y)); return 0; }</span></span></span></span></code> </pre> <br>  Apakah Anda berpikir bahwa suatu program, mengikuti standar C, harus mencetak jika kita meneruskan faktor 45.000 dan 50.000 ke fungsi? <br><br><ul><li>  18.048 </li><li>  2.250.000.000 </li><li>  Tuhan selamatkan Ratu! </li></ul><br>  Jawaban yang benar ... ya, semua yang di atas!  Anda mungkin berpendapat seperti ini: karena <i>short unsigned</i> adalah tipe unsigned, itu seharusnya mendukung semantik pembungkus modulo 65 536, karena pada prosesor x86 ukuran jenis ini, sebagai aturan, adalah tepat 16 bit (standar juga memungkinkan ukuran yang lebih besar, tetapi dalam prakteknya, ini masih tipe 16-bit).  Karena secara matematis produk adalah 2.250.000.000, maka akan dipotong modulo 65.536, yang memberikan jawaban 18.048. Namun, berpikir dengan cara ini, kita lupa tentang perluasan tipe integer.  Menurut standar C (bagian 6.3.1.1, paragraf 2), jika operan adalah tipe yang ukurannya benar-benar lebih kecil dari ukuran <i>int</i> , dan nilai-nilai tipe ini dapat diwakili oleh tipe <i>int</i> tanpa kehilangan bit (dan kami hanya memiliki case ini: pada x86 saya di bawah Linux memiliki ukuran <i>int</i> 32 bit, dan ia dapat secara eksplisit menyimpan nilai dari 0 hingga 65.535), kemudian kedua operan dilemparkan ke <i>int</i> dan operasi sudah dilakukan pada nilai yang dikonversi.  Yaitu: produk dihitung sebagai nilai dari tipe <i>int,</i> dan hanya setelah kembali dari fungsi itu dikembalikan ke <i>unsigned short</i> (yaitu, pada saat inilah pemotongan modulo 65 536 terjadi).  Masalahnya adalah bahwa secara matematis hasil sebelum transformasi terbalik adalah 2,250 juta, dan nilai ini melebihi kisaran <i>int</i> , yang merupakan tipe yang ditandatangani.  Akibatnya, kita mendapatkan perilaku yang tidak terdefinisi.  Setelah itu, apa pun bisa terjadi, termasuk serangan patriotisme Inggris yang tiba-tiba. <br><br>  Namun, dalam praktiknya, dengan kompiler biasa, hasilnya adalah 18.048, karena masih belum ada optimasi yang dapat mengambil keuntungan dari perilaku tidak terbatas dalam program khusus ini (orang dapat membayangkan lebih banyak skenario buatan di mana ia benar-benar akan menyebabkan masalah). <br><br>  Akhirnya, contoh lain, sekarang di C ++: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;array&gt; int main(int argc, char *argv[]) { std::array&lt;char, 16&gt; tmp; int i; if (argc &lt; 2) { return EXIT_FAILURE; } memset(tmp.data(), 0, 16); if (strlen(argv[1]) &lt; 16) { strcpy(tmp.data(), argv[1]); } for (i = 0; i &lt; 17; i ++) { printf(" %02x", tmp[i]); } printf("\n"); }</span></span></span></span></code> </pre> <br>  Ini bukan tipikal “bad awful <i>strcpy ()</i> !” Bagi Anda.  Memang, di sini fungsi <i>strcpy ()</i> dijalankan hanya jika ukuran string sumber, termasuk terminal nol, cukup kecil.  Selain itu, elemen-elemen array secara eksplisit diinisialisasi ke nol, sehingga semua byte dalam array memiliki nilai yang diberikan, terlepas dari apakah string besar atau kecil dilewatkan ke fungsi.  Pada saat yang sama, loop pada akhirnya salah: ia membaca satu byte lebih dari yang seharusnya. <br><br>  Jalankan kode: <br><br><pre> <code class="cpp hljs">$ g++ -W -Wall -O9 testvec.c $ ./a.out foo <span class="hljs-number"><span class="hljs-number">66</span></span> <span class="hljs-number"><span class="hljs-number">6f</span></span> <span class="hljs-number"><span class="hljs-number">6f</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-number"><span class="hljs-number">58</span></span> ffffffca ff ffffac ffffffc0 <span class="hljs-number"><span class="hljs-number">55</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> ffffff80 <span class="hljs-number"><span class="hljs-number">71</span></span> <span class="hljs-number"><span class="hljs-number">34</span></span> ffffff99 <span class="hljs-number"><span class="hljs-number">07</span></span> ffffffba ff ffffea ffffffd0 ffffffe5 <span class="hljs-number"><span class="hljs-number">44</span></span> ffffff83 fffffffd <span class="hljs-number"><span class="hljs-number">7f</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-number"><span class="hljs-number">58</span></span> ffffffca ffffffac ffffffc0 <span class="hljs-number"><span class="hljs-number">55</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> ffffff97 <span class="hljs-number"><span class="hljs-number">7b</span></span> <span class="hljs-number"><span class="hljs-number">12</span></span> <span class="hljs-number"><span class="hljs-number">1b</span></span> ffffffa1 <span class="hljs-number"><span class="hljs-number">7f</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">02</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> ffffffd8 ffffffe5 <span class="hljs-number"><span class="hljs-number">44</span></span> ffffff83 fffffffd <span class="hljs-number"><span class="hljs-number">7f</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> ffffff80 <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">02</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">60</span></span> <span class="hljs-number"><span class="hljs-number">56</span></span> (...) <span class="hljs-number"><span class="hljs-number">62</span></span> <span class="hljs-number"><span class="hljs-number">64</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>d <span class="hljs-number"><span class="hljs-number">30</span></span> <span class="hljs-number"><span class="hljs-number">30</span></span> zsh: <span class="hljs-function"><span class="hljs-function">segmentation </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fault</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(core dumped)</span></span></span><span class="hljs-function"> ./a.out foo ++?</span></span></code> </pre> <br>  Anda dapat secara naif menolak: well, ia membaca byte tambahan di luar batas array;  tetapi ini tidak begitu menakutkan, karena pada stack byte ini masih ada, ia dipetakan ke memori, jadi satu-satunya masalah di sini adalah elemen ketujuh belas ekstra dengan nilai yang tidak diketahui.  Siklus masih akan mencetak tepat 17 integer (dalam format heksadesimal) dan berakhir tanpa keluhan. <br><br>  Tetapi kompiler memiliki pendapat sendiri tentang masalah ini.  Dia sangat menyadari bahwa bacaan ketujuh belas memprovokasi perilaku yang tidak terbatas.  Menurut logikanya, setiap instruksi selanjutnya berada dalam limbo: tidak ada persyaratan bahwa setelah perilaku tidak pasti sesuatu harus ada sama sekali (instruksi formal bahkan sebelumnya mungkin sedang diserang, karena perilaku tidak terbatas juga bekerja di arah yang berlawanan).  Dalam kasus kami, kompiler hanya akan mengabaikan pemeriksaan kondisi di loop, dan akan berputar selamanya, atau lebih tepatnya, sampai mulai membaca di luar memori yang dialokasikan untuk stack, setelah itu sinyal <i>SIGSEGV</i> akan bekerja. <br><br>  Ini lucu, tetapi jika GCC memulai dengan pengaturan yang kurang agresif untuk optimisasi, itu akan memberi peringatan: <br><br><pre> <code class="cpp hljs">$ g++ -W -Wall -O1 testvec.c testvec.c: In function <span class="hljs-string"><span class="hljs-string">'int main(int, char**)'</span></span>: testvec.c:<span class="hljs-number"><span class="hljs-number">20</span></span>:<span class="hljs-number"><span class="hljs-number">15</span></span>: warning: iteration <span class="hljs-number"><span class="hljs-number">16</span></span> invokes undefined behavior [-Waggressive-loop-optimizations] <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">" %02x"</span></span>, tmp[i]); ~~~~~~^~~~~~~~~~~~~~~~~ testvec.c:<span class="hljs-number"><span class="hljs-number">19</span></span>:<span class="hljs-number"><span class="hljs-number">19</span></span>: note: <span class="hljs-function"><span class="hljs-function">within </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">this</span></span></span><span class="hljs-function"> loop </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">; i &lt; </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">17</span></span></span></span><span class="hljs-function"><span class="hljs-params">; i ++)</span></span></span><span class="hljs-function"> </span></span>{ ~~^~~~</code> </pre> <br>  Pada <i>-O9,</i> peringatan ini entah bagaimana menghilang.  Mungkin faktanya adalah bahwa pada tingkat optimasi yang tinggi, kompiler lebih agresif memberlakukan penyebaran loop.  Mungkin (tetapi tidak akurat) bahwa ini adalah bug GCC (dalam arti hilangnya peringatan; dengan demikian, tindakan GCC dalam hal apa pun tidak bertentangan dengan standar, karena tidak memerlukan penerbitan "diagnostik" dalam situasi ini). <br><br>  Kesimpulan: jika Anda menulis kode dalam C atau C ++, berhati-hatilah dan hindari situasi yang mengarah pada perilaku tidak terdefinisi, bahkan ketika sepertinya “tidak apa-apa”. <br><br>  Tipe integer yang tidak ditandatangani adalah penolong yang baik dalam perhitungan aritmatika, karena mereka dijamin semantik modular (tetapi Anda masih bisa mendapatkan masalah terkait dengan ekstensi tipe integer).  Pilihan lain - karena alasan tertentu tidak populer - adalah tidak menulis dalam C dan C ++ sama sekali.  Karena beberapa alasan, solusi ini tidak selalu cocok.  Tetapi jika Anda dapat memilih bahasa untuk menulis program, mis.  ketika Anda baru memulai proyek baru pada platform yang mendukung Go, Rust, Java, atau bahasa lain, mungkin lebih menguntungkan jika menolak menggunakan C sebagai "bahasa default".  Pilihan alat, termasuk bahasa pemrograman, selalu merupakan kompromi.  Jebakan C, terutama perilaku yang tidak terbatas dalam operasi dengan tipe yang ditandatangani, menyebabkan biaya tambahan untuk pemeliharaan kode lebih lanjut, yang sering diremehkan. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id439502/">https://habr.com/ru/post/id439502/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id439490/index.html">Jenis Referensi .NET vs Jenis Nilai. Bagian 2</a></li>
<li><a href="../id439492/index.html">10 Tips untuk Menjadi Pemimpin Teknologi yang Baik</a></li>
<li><a href="../id439496/index.html">Cara penagihan dilakukan di sana: ketika pelanggan dan pengembang berbicara bahasa yang berbeda</a></li>
<li><a href="../id439498/index.html">Pada perangkat keras mana untuk menganalisis sejumlah besar informasi?</a></li>
<li><a href="../id439500/index.html">Mengapa captcha menjadi begitu rumit</a></li>
<li><a href="../id439504/index.html">Apakah tim Anda membutuhkan Insinyur Data?</a></li>
<li><a href="../id439506/index.html">9 alternatif untuk tim yang buruk (pola desain)</a></li>
<li><a href="../id439508/index.html">Mitap tentang Pengembangan Sumber Terbuka di Moskow</a></li>
<li><a href="../id439510/index.html">Sistem kontrol terdistribusi tinggi dari pembangkit listrik tenaga nuklir modern</a></li>
<li><a href="../id439512/index.html">Usia dinosaurus atau reasuransi yang diverifikasi secara hukum?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>