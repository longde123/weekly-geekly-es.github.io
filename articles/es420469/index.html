<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üï° üà≤ üë©‚Äç‚úàÔ∏è Caracter√≠sticas del uso de druida en el ejemplo de compa√±eros de clase üë©‚Äçüëß‚Äçüëß üõ≥Ô∏è üèÖ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mi nombre es Yuri Nevinitsin y estoy involucrado en el sistema de estad√≠sticas internas en OK. Quiero hablar sobre c√≥mo transferimos un sistema anal√≠t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Caracter√≠sticas del uso de druida en el ejemplo de compa√±eros de clase</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/odnoklassniki/blog/420469/"><img src="https://habrastorage.org/webt/jd/0-/fd/jd0-fdngd2psn0-j-hkq1gmcm_a.jpeg"><br><br>  Mi nombre es Yuri Nevinitsin y estoy involucrado en el sistema de estad√≠sticas internas en OK.  Quiero hablar sobre c√≥mo transferimos un sistema anal√≠tico de 50 terabytes en tiempo real, en el que miles de millones de eventos se registran diariamente, desde Microsoft SQL a una base de columnas llamada Druid.  Y al mismo tiempo, aprender√° algunas recetas para usar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Druid</a> . <br><a name="habracut"></a><br><h2>  ¬øPor qu√© necesitamos estad√≠sticas? </h2><br>  Queremos saber todo acerca de nuestro sitio, por lo que registramos no solo el comportamiento de los discos, procesadores, etc., sino tambi√©n cada acci√≥n del usuario, cada interacci√≥n entre subsistemas y todos los procesos internos de casi todos nuestros sistemas.  El sistema de estad√≠sticas est√° estrechamente integrado en el proceso de desarrollo. <br><br>  Con base en los datos del sistema de estad√≠sticas, nuestros gerentes establecen metas para los equipos, realizan un seguimiento de sus logros e indicadores clave.  Los administradores y desarrolladores supervisan el funcionamiento de todos los sistemas, investigan incidentes y anomal√≠as.  El monitoreo autom√°tico monitorea constantemente y en una etapa temprana identifica problemas, hace pron√≥sticos de exceder los l√≠mites.  Adem√°s, las caracter√≠sticas y los experimentos se lanzan constantemente, se realizan actualizaciones y cambios.  Y monitoreamos el efecto de todas estas acciones a trav√©s del sistema de estad√≠sticas.  Si ella se niega, no podremos realizar cambios en el sitio. <br><br>  Nuestras estad√≠sticas se presentan principalmente en forma de gr√°ficos.  Por lo general, el gr√°fico muestra varios d√≠as a la vez, para que la din√°mica sea clara.  Aqu√≠ hay un ejemplo de mis experimentos con Druid.  Aqu√≠ hay un gr√°fico de carga de datos (l√≠neas / 5 min). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9b4/66b/1b1/9b466b1b191463f97dd3d192a8c4da42.jpg"><br><br>  Disminu√≠ la velocidad de la descarga (el gr√°fico rojo se bloquea a cero), esper√© un tiempo, reinici√© la descarga y observ√© qu√© tan r√°pido Druid pod√≠a cargar los datos acumulados (picos despu√©s de fallas). <br><br>  Cualquier programaci√≥n puede ampliarse mediante cualquier par√°metro, por ejemplo, por host, tabla, operaci√≥n, etc.  Tambi√©n tenemos gr√°ficos a largo plazo con din√°micas anuales.  Por ejemplo, a continuaci√≥n se muestra un gr√°fico del aumento diario en el n√∫mero de entradas en Druid. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d9d/b52/45d/d9db5245dca91cc7cbdeee071b3529fa.png"><br><br>  Tambi√©n podemos combinar varios gr√°ficos en paneles separados (paneles), lo que result√≥ ser muy conveniente.  E incluso si el usuario necesita ver solo un par de gr√°ficos de cientos, todav√≠a los abre no individualmente, sino en el panel, lo que aumenta la carga en el sistema. <br><br><h2>  El problema </h2><br>  Si bien el volumen de datos era peque√±o, lidiamos con SQL bastante bien.  Pero a medida que crec√≠a el volumen de datos, la producci√≥n de gr√°ficos disminuy√≥.  Y al final, las estad√≠sticas en la hora pico comenzaron a retrasarse media hora, y el tiempo de respuesta promedio de un gr√°fico alcanz√≥ los 6 segundos.  Es decir, alguien recibi√≥ el cronograma en 2 segundos, alguien en 10-20 y alguien en un minuto.  (Puede leer sobre el desarrollo del sistema en SQL <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> ) <br><br>  Cuando investiga una anomal√≠a o incidente, generalmente necesita abrir y ver una docena de gr√°ficos, cada uno de los cuales se deduce del anterior, no se pueden abrir al mismo tiempo.  Tuve que esperar 10 veces durante 10-20 segundos.  Fue muy molesto. <br><br><h2>  La migracion </h2><br>  Todav√≠a podr√≠a extraer algo del sistema, agregar servidores ... Pero aproximadamente al mismo tiempo, Microsoft cambi√≥ su pol√≠tica de licencias.  Si continuamos usando SQL Server, tendr√≠amos que regalar millones de d√≥lares.  Por lo tanto, decidieron migrar. <br><br>  Los requisitos fueron los siguientes: <br><br><ul><li>  Las estad√≠sticas no deben retrasarse (m√°s de 2 minutos). </li><li>  El cuadro debe abrirse en no m√°s de 2 segundos. </li><li>  Todo el panel deber√≠a abrirse en no m√°s de 10 segundos. </li><li>  El sistema debe ser tolerante a fallas, capaz de sobrevivir a la p√©rdida de un centro de datos. </li><li>  El sistema debe ser f√°cilmente escalable. </li><li>  El sistema deber√≠a ser f√°cil de modificar, por lo que quer√≠amos que estuviera en Java. </li></ul><br>  Todo esto nos lo ofreci√≥ solo Druida.  Tambi√©n tiene agregaci√≥n preliminar, que le permite ahorrar un poco m√°s de volumen e indexaci√≥n durante la inserci√≥n de datos.  Druid admite todos los tipos de consultas que se necesitan para nuestras estad√≠sticas.  Por lo tanto, parec√≠a que pod√≠amos sustituir f√°cilmente Druid por SQL Server. <br><br>  Por supuesto, consideramos no solo a Druid para el papel de candidato para la mudanza.  Mi primer pensamiento fue reemplazar Microsoft SQL Server con PostgreSQL.  Sin embargo, esto solo resolver√≠a el problema de los costos financieros, pero no ayudar√≠a con la accesibilidad y la ampliaci√≥n. <br><br>  Tambi√©n analizamos Influx, pero result√≥ que la parte responsable de la alta disponibilidad y escalabilidad est√° cerrada.  Prometheus, con el debido respeto a su rendimiento, est√° m√°s ajustado para el monitoreo y no puede presumir de alta disponibilidad o escalabilidad simple.  OpenTSDB tambi√©n es m√°s adecuado para la supervisi√≥n, no tiene √≠ndices para todos los campos.  No consideramos Click House, ya que en ese momento no estaba all√≠. <br><br>  Pon Druida.  Terabytes de datos migrados.  E inmediatamente despu√©s de cambiar de SQL Server a Druid, el n√∫mero de vistas de gr√°ficos aument√≥ 5 veces.  Luego comenzaron a ejecutar estad√≠sticas "pesadas", que ten√≠an miedo de ejecutar antes, porque  SQL dif√≠cilmente lo manejar√≠a. <br><br>  Ahora Druid de 12 nodos (40 n√∫cleos, 196 GB de RAM) toma 500 mil eventos por segundo por hora punta, mientras que hay un gran margen de seguridad (columna MAX: casi cinco veces el margen de la CPU). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/833/336/d09/833336d095db6e9d32da19dae981d474.png" width="500"><br><br>  Estas cifras se basan en datos de producci√≥n.  Te dir√© c√≥mo logramos esto, pero primero describir√© a Druid con m√°s detalle. <br><br><h2>  Druida </h2><br>  Este es un sistema OLAP de series de tiempo de columna distribuida.  Su documentaci√≥n no contiene los conceptos usuales del mundo SQL para una tabla (fuente de datos en su lugar) o una cadena (evento en su lugar), pero los usar√© para facilitar la descripci√≥n. <br><br>  Druid se basa en varios supuestos de datos (limitaciones): <br><br><ul><li>  cada l√≠nea de datos tiene una marca de tiempo que crece de manera mon√≥tona (dentro de una ventana de 10 minutos por defecto). </li><li>  los datos no cambian, solo insertar (la operaci√≥n de actualizaci√≥n no). </li></ul><br>  Esto le permite cortar datos en los llamados segmentos de tiempo.  Un segmento es una "partici√≥n" indivisible e invariable m√≠nima de una tabla durante un cierto per√≠odo de tiempo.  Todas las operaciones de datos, todas las consultas se realizan segmento por segmento. <br><br>  Cada segmento es autosuficiente: adem√°s de la tabla principal, escrita en forma de columnas, tambi√©n contiene directorios e √≠ndices necesarios para la ejecuci√≥n de consultas.  Podemos decir que un segmento es una peque√±a columna de base de datos de solo lectura (a continuaci√≥n se ofrece una descripci√≥n m√°s detallada del dispositivo del segmento). <br><br>  A su vez, esto da como resultado una "distribuci√≥n": la capacidad de dividir una gran cantidad de datos en peque√±os segmentos para realizar c√°lculos en paralelo (tanto en una m√°quina como en varias a la vez). <br><br>  Si necesita "actualizar" al menos una l√≠nea, deber√° volver a cargar todo el segmento nuevamente.  Es posible y todo est√° listo para esto.  Cada segmento tiene una versi√≥n, y un segmento con una versi√≥n m√°s nueva reemplazar√° autom√°ticamente al segmento con la versi√≥n anterior (sin embargo, si se requiere una actualizaci√≥n regular, entonces vale la pena reevaluar si Druid es adecuado para este caso de uso). <br><br>  Para describir el segmento del dispositivo, consideramos un ejemplo simple en la forma tabular habitual: <br><br><img src="https://habrastorage.org/webt/7l/pb/hw/7lpbhwalmq7ogn5qnaq2gjrkzua.png" width="600"><br><br>  En esta tabla, el n√∫mero de llamadas en dos cinco minutos de cuatro hosts (tenga en cuenta que para el host web1 hay dos l√≠neas en cada per√≠odo de cinco minutos). <br><br>  Todas las celdas de datos desde el punto de vista del druida se dividen en tres tipos: <br><br><ul><li>  marca de tiempo: marca de tiempo UTC en ms (en el ejemplo, es hora). </li><li>  m√©tricas es lo que necesita calcular (suma, m√≠nimo, m√°ximo, conteo, ...), y necesita conocerlas de antemano para cada tabla (en el ejemplo, esto es Llamadas, y calcularemos la suma). </li><li>  dimensiones: esto es lo que puede agrupar y filtrar (no necesita conocerlas de antemano y se puede cambiar sobre la marcha) (en el ejemplo, esto es Host). </li></ul><br>  Al insertar, todas las filas se agrupan por el conjunto completo de dimensiones + marca de tiempo, y si coinciden con cada una de las m√©tricas, se aplica "su" funci√≥n de agregaci√≥n (como resultado, no hay filas con el mismo conjunto de dimensiones + marca de tiempo).  Por lo tanto, nuestro ejemplo despu√©s de la inserci√≥n en el druida se ver√° as√≠: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/eb8/8b9/e64/eb88b9e64bdafc870ca39646e4c0a4fb.png" width="500"><br><br>  La marca de tiempo y todas las m√©tricas (en nuestro caso, es Tiempo y llamadas) se escribir√°n como matrices de n√∫meros de tipo largo (tambi√©n se admiten flotantes y dobles).  Para cada una de las dimensiones (en nuestro caso es Host), se crear√° un diccionario, un conjunto ordenado de cadenas (con nombres de host).  La columna del host se escribir√° como una matriz int, indicando los n√∫meros en el diccionario. <br><br>  Tenga en cuenta que despu√©s de insertar en el druida, se agregaron pares de l√≠neas para el host web1 con la misma marca de tiempo, y la cantidad total se registr√≥ en las llamadas (es imposible extraer los datos iniciales del druida). <br><br>  Se requieren √≠ndices para el filtrado r√°pido de datos, porque puede haber millones de filas y miles de hosts.  Los √≠ndices son mapas de bits, uno para cada l√≠nea en el diccionario. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f32/bb5/edd/f32bb5eddba3c14b6ef241057f061724.png" width="500"><br><br>  Las unidades indican los n√∫meros de l√≠nea en los que participa este host.  Para filtrar dos hosts, debe tomar dos mapas de bits, combinarlos a trav√©s de OR y seleccionar los n√∫meros de l√≠nea en unidades del mapa de bits resultante. <br><br><h2>  Un druida se compone de muchos componentes. </h2><br>  En primer lugar, tiene varias dependencias externas. <br><br><img src="https://habrastorage.org/webt/rd/zs/uo/rdzsuo03og7v4whzfi5rz4m6qss.png" width="400"><br><br><ol><li>  Almacenamiento  All√≠, Druid simplemente almacena los segmentos en forma comprimida.  Puede ser un directorio local, HDFS, Amazon S3.  Aqu√≠ solo se usa el espacio, no se realizan c√°lculos. </li><li>  Meta: una base de datos para la informaci√≥n Meta.  Esta base de datos almacena el mapa de datos completo: qu√© segmentos son relevantes, cu√°les est√°n desactualizados, qu√© ruta est√° almacenada. </li><li>  Usando ZooKeeper, el sistema realiza el descubrimiento y anuncia en qu√© nodos de druida qu√© segmentos est√°n disponibles para consulta. </li><li>  Cach√© de solicitudes ejecutadas, puede ser memcached o cach√© local en java heap. </li></ol><br>  En segundo lugar, el propio druida consta de varios tipos de componentes. <br><br><ol><li>  Los nodos en tiempo real cargan el flujo de datos nuevos en el orden en que se reciben y atienden las solicitudes. </li><li>  Los nodos hist√≥ricos contienen toda la masa de datos y sirven solicitudes para ello.  Cuando decimos que tenemos un cl√∫ster de 300 TB, nos referimos a nodos hist√≥ricos. </li><li>  Broker es responsable de distribuir los c√°lculos entre nodos hist√≥ricos y en tiempo real. </li><li>  El Coordinador es responsable de asignar segmentos entre los nodos hist√≥ricos y de la replicaci√≥n. </li><li>  Servicio de indexaci√≥n, que le permite (re) cargar datos en lotes, por ejemplo, para "actualizar" parte de los datos. </li></ol><br><h2>  Flujo de datos </h2><br><img src="https://habrastorage.org/webt/gh/yg/pc/ghygpcnsakfac9x6dqrjtjjagdc.png" width="400"><br>  <i>Las flechas en negrita indican una secuencia de datos, las flechas delgadas indican una secuencia de metadatos.</i> <br><br>  Un nodo en tiempo real toma datos, √≠ndices y cortes en segmentos por tiempo, por ejemplo, por d√≠a. <br><br>  Cada nuevo segmento de un nodo en tiempo real escribe en el almacenamiento y deja una copia para atender las solicitudes.  Luego registra metadatos de que un nuevo segmento ha aparecido en el repositorio a lo largo de tal y tal camino. <br><br>  El coordinador recibe esta informaci√≥n, releyendo peri√≥dicamente la base de metadatos.  Cuando encuentra un nuevo segmento, (a trav√©s de ZooKeeper) ordena varios nodos hist√≥ricos para descargar este segmento.  Se descargan y (a trav√©s de ZooKeeper) anuncian que tienen un nuevo segmento.  Cuando un nodo en tiempo real recibe este mensaje (a trav√©s de ZooKeeper), elimina su copia para dejar espacio para nuevos datos. <br><br><h2>  Procesamiento de solicitudes </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/c1f/8f5/e8f/c1f8f5e8fcc11c157c7ab10311ae977a.png"><br><br>  Tres tipos de nodos participan en el procesamiento de solicitudes: intermediario, en tiempo real e hist√≥rico.  La solicitud llega al agente, que sabe en qu√© nodos qu√© segmentos se encuentran.  Distribuye la solicitud por nodos hist√≥ricos (y en tiempo real) que almacenan los segmentos deseados.  Los nodos hist√≥ricos tambi√©n paralelizan los c√°lculos tanto como sea posible, env√≠an los resultados al intermediario y √©l se los entrega al cliente.  Al combinar este esquema con el almacenamiento de datos en columna, Druid puede procesar grandes cantidades de informaci√≥n muy r√°pidamente. <br><br><h2>  Alta disponibilidad </h2><br>  Como recordar√°, Druid en la lista de dependencias tiene una base para los metadatos, que pueden ser MySQL o PostgreSQL.  Tambi√©n se menciona Apache Derby, pero este producto no se puede usar para la producci√≥n, solo para el desarrollo (seg√∫n tengo entendido, el derby se usa en una forma incrustada, para no generar mysql / pgsql en un entorno virgen). <br><br>  ¬øQu√© suceder√° si esta base falla (y / o el almacenamiento y / o el coordinador)?  Un nodo en tiempo real no puede escribir metadatos (y / o segmentos).  Entonces el coordinador no podr√° volver a leerlos y no encontrar√° un nuevo segmento.  El nodo hist√≥rico no lo descargar√° y el nodo en tiempo real no eliminar√° su copia, pero continuar√° descargando los √∫ltimos datos.  Como resultado, los datos comenzar√°n a acumularse en nodos en tiempo real.  Esto no puede continuar indefinidamente.  Sin embargo, se sabe qu√© recursos est√°n disponibles en los nodos en tiempo real y qu√© tipo de flujo de datos tenemos.  Por lo tanto, tenemos una cantidad de tiempo predecible por la cual podemos arreglar la base fallida (y / o almacenamiento y / o coordinador). <br><br>  Dado que los mysql / pgsql compatibles no garantizan una alta disponibilidad inmediata, decidimos jugar de forma segura y utilizamos nuestra propia soluci√≥n (ya hecha) basada en Cassandra, ya que ofrece una alta disponibilidad (puede leer m√°s sobre esto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> ). <br><br>  Adem√°s, finalizamos los nodos en tiempo real de tal manera que con una acumulaci√≥n excesiva, los datos m√°s antiguos se eliminan, liberando espacio para los nuevos.  Esto es muy importante para nosotros, porque la situaci√≥n en la que no podemos elevar la base fallida (y / o el almacenamiento y / o el coordinador) durante mucho tiempo y se acumulan muchos datos es muy probablemente una consecuencia de un gran accidente.  Y en este momento, los √∫ltimos datos son los m√°s importantes. <br><br><h2>  Druida y ZooKeeper </h2><br>  Con ZooKeeper, todo es mejor y peor.  Mejor porque ZooKeeper es tolerante a fallas, tiene replicaci√≥n lista para usar.  Parece que eso podr√≠a pasar? <br><br>  En t√©rminos generales, este cap√≠tulo ya no es relevante.  Y esta no es una historia de √©xito, es un dolor que (tanto nosotros como el druida reciente) decidimos eliminar radicalmente casi todos los datos de ZooKeeper, y ahora los nodos de druida los solicitan directamente entre s√≠ a trav√©s de HTTP. <br><br>  ZooKeeper tiene dos tipos de tiempos de espera.  El tiempo de espera de conexi√≥n es un tiempo de espera de red simple, despu√©s del cual el cliente se vuelve a conectar a ZooKeeper e intenta restaurar su sesi√≥n.  Y el tiempo de espera de la sesi√≥n, despu√©s del cual la sesi√≥n se elimina y todos los datos <i>ef√≠meros</i> creados dentro de esta sesi√≥n tambi√©n se eliminan (por el propio ZooKeeper), que se notifica a todos los dem√°s clientes de ZooKeeper. <br><br>  En base a esto, el descubrimiento en el druida funciona: al inicio, cada nodo crea una nueva sesi√≥n en ZooKeeper y registra datos <i>ef√≠meros</i> sobre s√≠ mismo: host: puerto, tipo de nodo (corredor / tiempo real / hist√≥rico / ...), marca de tiempo de conexi√≥n, etc. ... Otros nodos druidas reciben notificaciones de ZooKeeper y leen estos datos, para que sepan que un nuevo nodo druida ha aumentado y qu√© tipo de nodo es.  Si alg√∫n nodo druida cae despu√©s del tiempo de espera de su sesi√≥n, ZooKeeper eliminar√° los datos al respecto, y los dem√°s nodos druidas lo sabr√°n.  Para que lo aprendan m√°s r√°pido, preferimos poner un peque√±o tiempo de espera de sesi√≥n. <br><br>  Cuando se eleva un nodo en tiempo real o hist√≥rico, adem√°s de datos sobre s√≠ mismo, tambi√©n escribe en ZooKeeper una lista de segmentos que tiene (tambi√©n son datos <i>ef√≠meros</i> ).  M√°s adelante, se crean segmentos en nodos hist√≥ricos y en tiempo real, se eliminan los nuevos y viejos, y cada nodo refleja esto en su lista en ZooKeeper.  Esta lista puede ser grande, por lo que se divide en partes para que no se sobrescriba toda la lista, sino solo la parte modificada. <br>  El agente, a su vez, cuando ve un nuevo nodo en tiempo real o hist√≥rico, tambi√©n resta su lista de segmentos de ZooKeeper para distribuir las solicitudes a este nodo.  Los nodos en tiempo real leen esta lista para eliminar su copia del segmento que apareci√≥ en el nodo hist√≥rico.  Dado que la lista se divide en partes y se sobrescribe en partes, ZooKeeper le dir√° qu√© parte ha cambiado, solo que se volver√° a leer. <br><br>  Como dije, esta lista puede ser larga.  Cuando hay muchos datos en ZooKeeper, resulta que ya no es tan estable.  En nuestro caso, los problemas obvios comenzaron cuando el n√∫mero de segmentos alcanz√≥ los 7 millones, la instant√°nea de ZooKeeper luego ocup√≥ 6 GB. <br>  ¬øQu√© sucede si un nodo druida pierde contacto con ZooKeeper? <br><br>  Druid trabaja con ZooKeeper de tal manera que en el caso de un tiempo de espera de sesi√≥n, cada nodo crea una nueva sesi√≥n y escribe todos sus datos all√≠ y vuelve a leer los datos de otros nodos.  Como hay muchos datos, el tr√°fico despega en ZooKeeper.  Esto puede llevar a un tiempo de espera en otros nodos del druida, luego ellos tambi√©n comienzan a reescribir y volver a leer.  Por lo tanto, el tr√°fico crece como una avalancha hasta el punto de que ZooKeeper pierde la sincronizaci√≥n entre sus instancias y comienza a generar instant√°neas de un lado a otro. <br><br>  ¬øQu√© ve el usuario en este momento? <br><br>  Cuando un corredor pierde contacto con ZooKeeper (y se produce un tiempo de espera de sesi√≥n), ya no sabe en qu√© segmentos se encuentran los nodos hist√≥ricos.  Y da respuestas vac√≠as.  Es decir, si ZooKeeper est√° inactivo, Druid no funciona.  Es completamente imposible "curarlo", pero es posible esparcir popotes en algunos lugares. <br>  En primer lugar, puede eliminar datos de ZooKeeper.  Est√° bien si se pierden: Druid simplemente los sobrescribir√°.  Si el problema con ZooKeeper ya ha comenzado, para su soluci√≥n m√°s r√°pida, se recomienda desactivar ZooKeeper, eliminar los datos y dejarlos vac√≠os, y no esperar a que se resuelva por s√≠ solo. <br><br>  Ahora estamos aumentando el tiempo de espera de la sesi√≥n.  ¬øQu√© pasa en este caso? <br><br>  Supongamos que un nodo hist√≥rico se reinicia incorrectamente y no elimina la sesi√≥n anterior de ZooKeeper, mientras crea uno nuevo y escribe un mont√≥n de datos all√≠.  Mientras la sesi√≥n anterior todav√≠a est√° activa y el tiempo de espera no ha pasado, dos copias de los datos se almacenan en ZooKeeper.  Si hay muchos de estos nodos reiniciados inmediatamente, se duplicar√°n muchos datos.  Por lo tanto, debe mantener un suministro de memoria para ZooKeeper para que no se agote y ZooKeeper no deje de funcionar.  ¬øPor qu√© no se pudieron eliminar los datos de la sesi√≥n anterior? <br><br>  Por la misma raz√≥n, es necesario completar correctamente la operaci√≥n de los nodos hist√≥ricos, ya que en ese momento eliminan sus datos de ZooKeeper y pueden hacerlo durante mucho tiempo.  La finalizaci√≥n de los nodos hist√≥ricos lleva aproximadamente media hora. <br><br>  Los nodos hist√≥ricos tienen una caracter√≠stica m√°s.  Cuando comienzan, observan qu√© segmentos est√°n almacenados en ellos, y luego la informaci√≥n sobre esto se escribe en ZooKeeper.  Y dado que los datos se distribuyen de manera m√°s o menos uniforme en los nodos hist√≥ricos, si los ejecuta al mismo tiempo, comenzar√°n a escribir en ZooKeeper aproximadamente al mismo tiempo.  De nuevo, esto aumenta la probabilidad de un crecimiento del tr√°fico y tiempos de espera similares a las olas.  Por lo tanto, debe ejecutar nodos hist√≥ricos secuencialmente para difundir las sesiones de grabaci√≥n en ZooKeeper a tiempo. <br><br>  Tambi√©n hicimos dos optimizaciones m√°s: <br><br><ul><li>  Reprogramamos ligeramente el trabajo con ZooKeeper para que solo los nodos que los necesitan fueran le√≠dos de Druid.     realtime,   ,    .    ,        .          ,    . </li><li>  ,    ZooKeeper,       ,     .      ZooKeeper  6   2  (  ). </li></ul><br>          8 ;         . <br><br><h2>   Druid </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/2f4/71b/9a9/2f471b9a9927b4075e3dcc9bba8333cc.png"><br><br>     realtime    ,      .      - (   , , ).       ,     MMAP (   ).          .     . <br><br> -, realtime-   ,       JVM    ,      . <br><br><img src="https://habrastorage.org/webt/on/uk/w1/onukw1xyab_eojgwxynlsxjr6qc.png" width="500"><br><br>    .         : 1)     2)       .       ,       . ,  ,  .     ,   ,      ,  . (  ,      ,   ). <br><br>    ,    realtime-       ,     , ..      ,     ,   ,     (  ). <br><br>  ,     .       ,      ,  . <br><br>     ,       Druid   .    ,       ,       ,     . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f32/bb5/edd/f32bb5eddba3c14b6ef241057f061724.png" width="500"><br><br>  ,      . ,          (web%, api%). <br><br><ul><li> Druid     ‚Äî  .           . </li><li>   ,      . </li><li>  Druid   ,  ,    :   ,  , ,    . </li><li>   Druid        ,   ,        calls. </li></ul><br>     ,     5 %     ,  95 % ‚Äî  . <br><br>  ,  ,  realtime-         . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/76b/30d/618/76b30d618474a0cd9afdf6aa40af6b90.png" width="500"><br><br>   ,   ( 10:45)  .  -   ,   -.  ,    ( 10:50)  ,   -.  Y as√≠ sucesivamente.    ,   ,   ¬´calls¬ª, ¬´time¬ª  ¬´host¬ª     . <br>       -.         ,    ¬´¬ª      .    ,    ,      .          (   95% )      ,    :   ,    .         100 ,          1000. <br><br>     ?    ,   . ,          realtime ,     .      (..      historical     realtime-),     . <br><br>    ,         :          . ,       ,    .    100 . ,   .           . <br><br>    .  80% ,   ,      ,    .             .    .      ,     selector,            .      ,   . <br><br><h2>   </h2><br>   ,      ,  ,    . ,        .        , 8    .     Druid.   ,    ,    Druid,       .      ,        .  : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c6d/917/10e/c6d91710e3436dc0feede42b3138baa0.png" width="500"><br><br>      ,  ,  .       .     ,       ,   .    .   27  . ,    27 , 27 . <br><br>   ,   .       27   ,    9,  9 ,    . <br>       . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/710/585/fcb/710585fcb1dcf69e39a4a8e2faacc62f.png" width="500"><br><br>  ‚Äî : , , .   ‚Äî : , , .   ‚Äî :  ,  ,  .        ‚Äî ,        .    ,     .         ,      27.   9,  .          (   95% )    9 .        27    . <br><br>      14 . . ,      14 .   14 . .  ,          ,      10 ,     .    . <br><br><h2>   </h2><br>          ,  2 .       11   ,    74 .  ,       .        74 ?  ,         . <br> Druid    .      ,  ,    ,       .  ,         ,    .  ,    ,       .  ,    ,  . <br><br>    ,   Druid        .   ,      ( ) ,    .     5 :     ,       .       .          (     java),      .   Druid  ,    . <br><br><h2>  Resumen </h2><br>   , ,    SQL Server,       Microsoft. <br><br>     ,     /   . <br><br>         ,   ,       . <br><br>       20 ,          ,     18    . <br><br>       one-cloud ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://habr.com/company/odnoklassniki/blog/346868/</a> ),      . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es420469/">https://habr.com/ru/post/es420469/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es420459/index.html">Icono con un contador en la barra de herramientas superior: un ejemplo de una variedad de enfoques para una tarea</a></li>
<li><a href="../es420461/index.html">10 citas de malos dise√±adores</a></li>
<li><a href="../es420463/index.html">ICO merecidamente en declive, pero tienen la oportunidad de cambiar</a></li>
<li><a href="../es420465/index.html">Variables Nginx con njs: simple, indoloro y a trav√©s de JavaScript</a></li>
<li><a href="../es420467/index.html">Contenedor C ++ para "todos" los sistemas operativos en tiempo real para CortexM4</a></li>
<li><a href="../es420471/index.html">Tres informes t√©cnicos RIT 2018 de Plesk</a></li>
<li><a href="../es420473/index.html">Libros para gerentes novatos o por qu√© es tan importante leer</a></li>
<li><a href="../es420475/index.html">Comparaci√≥n de las m√°quinas de corte por l√°ser Raylogic 11G y Raylogic V12</a></li>
<li><a href="../es420477/index.html">Revisi√≥n de HyperX Cloud Stinger Core: un auricular ligero y resistente para personajes</a></li>
<li><a href="../es420479/index.html">Inyecci√≥n de dependencias en el servicio Apache Ignite.NET</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>