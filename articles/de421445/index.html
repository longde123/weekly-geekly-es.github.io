<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐥 👇🏼 🚹 Wir schreiben einen einfachen Übersetzer in Lisp - II ✋🏾 🏚️ 👩‍👩‍👧‍👧</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vorheriger Artikel 

 Wir implementieren den Zuweisungsoperator 
 Lassen Sie uns nun dem Übersetzer den Umgang mit dem Zuweisungsoperator beibringen. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wir schreiben einen einfachen Übersetzer in Lisp - II</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/421445/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vorheriger Artikel</a> <br><br><h3>  Wir implementieren den Zuweisungsoperator </h3><br>  Lassen Sie uns nun dem Übersetzer den Umgang mit dem Zuweisungsoperator beibringen.  Und hier stehen wir vor der klassischen Aufgabe, die Berechnung der algebraischen Formel in der uns seit unseren Schuljahren bekannten Notation sicherzustellen.  Wenn wir einen Interpreter erstellen würden, müssten wir den Wert der Formel berechnen.  In unserem Fall berechnet der Lisp-Kernel (zur Laufzeit).  Und wir müssen nur die Formel von der üblichen Notation in Lisp konvertieren. <br>  Die uns bekannte Notation heißt „Infix-Notation“ (das Operationszeichen befindet sich zwischen Operanden).  In Lisp wird das Operationszeichen vor den Operanden platziert (eine solche Notation wird als "Präfixnotation" bezeichnet).  Unsere Aufgabe ist es daher, das Infix-Formular in das Präfix-Formular zu konvertieren. <br><br>  Sie können dieses Problem auf verschiedene Arten lösen ... <br><a name="habracut"></a><br>  Ich schlage vor, die Formel in die sogenannte umzuwandeln  "Reverse Polish Form" (SCF).  Die umgekehrte polnische Notation (benannt nach dem polnischen Mathematiker Lukaschewitsch) ist eine nicht blockierende Form der Notation, bei der sich die Zeichen der Operationen hinter den Operanden befinden („Postfix-Notation“).  Die Übersetzung vom Postfix in das Präfixformular ist recht einfach.  Man könnte "das Problem in einer Aktion lösen" - sofort die Konvertierung von Infix zu Präfix implementieren.  Diese Entscheidung wäre jedoch etwas umständlicher.  Wer es wünscht, kann es jedoch selbst versuchen. <br><br>  Und wir werden uns mit der Transformation der Formel im SCR befassen.  Am Eingang haben wir eine algebraische Formel in Infixnotation, die in Form einer mehrstufigen Lisp-Liste dargestellt wird.  Zum Beispiel dieses: <br><br> <code>(12 + x / ( y ^ 2 + z ^ 4))</code> <br> <br>  In der SCR hat dieser Ausdruck die folgende (auf den ersten Blick seltsame) Form: <br><br> <code>(12 xy 2 ^ z 4 ^ + / +)</code> <br> <br>  Um den Wert der Formel in Form von SCR zu berechnen, benötigen Sie einen Stapel (eine Datenstruktur, die Daten nach dem Prinzip "last come - first go" speichert und liefert).  Die Berechnung ist sehr einfach.  Die Liste wird einmal gelesen.  Für jedes Element werden die folgenden Aktionen ausgeführt: <br><br><ul><li>  Die Anzahl (der variablen Werte) wird einfach auf den Stapel geschoben. </li><li>  Die Operation wird an der entsprechenden Anzahl von Operanden von der Oberseite des Stapels ausgeführt. </li></ul><br>  Bitte beachten Sie, dass der SCF keine Klammern enthält und die Operationen in der Reihenfolge ausgeführt werden, in der sie geschrieben wurden (Prioritäten wie in Infixform sind hier nicht mehr vorhanden). <br><br>  Der Ausdruck, den wir in SCR übersetzen möchten, kann Zahlen, Variablen, Funktionen und Operationszeichen enthalten.  Es gibt ein Problem - wie kann man eine Variable von einer Funktion unterscheiden?  Eine natürliche Möglichkeit, dieses Problem zu lösen, besteht darin, eine Liste aller Operationen und Funktionen zu erstellen und das erforderliche Zeichen in dieser Liste zu überprüfen: Wenn das Zeichen in der Liste gefunden wird, handelt es sich um eine Operation, andernfalls handelt es sich um eine Variable. <br>  Außerdem müssen Sie für jede Funktion / Operation ihre <b>Arität</b> (Anzahl der Argumente) speichern.  Eine grundlegende Liste von Operationen könnte folgendermaßen aussehen: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">setq</span></span> *oplist* '((+ <span class="hljs-number"><span class="hljs-number">2</span></span>) (- <span class="hljs-number"><span class="hljs-number">2</span></span>) (* <span class="hljs-number"><span class="hljs-number">2</span></span>) (/ <span class="hljs-number"><span class="hljs-number">2</span></span>) (^ <span class="hljs-number"><span class="hljs-number">2</span></span>) (\ <span class="hljs-number"><span class="hljs-number">2</span></span>) (% <span class="hljs-number"><span class="hljs-number">2</span></span>) (= <span class="hljs-number"><span class="hljs-number">2</span></span>) (== <span class="hljs-number"><span class="hljs-number">2</span></span>) (/= <span class="hljs-number"><span class="hljs-number">2</span></span>) (&gt; <span class="hljs-number"><span class="hljs-number">2</span></span>) (&gt;= <span class="hljs-number"><span class="hljs-number">2</span></span>) (&lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) (&lt;= <span class="hljs-number"><span class="hljs-number">2</span></span>) (and <span class="hljs-number"><span class="hljs-number">2</span></span>) (or <span class="hljs-number"><span class="hljs-number">2</span></span>) (not <span class="hljs-number"><span class="hljs-number">1</span></span>) (sin <span class="hljs-number"><span class="hljs-number">1</span></span>) (cos <span class="hljs-number"><span class="hljs-number">1</span></span>) (abs <span class="hljs-number"><span class="hljs-number">1</span></span>) (exp <span class="hljs-number"><span class="hljs-number">1</span></span>) (log <span class="hljs-number"><span class="hljs-number">1</span></span>) (sqrt <span class="hljs-number"><span class="hljs-number">1</span></span>)))</code> </pre><br>  Es ist zu beachten, dass sich diese Liste im Verlauf des Übersetzers erhöhen kann.  Tatsache ist, dass die Mini-Grundfunktionen Werte zurückgeben und an Ausdrücken teilnehmen können.  Die Namen dieser Funktionen und ihre Arität müssen zur Liste * oplist * hinzugefügt werden.  Dies kann in der action-proc-Prozedur in dem Zweig erfolgen, der die proc-Anweisung verarbeitet.  Die Variable * oplist * kann in der Startprozedur erstellt (und vor Abschluss zerstört) werden.  Das Hinzufügen einer Funktion zum Action-Proc-Code kann folgendermaßen implementiert werden: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">cond</span></span> ((<span class="hljs-name"><span class="hljs-name">eq</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> stmt) 'proc) (<span class="hljs-name"><span class="hljs-name">setq</span></span> proc-name (<span class="hljs-name"><span class="hljs-name">nth</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> stmt)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> proc-parm (<span class="hljs-name"><span class="hljs-name">nth</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> stmt)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *oplist* (<span class="hljs-name"><span class="hljs-name">cons</span></span> (<span class="hljs-name"><span class="hljs-name">list</span></span> proc-name (<span class="hljs-name"><span class="hljs-name">length</span></span> proc-parm)) *oplist*)))</code> </pre><br>  Jetzt muss für jede Operation, die in der Funktion ausgeführt wird, eine bestimmte Priorität festgelegt werden.  Prioritäten werden durch die folgende Funktion festgelegt: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> prty (<span class="hljs-name"><span class="hljs-name">OP</span></span>) (<span class="hljs-name"><span class="hljs-name">cond</span></span> ((<span class="hljs-name"><span class="hljs-name">EQ</span></span> OP 'and) <span class="hljs-number"><span class="hljs-number">1</span></span>) ((<span class="hljs-name"><span class="hljs-name">EQ</span></span> OP 'or) <span class="hljs-number"><span class="hljs-number">1</span></span>) ((<span class="hljs-name"><span class="hljs-name">EQ</span></span> OP '&gt;) <span class="hljs-number"><span class="hljs-number">2</span></span>) ((<span class="hljs-name"><span class="hljs-name">EQ</span></span> OP '&gt;=) <span class="hljs-number"><span class="hljs-number">2</span></span>) ((<span class="hljs-name"><span class="hljs-name">EQ</span></span> OP '&lt;) <span class="hljs-number"><span class="hljs-number">2</span></span>) ((<span class="hljs-name"><span class="hljs-name">EQ</span></span> OP '&lt;=) <span class="hljs-number"><span class="hljs-number">2</span></span>) ((<span class="hljs-name"><span class="hljs-name">EQ</span></span> OP '=) <span class="hljs-number"><span class="hljs-number">2</span></span>) ((<span class="hljs-name"><span class="hljs-name">EQ</span></span> OP '==) <span class="hljs-number"><span class="hljs-number">2</span></span>) ((<span class="hljs-name"><span class="hljs-name">EQ</span></span> OP '/=) <span class="hljs-number"><span class="hljs-number">2</span></span>) ((<span class="hljs-name"><span class="hljs-name">EQ</span></span> OP '+) <span class="hljs-number"><span class="hljs-number">3</span></span>) ((<span class="hljs-name"><span class="hljs-name">EQ</span></span> OP '-) <span class="hljs-number"><span class="hljs-number">3</span></span>) ((<span class="hljs-name"><span class="hljs-name">EQ</span></span> OP '*) <span class="hljs-number"><span class="hljs-number">4</span></span>) ((<span class="hljs-name"><span class="hljs-name">EQ</span></span> OP '/) <span class="hljs-number"><span class="hljs-number">4</span></span>) ((<span class="hljs-name"><span class="hljs-name">EQ</span></span> OP '\) <span class="hljs-number"><span class="hljs-number">4</span></span>) ((<span class="hljs-name"><span class="hljs-name">EQ</span></span> OP '%) <span class="hljs-number"><span class="hljs-number">4</span></span>) ((<span class="hljs-name"><span class="hljs-name">EQ</span></span> OP '^) <span class="hljs-number"><span class="hljs-number">5</span></span>) ((<span class="hljs-name"><span class="hljs-name">member</span></span> op (<span class="hljs-name"><span class="hljs-name">mapcar</span></span> 'car *oplist*)) <span class="hljs-number"><span class="hljs-number">6</span></span>)))</code> </pre><br>  Die logische Operation "und" und "oder" hat die niedrigste Priorität.  Dann gibt es Vergleichsoperationen, dann Addition und Subtraktion usw.  Funktionen haben die höchste Priorität. <br><br>  Nun beschreiben wir den Algorithmus zum Übersetzen des Ausdrucks in den SCR.  Die Funktion inf2ipn akzeptiert einen erforderlichen Parameter (Eingabeformel) und zwei optionale Parameter (Operationsstapel und Akkumulatorliste).  In der Batterieliste wird das Ergebnis akkumuliert.  Die Funktion durchsucht die Eingabeliste und verhält sich wie folgt: <br><br><ul><li>  Wenn das nächste Element eine Zahl oder eine Variable ist, wird es in die Batterie eingegeben. </li><li>  Wenn das nächste Element eine Liste ist, wird die Funktion rekursiv auf diese Liste angewendet und das Ergebnis zur Batterie hinzugefügt. </li><li>  Wenn das nächste Element eine Operation ist, wird bei einem leeren Stapel von Operationen das nächste Element auf den Operationsstapel verschoben.  Bei einem nicht leeren Operationsstapel wird die Priorität der eingehenden Operation mit der Oberseite des Operationsstapels verglichen.  Wenn eine Operation mit höherer Priorität eintrifft, wird sie auf den Operationsstapel verschoben. </li><li>  Wenn eine Operation mit einer Priorität ankommt, die nicht größer als die Oberseite des Stapels ist, wird die Oberseite des Stapel von Operationen an den Akkumulator übertragen, und die neu angekommene Operation wird in den Stapel von Operationen eingegeben. </li><li>  Wenn die Eingabeliste erschöpft ist und der Operationsstapel leer ist, gibt die Funktion eine umgekehrte Batterie zurück (Anschlusszweig).  Andernfalls gibt die Funktion eine umgekehrte Batterie mit einer zuvor angehängten Liste von Vorgängen vom Stapel zurück. </li></ul><br>  Die Funktion, die die Operation vom Operanden unterscheidet, ist sehr einfach - es kommt darauf an, zu überprüfen, ob das angegebene Zeichen in der globalen * oplist * -Liste enthalten ist: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> is-op (<span class="hljs-name"><span class="hljs-name">o</span></span>) (<span class="hljs-name"><span class="hljs-name">member</span></span> o (<span class="hljs-name"><span class="hljs-name">mapcar</span></span> 'car *oplist*)))</code> </pre><br>  Und die Übertragungsfunktion im SCR hat die Form: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> inf2ipn (<span class="hljs-name"><span class="hljs-name">f</span></span> <span class="hljs-symbol"><span class="hljs-symbol">&amp;optional</span></span> (<span class="hljs-name"><span class="hljs-name">s</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">r</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)) (<span class="hljs-name"><span class="hljs-name">cond</span></span> ((<span class="hljs-name"><span class="hljs-name">null</span></span> f) (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">null</span></span> s) (<span class="hljs-name"><span class="hljs-name">reverse</span></span> r) (<span class="hljs-name"><span class="hljs-name">inf2ipn</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> (<span class="hljs-name"><span class="hljs-name">cdr</span></span> s) (<span class="hljs-name"><span class="hljs-name">cons</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> s) r)))) ((<span class="hljs-name"><span class="hljs-name">listp</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> f)) (<span class="hljs-name"><span class="hljs-name">inf2ipn</span></span> (<span class="hljs-name"><span class="hljs-name">cdr</span></span> f) s (<span class="hljs-name"><span class="hljs-name">append</span></span> (<span class="hljs-name"><span class="hljs-name">reverse</span></span> (<span class="hljs-name"><span class="hljs-name">inf2ipn</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> f))) r))) ((<span class="hljs-name"><span class="hljs-name">numberp</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> f)) (<span class="hljs-name"><span class="hljs-name">inf2ipn</span></span> (<span class="hljs-name"><span class="hljs-name">cdr</span></span> f) s (<span class="hljs-name"><span class="hljs-name">cons</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> f) r))) ((<span class="hljs-name"><span class="hljs-name">not</span></span> (<span class="hljs-name"><span class="hljs-name">is-op</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> f))) (<span class="hljs-name"><span class="hljs-name">inf2ipn</span></span> (<span class="hljs-name"><span class="hljs-name">cdr</span></span> f) s (<span class="hljs-name"><span class="hljs-name">cons</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> f) r))) (<span class="hljs-name"><span class="hljs-name">t</span></span> (<span class="hljs-name"><span class="hljs-name">cond</span></span> ((<span class="hljs-name"><span class="hljs-name">null</span></span> s) (<span class="hljs-name"><span class="hljs-name">inf2ipn</span></span> (<span class="hljs-name"><span class="hljs-name">cdr</span></span> f) (<span class="hljs-name"><span class="hljs-name">cons</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> f) s) r)) ((<span class="hljs-name"><span class="hljs-name">&gt;</span></span> (<span class="hljs-name"><span class="hljs-name">prty</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> f)) (<span class="hljs-name"><span class="hljs-name">prty</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> s))) (<span class="hljs-name"><span class="hljs-name">inf2ipn</span></span> (<span class="hljs-name"><span class="hljs-name">cdr</span></span> f) (<span class="hljs-name"><span class="hljs-name">cons</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> f) s) r)) (<span class="hljs-name"><span class="hljs-name">t</span></span> (<span class="hljs-name"><span class="hljs-name">let</span></span> ((<span class="hljs-name"><span class="hljs-name">a</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> s))) (<span class="hljs-name"><span class="hljs-name">inf2ipn</span></span> (<span class="hljs-name"><span class="hljs-name">cdr</span></span> f) (<span class="hljs-name"><span class="hljs-name">cons</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> f) (<span class="hljs-name"><span class="hljs-name">cdr</span></span> s)) (<span class="hljs-name"><span class="hljs-name">cons</span></span> ar))))))))</code> </pre><br>  Sie können die Funktionalität dieser Funktion überprüfen, indem Sie sie direkt aufrufen: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">inf2ipn</span></span> '(<span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">3</span></span> * 6)) ==&gt; (2 3 6 * +) (<span class="hljs-name"><span class="hljs-name">inf2ipn</span></span> '((<span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">3</span></span>) * 6)) ==&gt; (2 3 + 6 *) (<span class="hljs-name"><span class="hljs-name">inf2ipn</span></span> '(<span class="hljs-number"><span class="hljs-number">3</span></span> + a * sin ( 5 + x))) ==&gt; (3 A 5 X + SIN * +)</code> </pre><br>  Das Abrufen eines Präfixeintrags von einem SCR ist recht einfach.  Die Funktion ipn2inf akzeptiert den Ausdruck im SCR und den Antriebsparameter.  Die Funktion funktioniert folgendermaßen: <br><br><ul><li>  Wenn die Eingabeliste leer ist, wird der Laufwerkskopf zurückgegeben. </li><li>  Wenn das nächste Element eine Zahl oder eine Variable ist, wird dieses Atom an das Laufwerk angehängt. </li><li>  Wenn das nächste Element eine Operation der Arität n ist, wird eine Liste, die aus dem Symbol dieser Operation und einem umgekehrten Segment des Laufwerks der Länge n besteht, ohne die ersten n Elemente an das Laufwerk angehängt. </li></ul><br>  So sieht es im Code aus: <br><br><pre> <code class="lisp hljs"><span class="hljs-comment"><span class="hljs-comment">;;    (defun arity (o) (iter (for a in *oplist*) (when (eq o (car a)) (return (cadr a))))) ;;      (defun ipn2pref (f &amp;optional (s nil)) (cond ((null f) (car s)) ((numberp (car f)) (ipn2pref (cdr f) (cons (car f) s))) ((is-op (car f)) (let ((ar (arity (car f)))) (ipn2pref (cdr f) (cons (cons (car f) (reverse (subseq s 0 ar))) (subseq s ar))))) (t (ipn2pref (cdr f) (cons (car f) s))))) ;; -,      (defun i2p (f) (ipn2pref (inf2ipn f)))</span></span></code> </pre><br>  Überprüfen Sie den Zustand des Codes: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">i2p</span></span> '(<span class="hljs-number"><span class="hljs-number">3</span></span> + a * sin ( 5 + x))) ==&gt; (+ 3 (* A (SIN (+ <span class="hljs-number"><span class="hljs-number">5</span></span> X)))) (<span class="hljs-name"><span class="hljs-name">i2p</span></span> '((<span class="hljs-number"><span class="hljs-number">3</span></span> + a) * sin ( 5 ) + x)) ==&gt; (* (+ <span class="hljs-number"><span class="hljs-number">3</span></span> A) (+ (SIN <span class="hljs-number"><span class="hljs-number">5</span></span>) X)) (<span class="hljs-name"><span class="hljs-name">i2p</span></span> '((<span class="hljs-number"><span class="hljs-number">3</span></span> + a) * sin ( 5 ^ 2 - x ) + x)) ==&gt; (* (+ <span class="hljs-number"><span class="hljs-number">3</span></span> A) (+ (SIN (- (^ <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) X)) X))</code> </pre><br>  Jetzt muss nur noch der Handler des Zuweisungsoperators geschrieben und mit dem Prozedurhandler verbunden werden.  Der Zuweisungshandler kann wie folgt implementiert werden: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> action-set (<span class="hljs-name"><span class="hljs-name">meat</span></span>) (<span class="hljs-name"><span class="hljs-name">let</span></span> ((<span class="hljs-name"><span class="hljs-name">name-var</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> meat)) (<span class="hljs-name"><span class="hljs-name">r-value</span></span> (<span class="hljs-name"><span class="hljs-name">i2p</span></span> (<span class="hljs-name"><span class="hljs-name">cddr</span></span> meat)))) `(setq ,name-var ,r-value)))</code> </pre><br>  Der Fleischparameter soll sich auf die Listenzuordnung beziehen: <br><br><pre> <code class="lisp hljs">( = )</code> </pre> <br>  Die Erkennung des Zuweisungsoperators erfolgt in der Funktion action-proc, die folgende Form hat: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> action-proc (<span class="hljs-name"><span class="hljs-name">fi</span></span>) (<span class="hljs-name"><span class="hljs-name">let</span></span> ((<span class="hljs-name"><span class="hljs-name">stmt</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">proc-name</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">proc-parm</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">loc-var</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">lv</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) (<span class="hljs-name"><span class="hljs-name">body</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)) (<span class="hljs-name"><span class="hljs-name">loop</span></span> (<span class="hljs-name"><span class="hljs-name">setq</span></span> stmt (<span class="hljs-name"><span class="hljs-name">mk-intf</span></span> (<span class="hljs-name"><span class="hljs-name">getLine</span></span> fi))) (<span class="hljs-name"><span class="hljs-name">when</span></span> (<span class="hljs-name"><span class="hljs-name">null</span></span> stmt) (<span class="hljs-name"><span class="hljs-name">return</span></span> <span class="hljs-literal"><span class="hljs-literal">t</span></span>)) (<span class="hljs-name"><span class="hljs-name">cond</span></span> ((<span class="hljs-name"><span class="hljs-name">eq</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> stmt) 'proc) (<span class="hljs-name"><span class="hljs-name">setq</span></span> proc-name (<span class="hljs-name"><span class="hljs-name">nth</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> stmt)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> proc-parm (<span class="hljs-name"><span class="hljs-name">nth</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> stmt))) ((<span class="hljs-name"><span class="hljs-name">eq</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> stmt) 'end_proc) (<span class="hljs-name"><span class="hljs-name">return</span></span> <span class="hljs-literal"><span class="hljs-literal">t</span></span>)) ((<span class="hljs-name"><span class="hljs-name">eq</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> stmt) 'print) (<span class="hljs-name"><span class="hljs-name">setq</span></span> body (<span class="hljs-name"><span class="hljs-name">append</span></span> body (<span class="hljs-name"><span class="hljs-name">list</span></span> (<span class="hljs-name"><span class="hljs-name">cons</span></span> 'printline (<span class="hljs-name"><span class="hljs-name">cdr</span></span> stmt)))))) ((<span class="hljs-name"><span class="hljs-name">eq</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> stmt) 'input) (<span class="hljs-name"><span class="hljs-name">setq</span></span> body (<span class="hljs-name"><span class="hljs-name">append</span></span> body (<span class="hljs-name"><span class="hljs-name">list</span></span> (<span class="hljs-name"><span class="hljs-name">list</span></span> 'setq (<span class="hljs-name"><span class="hljs-name">cadr</span></span> stmt) (<span class="hljs-name"><span class="hljs-name">list</span></span> 'read) ))))) ((<span class="hljs-name"><span class="hljs-name">eq</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> stmt) 'local) (<span class="hljs-name"><span class="hljs-name">setq</span></span> loc-var (<span class="hljs-name"><span class="hljs-name">append</span></span> loc-var (<span class="hljs-name"><span class="hljs-name">cdr</span></span> stmt)))) ((<span class="hljs-name"><span class="hljs-name">eq</span></span> (<span class="hljs-name"><span class="hljs-name">cadr</span></span> stmt) '=) (<span class="hljs-name"><span class="hljs-name">setq</span></span> body (<span class="hljs-name"><span class="hljs-name">append</span></span> body (<span class="hljs-name"><span class="hljs-name">list</span></span> (<span class="hljs-name"><span class="hljs-name">action-set</span></span> stmt))))) (<span class="hljs-name"><span class="hljs-name">t</span></span> (<span class="hljs-name"><span class="hljs-name">printsline</span></span> (<span class="hljs-name"><span class="hljs-name">strCat</span></span> <span class="hljs-string"><span class="hljs-string">"****  "</span></span> (<span class="hljs-name"><span class="hljs-name">output</span></span> stmt) <span class="hljs-string"><span class="hljs-string">"  "</span></span>)) (<span class="hljs-name"><span class="hljs-name">setq</span></span> *flagerr* <span class="hljs-literal"><span class="hljs-literal">t</span></span>)))) (<span class="hljs-name"><span class="hljs-name">iter</span></span> (<span class="hljs-name"><span class="hljs-name">for</span></span> a in (<span class="hljs-name"><span class="hljs-name">setof</span></span> loc-var)) (<span class="hljs-name"><span class="hljs-name">collecting</span></span> (<span class="hljs-name"><span class="hljs-name">list</span></span> a <span class="hljs-number"><span class="hljs-number">0</span></span>) into lv)) `(defun ,proc-name ,proc-parm (let ,lv ,@body))))</code> </pre><br>  Lassen Sie uns die Leistung unseres Codes überprüfen.  Wir laden den Code in die Lisp-Umgebung, rufen die Startfunktion auf und übersetzen das folgende Verfahren: <br><br> <code>0001 proc main() <br> 0002 local x,y,z <br> 0003 x=3 <br> 0004 y=4 <br> 0005 z=x^2+y^2 <br> 0006 print z <br> 0007 end_proc <br></code> <br><br>  Mal sehen, was unser Übersetzer generiert hat: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">getd</span></span> 'main) ==&gt; (<span class="hljs-name"><span class="hljs-name">EXPR</span></span> NIL (<span class="hljs-name"><span class="hljs-name">LET</span></span> ((<span class="hljs-name"><span class="hljs-name">X</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>) (<span class="hljs-name"><span class="hljs-name">Y</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>) (<span class="hljs-name"><span class="hljs-name">Z</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>)) (<span class="hljs-name"><span class="hljs-name">SETQ</span></span> X <span class="hljs-number"><span class="hljs-number">3</span></span>) (<span class="hljs-name"><span class="hljs-name">SETQ</span></span> Y <span class="hljs-number"><span class="hljs-number">4</span></span>) (<span class="hljs-name"><span class="hljs-name">SETQ</span></span> Z (<span class="hljs-name"><span class="hljs-name">+</span></span> (^ X <span class="hljs-number"><span class="hljs-number">2</span></span>) (^ Y <span class="hljs-number"><span class="hljs-number">2</span></span>))) (<span class="hljs-name"><span class="hljs-name">PRINTLINE</span></span> Z)))</code> </pre><br>  Alles scheint richtig zu sein.  Rufen wir nun unsere Prozedur auf und erhalten das erwartete Ergebnis: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">main</span></span>) <span class="hljs-number"><span class="hljs-number">25</span></span> ==&gt; <span class="hljs-number"><span class="hljs-number">25</span></span></code> </pre><br>  Unser Übersetzer wird auch die eingebauten Funktionen korrekt handhaben.  Um dies zu überprüfen, führen wir beispielsweise den folgenden Code aus: <br><br> <code>0001 proc main() <br> 0002 local x,y,z,pi <br> 0003 pi=3.1415926535 <br> 0004 x=sin(pi/6) <br> 0005 y=cos(pi/6) <br> 0006 z=x^2+y^2 <br> 0007 print x <br> 0018 print y <br> 0019 print z <br> 0010 end_proc <br></code> <br><br>  Und wir bekommen: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">main</span></span>) <span class="hljs-number"><span class="hljs-number">0.499999999987039</span></span> <span class="hljs-number"><span class="hljs-number">0.866025403791922</span></span> <span class="hljs-number"><span class="hljs-number">1.0</span></span> ==&gt; <span class="hljs-number"><span class="hljs-number">1.0</span></span></code> </pre><br>  Unser Übersetzer wird vor unseren Augen lebendig! <br><br>  Wir waren jedoch sehr begeistert: Beim Streben nach dem Endziel haben wir überhaupt nicht über die Fehler nachgedacht, die der Benutzer (der Programmierer, der das Mini-Basic verwendet) machen kann.  Auf eine gute Weise mussten wir sofort über Fehler nachdenken, aber wir haben gerade angefangen zu arbeiten, sind nicht zu weit gegangen und es ist nicht zu spät, Fehlerbehandlung und -diagnose in den Code einzuführen.  Darüber hinaus ist es offensichtlich, dass „geringfügige Verbesserungen“ vorgeschlagen werden (unser Übersetzer verlangt beispielsweise, dass der Bediener genau eine Zeile belegt, was unpraktisch ist). <br><br>  Der folgende Artikel widmet sich all diesen Fragen. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><b>Fortsetzung folgt</b></a> <br><br>  Der Code für diesen Artikel kann hier heruntergeladen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">werden.</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de421445/">https://habr.com/ru/post/de421445/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de421433/index.html">Es dauerte genau einen Tag, bis der Server gestartet wurde.</a></li>
<li><a href="../de421435/index.html">"Warum machen wir das alle?" - Prisma-Schöpfer und ehemaliger VK-Projektleiter über sein neues geheimes Projekt</a></li>
<li><a href="../de421439/index.html">Die Japaner stellten einen Prototyp-Prozessor für Exaflops-Supercomputer vor: Wie der Chip funktioniert</a></li>
<li><a href="../de421441/index.html">Embox beginnt den Mount Elbrus zu besteigen</a></li>
<li><a href="../de421443/index.html">Neu in unserem Markt: Übersicht über Snom D385- und D785-IP-Telefone</a></li>
<li><a href="../de421447/index.html">Redmadrobot iOS Meetup</a></li>
<li><a href="../de421451/index.html">So schützen Sie Ihr Kind auf YouTube vor Müll und erstellen einen benutzerdefinierten Player mit einer weißen Liste von Kanälen</a></li>
<li><a href="../de421453/index.html">Situation: Sonos ging an die Öffentlichkeit und kann „den Raum verlassen“</a></li>
<li><a href="../de421455/index.html">Japan startet die weltweit erste klinische Studie mit Stammzellen unter Verwendung der Parkinson-Krankheit</a></li>
<li><a href="../de421461/index.html">Time Tracker für Google-Skripte, -Dokumente und -Tabellen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>