<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏾‍💼 🍖 🧠 Serverless and React 2: Sleight of Hand dan No Fraud 🍶 👏 💫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dapatkah saya memberi tahu pengembang front-end tentang arsitektur Serverless tanpa awan di dalam AWS (Amazon Web Services) dengan cara sederhana? Ken...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Serverless and React 2: Sleight of Hand dan No Fraud</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/417943/"> Dapatkah saya memberi tahu pengembang front-end tentang arsitektur Serverless tanpa awan di dalam AWS (Amazon Web Services) dengan cara sederhana?  Kenapa tidak  Mari kita membuat aplikasi AWS React / Redux, dan kemudian berbicara tentang pro dan kontra dari lambda AWS. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/wJcXVjemrEY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Materi ini didasarkan pada transkrip <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">laporan Marina Mironovich</a> dari konferensi musim semi HolyJS 2018 kami di St. Petersburg.</i> <br><a name="habracut"></a><br>  Secara resmi, Marina adalah pengembang terkemuka EPAM.  Sekarang dia bekerja di grup arsitek solusi untuk pelanggan dan karena ini berpartisipasi dalam sejumlah besar proyek.  Karena itu, akan lebih mudah bagi kami untuk menguraikan lingkaran minatnya saat ini daripada mendaftar semua teknologi yang digunakannya. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0e6/caf/b0d/0e6cafb0de05d040b8b7bc30ab969b34.jpg" align="left">  <i>Pertama-tama, saya tertarik pada semua teknologi cloud, khususnya, AWS, karena saya banyak bekerja dengan ini dalam produksi.</i>  <i>Tetapi saya mencoba mengikuti semua yang lain.</i> <i><br><br></i>  <i>Frontend adalah cinta pertamaku dan sepertinya selamanya.</i>  <i>Secara khusus, saya saat ini bekerja dengan Bereaksi dan Bereaksi Asli, jadi saya tahu sedikit tentang itu.</i>  <i>Saya juga mencoba melacak semua yang lainnya.</i>  <i>Saya tertarik pada segala sesuatu yang berkaitan dengan dokumentasi proyek, misalnya, diagram UML.</i>  <i>Karena saya adalah anggota dari kelompok arsitek solusi, saya harus melakukan banyak hal.</i> <i><br><br></i> <br><br><h2>  Bagian 1. Latar Belakang </h2><br>  Ide untuk berbicara tentang Serverless datang kepada saya sekitar setahun yang lalu.  Saya ingin berbicara tentang Serverless untuk pengembang front-end dengan mudah dan alami.  Agar Anda tidak memerlukan pengetahuan tambahan untuk menggunakannya, semakin banyak teknologi sekarang memungkinkan Anda untuk melakukan ini. <br><br>  Hingga taraf tertentu, idenya terwujud - saya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">berbicara tentang</a> Serverless di FrontTalks 2017. Tetapi ternyata 45 menit tidak cukup untuk cerita yang sederhana dan mudah dimengerti.  Oleh karena itu, laporan itu dibagi menjadi dua bagian, dan sekarang sebelum Anda adalah "seri" kedua.  Siapa yang tidak melihat yang pertama - jangan khawatir, ini tidak ada salahnya untuk memahami apa yang tertulis di bawah ini.  Seperti dalam acara TV yang layak, saya akan mulai dengan ringkasan dari bagian sebelumnya.  Lalu saya akan beralih ke jus itu sendiri - kita akan membuat aplikasi React / Redux.  Dan akhirnya, saya akan berbicara tentang pro dan kontra fungsi cloud pada prinsipnya (khususnya, AWS lambdas) dan apa lagi yang bisa dilakukan dengannya.  Saya berharap bagian ini akan bermanfaat bagi semua yang sudah terbiasa dengan lambda AWS.  Yang terpenting, dunia tidak berakhir dengan Amazon, jadi mari kita bicara tentang apa lagi yang ada di bidang fungsi cloud. <br><br><h3>  Apa yang akan saya gunakan </h3><br>  Untuk membuat aplikasi, saya akan menggunakan banyak layanan Amazon: <br><br><ol><li>  S3 adalah sistem file di awan.  Di sana kita akan menyimpan aset statis. <br></li><li>  IAM (hak akses untuk pengguna dan layanan) - secara implisit, tetapi akan digunakan di latar belakang sehingga layanan berkomunikasi satu sama lain. <br></li><li>  API Gateway (URL untuk mengakses situs) - Anda akan melihat URL tempat kami dapat memanggil lambda kami. <br></li><li>  CloudFormation (untuk penyebaran) - akan digunakan secara implisit di latar belakang. <br></li><li>  AWS Lambda - kami datang ke sini untuk ini. <br></li></ol><br><h3>  Apa itu serverless dan apa itu AWS Lambda? </h3><br>  Sebenarnya Serverless adalah penipuan besar, karena tentu saja ada server: di suatu tempat, semuanya dimulai.  Tetapi apa yang terjadi di sana? <br><br>  Kami sedang menulis fungsi, dan fungsi ini berjalan di server.  Tentu saja, itu tidak hanya dimulai begitu saja, tetapi juga dalam semacam wadah.  Dan, pada kenyataannya, fungsi ini dalam wadah di server disebut lambda. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6ad/2c6/ff1/6ad2c6ff181236d39a29121e8b607a96.png"></div><br>  Dalam kasus lambda, kita bisa melupakan servernya.  Saya bahkan akan mengatakan ini: ketika Anda menulis fungsi lambda, berbahaya untuk memikirkannya.  Kami tidak bekerja dengan lambda seperti yang kami lakukan dengan server. <br><br><h3>  Bagaimana cara menyebarkan lambda </h3><br>  Sebuah pertanyaan logis muncul: jika kita tidak memiliki server, bagaimana kita menggunakannya?  Ada SSH di server, kami mengunggah kode, meluncurkannya - semuanya baik-baik saja.  Apa yang harus dilakukan dengan lambda? <br><br>  <b>Opsi 1. Kami tidak dapat menyebarkannya.</b> <br><br>  AWS di konsol membuat IDE yang bagus dan lembut bagi kami, tempat kami dapat datang dan menulis fungsi di sana. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/08e/1cd/f73/08e1cdf73c5d5fec2c6315e0207e51ed.png"><br><br>  Itu bagus, tapi tidak bisa diperluas. <br><br>  <b>Opsi 2. Kita dapat membuat zip dan mengunduhnya dari baris perintah</b> <br><br>  Bagaimana cara kita membuat file zip? <br><br> <code>zip -r build/lambda.zip index.js [node_modules/] [package.json] <br></code> <br>  Jika Anda menggunakan node_modules, semua ini di-zip menjadi satu arsip. <br>  Lebih lanjut, tergantung pada apakah Anda membuat fungsi baru atau jika Anda sudah memiliki fungsi seperti itu, Anda melakukannya <br><br> <code>aws lambda create-function... <br></code> <br>  juga <br><br> <code>aws lambda update-function-code... <br></code> <br>  Apa masalahnya?  Pertama, AWS CLI ingin tahu apakah suatu fungsi sedang dibuat atau apakah Anda sudah memilikinya.  Ini adalah dua tim yang berbeda.  Jika Anda ingin memperbarui tidak hanya kode, tetapi juga beberapa atribut dari fungsi ini, masalah akan dimulai.  Jumlah perintah ini bertambah, dan Anda harus duduk dengan direktori dan memikirkan perintah mana yang harus digunakan. <br><br>  Kita bisa melakukannya dengan lebih baik dan lebih mudah.  Untuk ini, kami memiliki kerangka kerja. <br><br><h3>  Kerangka kerja AWS Lambda </h3><br>  Ada banyak kerangka kerja seperti itu.  Ini terutama AWS CloudFormation, yang bekerja bersama dengan AWS CLI.  CloudFormation adalah file Json yang menggambarkan layanan Anda.  Anda menggambarkannya dalam file Json, kemudian melalui AWS CLI mengatakan "eksekusi", dan secara otomatis akan membuat segalanya untuk Anda dalam layanan AWS. <br><br>  Tetapi masih sulit untuk tugas sederhana seperti merender sesuatu.  Di sini ambang entri terlalu besar - Anda perlu membaca struktur apa yang dimiliki CloudFormation, dll. <br><br>  Mari kita coba sederhanakan.  Dan di sini muncul berbagai kerangka kerja: APEX, Zappa (hanya untuk Python), Claudia.js.  Saya hanya mendaftarkan beberapa saja, secara acak. <br><br>  Masalah dan kekuatan kerangka kerja ini adalah bahwa mereka sangat terspesialisasi.  Jadi, mereka sangat pandai melakukan beberapa tugas sederhana.  Misalnya, Claudia.js sangat bagus untuk membuat API REST.  Dia akan membuat AWS memanggil API Gateway, dia akan membuat lambda untuk Anda, semuanya akan terkunci dengan indah.  Tetapi jika Anda perlu menerapkan sedikit lebih banyak, masalah mulai - Anda harus menambahkan sesuatu, membantu, mencari, dll. <br><br>  Zappa hanya ditulis untuk Python.  Dan saya ingin sesuatu yang lebih ambisius.  Dan inilah Terraform dan cinta Serverless-ku. <br><br>  Serverless berada di tengah-tengah antara CloudFormation yang sangat besar, yang dapat melakukan hampir semua hal, dan kerangka kerja yang sangat khusus ini.  Hampir semuanya dapat digunakan di dalamnya, tetapi melakukan semuanya masih cukup mudah.  Ini juga memiliki sintaks yang sangat ringan. <br><br>  Terraform, sampai taraf tertentu, merupakan analog dari CloudFormation.  Terraform adalah open source, di dalamnya Anda dapat menggunakan semuanya - baik, atau hampir semuanya.  Dan ketika AWS menciptakan layanan, Anda dapat menambahkan sesuatu yang baru di sana.  Tapi itu besar dan rumit. <br><br>  Sejujurnya, dalam produksi kami menggunakan Terraform, karena dengan Terraform semua yang kami miliki naik lebih mudah - Serverless tidak akan menjelaskan semua ini.  Tapi Terraform sangat kompleks.  Dan ketika saya menulis sesuatu untuk pekerjaan, saya pertama kali menulis di Serverless, mengujinya untuk kinerja, dan hanya setelah konfigurasi saya diuji dan diuji, saya menulis ulang di Terraform (ini "menyenangkan" selama beberapa hari lagi). <br><br><h3>  Tanpa server </h3><br>  Mengapa saya suka Serverless? <br><br><ol><li>  Serverless memiliki sistem yang memungkinkan Anda membuat plugin.  Menurut pendapat saya, ini adalah keselamatan dari segalanya.  Tanpa server - sumber terbuka.  Tetapi menambahkan sesuatu ke open source tidak selalu mudah.  Anda perlu memahami apa yang terjadi dalam kode yang ada, mematuhi pedoman, setidaknya codestyle, mengirimkan PR, mereka akan melupakan PR ini dan akan mengumpulkan debu selama tiga tahun.  Menurut hasil, Anda bercabang, dan ini akan berada di suatu tempat untuk Anda secara terpisah.  Semua ini sangat tidak sehat.  Tetapi ketika ada plugin, semuanya disederhanakan.  Anda perlu menambahkan sesuatu - Anda bertekad menciptakan plugin kecil Anda sendiri.  Untuk melakukan ini, Anda tidak perlu lagi memahami apa yang terjadi di dalam Serverless (jika ini bukan pertanyaan yang sangat khusus).  Anda cukup menggunakan API yang tersedia, di suatu tempat Anda menyimpan plugin atau menyebarkannya untuk semua orang.  Dan semuanya bekerja untuk Anda.  Selain itu, sudah ada kebun binatang besar plugin dan orang-orang yang menulis plugin ini.  Artinya, mungkin sesuatu sudah diputuskan untuk Anda. <br></li><li>  Serverless membantu menjalankan lambda secara lokal.  Kelemahan yang cukup besar dari lambda adalah AWS tidak berpikir tentang bagaimana kita akan men-debug dan mengujinya.  Tetapi Serverless memungkinkan Anda untuk menjalankan semuanya secara lokal, melihat apa yang terjadi (ia bahkan melakukan ini bersama dengan Gateway API). <br></li></ol><br><h3>  Demonstrasi </h3><br>  Sekarang saya akan menunjukkan bagaimana semua ini bekerja.  Selama satu setengah hingga dua menit berikutnya, kita akan dapat membuat layanan yang akan merender halaman HTML kita. <br>  Pertama, di folder baru, saya menjalankan SLS Buat template: <br><br> <code><br> mkdir sls-holyjs <br> cd sls-holyjs <br> sls create --template aws-nodejs-ecma-script <br></code> <br><img src="https://habrastorage.org/getpro/habr/post_images/4d2/620/2e5/4d26202e5337684014e9f43fb25771d3.png"><br><br> <code>npm install <br></code> <br><img src="https://habrastorage.org/getpro/habr/post_images/bee/67c/81f/bee67c81fbb0b19e21432a73b69751dc.png"><br><br>  Pengembang tanpa server menangani kami - memungkinkan untuk membuat layanan dari template.  Dalam hal ini, saya menggunakan <code>nodejs-ecma-script</code> , yang akan membuat beberapa file untuk saya, seperti konfigurasi webpack, package.json, beberapa fungsi dan serverless.yml: <br><br> <code>ls <br></code> <br><img src="https://habrastorage.org/getpro/habr/post_images/35b/6c6/86a/35b6c686a1fbe3e323ddb939147d1b3d.png"><br><br>  Saya tidak membutuhkan semua fitur.  Saya akan menghapus ganti nama pertama, kedua di holyjs: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/030/599/ae0/030599ae094881637ae09ee3daf33ffd.png"><br><br>  Saya akan sedikit mengubah serveless.yml, di mana saya memiliki deskripsi semua layanan yang diperlukan: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/85d/0ba/f9b/85d0baf9bad8e2918866f5a97c096017.png"><br><br>  Baiklah, maka saya akan memperbaiki respons yang mengembalikan fungsi: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e13/07a/d85/e1307ad8550ea44532f79e6db27d561c.png"><br><br>  Saya akan membuat HTML "Hello HolyJS" dan menambahkan pegangan untuk rendering. <br><br>  Selanjutnya: <br><br> <code>sls deploy <br></code> <br>  Dan voila!  Ada URL tempat saya dapat melihat di akses publik apa yang sedang dirender: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/228/4f3/b94/2284f3b9487a8d70a9244652d99874ff.png"><br><br>  Percaya, tapi verifikasi.  Saya akan pergi ke Konsol AWS dan memverifikasi bahwa saya telah membuat fungsi holyjs: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e62/458/e98/e62458e98369c7022c280c419f79be55.png"><br><br>  Seperti yang Anda lihat, sebelum menggunakan itu, Serverless akan membangunnya menggunakan webpack.  Selain itu, sisa infrastruktur yang dijelaskan di sana akan dibuat - API Gateway, dll. <br><br>  Ketika saya ingin menghapus ini: <br><br> <code>sls remove <br></code> <br>  Semua infrastruktur yang dijelaskan dalam serverless.yml akan dihapus. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ad7/8fb/f2d/ad78fbf2d65cbcaef9094673bcca4026.png"><br><br>  Jika seseorang berada di belakang proses yang dijelaskan di sini, saya mengundang Anda untuk sekadar meninjau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">laporan</a> saya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sebelumnya</a> . <br><br><h3>  Jalankan lambda secara lokal </h3><br>  Saya menyebutkan bahwa lambda dapat dijalankan secara lokal.  Ada dua opsi peluncuran di sini. <br><br>  <b>Opsi 1. Kami menjalankan semua yang ada di terminal</b> <br><br>  Kami mendapatkan apa yang dikembalikan fungsi kami. <br><br> <code><br> sls invoke local -f [fn_name] <br></code> <br>  <b>Opsi 2. Luncurkan lambda secara lokal tanpa server-offline</b> <br><br>  Jangan lupa, kami membuat aplikasi isomorfik, itu akan menjadi HTML dan CSS, jadi di terminal itu entah bagaimana tidak terlalu menarik untuk melihat garis HTML yang panjang.  Di sana Anda dapat memeriksa apakah fungsinya berfungsi.  Tetapi saya ingin menjalankan dan merender ini di browser.  Oleh karena itu, saya perlu banyak gateway API dengan lambda. <br><br>  Untuk melakukan ini, ada plugin serverless-offline terpisah yang akan meluncurkan lambda Anda pada beberapa port (ini ditulis), maka itu akan menampilkan URL di terminal di mana Anda dapat mengaksesnya. <br><br> <code>sls offline --port 8000 start <br></code> <br>  Bagian terbaiknya adalah ada hot reload.  Artinya, Anda menulis kode fungsi, memperbarui browser Anda dan Anda diperbarui apa fungsi kembali.  Anda tidak harus memulai kembali semuanya. <br><br>  Ini adalah ringkasan dari bagian pertama laporan.  Sekarang kita beralih ke bagian utama. <br><br><h2>  Bagian 2. Rendering dengan AWS </h2><br>  Proyek yang dijelaskan di bawah ini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sudah ada</a> di GitHub.  Jika Anda tertarik, Anda dapat mengunduh kode di sana. <br><br>  Mari kita mulai dengan cara kerjanya. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f03/f9d/a97/f03f9da976ac1723c15aad19dd631689.png"><br><br>  Misalkan ada pengguna - saya. <br><br><ul><li>  Saya membuka situs. <br></li><li>  Di URL tertentu, kami mengakses API gateway.  Saya ingin mencatat bahwa Gateway API sudah menjadi layanan AWS, kami sudah berada di awan. <br></li><li>  Gateway API akan memanggil lambda. <br></li><li>  Lambda akan membuat situs, dan semua ini akan kembali ke browser. <br></li><li>  Browser akan mulai membuat dan menyadari bahwa beberapa file statis hilang.  Kemudian ia akan beralih ke bucket S3 (sistem file kami, tempat kami akan menyimpan semua statika; di bucket S3 Anda dapat meletakkan semuanya - font, gambar, CSS, JS). <br></li><li>  Data dari bucket S3 akan kembali ke browser. <br></li><li>  Browser akan merender halaman. <br></li><li>  Semua orang senang. <br></li></ul><br>  Mari kita lakukan sedikit review kode dari apa yang saya tulis. <br><br>  Jika Anda pergi ke GitHub, Anda akan melihat struktur file berikut: <br><br> <code><b>lambda-react</b> <br> README.md <br> <b>config <br> package.json</b> <br> public <br> scripts <br> <b>serverless.yml <br> src</b> <br> yarn.lock <br></code> <br>  Semua ini secara otomatis dihasilkan dalam kit alat Bereaksi / Redux.  Bahkan, di sini kita hanya akan tertarik pada beberapa file dan mereka harus sedikit diperbaiki: <br><br><ul><li>  konfigurasi <br></li><li>  package.json <br></li><li>  serverless.yml - karena kami akan menggunakan, <br></li><li>  src - tidak ada tempat tanpa itu. <br></li></ul><br><h3>  Mari kita mulai dengan konfigurasi </h3><br>  Untuk menyatukan semuanya di server, kita perlu menambahkan webpack.config lain: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6c0/990/786/6c099078652d80adcdcb70518187644f.png"><br><br>  Webpack.config ini sudah akan dibuat untuk Anda jika Anda menggunakan templat.  Dan ada variabel <code>slsw.lib.entries</code> secara otomatis diganti, yang akan menunjuk ke penangan lambda Anda.  Jika mau, Anda bisa mengubahnya sendiri dengan menentukan sesuatu yang lain. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/535/90e/c6a/53590ec6ae4247d42bab7deca58a0b62.png"><br><br>  Kita perlu merender semuanya untuk node ( <code>target: 'node'</code> ).  Pada prinsipnya, semua loader lainnya tetap sama seperti untuk aplikasi Bereaksi reguler. <br><br><h3>  Lebih jauh ke package.json </h3><br>  Kami hanya akan menambahkan beberapa skrip - mulai dan bangun telah dibuat dengan React / Redux - tidak ada perubahan.  Tambahkan skrip untuk meluncurkan lambda dan skrip untuk menyebarkan lambda. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4e2/822/8c4/4e28228c43ebd1548ff77f0f2d3421a2.png"><br><br><h3>  serverless.yml </h3><br>  File yang sangat kecil - hanya 17 baris, semuanya di bawah ini: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0c5/404/6fa/0c54046fa5a2461532d6f7638aaf650b.png"><br><br>  Apa yang menarik bagi kita di dalamnya?  Pertama-tama, pawang.  Path lengkap ke file <code>src/lambda/handler</code> ( <code>src/lambda/handler</code> ) dan fungsi handler ditentukan melalui titik. <br><br>  Jika Anda benar-benar ingin, Anda dapat mendaftarkan beberapa penangan dalam satu file.  Juga di sini adalah jalur ke webpack, yang harus mengumpulkan semua ini.  Pada dasarnya, semuanya: sisanya sudah dihasilkan secara otomatis. <br><br><h3>  Yang paling menarik adalah src </h3><br>  Berikut ini adalah aplikasi React / Redux besar (dalam kasus saya ini tidak besar - ke halaman).  Dalam folder lambda tambahan adalah semua yang kita butuhkan untuk membuat lambda: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3f4/b29/61a/3f4b2961a0c6f9218b715d6f013c53bf.png"><br><br>  Ini adalah 2 file: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f10/df3/485/f10df348528805e990f1d781a2406226.png"><br><br>  Mari kita mulai dengan pawang.  Yang paling penting adalah baris 13.  Ini adalah renderer, yang merupakan lambda yang akan dipanggil di awan: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3dd/d02/4a2/3ddd024a27fe4ccd1d919885f56f1009.png"><br><br>  Seperti yang Anda lihat, fungsi <code>render ()</code> mengembalikan janji, dari mana semua pengecualian harus ditangkap.  Ini adalah kekhasan lambda, jika tidak lambda tidak akan segera berakhir, tetapi akan bekerja sampai batas waktu.  Anda harus membayar uang ekstra untuk kode yang sudah jatuh.  Untuk mencegah hal ini terjadi, Anda harus menyelesaikan lambda sedini mungkin - pertama-tama, tangkap dan tangani semua pengecualian.  Nanti kita akan kembali ke ini. <br><br>  Jika kami tidak memiliki kesalahan atau pengecualian, kami memanggil fungsi <code>createResponse</code> , yang mengambil lima baris.  Kami hanya menambahkan semua header sehingga ditampilkan dengan benar di browser: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1c3/15c/025/1c315c025f85e3d63a70a9843cb0a8d3.png"><br><br>  Hal yang paling menarik di sini adalah fungsi <code>render</code> , yang akan membuat halaman kita: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d3d/336/0b8/d3d3360b83d7d5c329c5177719029ba8.png"><br><br>  Fungsi ini datang kepada kita dari renderer.js.  Mari kita lihat apa yang ada di sana. <br><br>  Aplikasi isomorfik diberikan di sana.  Selain itu, ini diberikan pada server apa pun - tidak masalah apakah itu lambda atau tidak. <br><br>  Saya tidak akan memberi tahu Anda secara terperinci tentang apa itu aplikasi isomorfik, bagaimana merendernya, karena ini adalah topik yang sama sekali berbeda, dan ada orang yang mengatakannya lebih baik daripada saya.  Berikut adalah beberapa tutorial yang saya temukan dengan googling hanya dalam beberapa menit: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1e3/366/3d0/1e33663d08624d7649ae4cb084571b98.png"><br><br>  Jika Anda mengetahui laporan lain, Anda dapat memberi saran, saya akan memberikan tautan kepada mereka di Twitter saya. <br><br>  Agar tidak kehilangan siapa pun, saya hanya naik ke atas, ceritakan apa yang terjadi di sana. <br>  Pertama-tama, kita perlu membuat ini dengan HTML / React / Redux. <br><br>  Ini dilakukan melalui metode Bereaksi standar - <code>renderToString</code> : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/81f/69f/3e8/81f69f3e89005f3ff76e389a65a6d731.png"><br><br>  Selanjutnya kita perlu membuat gaya agar konten kita tidak berkedip.  Ini bukan tugas yang sangat sepele.  Ada beberapa paket npm yang menyelesaikannya.  Sebagai contoh, saya menggunakan <code>node-style-loader</code> , yang akan menggabungkan semuanya dalam <code>styleTag</code> , dan kemudian Anda dapat menempelkannya ke dalam HTML. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/509/827/653/509827653575b822318cc8746c893b1b.png"><br><br>  Jika ada paket yang lebih baik - itu adalah kebijaksanaan Anda. <br><br>  Selanjutnya kita harus melewati status Redux.  Karena Anda merender di server, Anda mungkin ingin mendapatkan beberapa data, dan Anda tidak ingin Redux bertanya kembali dan merendernya lagi.  Ini adalah tugas yang cukup standar.  Ada beberapa contoh di situs web Redux utama tentang cara melakukan ini: kita membuat objek dan kemudian meneruskannya melalui variabel global: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/732/726/151/7327261516c4747f0994c83f5237668b.png"><br>  Sekarang sedikit lebih dekat ke lambda. <br><br>  Maka perlu dilakukan penanganan kesalahan.  Kami ingin menangkap semuanya dan melakukan sesuatu dengan mereka, setidaknya menghentikan perkembangan lambda.  Misalnya, saya melakukan ini melalui <code>promise</code> : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fe4/eb4/827/fe4eb4827fd43e48c17a84767612da2d.png"><br><br>  Selanjutnya, kita perlu mengganti URL kita dengan file statis.  Dan untuk ini kita perlu mencari tahu di mana lambda berjalan - secara lokal atau di suatu tempat di awan.  Bagaimana cara mengetahuinya? <br><br>  Kami akan melakukan ini melalui variabel lingkungan: <br><br> <code><br> <br> … <br> const bundleUrl = process.env.NODE_ENV === 'AWS' ? <br> AWS_URL : LOCAL_URL; <br></code> <br>  Sebuah pertanyaan menarik: bagaimana variabel lingkungan berkumpul di lambda.  Sebenarnya cukup mudah.  Dalam yml, Anda dapat meneruskan variabel apa pun ke <code>environment</code> .  Ketika dikunci, mereka akan tersedia: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6bf/a6d/083/6bfa6d083ab79f39cf033342e7e1cec6.png"><br><br>  Nah, bonus - setelah kami menggunakan lambda, kami ingin menggunakan semua aset statis.  Untuk melakukan ini, kami telah menulis sebuah plugin di mana Anda dapat menetapkan keranjang S3 tempat Anda ingin menyebarkan sesuatu: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/784/43d/2a3/78443d2a3bcfbf351429efa9f98e9965.png"><br>  Secara total, kami membuat aplikasi isomorfik dalam waktu sekitar lima menit untuk menunjukkan bahwa ini semua mudah. <br><br>  Sekarang mari kita bicara sedikit tentang teori - pro dan kontra dari lambda. <br><br>  Mari kita mulai dengan yang buruk. <br><br><h3>  Kontra fungsi lambda </h3><br>  Minus mungkin termasuk (atau mungkin tidak) waktu awal yang dingin.  Misalnya, untuk lambda di Node.js yang kami tulis sekarang, waktu mulai yang dingin tidak berarti banyak. <br><br>  Grafik di bawah ini menunjukkan waktu mulai dingin.  Dan ini bisa menjadi masalah besar, terutama untuk Java dan C # (perhatikan titik-titik oranye) - Anda tidak ingin Anda butuh lima atau enam detik untuk memulai kode. <br><br>  Untuk Node.js, waktu mulai hampir nol - 30 - 50 ms.  Tentu saja, bagi sebagian orang ini mungkin juga menjadi masalah.  Tetapi fungsinya dapat dipanaskan (meskipun ini bukan topik laporan ini).  Jika ada yang tertarik dengan bagaimana tes ini dilakukan, selamat datang di acloud.guru, mereka akan memberi tahu Anda segalanya ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dalam artikel</a> ). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cb7/11b/185/cb711b1856839c3b9ee9d0a268e0b4cc.png"><br><br>  Jadi apa kerugiannya? <br><br><h3>  Batasan Ukuran Kode Fungsi </h3><br>  Kode harus kurang dari 50 MB.  Apakah mungkin untuk menulis fungsi sebesar itu?  Tolong jangan lupa tentang node_modules.  Jika Anda menghubungkan sesuatu, terutama jika ada file biner di sana, Anda dapat dengan mudah mencapai lebih dari 50 MB, bahkan untuk file zip.  Saya punya kasus seperti itu.  Tapi ini adalah alasan tambahan untuk melihat apa yang Anda sambungkan ke node_modules. <br><br><h3>  Keterbatasan Runtime </h3><br>  Secara default, fungsi ini dijalankan sesaat.  Jika tidak berakhir setelah satu detik, Anda akan memiliki batas waktu.  Tapi kali ini bisa ditingkatkan di pengaturan.  Saat membuat fungsi, Anda dapat mengatur nilainya menjadi lima menit.  Lima menit adalah tenggat waktu yang sulit.  Ini bukan masalah bagi situs.  Tetapi jika Anda ingin melakukan sesuatu yang lebih menarik pada lambdas, misalnya, memproses gambar, mengubah teks menjadi suara atau suara menjadi teks, dll., Perhitungan seperti itu dapat dengan mudah memakan waktu lebih dari lima menit.  Dan itu akan menjadi masalah.  Apa yang harus dilakukan?  Optimalkan atau tidak gunakan lambda. <br><br>  Hal menarik lain yang muncul sehubungan dengan batas waktu eksekusi lambda.  Ingat tata letak situs kami.  Semuanya bekerja dengan sempurna sampai produk datang dan berharap pada feed situs real time - untuk menampilkan berita secara real time.  Kita tahu bahwa ini diterapkan dengan WebSockets.  Tapi WebSockets tidak berfungsi selama lima menit, mereka harus disimpan lebih lama.  Dan di sini batas lima menit menjadi masalah. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4a3/baa/e78/4a3baae784a50a373e56e5e3652187c9.png"><br><br>  Sebuah komentar kecil.  Bagi AWS, ini bukan lagi masalah.  Mereka menemukan cara untuk mengatasi ini.  Tetapi berbicara secara umum, begitu soket web muncul, lambda bukanlah solusi untuk Anda.  Anda perlu beralih ke server lama yang baik lagi. <br><br><h3>  Jumlah fungsi paralel per menit </h3><br>  Di atas adalah batas 500 hingga 3.000, tergantung pada wilayah di mana Anda berada.  Menurut pendapat saya, di Eropa hampir 500. 3000 didukung di AS. <br><br>  Jika Anda memiliki situs yang sibuk dan Anda mengharapkan lebih dari tiga ribu permintaan per menit (yang mudah dibayangkan), ini menjadi masalah.  Tetapi sebelum kita berbicara tentang minus ini, mari kita bicara sedikit tentang bagaimana skala lambda. <br><br>  Permintaan datang kepada kami, dan kami mendapatkan lambda.  Sementara lambda ini dieksekusi, dua permintaan lagi datang kepada kami - kami mulai dua lambda lagi.  Orang-orang mulai datang ke situs kami, permintaan muncul dan lambdas diluncurkan, semakin banyak. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4a1/58e/a49/4a158ea4922c44333fbe590440dde1b3.png"><br><br>  Dengan melakukannya, Anda membayar waktu ketika lambda berjalan.  Misalkan Anda membayar satu sen untuk satu detik eksekusi lambda.  Jika Anda memiliki 10 lambda per detik, maka Anda akan membayar 10 sen untuk detik ini.  Jika Anda memiliki sejuta lambda berjalan per detik, itu sekitar 10 ribu dolar.  Sosok yang tidak menyenangkan. <br><br>  Oleh karena itu, AWS memutuskan bahwa mereka tidak ingin mengosongkan dompet Anda dalam sedetik jika Anda melakukan tes Anda dengan salah dan Anda memulai DDOS sendiri, menyebabkan lambda, atau orang lain datang untuk melakukan DDOS.  Oleh karena itu, batas tiga ribu ditetapkan - sehingga Anda memiliki kesempatan untuk menanggapi situasi tersebut. <br><br>  Jika memuat 3000 permintaan reguler untuk Anda, Anda dapat menulis dalam AWS dan mereka akan menaikkan batas. <br><br><h3>  Tanpa kewarganegaraan </h3><br>  Ini adalah yang terakhir, sekali lagi, minus yang kontroversial. <br><br>  Apa itu stateless?  Di sini muncul lelucon tentang ikan mas - mereka tidak memiliki konteks: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b03/c26/620/b03c26620417a57fec13f48b896c7ef9.png"><br><br>  Lambda, dipanggil untuk kedua kalinya, tidak tahu apa-apa tentang panggilan pertama. <br><br>  Mari saya tunjukkan sebuah contoh.  Katakanlah saya memiliki sistem - kotak hitam besar.  Dan sistem ini, antara lain, dapat mengirim SMS. <br><br>  Pengguna datang dan berkata: kirim nomor templat SMS 1. Dan sistem mengirimkannya ke perangkat nyata. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ad0/1e9/dea/ad01e9dead7ca1c6a23788c5179f1b3f.png"><br><br>  Pada titik tertentu, produk menyatakan keinginan untuk mencari tahu apa yang akan pergi ke sana, dan untuk memeriksa bahwa tidak ada yang rusak dalam sistem ini di mana pun.  Untuk melakukan ini, kami akan mengganti perangkat asli dengan semacam nomor tes - misalnya, Twilio dapat melakukan ini.  Dia akan memanggil Webhook, mengirim teks SMS, kami akan memproses teks SMS ini dalam aplikasi (kita perlu memeriksa bahwa templat kita telah menjadi SMS yang benar). <br><br>  Untuk memeriksa, kita perlu tahu apa yang dikirim - kita akan melakukan ini melalui aplikasi uji.  Tetap membandingkan dan menampilkan hasilnya. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5be/881/81f/5be88181fc05100d0f9000d2eb3be124.png"><br><br>  Mari kita coba melakukan hal yang sama pada lambda. <br><br>  Lambda akan mengirim SMS, SMS akan datang ke Twilio. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bce/e3d/499/bcee3d4993dc73090829810748f97ea4.png"><br><br>  Saya menarik garis putus-putus bukan karena kebetulan, karena SMS dapat kembali dalam hitungan menit, jam atau hari - tergantung operator Anda, artinya, ini bukan panggilan sinkron.  Pada saat ini, lambda akan melupakan segalanya, dan kami tidak akan dapat memeriksa SMS. <br><br>  Saya akan mengatakan bahwa ini bukan minus, tetapi fitur.  Skema dapat diulang.  Ada beberapa opsi untuk melakukan ini, saya akan menawarkan saya sendiri.  Jika kita memiliki stateless, dan kita ingin menyimpan sesuatu, maka kita pasti perlu menggunakan penyimpanan, misalnya, database, S3, tetapi apa pun yang akan menyimpan konteks kita. <br><br>  Dalam skema dengan penyimpanan SMS, itu akan dikirim ke nomor tes.  Dan ketika Webhook menyebutnya - saya sarankan memanggil, misalnya, lambda kedua, karena ini adalah fungsi yang sedikit berbeda.  Dan lambda kedua sudah bisa pergi dan mengambil SMS-ku yang masuk dari database, periksa dan tampilkan hasilnya. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d7f/fdc/2c3/d7ffdc2c3761dbadd4d2500daadd68db.png"><br><br>  Bingo! <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada awalnya, saya mengatakan bahwa Anda perlu melupakan server jika Anda menulis lambda. Saya bertemu orang-orang yang menulis di node.js dan digunakan untuk mengekspresikan server. Mereka suka mengandalkan cache, dan cache tetap di lambdas. Dan kadang-kadang, ketika mereka menguji, itu akan berhasil, dan kadang-kadang tidak. Bagaimana ini mungkin?</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Misalkan kita memiliki server, dan sebuah wadah dimulai di dalamnya. Meluncurkan wadah adalah operasi yang cukup mahal. Pertama, Anda harus membuat wadah ini. Hanya setelah dibuat, kode fungsi digunakan di sana dan dapat dieksekusi. Setelah fungsi Anda dieksekusi, wadah tidak terbunuh, karena AWS percaya bahwa Anda dapat memanggil fungsi ini lagi. AWS tidak pernah menulis berapa lama wadah itu hidup setelah fungsi berhenti. Kami melakukan eksperimen. Menurut pendapat saya, untuk simpul ini adalah tiga menit, untuk Jawa mereka dapat memegang wadah selama 12-15 menit. Tetapi ini berarti bahwa ketika fungsi berikutnya dipanggil, ia akan dipanggil dalam wadah yang sama dan di lingkungan yang sama. Jika Anda menggunakan cache node di suatu tempat, Anda membuat variabel di sana, dll. - jika Anda tidak membersihkannya, mereka akan tetap di sana. Jadi jika Anda menulis di lambda,maka Anda perlu melupakan cache secara umum, jika tidak Anda bisa masuk ke situasi yang tidak menyenangkan. Ini sulit untuk ditangkis.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Plus fungsi lambda </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jumlah mereka lebih sedikit, tetapi bagi saya mereka tampak lebih menyenangkan. </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pertama-tama, kami benar-benar lupa bahwa ada server. </font><font style="vertical-align: inherit;">Sebagai pengembang, saya menulis fungsi dalam javascript, dan hanya itu. </font><font style="vertical-align: inherit;">Saya yakin banyak dari Anda menulis fungsi dalam javascript, Anda tidak perlu tahu apa-apa lagi tentang ini.</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tidak perlu memikirkan cache, juga tentang penskalaan, vertikal atau horizontal. </font><font style="vertical-align: inherit;">Apa yang Anda tulis akan berhasil. </font><font style="vertical-align: inherit;">Tidak masalah jika satu orang datang ke situs Anda sebulan atau akan ada satu juta kunjungan.</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dalam kasus lambda AWS, mereka sudah memiliki integrasi sendiri dengan hampir semua server mereka (DynamoDB, Alexa, API Gateway, dll.). </font></font><br></li></ul><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Apa lagi yang bisa dilakukan pada lambdas? </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya memberikan contoh yang cukup standar - saya berbicara tentang rendering aplikasi isomorfik, karena pada dasarnya mereka menganggap lambdas sebagai REST API. </font><font style="vertical-align: inherit;">Tetapi saya ingin memberikan beberapa contoh lagi tentang apa yang dapat dilakukan dengan mereka, hanya untuk memberi Anda makanan untuk pemikiran dan imajinasi. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada prinsipnya, pada lambda Anda dapat melakukan apa saja ... dengan tanda bintang.</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Layanan HTTP adalah apa yang saya bicarakan. </font><font style="vertical-align: inherit;">REST API, setiap endpoint API adalah satu lambda. </font><font style="vertical-align: inherit;">Sangat cocok. </font><font style="vertical-align: inherit;">Terutama mengingat bagaimana perusahaan sering menggunakan node.js untuk membuat middleware. </font><font style="vertical-align: inherit;">Kami memiliki java yang melakukan semua penetapan biaya, lalu kami menulis layer pada js yang menangani permintaan dengan sangat mudah. </font><font style="vertical-align: inherit;">Ini dapat ditulis ulang dalam lambdas dan akan lebih keren.</font></font><br></li><li> IoT — ,   Alexa      - -,         ,  . <br></li><li> Chat Bots —    ,   IoT. <br></li><li> Image/Video conversions. <br></li><li> Machine learning. <br></li><li> Batch Jobs — -  ,  Batch Job     . <br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang, selain Amazon, Google, Azure, IBM, Twillio, hampir semua layanan besar ingin mengimplementasikan fungsi cloud di rumah mereka. Jika Roskomnadzor memblokir semuanya, kami memulai server favorit kecil di garasi kami dan menggunakan komputasi awan kami di sana. Untuk melakukan ini, kita perlu open source (terlebih lagi karena Anda harus membayar untuk layanan, dan open source gratis). Dan open source tidak tinggal diam. Mereka telah membuat sejumlah implementasi yang tidak realistis dari semua ini. Sekarang saya akan mengatakan kata-kata menakutkan untuk frontends - Docker Swarm, Kubernetes - semuanya bekerja seperti itu. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bagian terbaiknya adalah, pertama, fungsi cloud tetap sederhana. Jika Anda memiliki fungsi pada AWS atau lambdas, menerjemahkannya ke open source juga mudah.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tidak semua perkembangan tercantum di bawah ini. </font><font style="vertical-align: inherit;">Saya hanya memilih yang lebih besar dan lebih menarik. </font><font style="vertical-align: inherit;">Daftar lengkapnya sangat besar: banyak startup yang mulai mengerjakan topik ini sekarang:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fungsi besi </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fnproject </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Openfaas </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Apache OpenWhisk </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kubeless </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fisi </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Funktion </font></font><br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya mencoba Fnproject dan hanya menghabiskan beberapa jam untuk mentransfer aplikasi isomorfik ini ke Fnproject dan menjalankannya secara lokal dengan wadah Kubernetes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Masih terukur dengan cepat. </font><font style="vertical-align: inherit;">Anda akan memiliki banyak API Gateway (tentu saja, tanpa sisa layanan), tetapi Anda masih memiliki URL yang memanggil lambda. </font><font style="vertical-align: inherit;">Dan pada kenyataannya, hampir semua orang bisa melupakan server, seperti yang dijanjikan, kecuali satu orang yang akan menggunakan kerangka kerja ini dan mengkonfigurasi orkestrasi Kubernetes ini sehingga pengembang yang bahagia dapat menggunakannya nanti.</font></font><br><br><blockquote>  .   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a>  HolyJS 2018 Moscow,   24-25   .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a>      ,     Early Bird-. </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id417943/">https://habr.com/ru/post/id417943/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id417933/index.html">Minggu Keamanan 27: iPhone Palsu dan Harga Keamanan</a></li>
<li><a href="../id417935/index.html">Memo tentang Kecerdasan Buatan, Pembelajaran Mesin, Pembelajaran Dalam, dan Big Data</a></li>
<li><a href="../id417937/index.html">Apakah "besi" orang membuat perangkat lunak?</a></li>
<li><a href="../id417939/index.html">Optimalisasi rendering adegan dari kartun Disney "Moana". Bagian 4 dan 5</a></li>
<li><a href="../id417941/index.html">Di mana air dalam ketel menghilang?</a></li>
<li><a href="../id417945/index.html">Alat apa yang dimiliki probe surya Parker</a></li>
<li><a href="../id417947/index.html">Visualisasi data untuk proyek web Anda</a></li>
<li><a href="../id417949/index.html">Bagaimana saya menulis library C ++ 11 standar atau mengapa boost sangat menakutkan. Bab 4.2</a></li>
<li><a href="../id417951/index.html">Menulis Kode Java Ramah Kotlin</a></li>
<li><a href="../id417953/index.html">Tren dalam mendesain FPGA. Terjemahan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>