<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕰️ 👨‍🏫 🙌🏿 Wasmer: la bibliothèque Go la plus rapide pour exécuter le code WebAssembly 👩🏻‍✈️ 🍬 💿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="WebAssembly (wasm) est un format d'instruction binaire portable. Le même code wasm peut être exécuté dans n'importe quel environnement. Afin de prendr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wasmer: la bibliothèque Go la plus rapide pour exécuter le code WebAssembly</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/454518/">  WebAssembly (wasm) est un format d'instruction binaire portable.  Le même code wasm peut être exécuté dans n'importe quel environnement.  Afin de prendre en charge cette déclaration, chaque langue, plate-forme et système doit être capable d'exécuter un tel code, le rendant aussi rapide et sûr que possible. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/6b/ba/7g/6bba7gvszh2fqjm_zupvfk90fea.png"></a> <a name="habracut"></a><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Wasmer</a> est un runtime de wasm écrit en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Rust</a> .  De toute évidence, le wasmer peut être utilisé dans n'importe quelle application Rust.  L'auteur du document, dont nous publions la traduction aujourd'hui, dit que lui et d'autres participants au projet Wasmer ont mis en œuvre avec succès ce runtime de code wasm dans d'autres langues: <br><br><ul><li>  En <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">C et C ++,</a> cela est implémenté via des liaisons. </li><li>  En PHP, c'est une extension de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">php-ext-wasm</a> . </li><li>  En Python, il s'agit d'un package <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">wasmer</a> publié dans PyPi qui est en cours d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">élaboration dans le référentiel python-ext-wasm</a> . </li><li>  En Ruby, c'est le joyau du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">wasmer</a> que l'on trouve sur RubyGems.  Son code se trouve dans le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">référentiel ruby-ext-wasm</a> . </li></ul><br>  Ici, nous parlerons d'un nouveau projet - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">go-ext-wasm</a> , qui est une bibliothèque pour Go, conçue pour exécuter du code wasm binaire.  Il s'est avéré que le projet go-ext-wasm est beaucoup plus rapide que d'autres solutions similaires.  Mais n'allons pas de l'avant.  Commençons par une histoire sur la façon de travailler avec lui. <br><br><h2>  <font color="#3AC1EF">Appel des fonctions de wasm à partir de Go</font> </h2><br>  Pour commencer, installez wasmer dans un environnement Go (avec support cgo). <br><br><pre><code class="go hljs">export CGO_ENABLED=<span class="hljs-number"><span class="hljs-number">1</span></span>; export CC=gcc; <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> install github.com/wasmerio/<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>-ext-wasm/wasmer</code> </pre> <br>  Le projet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">go-ext-wasm</a> est une bibliothèque Go classique.  Lorsque vous travaillez avec cette bibliothèque, la construction d' <code>import "github.com/wasmerio/go-ext-wasm/wasmer"</code> . <br><br>  Passons maintenant à la pratique.  Nous allons écrire un programme simple qui se compile en wasm.  Nous utiliserons pour cela, par exemple, Rust: <br><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[no_mangle]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span></span>(x: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, y: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span> {   x + y }</code> </pre> <br>  Nous appelons le fichier avec le programme <code>simple.rs</code> , à la suite de la compilation de ce programme, nous obtenons le fichier <a href="">simple.wasm</a> . <br><br>  Le programme suivant, écrit en Go, exécute la fonction <code>sum</code> du fichier wasm, en lui passant les nombres 5 et 37 comme arguments: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> (   <span class="hljs-string"><span class="hljs-string">"fmt"</span></span>   wasm <span class="hljs-string"><span class="hljs-string">"github.com/wasmerio/go-ext-wasm/wasmer"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {   <span class="hljs-comment"><span class="hljs-comment">//   WebAssembly.   bytes, _ := wasm.ReadBytes("simple.wasm")   //    WebAssembly.   instance, _ := wasm.NewInstance(bytes)   defer instance.Close()   //    `sum`   WebAssembly.   sum := instance.Exports["sum"]   //        Go.   //   ,      ,  .   result, _ := sum(5, 37)   fmt.Println(result) // 42! }</span></span></code> </pre> <br>  Ici, un programme écrit en Go appelle une fonction à partir d'un fichier wasm qui a été obtenu en compilant du code écrit en Rust. <br><br>  L'expérience a donc été un succès, nous avons réussi à exécuter le code WebAssembly dans Go.  Il convient de noter que la conversion des types de données est automatisée.  Les valeurs Go transmises au code wasm sont converties en types WebAssembly.  Ce que la fonction wasm renvoie est converti en types Go.  Par conséquent, travailler avec des fonctions à partir de fichiers wasm dans Go ressemble à travailler avec des fonctions Go normales. <br><br><h2>  <font color="#3AC1EF">Fonctions d'appel à partir du code WebAssembly</font> </h2><br>  Comme nous l'avons vu dans l'exemple précédent, les modules WebAssembly sont capables d'exporter des fonctions qui peuvent être appelées de l'extérieur.  C'est le mécanisme qui permet au code wasm d'être exécuté dans divers environnements. <br><br>  Dans le même temps, les modules WebAssembly eux-mêmes peuvent fonctionner avec des fonctions importées.  Considérez le programme suivant écrit en Rust. <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> {   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span></span>(x: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, y: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>; } <span class="hljs-meta"><span class="hljs-meta">#[no_mangle]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add1</span></span></span></span>(x: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, y: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { sum(x, y) } + <span class="hljs-number"><span class="hljs-number">1</span></span> }</code> </pre> <br>  Nommez le fichier avec <code>import.rs</code> .  Le compiler dans WebAssembly se traduira par du code qui peut être trouvé <a href="">ici</a> . <br><br>  La fonction <code>add1</code> exportée appelle la fonction <code>sum</code> .  Il n'y a pas d'implémentation de cette fonction, seule sa signature est définie dans le fichier.  Il s'agit de la fonction dite externe.  Pour WebAssembly, il s'agit d'une fonction importée.  Son implémentation doit être importée. <br><br>  Nous implémentons la fonction <code>sum</code> utilisant Go.  Pour cela, nous devons utiliser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cgo</a> .  Voici le code résultant.  Certains commentaires, qui sont des descriptions des principaux fragments de code, sont numérotés.  Ci-dessous, nous en parlerons plus en détail. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-comment"><span class="hljs-comment">// // 1.    `sum` (   cgo). // // #include &lt;stdlib.h&gt; // // extern int32_t sum(void *context, int32_t x, int32_t y); import "C" import (   "fmt"   wasm "github.com/wasmerio/go-ext-wasm/wasmer"   "unsafe" ) // 2.    `sum`    ( cgo). //export sum func sum(context unsafe.Pointer, x int32, y int32) int32 {   return x + y } func main() {   //   WebAssembly.   bytes, _ := wasm.ReadBytes("import.wasm")   // 3.     WebAssembly.   imports, _ := wasm.NewImports().Append("sum", sum, C.sum)   // 4.     WebAssembly  .   instance, _ := wasm.NewInstanceWithImports(bytes, imports)   //    WebAssembly.   defer instance.Close()   //    `add1`   WebAssembly.   add1 := instance.Exports["add1"]   //   .   result, _ := add1(1, 2)   fmt.Println(result)   // add1(1, 2)   // = sum(1 + 2) + 1   // = 1 + 2 + 1   // = 4   // QED }</span></span></code> </pre> <br>  Analysons ce code: <br><br><ol><li>  La signature de la fonction <code>sum</code> est définie en C (voir le commentaire sur la commande d' <code>import "C"</code> ). </li><li>  L'implémentation de la fonction <code>sum</code> est définie dans Go (notez la ligne <code>//export</code> - ce mécanisme utilisé par cgo pour établir la connexion du code écrit en Go avec le code écrit en C). </li><li>  <code>NewImports</code> est une API utilisée pour créer des importations WebAssembly.  Dans ce code, <code>"sum"</code> est le nom de la fonction importée par WebAssembly, <code>sum</code> est le pointeur vers la fonction Go et <code>C.sum</code> est le pointeur vers la fonction cgo. </li><li>  Et enfin, <code>NewInstanceWithImports</code> est un constructeur conçu pour initialiser un module WebAssembly avec des importations. </li></ol><br><h2>  <font color="#3AC1EF">Lecture des données de la mémoire</font> </h2><br>  L'instance WebAssembly a une mémoire linéaire.  Parlons de la façon d'en lire les données.  Commençons, comme d'habitude, avec le code Rust, que nous appellerons <code>memory.rs</code> . <br><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[no_mangle]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">return_hello</span></span></span></span>() -&gt; *<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span> {   <span class="hljs-string"><span class="hljs-string">b"Hello, World!\0"</span></span>.as_ptr() }</code> </pre> <br>  Le résultat de la compilation de ce code se trouve dans le fichier <code>memory.wasm</code> , qui est utilisé ci-dessous. <br><br>  La fonction <code>return_hello</code> renvoie un pointeur sur une chaîne.  La ligne se termine, comme en C, par un caractère nul. <br><br>  Maintenant, allez sur le côté Go: <br><br><pre> <code class="go hljs">bytes, _ := wasm.ReadBytes(<span class="hljs-string"><span class="hljs-string">"memory.wasm"</span></span>) instance, _ := wasm.NewInstance(bytes) <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> instance.Close() <span class="hljs-comment"><span class="hljs-comment">//    `return_hello`. //      . result, _ := instance.Exports["return_hello"]() //      . pointer := result.ToI32() //    . memory := instance.Memory.Data() fmt.Println(string(memory[pointer : pointer+13])) // Hello, World!</span></span></code> </pre> <br>  La fonction <code>return_hello</code> renvoie un pointeur en tant que valeur <code>i32</code> .  Nous obtenons cette valeur en appelant <code>ToI32</code> .  Ensuite, nous obtenons les données de la mémoire en utilisant <code>instance.Memory.Data()</code> . <br><br>  Cette fonction renvoie la tranche de mémoire de l'instance WebAssembly.  Vous pouvez l'utiliser comme n'importe quelle tranche Go. <br><br>  Heureusement, nous connaissons la longueur de la ligne que nous voulons lire, donc, pour lire les informations nécessaires, il suffit d'utiliser la construction <code>memory[pointer : pointer+13]</code> .  Ensuite, les données lues sont converties en chaîne. <br><br>  <a href="">Voici</a> un exemple qui montre des mécanismes de mémoire plus avancés lors de l'utilisation du code WebAssembly de Go. <br><br><h2>  <font color="#3AC1EF">Repères</font> </h2><br>  Le projet go-ext-wasm, comme nous venons de le voir, dispose d'une API pratique.  Il est maintenant temps de parler de ses performances. <br><br>  Contrairement à PHP ou Ruby, le monde Go a déjà des solutions pour travailler avec du code wasm.  En particulier, nous parlons des projets suivants: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Life</a> from Perlin Network - Interprète WebAssembly. </li><li>  Go Interpreter's <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Wagon</a> est un interpréteur et une boîte à outils WebAssembly. </li></ul><br>  Le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">matériel</a> du projet php-ext-wasm a utilisé l'algorithme à <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">n corps</a> pour étudier les performances.  Il existe de nombreux autres algorithmes adaptés à l'examen des performances des environnements d'exécution de code.  Par exemple, il s'agit de l'algorithme de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Fibonacci</a> (version récursive) et de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">l'algorithme ρ de Pollard</a> utilisé dans Life.  Il s'agit de l'algorithme de compression Snappy.  Ce dernier fonctionne avec succès avec go-ext-wasm, mais pas avec Life ou Wagon.  En conséquence, il a été retiré de l'ensemble de test.  Le code de test peut être trouvé <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br>  Lors des tests, les dernières versions des projets de recherche ont été utilisées.  À savoir, ce sont Life 20190521143330-57f3819c2df0 et Wagon 0.4.0. <br><br>  Les nombres indiqués sur le graphique reflètent les valeurs moyennes obtenues après 10 démarrages du test.  L'étude a utilisé le MacBook Pro 15 pouces 2016 avec un processeur Intel Core i7 2,9 GHz et 16 Go de mémoire. <br><br>  Les résultats des tests sont regroupés le long de l'axe X en fonction des types de tests.  L'axe des Y indique le temps, en millisecondes, nécessaire pour terminer le test.  Plus l'indicateur est petit, mieux c'est. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/810/8c2/321/8108c23213493ab6ade095909770b58e.png"><br>  <i><font color="#999999">Comparaison des performances de Wasmer, Wagon et Life à l'aide d'implémentations de divers algorithmes</font></i> <br><br>  Les plateformes Life et Wagon, en moyenne, donnent à peu près les mêmes résultats.  Wasmer, en moyenne, est 72 fois plus rapide. <br><br>  Il est important de noter que Wasmer prend en charge trois <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">backends</a> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Singlepass</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Cranelift</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">LLVM</a> .  Le backend par défaut dans la bibliothèque Go est Cranelift ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> vous pouvez en savoir plus).  L'utilisation de LLVM donnera des performances proches de celles natives, mais il a été décidé de commencer par Cranelift, car ce backend donne le meilleur rapport entre le temps de compilation et le temps d'exécution du programme. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ici,</a> vous pouvez lire les différents backends, leurs avantages et leurs inconvénients, et dans quelles situations il est préférable de les utiliser. <br><br><h2>  <font color="#3AC1EF">Résumé</font> </h2><br>  Le projet open source <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">go-ext-wasm</a> est une nouvelle bibliothèque Go conçue pour exécuter du code wasm binaire.  Il comprend un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">runtime Wasmer</a> .  Sa première version comprend des API, dont le besoin se fait le plus souvent sentir. <br>  Les tests de performance ont montré que Wasmer, en moyenne, est 72 fois plus rapide que Life et Wagon. <br><br>  <b>Chers lecteurs!</b>  Envisagez-vous d'utiliser la possibilité d'exécuter du code wasm dans Go à l'aide de go-ext-wasm? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr454518/">https://habr.com/ru/post/fr454518/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr454506/index.html">Entropic - Nouveau registre de packages distribués pour Node.js</a></li>
<li><a href="../fr454508/index.html">Portage d'applications de bureau vers .NET Core</a></li>
<li><a href="../fr454512/index.html">Petit déjeuner avec Charles Weatherly, auteur du livre culte Etudes for Programmers</a></li>
<li><a href="../fr454514/index.html">Développement d'un synthétiseur musical simple sur ATMEGA8</a></li>
<li><a href="../fr454516/index.html">Comment obtenir un bon texte pour 200 roubles</a></li>
<li><a href="../fr454520/index.html">Consignes pour écrire du code JavaScript propre</a></li>
<li><a href="../fr454522/index.html">Node.js: gestion de la mémoire disponible pour les applications s'exécutant dans des conteneurs</a></li>
<li><a href="../fr454524/index.html">Réparation de bandeau Samsung Level On Pro</a></li>
<li><a href="../fr454530/index.html">DJI a créé un octocoptère qui peut faire des films</a></li>
<li><a href="../fr454532/index.html">Je vais dire un mot sur l'approche d'ingénierie</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>