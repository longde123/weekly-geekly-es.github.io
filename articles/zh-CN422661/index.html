<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌤️ 🙈 💼 使用http请求模块的示例在js中实际使用currying 👦🏻 🍚 🤸🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="大家好！ 在编程世界中，有许多技术，实践和编程模式（设计）对任何人来说都是秘密，但是，经常学习新知识，却不清楚在何处以及如何应用新知识。 


 今天，以创建一个小型包装器模块处理http请求的示例为例，我们将分析currying的真正好处-函数式编程的接收。 


 对于所有新手和有兴趣在实践中使...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>使用http请求模块的示例在js中实际使用currying</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/422661/"><p> 大家好！ 在编程世界中，有许多技术，实践和编程模式（设计）对任何人来说都是秘密，但是，经常学习新知识，却不清楚在何处以及如何应用新知识。 </p><br><p> 今天，以创建一个小型包装器模块处理http请求的示例为例，我们将分析currying的真正好处-函数式编程的接收。 </p><br><p> 对于所有新手和有兴趣在实践中使用函数式编程的人-欢迎，那些完全理解什么是currying的人-我期待您对代码的评论，因为正如他们所说-完美无止境。 <a name="habracut"></a></p><br><h2 id="itak-nachnem"> 所以我们开始吧 </h2><br><p> 但是，不是从“ curry”的概念出发，而是从问题的陈述出发，我们可以在哪里应用它。 </p><br><p> 我们有一个博客API会根据以下原则工作（与真实API的所有匹配都是偶然的）： </p><br><ul><li>对<code>/api/v1/index/</code>的请求将返回主页的数据 </li><li> 对<code>/api/v1/news/</code>的请求将返回新闻页面的数据 </li><li> 对<code>/api/v1/articles/</code>的请求将返回文章列表的数据 </li><li> 请求<code>/api/v1/article/222/</code>将返回ID为222的文章页面 </li><li> 对<code>/api/v1/article/edit/222/</code>的请求将返回ID为222的文章编辑表单 <br>  ...等等，更进一步 </li></ul><br><p> 如您所见，为了访问API，我们需要转到特定版本<strong>v1</strong> （它将增长多少并发布新版本）的<strong>api，</strong>然后进一步设计数据请求。 </p><br><p> 因此，在js代码中，要获取数据，例如，一篇<strong>ID为222的</strong>文章<strong>，</strong>我们必须编写（为简化示例，我们使用了本机js fetch方法）： </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">fetch</span></span>(<span class="hljs-string"><span class="hljs-string">'/api/v1/article/222/'</span></span>) .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-comment"><span class="hljs-comment">/* success */</span></span>) .catch(<span class="hljs-comment"><span class="hljs-comment">/* error */</span></span>)</code> </pre> <br><p> 要编辑同一篇文章，我们将要求您这样做： </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">fetch</span></span>(<span class="hljs-string"><span class="hljs-string">'/api/v1/article/edit/222/'</span></span>) .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-comment"><span class="hljs-comment">/* success */</span></span>) .catch(<span class="hljs-comment"><span class="hljs-comment">/* error */</span></span>)</code> </pre> <br><p> 当然，您已经注意到，在我们的请求中，有很多重复的路径。 例如，我们的API <code>/api/v1/</code>的路径和版本，并使用一个article <code>/api/v1/article/</code>和<code>/api/v1/article/edit/</code> 。 </p><br><h3 id="sleduya-nashemu-lyubimomu-pravilu-dry-dont-repeat-yourself-kak-optimizirovat-kod-zaprosov-k-api"> 遵循我们最喜欢的DRY（不要自己重复）规则，如何优化API请求代码？ </h3><br><p> 我们可以将查询部分添加到常量中，例如： </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> API = <span class="hljs-string"><span class="hljs-string">'/api'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> VERSION = <span class="hljs-string"><span class="hljs-string">'/v1'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ARTICLE = <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${API}</span></span></span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${VERSION}</span></span></span><span class="hljs-string">/article`</span></span></code> </pre> <br><p> 现在，我们可以通过以下方式重写上面的示例： </p><br><p>  <strong>文章要求</strong> </p><br><pre> <code class="hljs javascript">fetch(<span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${ARTICLE}</span></span></span><span class="hljs-string">/222/`</span></span>)</code> </pre> <br><p>  <strong>文章编辑要求</strong> </p><br><pre> <code class="hljs javascript">fetch(<span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${ARTICLE}</span></span></span><span class="hljs-string">/edit/222/`</span></span>)</code> </pre> <br><p> 代码似乎更少了，有一些与API相关的常量，但是您和我都知道可以更方便地完成操作。 </p><br><p> 我相信仍有解决问题的选项，但我们的任务是使用curring考虑解决方案。 </p><br><h2 id="princip-postroeniya-zaprosov-na-osnove-http-servisov"> 基于http服务构建请求的原则 </h2><br><p> 策略是通过调用我们将构造API请求的方法来创建某个函数。 </p><br><h3 id="kak-eto-dolzhno-rabotat"> 它应该如何工作 </h3><br><p> 我们通过在本机访存上调用包装函数（我们将其称为http。下面是该函数的完整代码）来构造请求，在该参数中，我们传递请求参数： </p><br><pre> <code class="hljs pgsql">cosnt httpToArticleId222 = http({ url: <span class="hljs-string"><span class="hljs-string">'/api/v1/article/222/'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">method</span></span>: <span class="hljs-string"><span class="hljs-string">'POST'</span></span> })</code> </pre> <br><p> 请注意，此http函数的结果将是包含url和方法请求设置的函数。 </p><br><p> 现在，通过调用<code>httpToArticleId222()</code>我们实际上将请求发送到了API。 </p><br><p> 您可以进行棘手的分阶段设计查询。 因此，我们可以使用有线API路径创建一组现成的函数。 我们将它们称为http服务。 </p><br><p> 因此，首先，我们正在构建一个API调用服务（同时添加对于所有后续请求都不变的请求参数，例如，方法） </p><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> httpAPI = http({ url: <span class="hljs-string"><span class="hljs-string">'/api'</span></span>, method: <span class="hljs-string"><span class="hljs-string">'POST'</span></span> })</code> </pre> <br><p> 现在，我们创建访问第一个版本的API的服务。 将来，我们将能够创建一个从httpAPI服务到不同版本API的独立请求分支。 </p><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> httpAPIv1 = httpAPI({ url: <span class="hljs-string"><span class="hljs-string">'/v1'</span></span> })</code> </pre> <br><p> 用于访问第一版API的服务已准备就绪。 现在，我们将为其中的其余数据创建服务（请记住本文开头的临时列表） </p><br><p>  <strong>主页数据</strong> </p><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> httpAPIv1Main = httpAPIv1({ url: <span class="hljs-string"><span class="hljs-string">'/index'</span></span> })</code> </pre> <br><p>  <strong>新闻页面数据</strong> </p><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> httpAPIv1News = httpAPIv1({ url: <span class="hljs-string"><span class="hljs-string">'/news'</span></span> })</code> </pre> <br><p>  <strong>文章列表数据</strong> </p><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> httpAPIv1Articles = httpAPIv1({ url: <span class="hljs-string"><span class="hljs-string">'/articles'</span></span> })</code> </pre> <br><p> 最后，我们来看我们的主要示例， <strong>材料的数据</strong> </p><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> httpAPIv1Article = httpAPIv1({ url: <span class="hljs-string"><span class="hljs-string">'/article'</span></span> })</code> </pre> <br><p> 如何获得文章编辑的路径？ 当然，您猜对了，我们正在从先前创建的函数<strong>httpAPIv1Article</strong>中加载数据 </p><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> httpAPIv1ArticleEdit = httpAPIv1({ url: <span class="hljs-string"><span class="hljs-string">'/edit'</span></span> })</code> </pre> <br><h3 id="nebolshoy-logicheskiy-itog"> 一个小的逻辑结果 </h3><br><p> 因此，我们有一个很漂亮的服务列表，例如，这些服务位于单独的文件中，根本不会打扰我们。 如果需要在请求中进行某些更改，我确切地知道在哪里进行编辑。 </p><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> { httpAPIv1Main, httpAPIv1News, httpAPIv1Articles, httpAPIv1Article, httpAPIv1ArticleEdit }</code> </pre> <br><p> 我正在导入具有特定功能的服务 </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { httpAPIv1Article } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'services'</span></span></code> </pre> <br><p> 然后执行请求，首先通过添加材料的ID来重建请求，然后调用该函数发送请求（正如他们所说的：“简单”） </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">httpAPIv1Article</span></span>({ <span class="hljs-attribute"><span class="hljs-attribute">url</span></span>: ArticleID // id  -   })() <span class="hljs-selector-class"><span class="hljs-selector-class">.then</span></span>(<span class="hljs-comment"><span class="hljs-comment">/* success */</span></span>) <span class="hljs-selector-class"><span class="hljs-selector-class">.catch</span></span>(<span class="hljs-comment"><span class="hljs-comment">/* error */</span></span>)</code> </pre> <br><p> 干净，美观，易于理解（不做广告） </p><br><h2 id="kak-eto-rabotaet"> 如何运作 </h2><br><p> 正是由于curring，我们才能用数据“加载”函数。 </p><br><p> 有点理论。 <br>  <em>Currying是一种构造函数的方法，可以逐步应用其参数。</em>  <em>这是通过在调用函数后返回它来实现的。</em> </p><br><p> 一个典型的例子是加法。 <br> 我们有一个sum函数，这是我们第一次调用时，我们传递第一个数字以进行后续折叠。 调用它之后，我们得到一个新函数，该函数期望第二个数字来计算总和。 这是她的代码（ES6语法） </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sum = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a</span></span></span><span class="hljs-function"> =&gt;</span></span> b =&gt; a + b</code> </pre> <br><p> 我们第一次调用它（部分应用程序）并将结果保存在变量中，例如sum13 </p><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sum13 = sum(<span class="hljs-number"><span class="hljs-number">13</span></span>)</code> </pre> <br><p> 现在<strong>sum13</strong>我们还可以在参数中使用缺少的数字进行调用，其结果将是13 +第二个参数 </p><br><pre> <code class="hljs objectivec">sum13(<span class="hljs-number"><span class="hljs-number">7</span></span>) <span class="hljs-comment"><span class="hljs-comment">// =&gt;  20</span></span></code> </pre> <br><h3 id="horosho-kak-eto-primenit-k-nashey-zadache"> 那么，如何将其应用于我们的任务？ </h3><br><p> 我们创建<strong>http</strong>函数，这将是fetch的包装器 </p><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">http</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(paramUser)</span></span></span></span> {}</code> </pre> <br><p> 其中<strong>paramUser</strong>是函数调用时传递的请求参数 </p><br><p> 让我们开始向函数添加逻辑。 </p><br><p> 添加默认设置的请求参数。 </p><br><pre> <code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">http</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(paramUser)</span></span></span></span> { /** *  -,    * @<span class="hljs-built_in"><span class="hljs-built_in">type</span></span> {<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>} */ let param = { method: <span class="hljs-string"><span class="hljs-string">'GET'</span></span>, credentials: <span class="hljs-string"><span class="hljs-string">'same-origin'</span></span> } }</code> </pre> <br><p> 然后是<strong>paramGen</strong>函数，该函数根据默认设置和用户定义的参数生成请求参数（实际上，这是两个对象的合并） </p><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">http</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(paramUser)</span></span></span></span> { /** *  -,    * @type {string} */ let <span class="hljs-keyword"><span class="hljs-keyword">param</span></span> = { method: <span class="hljs-string"><span class="hljs-string">'GET'</span></span>, credentials: <span class="hljs-string"><span class="hljs-string">'same-origin'</span></span> } /** *   , *  url  ,          * * @<span class="hljs-keyword"><span class="hljs-keyword">param</span></span> {object} <span class="hljs-keyword"><span class="hljs-keyword">param</span></span>   * @<span class="hljs-keyword"><span class="hljs-keyword">param</span></span> {object} paramUser ,    * * @<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {object}     */ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">paramGen</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(param, paramUser)</span></span></span></span> { let url = param.url || <span class="hljs-string"><span class="hljs-string">''</span></span> let newParam = Object.assign({}, <span class="hljs-keyword"><span class="hljs-keyword">param</span></span>, paramUser) url += paramUser.url || <span class="hljs-string"><span class="hljs-string">''</span></span> newParam.url = url <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> newParam } }</code> </pre> <br><h3 id="perehodim-k-samomu-glavnomu-opisyvaem-karrirovanie"> 我们传递到最重要的地方，我们描述了柯里化 </h3><br><p> 例如，由<strong>http</strong>函数返回的称为<strong>fabric</strong>的函数将对此提供帮助。 </p><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">http</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(paramUser)</span></span></span></span> { /** *  -,    * @type {string} */ let <span class="hljs-keyword"><span class="hljs-keyword">param</span></span> = { method: <span class="hljs-string"><span class="hljs-string">'GET'</span></span>, credentials: <span class="hljs-string"><span class="hljs-string">'same-origin'</span></span> } /** *   , *  url  ,          * * @<span class="hljs-keyword"><span class="hljs-keyword">param</span></span> {object} <span class="hljs-keyword"><span class="hljs-keyword">param</span></span>   * @<span class="hljs-keyword"><span class="hljs-keyword">param</span></span> {object} paramUser ,    * * @<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {object}     */ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">paramGen</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(param, paramUser)</span></span></span></span> { let url = param.url || <span class="hljs-string"><span class="hljs-string">''</span></span> url += paramUser.url || <span class="hljs-string"><span class="hljs-string">''</span></span> let newParam = Object.assign({}, <span class="hljs-keyword"><span class="hljs-keyword">param</span></span>, paramUser); newParam.url = url <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> newParam } /** *  ,     *  ,      * *  : * * -    ,        ,     * -   ,           * -   ,      * * @<span class="hljs-keyword"><span class="hljs-keyword">param</span></span> {object} <span class="hljs-keyword"><span class="hljs-keyword">param</span></span> ,       * @<span class="hljs-keyword"><span class="hljs-keyword">param</span></span> {object} paramUser ,   * * @<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> || </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">promise</span></span></span><span class="hljs-function">}   ,    </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fetch)</span></span></span><span class="hljs-function">,     */ </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fabric</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(param, paramUser)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (paramUser) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (typeof paramUser === <span class="hljs-string"><span class="hljs-string">'string'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fabric.bind(null, paramGen(<span class="hljs-keyword"><span class="hljs-keyword">param</span></span>, { url: paramUser })) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fabric.bind(null, paramGen(<span class="hljs-keyword"><span class="hljs-keyword">param</span></span>, paramUser)) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { //  ,   ,   <span class="hljs-keyword"><span class="hljs-keyword">param</span></span>    url, //       :) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fetch(param.url, <span class="hljs-keyword"><span class="hljs-keyword">param</span></span>) } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fabric.bind(null, paramGen(<span class="hljs-keyword"><span class="hljs-keyword">param</span></span>, paramUser)) }</code> </pre> <br><p> 首次调用<strong>http</strong>函数将返回<strong>fabric</strong>函数，并向其传递<strong>param</strong>参数（并由<strong>paramGen</strong>函数配置），它将等待其返回 <del> 小时 </del> 稍后再打电话。 </p><br><p> 例如，配置请求 </p><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> httpGift = http({ url: '<span class="hljs-comment"><span class="hljs-comment">//omozon.ru/givemegift/' })</span></span></code> </pre> <br><p> 并调用<strong>httpGift</strong> ，应用传递的参数，结果返回<strong>fetch</strong> ，如果要重新配置请求，我们只需将新参数传递给生成的<strong>httpGift</strong>函数，并期望不带参数地调用它 </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">httpGift</span></span>() <span class="hljs-selector-class"><span class="hljs-selector-class">.then</span></span>(<span class="hljs-comment"><span class="hljs-comment">/* success */</span></span>) <span class="hljs-selector-class"><span class="hljs-selector-class">.catch</span></span>(<span class="hljs-comment"><span class="hljs-comment">/* error */</span></span>)</code> </pre> <br><h2 id="itogi"> 总结 </h2><br><p> 通过在各种模块的开发中使用curring，我们可以在模块使用和测试简便方面获得高度的灵活性。 例如，当组织服务架构以使用API​​时。 </p><br><p> 就像我们正在创建一个小型库一样，使用我们的工具为应用程序创建单个基础结构。 </p><br><p> 我希望这些信息有用，不要再费力，这是我一生中的第一篇文章:) </p><br><p> 所有已编译的代码，一会见！ </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN422661/">https://habr.com/ru/post/zh-CN422661/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN422649/index.html">多人VR：如何实现？</a></li>
<li><a href="../zh-CN422651/index.html">黄瓜3 + Java</a></li>
<li><a href="../zh-CN422653/index.html">疾病战争：重新定义旧观点</a></li>
<li><a href="../zh-CN422655/index.html">开发人员激励价值矩阵</a></li>
<li><a href="../zh-CN422659/index.html">关于适当的姿势，肌肉锻炼和伸展运动</a></li>
<li><a href="../zh-CN422665/index.html">团队和解的成本</a></li>
<li><a href="../zh-CN422667/index.html">我不会学习您的垃圾查询语言</a></li>
<li><a href="../zh-CN422669/index.html">Oracle与PostgreSQL。 为什么选择Oracle可能是一个明智的决定</a></li>
<li><a href="../zh-CN422671/index.html">5G可以代替电缆-但并非到处都可以</a></li>
<li><a href="../zh-CN422675/index.html">在太空中制造：谁将在国际空间站上制造光纤</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>