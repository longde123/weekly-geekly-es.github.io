<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©‚Äç‚ù§Ô∏è‚Äçüíã‚Äçüë© ‚úçüèΩ üë®üèª‚Äçüî¨ Pelokalan aplikasi di iOS. Bagian 1. Apa yang kita miliki? üóΩ üì≤ ü§ù</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pelokalan aplikasi di iOS 
 Bagian 1. Apa yang kita miliki? 


 Panduan Sumber Daya String Lokal 
 Pendahuluan 


 Beberapa tahun yang lalu, saya terj...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pelokalan aplikasi di iOS. Bagian 1. Apa yang kita miliki?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/419077/"><h1 id="lokalizaciya-prilozheniy-v-ios">  Pelokalan aplikasi di iOS </h1><br><h2 id="chast-1-chto-my-imeem">  Bagian 1. Apa yang kita miliki? </h2><br><p>  <strong><em>Panduan Sumber Daya String Lokal</em></strong> </p><br><h3 id="vvedenie">  Pendahuluan </h3><br><p>  Beberapa tahun yang lalu, saya terjun ke dunia magis pengembangan iOS, yang dengan segala esensinya menjanjikan masa depan yang bahagia di bidang IT.  Namun, dengan menggali lebih dalam fitur platform dan lingkungan pengembangan, saya menghadapi banyak kesulitan dan ketidaknyamanan dalam menyelesaikan tugas yang tampaknya sangat sepele: ‚Äúkonservatisme inovatif‚Äù Apple terkadang membuat pengembang sangat canggih untuk memuaskan pelanggan ‚ÄúINGIN‚Äù yang tak terkendali. </p><br><p>  Salah satu masalah ini adalah masalah melokalisasi sumber daya string aplikasi.  Saya ingin mencurahkan beberapa publikasi pertama saya di hamparan Habr untuk masalah ini. </p><a name="habracut"></a><br><p>  Awalnya, saya berharap bisa memasukkan pikiran saya dalam satu artikel, tetapi jumlah informasi yang ingin saya sampaikan cukup besar.  Pada artikel ini saya akan mencoba mengungkap esensi dari mekanisme standar untuk bekerja dengan sumber daya lokal dengan penekanan pada beberapa aspek yang diabaikan oleh sebagian besar panduan dan tutorial.  Materi ini terutama ditujukan untuk pengembang pemula (atau mereka yang belum mengalami tugas seperti itu).  Untuk pengembang berpengalaman, informasi ini mungkin tidak terlalu berharga.  Tetapi tentang ketidaknyamanan dan kerugian yang dapat ditemui dalam praktek, saya akan memberitahu di masa depan ... </p><br><h3 id="iz-pod-korobki-kak-organizovano-hranenie-strokovyh-resursov-v-ios-prilozheniyah">  Di luar kotak.  Bagaimana penyimpanan sumber daya string diatur dalam aplikasi iOS </h3><br><p>  Untuk memulainya, kami mencatat bahwa keberadaan mekanisme lokalisasi di platform sudah merupakan nilai tambah yang besar, karena  menyimpan programmer dari pengembangan tambahan dan menetapkan format tunggal untuk bekerja dengan data.  Dan seringkali, mekanisme dasar sudah cukup untuk implementasi proyek yang relatif kecil. </p><br><p>  Jadi, peluang apa yang diberikan Xcode kepada kami "di luar kotak"?  Pertama, mari kita lihat standar untuk menyimpan sumber daya string dalam suatu proyek. </p><br><p> Dalam proyek dengan konten statis, data string dapat disimpan secara langsung di antarmuka ( <em><code>.storyboard</code></em> dan <em><code>.xib</code></em> , yang pada gilirannya adalah file XML yang dibuat menggunakan alat bantu <em>Builder Interface</em> ) atau dalam kode.  Pendekatan pertama memungkinkan kami untuk menyederhanakan dan mempercepat proses menandai layar dan tampilan individual  pengembang dapat mengamati sebagian besar perubahan tanpa membangun aplikasi.  Namun, dalam hal ini tidak sulit untuk mengalami redundansi data (jika teks yang sama digunakan oleh beberapa elemen, tampilan).  Pendekatan kedua hanya menghilangkan masalah redundansi data, tetapi mengarah pada kebutuhan untuk mengisi layar secara manual (dengan menetapkan <em><code>IBOutlet</code></em> tambahan dan menetapkan nilai teks yang sesuai), yang pada gilirannya mengarah pada redundansi kode (tentu saja, kecuali untuk kasus-kasus di mana teks harus dipasang langsung oleh kode aplikasi). </p><br><p>  Selain itu, Apple menyediakan ekstensi file standar <em><code>.strings</code></em> .  Standar ini mengatur format untuk menyimpan data string dalam bentuk array asosiatif ( <code>"-"</code> ): </p><br><pre> <code class="hljs objectivec"><span class="hljs-string"><span class="hljs-string">"key"</span></span> = <span class="hljs-string"><span class="hljs-string">"value"</span></span>;</code> </pre> <br><p>  Kuncinya adalah case-sensitive, memungkinkan penggunaan spasi, garis bawah, tanda baca dan karakter khusus. </p><br><p>  Penting untuk dicatat bahwa meskipun ada sintaks langsung, file <em>Strings</em> adalah sumber kesalahan rutin selama kompilasi, perakitan, atau operasi aplikasi.  Ada beberapa alasan untuk ini. </p><br><p>  Pertama, kesalahan sintaksis.  Titik koma yang hilang, tanda sama dengan, tanda kutip tambahan atau tidak terhindarkan pasti akan menyebabkan kesalahan kompiler.  Selain itu, Xcode akan menunjuk ke file dengan kesalahan, tetapi tidak akan menyoroti garis di mana ada sesuatu yang salah.  Menemukan kesalahan ketik seperti itu bisa memakan waktu cukup lama, terutama jika file tersebut berisi sejumlah besar data. </p><br><p>  Kedua, duplikasi kunci.  Aplikasi, tentu saja, tidak akan macet karena itu, tetapi data yang salah dapat ditampilkan kepada pengguna.  Masalahnya adalah bahwa ketika mengakses baris demi kunci, nilai yang sesuai dengan kemunculan terakhir kunci dalam file ditarik ke atas. </p><br><p>  Akibatnya, desain yang sederhana membutuhkan programmer untuk sangat teliti dan penuh perhatian saat mengisi file dengan data. </p><br><p><del>  Berpengetahuan luas </del>  pengembang dapat segera berseru: <em>"Tapi bagaimana dengan JSON dan PLIST? Apa yang tidak mereka sukai?"</em>  Yah, pertama-tama, <em><code>JSON</code></em> dan <em><code>PLIST</code></em> (pada kenyataannya, <em><code>XML</code></em> biasa) adalah standar universal yang memungkinkan penyimpanan string dan numerik, logis ( <em><code>BOOL</code></em> ), data biner, waktu dan tanggal, serta koleksi - indeks - terindeks ( <em><code>Array</code></em> ) dan asosiatif ( <em><code>Dictionary</code></em> ) array.  Dengan demikian, sintaks dari standar-standar ini lebih jenuh, dan karenanya lebih mudah untuk digigit.  Kedua, kecepatan pemrosesan file tersebut sedikit lebih rendah daripada file Strings, lagi-lagi karena sintaksis yang lebih kompleks.  Ini belum lagi fakta bahwa untuk bekerja dengan mereka, Anda perlu melakukan sejumlah manipulasi dalam kode. </p><br><h3 id="lokalizovali-lokalizovali-da-ne-vylokalizovali-lokalizaciya-polzovatelskogo-interfeysa">  Terlokalisasi, terlokalisasi, tetapi tidak terlokalisasi.  Lokalisasi Antarmuka Pengguna </h3><br><p>  Jadi, dengan standar yang sudah ditentukan, sekarang mari kita cari tahu cara menggunakannya. </p><br><p>  Mari kita mulai.  Pertama, buat <em>Aplikasi Tampilan Tunggal</em> sederhana dan tambahkan beberapa komponen teks ke <em>Main.storyboard</em> pada <em>ViewController</em> . </p><br><img src="https://habrastorage.org/getpro/habr/post_images/310/a0b/c0d/310a0bc0df4192cd2ab87ad46407666a.png" width="50%" height="50%"><br><br><p>  Konten dalam hal ini disimpan langsung di antarmuka.  Untuk melokalkannya, Anda harus melakukan yang berikut: </p><br><p>  1) Buka pengaturan proyek </p><br><img src="https://habrastorage.org/getpro/habr/post_images/b9e/0bb/f6e/b9e0bbf6eb66b5d8acb88ee3b29fd45c.png" width="50%" height="50%"><br><br><p>  2) Lalu - dari <strong><em>Target</em></strong> ke <strong><em>Proyek</em></strong> </p><br><img src="https://habrastorage.org/getpro/habr/post_images/bb5/bf0/334/bb5bf033410cedeb98e3e46399637d7b.png" width="50%" height="50%"><br><br><p>  3) Buka tab <strong><em>Info</em></strong> </p><br><img src="https://habrastorage.org/getpro/habr/post_images/324/5bd/cdd/3245bdcdd605153e52668fd795f65720.png" width="50%" height="50%"><br><br><p>  Di bagian <strong><em>Pelokalan</em></strong> , kami segera melihat bahwa kami sudah memiliki entri <em>"Bahasa Inggris - Bahasa Pembangunan"</em> .  Ini berarti bahwa bahasa Inggris ditetapkan sebagai bahasa pengembangan (atau standar). </p><br><p>  Mari tambahkan bahasa lain sekarang.  Untuk melakukan ini, klik " <strong>+</strong> " dan pilih bahasa yang diinginkan (misalnya, saya memilih bahasa Rusia).  Caring Xcode segera menawarkan kepada kami untuk memilih file mana yang akan dilokalisasi untuk bahasa yang ditambahkan. </p><br><img src="https://habrastorage.org/getpro/habr/post_images/781/801/3ae/7818013aee9b0574048779957404bb31.png" width="50%" height="50%"><br><br><p>  Klik <strong>Selesai</strong> , lihat apa yang terjadi.  Di navigator proyek, tombol untuk menampilkan sarang muncul di dekat file yang dipilih.  Dengan mengkliknya, kita melihat bahwa file yang dipilih sebelumnya berisi file lokalisasi yang dibuat. </p><br><img src="https://habrastorage.org/getpro/habr/post_images/5b0/882/089/5b0882089822427b954eb7ce5e497048.png" width="35%" height="35%"><br><br><p>  Misalnya, <strong><em><code>Main.storyboard (Base)</code></em></strong> adalah file markup antarmuka default dalam bahasa pengembangan basis, dan ketika membentuk lokalisasi untuk itu, <strong><em><code>Main.strings (Russian)</code></em></strong> terkait <strong><em><code>Main.strings (Russian)</code></em></strong> dibuat berpasangan - file string untuk lokalisasi Rusia.  Membuka itu, Anda dapat melihat yang berikut: </p><br><pre> <code class="hljs vbscript">/* <span class="hljs-keyword"><span class="hljs-keyword">Class</span></span> = <span class="hljs-string"><span class="hljs-string">"UILabel"</span></span>; text = <span class="hljs-string"><span class="hljs-string">"Label"</span></span>; ObjectID = <span class="hljs-string"><span class="hljs-string">"tQe-tG-eeo"</span></span>; */ <span class="hljs-string"><span class="hljs-string">"tQe-tG-eeo.text"</span></span> = <span class="hljs-string"><span class="hljs-string">"Label"</span></span>; /* <span class="hljs-keyword"><span class="hljs-keyword">Class</span></span> = <span class="hljs-string"><span class="hljs-string">"UITextField"</span></span>; placeholder = <span class="hljs-string"><span class="hljs-string">"TextField"</span></span>; ObjectID = <span class="hljs-string"><span class="hljs-string">"cpp-y2-Z0N"</span></span>; */ <span class="hljs-string"><span class="hljs-string">"cpp-y2-Z0N.placeholder"</span></span> = <span class="hljs-string"><span class="hljs-string">"TextField"</span></span>; /* <span class="hljs-keyword"><span class="hljs-keyword">Class</span></span> = <span class="hljs-string"><span class="hljs-string">"UIButton"</span></span>; normalTitle = <span class="hljs-string"><span class="hljs-string">"Button"</span></span>; ObjectID = <span class="hljs-string"><span class="hljs-string">"EKl-Rz-Dc2"</span></span>; */ <span class="hljs-string"><span class="hljs-string">"EKl-Rz-Dc2.normalTitle"</span></span> = <span class="hljs-string"><span class="hljs-string">"Button"</span></span>;</code> </pre> <br><p>  Di sini, secara umum, semuanya sederhana, tetapi demi kejelasan, kami akan mempertimbangkan lebih detail, memperhatikan komentar yang dihasilkan oleh Xcode yang peduli: </p><br><pre> <code class="hljs vbscript">/* <span class="hljs-keyword"><span class="hljs-keyword">Class</span></span> = <span class="hljs-string"><span class="hljs-string">"UILabel"</span></span>; text = <span class="hljs-string"><span class="hljs-string">"Label"</span></span>; ObjectID = <span class="hljs-string"><span class="hljs-string">"tQe-tG-eeo"</span></span>; */ <span class="hljs-string"><span class="hljs-string">"tQe-tG-eeo.text"</span></span> = <span class="hljs-string"><span class="hljs-string">"Label"</span></span>;</code> </pre> <br><p>  Ini adalah turunan dari kelas <strong><em><code>UILabel</code></em></strong> dengan nilai <strong><em><code>"Label"</code></em></strong> untuk parameter <strong><em><code>text</code></em></strong> .  <strong><em><code>ObjectID</code></em></strong> - pengidentifikasi objek dalam file markup - ini adalah baris unik yang ditetapkan untuk komponen apa pun pada saat ditempatkan di <em><code>Storyboard/Xib</code></em> .  Dari <em><code>ObjectID</code></em> dan nama parameter objek (dalam hal ini, <em><code>text</code></em> ) kunci dibuat, dan catatan itu sendiri dapat secara resmi diartikan sebagai berikut: </p><br><p>  Atur parameter teks dari objek tQe-tG-eeo ke Label. </p><br><p>  Dalam catatan ini, hanya " <em>nilai</em> " yang dapat berubah.  Ganti " <em>Label</em> " dengan " <em>Label</em> ".  Kami akan melakukan hal yang sama dengan benda lain. </p><br><pre> <code class="hljs vbscript">/* <span class="hljs-keyword"><span class="hljs-keyword">Class</span></span> = <span class="hljs-string"><span class="hljs-string">"UILabel"</span></span>; text = <span class="hljs-string"><span class="hljs-string">"Label"</span></span>; ObjectID = <span class="hljs-string"><span class="hljs-string">"tQe-tG-eeo"</span></span>; */ <span class="hljs-string"><span class="hljs-string">"tQe-tG-eeo.text"</span></span> = <span class="hljs-string"><span class="hljs-string">""</span></span>; /* <span class="hljs-keyword"><span class="hljs-keyword">Class</span></span> = <span class="hljs-string"><span class="hljs-string">"UITextField"</span></span>; placeholder = <span class="hljs-string"><span class="hljs-string">"TextField"</span></span>; ObjectID = <span class="hljs-string"><span class="hljs-string">"cpp-y2-Z0N"</span></span>; */ <span class="hljs-string"><span class="hljs-string">"cpp-y2-Z0N.placeholder"</span></span> = <span class="hljs-string"><span class="hljs-string">" "</span></span>; /* <span class="hljs-keyword"><span class="hljs-keyword">Class</span></span> = <span class="hljs-string"><span class="hljs-string">"UIButton"</span></span>; normalTitle = <span class="hljs-string"><span class="hljs-string">"Button"</span></span>; ObjectID = <span class="hljs-string"><span class="hljs-string">"EKl-Rz-Dc2"</span></span>; */ <span class="hljs-string"><span class="hljs-string">"EKl-Rz-Dc2.normalTitle"</span></span> = <span class="hljs-string"><span class="hljs-string">""</span></span>;</code> </pre> <br><p>  Kami meluncurkan aplikasi kami. </p><br><img src="https://habrastorage.org/getpro/habr/post_images/9e7/85a/332/9e785a3328aff1923329541d31447672.png" width="50%" height="50%"><br><br><p>  Tapi apa yang kita lihat?  Aplikasi ini menggunakan lokalisasi dasar.  Bagaimana cara memeriksa apakah kami melakukan transfer dengan benar? </p><br><p>  Di sini ada baiknya melakukan penyimpangan kecil dan menggali sedikit ke arah fitur platform iOS dan struktur aplikasi. </p><br><p>  Untuk memulai, pertimbangkan untuk mengubah struktur proyek dalam proses penambahan lokalisasi.  Ini adalah bagaimana direktori proyek terlihat sebelum menambahkan lokalisasi Rusia: </p><br><img src="https://habrastorage.org/getpro/habr/post_images/bb3/0b2/f07/bb30b2f0799f2c7ce2433aa7ec2350fc.png" width="50%" height="50%"><br><br><p>  Dan setelah itu: </p><br><img src="https://habrastorage.org/getpro/habr/post_images/ae7/a10/b14/ae7a10b14491da04c89ce8e456cf5ac1.png" width="50%" height="50%"><br><br><p>  Seperti yang bisa kita lihat, Xcode membuat direktori baru <em><code>ru.lproj</code></em> , di mana ia menempatkan string lokal yang dibuat. </p><br><img src="https://habrastorage.org/getpro/habr/post_images/ceb/ca2/ff5/cebca2ff5edaae9d6a1398f9e41e7652.png" width="50%" height="50%"><br><br><p>  Dan di mana struktur proyek Xcode untuk aplikasi iOS yang sudah selesai?  Dan terlepas dari kenyataan bahwa ini membantu untuk lebih memahami fitur-fitur platform, serta prinsip-prinsip distribusi dan penyimpanan sumber daya secara langsung dalam aplikasi jadi.  Intinya adalah bahwa ketika merakit proyek Xcode, selain menghasilkan file yang dapat dieksekusi, lingkungan mentransfer sumber daya (file tata letak antarmuka <em>Storyboard / Xib</em> , gambar, file garis, dll.) <em>Ke</em> aplikasi yang sudah selesai, menjaga hierarki yang ditentukan pada tahap pengembangan. </p><br><p>  Untuk bekerja dengan hierarki ini, Apple menyediakan kelas <em><code>Bundle(NSBundle)</code></em> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">terjemahan gratis</a> ): </p><br><blockquote>  Apple menggunakan <strong><code>Bundle</code></strong> untuk menyediakan akses ke aplikasi, kerangka kerja, plugin, dan banyak jenis konten lainnya.  Bundel mengatur sumber daya ke dalam subdirektori yang didefinisikan dengan jelas, dan struktur bundel bervariasi berdasarkan platform dan jenis.  Menggunakan <em><code>bundle</code></em> , Anda dapat mengakses sumber daya suatu paket tanpa mengetahui strukturnya.  <em><code>Bundle</code></em> adalah antarmuka tunggal untuk mencari elemen, dengan mempertimbangkan struktur paket, kebutuhan pengguna, pelokalan yang tersedia, dan faktor relevan lainnya. <br>  <strong>Cari dan temukan sumber daya</strong> <br>  Sebelum Anda mulai bekerja dengan sumber daya, Anda harus menentukan <em><code>bundle</code></em> .  Kelas <strong><code>Bundle</code></strong> memiliki banyak konstruktor, tetapi <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">utama</a></strong> paling sering digunakan.  <em><code>Bundle.main</code></em> menyediakan jalur ke direktori yang berisi kode yang dapat dieksekusi saat ini.  Dengan cara ini, <em><code>Bundle.main</code></em> menyediakan akses ke sumber daya yang digunakan oleh aplikasi saat ini. </blockquote><p>  Pertimbangkan struktur <em><code>Bundle.main</code></em> menggunakan kelas <em><code>Bundle.main</code></em> : </p><br><img src="https://habrastorage.org/getpro/habr/post_images/60f/e0f/8b3/60fe0f8b3bb62a0db757f06f999e8065.png" width="65%" height="65%"><br><br><p>  Berdasarkan uraian di atas, kita dapat menyimpulkan: ketika aplikasi dimuat, <em><code>Bundle.main</code></em> -nya terbentuk, lokalisasi perangkat saat ini (bahasa sistem), lokalisasi aplikasi dan sumber daya lokal dianalisis.  Kemudian aplikasi memilih dari semua lokalisasi yang tersedia yang sesuai dengan bahasa sistem saat ini dan menarik sumber daya lokal yang sesuai.  Jika tidak ada kecocokan, sumber daya dari direktori default digunakan (dalam kasus kami, pelokalan bahasa Inggris, karena bahasa Inggris didefinisikan sebagai bahasa pengembangan, dan kebutuhan untuk pelokalan sumber daya tambahan dapat diabaikan).  Jika Anda mengubah bahasa perangkat ke Rusia dan memulai ulang aplikasi, maka antarmuka sudah sesuai dengan lokalisasi Rusia. </p><br><img src="https://habrastorage.org/getpro/habr/post_images/47e/e24/6fe/47ee246fec532a890503019af1bfc91c.png" width="50%" height="50%"><br><br><p>  Tetapi sebelum Anda menutup topik pelokalan antarmuka pengguna melalui <em>Interface Builder</em> , perlu dicatat cara lain yang patut diperhatikan.  Saat membuat file pelokalan (dengan menambahkan bahasa baru ke proyek atau di inspektur file lokal), mudah untuk melihat bahwa Xcode menyediakan kemampuan untuk memilih jenis file yang akan dibuat: </p><br><img src="https://habrastorage.org/getpro/habr/post_images/272/aa5/cb3/272aa5cb38ea6b2a4178edc911296982.png" width="35%" height="35%"><br><br><p>  Alih-alih file baris, Anda dapat dengan mudah membuat <em><code>Storyboard/Xib</code></em> lokal yang akan menyimpan semua markup file dasar.  Nilai tambah yang besar dari pendekatan ini adalah pengembang dapat segera melihat bagaimana konten akan ditampilkan dalam bahasa tertentu dan segera memperbaiki tata letak layar, terutama jika jumlah teks berbeda, atau arah teks yang lain digunakan (misalnya, dalam bahasa Arab, bahasa Ibrani) dan sebagainya. .  Tetapi pada saat yang sama, membuat file <em>Storyboard / Xib</em> tambahan secara signifikan meningkatkan ukuran aplikasi itu sendiri (semua sama, file string memakan banyak ruang lebih sedikit). </p><br><p>  Oleh karena itu, ketika memilih satu atau beberapa metode pelokalan antarmuka lainnya, ada baiknya mempertimbangkan pendekatan mana yang lebih tepat dan praktis dalam situasi tertentu. </p><br><h3 id="do-it-yourself-rabota-s-lokalizovannymi-strokovymi-resursami-v-kode">  Lakukan Sendiri.  Bekerja dengan sumber string yang terlokalisasi dalam kode </h3><br><p>  Semoga dengan konten statis, semuanya lebih atau kurang jelas.  Tetapi bagaimana dengan teks yang diatur langsung dalam kode? </p><br><p>  Pengembang sistem operasi iOS menangani ini. </p><br><p>  Untuk bekerja dengan sumber daya teks lokal, kerangka kerja Yayasan menyediakan keluarga <strong><em><code>NSLocalizedStrings</code></em></strong> metode di <strong><em>Swift</em></strong> </p><br><pre> <code class="hljs sql">NSLocalizedString(_ key: String, <span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">String</span></span>) NSLocalizedString(_ <span class="hljs-keyword"><span class="hljs-keyword">key</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">String</span></span>, tableName: <span class="hljs-keyword"><span class="hljs-keyword">String</span></span>?, bundle: Bundle, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">String</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">comment</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">String</span></span>)</code> </pre> <br><p>  dan makro di <strong><em>Objective-C</em></strong> </p><br><pre> <code class="objectivec hljs"><span class="hljs-built_in"><span class="hljs-built_in">NSLocalizedString</span></span>(key, comment) <span class="hljs-built_in"><span class="hljs-built_in">NSLocalizedStringFromTable</span></span>(key, tbl, comment) <span class="hljs-built_in"><span class="hljs-built_in">NSLocalizedStringFromTableInBundle</span></span>(key, tbl, bundle, comment) <span class="hljs-built_in"><span class="hljs-built_in">NSLocalizedStringWithDefaultValue</span></span>(key, tbl, bundle, val, comment)</code> </pre> <br><p>  Mari kita mulai dengan yang jelas.  Parameter <strong><em><code>key</code></em></strong> adalah kunci string dalam file Strings;  <strong><em><code>val</code></em></strong> (nilai default) - nilai default yang digunakan jika kunci yang ditentukan tidak ada dalam file;  <strong><em><code>comment</code></em></strong> - (kurang jelas) deskripsi singkat dari string terlokalisasi (pada kenyataannya, itu tidak membawa fungsionalitas yang berguna dan dimaksudkan untuk menjelaskan tujuan penggunaan string tertentu). </p><br><p>  Adapun parameter <em><code>tableName</code></em> ( <em><code>tbl</code></em> ) dan <em><code>bunble</code></em> , maka mereka harus dipertimbangkan secara lebih rinci. </p><br><p>  <strong><em><code>tableName</code></em></strong> ( <strong><em><code>tbl</code></em></strong> ) adalah nama file String (sejujurnya, saya tidak tahu mengapa Apple menyebutnya tabel), yang berisi baris yang kita butuhkan dengan kunci yang ditentukan;  ketika ditransfer, ekstensi <em><code>.string</code></em> tidak ditentukan.  Kemampuan untuk menavigasi antar tabel memungkinkan Anda untuk tidak menyimpan sumber daya string dalam satu file, tetapi untuk mendistribusikannya atas kebijakan Anda sendiri.  Ini memungkinkan Anda untuk menyingkirkan kemacetan file, menyederhanakan pengeditan, dan meminimalkan kemungkinan kesalahan. </p><br><p>  Parameter <strong><em><code>bundle</code></em></strong> memperluas navigasi sumber daya lebih jauh.  Seperti yang disebutkan sebelumnya, <em>bundel</em> adalah mekanisme untuk mengakses sumber daya aplikasi, yaitu, kita dapat menentukan sumber sumber daya secara independen. </p><br><p>  Sedikit lagi.  Kami akan pergi langsung ke <strong><em>Yayasan</em></strong> dan mempertimbangkan deklarasi metode (makro) untuk gambaran yang lebih jelas, karena  sebagian besar tutorial mengabaikan hal ini.  Kerangka kerja <em>Swift</em> tidak terlalu informatif: </p><br><pre> <code class="hljs vhdl">/// Returns a localized <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, using the main bundle <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> one <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> specified. public func NSLocalizedString(_ key: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, tableName: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>? = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>, bundle: Bundle = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>, value: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>, comment: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">String</span></span></code> </pre> <br><p>  <em>"Bundel utama mengembalikan string yang dilokalkan"</em> - semua yang kita miliki.  <em>Objective-C</em> agak berbeda. </p><br><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#define NSLocalizedString(key, comment) \ [NSBundle.mainBundle localizedStringForKey:(key) value:@</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">""</span></span></span><span class="hljs-meta"> table:nil] #define NSLocalizedStringFromTable(key, tbl, comment) \ [NSBundle.mainBundle localizedStringForKey:(key) value:@</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">""</span></span></span><span class="hljs-meta"> table:(tbl)] #define NSLocalizedStringFromTableInBundle(key, tbl, bundle, comment) \ [bundle localizedStringForKey:(key) value:@</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">""</span></span></span><span class="hljs-meta"> table:(tbl)] #define NSLocalizedStringWithDefaultValue(key, tbl, bundle, val, comment) \ [bundle localizedStringForKey:(key) value:(val) table:(tbl)]</span></span></code> </pre> <br><p>  Di sini Anda sudah dapat melihat dengan jelas bahwa tidak lain dari <strong><em><code>bundle</code></em></strong> (dalam dua kasus utama <em><code>mainBundle</code></em> ) bekerja dengan file sumber daya string - sama seperti dalam kasus pelokalan antarmuka.  Tentu saja, saya dapat langsung mengatakan ini, mengingat kelas <em><code>Bundle</code></em> ( <em><code>NSBundle</code></em> ) pada paragraf sebelumnya, tetapi pada saat itu informasi ini tidak memiliki nilai praktis tertentu.  Tetapi dalam konteks bekerja dengan baris dalam kode, ini tidak bisa dikatakan.  Bahkan, fungsi global yang disediakan oleh <strong><em>Yayasan</em></strong> hanyalah pembungkus metode bundel standar, tugas utamanya adalah membuat kode lebih ringkas dan aman.  Tidak ada yang melarang untuk menginisialisasi <em><code>bundle</code></em> secara manual dan secara langsung mengakses sumber daya atas namanya, tetapi dengan cara ini muncul (walaupun sangat, sangat kecil) kemungkinan pembentukan tautan sirkuler dan kebocoran memori. </p><br><p>  Contoh di bawah ini akan menjelaskan cara bekerja dengan fungsi global dan makro. </p><br><p>  Mari kita lihat bagaimana semuanya bekerja. <br>  Pertama, buat file String yang akan berisi sumber daya string kami.  Sebut saja Localizable.strings * dan tambahkan ke dalamnya. </p><br><pre> <code class="hljs objectivec"><span class="hljs-string"><span class="hljs-string">"testKey"</span></span> = <span class="hljs-string"><span class="hljs-string">"testValue"</span></span>;</code> </pre> <br><p>  ( <em>File string dilokalkan dengan cara yang persis sama dengan</em> Storyboard / Xib <em>, jadi saya tidak akan menjelaskan proses ini. Kami akan mengganti "</em> testValue <em>" dalam</em> <em>file pelokalan Rusia</em> <em>dengan "</em> test value *".) </p><br><p>  <strong>Penting!</strong>  Di iOS, file dengan nama ini adalah file sumber daya string default, mis.  jika Anda tidak menentukan nama tabel <em><code>tableName</code></em> ( <em><code>tbl</code></em> ), aplikasi akan secara otomatis mengetuk <strong><em><code>Localizable.strings</code></em></strong> . </p><br><p>  Tambahkan kode berikut ke proyek kami </p><br><pre> <code class="hljs lisp">//Swift print(<span class="hljs-string"><span class="hljs-string">"String for 'testKey': "</span></span> + NSLocalizedString(<span class="hljs-string"><span class="hljs-string">"testKey"</span></span>, comment: <span class="hljs-string"><span class="hljs-string">""</span></span>))</code> </pre> <br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">//Objective-C NSLog(@"String for 'testKey': %@", NSLocalizedString(@"testKey", @""));</span></span></code> </pre> <br><p>  dan jalankan proyek.  Setelah mengeksekusi kode, sebuah baris akan muncul di konsol </p><br><pre> <code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-string"><span class="hljs-string">'testKey'</span></span>: testValue</code> </pre> <br><p>  Semuanya bekerja dengan baik! </p><br><p>  Demikian pula dengan contoh lokalisasi antarmuka, ubah lokalisasi dan jalankan aplikasi.  Hasil dari eksekusi kode adalah </p><br><pre> <code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-string"><span class="hljs-string">'testKey'</span></span>:  </code> </pre> <br><p>  Sekarang mari kita coba untuk mendapatkan nilai dengan kunci, yang tidak ada di file <em><code>Localizable.strings</code></em> : </p><br><pre> <code class="hljs lisp">//Swift print(<span class="hljs-string"><span class="hljs-string">"String for 'unknownKey': "</span></span> + NSLocalizedString(<span class="hljs-string"><span class="hljs-string">"unknownKey"</span></span>, comment: <span class="hljs-string"><span class="hljs-string">""</span></span>))</code> </pre> <br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">//Objective-C NSLog(@"String for 'unknownKey': %@", NSLocalizedString(@"unknownKey", @""));</span></span></code> </pre> <br><p>  Hasil dari eksekusi kode tersebut adalah </p><br><pre> <code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-string"><span class="hljs-string">'unknownKey'</span></span>: unknownKey</code> </pre> <br><p>  Karena tidak ada kunci dalam file, metode mengembalikan kunci itu sendiri sebagai hasilnya.  Jika hasil seperti itu tidak dapat diterima, maka lebih baik menggunakan metode ini </p><br><pre> <code class="hljs lisp">//Swift print(<span class="hljs-string"><span class="hljs-string">"String for 'testKey': "</span></span> + NSLocalizedString(<span class="hljs-string"><span class="hljs-string">"unknownKey"</span></span>, tableName: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, bundle: Bundle.main, value: <span class="hljs-string"><span class="hljs-string">"noValue"</span></span>, comment: <span class="hljs-string"><span class="hljs-string">""</span></span>))</code> </pre> <br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">//Objective-C NSLog(@"String for 'testKey': %@", NSLocalizedStringWithDefaultValue(@"unknownKey", nil, NSBundle.mainBundle, @"noValue", @""));</span></span></code> </pre> <br><p>  di mana ada parameter <strong><em><code>value</code></em></strong> ( <em>nilai default</em> ).  Tetapi dalam kasus ini, Anda harus menentukan sumber sumber daya - <em><code>bundle</code></em> . </p><br><p>  String lokal mendukung mekanisme interpolasi, mirip dengan string iOS standar.  Untuk melakukan ini, tambahkan catatan ke file string menggunakan string literal ( <em><code>%@</code></em> , <em><code>%li</code></em> , <em><code>%f</code></em> , dll.), Misalnya: </p><br><pre> <code class="hljs perl"><span class="hljs-string"><span class="hljs-string">"stringWithArgs"</span></span> = <span class="hljs-string"><span class="hljs-string">"String with %@: %li, %f"</span></span>;</code> </pre> <br><p>  Untuk menampilkan garis seperti itu, Anda harus menambahkan kode formulir </p><br><pre> <code class="hljs lisp">//Swift print(<span class="hljs-name"><span class="hljs-name">String</span></span>(<span class="hljs-name"><span class="hljs-name">format</span></span>: NSLocalizedString(<span class="hljs-string"><span class="hljs-string">"stringWithArgs"</span></span>, comment: <span class="hljs-string"><span class="hljs-string">""</span></span>), <span class="hljs-string"><span class="hljs-string">"some"</span></span>, <span class="hljs-number"><span class="hljs-number">123</span></span>, <span class="hljs-number"><span class="hljs-number">123.098</span></span> ))</code> </pre> <br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">//Objective-C NSLog(@"%@", [NSString stringWithFormat: NSLocalizedString(@"stringWithArgs", @""), @"some", 123, 123.098]);</span></span></code> </pre> <br><p>  Tetapi ketika menggunakan desain seperti itu Anda harus sangat berhati-hati!  Faktanya adalah bahwa iOS secara ketat memonitor jumlah, urutan argumen, korespondensi jenisnya dengan literal yang ditentukan.  Jadi, misalnya, jika Anda mengganti string sebagai argumen kedua alih-alih nilai integer </p><br><pre> <code class="hljs lisp">//Swift print(<span class="hljs-name"><span class="hljs-name">String</span></span>(<span class="hljs-name"><span class="hljs-name">format</span></span>: NSLocalizedString(<span class="hljs-string"><span class="hljs-string">"stringWithArgs"</span></span>, comment: <span class="hljs-string"><span class="hljs-string">""</span></span>), <span class="hljs-string"><span class="hljs-string">"some"</span></span>, <span class="hljs-string"><span class="hljs-string">"123"</span></span>, <span class="hljs-number"><span class="hljs-number">123.098</span></span> ))</code> </pre> <br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">//Objective-C NSLog(@"%@", [NSString stringWithFormat: NSLocalizedString(@"stringWithArgs", @""), @"some", @"123", 123.098]);</span></span></code> </pre> <br><p>  maka aplikasi akan menggantikan kode integer dari string <strong><em>"123"</em></strong> di tempat ketidakcocokan </p><br><pre> <code class="hljs sql">"String <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-keyword"><span class="hljs-keyword">some</span></span>: <span class="hljs-number"><span class="hljs-number">4307341664</span></span>, <span class="hljs-number"><span class="hljs-number">123.089000</span></span><span class="hljs-string"><span class="hljs-string">"</span></span></code> </pre> <br><p>  Jika Anda melewatkannya, kami dapat </p><br><pre> <code class="hljs sql">"String <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-keyword"><span class="hljs-keyword">some</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">123.089000</span></span><span class="hljs-string"><span class="hljs-string">"</span></span></code> </pre> <br><p>  Tetapi jika Anda melewatkan objek yang sesuai dengan <strong><em><code>%@</code></em></strong> dalam daftar argumen </p><br><pre> <code class="hljs lisp">//Swift print(<span class="hljs-name"><span class="hljs-name">String</span></span>(<span class="hljs-name"><span class="hljs-name">format</span></span>: NSLocalizedString(<span class="hljs-string"><span class="hljs-string">"stringWithArgs"</span></span>, comment: <span class="hljs-string"><span class="hljs-string">""</span></span>), <span class="hljs-string"><span class="hljs-string">"123"</span></span>, <span class="hljs-number"><span class="hljs-number">123.098</span></span> ))</code> </pre> <br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">//Objective-C NSLog(@"%@", [NSString stringWithFormat: NSLocalizedString(@"stringWithArgs", @""), @"123", 123.098]);</span></span></code> </pre> <br><p>  maka aplikasi hanya akan crash pada saat eksekusi kode. </p><br><h3 id="push-me-baby-lokalizaciya-uvedomleniy">  Dorong aku, sayang!  Pelokalan pemberitahuan </h3><br><p>  Tugas penting lainnya dalam bekerja dengan sumber daya string terlokalisasi, yang ingin saya bicarakan secara singkat, adalah tugas melokalisasi notifikasi.  Intinya adalah bahwa sebagian besar tutorial (baik pada <em><code>Push Notifications</code></em> dan <em><code>Localizable Strings</code></em> ) sering mengabaikan masalah ini, dan tugas-tugas semacam itu tidak begitu jarang.  Oleh karena itu, ketika dihadapkan dengan ini untuk pertama kalinya, pengembang mungkin memiliki pertanyaan yang masuk akal: <em>apakah ini pada prinsipnya mungkin?</em>  Saya tidak akan mempertimbangkan mekanisme operasi <em><code>Apple Push Notification Service</code></em> sini, terutama sejak mulai dengan iOS 10.0, pemberitahuan Push dan lokal diimplementasikan melalui kerangka kerja yang sama - <strong><code>UserNotifications</code></strong> . </p><br><p>  Anda harus menghadapi masalah serupa ketika mengembangkan aplikasi server-klien multibahasa.  Ketika tugas seperti itu pertama kali menghadang saya, hal pertama yang muncul di benak saya adalah membuang masalah lokalisasi pesan di sisi server.  Idenya sangat sederhana: aplikasi mengirimkan lokalisasi saat ini ke <em>backend</em> saat startup, dan server memilih pesan yang sesuai saat mengirim <em>push</em> .  Tetapi masalahnya segera matang: jika pelokalan perangkat berubah, dan aplikasi tidak dimulai ulang (tidak memperbarui data dalam database), maka server mengirim teks yang sesuai dengan pelokalan "terdaftar" terakhir.  Dan jika aplikasi diinstal pada beberapa perangkat dengan bahasa sistem yang berbeda sekaligus, maka seluruh implementasinya akan bekerja seperti neraka.  Karena solusi seperti itu segera bagi saya tampak sebagai penopang paling liar, saya segera mulai mencari solusi yang memadai (lucu, tetapi di banyak forum "pengembang" menyarankan untuk melokalisasi pushies tepat di <em>backend</em> ). </p><br><p>  Keputusan yang tepat sangat sederhana, meskipun tidak sepenuhnya jelas.  Alih-alih <em>JSON</em> standar yang dikirim oleh server di <em>APNS</em> </p><br><pre> <code class="hljs objectivec"> <span class="hljs-string"><span class="hljs-string">"aps"</span></span> : { <span class="hljs-string"><span class="hljs-string">"alert"</span></span> : { <span class="hljs-string"><span class="hljs-string">"body"</span></span> : <span class="hljs-string"><span class="hljs-string">"some message"</span></span>; }; };</code> </pre> <br><p>  perlu mengirim formulir <em>JSON</em> </p><br><pre> <code class="hljs objectivec"> <span class="hljs-string"><span class="hljs-string">"aps"</span></span> : { <span class="hljs-string"><span class="hljs-string">"alert"</span></span> : { <span class="hljs-string"><span class="hljs-string">"loc-key"</span></span> : <span class="hljs-string"><span class="hljs-string">"message localized key"</span></span>; }; };</code> </pre> <br><p>  di mana <strong><em><code>loc-key</code></em></strong> digunakan untuk meneruskan kunci string yang dilokalkan dari file <strong><em><code>Localizable.strings</code></em></strong> .  Dengan demikian, pesan push ditampilkan sesuai dengan lokalisasi perangkat saat ini. </p><br><p>  Mekanisme interpolasi string lokal dalam pemberitahuan <em>push</em> bekerja dengan cara yang sama: </p><br><pre> <code class="hljs powershell"> <span class="hljs-string"><span class="hljs-string">"aps"</span></span> : { <span class="hljs-string"><span class="hljs-string">"alert"</span></span> : { <span class="hljs-string"><span class="hljs-string">"loc-key"</span></span> : <span class="hljs-string"><span class="hljs-string">"message localized key"</span></span>; <span class="hljs-string"><span class="hljs-string">"loc-args"</span></span> : [ <span class="hljs-string"><span class="hljs-string">"First argument"</span></span>, <span class="hljs-string"><span class="hljs-string">"Second argument"</span></span> ]; }; };</code> </pre> <br><p>  Kunci <strong><em><code>loc-args</code></em></strong> melewati array argumen yang harus disematkan dalam teks notifikasi yang dilokalkan. </p><br><h3 id="podytozhim">  Untuk meringkas ... </h3><br><p>  Jadi, apa yang kita miliki pada akhirnya: </p><br><ul><li>  standar untuk menyimpan data string dalam file <strong><em><code>.string</code></em></strong> khusus dengan sintaksis sederhana dan dapat diakses; </li><li>  kemampuan untuk melokalkan antarmuka tanpa manipulasi tambahan dalam kode; </li><li>  akses cepat ke sumber daya lokal dari kode; </li><li>  pembuatan otomatis file pelokalan dan penataan sumber daya direktori proyek (aplikasi) menggunakan alat Xcode; </li><li>  kemampuan untuk melokalkan teks pemberitahuan. </li></ul><br><p>  , Xcode           ,          . </p><br><p>               . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id419077/">https://habr.com/ru/post/id419077/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id419065/index.html">Intel Dunia Virtual. Berlatih</a></li>
<li><a href="../id419067/index.html">Cara menjual data pribadi, atau mengapa sulit memberi label harga pada informasi</a></li>
<li><a href="../id419069/index.html">Pemanasan global akan membuat dunia kita lebih hijau, tetapi jangan bersukacita</a></li>
<li><a href="../id419071/index.html">Mengikuti hack tp-link</a></li>
<li><a href="../id419075/index.html">Pada pembentukan urutan dalam hipotesis Collatz (3n + 1)</a></li>
<li><a href="../id419085/index.html">Gagasan singularitas sebelum Big Bang sudah ketinggalan zaman</a></li>
<li><a href="../id419087/index.html">Memahami pikiran orang lain adalah mitos</a></li>
<li><a href="../id419089/index.html">Bagaimana cara curang ketika bermain dadu - kiat ahli gim</a></li>
<li><a href="../id419091/index.html">Benda radioaktif di antara kita</a></li>
<li><a href="../id419095/index.html">Kami menulis CSS lebih baik dan lebih indah</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>