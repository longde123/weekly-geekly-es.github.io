<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👊🏿 😘 🏦 FlexiRemap®与RAID 👩🏻‍🚀 🌁 🍳</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="RAID算法是在1987年向公众推出的。 时至今日，它们仍然是保护和加速信息存储领域中数据访问的最流行技术。 但是，已经跨越了30年里程碑的IT技术时代不是成熟，而是老龄化。 原因是进步，必然带来新的机遇。 在除了HDD几乎没有其他驱动器的时代，RAID算法使最有效地利用可用存储资源成为可能。 但是...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>FlexiRemap®与RAID</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/accelstor/blog/445336/"><p> RAID算法是在1987年向公众推出的。 时至今日，它们仍然是保护和加速信息存储领域中数据访问的最流行技术。 但是，已经跨越了30年里程碑的IT技术时代不是成熟，而是老龄化。 原因是进步，必然带来新的机遇。 在除了HDD几乎没有其他驱动器的时代，RAID算法使最有效地利用可用存储资源成为可能。 但是，随着SSD的出现，情况发生了根本变化。 现在，与SSD配合使用时，RAID已经成为其性能的“障碍”。 因此，为了充分发挥SSD的速度特性的潜力，完全有必要使用一种完全不同的方法来使用它们。 </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/xz/ny/fl/xznyflcrmta9iytkfrt6azk6ttq.jpeg"></div><a name="habracut"></a><br><p> 除了HDD和SSD在工作原理上的明显区别外，这些类型的媒体还有一个重要的特征：任何硬盘驱动器都可以在一个块内（现在通常为4K）以粒度覆盖任何数据。 对于SSD，重写过程是一个更为复杂的过程： </p><br><ul><li> 更改的数据将复制到新位置。 同时，粒度是相同的块，但由多个页面组成，大小为256KB-4MB。 即 当更改相同的4KB时，必须复制包括所有相邻页面的内容，从而形成一个块。 </li><li> 将“旧”块标记为未使用，然后用垃圾收集器擦拭它们。 </li></ul><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/wc/e4/6m/wce46mqg4-y_gaq_j91juzk0bg0.png"></div><br><p>  <i>在SSD上顺序写入/覆盖</i> </p><br><p> 在顺序记录/配音的情况下，SSD的此功能在性能方面不会发挥重要作用，因为 这些块位于附近，垃圾收集器正在后台执行其工作。 但是在现实生活中，甚至在用于SSD的企业版中更是如此，最经常使用随机访问数据。 并将此数据写入驱动器上的任意位置。 </p><br><p> 由于碎片迅速增加，写入SSD的数据越多，垃圾收集器的工作就越困难。 结果是，清洁驱动器的过程不再是“后台”的时刻到了：SSD的性能大幅下降，因为 其中很大一部分由垃圾收集器处理。 </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/9m/by/hx/9mbyhx6cjjeorfmu1rsohmcyq28.png"></div><br><p>  <i>固态硬盘上的实际数据布局，可日常使用</i> </p><br><p> 为了说明垃圾收集器的工作效果，根据驱动器上的记录模式，可以执行最简单的测试：将4K块中的顺序和随机记录记录到100GB驱动器中。  （来源- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">美光</a> ） </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/my/bk/u4/mybku4ccwioysxazxa27eacj1yq.png"></div><br><p>  <i>顺序写性能</i> </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/ds/nc/p6/dsncp6gfnotass9g9g1ork7atcu.png"></div><br><p>  <i>随机写入性能</i> </p><br><p> 从测试中可以看到，性能下降可能达到两倍以上。 这只是一个驱动器。 在使用SSD作为RAID组的一部分的情况下，由于使用了奇偶校验，因此重写操作的数量大大增加。 </p><br><p> 通常，由于SSD的这些功能，因此它们具有诸如写系数（写放大）之类的参数。 这是写入驱动器的数据量与主机实际发送的数据量之比。 对于最受欢迎的RAID5，此比率约为3.5。 </p><br><p> 结果，具有经典RAID的系统基本上只使用固态硬盘的约10％的真实速度，并且扩展性很差，驱动器数量增加了十几个。 </p><br><p> 我们还注意到，过多的写操作不仅会降低SSD的性能，还会减少其与无穷资源的距离，从而缩短了驱动器的使用寿命。 </p><br><p> 作为所有AccelStor产品的核心的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">FlexiRemap®技术</a>已被开发出来，以替代用于SSD的经典RAID算法。 多项专利和奖项（包括在2016年闪存峰会上）以及独立测试的结果（例如，SPC1）都指出了该技术的创新。 </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">FlexiRemap®</a>的本质是将所有传入的写入请求（主要是随机类型）转换为一组块，从驱动器的角度来看，这些块与顺序记录尽可能相似。 结果，对他们来说，以最舒适的模式记录到SSD上，最终性能超过了任何具有经典RAID的系统。 </p><br><p>  AccelStor系统中的所有SSD均分为两个对称的FlexiRemap®组。 组的大小取决于型号，并且是5-11个驱动器。 对于组内的弹性，像RAID5一样使用奇偶校验。 这两个组一起使用以形成一个公共存储空间。 因此，由此产生的容错能力将类似于由两组组成的RAID50阵列：该系统能够承受多达两个SSD的故障，但每个FlexiRemap®组最多只能承受一个。 </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/qx/xy/ij/qxxyijh0huqx3civilqtwanvzdk.png"></div><br><p> 所有传入的写入请求均被分成4K块，以循环方式将其写入两个FlexiRemap®组。 此外，系统不断跟踪对记录块的需求，试图记录彼此尽可能近的块。 如果以存储方式表示的话，它实际上是撕裂的类似物。 在这种情况下，极大地简化了垃圾收集器的工作：毕竟，未使用的块将始终在附近。 </p><br><p> 应当注意，与竞争对手的产品不同， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">AccelStor系统</a>不使用控制器RAM中传入请求的缓存功能。 所有传入的数据块都将立即写入SSD。 仅在将数据物理放置在驱动器上之后，主机才会收到成功记录的确认。 仅将SSD上的块分配表存储在RAM中，以加快访问速度并确定将下一个数据块写入何处。 当然，出于可靠性考虑，这些表的副本也位于介质本身上。 因此，AccelStor系统不需要电池/电容器形式的任何高速缓存保护（但是，有机会与UPS建立连接，以便在出现电源问题时进行“软”关机）。 </p><br><p> 由于采用了这种组织记录的方法，垃圾收集器确实能够在后台工作，而不会显着影响驱动器的速度，从而最终允许在系统中利用高达90％的SSD性能。 这正是基于RAID算法的针对全闪存的AccelStor系统中的IOPS。 </p><br><p>  FlexiRemap®技术的另一个重要功能是大大减少了SSD上的冗余写入操作。 因此，AccelStor系统的写放大系数仅为1.3，翻译成通用语言后，意味着驱动器的使用寿命比RAID5延长了2.5倍以上！ </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/qe/zm/kf/qezmkfb5nltjqdh1xsqrqgsnaxm.png"></div><br><p> 由于系统不断监控在SSD上放置数据的策略，因此所有驱动器的磨损方式都相同。 这种方法使我们能够预测其使用寿命，并提前向管理员发出有关录制资源耗尽的信号。 </p><br><p> 很明显，SSD可能会发生故障。 在这种情况下，系统将立即开始重建为热备用驱动器之一。 在这种情况下，处于降级状态的FlexiRemap®组将进入只读模式，并且所有写请求都将发送到第二组。 提供这种保护机制可加快重建操作并减少同一组内另一个驱动器发生故障的可能性。 众所周知，在重建期间，由于热备用上的读取，写入和还原操作的干扰，该组中的所有驱动器的负载都会增加。 这增加了另一个驱动器发生故障的可能性。 记录操作越多，重建所需的时间就越长。 </p><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/qi/nv/mo/qinvmor3hiqo8133beft0yirjfe.png"></div><br><p> 恢复过程完成后，FlexiRemap®组返回其正常状态，两组之间的记录资源将略有偏差。 因此，为了使其对齐，后续的记录操作通常将落在已还原的组上（当然，这样会使最终的系统性能不会受到太大影响）。 </p><br><blockquote> 即使使用复杂的缓存系统，也无法将基于RAID算法的全闪存系统的性能提高到某些值以上（〜280K IOPS @ 4K随机写入）。 由于采用了完全不同的组织存储空间的方法，FlexiRemap®技术不仅可以轻松克服这一障碍，而且还可以将SSD的使用寿命延长数倍。 因此， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">AccelStor</a>系统在所有方面（IOPS / $，GB / $，TCO，ROI）在全闪存阵列中都具有明显的优势，使其成为解决客户数据中心中资源密集型任务关键职位的理想人选。 </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN445336/">https://habr.com/ru/post/zh-CN445336/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN445322/index.html">为产品经理选择大量有用的资源</a></li>
<li><a href="../zh-CN445326/index.html">无情的自动化。 导演剪辑</a></li>
<li><a href="../zh-CN445328/index.html">重新思考儿童机器人</a></li>
<li><a href="../zh-CN445330/index.html">Java中的密码学。 签名班</a></li>
<li><a href="../zh-CN445334/index.html">我们有DevOps。 让我们解雇所有测试人员</a></li>
<li><a href="../zh-CN445338/index.html">Python中的DHCP + Mysql服务器</a></li>
<li><a href="../zh-CN445340/index.html">使用云分析仪提高网络安全性</a></li>
<li><a href="../zh-CN445344/index.html">OpenVox统一通信平台</a></li>
<li><a href="../zh-CN445346/index.html">如何编写错误的API</a></li>
<li><a href="../zh-CN445348/index.html">SNA Hackathon 2019：简化体系结构-简化功能</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>