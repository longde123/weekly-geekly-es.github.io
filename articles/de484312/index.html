<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§∞üèº üí≠ ü§π Effiziente Speicherung von Hunderten Millionen kleiner Dateien. Selbst gehostete L√∂sung üëñ üèáüèæ üí´</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Liebe Community, dieser Artikel befasst sich mit der effizienten Speicherung und Bereitstellung von Hunderten Millionen kleiner Dateien. In dieser Pha...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Effiziente Speicherung von Hunderten Millionen kleiner Dateien. Selbst gehostete L√∂sung</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/484312/"><img src="https://habrastorage.org/webt/32/yq/2a/32yq2adas-fjtcztdzu7fhyhiss.png"><br><br>  Liebe Community, dieser Artikel befasst sich mit der effizienten Speicherung und Bereitstellung von Hunderten Millionen kleiner Dateien.  In dieser Phase wird die endg√ºltige L√∂sung f√ºr POSIX-kompatible Dateisysteme mit vollst√§ndiger Unterst√ºtzung f√ºr Sperren, einschlie√ülich Cluster-Dateisysteme und sogar ohne Kr√ºcken, vorgeschlagen. <br><br>  Deshalb habe ich zu diesem Zweck meinen eigenen spezialisierten Server geschrieben. <br>  W√§hrend dieser Aufgabe konnte das Hauptproblem gel√∂st werden, indem Speicherplatz und RAM gespart wurden, die unser Cluster-Dateisystem gnadenlos verbrauchte.  Tats√§chlich ist eine solche Anzahl von Dateien f√ºr jedes Cluster-Dateisystem sch√§dlich. <a name="habracut"></a><br><br>  Die Idee ist folgende: <br><br>  Mit einfachen Worten, kleine Dateien werden √ºber den Server hochgeladen, sie werden direkt im Archiv gespeichert und auch daraus gelesen, und gro√üe Dateien werden in der N√§he abgelegt.  Schema: 1 Ordner = 1 Archiv, insgesamt haben wir mehrere Millionen Archive mit kleinen Dateien und nicht mehrere hundert Millionen Dateien.  Und all dies ist vollst√§ndig implementiert, ohne Skripte und Dateizerlegung in tar / zip-Archiven. <br><br>  Ich werde versuchen, es k√ºrzer zu machen, ich entschuldige mich im Voraus, wenn der Beitrag gro√ü sein wird. <br><br>  Alles begann mit der Tatsache, dass ich keinen geeigneten Server auf der Welt finden konnte, der √ºber das HTTP-Protokoll empfangene Daten direkt in Archiven speichern konnte, sodass normale Archive und Objekt-Repositorys keine Nachteile aufwiesen.  Und der Grund f√ºr die Suche war ein Cluster von 10 Servern, die zu einem gro√üen Origin gewachsen waren, in dem sich bereits 250.000.000 kleine Dateien angesammelt hatten und der Wachstumstrend nicht aufh√∂ren w√ºrde. <br><br>  <b>Diejenigen, die Artikel und ein wenig Dokumentation nicht gerne lesen, haben es leichter:</b> <br><br>  <a href="" rel="nofollow">hier</a> und <a href="" rel="nofollow">hier</a> . <br><br>  <b>Update</b>  <b>Nginx aus Docker-Image entfernt.</b> <br><br>  Und Docker zur gleichen Zeit: <br><pre><code class="bash hljs">docker run -d --restart=always -e bindaddr=127.0.0.1:9699 \ -e host=localhost -e root=/var/storage -v /var/storage:/var/storage --name wzd \ -p 80:9699 eltaline/wzd</code> </pre> <br>  Weiter: <br><br>  <b>Update</b>  <b>In Version 1.1.0 wurde bereits die HTTPS / POST / IP-Authentifizierungsmethode usw. angezeigt.</b> <br><br>  Wenn es viele Dateien gibt, werden erhebliche Ressourcen ben√∂tigt, und am offensivsten ist, dass einige davon verschwendet werden.  Wenn Sie beispielsweise ein Cluster-Dateisystem (in diesem Fall MooseFS) verwenden, ben√∂tigt eine Datei unabh√§ngig von der tats√§chlichen Gr√∂√üe immer mindestens 64 KB.  Das hei√üt, f√ºr Dateien mit einer Gr√∂√üe von 3, 10 oder 30 KB sind 64 KB auf der Festplatte erforderlich.  Bei einer Viertelmilliarde Dateien verlieren wir 2 bis 10 Terabyte.  Es ist nicht m√∂glich, unbegrenzt neue Dateien zu erstellen, da MooseFS selbst eine Einschr√§nkung aufweist: nicht mehr als 1 Milliarde mit einem Replikat jeder Datei. <br><br>  Wenn die Anzahl der Dateien zunimmt, ben√∂tigen Sie viel RAM f√ºr Metadaten.  H√§ufige gro√üe Metadaten-Dumps tragen auch zum Verschlei√ü von SSDs bei. <br><br>  <b>WZD-Server.</b>  <b>Wir bringen die Scheiben in Ordnung.</b> <br><br>  Der Server ist in Go geschrieben.  Zun√§chst musste ich die Anzahl der Dateien reduzieren.  Wie kann man das machen?  Aufgrund der Archivierung, aber in diesem Fall ohne Komprimierung, da meine Dateien solide, beschnittene Bilder sind.  Zur Rettung kam BoltDB, dem noch M√§ngel vorenthalten werden mussten, was sich in der Dokumentation widerspiegelt. <br><br>  Insgesamt blieben statt einer Viertelmilliarde Akten in meinem Fall nur 10 Millionen Bolt-Archive √ºbrig.  Wenn ich die M√∂glichkeit h√§tte, die aktuelle Struktur des F√ºllens von Verzeichnisdateien zu √§ndern, w√§re es m√∂glich, auf ungef√§hr 1 Million Dateien zu reduzieren. <br><br>  Alle kleinen Dateien werden in Bolt-Archive gepackt und erhalten automatisch die Namen der Verzeichnisse, in denen sie sich befinden. Alle gro√üen Dateien verbleiben neben Archiven. Es macht keinen Sinn, sie zu packen. Dies ist anpassbar.  Klein - Archiv, gro√ü - unver√§ndert lassen.  Der Server arbeitet transparent mit beiden. <br><br>  <b>Architektur und Funktionen des wZD-Servers.</b> <br><br><img src="https://habrastorage.org/webt/uu/yu/t1/uuyut1do539zyzy3qs9atm_h9xg.png"><br><br>  Auf dem Server werden Linux, BSD, Solaris und OSX ausgef√ºhrt.  Ich habe nur die AMD64-Architektur unter Linux getestet, aber sie sollte auch f√ºr ARM64, PPC64 und MIPS64 geeignet sein. <br><br>  <b>Hauptmerkmale:</b> <br><br><ul><li>  Multithreading; </li><li>  Multi-Server, bietet Fehlertoleranz und Lastausgleich; </li><li>  Maximale Transparenz f√ºr den Benutzer oder Entwickler; </li><li>  Unterst√ºtzte HTTP-Methoden: GET, HEAD, PUT und DELETE; </li><li>  Verwaltung des Lese- und Schreibverhaltens √ºber Client-Header; </li><li>  Unterst√ºtzung f√ºr anpassbare virtuelle Hosts; </li><li>  Unterst√ºtzung der CRC-Datenintegrit√§t beim Schreiben / Lesen; </li><li>  Semidynamische Puffer f√ºr minimalen Speicherverbrauch und optimale Abstimmung der Netzwerkleistung; </li><li>  Verz√∂gerte Datenkomprimierung </li><li>  Dar√ºber hinaus wird ein Multithread-wZA-Archivierungsprogramm f√ºr die Dateimigration angeboten, ohne den Dienst zu beenden. </li></ul><br>  <b>Echte Erfahrung:</b> <br><br>  Ich habe den Server und den Archivierer lange Zeit auf Live-Daten entwickelt und getestet. Jetzt funktioniert er erfolgreich in einem Cluster mit 250.000.000 kleinen Dateien (Bildern), die sich in 15.000.000 Verzeichnissen auf separaten SATA-Festplatten befinden.  Ein Cluster von 10 Servern ist ein Origin-Server, der hinter einem CDN-Netzwerk installiert ist.  F√ºr die Wartung werden 2 Nginx-Server + 2 wZD-Server verwendet. <br><br>  F√ºr diejenigen, die sich f√ºr diesen Server entscheiden, ist es sinnvoll, die Verzeichnisstruktur gegebenenfalls vor der Verwendung zu planen.  Machen Sie sofort eine Reservierung, dass der Server nicht daf√ºr ausgelegt ist, alles in das 1-Bolt-Archiv zu verschieben. <br><br>  <b>Leistungstests:</b> <br><br>  Je kleiner die archivierte Datei ist, desto schneller werden die Operationen GET und PUT ausgef√ºhrt.  Vergleichen Sie die Gesamtzeit, die der HTTP-Client in regul√§re Dateien und in Bolt-Archive schreibt und auch liest.  Es vergleicht die Arbeit mit Dateien mit einer Gr√∂√üe von 32 KB, 256 KB, 1024 KB, 4096 KB und 32768 KB. <br><br>  Bei der Arbeit mit Bolt-Archiven wird die Integrit√§t der Daten jeder Datei √ºberpr√ºft (CRC wird verwendet). Vor dem Schreiben und auch nach dem Schreiben wird im laufenden Betrieb gelesen und nachgez√§hlt. Dies f√ºhrt nat√ºrlich zu Verz√∂gerungen. Hauptsache ist jedoch die Datensicherheit. <br><br>  Ich habe Leistungstests auf SSDs durchgef√ºhrt, da die Tests auf SATA-Festplatten keinen deutlichen Unterschied zeigen. <br><br>  <b>Update (v1.1.0), verbesserte Leistung um 5-25%.</b> <br><br>  <b>Diagramme basierend auf Testergebnissen:</b> <br><br><img src="https://habrastorage.org/webt/mi/ok/np/mioknp3lbcmd6vd87l255wksyg0.png"><br><img src="https://habrastorage.org/webt/zz/7b/k_/zz7bk_uhudvy71kyrdk5qe6fulc.png"><br><br>  Wie Sie sehen, ist bei kleinen Dateien der Unterschied in der Lese- und Schreibzeit zwischen archivierten und nicht archivierten Dateien gering. <br><br>  Beim Lesen und Schreiben von 32-MB-Dateien erhalten wir ein v√∂llig anderes Bild: <br><br><img src="https://habrastorage.org/webt/mo/br/xw/mobrxwox3c6o-kq3qjnj7vdaymu.png"><br><br>  Der Zeitunterschied zwischen dem Lesen von Dateien liegt zwischen 5 und 25 ms.  Bei der Aufnahme sieht es noch schlimmer aus, die Differenz betr√§gt ca. 150 ms.  In diesem Fall ist es jedoch nicht erforderlich, gro√üe Dateien hochzuladen. Dies ist einfach nicht sinnvoll. Sie k√∂nnen getrennt von Archiven gespeichert werden. <br><br>  * Technisch gesehen kann dieser Server auch f√ºr Aufgaben verwendet werden, die NoSQL erfordern. <br><br>  <b>Grundlegende Methoden zum Arbeiten mit dem wZD-Server:</b> <br><br>  Laden Sie die regul√§re Datei herunter: <br><pre> <code class="bash hljs">curl -X PUT --data-binary @test.jpg http://localhost/<span class="hljs-built_in"><span class="hljs-built_in">test</span></span>/test.jpg</code> </pre> <br>  Hochladen einer Datei in das Bolt-Archiv (wenn der Serverparameter fmaxsize nicht √ºberschritten wird, der die maximale Dateigr√∂√üe festlegt, die in das Archiv aufgenommen werden kann, wird die Datei bei √úberschreitung wie gewohnt neben dem Archiv geladen): <br><pre> <code class="bash hljs">curl -X PUT -H <span class="hljs-string"><span class="hljs-string">"Archive: 1"</span></span> --data-binary @test.jpg http://localhost/<span class="hljs-built_in"><span class="hljs-built_in">test</span></span>/test.jpg</code> </pre> <br>  Herunterladen einer Datei (wenn sich Dateien mit demselben Namen auf der Festplatte und im Archiv befinden, wird beim Herunterladen der entpackten Datei die Standardpriorit√§t zugewiesen): <br><pre> <code class="bash hljs">curl -o test.jpg http://localhost/<span class="hljs-built_in"><span class="hljs-built_in">test</span></span>/test.jpg</code> </pre> <br>  Herunterladen einer Datei aus dem Bolt-Archiv (erzwungen): <br><pre> <code class="bash hljs">curl -o test.jpg -H <span class="hljs-string"><span class="hljs-string">"FromArchive: 1"</span></span> http://localhost/<span class="hljs-built_in"><span class="hljs-built_in">test</span></span>/test.jpg</code> </pre> <br><br>  Eine Beschreibung anderer Methoden finden Sie in der Dokumentation. <br><br>  <a href="" rel="nofollow">WZD-Dokumentation</a> <br>  <a href="" rel="nofollow">WZA-Dokumentation</a> <br><br>  Der Server unterst√ºtzt bisher nur HTTP, es funktioniert noch nicht mit HTTPS.  Die POST-Methode wird ebenfalls nicht unterst√ºtzt (es wurde noch nicht entschieden, ob sie ben√∂tigt wird oder nicht). <br><br>  Wer sich mit dem Quellcode befasst, findet dort ein Toffee, das nicht jeder mag, aber ich habe den Hauptcode bis auf den Interrupt-Handler nicht an die Funktionen des Webframeworks gebunden, damit ich in Zukunft schnell auf fast jede Engine umschreiben kann. <br><br>  <b>ToDo:</b> <br><br><ul><li>  Entwicklung eines eigenen Replikators und Distributors + Geo f√ºr den Einsatz in gro√üen Systemen ohne Cluster-FSs (alle f√ºr Erwachsene) </li><li>  Die M√∂glichkeit, die Wiederherstellung von Metadaten vollst√§ndig r√ºckg√§ngig zu machen, wenn diese vollst√§ndig verloren gehen (wenn ein Verteiler verwendet wird) </li><li>  Natives Protokoll f√ºr die M√∂glichkeit, permanente Netzwerkverbindungen und Treiber f√ºr verschiedene Programmiersprachen zu verwenden </li><li>  Erweiterte Funktionen zur Verwendung der NoSQL-Komponente </li><li>  Komprimierungen verschiedener Typen (gzip, zstd, snappy) f√ºr Dateien oder Werte in Bolt-Archiven und f√ºr normale Dateien </li><li>  Verschiedene Verschl√ºsselungstypen f√ºr Dateien oder Werte in Bolt-Archiven und f√ºr normale Dateien </li><li>  Verz√∂gerte Server-Videokonvertierung, einschlie√ülich GPU </li></ul><br>  Das ist alles, ich hoffe, dieser Server ist f√ºr jemanden n√ºtzlich, BSD-3-Lizenz, doppelte Urheberrechte, da es kein Unternehmen gibt, in dem ich arbeite, w√ºrde ich auch keinen Server schreiben.  Ich bin ein Entwickler im Singular.  Ich w√§re dankbar f√ºr die gefundenen Bugs und Feature Requests. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de484312/">https://habr.com/ru/post/de484312/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de484300/index.html">Funktionale PowerShell mit Klassen - kein Oxymoron, das garantiere ich</a></li>
<li><a href="../de484302/index.html">Slurm DevOps - eine bessere Arbeitsmeise in 3 Tagen als ein sch√∂ner Kran in ferner Zukunft</a></li>
<li><a href="../de484304/index.html">China verabschiedete sein "Fr√ºhlingspaket"</a></li>
<li><a href="../de484306/index.html">Lernf√§higkeit kann unentscheidbar sein</a></li>
<li><a href="../de484310/index.html">Webix JavaScript-Bibliothek mit den Augen eines Anf√§ngers. Teil 2. Mit Formularen arbeiten</a></li>
<li><a href="../de484320/index.html">Erstellen eines Microservices f√ºr Quarkus, Kotlin und Gradle</a></li>
<li><a href="../de484326/index.html">Springe nach London oder mein Praktikum bei Jump Trading</a></li>
<li><a href="../de484328/index.html">Paul Graham k√ºndigt neue Bel-Programmiersprache an</a></li>
<li><a href="../de484330/index.html">[Nginx] So schlagen Sie response_status = 0</a></li>
<li><a href="../de484332/index.html">Fokus auf Aufgabenverwaltung. Wie wir unser Managementsystem machen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>