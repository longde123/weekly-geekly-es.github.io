<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩‍👧‍👧 🥗 🥩 Localisation dans Go avec des packages de base 👢 🤸🏿 💆</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Créer une bonne application n'est pas facile. Quelle que soit l'application unique et utile que vous écrivez, si l'utilisateur ne l'aime pas, alors, c...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Localisation dans Go avec des packages de base</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/431604/"><p>  Créer une bonne application n'est pas facile.  Quelle que soit l'application unique et utile que vous écrivez, si l'utilisateur ne l'aime pas, alors, comme on dit, vous avez un gros problème.  La plupart des gens n'aiment pas et effraient tout ce qu'ils ne comprennent pas.  Souvent, l'interface utilisateur et les lettres sont la partie visible de l'iceberg de votre application, selon laquelle l'utilisateur l'évalue.  Par conséquent, la localisation de tout ce que l'utilisateur voit est extrêmement importante. </p><br><p>  Rappelez-vous qu'il y a dix ans, alors qu'Internet commençait à peine à entrer dans la vie des masses, et que de nombreux géants de l'informatique étaient au stade de start-up nains avec quelques dizaines d'employés, il était dans l'ordre d'envoyer une lettre en anglais à l'utilisateur.  Et les utilisateurs étaient sympathiques à cela.  Aujourd'hui, lorsque tout est présent sur Internet et que vous n'avez pas besoin d'avoir sept travées dans le front, d'avoir un enseignement supérieur ou de connaître l'anglais pour l'utiliser, il est considéré comme une mauvaise forme de ne pas prendre en charge la localisation dans votre application.  Soit dit en passant, dans notre entreprise, la localisation de tous les textes de l'interface utilisateur est déjà effectuée dans 20 langues et la liste des langues prises en charge est en constante augmentation. </p><br><p> Dans Go, comme dans une langue plutôt jeune, toutes les tendances de développement web modernes sont implémentées au niveau des packages de base et ne nécessitent pas de «danse avec un tambourin» supplémentaire.  (J'ai commencé à apprendre Go il y a quelques années, mais je me souviens encore du sentiment de «superpuissances découvertes» que j'ai ressenti les premiers jours après avoir appris cette langue. Il semblait que maintenant je peux réaliser n'importe quelle tâche en écrivant seulement quelques lignes.) </p><br><p>  Bien sûr, ils n'ont pas non plus ignoré la localisation dans Go.  La localisation est disponible presque « <b>prête</b> à l'emploi» en utilisant les packages de base: <b>golang.org/x/text/language</b> , <b>golang.org/x/text/message</b> et <b>golang.org/x/text/feature/plural</b> .  Voyons à quel point c'est facile dans Go en seulement une demi-heure, en utilisant ces packages, vous pouvez implémenter une tâche non triviale comme la localisation de lettres. </p><a name="habracut"></a><br><p>  Pour l'avenir, je dirai que le but de cet article est principalement de montrer la puissance et la beauté de Go et de mettre en évidence les fonctionnalités de base des packages de messages pour travailler avec les localisations.  Si vous recherchez une solution pour une application de production, vous souhaiterez peut-être une meilleure <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">bibliothèque standard</a> .  Les avantages du <i>go-i18n</i> sont de nombreuses étoiles sur github (parmi eux il y a le mien) et une grande flexibilité.  Cependant, il existe des arguments contre son utilisation: vous n'avez peut-être pas besoin de toute cette flexibilité et fonctionnalité;  pourquoi utiliser une bibliothèque externe alors que tout est déjà implémenté dans le langage lui-même;  si vous avez déjà votre propre système de traduction avec ses propres formats, cette bibliothèque "telle quelle" ne fonctionnera probablement pas et vous devrez quand même la modifier;  et, en fin de compte, l'utilisation d'une bibliothèque tierce n'est pas aussi intéressante et informative que la façon de faire quelque chose vous-même. </p><br><p>  Nous formulons les exigences de base pour la tâche mise en œuvre.  Il existe: a) des étiquettes au format yaml: <i>"nom_étiquette: texte de traduction"</i> ;  la langue de traduction est spécifiée dans le nom du fichier, par exemple ru.yml;  b) modèles d'email en html.  Il est nécessaire, en fonction des paramètres d'entrée: paramètres régionaux et tableau de données, de générer un texte localisé du message. </p><br><p>  Et commençons ... Mais d'abord, quelques mots de plus sur le paquet de messages (golang.org/x/text/message).  Il est conçu pour formater la sortie des chaînes localisées.  Message implémente l'interface du package fmt standard et peut le remplacer.  Exemple d'utilisation: <br><br></p><pre><code class="go hljs">message.SetString(language.Russian, <span class="hljs-string"><span class="hljs-string">"toxic"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>) message.SetString(language.Japanese, <span class="hljs-string"><span class="hljs-string">"toxic"</span></span>, <span class="hljs-string"><span class="hljs-string">"毒性"</span></span>) message.NewPrinter(language.Russian).Println(“toxic”) message.NewPrinter(language.Japanese).Println(“toxic”) <span class="hljs-comment"><span class="hljs-comment">//: // //毒性</span></span></code> </pre> <br>  Pour que l'emballage «voie» l'étiquette, il doit d'abord être déclaré.  Dans l'exemple, la fonction SetString est utilisée pour cela.  Ensuite, une imprimante est créée pour la langue sélectionnée et une chaîne localisée s'affiche directement. <br><p>  Pour résoudre notre problème, nous pourrions générer un fichier go avec toutes les balises, mais ce n'est pas très pratique, car lorsque vous ajoutez de nouvelles balises, vous devrez régénérer ce fichier à chaque fois et reconstruire l'application.  Une autre façon de transmettre un message sur nos balises est d'utiliser des dictionnaires.  Un dictionnaire est une structure qui implémente l'interface de recherche d'étiquettes <i>Lookup (chaîne de clés) (chaîne de données, ok bool)</i> . <br><br>  L'option dictionnaires nous convient.  Tout d'abord, nous définissons la structure du dictionnaire et implémentons l'interface de recherche pour celui-ci: <br><br></p><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> dictionary <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Data <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(d *dictionary)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Lookup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(key </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, ok </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> value, ok := d.Data[key]; ok { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"\x02"</span></span> + value, <span class="hljs-literal"><span class="hljs-literal">true</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span> }</code> </pre><br><p>  Nous analysons toutes les balises des fichiers yaml dans une collection de dictionnaires, qui est une <i>carte au</i> format <i>dictionnaire map [lang] *</i> , où <i>lang</i> est une balise de langue au format <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">BCP47</a> . <br><br></p><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parseYAMLDict</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">map</span></span></span></span><span class="hljs-function"><span class="hljs-params">[</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">]catalog.Dictionary, error)</span></span></span></span> { dir := <span class="hljs-string"><span class="hljs-string">"./translations"</span></span> files, err := ioutil.ReadDir(dir) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, err } translations := <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]catalog.Dictionary{} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, f := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> files { yamlFile, err := ioutil.ReadFile(dir + <span class="hljs-string"><span class="hljs-string">"/"</span></span> + f.Name()) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, err } data := <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>{} err = yaml.Unmarshal(yamlFile, &amp;data) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, err } lang := strings.Split(f.Name(), <span class="hljs-string"><span class="hljs-string">"."</span></span>)[<span class="hljs-number"><span class="hljs-number">0</span></span>] translations[lang] = &amp;dictionary{Data: data} } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> translations, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre><br>  Nous installons la collection de dictionnaires dans la fonction init afin que les dictionnaires puissent être utilisés par le package de messages au démarrage de l'application. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { dict, err := parseYAMLDict() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">panic</span></span>(err) } cat, err := catalog.NewFromMap(dict) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">panic</span></span>(err) } message.DefaultCatalog = cat }</code> </pre><br><p>  Donc, pour le moment, nous avons atteint la disponibilité de la localisation des étiquettes à partir de nos fichiers n'importe où dans le programme: <br><br></p><pre> <code class="go hljs">message.NewPrinter(language.Russian).Println(“label_name”)</code> </pre> <br><p>  Il est temps de passer à la deuxième partie de la tâche et de remplacer nos étiquettes localisées dans les modèles de courrier électronique.  Par exemple, considérez un message simple - une lettre de bienvenue lors de l'inscription d'un utilisateur: <br>  <i>Bonjour, Bill Smith!</i> </p><br><p>  Pour l'analyse, nous utilisons un autre package standard - <b>html / template</b> .  Lors de l'analyse des modèles dans le modèle, vous pouvez définir vos fonctions via <i>.Funcs ()</i> : <br></p><pre> <code class="go hljs">template.New(tplName).Funcs(fmap).ParseFiles(tplName)</code> </pre> <br><p>  Ajoutez une fonction au modèle qui traduira les étiquettes et y substituera des variables, et appelez-la <i>traduire</i> .  Code d'analyse du modèle: <br><br></p><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//  lang:=language.Russian //  tplName:=”./templates/hello.html” //   data := &amp;struct { Name string LastName string }{Name: "Bill", LastName: "Smith"} fmap := template.FuncMap{ //   "translate": message.NewPrinter(lang).Sprintf, } t, err := template.New(tplName).Funcs(fmap).ParseFiles(tplName) if err != nil { panic(err) } buf := bytes.NewBuffer([]byte{}) if err := t.Execute(buf, data); err != nil { panic(err) } fmt.Println(buf.String())</span></span></code> </pre><br>  Le modèle de lettre résultant ./templates/hello.html: <br><br><pre> <code class="xml hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">head</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">title</span></span></span><span class="hljs-tag">&gt;</span></span>{{translate "hello_subject"}}<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">title</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">head</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">body</span></span></span><span class="hljs-tag">&gt;</span></span> {{translate "hello_msg" .Name .LastName}} <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">body</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">html</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  Puisque dans <i>translate</i> nous utilisons la fonction <i>Sprintf</i> pour la localisation, les variables dans le texte de l'étiquette seront cousues en utilisant la syntaxe de cette fonction.  Par exemple, <i>% s</i> est une chaîne, <i>% d</i> est un entier. <br>  Fichiers balisés <br>  en.yml <br><br><pre> <code class="plaintext hljs">hello_subject: Greeting mail hello_msg: Hello, %s %s!</code> </pre><br>  ru.yml <br><br><pre> <code class="plaintext hljs">hello_subject:   hello_msg: , %s %s!</code> </pre><br><p>  Sur cela, en principe, c’est tout, la localisation des lettres est prête!  Ayant écrit seulement quelques dizaines de lignes de code, nous avons obtenu de puissantes fonctionnalités qui permettent de localiser des lettres de toute complexité dans des dizaines de langues. </p><br><p>  Si vous avez aimé cet exemple, vous pouvez continuer et implémenter la pluralisation vous-même, en utilisant des noms de variables pour les variables dans les étiquettes au lieu de <i>% s</i> et en utilisant des fonctions dans les étiquettes.  Je n'ai délibérément pas fait cela pour laisser de la place à votre imagination. </p><br><p>  Le code dans les exemples est écrit spécifiquement pour démontrer les capacités du package de message et ne prétend pas être idéal; une liste complète du code est disponible sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">github</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr431604/">https://habr.com/ru/post/fr431604/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr431590/index.html">La modernisation des parcs éoliens britanniques obsolètes augmentera la production d'énergie de 171%</a></li>
<li><a href="../fr431596/index.html">Test de charge de sauvegarde et de réplication Veeam</a></li>
<li><a href="../fr431598/index.html">Nous apportons à Internet une machine virtuelle publique QEMU sans carte réseau et essayons d'exploiter</a></li>
<li><a href="../fr431600/index.html">Augmenter IDS / NMS: Mikrotik et Suricata avec une interface Web</a></li>
<li><a href="../fr431602/index.html">Les développeurs russes ont présenté à Londres un système de réadaptation virtuel</a></li>
<li><a href="../fr431608/index.html">La société américaine DriveSavers est la première au monde à lancer un service de piratage iPhone pour les particuliers</a></li>
<li><a href="../fr431610/index.html">Chef de projet Lifehacks</a></li>
<li><a href="../fr431612/index.html">Boîte à musique et encodeur rotatif sur carte FPGA</a></li>
<li><a href="../fr431614/index.html">Création d'art à l'aide de DCGAN sur Keras</a></li>
<li><a href="../fr431616/index.html">Introduction aux propriétés CSS personnalisées</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>