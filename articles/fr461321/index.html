<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèáüèº üîß üßù Mod√®les g√©n√©riques et de m√©taprogrammation: Go, Rust, Swift, D et autres üßöüèø üßò üëÆ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans certains domaines de la programmation, il est normal de vouloir √©crire une structure de donn√©es ou un algorithme pouvant fonctionner avec des √©l√©...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mod√®les g√©n√©riques et de m√©taprogrammation: Go, Rust, Swift, D et autres</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/461321/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/cs/o5/zc/cso5zcp78nxxi31mspfvdat89w4.jpeg"></div><br>  Dans certains domaines de la programmation, il est normal de vouloir √©crire une structure de donn√©es ou un algorithme pouvant fonctionner avec des √©l√©ments de diff√©rents types.  Par exemple, une liste de g√©n√©riques ou un algorithme de tri qui n'a besoin que d'une fonction de comparaison.  Dans divers langages, diff√©rentes mani√®res de r√©soudre ce probl√®me sont propos√©es: du simple fait de signaler les fonctions communes appropri√©es (C, Go) aux programmeurs √† des syst√®mes g√©n√©riques si puissants qu'ils deviennent Turing complet ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Rust</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">C ++</a> ).  Dans cet article, je parlerai des syst√®mes g√©n√©riques de diff√©rentes langues et de leur impl√©mentation.  Je commencerai par r√©soudre le probl√®me dans les langues sans un tel syst√®me (comme C), puis je montrerai comment l'ajout progressif d'extensions conduit √† des syst√®mes d'autres langues. <br><a name="habracut"></a><br>  Je trouve que les g√©n√©riques sont une option int√©ressante, car ils sont un cas sp√©cial simple du probl√®me g√©n√©ral de m√©taprogrammation: √©crire des programmes qui peuvent g√©n√©rer des classes d'autres programmes.  Pour preuve, je montrerai comment trois m√©thodes de m√©taprogrammation diff√©rentes et compl√®tement g√©n√©rales peuvent √™tre consid√©r√©es comme des extensions multidirectionnelles dans l'espace des syst√®mes g√©n√©riques: les langages dynamiques comme Python, les macro-syst√®mes proc√©duraux comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Template Haskel</a> et la compilation par phases comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Zig</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Terra</a> . <br><br><h2>  Revue </h2><br>  J'ai dessin√© un sch√©ma de principe de tous les syst√®mes d√©crits dans l'article afin que vous puissiez pr√©senter son contenu et comment ces syst√®mes sont interconnect√©s: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5fa/259/577/5fa259577cd99685d90ab7912710e348.png"><br><br><h2>  Id√©es principales </h2><br>  Supposons que nous √©crivons dans un langage sans syst√®mes g√©n√©riques et que nous voulons cr√©er une structure de donn√©es de structure de donn√©es de pile g√©n√©rique qui fonctionne avec des donn√©es de tout type.  Le probl√®me est que chaque d√©finition de fonction et de type ne fonctionnera qu'avec des donn√©es de m√™me taille et copi√©es dans un sens, et fonctionnera g√©n√©ralement de la m√™me mani√®re. <br><br>  Il existe deux fa√ßons de contourner ce probl√®me: soit assurez-vous que tous les types de donn√©es agissent de la m√™me mani√®re dans notre structure, soit faites de nombreuses copies de la structure de donn√©es avec des modifications mineures pour fonctionner correctement avec chaque type de donn√©es.  Ces id√©es ont form√© la base de deux grands groupes de solutions g√©n√©riques: la boxe et la monomorphisation. <br><br>  L'emballage signifie mettre tout de suite dans des ¬´bo√Ætes¬ª unifi√©es qui fonctionnent de la m√™me mani√®re.  Cela se fait g√©n√©ralement comme ceci: les donn√©es sont plac√©es dans un tas et les pointeurs vers celles-ci sont plac√©s dans la structure de donn√©es.  Vous pouvez cr√©er des pointeurs vers tous les types qui fonctionneront de la m√™me mani√®re, donc le m√™me code fonctionnera avec des donn√©es de tout type!  Cependant, cela entra√Æne une consommation de m√©moire accrue, une recherche dynamique et des √©checs de cache.  En C, cela signifie que votre structure de donn√©es stocke des pointeurs <code>void*</code> et met simplement en cache les donn√©es vers et depuis <code>void*</code> (si les donn√©es ne sont pas sur le tas, elles les placent l√†). <br><br>  La monomorphisation signifie la copie r√©p√©t√©e de code pour les diff√©rents types de donn√©es que nous voulons stocker.  Ensuite, chaque instance de code peut utiliser directement la taille et les m√©thodes de donn√©es avec lesquelles elle fonctionne sans recherche dynamique.  Avec cette approche, le code s'ex√©cute le plus rapidement, mais sa taille et son temps de compilation augmentent, car nous compilons √† plusieurs reprises le m√™me code avec des modifications mineures.  En C, cela correspond √† la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">d√©finition de la structure de donn√©es enti√®re en tant que macro</a> , suivie de son invocation pour chaque type de donn√©es. <br><br>  En g√©n√©ral, lors de la compilation, le code se compile plus rapidement, mais ses performances peuvent se d√©t√©riorer pendant l'ex√©cution, tandis que pendant la monomorphisation, nous g√©n√©rons du code rapide, mais il faut plus de temps pour compiler et optimiser toutes les instances du code.  Une autre diff√©rence est que lorsque les extensions d'empaquetage vous permettent de faire un comportement plus dynamique du code ex√©cutable, et la monomorphisation vous permet de s√©parer de mani√®re plus flexible diff√©rentes instances du code g√©n√©rique.  Il convient √©galement de noter que dans certains grands programmes, les avantages de la monomorphisation peuvent √™tre compens√©s par des √©checs dans le cache d'instructions suppl√©mentaires du code g√©n√©r√©. <br><br>  Chacun des sch√©mas d√©crits pour travailler avec des g√©n√©riques peut √™tre d√©velopp√© dans diff√©rentes directions, si vous avez besoin de plus de fonctionnalit√©s ou de s√©curit√©, et les auteurs de diff√©rentes langues ont trouv√© des solutions tr√®s int√©ressantes.  Par exemple, les deux approches peuvent √™tre utilis√©es dans Rust et C #! <br><br><h2>  Emballage </h2><br>  Commen√ßons par un exemple d'emballage de base dans Go: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Stack <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { values []<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{} } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(this *Stack)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Push</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span></span> { this.values = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(this.values, value) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(this *Stack)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Pop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">interface</span></span></span></span>{} { x := this.values[<span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(this.values)<span class="hljs-number"><span class="hljs-number">-1</span></span>] this.values = this.values[:<span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(this.values)<span class="hljs-number"><span class="hljs-number">-1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x }</code> </pre> <br>  De plus, le packaging est utilis√© en C ( <code>void*</code> ), Go ( <code>interface{}</code> ), Java pr√©-g√©n√©rique ( <code>Object</code> ) et Objective-C pr√©-g√©n√©rique ( <code>id</code> ). <br><br><h2>  G√©n√©riques emball√©s avec types de pur√©e </h2><br>  La principale m√©thode d'emballage pr√©sente des inconv√©nients: <br><br><ul><li>  Selon la langue, nous devons souvent convertir des valeurs vers ou √† partir du type correct chaque fois que nous lisons ou √©crivons dans la structure de donn√©es. <br></li><li>  Rien ne nous emp√™che de mettre des √©l√©ments de diff√©rents types dans la structure, ce qui peut provoquer des bugs qui ressemblent √† des plantages lors de l'ex√©cution du code. <br></li></ul><br>  Les deux probl√®mes peuvent √™tre r√©solus en ajoutant des g√©n√©riques au syst√®me de types de fonctionnalit√©s, tout en utilisant la m√©thode d'empaquetage principale de la m√™me mani√®re qu'auparavant lors de l'ex√©cution du code.  Cette approche est souvent appel√©e effacement de type, car les types du syst√®me g√©n√©rique sont √©cras√©s et deviennent un type sous le capot (comme <code>Object</code> ). <br><br>  Java et Objective-C ont commenc√© avec le packaging habituel, et ont ensuite acquis des outils de langage pour les g√©n√©riques avec le mashing de type, par souci de compatibilit√©, en utilisant les m√™mes types de collection qu'auparavant, mais avec les param√®tres facultatifs des types g√©n√©riques.  Prenons un exemple tir√© d'un article de Wikipedia sur les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">g√©n√©riques en Java</a> : <br><br><pre> <code class="java hljs">List v = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList(); v.add(<span class="hljs-string"><span class="hljs-string">"test"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// A String that cannot be cast to an Integer Integer i = (Integer)v.get(0); // Run time error List&lt;String&gt; v = new ArrayList&lt;String&gt;(); v.add("test"); Integer i = v.get(0); // (type error) compilation-time error</span></span></code> </pre><br><h3>  G√©n√©riques packag√©s d√©riv√©s avec performances unifi√©es </h3><br>  OCaml d√©veloppe encore l'id√©e d'une vision unifi√©e.  Il n'y a pas de types primitifs qui n√©cessitent un placement d'empaquetage suppl√©mentaire (car un <code>Integer</code> doit se transformer en <code>Integer</code> pour entrer dans une liste de <code>ArrayList</code> en Java), car tout est d√©j√† compress√© ou repr√©sent√© par une valeur enti√®re de la taille d'un pointeur, c'est-√†-dire que tout tient dans un seul mot machine.  Mais lorsque le garbage collector examine les donn√©es stock√©es dans des structures g√©n√©riques, il doit distinguer les pointeurs des nombres, de sorte que les nombres sont marqu√©s avec un bit, plac√©s l√† o√π les pointeurs correctement align√©s n'ont pas un bit, laissant des plages de seulement 31 ou 63 bits. <br><br>  OCaml dispose √©galement d'un syst√®me d'inf√©rence de type, vous pouvez donc √©crire une fonction et le compilateur affichera le type g√©n√©rique le plus appropri√© si vous ne l'annotez pas, et donc les fonctions ressembleront √† un langage typ√© dynamiquement: <br><br><pre> <code class="plaintext hljs">let first (head :: tail) = head (* inferred type: 'a list -&gt; 'a *)</code> </pre> <br>  Le type donn√© peut √™tre appel√© ¬´une fonction de la liste des √©l√©ments de type <code>'a</code> vers quelque chose de type <code>'a</code> ¬ª.  Cela signifie que le type de retour sera le m√™me que le type de liste, et il peut √™tre de n'importe quel type. <br><br><h2>  Interfaces </h2><br>  Une autre limitation de l'emballage conventionnel est que les types emball√©s sont <i>compl√®tement</i> opaques.  Ce n'est pas un probl√®me pour les structures de donn√©es comme une pile, mais des outils comme le tri des fonctions g√©n√©riques n√©cessitent des fonctionnalit√©s suppl√©mentaires, telles que des fonctions de comparaison sp√©cifiques au type.  Il existe de nombreuses fa√ßons de l'impl√©menter lors de l'ex√©cution et de refl√©ter dans le langage, techniquement, ce sont des directions diff√©rentes, et vous pouvez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">impl√©menter le m√™me langage avec plusieurs approches similaires</a> .  Cependant, les fonctionnalit√©s de diff√©rents langages affectent leur impl√©mentation et ce n'est qu'alors que les extensions am√©liorent les points forts des impl√©mentations s√©lectionn√©es.  Cela signifie qu'il existe deux familles de langages bas√©es sur des approches diff√©rentes de l'ex√©cution: les tables de m√©thodes virtuelles (vtables) et le transfert de dictionnaire. <br><br><h3>  Tableaux de m√©thodes d'interface </h3><br>  Si nous voulons fournir des fonctions sp√©cifiques au type, en adh√©rant √† la strat√©gie d'emballage pour le travail unifi√© avec tout, alors il suffit d'avoir un moyen unifi√© de trouver des fonctions similaires que nous devons obtenir de l'objet.  Cette approche est appel√©e ¬´tables de m√©thodes virtuelles¬ª (vtables, tables de m√©thodes virtuelles), bien que personne n'utilise le nom complet.  Il est impl√©ment√© comme suit: √† un d√©calage nul dans chaque objet de structure g√©n√©rique, il y a un pointeur vers une table de pointeurs de fonction avec un circuit coh√©rent.  Dans ces tableaux, le code g√©n√©rique recherche des pointeurs vers des fonctions sp√©cifiques au type en indexant des pointeurs sp√©cifiques √† des d√©calages fixes. <br><br>  C'est ainsi que <code>interface</code> types d' <code>interface</code> sont impl√©ment√©s dans les objets <code>dyn trait</code> Go et <code>dyn trait</code> dans Rust.  Lorsque vous convertissez un type en un type d'interface de ce qu'il impl√©mente, un wrapper est cr√©√© pour l'interface qui contient un pointeur sur l'objet source et un pointeur sur la table des fonctions sp√©cifiques au type.  Mais cela n√©cessite un niveau suppl√©mentaire d'adressage indirect des pointeurs et un autre sch√©ma.  Par cons√©quent, le tri dans Go utilise l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">interface du conteneur avec la m√©thode Swap</a> et ne prend pas la tranche de l'interface comparable, car cela n√©cessiterait de placer en m√©moire une toute nouvelle tranche de types d'interface qui serait tri√©e √† la place de la tranche d'origine! <br><br><h3>  Programmation orient√©e objet </h3><br>  La POO est une propri√©t√© de langage qui fait bon usage des capacit√©s des tables de types virtuels.  Au lieu d'objets d'interface s√©par√©s avec vtables, les langages OOP comme Java ins√®rent simplement un pointeur vers une table de types virtuels au d√©but de chaque objet.  Les langages de type Java ont un syst√®me d'h√©ritage et des interfaces qui peuvent √™tre enti√®rement impl√©ment√©es √† l'aide de ces tables d'objets de type virtuel. <br><br>  En plus de fournir des fonctionnalit√©s suppl√©mentaires, l'int√©gration de vtable dans chaque objet r√©sout le probl√®me de la n√©cessit√© de construire de nouveaux types d'interface avec un adressage indirect (indirection).  Contrairement √† Go, en Java <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">, la fonction de tri</a> peut appliquer l'interface <code>Comparable</code> aux types qu'elle impl√©mente. <br><br><h3>  La r√©flexion </h3><br>  Si vous avez des tables de types virtuels, il ne vous sera pas difficile de forcer le compilateur √† g√©n√©rer des tables d'autres types d'informations, par exemple, des noms de champs, des types et des emplacements.  Cela permettra d'acc√©der √† toutes les donn√©es de ce type √† l'aide d'un code qui peut afficher toutes les donn√©es de tout autre type.  Ce comportement peut √™tre utilis√© pour ajouter de la ¬´r√©flexion¬ª au langage, ce qui permet la s√©rialisation et un bel affichage de types arbitraires.  La r√©flexion, en tant qu'extension du paradigme de l'empaquetage, a un inconv√©nient: pour cela, une seule copie du code suffit, mais vous devez effectuer de nombreuses recherches dynamiques, ce qui r√©duit la vitesse de s√©rialisation. <br><br>  Langages qui utilisent la r√©flexion pour la s√©rialisation et d'autres fonctions: Java, C # et Go. <br><br><h3>  Langues typ√©es dynamiquement </h3><br>  La r√©flexion est un outil tr√®s puissant qui vous permet de r√©soudre un tas de t√¢ches de m√©taprogrammation diff√©rentes.  Mais cela ne vous permet pas de cr√©er de nouveaux types ou de modifier des informations sur les types de valeurs existantes.  Si nous ajoutons cette fonctionnalit√© et que les syntaxes d'acc√®s aux donn√©es et de modification utilisent la r√©flexion par d√©faut, nous obtenons des langages typ√©s dynamiquement!  L'incroyable flexibilit√© de la m√©taprogrammation dans des langages comme Python et Ruby est n√©e gr√¢ce aux syst√®mes de r√©flexion efficaces et puissants qui sont utilis√©s pour r√©soudre tous les probl√®mes. <br><br>  Vous pouvez dire: "Mais les langages dynamiques ne fonctionnent pas comme √ßa, ils impl√©mentent simplement tout en utilisant des tables de hachage!"  Les tables de hachage ne sont qu'une bonne structure de donn√©es pour cr√©er des tables modifiables avec des informations de type.  De plus, certains interpr√®tes, tels que CPython, fonctionnent de cette fa√ßon.  Dans un JIT hautes performances, par exemple V8, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">il y a beaucoup de tables de types virtuels et d'</a> informations de r√©flexion.  Dans la V8, les classes cach√©es (vtables et informations de r√©flexion) et la structure des objets sont similaires √† ce que vous pouvez voir dans Java VM, avec la possibilit√© de remplacer des objets par de nouvelles tables de types virtuels lors de l'ex√©cution.  Ce n'est pas une co√Øncidence, car il n'y a pas de co√Øncidences: le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cr√©ateur de V8</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">travaillait sur une machine virtuelle Java haute performance</a> . <br><br><h3>  Transfert de dictionnaire </h3><br>  Une autre fa√ßon d'impl√©menter des interfaces dynamiques consiste √† transf√©rer une table avec les pointeurs de fonction requis vers la fonction g√©n√©rique qui en a besoin.  Ceci est quelque peu similaire √† la construction d'objets d'interface en forme de Go sur le lieu de l'appel, seulement dans notre cas, la table est pass√©e comme argument cach√©, et non empaquet√©e dans un bundle comme l'un des arguments existants. <br><br>  Cette approche est utilis√©e dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">les classes de types dans Haskell</a> , bien que GHC vous permette d'effectuer une sorte de monomorphisation en utilisant l'inline et la sp√©cialisation.  OCaml utilise le transfert de dictionnaire avec un argument explicite sous la forme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">de modules de premi√®re classe</a> , mais il a d√©j√† √©t√© propos√© d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ajouter la possibilit√© de rendre le param√®tre implicite</a> . <br><br><h3>  Tables de t√©moins dans Swift </h3><br>  Les auteurs de Swift ont utilis√© une solution int√©ressante: le transfert du dictionnaire, ainsi que la mise en place de donn√©es sur les tailles de caract√®res et comment les d√©placer, les copier et les publier dans le tableau, vous permet de fournir toutes les informations n√©cessaires pour un travail unifi√© avec tous les types sans les emballer.  Ainsi, Swift peut impl√©menter des g√©n√©riques <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sans monomorphisation et placement en m√©moire dans une repr√©sentation unifi√©e de</a> toutes les entit√©s!  Oui, vous devez payer pour les recherches dynamiques, comme c'est la caract√©ristique de toute la famille qui utilise le packaging, mais cela √©conomise des ressources pour le placement en m√©moire, sa consommation et l'incoh√©rence du cache.  En utilisant les fonctions <a href="">annot√©es comme @inlinable</a> , le compilateur Swift est √©galement capable de sp√©cialiser (monomorphiser) et de g√©n√©rer des g√©n√©riques √† l'int√©rieur du module ou entre les modules pour √©viter les d√©penses mentionn√©es.  Une √©valuation heuristique de l'effet sur la taille du code est probablement utilis√©e. <br><br>  Cela explique √©galement comment Swift peut <a href="">impl√©menter la stabilit√© ABI</a> , tout en vous permettant d'ajouter et de redistribuer des champs dans la structure, bien que les auteurs fournissent l'attribut <code>@frozen</code> pour refuser les recherches dynamiques pour de meilleures performances. <br><br><h3>  Analyse de type intensionnelle </h3><br>  Il existe une autre fa√ßon d'impl√©menter des interfaces pour les types packag√©s.  Nous ajoutons l'identificateur de type √† une certaine partie de l'objet, en suivant l'exemple du pointeur vtable, puis g√©n√©rons des fonctions pour chaque m√©thode d'interface qui a une grande expression de <code>switch</code> pour tous les types qui impl√©mentent cette m√©thode et la transmettons √† la m√©thode sp√©cifique au type correcte. <br><br>  Je ne mets pas en garde contre l'utilisation de langages qui utilisent cette approche, mais les compilateurs C ++ et les machines virtuelles Java agissent de la m√™me mani√®re, lorsqu'ils utilisent l'optimisation bas√©e sur des profils, ils d√©couvrent qu'un certain endroit de l'appel des g√©n√©riques fonctionne principalement avec des objets de certains types.  Les compilateurs et les machines virtuelles remplacent les points d'appel par des v√©rifications pour chaque type ordinaire, puis r√©partissent statiquement ces types, comme solution de rechange en utilisant la r√©partition dynamique conventionnelle.  Par cons√©quent, l'algorithme de pr√©diction de branche peut pr√©dire quelle branche le code continuera et continuera √† envoyer des instructions √† l'aide d'appels statiques. <br><br><h2>  Monomorphisation </h2><br>  Il s'agit d'une alternative √† l'emballage.  Avec la monomorphisation, nous devons trouver un moyen de g√©n√©rer plusieurs versions du code pour chaque type que nous voulons utiliser.  Les compilateurs ont plusieurs phases de pr√©sentation que le code traverse et, th√©oriquement, peuvent √™tre copi√©s √† n'importe laquelle de ces √©tapes. <br><br><h3>  G√©n√©ration de code source </h3><br>  La fa√ßon la plus simple de monomorphiser est de copier au premier stade de la pr√©sentation: copiez le code source!  Ensuite, le compilateur n'a m√™me pas √† prendre en charge les g√©n√©riques, et cela est parfois fait par les utilisateurs des langages C et Go, dont les compilateurs ne disposent pas d'un tel support. <br><br>  En C, vous pouvez utiliser un pr√©processeur et d√©finir la structure de donn√©es dans une macro ou un en-t√™te en l'ins√©rant √† plusieurs reprises avec diff√©rents <code>#define</code> .  Go a des scripts comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">genny</a> qui facilitent la g√©n√©ration de code. <br><br>  L'inconv√©nient de la duplication du code source est que, selon la langue, il peut √™tre n√©cessaire de traiter de nombreux probl√®mes et cas marginaux.En outre, le compilateur analyse et v√©rifie plusieurs fois les types r√©ellement pour le m√™me code.  Encore une fois, selon le langage et les outils, ces g√©n√©riques de m√©thodes peuvent √™tre difficiles √† √©crire et √† utiliser, comme si √† l'int√©rieur d'une macro C chaque ligne se termine par une barre oblique inverse et tous les types et noms de fonctions doivent √™tre coll√©s manuellement dans leurs identifiants pour √©viter les collisions. <br><br><h3>  Mixins √† cordes en r√© </h3><br>  Cependant, la g√©n√©ration de code a ses avantages, comme le fait que vous pouvez g√©n√©rer du code en utilisant un langage de programmation √† part enti√®re, ainsi que d'utiliser une vue famili√®re aux utilisateurs. <br><br>  Certains langages dans lesquels les g√©n√©riques sont impl√©ment√©s diff√©remment vous permettent √©galement de g√©n√©rer du code pour des cas de m√©taprogrammation plus g√©n√©raux qui ne sont pas pris en compte dans leurs syst√®mes g√©n√©riques, par exemple pour la s√©rialisation.  L'exemple le plus compr√©hensible est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le mixage de cha√Ænes en D</a> , qui permet de compiler du code D sous forme de valeurs de cha√Æne au milieu de la compilation, en utilisant toutes les fonctionnalit√©s du langage. <br><br><h3>  Macros proc√©durales de rouille </h3><br>  Un exemple similaire, uniquement avec une repr√©sentation dans le compilateur √† une seule √©tape.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Les macros proc√©durales de Rust</a> utilisent des flux de jetons comme entr√©e et sortie, fournissant des utilitaires pour convertir ces flux en cha√Æne et vice versa.  L'avantage de cette approche est que les flux de jetons peuvent stocker des informations de localisation √† partir du code source.  Le code √©crit par l'utilisateur, la macro peut √™tre ins√©r√©e en tant que jetons directement de l'entr√©e au week-end.  Et si ce code conduit √† une erreur de compilation dans la sortie des macos, le compilateur affichera un message et pointera avec pr√©cision vers le fichier, la ligne et la colonne de la partie cass√©e du code.  Mais si la macro g√©n√®re un code cass√©, un message d'erreur indiquera un appel de macro.  Par exemple, si vous utilisez une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">macro qui encapsule une fonction dans la journalisation des appels</a> et commet une erreur lors de l'impl√©mentation d'une fonction encapsul√©e, le message d'erreur pointera directement vers l'erreur dans le fichier et non vers le code g√©n√©r√© par la macro. <br><br><h3>  Macros d'arborescence de syntaxe </h3><br>  Certaines langues vont encore plus loin et proposent des outils pour utiliser et cr√©er diff√©rents types d'arbres de syntaxe abstraite dans les macros (Abstract Syntax Tree, AST).  Les exemples incluent <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Template Haskell</a> , les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">macros Nim</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">OCaml PPX</a> et presque tous <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Lisp</a> . <br><br>  L'inconv√©nient des macros AST est que vous ne voulez pas forcer les utilisateurs √† apprendre un tas de fonctions pour cr√©er des types AST, ainsi que des langages de base.  Dans la famille de langages Lisp, cela est r√©solu √† l'aide d'une forte simplification et d'une correspondance maximale entre la syntaxe et la structure d'AST, cependant, la cr√©ation de structures n'est pas toujours facile. <br><br>  Ainsi, dans toutes les langues que j'ai mentionn√©es, sous une forme ou une autre, il existe une primitive ¬´quote¬ª √† laquelle vous donnez un morceau de code dans la langue, et qui renvoie un arbre de syntaxe.  Ces primitives peuvent fusionner les valeurs de l'arbre de syntaxe en utilisant la similitude de l'interpolation de cha√Ænes.  Voici un exemple sur Template Haskell: <br><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- using AST construction functions genFn :: Name -&gt; Q Exp genFn f = do x &lt;- newName "x" lamE [varP x] (appE (varE f) (varE x)) -- using quotation with $() for splicing genFn' :: Name -&gt; Q Exp genFn' f = [| \x -&gt; $(varE f) x |]</span></span></code> </pre> <br>         ,     ,   ,           .      .  ,  PPX  OCaml  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">     </a> /  ,  .  Rust  ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">parsing</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">quotation</a> ,          ,       .    Rust  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> ,    ,  </a> ! <br><br><h3>  Patterns </h3><br>    ‚Äî        .   ++  D    ,         ¬´ ¬ª.        ,     ,      ,        ,   . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">myMax</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">b</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (a&gt;b?a:b); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pair</span></span></span><span class="hljs-class"> {</span></span> T values[<span class="hljs-number"><span class="hljs-number">2</span></span>]; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ myMax(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>); Pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; p { {<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>} }; <span class="hljs-comment"><span class="hljs-comment">// This would give us a compile error inside myMax // about Pair being an invalid operand to `&gt;`: // myMax(p, p); }</span></span></code> </pre> <br>       ,                 ,        .     ,         ,     .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">D</a>     ,  ,       :       ,    ,       .    D;    <code>if</code>       ( <code>!</code>     ): <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// We're going to use the isNumeric function in std.traits import std.traits; // The `if` is optional (without it you'll get an error inside like C++) // The `if` is also included in docs and participates in overloading! T myMax(T)(T a, T b) if(isNumeric!T) { return (a&gt;b?a:b); } struct Pair(T) { T[2] values; } void main() { myMax(5, 6); Pair!int p = {[5,6]}; // This would give a compile error saying that `(Pair!int, Pair!int)` // doesn't match the available instance `myMax(T a, T b) if(isNumeric!T)`: // myMax(p, p); }</span></span></code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">C++20  ¬´¬ª</a> ,      ,           . <br><br><h3>    </h3><br>    D   ,        (compile time function evaluation)  <code>static if</code> , ,  ,    ,          - runtime-.          , ,   ,    ++    ,    . <br><br>  ,      ¬´    ¬ª. , Zig: <br><br><pre> <code class="plaintext hljs">fn Stack(comptime T: type) type { return struct { items: []T, len: usize, const Self = @This(); pub fn push(self: Self, item: T) { // ... } }; }</code> </pre> <br>  Zig            ,      ,  <code>comptime</code> .   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Terra</a>    ,   . Terra ‚Äî   Lua,     -  ,     Lua API    ,    quoting  splicing: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MakeStack</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> struct Stack { items : &amp;T; <span class="hljs-comment"><span class="hljs-comment">-- &amp;T is a pointer to T len : int; } terra Stack:push(item : T) -- ... end return Stack end</span></span></code> </pre> <br>     Terra  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">        - (domain specific) </a> ,       <a href="">Java</a>  <a href="">Go</a>      .    Terra      runtime     ,   . <br><br><h3>   Rust </h3><br>           ,   .  ,    ,      ++,       .   ,    ,  ,     ,   .      ,                  .     Rust,     ‚Äî  Swift  Haskell. <br><br>  Rust      ¬´ ¬ª (trait bounds). <code>Trait</code> ‚Äî      ,    ,  .  Rust ,     -    ,   ,      ,      .   -  Rust <i></i>         .  ,           -. <br><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">my_max</span></span></span></span>&lt;T: <span class="hljs-built_in"><span class="hljs-built_in">PartialOrd</span></span>&gt;(a: T, b: T) -&gt; T { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> a &gt; b { a } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { b } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pair</span></span></span></span>&lt;T&gt; { values: [T; <span class="hljs-number"><span class="hljs-number">2</span></span>], } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { my_max(<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> p: Pair&lt;<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>&gt; = Pair { values: [<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>] }; <span class="hljs-comment"><span class="hljs-comment">// Would give a compile error saying that // PartialOrd is not implemented for Pair&lt;i32&gt;: // my_max(p,p); }</span></span></code> </pre> <br>           ,            .  Rust       .  Rust 2018    ,    <code>v: &amp;impl SomeTrait</code>  ,   <code>v: &amp;dyn SomeTrait</code>  .      GHC  Swift  Haskell     ,       . <br><br><h3>    </h3><br>        ‚Äî          ,  .      ,    (placeholders)  -,           ,    .            <code>memcpy</code>   ,  !   ,       .          .         JIT,            ,     . <br><br>   ,      ,    ,   ,        ,     ,        !  ,              ,   ,       .  ,        ,              . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr461321/">https://habr.com/ru/post/fr461321/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr461307/index.html">Nous vous invitons au VK Hackathon 2019. La cagnotte de cette ann√©e est de deux millions de roubles.</a></li>
<li><a href="../fr461309/index.html">Tout sauf Kotlin: Andrei Breslav sur l'√©quilibre entre les sexes dans l'informatique, les √©motions et plus encore</a></li>
<li><a href="../fr461313/index.html">Sortie de Zimbra 8.8.15 LTS</a></li>
<li><a href="../fr461317/index.html">9 principes pour cr√©er des applications iOS de qualit√©</a></li>
<li><a href="../fr461319/index.html">Que fait un game designer?</a></li>
<li><a href="../fr461323/index.html">Une explication accessible de l'algorithme d'effondrement de la fonction d'onde</a></li>
<li><a href="../fr461325/index.html">Victoire aux PHDays 9. Nous partageons les hacks de vie en trois parties. 3e partie</a></li>
<li><a href="../fr461327/index.html">Crise frontale?</a></li>
<li><a href="../fr461329/index.html">Segmentation automatique des organes respiratoires</a></li>
<li><a href="../fr461333/index.html">ITX5 mitap: JAVA en direct, magie Kotlin et amadou tomate</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>