<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>游 游 游 Interacci칩n cliente-servidor en un nuevo dispositivo m칩vil PvP shooter y servidor de juegos: problemas y soluciones 游빃游 游놂 游댏</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En art칤culos anteriores de la serie (todos los enlaces al final del art칤culo) sobre el desarrollo de un nuevo tirador de ritmo r치pido, examinamos los ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Interacci칩n cliente-servidor en un nuevo dispositivo m칩vil PvP shooter y servidor de juegos: problemas y soluciones</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pixonic/blog/420019/">  En art칤culos anteriores de la serie (todos los enlaces al final del art칤culo) sobre el desarrollo de un nuevo tirador de ritmo r치pido, examinamos los mecanismos de la arquitectura principal de la l칩gica del juego basada en ECS, y las caracter칤sticas de trabajar con un tirador en el cliente, en particular, la implementaci칩n de un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">sistema para predecir las acciones locales del jugador</a> para aumentar la capacidad de respuesta del juego. .  Esta vez nos detendremos en m치s detalles sobre cuestiones de interacci칩n cliente-servidor en condiciones de mala conexi칩n de redes m칩viles y formas de mejorar la calidad del juego para el usuario final.  Tambi칠n describir칠 brevemente la arquitectura del servidor del juego. <br><br><img src="https://habrastorage.org/webt/py/lp/8q/pylp8q_ki2el3odmsmd_h5ppqh0.jpeg"><br><a name="habracut"></a><br><br>  Durante el desarrollo del nuevo PvP s칤ncrono para dispositivos m칩viles, encontramos problemas t칤picos del g칠nero: <br><br><ol><li>  La calidad de conexi칩n de los clientes m칩viles es deficiente.  Este es un ping promedio relativamente alto en la regi칩n de 200-250 ms, y una distribuci칩n de tiempo inestable del ping teniendo en cuenta el cambio de puntos de acceso (aunque, contrariamente a la creencia popular, el porcentaje de p칠rdida de paquetes en redes m칩viles 3G + es bastante bajo, aproximadamente 1%). </li><li>  Las soluciones t칠cnicas existentes son marcos monstruosos que llevan a los desarrolladores a marcos ajustados. </li></ol><br>  Creamos el primer prototipo en UNet, a pesar de que impuso restricciones en la escalabilidad, el control sobre el componente de red y agreg칩 dependencia en la conexi칩n caprichosa de los clientes maestros.  Luego cambiamos a un c칩digo de red autoescrito en la parte superior de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Photon Server</a> , pero m치s sobre eso m치s adelante. <br><br>  Considere los mecanismos para organizar las interacciones entre clientes en juegos PvP sincr칩nicos.  El m치s popular de ellos: <br><br><ul><li>  <b>P2P o de igual a igual</b> .  Toda la l칩gica del partido est치 alojada en uno de los clientes y no requiere casi ning칰n costo de tr치fico de nuestra parte.  Pero el alcance de los tramposos y los altos requisitos para el cliente que aloja el partido, as칤 como las limitaciones de NAT no nos permitieron tomar esta soluci칩n para un juego m칩vil. </li><li>  <b>Cliente-servidor</b> .  Un servidor dedicado, por el contrario, le permite controlar completamente todo lo que sucede en el partido (adi칩s, tramposos), y su rendimiento le permite calcular algunas cosas espec칤ficas de nuestro proyecto.  Adem치s, muchos proveedores de alojamiento grandes tienen su propia estructura de subred, que proporciona un retraso m칤nimo para el usuario final. </li></ul><br>  Se decidi칩 escribir un servidor autoritario. <br><br><img src="https://habrastorage.org/webt/x4/a4/ku/x4a4kunfi3lnbjqeghpddh-hsz8.jpeg"><br>  <i>Redes con punto a punto (izquierda) y cliente-servidor (derecha)</i> <br><br><h3>  Transferencia de datos entre cliente y servidor </h3><br>  Usamos <b>Photon Server</b> : esto nos permiti칩 implementar r치pidamente la infraestructura necesaria para el proyecto sobre la base de un esquema que ya se desarroll칩 a lo largo de los a침os (en War Robots lo usamos). <br><br>  Photon Server es exclusivamente una soluci칩n de transporte para nosotros, sin dise침os de alto nivel que est칠n fuertemente vinculados a un motor de juego espec칤fico.  Lo que ofrece cierta ventaja, ya que la biblioteca de transferencia de datos se puede reemplazar en cualquier momento. <br><br>  El servidor del juego es una aplicaci칩n multiproceso en el contenedor Photon.  Se crea una secuencia separada para cada coincidencia, que encapsula toda la l칩gica de trabajo y evita la influencia de una coincidencia en otra.  Photon controla todas las conexiones del servidor, y los datos que le llegan de los clientes se agregan a la cola, que luego se analiza en ECS. <br><br><img src="https://habrastorage.org/webt/j-/ws/wm/j-wswmt08qutnwc1jha0dgazkfo.jpeg"><br>  <i>Esquema general de transmisiones de coincidencias en el contenedor de Photon Server</i> <br><br>  Cada partido consta de varias etapas: <br><br><ol><li>  El cliente del juego hace cola en el llamado servicio de emparejamiento.  Tan pronto como se re칰ne el n칰mero requerido de jugadores que satisfacen ciertas condiciones, informa esto al servidor del juego usando gRPC.  Al mismo tiempo, se transmiten todos los datos necesarios para crear el juego. <br><br><img src="https://habrastorage.org/webt/e_/rq/qp/e_rqqp5kiwrz-mxwbtkeuqptfpy.jpeg"><br>  <i>Esquema general para crear una coincidencia.</i> </li><li>  En el servidor del juego, comienza la inicializaci칩n del partido.  Todos los par치metros de coincidencia se procesan y preparan, incluidos los datos del mapa, as칤 como todos los datos del cliente recibidos del servicio de creaci칩n de coincidencias.  Procesar y preparar datos implica que analizamos todos los datos necesarios y los escribimos en un subconjunto especial de entidades que llamamos RuleBook.  Almacena las estad칤sticas de los partidos (que no cambian durante su curso) y se transmitir치n a todos los clientes durante la conexi칩n y la autorizaci칩n en el servidor del juego una vez o cuando se vuelvan a conectar despu칠s de perder la conexi칩n.  Los datos de coincidencia est치ticos incluyen la configuraci칩n del mapa (presentaci칩n del mapa por componentes de ECS que los conectan al motor f칤sico), datos del cliente (apodos, un conjunto de armas que tienen y que no cambian durante la batalla, etc.). </li><li>  Corriendo un partido.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Los sistemas ECS</a> que componen el juego en el servidor comienzan a funcionar.  Todos los sistemas est치n marcando 30 cuadros por segundo. </li><li>  Cada cuadro lee y desempaqueta las entradas o copias del jugador si los jugadores no enviaron su entrada dentro de un cierto intervalo. </li><li>  Luego, en el mismo marco, la entrada se procesa en el sistema ECS, a saber: cambio de estado del jugador;  el mundo que influye con su aportaci칩n;  y el estado de otros jugadores. </li><li>  Al final de la trama, el estado mundial resultante se empaqueta para el jugador y se env칤a a trav칠s de la red. </li><li>  Al final de la partida, los resultados se env칤an a los clientes y al microservicio, que procesa las recompensas de la batalla usando gRPC, as칤 como al analista de la partida. </li><li>  Despu칠s de eso, el flujo de cerillas se cierra y el flujo se cierra. </li></ol><br><img src="https://habrastorage.org/webt/02/8i/jl/028ijlnhor-evm6llkmfbiguf3s.jpeg"><br>  <i>La secuencia de acciones en el servidor dentro de un marco</i> <br><br>  En el lado del cliente, el proceso de conexi칩n a un partido es el siguiente: <br><br><ol><li>  Primero, se hace una solicitud para hacer cola en el servicio para crear coincidencias a trav칠s de websocket con serializaci칩n a trav칠s de protobuf. </li><li>  Al crear una partida, este servicio informa al cliente de la direcci칩n del servidor del juego y transfiere la carga adicional requerida por el cliente antes de la partida.  Ahora el cliente est치 listo para iniciar el proceso de autorizaci칩n en el servidor del juego. </li><li>  El cliente crea un socket UDP y comienza a enviar una solicitud al servidor del juego para conectarse al partido junto con algunas credenciales.  El servidor ya est치 esperando a este cliente.  Cuando est치 conectado, le da todos los datos necesarios para comenzar el juego y mostrar el mundo por primera vez.  Estos incluyen: RuleBook (una lista de datos est치ticos para el partido), as칤 como StringIntMap, al que nos referimos como datos sobre las l칤neas utilizadas en el juego que ser치n identificadas por los enteros durante el partido).  Esto es necesario para ahorrar tr치fico, porque  pasando l칤neas cada cuadro crea una carga significativa en la red.  Por ejemplo, todos los nombres de jugadores, nombres de clases, identificadores de armas, cuentas y similares, toda la informaci칩n se escribe en StringIntMap, donde se codifica utilizando datos enteros simples. </li></ol><br>  Cuando un jugador afecta directamente a otros usuarios (causa da침os, impone efectos, etc.), se busca un historial de estado en el servidor para comparar el mundo del juego que el cliente realmente ve en una marca de simulaci칩n espec칤fica con lo que estaba sucediendo en el servidor con otros en ese momento. entidades del juego <br><br>  Por ejemplo, disparas a tu cliente.  Para usted, esto sucede instant치neamente, pero el cliente ya se ha "escapado" por alg칰n tiempo en comparaci칩n con el mundo circundante, que muestra.  Por lo tanto, debido a la predicci칩n local del comportamiento del jugador, el servidor necesita comprender d칩nde y en qu칠 estado estaban los oponentes en el momento del disparo (tal vez ya estaban muertos o, por el contrario, invulnerables).  El servidor verifica todos los factores y presenta su veredicto sobre el da침o hecho. <br><br><img src="https://habrastorage.org/webt/os/fb/hh/osfbhh4iwrw6gk2hvtpqp8co2sw.jpeg"><br>  <i>Solicitud para crear una partida, conectarse a un servidor de juegos y autorizaci칩n</i> <br><br><h3>  Serializaci칩n y deserializaci칩n, empaquetado y desempaquetado de los primeros bytes del partido. </h3><br>  Tenemos una serializaci칩n de datos binarios patentada, y para la transferencia de datos usamos UDP. <br><br>  UDP es la opci칩n m치s obvia para enviar mensajes r치pidamente entre el cliente y el servidor, donde generalmente es mucho m치s importante mostrar los datos lo antes posible que, en principio, mostrarlos.  Los paquetes perdidos hacen ajustes, pero los problemas se resuelven para cada caso individualmente, como  Dado que los datos provienen constantemente del cliente al servidor y viceversa, puede ingresar el concepto de una conexi칩n entre el cliente y el servidor. <br><br>  Para crear un c칩digo 칩ptimo y conveniente basado en la descripci칩n declarativa de la estructura de nuestro ECS, utilizamos la generaci칩n de c칩digo.  Al crear componentes, tambi칠n se generan reglas de serializaci칩n y deserializaci칩n para ellos.  La serializaci칩n se basa en un empaquetador binario personalizado que le permite empacar datos de la manera m치s econ칩mica.  El conjunto de bytes obtenido durante su funcionamiento no es el m치s 칩ptimo, pero le permite crear una secuencia desde la que puede leer algunos datos de paquetes sin la necesidad de su deserializaci칩n completa. <br><br>  El l칤mite de transferencia de datos de 1500 bytes (tambi칠n conocido como MTU) es, de hecho, el tama침o m치ximo de paquete que se puede transferir a trav칠s de Ethernet.  Esta propiedad se puede configurar en cada salto de la red y, a menudo, incluso por debajo de 1500 bytes.  쯈u칠 sucede si env칤o un paquete de m치s de 1500 bytes?  Comienza la fragmentaci칩n del paquete.  Es decir  cada paquete se dividir치 a la fuerza en varios fragmentos, que se enviar치n por separado de una interfaz a otra.  Se pueden enviar por rutas completamente diferentes, y el tiempo para recibir dichos paquetes puede aumentar significativamente antes de que la capa de red emita un paquete pegado a su aplicaci칩n. <br><br>  En el caso de Photon, la biblioteca comienza a enviar dichos paquetes en modo UDP confiable.  Es decir  El fot칩n esperar치 cada fragmento del paquete, y reenviar치 los fragmentos que faltan si se pierden durante el reenv칤o.  Pero tal trabajo de la parte de la red es inaceptable en los juegos donde se requiere un retraso m칤nimo de la red.  Por lo tanto, se recomienda reducir el tama침o de los paquetes reenviados a un m칤nimo y no exceder los 1500 bytes recomendados (en nuestro juego, el tama침o de un estado completo del mundo no excede los 1000 bytes; el tama침o del paquete con compresi칩n delta es de 200 bytes). <br><br>  Cada paquete del servidor tiene un encabezado corto que contiene varios bytes que describen el tipo de paquete.  El cliente primero desempaqueta este conjunto de bytes y determina con qu칠 paquete estamos tratando.  Confiamos en gran medida en esta propiedad de nuestro mecanismo de deserializaci칩n durante la autorizaci칩n: para no exceder el tama침o de paquete recomendado de 1500 bytes, dividimos los paquetes RuleBook y StringIntMap en varias etapas;  y para entender qu칠 obtuvimos exactamente del servidor, las reglas del juego o el estado en s칤, utilizamos el encabezado del paquete. <br><br>  Cuando se desarrollan nuevas caracter칤sticas del proyecto, el tama침o del paquete crece constantemente.  Cuando nos encontramos con este problema, se decidi칩 escribir nuestro propio sistema de compresi칩n delta, as칤 como el recorte contextual de datos que el cliente no necesitaba. <br><br><h3>  Optimizaci칩n del tr치fico de red sensible al contexto.  Compresi칩n Delta </h3><br>  El recorte de datos contextuales se escribe manualmente en funci칩n de los datos que el cliente necesita para mostrar correctamente el mundo y la predicci칩n local de sus propios datos para funcionar correctamente.  Luego, la compresi칩n delta se aplica a los datos restantes. <br><br>  Nuestro juego cada tick produce un nuevo estado del mundo, que debe ser empaquetado y transmitido a los clientes.  Por lo general, la compresi칩n delta es enviar primero un estado completo con todos los datos necesarios al cliente y luego enviar solo los cambios a estos datos.  Esto se puede representar de la siguiente manera: <br><br>  <i>deltaGameState = newGameState - prevGameState</i> <br><br>  Pero para cada cliente se env칤an datos diferentes y la p칠rdida de un solo paquete puede llevar al hecho de que tiene que reenviar el estado completo del mundo. <br><br>  Reenviar el estado completo del mundo es una tarea bastante costosa para la red.  Por lo tanto, modificamos el enfoque y enviamos la diferencia entre el estado procesado actual del mundo y el que recibe exactamente el cliente.  Para hacer esto, el cliente en su paquete con la entrada tambi칠n env칤a un n칰mero de marca, que es un identificador 칰nico del estado del juego que ya recibi칩 exactamente.  Ahora el servidor sabe sobre la base de qu칠 estado es necesario construir la compresi칩n delta.  El cliente generalmente no tiene tiempo para enviar al servidor el n칰mero de marca que tiene antes de que el servidor prepare el siguiente marco con los datos.  Por lo tanto, en el cliente hay un historial de estados del servidor del mundo, al que se aplica el parche deltaGameState generado por el servidor. <br><br><img src="https://habrastorage.org/webt/ji/uo/ka/jiuokasgdo-wgmgmzbmchlb1gvm.jpeg"><br>  <i>Ilustraci칩n de la frecuencia de interacci칩n cliente-servidor en el proyecto.</i> <br><br>  Deteng치monos en m치s detalle sobre lo que env칤a el cliente.  En los shooters cl치sicos, dicho paquete se llama ClientCmd y contiene informaci칩n sobre las teclas presionadas por el jugador y el momento en que se cre칩 el equipo.  Dentro del paquete de entrada, enviamos muchos m치s datos: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">InputSample</span></span> { <span class="hljs-comment"><span class="hljs-comment">//  ,        public uint WorldTick; // ,      ,     public uint PlayerSimulationTick; //   .  (idle, , ) public MovementMagnitude MovementMagnitude; //  ,   public float MovementAngle; //    public AimMagnitude AimMagnitude; //    public float AimAngle; //   ,       public uint ShotTarget; //    ,        public float AimMagnitudeCompressed; }</span></span></code> </pre> <br><br>  Hay algunos puntos interesantes.  En primer lugar, el cliente le dice al servidor en qu칠 marca ve todos los objetos del mundo del juego que lo rodea que no puede predecir (WorldTick).  Puede parecer que el cliente puede "detener" el tiempo para el mundo, y correr y disparar a todos por la predicci칩n local.  Esto no es asi.  Confiamos solo en un conjunto limitado de valores del cliente y no le permitimos disparar al pasado por m치s de 1 segundo.  El campo WorldTick tambi칠n se usa como un paquete de reconocimiento, en base al cual se construye la compresi칩n delta. <br><br>  Puede encontrar n칰meros de coma flotante en un paquete.  Por lo general, estos valores a menudo se usan para tomar lecturas del joystick del jugador, pero no se transmiten muy bien a trav칠s de la red, ya que tienen un gran "rebote" y generalmente son demasiado precisos.  Cuantificamos dichos n칰meros y los empaquetamos usando un empacador binario para que no excedan un valor entero que pueda caber en varios bits, dependiendo de su tama침o.  Por lo tanto, el paquete de entrada del joystick de punter칤a se rompe: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Math.Abs(s.AimMagnitudeCompressed) &lt; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>.Epsilon) { packer.PackByte(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { packer.PackByte(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> min = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> max = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> step = <span class="hljs-number"><span class="hljs-number">0.001f</span></span>; <span class="hljs-comment"><span class="hljs-comment">//     1000    , //          //     packer.PackUInt32((uint)((s.AimMagnitudeCompressed - min)/step), CalcFloatRangeBits(min, max, step)); }</span></span></code> </pre> <br><br>  Otra caracter칤stica interesante al enviar entradas es que algunos comandos se pueden enviar varias veces.  Muy a menudo se nos pregunta qu칠 hacer si una persona ha presionado la habilidad m치xima y se ha perdido el paquete con su entrada.  Simplemente enviamos esta entrada varias veces.  Parece una entrega garantizada, pero m치s flexible y m치s r치pida.  Porque  el tama침o del paquete de entrada es muy peque침o, podemos empacar varias entradas de jugadores adyacentes en el paquete resultante.  Por el momento, el tama침o de la ventana que determina su n칰mero es cinco. <br><br><img src="https://habrastorage.org/webt/gi/08/0g/gi080gxlym3kf7n801ah19gjeq8.jpeg"><br>  <i>Paquetes de entrada generados en el cliente en cada tic y enviados al servidor</i> <br><br>  La transmisi칩n de este tipo de datos es lo suficientemente r치pida y confiable como para resolver nuestros problemas sin usar un UDP confiable.  Partimos del hecho de que la probabilidad de perder tal cantidad de paquetes seguidos es muy baja y es un indicador de una grave degradaci칩n de la calidad de la red en su conjunto.  Si esto sucede, el servidor simplemente copia la 칰ltima entrada recibida del jugador y la aplica, con la esperanza de que no se modifique. <br><br>  Si el cliente se da cuenta de que no recibi칩 paquetes a trav칠s de la red durante mucho tiempo, se inicia el proceso de reconexi칩n con el servidor.  El servidor, por su parte, supervisa que la cola de entrada del reproductor est칠 completa. <br><br><h3>  En lugar de conclusi칩n y referencia </h3><br>  Hay muchos otros sistemas en el servidor del juego que son responsables de detectar, depurar y editar coincidencias "por ganancia", los dise침adores de juegos actualizan la configuraci칩n sin reiniciar, registrar y monitorear el estado de los servidores.  Tambi칠n queremos escribir sobre esto con m치s detalle, pero por separado. <br><br>  En primer lugar, al desarrollar un juego de red en plataformas m칩viles, debe prestar atenci칩n al funcionamiento correcto de su cliente con pings altos (aproximadamente 200 ms), p칠rdida de datos un poco m치s frecuente, as칤 como el tama침o de los datos enviados.  Y debe ajustarse claramente al l칤mite de paquetes de 1500 bytes para evitar fragmentaci칩n y demoras en el tr치fico. <br><br>  Enlaces utiles: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://gafferongames.com/post/udp_vs_tcp/</a> es un excelente art칤culo sobre c칩mo elegir entre TCP y UDP para juegos de red. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://api.unrealengine.com/udk/Three/NetworkingOverview.html</a> : una descripci칩n del modelo de servidor en Unreal Engine. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">http://ieeexplore.ieee.org/document/5360721</a> - estudio de la calidad de red de las conexiones m칩viles. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">http://ithare.com/mmog-rtt-input-lag-and-how-to-mitigate-them/</a> - interacci칩n de red en juegos de ritmo r치pido. </li></ul><br>  Art칤culos anteriores sobre el proyecto: <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"C칩mo nos lanzamos en un tirador m칩vil de ritmo r치pido: tecnolog칤a y enfoques"</a> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"C칩mo y por qu칠 escribimos nuestro ECS"</a> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Como escribimos el c칩digo de red del tirador PvP m칩vil: sincronizaci칩n del jugador en el cliente"</a> . </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es420019/">https://habr.com/ru/post/es420019/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es420009/index.html">Las sutilezas del dise침o del producto.</a></li>
<li><a href="../es420011/index.html">C칩mo elegir una impresora 3D: una gu칤a para principiantes</a></li>
<li><a href="../es420013/index.html">B칰squeda de direcci칩n MAC en conmutadores Juniper</a></li>
<li><a href="../es420015/index.html">C칩mo medir correctamente la velocidad del canal de Internet y dejar de parecer un tonto a los ojos de su proveedor</a></li>
<li><a href="../es420017/index.html">El arte de recoger contrase침as</a></li>
<li><a href="../es420021/index.html">쯇or qu칠 necesitas Splunk? Internet de las cosas y datos industriales</a></li>
<li><a href="../es420023/index.html">Guardar estados en aplicaciones de Android</a></li>
<li><a href="../es420025/index.html">Granja inteligente 쮺칩mo ser치 ella?</a></li>
<li><a href="../es420029/index.html">C칩mo en 1C: Enterprise resolvemos sistemas de ecuaciones algebraicas</a></li>
<li><a href="../es420031/index.html">Dibujar con objetivos de renderizado en Unreal Engine</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>