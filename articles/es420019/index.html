<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🆗 📿 📟 Interacción cliente-servidor en un nuevo dispositivo móvil PvP shooter y servidor de juegos: problemas y soluciones 🧝🏿 👫 🔐</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En artículos anteriores de la serie (todos los enlaces al final del artículo) sobre el desarrollo de un nuevo tirador de ritmo rápido, examinamos los ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Interacción cliente-servidor en un nuevo dispositivo móvil PvP shooter y servidor de juegos: problemas y soluciones</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pixonic/blog/420019/">  En artículos anteriores de la serie (todos los enlaces al final del artículo) sobre el desarrollo de un nuevo tirador de ritmo rápido, examinamos los mecanismos de la arquitectura principal de la lógica del juego basada en ECS, y las características de trabajar con un tirador en el cliente, en particular, la implementación de un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">sistema para predecir las acciones locales del jugador</a> para aumentar la capacidad de respuesta del juego. .  Esta vez nos detendremos en más detalles sobre cuestiones de interacción cliente-servidor en condiciones de mala conexión de redes móviles y formas de mejorar la calidad del juego para el usuario final.  También describiré brevemente la arquitectura del servidor del juego. <br><br><img src="https://habrastorage.org/webt/py/lp/8q/pylp8q_ki2el3odmsmd_h5ppqh0.jpeg"><br><a name="habracut"></a><br><br>  Durante el desarrollo del nuevo PvP síncrono para dispositivos móviles, encontramos problemas típicos del género: <br><br><ol><li>  La calidad de conexión de los clientes móviles es deficiente.  Este es un ping promedio relativamente alto en la región de 200-250 ms, y una distribución de tiempo inestable del ping teniendo en cuenta el cambio de puntos de acceso (aunque, contrariamente a la creencia popular, el porcentaje de pérdida de paquetes en redes móviles 3G + es bastante bajo, aproximadamente 1%). </li><li>  Las soluciones técnicas existentes son marcos monstruosos que llevan a los desarrolladores a marcos ajustados. </li></ol><br>  Creamos el primer prototipo en UNet, a pesar de que impuso restricciones en la escalabilidad, el control sobre el componente de red y agregó dependencia en la conexión caprichosa de los clientes maestros.  Luego cambiamos a un código de red autoescrito en la parte superior de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Photon Server</a> , pero más sobre eso más adelante. <br><br>  Considere los mecanismos para organizar las interacciones entre clientes en juegos PvP sincrónicos.  El más popular de ellos: <br><br><ul><li>  <b>P2P o de igual a igual</b> .  Toda la lógica del partido está alojada en uno de los clientes y no requiere casi ningún costo de tráfico de nuestra parte.  Pero el alcance de los tramposos y los altos requisitos para el cliente que aloja el partido, así como las limitaciones de NAT no nos permitieron tomar esta solución para un juego móvil. </li><li>  <b>Cliente-servidor</b> .  Un servidor dedicado, por el contrario, le permite controlar completamente todo lo que sucede en el partido (adiós, tramposos), y su rendimiento le permite calcular algunas cosas específicas de nuestro proyecto.  Además, muchos proveedores de alojamiento grandes tienen su propia estructura de subred, que proporciona un retraso mínimo para el usuario final. </li></ul><br>  Se decidió escribir un servidor autoritario. <br><br><img src="https://habrastorage.org/webt/x4/a4/ku/x4a4kunfi3lnbjqeghpddh-hsz8.jpeg"><br>  <i>Redes con punto a punto (izquierda) y cliente-servidor (derecha)</i> <br><br><h3>  Transferencia de datos entre cliente y servidor </h3><br>  Usamos <b>Photon Server</b> : esto nos permitió implementar rápidamente la infraestructura necesaria para el proyecto sobre la base de un esquema que ya se desarrolló a lo largo de los años (en War Robots lo usamos). <br><br>  Photon Server es exclusivamente una solución de transporte para nosotros, sin diseños de alto nivel que estén fuertemente vinculados a un motor de juego específico.  Lo que ofrece cierta ventaja, ya que la biblioteca de transferencia de datos se puede reemplazar en cualquier momento. <br><br>  El servidor del juego es una aplicación multiproceso en el contenedor Photon.  Se crea una secuencia separada para cada coincidencia, que encapsula toda la lógica de trabajo y evita la influencia de una coincidencia en otra.  Photon controla todas las conexiones del servidor, y los datos que le llegan de los clientes se agregan a la cola, que luego se analiza en ECS. <br><br><img src="https://habrastorage.org/webt/j-/ws/wm/j-wswmt08qutnwc1jha0dgazkfo.jpeg"><br>  <i>Esquema general de transmisiones de coincidencias en el contenedor de Photon Server</i> <br><br>  Cada partido consta de varias etapas: <br><br><ol><li>  El cliente del juego hace cola en el llamado servicio de emparejamiento.  Tan pronto como se reúne el número requerido de jugadores que satisfacen ciertas condiciones, informa esto al servidor del juego usando gRPC.  Al mismo tiempo, se transmiten todos los datos necesarios para crear el juego. <br><br><img src="https://habrastorage.org/webt/e_/rq/qp/e_rqqp5kiwrz-mxwbtkeuqptfpy.jpeg"><br>  <i>Esquema general para crear una coincidencia.</i> </li><li>  En el servidor del juego, comienza la inicialización del partido.  Todos los parámetros de coincidencia se procesan y preparan, incluidos los datos del mapa, así como todos los datos del cliente recibidos del servicio de creación de coincidencias.  Procesar y preparar datos implica que analizamos todos los datos necesarios y los escribimos en un subconjunto especial de entidades que llamamos RuleBook.  Almacena las estadísticas de los partidos (que no cambian durante su curso) y se transmitirán a todos los clientes durante la conexión y la autorización en el servidor del juego una vez o cuando se vuelvan a conectar después de perder la conexión.  Los datos de coincidencia estáticos incluyen la configuración del mapa (presentación del mapa por componentes de ECS que los conectan al motor físico), datos del cliente (apodos, un conjunto de armas que tienen y que no cambian durante la batalla, etc.). </li><li>  Corriendo un partido.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Los sistemas ECS</a> que componen el juego en el servidor comienzan a funcionar.  Todos los sistemas están marcando 30 cuadros por segundo. </li><li>  Cada cuadro lee y desempaqueta las entradas o copias del jugador si los jugadores no enviaron su entrada dentro de un cierto intervalo. </li><li>  Luego, en el mismo marco, la entrada se procesa en el sistema ECS, a saber: cambio de estado del jugador;  el mundo que influye con su aportación;  y el estado de otros jugadores. </li><li>  Al final de la trama, el estado mundial resultante se empaqueta para el jugador y se envía a través de la red. </li><li>  Al final de la partida, los resultados se envían a los clientes y al microservicio, que procesa las recompensas de la batalla usando gRPC, así como al analista de la partida. </li><li>  Después de eso, el flujo de cerillas se cierra y el flujo se cierra. </li></ol><br><img src="https://habrastorage.org/webt/02/8i/jl/028ijlnhor-evm6llkmfbiguf3s.jpeg"><br>  <i>La secuencia de acciones en el servidor dentro de un marco</i> <br><br>  En el lado del cliente, el proceso de conexión a un partido es el siguiente: <br><br><ol><li>  Primero, se hace una solicitud para hacer cola en el servicio para crear coincidencias a través de websocket con serialización a través de protobuf. </li><li>  Al crear una partida, este servicio informa al cliente de la dirección del servidor del juego y transfiere la carga adicional requerida por el cliente antes de la partida.  Ahora el cliente está listo para iniciar el proceso de autorización en el servidor del juego. </li><li>  El cliente crea un socket UDP y comienza a enviar una solicitud al servidor del juego para conectarse al partido junto con algunas credenciales.  El servidor ya está esperando a este cliente.  Cuando está conectado, le da todos los datos necesarios para comenzar el juego y mostrar el mundo por primera vez.  Estos incluyen: RuleBook (una lista de datos estáticos para el partido), así como StringIntMap, al que nos referimos como datos sobre las líneas utilizadas en el juego que serán identificadas por los enteros durante el partido).  Esto es necesario para ahorrar tráfico, porque  pasando líneas cada cuadro crea una carga significativa en la red.  Por ejemplo, todos los nombres de jugadores, nombres de clases, identificadores de armas, cuentas y similares, toda la información se escribe en StringIntMap, donde se codifica utilizando datos enteros simples. </li></ol><br>  Cuando un jugador afecta directamente a otros usuarios (causa daños, impone efectos, etc.), se busca un historial de estado en el servidor para comparar el mundo del juego que el cliente realmente ve en una marca de simulación específica con lo que estaba sucediendo en el servidor con otros en ese momento. entidades del juego <br><br>  Por ejemplo, disparas a tu cliente.  Para usted, esto sucede instantáneamente, pero el cliente ya se ha "escapado" por algún tiempo en comparación con el mundo circundante, que muestra.  Por lo tanto, debido a la predicción local del comportamiento del jugador, el servidor necesita comprender dónde y en qué estado estaban los oponentes en el momento del disparo (tal vez ya estaban muertos o, por el contrario, invulnerables).  El servidor verifica todos los factores y presenta su veredicto sobre el daño hecho. <br><br><img src="https://habrastorage.org/webt/os/fb/hh/osfbhh4iwrw6gk2hvtpqp8co2sw.jpeg"><br>  <i>Solicitud para crear una partida, conectarse a un servidor de juegos y autorización</i> <br><br><h3>  Serialización y deserialización, empaquetado y desempaquetado de los primeros bytes del partido. </h3><br>  Tenemos una serialización de datos binarios patentada, y para la transferencia de datos usamos UDP. <br><br>  UDP es la opción más obvia para enviar mensajes rápidamente entre el cliente y el servidor, donde generalmente es mucho más importante mostrar los datos lo antes posible que, en principio, mostrarlos.  Los paquetes perdidos hacen ajustes, pero los problemas se resuelven para cada caso individualmente, como  Dado que los datos provienen constantemente del cliente al servidor y viceversa, puede ingresar el concepto de una conexión entre el cliente y el servidor. <br><br>  Para crear un código óptimo y conveniente basado en la descripción declarativa de la estructura de nuestro ECS, utilizamos la generación de código.  Al crear componentes, también se generan reglas de serialización y deserialización para ellos.  La serialización se basa en un empaquetador binario personalizado que le permite empacar datos de la manera más económica.  El conjunto de bytes obtenido durante su funcionamiento no es el más óptimo, pero le permite crear una secuencia desde la que puede leer algunos datos de paquetes sin la necesidad de su deserialización completa. <br><br>  El límite de transferencia de datos de 1500 bytes (también conocido como MTU) es, de hecho, el tamaño máximo de paquete que se puede transferir a través de Ethernet.  Esta propiedad se puede configurar en cada salto de la red y, a menudo, incluso por debajo de 1500 bytes.  ¿Qué sucede si envío un paquete de más de 1500 bytes?  Comienza la fragmentación del paquete.  Es decir  cada paquete se dividirá a la fuerza en varios fragmentos, que se enviarán por separado de una interfaz a otra.  Se pueden enviar por rutas completamente diferentes, y el tiempo para recibir dichos paquetes puede aumentar significativamente antes de que la capa de red emita un paquete pegado a su aplicación. <br><br>  En el caso de Photon, la biblioteca comienza a enviar dichos paquetes en modo UDP confiable.  Es decir  El fotón esperará cada fragmento del paquete, y reenviará los fragmentos que faltan si se pierden durante el reenvío.  Pero tal trabajo de la parte de la red es inaceptable en los juegos donde se requiere un retraso mínimo de la red.  Por lo tanto, se recomienda reducir el tamaño de los paquetes reenviados a un mínimo y no exceder los 1500 bytes recomendados (en nuestro juego, el tamaño de un estado completo del mundo no excede los 1000 bytes; el tamaño del paquete con compresión delta es de 200 bytes). <br><br>  Cada paquete del servidor tiene un encabezado corto que contiene varios bytes que describen el tipo de paquete.  El cliente primero desempaqueta este conjunto de bytes y determina con qué paquete estamos tratando.  Confiamos en gran medida en esta propiedad de nuestro mecanismo de deserialización durante la autorización: para no exceder el tamaño de paquete recomendado de 1500 bytes, dividimos los paquetes RuleBook y StringIntMap en varias etapas;  y para entender qué obtuvimos exactamente del servidor, las reglas del juego o el estado en sí, utilizamos el encabezado del paquete. <br><br>  Cuando se desarrollan nuevas características del proyecto, el tamaño del paquete crece constantemente.  Cuando nos encontramos con este problema, se decidió escribir nuestro propio sistema de compresión delta, así como el recorte contextual de datos que el cliente no necesitaba. <br><br><h3>  Optimización del tráfico de red sensible al contexto.  Compresión Delta </h3><br>  El recorte de datos contextuales se escribe manualmente en función de los datos que el cliente necesita para mostrar correctamente el mundo y la predicción local de sus propios datos para funcionar correctamente.  Luego, la compresión delta se aplica a los datos restantes. <br><br>  Nuestro juego cada tick produce un nuevo estado del mundo, que debe ser empaquetado y transmitido a los clientes.  Por lo general, la compresión delta es enviar primero un estado completo con todos los datos necesarios al cliente y luego enviar solo los cambios a estos datos.  Esto se puede representar de la siguiente manera: <br><br>  <i>deltaGameState = newGameState - prevGameState</i> <br><br>  Pero para cada cliente se envían datos diferentes y la pérdida de un solo paquete puede llevar al hecho de que tiene que reenviar el estado completo del mundo. <br><br>  Reenviar el estado completo del mundo es una tarea bastante costosa para la red.  Por lo tanto, modificamos el enfoque y enviamos la diferencia entre el estado procesado actual del mundo y el que recibe exactamente el cliente.  Para hacer esto, el cliente en su paquete con la entrada también envía un número de marca, que es un identificador único del estado del juego que ya recibió exactamente.  Ahora el servidor sabe sobre la base de qué estado es necesario construir la compresión delta.  El cliente generalmente no tiene tiempo para enviar al servidor el número de marca que tiene antes de que el servidor prepare el siguiente marco con los datos.  Por lo tanto, en el cliente hay un historial de estados del servidor del mundo, al que se aplica el parche deltaGameState generado por el servidor. <br><br><img src="https://habrastorage.org/webt/ji/uo/ka/jiuokasgdo-wgmgmzbmchlb1gvm.jpeg"><br>  <i>Ilustración de la frecuencia de interacción cliente-servidor en el proyecto.</i> <br><br>  Detengámonos en más detalle sobre lo que envía el cliente.  En los shooters clásicos, dicho paquete se llama ClientCmd y contiene información sobre las teclas presionadas por el jugador y el momento en que se creó el equipo.  Dentro del paquete de entrada, enviamos muchos más datos: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">InputSample</span></span> { <span class="hljs-comment"><span class="hljs-comment">//  ,        public uint WorldTick; // ,      ,     public uint PlayerSimulationTick; //   .  (idle, , ) public MovementMagnitude MovementMagnitude; //  ,   public float MovementAngle; //    public AimMagnitude AimMagnitude; //    public float AimAngle; //   ,       public uint ShotTarget; //    ,        public float AimMagnitudeCompressed; }</span></span></code> </pre> <br><br>  Hay algunos puntos interesantes.  En primer lugar, el cliente le dice al servidor en qué marca ve todos los objetos del mundo del juego que lo rodea que no puede predecir (WorldTick).  Puede parecer que el cliente puede "detener" el tiempo para el mundo, y correr y disparar a todos por la predicción local.  Esto no es asi.  Confiamos solo en un conjunto limitado de valores del cliente y no le permitimos disparar al pasado por más de 1 segundo.  El campo WorldTick también se usa como un paquete de reconocimiento, en base al cual se construye la compresión delta. <br><br>  Puede encontrar números de coma flotante en un paquete.  Por lo general, estos valores a menudo se usan para tomar lecturas del joystick del jugador, pero no se transmiten muy bien a través de la red, ya que tienen un gran "rebote" y generalmente son demasiado precisos.  Cuantificamos dichos números y los empaquetamos usando un empacador binario para que no excedan un valor entero que pueda caber en varios bits, dependiendo de su tamaño.  Por lo tanto, el paquete de entrada del joystick de puntería se rompe: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Math.Abs(s.AimMagnitudeCompressed) &lt; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>.Epsilon) { packer.PackByte(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { packer.PackByte(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> min = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> max = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> step = <span class="hljs-number"><span class="hljs-number">0.001f</span></span>; <span class="hljs-comment"><span class="hljs-comment">//     1000    , //          //     packer.PackUInt32((uint)((s.AimMagnitudeCompressed - min)/step), CalcFloatRangeBits(min, max, step)); }</span></span></code> </pre> <br><br>  Otra característica interesante al enviar entradas es que algunos comandos se pueden enviar varias veces.  Muy a menudo se nos pregunta qué hacer si una persona ha presionado la habilidad máxima y se ha perdido el paquete con su entrada.  Simplemente enviamos esta entrada varias veces.  Parece una entrega garantizada, pero más flexible y más rápida.  Porque  el tamaño del paquete de entrada es muy pequeño, podemos empacar varias entradas de jugadores adyacentes en el paquete resultante.  Por el momento, el tamaño de la ventana que determina su número es cinco. <br><br><img src="https://habrastorage.org/webt/gi/08/0g/gi080gxlym3kf7n801ah19gjeq8.jpeg"><br>  <i>Paquetes de entrada generados en el cliente en cada tic y enviados al servidor</i> <br><br>  La transmisión de este tipo de datos es lo suficientemente rápida y confiable como para resolver nuestros problemas sin usar un UDP confiable.  Partimos del hecho de que la probabilidad de perder tal cantidad de paquetes seguidos es muy baja y es un indicador de una grave degradación de la calidad de la red en su conjunto.  Si esto sucede, el servidor simplemente copia la última entrada recibida del jugador y la aplica, con la esperanza de que no se modifique. <br><br>  Si el cliente se da cuenta de que no recibió paquetes a través de la red durante mucho tiempo, se inicia el proceso de reconexión con el servidor.  El servidor, por su parte, supervisa que la cola de entrada del reproductor esté completa. <br><br><h3>  En lugar de conclusión y referencia </h3><br>  Hay muchos otros sistemas en el servidor del juego que son responsables de detectar, depurar y editar coincidencias "por ganancia", los diseñadores de juegos actualizan la configuración sin reiniciar, registrar y monitorear el estado de los servidores.  También queremos escribir sobre esto con más detalle, pero por separado. <br><br>  En primer lugar, al desarrollar un juego de red en plataformas móviles, debe prestar atención al funcionamiento correcto de su cliente con pings altos (aproximadamente 200 ms), pérdida de datos un poco más frecuente, así como el tamaño de los datos enviados.  Y debe ajustarse claramente al límite de paquetes de 1500 bytes para evitar fragmentación y demoras en el tráfico. <br><br>  Enlaces utiles: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://gafferongames.com/post/udp_vs_tcp/</a> es un excelente artículo sobre cómo elegir entre TCP y UDP para juegos de red. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://api.unrealengine.com/udk/Three/NetworkingOverview.html</a> : una descripción del modelo de servidor en Unreal Engine. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">http://ieeexplore.ieee.org/document/5360721</a> - estudio de la calidad de red de las conexiones móviles. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">http://ithare.com/mmog-rtt-input-lag-and-how-to-mitigate-them/</a> - interacción de red en juegos de ritmo rápido. </li></ul><br>  Artículos anteriores sobre el proyecto: <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Cómo nos lanzamos en un tirador móvil de ritmo rápido: tecnología y enfoques"</a> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Cómo y por qué escribimos nuestro ECS"</a> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Como escribimos el código de red del tirador PvP móvil: sincronización del jugador en el cliente"</a> . </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es420019/">https://habr.com/ru/post/es420019/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es420009/index.html">Las sutilezas del diseño del producto.</a></li>
<li><a href="../es420011/index.html">Cómo elegir una impresora 3D: una guía para principiantes</a></li>
<li><a href="../es420013/index.html">Búsqueda de dirección MAC en conmutadores Juniper</a></li>
<li><a href="../es420015/index.html">Cómo medir correctamente la velocidad del canal de Internet y dejar de parecer un tonto a los ojos de su proveedor</a></li>
<li><a href="../es420017/index.html">El arte de recoger contraseñas</a></li>
<li><a href="../es420021/index.html">¿Por qué necesitas Splunk? Internet de las cosas y datos industriales</a></li>
<li><a href="../es420023/index.html">Guardar estados en aplicaciones de Android</a></li>
<li><a href="../es420025/index.html">Granja inteligente ¿Cómo será ella?</a></li>
<li><a href="../es420029/index.html">Cómo en 1C: Enterprise resolvemos sistemas de ecuaciones algebraicas</a></li>
<li><a href="../es420031/index.html">Dibujar con objetivos de renderizado en Unreal Engine</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>