<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏼‍🚀 🥩 🤜🏾 MQTT-Protokoll: Konzeptionelles Eintauchen 👨🏾‍🎨 🍜 👲🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Das MQTT-Protokoll (Message Queuing Telemetry Transport) wird seit vielen Jahren verwendet. Aufgrund des explosionsartigen Wachstums des Internet der ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MQTT-Protokoll: Konzeptionelles Eintauchen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/463669/">  Das MQTT-Protokoll (Message Queuing Telemetry Transport) wird seit vielen Jahren verwendet. Aufgrund des explosionsartigen Wachstums des Internet der Dinge ist es jetzt besonders relevant: Sowohl Verbraucher- als auch Industriegeräte implementieren verteilte Netzwerke und Edge-Computing, und Geräte mit kontinuierlicher Datenübertragung gehören zum Alltag des Lebens. <br><br>  Dies bedeutet, dass leichte, offene und erschwingliche Protokolle im Laufe der Zeit noch wichtiger werden.  Dieser Artikel bietet einen konzeptionellen Einblick in MQTT: wie es funktioniert, wie es jetzt verwendet wird und wie es in Zukunft verwendet wird. <br><a name="habracut"></a><br><h1>  Kleine Einführung </h1><br>  MQTT ist ein Publisher-Subscriber-basiertes Messaging-Protokoll (Pub / Sub).  Die erste Version im Jahr 1999 wurde <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">von</a> Andy Stanford-Clark von IBM und Arlene Nipper von Cirrus Link veröffentlicht.  Sie betrachteten MQTT als eine Möglichkeit, die Kommunikation zwischen Maschinen in Netzwerken mit begrenzter Bandbreite oder unvorhersehbarer Kommunikation aufrechtzuerhalten.  Eine der ersten Optionen für seine Verwendung bestand darin, den Kontakt zwischen Fragmenten der Pipeline untereinander und mit den zentralen Verbindungen über Satelliten sicherzustellen. <br><br>  Angesichts der rauen Betriebsbedingungen ist das Protokoll klein und leicht.  Es ist ideal für Geräte mit geringem Stromverbrauch und begrenzter Akkulaufzeit.  Dazu gehören jetzt die allgegenwärtigen Smartphones und die ständig wachsende Anzahl von Sensoren und angeschlossenen Geräten. <br><br>  Somit ist MQTT zu einem Protokoll für das Streaming von Daten zwischen Geräten mit begrenzter CPU-Leistung und / oder Akkulaufzeit sowie für Netzwerke mit teurer oder geringer Bandbreite, unvorhersehbarer Stabilität oder hoher Latenz geworden.  Deshalb ist MQTT als ideales Fahrzeug für IoT bekannt.  Es basiert auf dem TCP / IP-Protokoll, es gibt jedoch einen MQTT-SN-Zweig für die Arbeit über Bluetooth, UDP, ZigBee und andere IoT-Netzwerke als TCP / IP. <br><br>  MQTT ist nicht das einzige Echtzeit-Pub / Sub-Messaging-Protokoll seiner Art, hat sich jedoch bereits in verschiedenen Umgebungen verbreitet, die von der Kommunikation von Maschine zu Maschine abhängen.  Zu seinen Kollegen zählen das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Web Application Messaging Protocol</a> , das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Streaming Text-Oriented Messaging Protocol</a> und das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Alternative Message Queuing Protocol</a> . <br><br>  MQTT ist die logische Wahl für Entwickler, die Anwendungen mit zuverlässiger Funktionalität und umfassender Kompatibilität mit Geräten und Anwendungen erstellen möchten, die mit dem Internet verbunden sind, einschließlich Browsern, Smartphones und IoT-Geräten. <br><br><h1>  Wie MQTT funktioniert: Die Grundlagen </h1><br>  Das auf MQTT basierende Kommunikationssystem besteht aus einem Publisher-Server, einem Broker-Server und einem oder mehreren Clients.  Der Herausgeber benötigt keine Einstellungen für die Anzahl oder den Standort der Abonnenten, die Nachrichten empfangen.  Darüber hinaus müssen Abonnenten nicht auf einen bestimmten Herausgeber einstellen.  Es können mehrere Nachrichtenbroker im System vorhanden sein. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/029/60b/c0b/02960bc0baf11fcfc7c8cd56d331ba4c.png"><br><br>  MQTT bietet eine Möglichkeit, eine Hierarchie von Kommunikationskanälen zu erstellen - eine Art Zweig mit Blättern.  Immer wenn der Verlag neue Daten zur Verteilung an Kunden hat, wird der Nachricht ein Hinweis zur Zustellungskontrolle beigefügt.  Clients auf höherer Ebene können jede Nachricht empfangen, während Clients auf niedrigerer Ebene Nachrichten empfangen können, die sich nur auf einen oder zwei grundlegende Kanäle beziehen, „Zweige“ am Ende der Hierarchie.  Dies erleichtert den Informationsaustausch zwischen zwei Byte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">und 256 Megabyte</a> . <br><br>  Ein Beispiel dafür, wie Sie den Client für die Verbindung über den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MQTT-Broker</a> konfigurieren können: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> options = { <span class="hljs-attr"><span class="hljs-attr">keepalive</span></span>: <span class="hljs-number"><span class="hljs-number">60</span></span>, <span class="hljs-attr"><span class="hljs-attr">username</span></span>: <span class="hljs-string"><span class="hljs-string">'FIRST_HALF_OF_API_KEY'</span></span>, <span class="hljs-attr"><span class="hljs-attr">password</span></span>: <span class="hljs-string"><span class="hljs-string">'SECOND_HALF_OF_API_KEY'</span></span>, <span class="hljs-attr"><span class="hljs-attr">port</span></span>: <span class="hljs-number"><span class="hljs-number">8883</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> client = mqtt.connect(<span class="hljs-string"><span class="hljs-string">'mqtts:mqtt.ably.io'</span></span>, options);</code> </pre> <br>  Alle vom MQTT-Broker veröffentlichten oder empfangenen Daten werden im Binärformat codiert, da MQTT ein Binärprotokoll ist.  Dies bedeutet, dass Sie die Nachricht interpretieren müssen, um den ursprünglichen Inhalt zu erhalten.  So sieht es mit Ably und JavaScript aus: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ably = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Ably.Realtime(<span class="hljs-string"><span class="hljs-string">'REPLACE_WITH_YOUR_API_KEY'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> decoder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TextDecoder(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> channel = ably.channels.get(<span class="hljs-string"><span class="hljs-string">'input'</span></span>); channel.subscribe(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">message</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> command = decoder.decode(message.data); });</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MQTT-Broker</a> können manchmal Nachrichten sammeln, die sich auf Kanäle beziehen, die keine aktuellen Abonnenten haben.  In diesem Fall werden die Nachrichten abhängig von den Anweisungen in der Kontrollnachricht entweder verworfen oder gespeichert.  Dies ist in Fällen nützlich, in denen neue Teilnehmer möglicherweise den zuletzt aufgezeichneten Datenpunkt benötigen, anstatt auf den nächsten Sendevorgang zu warten. <br><br>  Es ist bemerkenswert, dass MQTT Sicherheitsanmeldeinformationen im Klartext überträgt, da sonst Authentifizierungs- oder Sicherheitsfunktionen nicht unterstützt werden.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier kommt das SSL-Framework ins Spiel</a> , das dazu beiträgt, übertragene Informationen vor dem Abfangen oder sonstigen Manipulieren zu schützen. <br><br>  Darüber hinaus können Sie in MQTT die Ably-Authentifizierung für Token verwenden, wenn Sie Ihren API-Schlüssel überhaupt nicht an den tatsächlichen MQTT-Client weitergeben möchten (bei MQTT ohne SSL sind Token erforderlich, um die Übertragung von API-Schlüsseln im Klartext zu verhindern).  Beispiel für eine Token-Authentifizierung: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> options = { <span class="hljs-attr"><span class="hljs-attr">keepalive</span></span>: <span class="hljs-number"><span class="hljs-number">60</span></span>, <span class="hljs-attr"><span class="hljs-attr">username</span></span>: INSERT_TOKEN_HERE, <span class="hljs-attr"><span class="hljs-attr">password</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-attr"><span class="hljs-attr">port</span></span>: <span class="hljs-number"><span class="hljs-number">8883</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> client = mqtt.connect(<span class="hljs-string"><span class="hljs-string">'mqtts:mqtt.ably.io'</span></span>, options); client.subscribe(<span class="hljs-string"><span class="hljs-string">"[mqtt]tokenevents"</span></span>, { <span class="hljs-comment"><span class="hljs-comment">/* Create a new token called 'NEW_TOKEN' */</span></span> client.end(); options.username = NEW_TOKEN; client = mqtt.connect(<span class="hljs-string"><span class="hljs-string">'mqtts:mqtt.ably.io'</span></span>, options); });</code> </pre> <br><h1>  MQTT-Funktionalität: tieferes Eintauchen </h1><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Laut IBM</a> hat MQTT die folgenden Eigenschaften: <br><br><ul><li>  Neutral zum Nachrichteninhalt <br></li><li>  Ideal für verteilte Eins-zu-Viele-Kommunikation und getrennte Anwendungen <br></li><li>  Ausgestattet mit der LWT-Funktion (Letzter Wille und Testament, „Letzter Wille und Testament“), um die Parteien über eine abnormale Trennung des Kunden zu informieren <br></li><li>  Verlässt sich für grundlegende Kommunikationsaufgaben auf TCP / IP <br></li><li>  Entwickelt, um Nachrichten mit den Vorlagen "höchstens einmal", "mindestens einmal" und "genau einmal" zu übermitteln. </li></ul><br>  Ein Mitglied des MQTT-Systems kann gleichzeitig die Rolle des Herausgebers, Verbrauchers oder beider Rollen übernehmen. <br><br>  Eines der charakteristischen Merkmale von MQTT ist das einzigartige Verständnis der Kanäle: Jeder von ihnen wird als Dateipfad behandelt, zum Beispiel: <br><br><pre> <code class="javascript hljs">channel = <span class="hljs-string"><span class="hljs-string">"user/path/channel"</span></span></code> </pre> <br>  Kanäle stellen sicher, dass jeder Kunde Nachrichten erhält, die für ihn bestimmt sind.  Durch die Behandlung von Kanälen als Dateipfade führt MQTT alle Arten nützlicher Kommunikationsfunktionen aus, einschließlich des Filterns von Nachrichten basierend darauf, wo - auf welcher Ebene oder in welchem ​​Zweig - Clients den Dateipfad abonnieren. <br><br><h1>  MQTT-Nachrichtenformat </h1><br>  Schauen Sie sich die beiden Komponenten an, aus denen jede MQTT-Nachricht besteht: <br><br><ul><li>  <b>Byte 1</b> : Enthält den Nachrichtentyp (Verbindungsanforderung des Clients, Abonnementbestätigung, Ping-Anforderung usw.), ein Duplizierungsflag, Anweisungen zum Speichern von Nachrichten und Informationen zur Dienstgüte (Quality of Service, QoS). <br></li><li>  <b>Byte 2</b> : Enthält Informationen zur verbleibenden Nachrichtenlänge, einschließlich der Nutzdaten und aller Daten im Header einer optionalen Variablen. </li></ul><br>  Das QoS-Flag in Byte 1 verdient besondere Aufmerksamkeit, da es der von MQTT unterstützten Variablenfunktionalität zugrunde liegt.  QoS-Flags enthalten die folgenden Werte, basierend auf der Absicht und Dringlichkeit der Nachricht: <br><br><ul><li>  0 = nicht mehr als einmal: Der Server wird ausgelöst und vergisst.  Nachrichten können verloren gehen oder dupliziert werden. <br></li><li>  1 = mindestens einmal: Der Empfänger bestätigt die Lieferung.  Nachrichten können dupliziert werden, die Zustellung ist jedoch garantiert <br></li><li>  2 = genau einmal: Der Server liefert.  Nachrichten kommen genau einmal ohne Verlust oder Vervielfältigung an </li></ul><br>  Schauen wir uns an, wie die verschiedenen QoS-Ebenen in IoT-Geräten und anderen Anwendungen verwendet werden. <br><br><h1>  Wo kann ich MQTT verwenden? </h1><br>  Da IoT-Anwendungen jetzt in großem Umfang implementiert werden, hat sich MQTT als offene, einfache und skalierbare Möglichkeit herausgestellt, verteilte Computer- und IoT-Funktionen für eine breitere Anwenderbasis bereitzustellen - sowohl auf dem Verbraucher- als auch auf dem Industriemarkt. <br><br>  Wie oben erwähnt, ist MQTT ein leichtes Messaging-Protokoll, das für nicht vertrauenswürdige Netzwerke und Geräte mit Einschränkungen hinsichtlich Stromversorgung und CPU entwickelt wurde.  Dies bedeutet jedoch nicht, dass die Verbindung mit potenziellem Paketverlust die einzige Anwendung ist.  MQTT bietet verschiedene Serviceebenen für verschiedene Arten von IoT-Infrastrukturen, von der wiederholten Datenerfassung bis zur Verwaltung von Industriemaschinen: <br><br><ul><li>  <b>Umgebungssensordaten</b> : Wie bereits erwähnt, unterstützt MQTT das Nachrichtenübermittlungsmodell „nicht mehr als einmal“.  In Netzwerken mit teilweiser Abdeckung oder hoher Latenz bedeutet dies, dass Informationen verloren gehen oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dupliziert werden können</a> .  In Bereichen, in denen Fernsensoren Daten in festgelegten Intervallen aufzeichnen und übertragen, ist dies kein Problem, da regelmäßig neue Messwerte empfangen werden.  Sensoren in entfernten Umgebungen sind normalerweise Geräte mit geringem Stromverbrauch, was MQTT zur idealen Lösung für IoT-Sensoren mit einer relativ niedrigen Datenübertragungspriorität macht. <br></li><li>  <b>Maschinenleistungsdaten</b> : um schnell auf Probleme zu reagieren und Ausfallzeiten zu vermeiden.  Beispielsweise muss eine Windkraftanlage die aktuellen Leistungsindikatoren garantiert an lokale Teams liefern, noch bevor diese Informationen das Rechenzentrum erreichen.  In solchen Situationen stellt die Zustellung von Nachrichten „mindestens einmal“ sicher, dass die entsprechenden Spezialisten von den erforderlichen Spezialisten unverzüglich bemerkt werden, auch wenn sie als Duplikate eintreffen.  Dies ist wichtig für die Maschinenkommunikation mit höherer Priorität. <br></li><li>  <b>Abrechnungssysteme</b> : Es gibt noch vorrangigere und genauere Nachrichten, die korrekt verarbeitet werden müssen.  In Geschäftssituationen, in denen das Duplizieren von Datensätzen nicht akzeptabel ist, einschließlich in Abrechnungssystemen, ist das QoS-Flag <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">„genau einmal“</a> nützlich.  Dies eliminiert die Verdoppelung oder den Verlust von Paketen in Abrechnungs- oder Abrechnungssystemen, verringert die Anzahl der Anomalien und unnötigen Widersprüche, wie vereinbart. </li></ul><br><h1>  Wann sollte MQTT nicht verwendet werden? </h1><br>  Entwickler haben eine große Auswahl an Protokollen zum Entwerfen und Bereitstellen von bidirektionalen IoT-Kommunikationskanälen, einschließlich MQTT, HTTP, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CoAP</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">WebSockets</a> (sofern die CPU / Batterie dies zulässt) und anderen.  Ob MQTT die beste Wahl ist, hängt von der Hardware und der Aufgabe der Anwendung ab. <br><br>  Das MQTT-Protokoll wurde für Umgebungen mit extrem geringer Bandbreite entwickelt und kann sehr unflexibel sein, um jedes Byte zu speichern.  Beispielsweise definiert die Spezifikation nur fünf Fehlermeldungen, mit denen der Server die Verbindung ablehnen kann (z. B. einen ungültigen Benutzernamen / ein ungültiges Kennwort oder eine nicht akzeptable Version des Protokolls).  Wenn der Server auf einen anderen Fehler hinweisen möchte, hat er kein Glück.  Schlimmer noch, wenn nach dem Starten der Verbindung ein Fehler auftritt, gibt es überhaupt keinen Mechanismus, um einen Fehler zu melden.  Der Server kann nur mit den Schultern zucken und die TCP-Verbindung abrupt beenden, sodass der Client keine Ahnung hat, warum er sie abgebrochen hat (und ohne eine absichtliche Trennung von einem vorübergehenden Netzwerkproblem zu unterscheiden).  Für Leute, die an flexiblere und einfacher zu debuggende (wenn auch weniger sparsam in Bezug auf die Bandbreite) Pub / Sub-Protokolle gewöhnt sind, mag ein solcher spartanischer Ansatz ein wenig primitiv erscheinen. <br><br>  MQTT wird häufig zusammen mit HTTP bezeichnet. Daher führte Google eine Studie durch, in der die Antwortzeit, das Verkehrsaufkommen und andere für Entwickler wichtige Attribute verglichen wurden.  MQTT belegte in Google-Tests den ersten Platz, jedoch <i>nur unter Bedingungen, unter denen die Verbindung</i> zum Senden mehrerer Nutzdaten <i>wiederverwendet werden kann</i> . <br><br>  HTTP und MQTT sind aufgrund des relativ geringen Datenverkehrs, des geringen Batterie- und Speicherbedarfs eine gute Wahl für IoT-Anwendungen. <br><br>  CoAP ist ein weiteres Protokoll, das häufig mit MQTT für die Entwicklung von IoT-Systemen verglichen wird.  Sie sind ähnlich, aber es gibt spürbare Unterschiede.  MQTT ist ein Viele-zu-Viele-Protokoll, während CoAP im Grunde ein Eins-zu-Eins-Protokoll für die Kommunikation zwischen einem Server und einem Client ist.  Gleichzeitig bietet CoAP Funktionen für Metadaten, Ermittlung und Inhaltsverhandlung, über <i>die MQTT nicht verfügt</i> . <br><br>  In Fällen, in denen Clients nur Daten empfangen sollen, sind vom <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Server gesendete Ereignisse</a> ebenfalls eine geeignete Option. <br><br><h1>  So richten Sie MQTT schnell ein </h1><br>  Das MQTT-Repository auf GitHub verfügt über <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eine umfangreiche Liste von Open Source-MQTT-Bibliotheken</a> in verschiedenen Sprachen.  Im Folgenden finden Sie zwei Beispiele für die Anpassung mithilfe des Open Source-MQTT-Brokers, der JavaScript-Bibliothek und der .NET-Bibliothek. <br><br><h3>  Eclipse Mosquitto - Open Source MQTT Broker </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Eclipse Mosquitto</a> ist ein Open Source Message Broker (EPL / EDL), der die MQTT-Protokolle Version 5.0, 3.1.1 und 3.1 implementiert.  Mosquitto ist leicht und für alle Geräte geeignet: von Single-Board-Computern mit geringem Stromverbrauch bis hin zu vollwertigen Servern. <br><br><h3>  MQTT.js </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MQTT.js</a> ist eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Clientbibliothek</a> für das MQTT-Protokoll, die in JavaScript für Node.js und einem Browser geschrieben wurde.  Hier ist ein Beispiel für das Senden einer Nachricht mit MQTT.js: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> mqtt = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'mqtt'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> client = mqtt.connect(<span class="hljs-string"><span class="hljs-string">'mqtt://test.mosquitto.org'</span></span>) client.on(<span class="hljs-string"><span class="hljs-string">'connect'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ client.subscribe(<span class="hljs-string"><span class="hljs-string">'presence'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!err) { client.publish(<span class="hljs-string"><span class="hljs-string">'presence'</span></span>, <span class="hljs-string"><span class="hljs-string">'Hello mqtt'</span></span>) } }) }) client.on(<span class="hljs-string"><span class="hljs-string">'message'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">topic, message</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// message is Buffer console.log(message.toString()) client.end() })</span></span></code> </pre> <br><h3>  MQTTnet </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MQTTnet</a> ist eine leistungsstarke .NET-Bibliothek, die sowohl den Client als auch den MQTT-Server (Broker) bereitstellt. <br><br>  Installation des MQTT-Clients: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Create a new MQTT client. var factory = new MqttFactory(); var mqttClient = factory.CreateMqttClient();</span></span></code> </pre> <br>  Nachdem Sie die MQTT-Clienteinstellungen konfiguriert haben, können Sie eine Verbindung herstellen.  Der folgende Code zeigt, wie eine Verbindung zum Server hergestellt wird: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Use WebSocket connection. var options = new MqttClientOptionsBuilder() .WithWebSocketServer("broker.hivemq.com:8000/mqtt") .Build(); await client.ConnectAsync(options);</span></span></code> </pre> <br>  Eingehende Nachrichten empfangen: <br><br><pre> <code class="cpp hljs">client.UseApplicationMessageReceivedHandler(e =&gt; { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"### RECEIVED APPLICATION MESSAGE ###"</span></span>); Console.WriteLine($<span class="hljs-string"><span class="hljs-string">"+ Topic = {e.ApplicationMessage.Topic}"</span></span>); Console.WriteLine($<span class="hljs-string"><span class="hljs-string">"+ Payload = {Encoding.UTF8.GetString(e.ApplicationMessage.Payload)}"</span></span>); Console.WriteLine($<span class="hljs-string"><span class="hljs-string">"+ QoS = {e.ApplicationMessage.QualityOfServiceLevel}"</span></span>); Console.WriteLine($<span class="hljs-string"><span class="hljs-string">"+ Retain = {e.ApplicationMessage.Retain}"</span></span>); Console.WriteLine(); Task.Run(() =&gt; client.PublishAsync(<span class="hljs-string"><span class="hljs-string">"hello/world"</span></span>)); });</code> </pre> <br>  Post Veröffentlichung: <br><br><pre> <code class="cpp hljs">var message = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MqttApplicationMessageBuilder() .WithTopic(<span class="hljs-string"><span class="hljs-string">"MyTopic"</span></span>) .WithPayload(<span class="hljs-string"><span class="hljs-string">"Hello World"</span></span>) .WithExactlyOnceQoS() .WithRetainFlag() .Build(); await client.PublishAsync(message);</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Weitere Beispiele finden</a> Sie in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MQTTnet-Dokumentation und im Wiki</a> . <br><br>  Anbieter für Unternehmen verfügen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">über handelsübliche MQTT-Server</a> für skalierbares Messaging zwischen mobilen Anwendungen, Industriemaschinen und einer Vielzahl anderer IoT-Anwendungen.  In diesem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Handbuch</a> erfahren Sie, wie Sie MQTT über einen Broker auf Unternehmensebene verwenden. <br><br><h1>  Was ist mit Skalierung? </h1><br>  Bei der Skalierung von MQTT sind zwei Überlegungen zu berücksichtigen: 1) Ist dies das richtige Protokoll?  2) Unabhängig von der Wahl des Protokolls, welche Infrastruktur- und Netzwerkfunktionen erforderlich sind, um den erhöhten Datenverkehr zwischen Geräten mit MQTT zu bewältigen. <br><br>  Lightweight Machine-to-Machine (LWM2M) ist ein weiteres Protokoll, das mit MQTT auf Unternehmensebene verwendet werden kann.  Im Vergleich zu MQTT ist es manchmal <i>besser für langfristige IoT-Systeme geeignet</i> .  MQTT ist ideal für einen mühelosen Testlauf von IoT geeignet, während das LWM2M Funktionen für eine langfristige, vielseitige Infrastruktur bietet.  LWM2M bietet außerdem überlegene Geräteverwaltungstools wie Verbindungsüberwachung, Firmware-Updates und Remote-Geräteaktionen.  Für Unternehmen mit einer großen Anzahl nicht verwalteter Geräte, die große Datenmengen an eine zentrale Plattform senden, ist LWM2M die beste Wahl.  Wir sprechen jedoch von umfangreichen IoT-Bereitstellungen, sodass MQTT normalerweise mehr als eine angemessene Option ist.  Darüber hinaus ist MQTT häufiger und wird breiter unterstützt. <br><br>  Nun zu den Möglichkeiten der Infrastruktur.  Beim Laden von Servern ist die Anzahl der gleichzeitigen Verbindungen selten ein Engpass.  Die meisten guten MQTT-Server / Broker unterstützen Tausende von gleichzeitigen Verbindungen. Wie hoch ist jedoch die Arbeitslast, die zum Verarbeiten und Beantworten von Nachrichten erforderlich ist, nachdem der MQTT-Server die tatsächlichen Daten empfangen hat?  In der Regel gibt es alle möglichen Probleme, z. B. Lesen und Schreiben in und aus der Datenbank, Integration in den Server, Verteilung und Verwaltung von Ressourcen für jeden Client usw. Sobald ein Computer die Last nicht mehr bewältigt, müssen Sie zusätzliche Server hinzufügen. Denken Sie also an den Lastenausgleich, die Nachrichtensynchronisierung zwischen Clients, die mit verschiedenen Servern verbunden sind, den allgemeinen Zugriff auf den Clientstatus, unabhängig von der Verbindungszeit oder dem spezifischen Server, mit dem der Client verbunden ist - der Produktliste  zhaetsya und es geht weiter. <br><br>  Solche Probleme verdienen einen separaten Artikel, und viele Informationen finden Sie im Engineering-Bereich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">unseres Blogs</a> .  Lesen Sie insbesondere den Artikel über <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einige der Komplexitäten bei der Wartung einer umfangreichen Echtzeit-Messaging-Infrastruktur</a> . <br><br><h1>  Wie ist die aktuelle Situation mit MQTT? </h1><br>  Im April 2019 veröffentlichte OASIS MQTT v5.0 als offiziellen Standard.  OASIS ist ein gemeinnütziges Konsortium aus 600 Mitgliedsorganisationen und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">5.000 Einzelmitgliedern</a> . <br><br>  Version 5.0 enthält eine Reihe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">neuer Funktionen</a> , die für Entwickler von Echtzeitsystemen von Interesse sein sollten.  Diese neuen Funktionen sind abwärtskompatibel mit aktuellen Versionen von MQTT.  Unter ihnen: <br><br><ul><li>  <b>Verbesserte Fehlerberichterstattung</b> : Rückkehrcodes können jetzt darüber informieren, dass Daten aus irgendeinem Grund nicht übertragen werden.  Optionale Zeichenfolgen werden unterstützt, um den Grund anzugeben.  Sie helfen bei der Verbesserung der Fehlerbehebungsdiagnose. <br></li><li>  <b>Abonnements freigeben</b> : Um die Last auszugleichen, können Abonnements auf der empfangenden Seite von mehreren Clients gemeinsam genutzt werden. <br></li><li>  <b>Nachrichteneigenschaften</b> : Version 5.0 führt Metadaten als Teil des Nachrichtenkopfs ein.  Es kann dem Endbenutzer zusätzliche Informationen übermitteln oder einige der anderen unten aufgeführten Funktionen erleichtern. <br></li><li>  <b>Kanalalias</b> : Publisher können Kanäle durch numerische Kennungen ersetzen, um die Anzahl der zu sendenden Bytes zu verringern. <br></li><li>  <b>Ablaufdatum der</b> Nachricht: Nachrichten können zum automatischen Löschen markiert werden, wenn das System sie nicht innerhalb eines bestimmten Zeitraums zustellen kann. </li></ul><br>  Eine vollständige Liste der neuen MQTT 5.0-Funktionen finden Sie in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Anhang C</a> des offiziellen Standards. <br><br>  Zusätzlich zu den vielen Consumer-Geräten und -Diensten auf dem Markt hat MQTT Verwendung in Unternehmensinfrastrukturen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">aller Formen und Größen gefunden</a> .  Dies sind Smartphones und Tablets, Energieüberwachungssysteme, medizinische Geräte, Ölplattformen und Bohrinseln, die Automobil- und Luftfahrtindustrie sowie Sensoren und Bildverarbeitungssysteme, die in den Bereichen Materialtransport, Bauwesen, Lieferkette, Einzelhandel und vielem mehr eingesetzt werden. <br><br><h1>  MQTT und Ably </h1><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MQTT</a> ist ein beliebtes, weit verbreitetes und relativ ausgereiftes Protokoll.  Es eignet sich hervorragend für <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">viele Echtzeitanwendungen</a> und nicht nur für die Bereitstellung von IoT.  Da die Produktion und der Verbrauch von Echtzeitdaten jedoch weiterhin <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">exponentiell zunehmen</a> , ist MQTT möglicherweise nicht immer das richtige Protokoll, um Ihre Streaming-Anforderungen zu erfüllen.  Befolgen Sie unseren Abschnitt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Echtzeitkonzepte,</a> um Informationen zu anderen Protokollen und deren Anpassung an Ihre Situation zu erhalten. <br><br>  Ably bietet einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Broker und einen MQTT-Protokolladapter</a> mit Übersetzung in das eigene Protokoll von Ably in beide Richtungen, sodass Sie sich in vorhandene Systeme und Verbindungen integrieren können.  Es werden WebSockets, HTTP, SSE, gRPC (in Entwicklung), STOMP, AMQP und andere Protokolle zum Organisieren einer verteilten Echtzeit-Messaging-Infrastruktur unterstützt.  Es gibt über 40 SDK-Client-Bibliotheken und Unterstützung für proprietäre Echtzeitprotokolle. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de463669/">https://habr.com/ru/post/de463669/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de463655/index.html">Die Geburt eines Projekts oder wie man ein eigenes CMS schreibt</a></li>
<li><a href="../de463657/index.html">Chatbots sind scheiße</a></li>
<li><a href="../de463663/index.html">10 Bücher, um die Struktur der Börse, Investitionen an der Börse und automatisierten Handel zu verstehen</a></li>
<li><a href="../de463665/index.html">1,1 Milliarden Taxifahrten: 108-Kern-ClickHouse-Cluster</a></li>
<li><a href="../de463667/index.html">Forest gibt sich nicht der Suchtechnologie hin, aber Ingenieure schlagen zurück</a></li>
<li><a href="../de463673/index.html">6 Gründe, ein IT-Startup in Kanada zu eröffnen</a></li>
<li><a href="../de463675/index.html">Personalalchemie: Wie setzt sich das Team des Zentrums GosSOPKA optimal zusammen?</a></li>
<li><a href="../de463677/index.html">Teamleiter auf einer Fernbedienung: Wie ich mit meiner Familie gereist bin und von Griechenland und Vietnam aus gearbeitet habe</a></li>
<li><a href="../de463681/index.html">Budget Wassersucht für die GPU. Bekanntschaft und erste Erfahrung</a></li>
<li><a href="../de463683/index.html">Übersicht über Open Typo Correction Solutions</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>