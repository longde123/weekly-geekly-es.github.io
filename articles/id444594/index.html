<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>â˜ğŸ¿ ğŸ— ğŸ‘¨ğŸ¾â€ğŸ”¬ Besar o ğŸ‘¨ğŸ¿â€ğŸ¤â€ğŸ‘¨ğŸ¼ ğŸ–Šï¸ ğŸ™‹ğŸ¼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Catatan Terjemahan singkat, agak menceritakan kembali kata-kata Anda sendiri. 
 UPD: seperti disebutkan dalam komentar, contohnya tidak sempurna. Penu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Besar o</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444594/">  <i><u>Catatan</u></i>  <i>Terjemahan singkat, agak menceritakan kembali kata-kata Anda sendiri.</i> <i><br></i>  <i>UPD: seperti disebutkan dalam komentar, contohnya tidak sempurna.</i>  <i>Penulis tidak mencari solusi terbaik untuk masalah ini, tujuannya adalah untuk menjelaskan kompleksitas algoritma "di jari".</i> <br><br>  Notasi O besar diperlukan untuk menggambarkan kompleksitas algoritme.  Untuk ini, konsep waktu digunakan.  Topik itu menakutkan bagi banyak orang, programmer menghindari berbicara tentang "waktu urutan N" adalah hal yang umum. <br><br>  Jika Anda dapat mengevaluasi kode dalam hal Big O, Anda kemungkinan besar dianggap sebagai "orang pintar."  Dan kemungkinan besar Anda akan menjalani wawancara berikutnya.  Anda tidak akan dihentikan oleh pertanyaan apakah mungkin untuk mengurangi kompleksitas sepotong kode menjadi n log n terhadap n ^ 2. <br><br><h2>  Struktur data </h2><br>  Pilihan struktur data tergantung pada tugas spesifik: pada jenis data dan algoritma untuk pemrosesan mereka.  Berbagai struktur data (dalam. NET atau Java atau Elixir) dibuat untuk beberapa jenis algoritma. <br><br>  Seringkali, memilih satu atau lain struktur, kami hanya menyalin solusi yang diterima secara umum.  Dalam kebanyakan kasus, ini sudah cukup.  Namun pada kenyataannya, tanpa memahami kompleksitas algoritma, kami tidak dapat membuat pilihan berdasarkan informasi.  Topik struktur data hanya dapat diteruskan setelah kompleksitas algoritma. <br><br>  Di sini kita hanya akan menggunakan array angka (seperti dalam wawancara).  Contoh JavaScript. <br><a name="habracut"></a><br><h2>  Mari kita mulai dengan yang paling sederhana: O (1) </h2><br>  Ambil 5 nomor array: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> nums = [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>];</code> </pre> <br>  Misalkan Anda perlu mendapatkan elemen pertama.  Kami menggunakan indeks untuk ini: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> nums = [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> firstNumber = nums[<span class="hljs-number"><span class="hljs-number">0</span></span>];</code> </pre> <br>  Seberapa rumitkah algoritma ini?  Kita dapat mengatakan: "sama sekali tidak rumit - cukup ambil elemen pertama dari array."  Ini benar, tetapi lebih tepat untuk menggambarkan kompleksitas melalui jumlah operasi yang dilakukan untuk mencapai hasil, tergantung pada input ( <i>operasi</i> input). <br><br>  Dengan kata lain: berapa banyak operasi akan meningkat seiring dengan meningkatnya parameter input. <br><br>  Dalam contoh kita, ada 5 parameter input, karena ada 5 elemen dalam array.  Untuk mendapatkan hasilnya, Anda perlu melakukan satu operasi (mengambil elemen dengan indeks).  Berapa banyak operasi yang diperlukan jika ada 100 elemen dalam array?  Atau 1000?  Atau 100.000?  Semua sama, hanya satu operasi yang diperlukan. <br><br>  Yaitu: "satu operasi untuk semua data input yang mungkin" - O (1). <br><br>  O (1) dapat dibaca sebagai "kompleksitas urutan 1" (urutan 1), atau "algoritma berjalan dalam waktu konstan / konstan" (waktu konstan). <br><br>  Anda sudah menebak bahwa algoritma O (1) adalah yang paling efisien. <br><br><h2>  Iterasi dan "waktu pemesanan n": O (n) </h2><br>  Sekarang mari kita cari jumlah elemen-elemen dari array: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> nums = [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sum = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> num <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> nums){ sum += num; }</code> </pre> <br>  Sekali lagi kami bertanya pada diri sendiri: berapa banyak operasi input yang kita butuhkan?  Di sini Anda perlu memilah-milah semua elemen, yaitu  operasi pada setiap elemen.  Semakin besar array, semakin banyak operasi. <br><br>  Menggunakan notasi O Besar: O (n), atau "kompleksitas urutan n (urutan n)".  Juga, jenis algoritma ini disebut "linier" atau bahwa algoritme itu "skala linear". <br><br><h3>  Analisis </h3><br>  Bisakah kita membuat penjumlahan lebih efisien?  Secara umum tidak.  Dan jika kita tahu bahwa array dijamin mulai dari 1, disortir dan tidak memiliki celah?  Kemudian kita bisa menerapkan rumus S = n (n + 1) / 2 (di mana n adalah elemen terakhir dari array): <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sumContiguousArray = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ary</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">//get the last item const lastItem = ary[ary.length - 1]; //Gauss's trick return lastItem * (lastItem + 1) / 2; } const nums = [1,2,3,4,5]; const sumOfArray = sumContiguousArray(nums);</span></span></code> </pre> <br>  Algoritma seperti itu jauh lebih efisien daripada O (n), apalagi, dieksekusi dalam "waktu konstan / konstan", yaitu.  itu adalah O (1). <br><br>  Bahkan, ada lebih dari satu operasi: Anda perlu mendapatkan panjang array, mendapatkan elemen terakhir, melakukan perkalian dan pembagian.  Bukankah itu O (3) atau sesuatu?  Dalam notasi O Besar, jumlah langkah aktual tidak penting, penting bahwa algoritma berjalan dalam waktu yang konstan. <br><br>  Algoritma konstan-waktu selalu O (1).  Sama dengan algoritma linier, pada kenyataannya, operasi dapat menjadi O (n + 5), dalam Big O notasi adalah O (n). <br><br><h2>  Bukan solusi terbaik: O (n ^ 2) </h2><br>  Mari kita menulis fungsi yang memeriksa array untuk duplikat.  Solusi Nested Loop: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> hasDuplicates = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">num</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//loop the list, our O(n) op for (let i = 0; i &lt; nums.length; i++) { const thisNum = nums[i]; //loop the list again, the O(n^2) op for (let j = 0; j &lt; nums.length; j++) { //make sure we're not checking same number if (j !== i) { const otherNum = nums[j]; //if there's an equal value, return if (otherNum === thisNum) return true; } } } //if we're here, no dups return false; } const nums = [1, 2, 3, 4, 5, 5]; hasDuplicates(nums);//true</span></span></code> </pre> <br>  Kita sudah tahu bahwa iterasi array adalah O (n).  Kami memiliki loop bersarang, untuk setiap elemen kami mengulangi lagi - yaitu  O (n ^ 2) atau "kompleksitas urutan n kuadrat." <br><br>  Algoritma dengan loop bersarang atas koleksi yang sama selalu O (n ^ 2). <br><br><h2>  "Kompleksitas urutan log n": O (log n) </h2><br>  Pada contoh di atas, loop bersarang, dengan sendirinya (jika Anda tidak memperhitungkannya bersarang), memiliki kompleksitas O (n), karena  ini adalah enumerasi elemen array.  Siklus ini berakhir segera setelah elemen yang diinginkan ditemukan, mis.  pada kenyataannya, tidak semua elemen akan disebutkan.  Namun notasi Big O selalu mempertimbangkan skenario terburuk - item yang Anda cari mungkin yang terakhir. <br><br>  Di sini, loop bersarang digunakan untuk mencari elemen yang diberikan dalam array.  Pencarian elemen dalam array, dalam kondisi tertentu, dapat dioptimalkan - dilakukan lebih baik daripada linear O (n). <br><br>  Biarkan array diurutkan.  Kemudian kita dapat menggunakan algoritma pencarian biner: membagi array menjadi dua bagian, membuang yang tidak perlu, membagi sisanya lagi menjadi dua bagian, dan seterusnya sampai kita menemukan nilai yang diinginkan.  Jenis algoritma ini disebut Divide and Conquer Divide and Conquer. <br><br><img src="https://habrastorage.org/webt/0p/b9/em/0pb9em6fqdkdj0dtknyxbt8kbvk.png" alt="pencarian biner"><br><br>  Algoritma ini didasarkan pada logaritma. <br><br><h2>  Tinjauan singkat logaritma </h2><br>  Pertimbangkan sebuah contoh, apa yang akan sama dengan x? <br><br>  x ^ 3 = 8 <br><br>  Kita perlu mengambil akar kubik 8 - ini akan 2. Sekarang lebih sulit <br><br>  2 ^ x = 512 <br><br>  Menggunakan logaritma, masalahnya bisa ditulis sebagai <br><br>  log2 (512) = x <br><br>  "Logaritma basis 2 dari 512 adalah x."  Perhatikan â€œbase 2â€, mis.  kami pikir dalam dua - berapa kali Anda perlu mengalikan 2 untuk mendapatkan 512. <br><br>  Dalam algoritma pencarian biner, pada setiap langkah kami membagi array menjadi dua bagian. <br><br>  <i><u>Tambahan saya.</u></i>  <i>Yaitu</i>  <i>dalam kasus terburuk, kami melakukan operasi sebanyak yang kami bisa membagi array menjadi dua bagian.</i>  <i>Misalnya, berapa kali kita dapat membagi array 4 elemen menjadi dua bagian?</i>  <i>2 kali.</i>  <i>Dan array 8 elemen?</i>  <i>3 kali.</i>  <i>Yaitu</i>  <i>jumlah divisi / operasi = log2 (n) (di mana n adalah jumlah elemen dalam array).</i> <i><br><br></i>  <i>Ternyata ketergantungan dari jumlah operasi pada jumlah elemen input digambarkan sebagai log2 (n)</i> <i><br></i> <br><br>  Dengan demikian, menggunakan notasi Big O, algoritma pencarian biner memiliki kompleksitas O (log n). <br><br><h2>  Tingkatkan O (n ^ 2) menjadi O (n log n) </h2><br>  Mari kita kembali ke tugas memeriksa array untuk duplikat.  Kami mengulangi semua elemen array, dan untuk setiap elemen kami mengulangi lagi.  Mereka melakukan O (n) di dalam O (n), yaitu  O (n * n) atau O (n ^ 2). <br><br>  Kita dapat mengganti nested loop dengan pencarian biner *.  Yaitu  kita hanya harus melalui semua elemen O (n), di dalam kita lakukan O (log n).  Ternyata O (n * log n), atau O (n log n). <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> nums = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> searchFor = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">items, num</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//use binary search! //if found, return the number. Otherwise... //return null. We'll do this in a later chapter. } const hasDuplicates = function (nums) { for (let num of nums) { //let's go through the list again and have a look //at all the other numbers so we can compare if (searchFor(nums, num)) { return true; } } //only arrive here if there are no dups return false; }</span></span></code> </pre> <br><br>  * PERHATIAN, untuk menghindari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pencetakan</a> .  Menggunakan pencarian biner untuk memeriksa array untuk duplikat adalah solusi yang buruk.  Ini hanya menunjukkan bagaimana, dalam istilah Big O, untuk mengevaluasi kompleksitas algoritma yang ditunjukkan dalam daftar kode di atas.  Algoritma yang baik atau yang buruk tidak penting untuk artikel ini, visibilitas penting. <br><br><h2>  Berpikir dalam hal Big O </h2><br><ul><li>  Mendapatkan barang koleksi adalah O (1).  Apakah itu diperoleh dengan indeks dalam array, atau dengan kunci dalam kamus dalam notasi O Besar, itu akan menjadi O (1) </li><li>  Iterasi atas koleksi adalah O (n) </li><li>  Loop bersarang atas koleksi yang sama adalah O (n ^ 2) </li><li>  Bagi dan Taklukkan selalu O (log n) </li><li>  Iterasi yang menggunakan Divide dan Conquer adalah O (n log n) </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id444594/">https://habr.com/ru/post/id444594/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id444582/index.html">Palo Alto Networks Pengoptimal Kebijakan Keamanan NGFW</a></li>
<li><a href="../id444584/index.html">Android akan menawarkan pengguna Eropa browser dan mesin pencari pilihan</a></li>
<li><a href="../id444586/index.html">Arsitektur Segmen Internet Rusia</a></li>
<li><a href="../id444590/index.html">Kebocoran data (yang bisa saja terjadi tetapi tidak terjadi) dari perusahaan telemedicine</a></li>
<li><a href="../id444592/index.html">Militer AS berencana untuk menggunakan exoskeleton tipe baru</a></li>
<li><a href="../id444596/index.html">Iodide: Editor Sains Interaktif Mozilla</a></li>
<li><a href="../id444598/index.html">CD itu berusia 40 tahun dan dia sudah mati (kan?)</a></li>
<li><a href="../id444600/index.html">Ulasan dari 14 cm tanpa kepala 2019</a></li>
<li><a href="../id444602/index.html">Enkapsulasi dalam C ++ dan C</a></li>
<li><a href="../id444610/index.html">Statistik dan pemantauan skrip PHP secara real time. ClickHouse dan Grafana pergi untuk membantu Pinba</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>