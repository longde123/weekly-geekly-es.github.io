<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë∏ üîΩ üïö C #: compatibilit√© descendante et surcharge üàπ üò¥ ü§π</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour coll√®gues! 

 Nous rappelons √† tous que nous avons un excellent livre de Mark Price, " C # 7 et .NET Core. D√©veloppement multiplateforme pour ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C #: compatibilit√© descendante et surcharge</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/414223/">  Bonjour coll√®gues! <br><br>  Nous rappelons √† tous que nous avons un excellent livre de Mark Price, " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">C # 7 et .NET Core. D√©veloppement multiplateforme pour les professionnels</a> ."  Remarque: il s'agit de la troisi√®me √©dition, la premi√®re √©dition a √©t√© √©crite dans la version 6.0 et n'appara√Æt pas en russe, et la troisi√®me √©dition a √©t√© publi√©e dans l'original en novembre 2017 et couvre la version 7.1. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qu/3r/yz/qu3ryzosqkh7hbufbfvfjcukuf8.jpeg"></div><br>  Apr√®s la publication d'un tel recueil, qui a fait l'objet d'une √©dition scientifique distincte pour v√©rifier la compatibilit√© descendante et d'autres correctes du mat√©riel pr√©sent√©, nous avons d√©cid√© de traduire un article int√©ressant de John Skeet sur les difficult√©s connues et peu connues de la compatibilit√© descendante qui peuvent survenir en C #.  Bonne lecture. <br><a name="habracut"></a><br>  En juillet 2017, j'ai commenc√© √† √©crire un article sur le contr√¥le de version.  Bient√¥t abandonn√©, car le sujet √©tait trop √©tendu pour le couvrir en un seul post.  Sur un tel sujet, il est plus logique de mettre en √©vidence un site / wiki / r√©f√©rentiel entier.  J'esp√®re revenir un jour sur ce sujet, car je le consid√®re extr√™mement important et je pense qu'il re√ßoit beaucoup moins d'attention qu'il ne le m√©rite. <br><br>  Ainsi, dans l'√©cosyst√®me .NET, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le versioning s√©mantique</a> est g√©n√©ralement le bienvenu - cela semble g√©nial, mais exige que tout le monde comprenne √©galement ce qui est consid√©r√© comme un ¬´changement fondamental¬ª.  Voil√† ce que je pense depuis longtemps.  L'un des aspects qui m'a le plus r√©cemment frapp√© est la difficult√© d'√©viter des changements fondamentaux lors de la surcharge des m√©thodes.  C'est √† ce sujet (principalement) que nous discuterons du post que vous lisez;  apr√®s tout, ce sujet est tr√®s int√©ressant. <br>  Pour commencer - une br√®ve d√©finition ... <br><br>  <b>Sources et compatibilit√© binaire</b> <br><br>  Si je peux recompiler mon code client avec la nouvelle version de la biblioth√®que, et que tout fonctionne bien, alors c'est la compatibilit√© au niveau du code source.  Si je peux red√©ployer mon binaire client avec la nouvelle version de la biblioth√®que sans recompilation, alors il est compatible binaire.  Rien de tout cela n'est un surensemble de l'autre: <br><br><ul><li>  Certaines modifications peuvent √™tre incompatibles avec le code source et le code binaire en m√™me temps - par exemple, vous ne pouvez pas supprimer un type public entier dont vous d√©pendez compl√®tement. </li><li>  Certaines modifications sont compatibles avec le code source, mais incompatibles avec le code binaire - par exemple, si vous convertissez un champ statique public en lecture seule en propri√©t√©. </li><li>  Certaines modifications sont compatibles avec le binaire, mais pas compatibles avec la source - par exemple, l'ajout d'une surcharge qui peut provoquer une ambigu√Øt√© lors de la compilation. </li><li>  Certaines modifications sont compatibles avec le code source et binaire - par exemple, une nouvelle impl√©mentation du corps de la m√©thode. </li></ul><br>  <b>Alors de quoi parle-t-on?</b> <br><br>  Supposons que nous ayons une biblioth√®que publique de la version 1.0, et que nous voulons y ajouter plusieurs surcharges afin de finaliser la version 1.1.  Nous nous en tenons au versioning s√©mantique, nous avons donc besoin d'une compatibilit√© descendante.  Qu'est-ce que cela signifie que nous pouvons et ne pouvons pas faire, et peut-on r√©pondre √† toutes les questions ici par ¬´oui¬ª ou ¬´non¬ª? <br><br>  Dans diff√©rents exemples, je montrerai le code dans les versions 1.0 et 1.1, puis le code ¬´client¬ª (c'est-√†-dire le code qui utilise la biblioth√®que), qui peut se casser √† la suite de modifications.  Il n'y aura ni corps de m√©thode, ni d√©clarations de classe, car ils ne sont, par essence, pas importants - nous accordons la plus grande attention aux signatures.  Cependant, si vous √™tes int√©ress√©, toutes ces classes et m√©thodes peuvent √™tre facilement reproduites.  Supposons que toutes les m√©thodes d√©crites ici se trouvent dans la classe <code>Library</code> . <br><br>  Le changement le plus simple imaginable, orn√© de la transformation d'un groupe de m√©thodes en d√©l√©gu√© <br>  L'exemple le plus simple qui me vient √† l'esprit est d'ajouter une m√©thode param√©tr√©e l√† o√π il y en a d√©j√† une non param√©tr√©e: <br><br><pre> <code class="cs hljs"> <span class="hljs-comment"><span class="hljs-comment">//   1.0 public void Foo() //   1.1 public void Foo() public void Foo(int x)</span></span></code> </pre> <br><br>  M√™me ici, la compatibilit√© est incompl√®te.  Consid√©rez le code client suivant: <br><br><pre> <code class="cs hljs"> <span class="hljs-comment"><span class="hljs-comment">//  static void Method() { var library = new Library(); HandleAction(library.Foo); } static void HandleAction(Action action) {} static void HandleAction(Action&lt;int&gt; action) {}</span></span></code> </pre> <br>  Dans la premi√®re version de la biblioth√®que, tout va bien.  L'appel de la m√©thode <code>HandleAction</code> convertit le groupe de m√©thodes en d√©l√©gu√© <code>library.Foo</code> et, par cons√©quent, une <code>Action</code> est cr√©√©e.  Dans la version 1.1, la situation devient ambigu√´: un groupe de m√©thodes peut √™tre converti en Action ou Action.  Autrement dit, une telle modification est incompatible avec le code source. <br><br>  √Ä ce stade, il est tentant de simplement abandonner et de vous promettre de ne plus jamais ajouter de surcharge.  Ou nous pouvons dire qu'un tel cas est assez peu probable pour ne pas avoir peur d'un tel √©chec.  Appelons pour l'instant les transformations d'un groupe de m√©thodes hors de port√©e. <br><br>  <b>Types de r√©f√©rence ind√©pendants</b> <br><br>  Prenons un autre contexte dans lequel vous devez utiliser des surcharges avec le m√™me nombre de param√®tres.  On peut supposer qu'une telle modification de la biblioth√®que sera non destructive: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//  1.0 public void Foo(string x) //  1.1 public void Foo(string x) public void Foo(FileStream x)</span></span></code> </pre> <br>  √Ä premi√®re vue, tout est logique.  Nous conservons la m√©thode d'origine, donc nous ne briserons pas la compatibilit√© binaire.  Le moyen le plus simple de le casser est d'√©crire un appel qui fonctionne dans la version 1.0, mais ne fonctionne pas dans la version 1.1, ou fonctionne dans les deux versions, mais de diff√©rentes mani√®res. <br>  Quelle incompatibilit√© entre v1.0 et v1.1 un tel appel peut-il donner?  Nous devons avoir un argument compatible avec la <code>string</code> et <code>FileStream</code> .  Mais ce sont des types de r√©f√©rence qui ne sont pas li√©s les uns aux autres ... <br><br>  Le premier √©chec est possible si nous effectuons une conversion implicite d√©finie par l'utilisateur en <code>string</code> et <code>FileStream</code> : <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//  class OddlyConvertible { public static implicit operator string(OddlyConvertible c) =&gt; null; public static implicit operator FileStream(OddlyConvertible c) =&gt; null; } static void Method() { var library = new Library(); var convertible = new OddlyConvertible(); library.Foo(convertible); }</span></span></code> </pre> <br>  J'esp√®re que le probl√®me est √©vident: le code qui √©tait auparavant sans ambigu√Øt√© et fonctionnait avec la <code>string</code> est maintenant ambigu, car le type <code>OddlyConvertible</code> peut √™tre implicitement converti √† la fois en <code>string</code> et en <code>FileStream</code> (les deux surcharges sont applicables, aucune d'elles n'est meilleure que l'autre). <br><br>  Dans ce cas, il est peut-√™tre raisonnable d'interdire les conversions d√©finies par l'utilisateur ... mais ce code peut √™tre r√©duit et beaucoup plus facile: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//  static void Method() { var library = new Library(); library.Foo(null); }</span></span></code> </pre> <br>  Nous pouvons implicitement convertir un litt√©ral null en n'importe quel type de r√©f√©rence ou en n'importe quel type significatif nullable ... par cons√©quent, encore une fois, la situation dans la version 1.1 est ambigu√´.  Essayons encore ... <br><br>  <b>Param√®tres des types de r√©f√©rence et des types significatifs non nullables</b> <br><br>  Supposons que nous ne nous soucions pas des transformations d√©finies par l'utilisateur, mais que nous n'aimons pas les litt√©raux null probl√©matiques.  Comment dans ce cas ajouter une surcharge avec un type significatif non nul? <br><br><pre> <code class="cs hljs"> <span class="hljs-comment"><span class="hljs-comment">//  1.0 public void Foo(string x) //  1.1 public void Foo(string x) public void Foo(int x)</span></span></code> </pre> <br>  √Ä premi√®re vue, c'est bien - <code>library.Foo(null)</code> fonctionnera bien dans la v1.1.  Il est donc en s√©curit√©?  Non, tout simplement pas en C # 7.1 ... <br><br><pre> <code class="cs hljs"> <span class="hljs-comment"><span class="hljs-comment">//  static void Method() { var library = new Library(); library.Foo(default); }</span></span></code> </pre> <br>  Le litt√©ral par d√©faut est exactement nul, mais s'applique √† tout type.  C'est tr√®s pratique - et un vrai casse-t√™te en mati√®re de surcharge et de compatibilit√© :( <br><br>  <b>Param√®tres facultatifs</b> <br><br>  Les param√®tres facultatifs sont un autre probl√®me.  Supposons que nous ayons un param√®tre facultatif et que nous voulons en ajouter un deuxi√®me.  Nous avons trois options, identifi√©es ci-dessous comme 1.1a, 1.1b et 1.1c. <br><br><pre> <code class="cs hljs"> <span class="hljs-comment"><span class="hljs-comment">//  1.0 public void Foo(string x = "") //  1.1a //   ,         public void Foo(string x = "") public void Foo(string x = "", string y = "") //  1.1b //          public void Foo(string x = "", string y = "") //  1.1c //   ,    ,   //  ,     . public void Foo(string x) public void Foo(string x = "", string y = "")</span></span></code> </pre> <br><br>  Mais que faire si le client fait deux appels: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//  static void Method() { var library = new Library(); library.Foo(); library.Foo("xyz"); }</span></span></code> </pre><br>  La biblioth√®que 1.1a maintient la compatibilit√© au niveau binaire, mais viole au niveau du code source: maintenant <code>library.Foo()</code> ambigu.  Selon les r√®gles de surcharge en C #, les m√©thodes sont pr√©f√©r√©es qui ne n√©cessitent pas que le compilateur "remplisse" tous les param√®tres facultatifs disponibles, cependant, il ne r√©gule pas le nombre de param√®tres facultatifs qui peuvent √™tre remplis. <br><br>  La biblioth√®que 1.1b maintient la compatibilit√© au niveau source, mais viole la compatibilit√© binaire.  Le code compil√© existant est con√ßu pour appeler une m√©thode avec un seul param√®tre - et une telle m√©thode n'existe plus. <br><br>  La biblioth√®que 1.1c conserve la compatibilit√© binaire, mais est pleine de surprises possibles au niveau du code source.  Maintenant, l'appel <code>library.Foo()</code> est r√©solu en une m√©thode avec deux param√®tres, tandis que <code>library.Foo("xyz")</code> r√©solu en une m√©thode avec un param√®tre (du point de vue du compilateur, il est pr√©f√©rable √† une m√©thode avec deux param√®tres, principalement parce qu'il n'y a pas de param√®tres optionnels aucun remplissage requis).  Cela peut √™tre acceptable si une version avec un param√®tre d√©l√®gue simplement les versions avec deux param√®tres, et dans les deux cas, la m√™me valeur par d√©faut est utilis√©e.  Cependant, il semble √©trange que la valeur du premier appel change si la m√©thode √† laquelle il √©tait pr√©c√©demment r√©solu existe toujours. <br><br>  La situation avec les param√®tres facultatifs devient encore plus d√©routante si vous souhaitez ajouter un nouveau param√®tre non pas √† la fin, mais au milieu - par exemple, essayez d'adh√©rer √† l'accord et de conserver le param√®tre CancellationToken facultatif √† la toute fin.  Je n'entrerai pas dans √ßa ... <br><br>  <b>M√©thodes g√©n√©ralis√©es</b> <br><br>  La conclusion des types dans le meilleur des cas n'√©tait pas une t√¢che facile.  Lorsqu'il s'agit de r√©soudre les surcharges, ce travail se transforme en cauchemar uniforme. <br><br>  Supposons que nous ayons une seule m√©thode non g√©n√©ralis√©e dans la v1.0, et dans la v1.1 nous ajoutons une autre m√©thode g√©n√©ralis√©e. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//  1.0 public void Foo(object x) //  1.1 public void Foo(object x) public void Foo&lt;T&gt;(T x)</span></span></code> </pre> <br>  √Ä premi√®re vue, ce n'est pas si effrayant ... mais voyons ce qui se passe dans le code client: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//  static void Method() { var library = new Library(); library.Foo(new object()); library.Foo("xyz"); }</span></span></code> </pre> <br>  Dans la biblioth√®que v1.0, les deux appels sont r√©solus dans <code>Foo(object)</code> - la seule m√©thode disponible. <br><br>  La biblioth√®que v1.1 est r√©trocompatible: si vous prenez le fichier client ex√©cutable compil√© pour v1.1, les deux appels utiliseront toujours <code>Foo(object)</code> .  Mais, en cas de recompilation, le deuxi√®me appel (et seulement le second) basculera pour fonctionner avec la m√©thode g√©n√©ralis√©e.  Les deux m√©thodes s'appliquent aux deux appels. <br><br>  Au premier appel, l'inf√©rence de type montrera que <code>T</code> est un <code>object</code> , donc la conversion de l'argument en type de param√®tre dans les deux cas sera r√©duite en <code>object</code> dans <code>object</code> .  Super.  Le compilateur appliquera la r√®gle selon laquelle les m√©thodes non g√©n√©riques sont toujours pr√©f√©rables aux m√©thodes g√©n√©riques. <br><br>  Lors du deuxi√®me appel, l'inf√©rence de type montrera que <code>T</code> sera toujours une <code>string</code> , donc lors de la conversion d'un argument en un param√®tre de type, nous obtenons une <code>string</code> en <code>object</code> pour la m√©thode d'origine ou une <code>string</code> en <code>string</code> pour la m√©thode g√©n√©ralis√©e.  La deuxi√®me transformation est ¬´meilleure¬ª, c'est pourquoi la deuxi√®me m√©thode est choisie. <br><br>  Si les deux m√©thodes fonctionnent de la m√™me mani√®re, tr√®s bien.  Sinon, vous casserez la compatibilit√© d'une mani√®re tr√®s non √©vidente. <br><br>  <b>H√©ritage et typage dynamique</b> <br><br>  D√©sol√©, je suis d√©j√† essouffl√©.  L'h√©ritage et le typage dynamique lors de la r√©solution des surcharges peuvent se manifester de la mani√®re la plus ¬´cool¬ª et myst√©rieuse. <br>  Si nous ajoutons une telle m√©thode √† un niveau de la hi√©rarchie d'h√©ritage qui surchargera la m√©thode de la classe de base, alors la nouvelle m√©thode sera trait√©e en premier et sera pr√©f√©r√©e √† la m√©thode de la classe de base, m√™me si la m√©thode de la classe de base est plus pr√©cise lors de la conversion d'un argument en param√®tre de type.  Il y a assez d'espace pour tout m√©langer. <br><br>  Il en va de m√™me pour la frappe dynamique (dans le code client);  dans une certaine mesure, la situation devient impr√©visible.  Vous avez d√©j√† s√©rieusement sacrifi√© la s√©curit√© lors de la compilation ... alors ne soyez pas surpris si quelque chose se casse. <br><br>  <b>R√©sum√©</b> <br><br>  J'ai essay√© de rendre les exemples de cet article assez simples.  Tout devient tr√®s compliqu√©, et tr√®s rapidement, lorsque vous avez beaucoup de param√®tres optionnels.  Le versioning est une affaire compliqu√©e, ma t√™te s'en gonfle. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr414223/">https://habr.com/ru/post/fr414223/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr414213/index.html">Un, deux, trois! Chatbot de Google Sheets utilisant l'exemple d'un jeu PvP pour Alice</a></li>
<li><a href="../fr414215/index.html">Blocs personnalis√©s dans les puces (Silicon IP): comment cela fonctionne</a></li>
<li><a href="../fr414217/index.html">Smartphones locaux Vertex: premiers en qualit√©, premiers en puces, premiers en design</a></li>
<li><a href="../fr414219/index.html">L'exp√©rience de l'utilisation de l'√©nergie solaire dans la r√©gion de Moscou: pour, contre et qui en a besoin</a></li>
<li><a href="../fr414221/index.html">Analyser et travailler avec Codable dans Swift 4</a></li>
<li><a href="../fr414225/index.html">Cr√©ation de votre propre r√©seau d'appareils faits maison bas√©s sur Arduino (partie 1)</a></li>
<li><a href="../fr414227/index.html">Une nouvelle √©tude des indicateurs Telegram apr√®s blocage: les abonn√©s augmentent, la couverture diminue</a></li>
<li><a href="../fr414229/index.html">Analyse de diff√©rentes m√©thodes de formation informatique</a></li>
<li><a href="../fr414231/index.html">Comment j'ai fait un ordinateur compl√®tement silencieux</a></li>
<li><a href="../fr414233/index.html">1. Bas√© sur Meyers ¬´c ++ efficace et moderne¬ª - inf√©rence de type de mod√®le</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>