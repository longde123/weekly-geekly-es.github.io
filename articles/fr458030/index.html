<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🖕🏼 💯 👨🏼‍🏭 JavaScript fonctionnel: cinq façons de trouver la moyenne arithmétique des éléments d'un tableau et la méthode .reduce () 💿 🃏 🌘</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Les méthodes d'itération des tableaux sont similaires aux «médicaments de départ» (bien sûr, ce ne sont pas des médicaments; et je ne dis pas que les ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>JavaScript fonctionnel: cinq façons de trouver la moyenne arithmétique des éléments d'un tableau et la méthode .reduce ()</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/458030/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Les méthodes d'itération des tableaux sont</a> similaires aux «médicaments de départ» (bien sûr, ce ne sont pas des médicaments; et je ne dis pas que les médicaments sont bons; ils ne sont qu'une figure de style).  À cause d'eux, beaucoup de «s'asseoir» sur la programmation fonctionnelle.  Le fait est qu'ils sont incroyablement pratiques.  De plus, la plupart de ces méthodes sont très faciles à comprendre.  Des méthodes comme <code>.map()</code> et <code>.filter()</code> n'acceptent qu'un seul argument de rappel et vous permettent de résoudre des problèmes simples.  Mais il y a un sentiment que la méthode <code>.reduce()</code> cause des difficultés à beaucoup.  Le comprendre est un peu plus difficile. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/zd/ig/jp/zdigjpelbgmyf4qdprvkrxo5bu4.png"></a> <br><a name="habracut"></a><br>  J'ai déjà <code>.reduce()</code> pourquoi je pense que <code>.reduce()</code> crée beaucoup de problèmes.  Cela est dû en partie au fait que de nombreux manuels démontrent l'utilisation de <code>.reduce()</code> uniquement lors de la gestion des nombres.  Par conséquent, j'ai écrit combien de tâches qui n'impliquent pas d'opérations arithmétiques peuvent être résolues en utilisant <code>.reduce()</code> .  Mais que faire si vous avez absolument besoin de travailler avec des chiffres? <br><br>  Une utilisation typique de <code>.reduce()</code> ressemble à un calcul de la moyenne arithmétique des éléments d'un tableau.  À première vue, il semble qu'il n'y ait rien de spécial dans cette tâche.  Mais elle n'est pas si simple.  Le fait est qu'avant de calculer la moyenne, vous devez trouver les indicateurs suivants: <br><br><ol><li>  Le montant total des valeurs des éléments du tableau. </li><li>  La longueur du tableau. </li></ol><br>  Découvrir tout cela est assez simple.  Et le calcul des valeurs moyennes pour les tableaux numériques n'est pas non plus une opération difficile.  Voici un exemple élémentaire: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">average</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">nums</span></span></span><span class="hljs-function">) </span></span>{    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> nums.reduce(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) =&gt;</span></span> (a + b)) / nums.length; }</code> </pre> <br>  Comme vous pouvez le voir, il n'y a pas d'incompréhensions particulières ici.  Mais la tâche devient plus difficile si vous devez travailler avec des structures de données plus complexes.  Et si nous avons un tableau d'objets?  Que faire si certains objets de ce tableau doivent être filtrés?  Que faire si vous devez extraire certaines valeurs numériques d'objets?  Dans cette situation, le calcul de la valeur moyenne des éléments du tableau est déjà une tâche un peu plus compliquée. <br><br>  Pour résoudre ce problème, nous allons résoudre le problème de formation (il est basé sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cette</a> tâche avec FreeCodeCamp).  Nous allons le résoudre de cinq manières différentes.  Chacun d'eux a ses propres avantages et inconvénients.  Une analyse de ces cinq approches pour résoudre ce problème montrera à quel point JavaScript peut être flexible.  Et j'espère que l'analyse des solutions vous donnera matière à réflexion sur la manière d'utiliser <code>.reduce()</code> dans des projets réels. <br><br><h2>  <font color="#3AC1EF">Aperçu des tâches</font> </h2><br>  Supposons que nous ayons un tableau d'objets qui décrivent des expressions d'argot victorien.  Vous devez filtrer les expressions qui ne se trouvent pas dans Google Livres (la propriété <code>found</code> des objets correspondants est <code>false</code> ) et trouver une note moyenne pour la popularité des expressions.  Voici à quoi pourraient ressembler ces données (prises à <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">partir d'ici</a> ): <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> victorianSlang = [           term: <span class="hljs-string"><span class="hljs-string">'doing the bear'</span></span>,        <span class="hljs-attr"><span class="hljs-attr">found</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>,        <span class="hljs-attr"><span class="hljs-attr">popularity</span></span>: <span class="hljs-number"><span class="hljs-number">108</span></span>,    },           <span class="hljs-attr"><span class="hljs-attr">term</span></span>: <span class="hljs-string"><span class="hljs-string">'katterzem'</span></span>,        <span class="hljs-attr"><span class="hljs-attr">found</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>,        <span class="hljs-attr"><span class="hljs-attr">popularity</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span>,    },           <span class="hljs-attr"><span class="hljs-attr">term</span></span>: <span class="hljs-string"><span class="hljs-string">'bone shaker'</span></span>,        <span class="hljs-attr"><span class="hljs-attr">found</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>,        <span class="hljs-attr"><span class="hljs-attr">popularity</span></span>: <span class="hljs-number"><span class="hljs-number">609</span></span>,    },           <span class="hljs-attr"><span class="hljs-attr">term</span></span>: <span class="hljs-string"><span class="hljs-string">'smothering a parrot'</span></span>,        <span class="hljs-attr"><span class="hljs-attr">found</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>,        <span class="hljs-attr"><span class="hljs-attr">popularity</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span>,    },           <span class="hljs-attr"><span class="hljs-attr">term</span></span>: <span class="hljs-string"><span class="hljs-string">'damfino'</span></span>,        <span class="hljs-attr"><span class="hljs-attr">found</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>,        <span class="hljs-attr"><span class="hljs-attr">popularity</span></span>: <span class="hljs-number"><span class="hljs-number">232</span></span>,    },           <span class="hljs-attr"><span class="hljs-attr">term</span></span>: <span class="hljs-string"><span class="hljs-string">'rain napper'</span></span>,        <span class="hljs-attr"><span class="hljs-attr">found</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>,        <span class="hljs-attr"><span class="hljs-attr">popularity</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span>,    },           <span class="hljs-attr"><span class="hljs-attr">term</span></span>: <span class="hljs-string"><span class="hljs-string">'donkey'</span></span>s breakfast<span class="hljs-string"><span class="hljs-string">',        found: true,        popularity: 787,    },           term: '</span></span>rational costume<span class="hljs-string"><span class="hljs-string">',        found: true,        popularity: 513,    },           term: '</span></span>mind the grease<span class="hljs-string"><span class="hljs-string">',        found: true,        popularity: 154,    }, ];</span></span></code> </pre> <br>  Considérez 5 façons de trouver la valeur moyenne de l'évaluation de la popularité des expressions de ce tableau. <br><br><h2>  <font color="#3AC1EF">1. Résoudre un problème sans utiliser .reduce () (boucle impérative)</font> </h2><br>  Dans notre première approche pour résoudre le problème, la méthode <code>.reduce()</code> ne sera pas utilisée.  Si vous n'avez jamais rencontré de méthodes d'itération de tableaux auparavant, j'espère que l'analyse de cet exemple clarifiera un peu la situation pour vous. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> popularitySum = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> itemsFound = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> len = victorianSlang.length; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> item = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; len; i++) {    item = victorianSlang[i];    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (item.found) {        popularitySum = item.popularity + popularitySum;        itemsFound = itemsFound + <span class="hljs-number"><span class="hljs-number">1</span></span>;   } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> averagePopularity = popularitySum / itemsFound; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"Average popularity:"</span></span>, averagePopularity);</code> </pre> <br>  Si vous connaissez JavaScript, vous comprendrez facilement cet exemple.  En fait, ce qui suit se produit ici: <br><br><ol><li>  Nous initialisons les variables <code>itemsFound</code> et <code>itemsFound</code> .  La première variable, <code>popularitySum</code> , stocke la note globale de popularité des expressions.  Et la deuxième variable, <code>itemsFound</code> , (c'est une surprise) stocke le nombre d'expressions trouvées. </li><li>  Ensuite, nous initialisons la constante <code>len</code> et l' <code>item</code> variable, qui nous sont utiles lors de la traversée du tableau. </li><li>  Dans une boucle <code>for</code> , le compteur <code>i</code> incrémenté jusqu'à ce que sa valeur atteigne la valeur d'index du dernier élément du tableau. </li><li>  À l'intérieur de la boucle, nous prenons l'élément du tableau que nous voulons explorer.  Nous accédons à l'élément en utilisant la construction <code>victorianSlang[i]</code> . </li><li>  Nous découvrons ensuite si cette expression se retrouve dans la collection de livres. </li><li>  Si une expression apparaît dans les livres, nous prenons la valeur de sa cote de popularité et ajoutons à la valeur de la variable <code>popularitySum</code> . </li><li>  Dans le même temps, nous <code>itemsFound</code> également le compteur des expressions trouvées - <code>itemsFound</code> . </li><li>  Et enfin, nous trouvons la moyenne en divisant la <code>popularitySum</code> par les <code>itemsFound</code> . </li></ol><br>  Nous avons donc fait face à la tâche.  Peut-être que notre décision n'était pas particulièrement belle, mais elle fait son travail.  L'utilisation de méthodes pour parcourir les tableaux le rendra un peu plus propre.  Voyons si nous réussissons, et la vérité est, pour «nettoyer» cette décision. <br><br><h2>  <font color="#3AC1EF">2. Solution simple n ° 1: .filter (), .map () et recherche du montant à l'aide de .reduce ()</font> </h2><br>  Disons, avant la première tentative d'utiliser les méthodes de tableaux pour résoudre le problème, nous le divisons en petites parties.  À savoir, voici ce que nous devons faire: <br><br><ol><li>  Sélectionnez des objets représentant des expressions qui se trouvent dans la collection Google Livres.  Ici, vous pouvez utiliser la méthode <code>.filter()</code> . </li><li>  Extraire des objets l'évaluation de la popularité des expressions.  Pour résoudre cette sous-tâche, la méthode <code>.map()</code> convient. </li><li>  Calculez la somme des notes.  Ici, nous pouvons recourir à l'aide de notre vieil ami <code>.reduce()</code> . </li><li>  Et enfin, trouvez la valeur moyenne des estimations. </li></ol><br>  Voici à quoi cela ressemble dans le code: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   // ---------------------------------------------------------------------------- function isFound(item) {    return item.found; }; function getPopularity(item) {    return item.popularity; } function addScores(runningTotal, popularity) {    return runningTotal + popularity; } //  // ---------------------------------------------------------------------------- //  ,      . const foundSlangTerms = victorianSlang.filter(isFound); //   ,   . const popularityScores = foundSlangTerms.map(getPopularity); //     .    ,    //   ,  reduce     ,  0. const scoresTotal = popularityScores.reduce(addScores, 0); //       . const averagePopularity = scoresTotal / popularityScores.length; console.log("Average popularity:", averagePopularity);</span></span></code> </pre> <br>  <code>addScore</code> œil à la fonction <code>addScore</code> et à la ligne où <code>.reduce()</code> appelé.  Notez que <code>addScore</code> accepte deux paramètres.  Le premier, <code>runningTotal</code> , est connu sous le nom de batterie.  Il stocke la somme des valeurs.  Sa valeur change à chaque fois que nous parcourons le tableau et exécutons l' <code>return</code> .  Le deuxième paramètre, la <code>popularity</code> , est un élément distinct du tableau que nous traitons.  Au tout début de l' <code>addScore</code> sur le tableau, l' <code>return</code> <code>addScore</code> dans <code>addScore</code> n'a jamais été exécutée.  Cela signifie que <code>runningTotal</code> pas encore été défini automatiquement.  Par conséquent, en appelant <code>.reduce()</code> , nous transmettons à cette méthode la valeur qui doit être écrite dans <code>runningTotal</code> au tout début.  Il s'agit du deuxième paramètre passé à <code>.reduce()</code> . <br><br>  Nous avons donc appliqué les méthodes d'itération des tableaux pour résoudre le problème.  La nouvelle version de la solution s'est avérée beaucoup plus propre que la précédente.  En d'autres termes, la décision s'est avérée plus déclarative.  Nous ne disons pas à JavaScript exactement comment exécuter la boucle; nous ne suivons pas les index des éléments du tableau.  Au lieu de cela, nous déclarons des fonctions d'assistance simples de petite taille et les combinons.  Tout le travail acharné est fait pour nous par les méthodes de tableau <code>.filter()</code> , <code>.map()</code> et <code>.reduce()</code> .  Cette approche pour résoudre de tels problèmes est plus expressive.  Ces méthodes de tableau sont beaucoup plus complètes que la boucle ne peut le faire, elles nous renseignent sur l'intention énoncée dans le code. <br><br><h2>  <font color="#3AC1EF">3. Solution facile n ° 2: utilisation de plusieurs batteries</font> </h2><br>  Dans la version précédente de la solution, nous avons créé tout un tas de variables intermédiaires.  Par exemple, <code>foundSlangTerms</code> et <code>popularityScores</code> .  Dans notre cas, une telle solution est tout à fait acceptable.  Mais que se passe-t-il si nous nous fixons un objectif plus complexe concernant la conception de code?  Ce serait bien si nous pouvions utiliser le modèle de conception d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">interface fluide</a> dans le programme.  Avec cette approche, nous serions en mesure de chaîner les appels de toutes les fonctions et de pouvoir nous passer de variables intermédiaires.  Cependant, un problème nous attend ici.  Notez que nous devons obtenir la valeur de <code>popularityScores.length</code> .  Si nous allons tout enchaîner, nous avons besoin d'une autre façon de trouver le nombre d'éléments dans le tableau.  Le nombre d'éléments dans le tableau joue le rôle d'un diviseur dans le calcul de la valeur moyenne.  Voyons si nous pouvons changer l'approche pour résoudre le problème afin que tout puisse être fait en combinant les appels de méthode dans une chaîne.  Nous le ferons en suivant deux valeurs lors de l'itération sur les éléments du tableau, c'est-à-dire en utilisant la «double batterie». <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   // --------------------------------------------------------------------------------- function isFound(item) {    return item.found; }; function getPopularity(item) {    return item.popularity; } //    ,  return,   . function addScores({totalPopularity, itemCount}, popularity) {    return {        totalPopularity: totalPopularity + popularity,        itemCount:    itemCount + 1,    }; } //  // --------------------------------------------------------------------------------- const initialInfo  = {totalPopularity: 0, itemCount: 0}; const popularityInfo = victorianSlang.filter(isFound)    .map(getPopularity)    .reduce(addScores, initialInfo); //       . const {totalPopularity, itemCount} = popularityInfo; const averagePopularity = totalPopularity / itemCount; console.log("Average popularity:", averagePopularity);</span></span></code> </pre> <br>  Ici, pour travailler avec deux valeurs, nous avons utilisé l'objet dans la fonction de réduction.  À chaque passage dans le tableau effectué à l'aide d' <code>addScrores</code> , nous mettons à jour la valeur totale de la cote de popularité et le nombre d'éléments.  Il est important de noter que ces deux valeurs sont représentées comme un seul objet.  Avec cette approche, nous pouvons «tromper» le système et stocker deux entités dans la même valeur de retour. <br><br>  La fonction <code>addScrores</code> être un peu plus compliquée que la fonction du même nom dans l'exemple précédent.  Mais maintenant, il s'avère que nous pouvons utiliser une seule chaîne d'appels de méthode pour effectuer toutes les opérations avec le tableau.  À la suite du traitement du tableau, nous obtenons l'objet popularInfo, qui stocke tout ce dont vous avez besoin pour trouver la moyenne.  Cela rend la chaîne d'appel nette et simple. <br><br>  Si vous ressentez le désir d'améliorer ce code, vous pouvez l'expérimenter.  Par exemple - vous pouvez le refaire afin de vous débarrasser de nombreuses variables intermédiaires.  Vous pouvez même essayer de mettre ce code sur une seule ligne. <br><br><h2>  <font color="#3AC1EF">4. Composition des fonctions sans utiliser la notation par points</font> </h2><br>  Si vous êtes nouveau dans la programmation fonctionnelle, ou s'il vous semble que la programmation fonctionnelle est trop compliquée, vous pouvez ignorer cette section.  Son analyse vous sera utile si vous êtes déjà familier avec <code>curry()</code> et <code>compose()</code> .  Si vous souhaitez approfondir ce sujet, jetez un œil à <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ce</a> matériel sur la programmation fonctionnelle en JavaScript et, en particulier, à la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">troisième</a> partie de la série dans laquelle il est inclus. <br><br>  Nous sommes des programmeurs qui adoptent une approche fonctionnelle.  Cela signifie que nous nous efforçons de créer des fonctions complexes à partir d'autres fonctions - petites et simples.  Jusqu'à présent, au cours de l'examen de diverses options pour résoudre le problème, nous avons réduit le nombre de variables intermédiaires.  En conséquence, le code de la solution est devenu plus simple et plus facile.  Mais que se passe-t-il si cette idée est poussée à l'extrême?  Et si vous essayez de vous débarrasser de toutes les variables intermédiaires?  Et même essayer de s'éloigner de certains paramètres? <br><br>  Vous pouvez créer une fonction pour calculer la moyenne en utilisant la fonction <code>compose()</code> seule, sans utiliser de variables.  Nous appelons cela «programmation sans utiliser de notation à grain fin» ou «programmation implicite».  Pour écrire de tels programmes, vous aurez besoin de nombreuses fonctions auxiliaires. <br><br>  Parfois, un tel code choque les gens.  Cela est dû au fait qu'une telle approche est très différente de celle généralement acceptée.  Mais j'ai découvert que l'écriture de code dans le style de la programmation implicite est l'un des moyens les plus rapides pour comprendre l'essence de la programmation fonctionnelle.  Par conséquent, je peux vous conseiller d'essayer cette technique dans un projet personnel.  Mais je veux dire que vous ne devriez peut-être pas écrire dans le style de programmation implicite le code que les autres doivent lire. <br><br>  Revenons donc à notre tâche de construire un système de calcul des moyennes.  Par souci d'économie d'espace, nous allons passer ici à l'utilisation des fonctions flèches.  En règle générale, il est préférable d'utiliser des fonctions nommées.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Voici un</a> bon article sur ce sujet.  Cela vous permet d'obtenir de meilleurs résultats de trace de pile en cas d'erreurs. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   // ---------------------------------------------------------------------------- const filter = p =&gt; a =&gt; a.filter(p); const map   = f =&gt; a =&gt; a.map(f); const prop  = k =&gt; x =&gt; x[k]; const reduce = r =&gt; i =&gt; a =&gt; a.reduce(r, i); const compose = (...fns) =&gt; (arg) =&gt; fns.reduceRight((arg, fn) =&gt; fn(arg), arg); //  -   "blackbird combinator". //     : https://jrsinclair.com/articles/2019/compose-js-functions-multiple-parameters/ const B1 = f =&gt; g =&gt; h =&gt; x =&gt; f(g(x))(h(x)); //  // ---------------------------------------------------------------------------- //   sum,    . const sum = reduce((a, i) =&gt; a + i)(0); //     . const length = a =&gt; a.length; //       . const div = a =&gt; b =&gt; a / b; //   compose()        . //    compose()     . const calcPopularity = compose(    B1(div)(sum)(length),    map(prop('popularity')),    filter(prop('found')), ); const averagePopularity = calcPopularity(victorianSlang); console.log("Average popularity:", averagePopularity);</span></span></code> </pre> <br>  Si tout ce code vous semble complètement insensé, ne vous en faites pas.  Je l'ai inclus ici comme un exercice intellectuel, et non pour vous déranger. <br><br>  Dans ce cas, le travail principal est dans la fonction <code>compose()</code> .  Si vous lisez son contenu de bas en haut, il s'avère que les calculs commencent par filtrer le tableau par la propriété de ses éléments <code>found</code> .  Ensuite, nous récupérons la propriété de l'élément de <code>popularity</code> aide de <code>map()</code> .  Après cela, nous utilisons le soi-disant « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">combinateur merle</a> ».  Cette entité est représentée comme une fonction <code>B1</code> , qui est utilisée pour effectuer deux passes de calculs sur un ensemble de données d'entrée.  Pour mieux comprendre cela, jetez un œil à ces exemples: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   ,  , : const avg1 = B1(div)(sum)(length); const avg2 = arr =&gt; div(sum(arr))(length(arr)); const avg3 = arr =&gt; ( sum(arr) / length(arr) ); const avg4 = arr =&gt; arr.reduce((a, x) =&gt; a + x, 0) / arr.length;</span></span></code> </pre> <br>  Encore une fois, si vous ne comprenez plus rien - ne vous inquiétez pas.  Ceci est juste une démonstration que JavaScript peut être écrit de différentes manières.  De ces caractéristiques, c'est la beauté de ce langage. <br><br><h2>  <font color="#3AC1EF">5. Résoudre le problème en un seul passage avec le calcul de la valeur moyenne cumulée</font> </h2><br>  Toutes les constructions de logiciels ci-dessus font un bon travail de résolution de notre problème (y compris le cycle impératif).  Ceux qui utilisent la méthode <code>.reduce()</code> ont quelque chose en commun.  Ils sont basés sur la division du problème en petits fragments.  Ces fragments sont ensuite assemblés de différentes manières.  En analysant ces solutions, vous remarquerez peut-être que nous parcourons le tableau trois fois.  On a l'impression que c'est inefficace.  Ce serait bien s'il y avait un moyen de traiter le tableau et de retourner le résultat en une seule passe.  Cette méthode existe, mais son application nécessitera le recours aux mathématiques. <br><br>  Afin de calculer la valeur moyenne des éléments du tableau en un seul passage, nous avons besoin d'une nouvelle méthode.  Vous devez trouver un moyen de calculer la moyenne en utilisant la moyenne précédemment calculée et la nouvelle valeur.  Nous recherchons cette méthode en utilisant l'algèbre. <br><br>  La valeur moyenne de <code>n</code> nombres peut être trouvée en utilisant cette formule: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ea8/922/a8a/ea8922a8ad59e55aa604bf01c72b55e4.png"></div><br>  Afin de connaître le nombre moyen de <code>n + 1</code> , la même formule fera l'affaire, mais dans une entrée différente: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/77c/ee8/a1f/77cee8a1fe717b88a55b2f2af6f222e2.png"></div><br>  Cette formule est la même que celle-ci: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/651/b3a/0ca/651b3a0caa501b140e23cbce68a96720.png"></div><br>  Et la même chose que celle-ci: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f7b/e1b/da4/f7be1bda4b12343eee3dde51d80f95c0.png"></div><br>  Si vous convertissez cela un peu, vous obtenez ce qui suit: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/038/165/1b5/0381651b520c5136458129c1882a44af.png"></div><br>  Si vous ne voyez pas l'intérêt de tout cela, alors ça va.  Le résultat de toutes ces transformations est qu'à l'aide de la dernière formule, nous pouvons calculer la valeur moyenne au cours d'une seule traversée du tableau.  Pour ce faire, vous devez connaître la valeur de l'élément actuel, la valeur moyenne calculée à l'étape précédente et le nombre d'éléments.  De plus, la plupart des calculs peuvent être effectués dans la fonction réducteur: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//      // ---------------------------------------------------------------------------- function averageScores({avg, n}, slangTermInfo) {    if (!slangTermInfo.found) {        return {avg, n};       return {        avg: (slangTermInfo.popularity + n * avg) / (n + 1),        n:  n + 1,    }; } //  // ---------------------------------------------------------------------------- //       . const initialVals    = {avg: 0, n: 0}; const averagePopularity = victorianSlang.reduce(averageScores, initialVals).avg; console.log("Average popularity:", averagePopularity);</span></span></code> </pre> <br>  Grâce à cette approche, la valeur nécessaire peut être trouvée en contournant le tableau une seule fois.  D'autres approches utilisent une passe pour filtrer le tableau, une autre pour en extraire les données nécessaires et une autre pour trouver la somme des valeurs des éléments.  Ici, tout rentre dans un passage à travers le tableau. <br><br>  Veuillez noter que cela ne rend pas nécessairement les calculs plus efficaces.  Avec cette approche, plus de calculs doivent être effectués.  Lorsque chaque nouvelle valeur arrive, nous effectuons les opérations de multiplication et de division, ce faisant pour maintenir la valeur moyenne actuelle dans l'état actuel.  Dans d'autres solutions à ce problème, nous divisons un numéro en un autre une seule fois - à la fin du programme.  Mais cette approche est beaucoup plus efficace en termes d'utilisation de la mémoire.  Les tableaux intermédiaires ne sont pas utilisés ici, par conséquent, nous devons stocker en mémoire uniquement un objet avec deux valeurs. <br><br>         .        .     ,     .   .  ,   ,      . <br><br><h2> <font color="#3AC1EF"> ?</font> </h2><br>              ?   ,     . ,    -  . , ,      ,       .         ,       .       ,           .          ,      ,       . <br><br> ,  -     ,           .       ,         ?   .      .  —   . <br><br><h2> <font color="#3AC1EF"></font> </h2><br>         : <br><br><ol><li>   <code>.reduce()</code> . </li><li>    <code>.filter()</code>  <code>.map()</code> ,   —  <code>.reduce()</code>       . </li><li>   ,      . </li><li>     . </li><li>         . </li></ol><br>  , -,     ?    —  .      -  —     ,          : <br><br><ol><li>    ,     .      —   . </li><li>    ,    ,    —     . </li><li> , ,        —   ,     . </li></ol><br> <b> !</b>        JavaScript-? <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/a09/9e4/5a8/a099e45a81c9dafd3a3673edd5ea415b.jpg"></a> </div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr458030/">https://habr.com/ru/post/fr458030/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr458014/index.html">Robot FEDOR - formation avec le nouvel équipage de l'ISS et les premières tâches spatiales</a></li>
<li><a href="../fr458018/index.html">composer vs npm: développement multi-modules</a></li>
<li><a href="../fr458020/index.html">Résumé des événements informatiques de juillet</a></li>
<li><a href="../fr458022/index.html">Empreintes digitales à travers des bannières publicitaires? Maintenant, c'est courant</a></li>
<li><a href="../fr458026/index.html">Comparaison des formats de sérialisation</a></li>
<li><a href="../fr458040/index.html">De Moscou à Tomsk. L'histoire d'un mouvement</a></li>
<li><a href="../fr458042/index.html">Comment j'ai organisé une formation en apprentissage automatique à NSU</a></li>
<li><a href="../fr458044/index.html">Sécurité de l'information provinciale - stagnation ou développement?</a></li>
<li><a href="../fr458046/index.html">Gradle Cheat Sheet</a></li>
<li><a href="../fr458048/index.html">La délégation comme outil de gestion</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>