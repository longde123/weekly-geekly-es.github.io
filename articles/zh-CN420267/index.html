<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✋🏽 🥚 💃 游戏0 AD的作者-做得好 🔂 🤚🏼 👼🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="0 AD是由志愿者社区开发的实时历史策略类型的三维游戏。 代码库的大小很小，因此我决定将游戏与大型项目（例如Android和XNU Kernel）分开检查。 因此，摆在我们面前的是一个包含165,000行C ++代码的项目。 让我们看看使用PVS-Studio静态分析器可以发现的有趣之处。 

 0...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>游戏0 AD的作者-做得好</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/420267/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6c5/b41/bfb/6c5b41bfb68b23ef10d61f6ecd1a6665.png" alt="PVS-Studio和0 A.D."></div><br>  0 AD是由志愿者社区开发的实时历史策略类型的三维游戏。 代码库的大小很小，因此我决定将游戏与大型项目（例如Android和XNU Kernel）分开检查。 因此，摆在我们面前的是一个包含165,000行C ++代码的项目。 让我们看看使用PVS-Studio静态分析器可以发现的有趣之处。 <br><a name="habracut"></a><br><h2>  0公元 </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">AD 0</a> （A.D.）是一款实时的历史策略类型的免费三维游戏，由一个志愿者社区（主要开发者联合在Wildfire游戏团队中）开发。 该游戏允许您控制存在于公元前500年的文明。  e。—公元前1年。  e。 截至2018年夏季，该项目为Alpha版本。  [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">描述</a>取自维基百科]。 <br><br> 为什么正好是0 AD？ <br><br> 我请<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Egor Bredikhin</a> （ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">EgorBredikhin</a> ）的同事选择并检查了一些小型的开放项目，我可以用它完成其他任务。 他给我发送了一个0 AD项目的日志，问题是：“为什么要这个项目？”  -有一个答案：“是的，我刚刚玩了这个游戏，这是一个很好的实时策略。” 好的，那将是0 AD :)。 <br><br><h2> 误差密度 </h2><br> 我要赞扬0 AD的作者的C ++代码的高质量。 做得好，您很少会遇到如此低的错误密度。 当然，这些并非全部错误，而是可以使用PVS-Studio检测到的那些错误。 就像我说的那样，尽管PVS-Studio并没有发现所有错误，但是我们可以放心地讨论错误的密度与整体代码质量之间的关系。 <br><br> 一些数字。 非空代码行的总数为231270。其中，注释占28.7％。 总共有165,000行纯C ++代码。 <br><br> 分析器发出的消息数量很少，查看了所有消息后，我写出了19个错误。 我将在本文后面考虑所有这些错误。 可能我错过了一些东西，认为该错误是无害的草率代码。 但是，通常，这不会改变图片。 <br><br> 因此，我在165,000行代码中发现了19个错误。 我们计算误差密度：19 * 1000/165000 = 0.115。 <br><br> 为简单起见，我们四舍五入并假设PVS-Studio分析器在游戏代码中每1000行代码检测到0.1个错误。 <br><br> 好结果！ 为了进行比较，在最近<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">有关Android的文章中，</a>我计算出每1000行代码至少检测到0.25个错误。 实际上，错误的密度甚至更大，我只是没有发现仔细分析整个报告的能力。 <br><br> 或以EFL核心库为例，我仔细<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">研究</a>并计算了缺陷数。 在其中，PVS-Studio每1000行代码检测到0.71个错误。 <br><br> 因此，0 AD的作者是好伙伴，但是，为了公平起见，应注意的是，用C ++编写的少量代码对他们有帮助。 不幸的是，项目越大，其复杂性增长得越快，并且错误密度非线性地增加（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">更多</a> ）。 <br><br><h2> 失误 </h2><br> 现在，让我们看一下我在游戏中发现的19个错误。 为了分析该项目，我使用了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PVS-Studio</a>版本6.24。 我建议您尝试下载演示版本并检查您正在处理的项目。 <br><br>  <b>注意事项</b> 我们将PVS-Studio定位为B2B解决方案。 对于小型项目和个人开发人员，我们有一个免费的许可证选项：“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">如何免费使用PVS-Studio</a> ”。 <br><br>  <b>错误N1</b> <br><br> 让我们从一个复杂的错误开始。 实际上，它并不复杂，但是您必须熟悉相当大的一段代码。 <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> WaterManager::CreateWaveMeshes() { .... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nbNeighb = <span class="hljs-number"><span class="hljs-number">0</span></span>; .... <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> found = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; nbNeighb = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> p = <span class="hljs-number"><span class="hljs-number">0</span></span>; p &lt; <span class="hljs-number"><span class="hljs-number">8</span></span>; ++p) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (CoastalPointsSet.count(xx+around[p][<span class="hljs-number"><span class="hljs-number">0</span></span>] + (yy + around[p][<span class="hljs-number"><span class="hljs-number">1</span></span>])*SideSize)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nbNeighb &gt;= <span class="hljs-number"><span class="hljs-number">2</span></span>) { CoastalPointsSet.erase(xx + yy*SideSize); <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } ++nbNeighb; <span class="hljs-comment"><span class="hljs-comment">// We've found a new point around us. // Move there xx = xx + around[p][0]; yy = yy + around[p][1]; indexx = xx + yy*SideSize; if (i == 0) Chain.push_back(CoastalPoint(indexx,CVector2D(xx*2,yy*2))); else Chain.push_front(CoastalPoint(indexx,CVector2D(xx*2,yy*2))); CoastalPointsSet.erase(xx + yy*SideSize); found = true; break; } } if (!found) endedChain = true; .... }</span></span></code> </pre> <br>  PVS-Studio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">警告</a> ： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V547</a> CWE-570表达式'nbNeighb&gt; = 2'始终为false。 水管理器.cpp 581 <br><br> 乍一看，分析器消息似乎很奇怪。 为什么条件<i>nbNeighb&gt; = 2</i>始终为假？ 实际上，在循环的主体中，变量<i>nbNeighb</i>的增量是！ <br><br> 看下面，您将看到一个<i>break</i>语句，该语句中断循环的执行。 因此，如果增加变量<i>nbNeighb</i> ，则循环将停止。 因此，变量<i>nbNeighb</i>的值将永远不会达到大于1的值。 <br><br> 该代码显然包含某种逻辑错误。 <br><br>  <b>错误N2</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CmpRallyPointRenderer::MergeVisibilitySegments( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">deque</span></span>&lt;SVisibilitySegment&gt;&amp; segments) { .... segments.erase(segments.end()); .... }</code> </pre> <br>  PVS-Studio警告： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V783</a> CWE-119可能会取消引用无效的迭代器“ segments.end（）”。  CCmpRallyPointRenderer.cpp 1290 <br><br> 非常非常奇怪的代码。 也许程序员希望从容器中删除最后一个元素。 在这种情况下，代码应如下所示： <br><br><pre> <code class="cpp hljs">segments.erase(segments.end() - <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br> 虽然，这样写起来会更容易： <br><br><pre> <code class="cpp hljs">segments.pop_back();</code> </pre> <br> 老实说，我目前还不太清楚应该在这里写什么。 <br><br>  <b>错误N3，N4</b> <br><br> 我决定一起考虑两个错误，因为它们与资源泄漏有关，并且需要首先显示<i>WARN_RETURN</i>宏<i>是</i>什么。 <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> WARN_RETURN(status)\ do\ {\ DEBUG_WARN_ERR(status);\ return status;\ }\ while(0)</span></span></code> </pre> <br> 因此，如您所见， <i>WARN_RETURN</i>宏使函数退出主体。 现在，让我们看一下使用此宏的不正确方法。 <br><br> 第一个片段。 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Status </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sys_generate_random_bytes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(u8* buf, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> count)</span></span></span><span class="hljs-function"> </span></span>{ FILE* f = fopen(<span class="hljs-string"><span class="hljs-string">"/dev/urandom"</span></span>, <span class="hljs-string"><span class="hljs-string">"rb"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!f) WARN_RETURN(ERR::FAIL); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (count) { <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> numread = fread(buf, <span class="hljs-number"><span class="hljs-number">1</span></span>, count, f); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (numread == <span class="hljs-number"><span class="hljs-number">0</span></span>) WARN_RETURN(ERR::FAIL); buf += numread; count -= numread; } fclose(f); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> INFO::OK; }</code> </pre> <br>  PVS-Studio警告： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V773</a> CWE-401在不释放'f'手柄的情况下退出了该功能。 资源泄漏是可能的。  unix.cpp 332 <br><br> 如果<i>fread</i>函数无法读取数据，则<i>sys_generate_random_bytes</i>函数将退出而不释放文件描述符。 实际上，这几乎是不可能的。 令人怀疑的是，您将无法从“ / dev / urandom”读取数据。 但是，代码很草率。 <br><br> 第二个片段。 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Status </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sys_cursor_create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... sys_cursor_impl* impl = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> sys_cursor_impl; impl-&gt;image = image; impl-&gt;cursor = XcursorImageLoadCursor(wminfo.info.x11.display, image); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(impl-&gt;cursor == None) WARN_RETURN(ERR::FAIL); *cursor = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;sys_cursor&gt;(impl); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> INFO::OK; }</code> </pre> <br>  PVS-Studio警告：V773 CWE-401在不释放“ impl”指针的情况下退出了该功能。 可能发生内存泄漏。 第421章 <br><br> 如果游标无法加载，则会发生内存泄漏。 <br><br>  <b>错误N5</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Status </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LoadHeightmapImageOs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;u8&gt; fileData = <span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;u8&gt;(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> u8[fileSize]); .... }</code> </pre> <br>  PVS-Studio警告： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V554</a> CWE-762错误使用了shared_ptr。 分配给'new []'的内存将使用'delete'清除。  MapIO.cpp 54 <br><br> 正确的选项： <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;u8[]&gt; fileData = <span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;u8&gt;(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> u8[fileSize]);</code> </pre> <br>  <b>错误N6</b> <br><br><pre> <code class="cpp hljs">FUTrackedPtr(ObjectClass* _ptr = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) : ptr(_ptr) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ptr != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) FUTracker::TrackObject((FUTrackable*) ptr); ptr = ptr; }</code> </pre> <br>  PVS-Studio警告： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V570</a>为其自身分配了“ ptr”变量。  FUTracker.h 122 <br><br>  <b>错误N7，N8</b> <br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::wstring TraceEntry::EncodeAsText() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">wchar_t</span></span> action = (<span class="hljs-keyword"><span class="hljs-keyword">wchar_t</span></span>)m_action; <span class="hljs-keyword"><span class="hljs-keyword">wchar_t</span></span> buf[<span class="hljs-number"><span class="hljs-number">1000</span></span>]; swprintf_s(buf, ARRAY_SIZE(buf), <span class="hljs-string"><span class="hljs-string">L"%#010f: %c \"%ls\" %lu\n"</span></span>, m_timestamp, action, m_pathname.<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>().c_str(), (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)m_size); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> buf; }</code> </pre> <br>  PVS-Studio警告： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V576</a> CWE-628格式错误。 考虑检查“ swprintf_s”函数的第五个实际参数。  char类型参数是预期的。  trace.cpp 93 <br><br> 在这里，我们遇到了Visual C ++中<i>swprintf</i>函数的替代实现的困惑和模糊的历史。 我不会<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">重述</a> ，但是请参考<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V576</a>诊断程序的文档（请参阅“宽线”部分）。 <br><br> 在这种情况下，很可能该代码在Windows的Visual C ++中编译时将正确运行，而在Linux或macOS上进行编译时将不正确。 <br><br> 类似错误：V576 CWE-628格式错误。 考虑检查“ swprintf_s”函数的第四个实际参数。  char类型参数是预期的。  vfs_tree.cpp 211 <br><br>  <b>错误N9，N10，N11</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">经典版</a> 首先，使用指针，然后才检查指针。 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TEST_CAT2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* dst, ....)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">strcpy</span></span>(dst, dst_val); <span class="hljs-comment"><span class="hljs-comment">// &lt;= int ret = strcat_s(dst, max_dst_chars, src); TS_ASSERT_EQUALS(ret, expected_ret); if(dst != 0) // &lt;= TS_ASSERT(!strcmp(dst, expected_dst)); }</span></span></code> </pre> <br>  PVS-Studio警告： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V595</a> CWE-476在针对nullptr进行验证之前，已使用了'dst'指针。 检查行：140，143。test_secure_crt.h 140 <br><br> 我认为该错误不需要解释。 类似警告： <br><br><ul><li>  V595 CWE-476在针对nullptr对其进行验证之前，已使用了'dst'指针。 检查行：150，153。test_secure_crt.h 150 </li><li>  V595 CWE-476在针对nullptr对其进行验证之前，已使用了'dst'指针。 检查行：314、317。test_secure_crt.h 314 </li></ul><br>  <b>错误N12</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> tbool; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> MikkTSpace::setTSpace(...., <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> tbool bIsOrientationPreserving, ....) { .... m_NewVertices.push_back(bIsOrientationPreserving &gt; <span class="hljs-number"><span class="hljs-number">0.5</span></span> ? <span class="hljs-number"><span class="hljs-number">1.0f</span></span> : (<span class="hljs-number"><span class="hljs-number">-1.0f</span></span>)); .... }</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V674</a> CWE-682将'double'类型的'0.5'文字与'int'类型的值进行比较。 考虑检查“ bIsOrientationPreserving&gt; 0.5”表达式。 第137章 <br><br> 比较类型为<i>int</i>的变量和常量为0.5毫无意义。 此外，就含义而言，这通常是布尔类型的变量，这意味着将其与0.5进行比较看起来很奇怪。 假定此处应使用<i>bssOrientationPreserving</i>代替另一个变量。 <br><br>  <b>错误N13</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> Status </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReplaceFile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> VfsPath&amp; pathname, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">shared_ptr</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;u8&gt;&amp; fileContents, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> </span></span>{ ScopedLock s; VfsDirectory* directory; VfsFile* file; Status st; st = vfs_Lookup(pathname, &amp;m_rootDirectory, directory, &amp;file, VFS_LOOKUP_ADD|VFS_LOOKUP_CREATE); <span class="hljs-comment"><span class="hljs-comment">// There is no such file, create it. if (st == ERR::VFS_FILE_NOT_FOUND) { s.~ScopedLock(); return CreateFile(pathname, fileContents, size); } .... }</span></span></code> </pre> <br>  PVS-Studio警告： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V749</a> CWE-675离开对象范围后，将再次调用“ s”对象的析构函数。  vfs.cpp 165 <br><br> 在创建文件之前，必须使<i>ScopedLock</i>类型的对象“解锁”对象。 为此，显式调用析构函数。 问题是当函数退出时， <i>s</i>对象的析构函数将再次被自动调用。 即 析构函数将被调用两次。 我尚未研究<i>ScopedLock</i>类的设备，但是无论如何，您都不应这样做。 通常，对析构函数的这种双重调用会导致未定义的行为或其他不愉快的错误。 即使代码现在工作正常，通过更改<i>ScopedLock</i>类的实现也很容易破坏所有内容。 <br><br>  <b>错误N14，N15，N16，N17</b> <br><br><pre> <code class="cpp hljs">CFsmEvent* CFsm::AddEvent( <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> eventType ) { .... pEvent = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CFsmEvent( eventType ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !pEvent ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; .... }</code> </pre> <br>  PVS-Studio警告： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V668</a> CWE-570没有针对空测试'pEvent'指针的意义，因为使用'new'运算符分配了内存。 如果内存分配错误，将生成异常。  fsm.cpp 259 <br><br> 检查指针没有意义，因为在发生内存分配错误的情况下，将<i>引发</i>异常<i>std :: bad_alloc</i> 。 <br><br> 因此，检查是多余的，但错误并不严重。 但是， <i>如果</i>在<i>if语句</i>的主体中执行某些逻辑，则一切都会变得更加糟糕。 考虑以下情况： <br><br><pre> <code class="cpp hljs">CFsmTransition* CFsm::AddTransition(....) { .... CFsmEvent* pEvent = AddEvent( eventType ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !pEvent ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Create new transition CFsmTransition* pNewTransition = new CFsmTransition( state ); if ( !pNewTransition ) { delete pEvent; return NULL; } .... }</span></span></code> </pre> <br> 分析器警告：V668 CWE-570没有针对空测试'pNewTransition'指针的意义，因为使用'new'运算符分配了内存。 如果内存分配错误，将生成异常。  fsm.cpp 289 <br><br> 试图释放其地址存储在<i>pEvent</i>指针中的<i>内存</i> 。 自然，这不会发生，并且会发生内存泄漏。 <br><br> 实际上，当我开始处理这段代码时，结果发现一切都变得更加复杂，也许不是一个错误，而是两个错误。 现在，我将解释这段代码有什么问题。 为此，我们需要熟悉<i>AddEvent</i>函数设备。 <br><br><pre> <code class="cpp hljs">CFsmEvent* CFsm::AddEvent( <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> eventType ) { CFsmEvent* pEvent = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Lookup event by type EventMap::iterator it = m_Events.find( eventType ); if ( it != m_Events.end() ) { pEvent = it-&gt;second; } else { pEvent = new CFsmEvent( eventType ); if ( !pEvent ) return NULL; // Store new event into internal map m_Events[ eventType ] = pEvent; } return pEvent; }</span></span></code> </pre> <br> 请注意，该函数并不总是返回指向使用<i>new</i>运算符创建的新对象的指针。 有时，它从<i>m_Events</i>容器中获取一个现有对象。 顺便说一下，指向新创建对象的指针也将放置在<i>m_Events中</i> 。 <br><br> 问题就出现了：谁拥有并应销毁其指针存储在<i>m_Events</i>容器中的<i>对象</i> ？ 我对这个项目不熟悉，但是很可能是某个地方的代码破坏了所有这些对象。 然后，在<i>CFsm :: AddTransition函数</i>内部删除对象通常<i>是</i>多余的。 <br><br> 我的印象是，您可以简单地删除以下代码片段： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !pNewTransition ) { <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> pEvent; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; }</code> </pre> <br> 其他错误： <br><br><ul><li>  V668 CWE-571对“ ret”指针针对null进行测试是没有意义的，因为使用“ new”运算符分配了内存。 如果内存分配错误，将生成异常。  TerrainTextureEntry.cpp 120 </li><li>  V668 CWE-571没有必要针对空值测试“答案”指针，因为使用“新”运算符分配了内存。 如果内存分配错误，将生成异常。 声音管理器.cpp 542 </li></ul><br>  <b>错误N18，N19</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dir_scan_callback</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct de *de, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *data)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dir_scan_data</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dsd</span></span></span><span class="hljs-class"> = (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dir_scan_data</span></span></span><span class="hljs-class"> *) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dsd-&gt;entries == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> || dsd-&gt;num_entries &gt;= dsd-&gt;arr_size) { dsd-&gt;arr_size *= <span class="hljs-number"><span class="hljs-number">2</span></span>; dsd-&gt;entries = (struct de *) <span class="hljs-built_in"><span class="hljs-built_in">realloc</span></span>(dsd-&gt;entries, dsd-&gt;arr_size * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(dsd-&gt;entries[<span class="hljs-number"><span class="hljs-number">0</span></span>])); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dsd-&gt;entries == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// TODO(lsm): propagate an error to the caller dsd-&gt;num_entries = 0; } else { dsd-&gt;entries[dsd-&gt;num_entries].file_name = mg_strdup(de-&gt;file_name); dsd-&gt;entries[dsd-&gt;num_entries].st = de-&gt;st; dsd-&gt;entries[dsd-&gt;num_entries].conn = de-&gt;conn; dsd-&gt;num_entries++; } }</span></span></code> </pre> <br>  PVS-Studio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">警告</a> ： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V701</a> CWE-401 realloc（）可能泄漏：当realloc（）分配内存失败时，原始指针“ dsd-&gt;条目”丢失。 考虑将realloc（）分配给一个临时指针。  mongoose.cpp 2462 <br><br> 如果数组的大小不足，则使用<i>realloc</i>函数分配内存。 错误是指向原始内存块的指针的值立即被<i>realloc</i>函数返回的新值覆盖。 <br><br> 如果内存分配失败，则<i>realloc</i>函数将返回NULL，并将此NULL写入<i>dsd-&gt; entrys</i>变量。 之后，将不可能释放其地址先前存储在<i>dsd-&gt; entry中</i>的内存块。 将会发生内存泄漏。 <br><br> 另一个错误：V701 CWE-401 realloc（）可能泄漏：当realloc（）分配内存失败时，原始指针“ Buffer”丢失。 考虑将realloc（）分配给一个临时指针。  Preprocessor.cpp 84 <br><br><h2> 结论 </h2><br> 我不能说这一次这篇文章引人入胜，或者我设法表现出许多可怕的错误。 一次无需执行任何操作。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">我所看到的，然后我写</a> 。 <br><br> 谢谢您的关注。 要进行更改，我将在邀请结束时在Instagram <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">@pvs_studio_unicorn</a>和Twitter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">@Code_Analysis</a>上关注我。 <br><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/ts/z9/km/tsz9kmyjtteajhd4x1au60rsrvq.png" align="left"></a> </p><br><br> 如果您想与说英语的读者分享这篇文章，请使用以下链接：Andrey Karpov。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">干得好，游戏的作者0 AD！</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN420267/">https://habr.com/ru/post/zh-CN420267/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN420257/index.html">您仍然安装Windows 2008吗？ 我也是，这就是为什么</a></li>
<li><a href="../zh-CN420259/index.html">新加坡老化诊断小组</a></li>
<li><a href="../zh-CN420261/index.html">我们将衡量什么？ 如何为业务任务选择正确的ML指标</a></li>
<li><a href="../zh-CN420263/index.html">服务现在的会议“ Knowledge18”</a></li>
<li><a href="../zh-CN420265/index.html">我们不知道的七个Scrum实施问题</a></li>
<li><a href="../zh-CN420269/index.html">资金流失：为什么您的反网络钓鱼程序无法检测到网络钓鱼站点，以及数据科学如何使其起作用？</a></li>
<li><a href="../zh-CN420271/index.html">移情训练：通过视频游戏刺激大脑神经连接</a></li>
<li><a href="../zh-CN420273/index.html">长途客车的安排方式</a></li>
<li><a href="../zh-CN420275/index.html">2018-2019年有关物联网的主要会议。 俄罗斯与世界</a></li>
<li><a href="../zh-CN420277/index.html">淘金热之后：区块链技术的前景</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>