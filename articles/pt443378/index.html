<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèçÔ∏è üö∂üèº üóúÔ∏è Estamos escrevendo um cliente http de alto desempenho usando fasthttp como exemplo. Alexander Valyalkin (VertaMedia) üèòÔ∏è ‚ô£Ô∏è üßëüèø‚Äçü§ù‚ÄçüßëüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A biblioteca Fasthttp √© uma alternativa acelerada ao net / http dos pacotes Golang padr√£o. 
 Como √© organizado? Por que ela √© t√£o r√°pida? 


 Trago √† ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Estamos escrevendo um cliente http de alto desempenho usando fasthttp como exemplo. Alexander Valyalkin (VertaMedia)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/443378/"><p>  A biblioteca Fasthttp √© uma alternativa acelerada ao net / http dos pacotes Golang padr√£o. <br>  Como √© organizado?  Por que ela √© t√£o r√°pida? </p><br><p>  Trago √† sua aten√ß√£o uma transcri√ß√£o do relat√≥rio dos internos de clientes de Alexander Valyalkin Fasthttp. <br>  Padr√µes de Fasthttp podem ser usados ‚Äã‚Äãpara acelerar seus aplicativos, seu c√≥digo. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/fg3JPUswiek" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Quem se importa, bem-vindo ao gato. </p><a name="habracut"></a><br><p>  Eu sou Alexander Valyalkin.  Eu trabalho na VertaMedia.  Desenvolvi fasthttp para nossas necessidades.  Inclui a implementa√ß√£o do cliente http e do servidor http.  O Fasthttp √© muito mais r√°pido que o net / http dos pacotes Go padr√£o. </p><br><p><img src="https://habrastorage.org/webt/mw/xn/qb/mwxnqbi-ufmc9agmni-so-gy-ls.png"></p><br><p>  O Fasthttp √© uma implementa√ß√£o r√°pida do servidor http e do cliente.  Localizado fasthttp no github.com </p><br><p><img src="https://habrastorage.org/webt/ve/vz/07/vevz07ucp1l6ou4pg8zp2kuhvzu.png"></p><br><p>  Eu acho que muitos j√° ouviram falar do servidor fasthttp, que √© muito r√°pido.  Mas poucos ouviram falar do cliente fasthttp.  O servidor Fasthttp participa do benchmark da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">techempower</a> - o famoso benchmark em c√≠rculos estreitos para servidores http.  O servidor Fasthttp participa das rodadas 12 e 13.  A rodada 13 ainda n√£o foi lan√ßada (em 2016 - aprox. Ed.). </p><br><p><img src="https://habrastorage.org/webt/ow/t8/hv/owt8hvhbrxpvfxihc1golxlgp-y.png"></p><br><p>  Os resultados de um dos testes da rodada 12, em que fasthttp est√° quase no topo.  Os n√∫meros mostram quantas consultas ele faz por segundo neste teste.  Neste teste, √© feita uma solicita√ß√£o para uma p√°gina que retorna hello world.  No hello world, fasthttp √© muito r√°pido. </p><br><p><img src="https://habrastorage.org/webt/tk/h8/1t/tkh81tfzy0ee5jt0poqw_gxmv-e.png"></p><br><p>  Resultados preliminares da pr√≥xima rodada, que ainda n√£o foram divulgados (em 2016 - aprox. Ed.).  4 implementa√ß√µes fasthttp ocupam o primeiro lugar no benchmark, que n√£o apenas o hello world d√°, mas tamb√©m rastreia o banco de dados e forma uma p√°gina html com base no modelo. </p><br><p><img src="https://habrastorage.org/webt/lj/h1/ov/ljh1ovyrxst7hzjjgd16yk4tbmo.png"></p><br><p>  Muito poucas pessoas sabem sobre o cliente fasthttp.  Mas na verdade ele tamb√©m √© legal.  Neste relat√≥rio, vou falar sobre o cliente fasthttp do dispositivo interno e por que ele foi desenvolvido. </p><br><p><img src="https://habrastorage.org/webt/z6/rp/az/z6rpazy3l_asbpcbaklgdo8mnkq.png"></p><br><p>  Na verdade, existem v√°rios clientes no fasthttp: Client, HostClient e PipelineClient.  Al√©m disso, vou falar mais sobre cada um deles. </p><br><p><img src="https://habrastorage.org/webt/vs/ok/5u/vsok5umamlhuly1-gcfdewuxybu.png"></p><br><p>  Fasthttp.Client √© um cliente http de uso geral regular.  Com ele, voc√™ pode fazer solicita√ß√µes para qualquer site da Internet, receber respostas.  Suas caracter√≠sticas: funciona rapidamente, pode limitar o n√∫mero de conex√µes abertas por host, diferentemente do pacote net / http.  A documenta√ß√£o est√° em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://godoc.org/github.com/valyala/fast">https://godoc.org/github.com/valyala/fasthttp#Client</a> . </p><br><p><img src="https://habrastorage.org/webt/r0/il/cc/r0ilcc3iwd6acpv1pqbawqxvfc4.png"></p><br><p>  O Fasthttp.HostClient √© um cliente especializado para se comunicar com apenas um servidor.  Geralmente √© usado para acessar a API HTTP: API REST, API JSON.  Tamb√©m pode ser usado para proxy de tr√°fego da Internet para um DataCenter interno em v√°rios servidores.  A documenta√ß√£o est√° aqui: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://godoc.org/github.com/valyala/fast">https://godoc.org/github.com/valyala/fasthttp#HostClient</a> . </p><br><p>  Como o Fasthttp.Client, o Fasthttp.HostClient pode limitar o n√∫mero de conex√µes abertas para cada um dos servidores de back-end.  Essa funcionalidade est√° ausente no net / http e tamb√©m est√° ausente no nginx livre.  Essa funcionalidade √© apenas no nginx pago, tanto quanto eu sei. </p><br><p><img src="https://habrastorage.org/webt/sn/ys/ep/snysephpvj2u3itk5icip242ima.png"></p><br><p>  O Fasthttp.PipelineClient √© um cliente especializado que permite gerenciar solicita√ß√µes de pipeline para um servidor ou para um n√∫mero limitado de servidores.  Ele pode ser usado para acessar a API, atrav√©s do protocolo HTTP, onde voc√™ precisa executar muitas solicita√ß√µes e o mais r√°pido poss√≠vel.  A limita√ß√£o do Fasthttp.PipelineClient √© que ele pode sofrer com o bloqueio do chefe de linha.  √â quando enviamos muitas solicita√ß√µes ao servidor e n√£o esperamos uma resposta para cada solicita√ß√£o.  O servidor est√° bloqueado em uma dessas solicita√ß√µes.  Por esse motivo, todas as outras solicita√ß√µes que o seguiram aguardar√£o at√© que este servidor processe uma solicita√ß√£o lenta.  O Fasthttp.PipelineClient deve ser usado apenas se voc√™ tiver certeza de que o servidor responder√° instantaneamente √†s suas solicita√ß√µes.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://godoc.org/github.com/valyala/fast">Documenta√ß√£o</a> </p><br><p><img src="https://habrastorage.org/webt/9b/sa/z2/9bsaz297eqozr0ckcwrlbmefdqk.png"></p><br><p>  Agora vou come√ßar a falar sobre a implementa√ß√£o interna de cada um desses clientes.  Come√ßarei com Fasthttp.HostClient, porque quase todos os outros clientes s√£o criados com base nele. </p><br><p><img src="https://habrastorage.org/webt/zm/vq/rt/zmvqrtpi1eogjgjqmlnvxbjh7ca.png"></p><br><p>  Essa √© a implementa√ß√£o mais simples do cliente HTTP no pseudoc√≥digo no Go.  Estamos conectados, obtemos uma resposta http neste URL.  Estamos nos conectando a este host.  Temos conex√£o.  Nesse c√≥digo, para que seja menor que o volume, todas as verifica√ß√µes de erro est√£o ausentes.  De fato, n√£o √© assim.  Voc√™ deve sempre verificar se h√° erros.  Crie uma conex√£o.  Feche a conex√£o com o adiamento.  Enviamos uma solicita√ß√£o para esta conex√£o por URL.  Recebemos a resposta, retornamos essa resposta.  O que h√° de errado com esta implementa√ß√£o do cliente HTTP? </p><br><p><img src="https://habrastorage.org/webt/ev/lq/q4/evlqq4u3y3qbzr_agvrnmknzdee.png"></p><br><p>  O primeiro problema √© que nesta implementa√ß√£o, a conex√£o √© estabelecida para cada solicita√ß√£o.  Esta implementa√ß√£o n√£o suporta HTTP KeepAlive.  Como resolver este problema?  Voc√™ pode usar o pool de conex√µes para cada servidor.  Voc√™ n√£o pode usar o Conjunto de Conex√µes para todos os servidores, porque a pr√≥xima solicita√ß√£o n√£o est√° clara para qual servidor enviar.  Cada servidor deve ter seu pr√≥prio pool de conex√µes.  E usamos o HTTP KeepAlive.  Isso significa que o cabe√ßalho da conex√£o n√£o precisa especificar o fechamento da conex√£o.  No HTTP / 1.1, por padr√£o, h√° suporte para o HTTP KeepAlive e o Connection Close deve ser removido do cabe√ßalho.  Aqui est√° a implementa√ß√£o no pseudo-c√≥digo do cliente com suporte ao Pool de Conex√£o.  H√° um conjunto de v√°rios conjuntos de conex√µes para cada host.  A primeira fun√ß√£o, connPoolForHost, retorna o Conjunto de Conex√µes para um determinado host a partir de uma determinada URL.  Em seguida, obtemos a conex√£o desse pool de conex√µes, planejamos usar o adiamento para enviar essa conex√£o de volta ao pool, enviar uma solicita√ß√£o KeepAlive para essa conex√£o e retornar uma resposta.  Ap√≥s a resposta, o adiamento √© executado e a conex√£o retorna ao pool.  Assim, habilitamos o suporte HTTP KeepAlive e tudo come√ßa a funcionar mais rapidamente.  Porque n√£o perdemos tempo criando uma conex√£o para cada solicita√ß√£o. </p><br><p>  Mas a solu√ß√£o tamb√©m tem problemas.  Se voc√™ observar a assinatura da fun√ß√£o, poder√° ver que ela retorna um objeto de resposta para cada solicita√ß√£o.  Isso significa que, para esse objeto, voc√™ precisa alocar mem√≥ria toda vez, inicializ√°-lo e devolv√™-lo.  Isso √© ruim para o desempenho.  Pode ser ruim se voc√™ tiver muitas dessas chamadas para obter fun√ß√µes. </p><br><p><img src="https://habrastorage.org/webt/jb/yq/rr/jbyqrrzhu_qusd9j9ocba8m0czk.png"></p><br><p>  Portanto, esse problema pode ser resolvido da mesma maneira que no Fasthttp, colocando o objeto ponteiro no objeto de resposta nos par√¢metros dessa fun√ß√£o.  Dessa forma, esse c√≥digo de chamada pode reutilizar esse objeto de resposta v√°rias vezes.  No slide, est√° a implementa√ß√£o dessa ideia.  Passamos uma refer√™ncia ao objeto de resposta para a fun√ß√£o Get - e a fun√ß√£o preenche essa resposta.  A √∫ltima linha preenche esse objeto. </p><br><p><img src="https://habrastorage.org/webt/bm/z7/rq/bmz7rqtnowb5dreyup6c-er_tq0.png"></p><br><p>  Veja como ele pode ficar no seu c√≥digo.  Uma fun√ß√£o que aceita um canal ao qual √© transmitida uma lista de URLs a serem pesquisados.  Vamos organizar um ciclo neste canal.  Criamos um objeto de resposta uma vez e o reutilizamos em um loop.  Chame Get, passe um ponteiro para o objeto, processe esta resposta.  Ap√≥s process√°-lo, redefini-lo para seu estado original.  Dessa forma, evitamos a aloca√ß√£o de mem√≥ria e agilizamos nosso c√≥digo. </p><br><p><img src="https://habrastorage.org/webt/ok/2t/5z/ok2t5zsghgoxj7ruc2z_1hhcagu.png"></p><br><p>  O terceiro problema √© o fechamento da conex√£o.  Fechamento da conex√£o - cabe√ßalho HTTP, que pode ser encontrado em solicita√ß√£o e resposta.  Se obtivermos esse cabe√ßalho, essa conex√£o dever√° ser fechada.  Portanto, na implementa√ß√£o do cliente, √© imperativo fornecer o fechamento da conex√£o.  Se voc√™ enviou uma solicita√ß√£o com o cabe√ßalho Conex√£o encerrada, depois de receber a resposta, precisa fechar esta conex√£o.  Se voc√™ enviou uma solicita√ß√£o sem o fechamento da conex√£o e retornou uma resposta com o fechamento da conex√£o, tamb√©m ser√° necess√°rio fechar esta conex√£o ap√≥s receber uma resposta. </p><br><p><img src="https://habrastorage.org/webt/bc/ve/up/bcveuplhhdifuc0malg7f7bm2vw.png"></p><br><p>  Aqui est√° o pseudo-c√≥digo para esta implementa√ß√£o.  Depois de receber uma resposta, verificamos se os cabe√ßalhos de conex√£o pr√≥ximos est√£o instalados l√°.  Se instalado, basta fechar a conex√£o.  Se n√£o estiver instalado, retorne a conex√£o ao pool.  Se isso n√£o for feito, se o servidor fechar a conex√£o ap√≥s retornar as respostas, seu pool de conex√µes conter√° a conex√£o interrompida que o servidor fechou e voc√™ tentar√° escrever algo neles e obter√° erros. </p><br><p><img src="https://habrastorage.org/webt/wi/ms/gh/wimsghjdbpnjilbkgmvw5cryrvg.png"></p><br><p>  O quarto problema ao qual os clientes HTTP est√£o expostos √© servidores lentos ou uma rede lenta e inativa.  Os servidores podem parar de responder √†s suas solicita√ß√µes por v√°rios motivos.  Por exemplo, o servidor est√° com problemas ou a rede entre o cliente e o servidor parou de funcionar.  Por esse motivo, todas as suas goroutines que chamam a fun√ß√£o Get, descritas anteriormente, ser√£o bloqueadas, aguardando uma resposta do servidor indefinidamente.  Por exemplo, se voc√™ implementar um proxy http que aceite uma conex√£o de entrada e chame a fun√ß√£o Get em cada conex√£o, um grande n√∫mero de goroutines ser√° criado e todas elas permanecer√£o no servidor at√© que o servidor trave, at√© que a mem√≥ria se esgote. </p><br><p><img src="https://habrastorage.org/webt/cb/mq/1c/cbmq1c_b9ua-0ess-if8dfqkk0a.png"></p><br><p>  Como resolver este problema?  Existe uma decis√£o t√£o ing√™nua que primeiro vem √† mente - basta embrulhar este Get em uma goroutine separada.  Em seguida, na goroutine, passe um canal vazio, que ser√° fechado ap√≥s a execu√ß√£o de Get.  Depois de iniciar esta goroutine, aguarde neste canal por um tempo (tempo limite).  Nesse caso, se algum tempo passar e este Get n√£o for executado, a sa√≠da desta fun√ß√£o ocorrer√° por tempo limite.  Se este Get for executado, o canal ser√° fechado e a sa√≠da ocorrer√°.  Mas esta decis√£o est√° errada, porque transfere o problema de uma cabe√ßa doente para uma saud√°vel.  Mesmo assim, as goroutines ser√£o criadas e travadas, independentemente do tempo limite que voc√™ usar.  O n√∫mero de goroutines que causaram o tempo limite do Get ser√° limitado, mas haver√° um n√∫mero ilimitado de goroutines que ser√£o criadas dentro do Get with timeout. </p><br><p><img src="https://habrastorage.org/webt/yx/jx/nj/yxjxnjpdobdntdoel9119aqdgyo.png"></p><br><p>  Como resolver este problema?  A primeira solu√ß√£o √© limitar o n√∫mero de goroutines bloqueadas na fun√ß√£o Get.  Isso pode ser feito usando um padr√£o conhecido como o uso de um canal em buffer de comprimento limitado, que contar√° o n√∫mero de goroutines que executam a fun√ß√£o Get.  Se essa quantidade de goroutine exceder um certo limite - a capacidade deste canal, sairemos para o ramo padr√£o.  Isso significa que temos todas as goroutines executadas em execu√ß√£o e, na ramifica√ß√£o padr√£o, precisamos apenas retornar Error, que n√£o h√° recursos livres.  Antes de criar a goroutine, tentamos escrever alguma estrutura vazia neste canal.  Se isso n√£o der certo, excederemos a quantidade de goroutines.  Se acabou, criamos esse gorutin e depois que Get √© executado, lemos um valor desse canal.  Assim, limitamos a quantidade de goroutines que podem ser bloqueadas no Get. </p><br><p><img src="https://habrastorage.org/webt/w4/id/rr/w4idrrvfykc05ahmf_hrbyscwcs.png"></p><br><p>  A segunda solu√ß√£o, que complementa a primeira, √© definir tempos limite na conex√£o com o servidor.  Isso desbloquear√° a fun√ß√£o get se o servidor n√£o responder por um longo tempo ou a rede estiver inoperante. </p><br><p>  Se a rede n√£o funcionar na Solu√ß√£o 1, tudo ficar√° travado.  Depois de digitarmos na circuncis√£o um n√∫mero limitado de goroutines penduradas aqui, a fun√ß√£o getimeout sempre retornar√° um erro.  Para come√ßar a funcionar normalmente, voc√™ precisa de uma segunda solu√ß√£o (Solu√ß√£o 2), que define um tempo limite para leitura e grava√ß√£o da conex√£o.  Isso ajuda a desbloquear goroutines bloqueadas se a rede ou o servidor parar de funcionar. </p><br><p><img src="https://habrastorage.org/webt/yx/jx/nj/yxjxnjpdobdntdoel9119aqdgyo.png"></p><br><p>  A solu√ß√£o 1 tem uma corrida de dados.  O objeto de resposta do qual o ponteiro foi passado ser√° ocupado se Get for bloqueado.  Mas essa fun√ß√£o Get timeout pode expirar.  Nesse caso, sa√≠mos dessa fun√ß√£o, uma resposta ser√° interrompida e depois de algum tempo ser√° reescrita.  Assim, uma corrida de dados √© obtida.  Como temos resposta ap√≥s sair da fun√ß√£o, ela ainda √© usada em algum lugar da goroutina. </p><br><p>  O problema √© resolvido criando uma c√≥pia de resposta e passando a c√≥pia de resposta para a goroutine.  Ap√≥s a conclus√£o do Get, copie a resposta desta resposta para a nossa resposta original, que √© passada aqui.  Assim, a corrida de dados √© resolvida.  Essa c√≥pia da resposta permanece por um curto per√≠odo de tempo e retorna ao pool.  N√≥s reutilizamos a resposta.  Uma c√≥pia de resposta pode n√£o caber no pool apenas por tempo limite.  Por tempo limite, h√° uma perda de resposta do pool. </p><br><p><img src="https://habrastorage.org/webt/sc/cm/ar/sccmar-ze8kukg1nm5csyxz2riy.png"></p><br><p>  Preciso fechar a conex√£o ap√≥s o servidor n√£o retornar uma resposta dentro de um tempo limite?  A resposta √© n√£o.  Em vez disso, sim, se voc√™ deseja fazer backup do servidor.  Como quando voc√™ envia uma solicita√ß√£o para o servidor, aguarde um pouco, o servidor n√£o responde durante esse per√≠odo - ele n√£o lida com solicita√ß√µes.  Por exemplo, voc√™ fecha esta conex√£o, mas isso n√£o significa que o servidor parar√° imediatamente de executar essa solicita√ß√£o.  O servidor continuar√° a execut√°-lo.  O servidor detectar√° que essa solicita√ß√£o n√£o precisa ser executada ap√≥s tentar retornar uma resposta para voc√™.  Voc√™ fechou a conex√£o, tentou novamente criar uma nova solicita√ß√£o, novamente o tempo limite passou, fechou novamente, criou uma nova solicita√ß√£o.  Voc√™ ter√° uma carga no aumento do servidor.  Como resultado, seu servi√ßo depende de suas solicita√ß√µes.  Esses s√£o DoS no n√≠vel de solicita√ß√µes http.  Se voc√™ possui servidores em execu√ß√£o lenta e n√£o deseja fazer backup deles, n√£o √© necess√°rio fechar a conex√£o ap√≥s um tempo limite.  Voc√™ precisa esperar um pouco, deixar a conex√£o para expiar este servidor.  Deixe-o tentar lhe dar uma resposta.  Enquanto isso, use outras conex√µes gratuitas.  Tudo o que foi dito antes disso s√£o todos os est√°gios da implementa√ß√£o do Fasthttp.Client e os problemas que ocorreram durante a implementa√ß√£o do Fasthttp.Client.  Esses problemas foram resolvidos no Fasthttp.HostClient. </p><br><p><img src="https://habrastorage.org/webt/ht/yz/uj/htyzujg6gqaycezv_ot4_xucb6w.png">  Agora temos um cliente r√°pido?  Na verdade n√£o.  Voc√™ precisa ver como o Pool de conex√£o √© implementado. </p><br><p><img src="https://habrastorage.org/webt/tk/rs/1u/tkrs1uhjy3nlqecg_j2payseg_i.png"></p><br><p>  A implementa√ß√£o ing√™nua do Connection Pool se parece com isso.  H√° algum tipo de endere√ßo do servidor em que voc√™ precisa instalar a conex√£o.  H√° uma lista de conex√µes gratuitas e um bloqueio para sincronizar o acesso a essa lista. </p><br><p><img src="https://habrastorage.org/webt/zb/lk/j5/zblkj5q4hygyxgd9rmrzjx2nxpa.png"></p><br><p>  Aqui est√° a fun√ß√£o para obter conex√£o do pool de conex√µes.  Estamos vendo uma lista de nossa cole√ß√£o.  Se houver algo l√°, obtemos uma conex√£o gratuita e a devolvemos.  Se n√£o houver nada, crie uma nova conex√£o com este servidor e devolva-a.  O que h√° de errado aqui? </p><br><p><img src="https://habrastorage.org/webt/lw/xz/7q/lwxz7qmhwkqv3tmu4mc5f0tfumi.png">  A fun√ß√£o connPool.Put retorna uma conex√£o livre. </p><br><p>  Na conta de tempo limite.  No Fasthttp.Client, voc√™ pode especificar o tempo de vida m√°ximo de uma conex√£o aberta n√£o utilizada.  Ap√≥s esse per√≠odo, as conex√µes n√£o utilizadas s√£o fechadas automaticamente e lan√ßadas para fora desse pool. </p><br><p>  As conex√µes mais antigas ficam sem uso com o tempo e s√£o automaticamente fechadas e removidas do pool. </p><br><p>  Quando a conex√£o √© retirada do pool, e o servidor foi fechado e voc√™ tentou escrever algo l√°, √© feita uma segunda tentativa - uma nova conex√£o √© obtida e tenta enviar novamente pedidos para essa conex√£o.  Mas isso √© apenas se essa solicita√ß√£o √© idempotente - ou seja, uma solicita√ß√£o que pode ser executada v√°rias vezes sem efeitos colaterais no servidor - √© uma solicita√ß√£o GET ou HEAD.  Por exemplo, no net / http padr√£o agora adicionamos uma verifica√ß√£o de conex√µes fechadas.  L√° eles fizeram uma checagem mais complicada.  Eles verificam, quando tentam enviar uma nova solicita√ß√£o para a conex√£o do pool, se pelo menos um byte √© enviado a essa conex√£o.  Se ativado, retorne Erro.  Se voc√™ n√£o saiu, pegamos uma nova conex√£o do pool. </p><br><p><img src="https://habrastorage.org/webt/h2/ug/yv/h2ugyvjrfzht7gfwx2gemetfazy.png"></p><br><p>  O que h√° de errado com a piscina?  Seu tamanho n√£o √© limitado.  Mesma implementa√ß√£o que em net / http.  Se voc√™ escrever um cliente que est√° quebrando de milh√µes de goroutines para um servidor lento, ele tentar√° criar um milh√£o de conex√µes com esse servidor.  N√£o h√° limite para o n√∫mero m√°ximo de conex√µes no pacote net / http padr√£o.  Para o cliente usado para acessar a API por HTTP, √© recomend√°vel limitar o tamanho desse conjunto de conex√µes.  Caso contr√°rio, seus clientes poder√£o cair, porque voc√™ usar√° todos os recursos: threads, objetos, conex√£o, goroutines e mem√≥ria.  Al√©m disso, isso pode levar ao DoS de seus servidores, uma vez que ser√° estabelecida muita conex√£o com eles, que n√£o s√£o usados ‚Äã‚Äãou s√£o usados ‚Äã‚Äãineficientemente, porque o servidor n√£o pode suportar tanta conex√£o. </p><br><p><img src="https://habrastorage.org/webt/km/zk/pn/kmzkpnls98apnqltus4tvoeeb5c.png"></p><br><p>  Limite do conjunto de conex√µes.  O c√≥digo n√£o est√° aqui, porque √© muito grande para caber em um slide.  Os interessados ‚Äã‚Äãpodem ver a implementa√ß√£o desta fun√ß√£o no github.com. </p><br><p><img src="https://habrastorage.org/webt/ub/1a/ko/ub1akoqexz4yoqyn3xogkcwveza.png"></p><br><p>  O segundo problema.  Muitas solicita√ß√µes chegam ao cliente em algum momento.  E depois disso, h√° um decl√≠nio e um retorno ao n√∫mero anterior de solicita√ß√µes.  Por exemplo, 10.000 solicita√ß√µes chegaram simultaneamente e, em seguida, o n√∫mero de solicita√ß√µes retornou a 1000 por unidade de tempo.  Depois disso, o conjunto de conex√µes aumentar√° para 10000.  Essas conex√µes permanecer√£o intermin√°veis.  Esse problema estava no cliente net / http padr√£o anterior √† vers√£o 1.7.  Portanto, voc√™ precisa resolver esse problema. </p><br><p><img src="https://habrastorage.org/webt/dm/o1/w4/dmo1w4jixcnjjjaoznw8r7zz8bw.png"></p><br><p>  Esse problema √© resolvido limitando a vida √∫til de uma conex√£o n√£o utilizada.  Se, por algum tempo, nenhuma solicita√ß√£o foi enviada por conex√£o, ela simplesmente fecha e √© expulsa do pool.  N√£o h√° implementa√ß√£o porque √© muito grande. </p><br><p><img src="https://habrastorage.org/webt/hs/wj/wx/hswjwxgrlyawxzj_t-mmdbxhh3m.png"></p><br><p>  Temos um cliente que trabalha r√°pido e legal?  N√£o √© bem assim.  Ainda temos a fun√ß√£o de criar a conex√£o - dialHost. </p><br><p><img src="https://habrastorage.org/webt/cl/bs/jr/clbsjrbour6diwgkjri6jpdhnx8.png"></p><br><p>  Vejamos sua implementa√ß√£o.  Uma implementa√ß√£o ing√™nua se parece com isso.  O endere√ßo em que voc√™ deseja conectar √© simplesmente transmitido.  Chamamos a fun√ß√£o padr√£o net.Dial.  Ela retorna a conex√£o.  O que h√° de errado com esta implementa√ß√£o? </p><br><p><img src="https://habrastorage.org/webt/sm/b_/bc/smb_bcj41taldeo3mvnfl9ek-2g.png"></p><br><p>  Por padr√£o, o net.Dial faz uma solicita√ß√£o de DNS para cada chamada.  Isso pode levar ao aumento do uso de recursos do seu subsistema DNS.  Se os clientes da API se conectarem a servidores que n√£o suportam conex√µes KeepAlive, eles fechar√£o as conex√µes.  Voc√™ √© apoiado pelo KeepAlive e os servidores n√£o.  Ap√≥s essa resposta, o servidor fecha a conex√£o.  Acontece que net.Dial √© chamado em cada solicita√ß√£o.  Existem cerca de 10 mil solicita√ß√µes por segundo.  Voc√™ tem 10 mil vezes por segundo vai resolver em DNS.  Isso carrega o subsistema DNS. </p><br><p><img src="https://habrastorage.org/webt/2j/au/e6/2jaue6kkmfwaob6p9tu-5quhgei.png"></p><br><p>  Como resolver este problema?  Crie um cache que mapeie o host no IP por um curto per√≠odo diretamente no seu c√≥digo Go e n√£o chame o DNS que resolve em cada net.Dial.  Conecte-se a endere√ßos IP prontos. </p><br><p><img src="https://habrastorage.org/webt/eh/n2/j3/ehn2j3tfuse-43qoibyq5oqqcsu.png"></p><br><p>  O segundo problema √© a carga desigual no servidor se voc√™ tiver v√°rios servidores ocultos atr√°s do nome do dom√≠nio.  Por exemplo, como Round Robin DNS.  Se voc√™ armazenar em cache um endere√ßo IP no DNS por um tempo, durante esse per√≠odo, todas as suas solicita√ß√µes ir√£o para um servidor.  Embora voc√™ possa ter v√°rios deles l√°.  √â necess√°rio resolver este problema.  Isso √© resolvido enumerando todos os IPs dispon√≠veis ocultos atr√°s de um determinado nome de dom√≠nio.  Isso tamb√©m √© feito no Fasthttp.Client. </p><br><p><img src="https://habrastorage.org/webt/wx/hb/6r/wxhb6r3hlt_wofv6o347jyvw_oo.png"></p><br><p>  O terceiro problema √© que o net.Dial tamb√©m pode travar indefinidamente devido a problemas na rede ou no servidor em que voc√™ est√° tentando se conectar.  Nesse caso, suas goroutines ir√£o travar na fun√ß√£o Get.  Isso tamb√©m pode levar ao aumento do uso de recursos. </p><br><p><img src="https://habrastorage.org/webt/jc/k3/id/jck3idzikb6vyzvsbcuckeg8wae.png">  A solu√ß√£o √© adicionar um tempo limite.   Dial     package net. ,   ,   . ,    ,      ,   . </p><br><p><img src="https://habrastorage.org/webt/cb/mq/1c/cbmq1c_b9ua-0ess-if8dfqkk0a.png"></p><br><p>     .  Get  Dial .    - .  Dial ,  ,   .   ,  ,   .    DialTimeout. ,   . </p><br><p><img src="https://habrastorage.org/webt/jo/tn/t0/jotnt0t9nwul2jx8sym4-kycfvu.png"></p><br><p>   HostClient   . </p><br><p> HostClient      ,   .     LoadBalance. </p><br><p>  HostClient    .          ,  HostClient        .   connection       .     .     . </p><br><p> Fauly host     . </p><br><p>   ‚Äî        .   Dial.    ,     Dial. Get,  ,   - .   ,           .  ,       ,   . </p><br><p>   ‚Äî      .   Get   ,   .     ,    ,  ,    . </p><br><p>   Error ,     Round Robin    . </p><br><p>  SSL   ,    Golang   .        . </p><br><p><img src="https://habrastorage.org/webt/py/wf/93/pywf93cfwemlknabq_iejxfgpt4.png"></p><br><p>   fasthttp.Client.           HostClient,   fasthttp.Client    HostClient. </p><br><p><img src="https://habrastorage.org/webt/0s/f8/mz/0sf8mzfxpk1nl5lucgjvwaqkgy8.png"></p><br><p>        Get.     HostClient    .      HostClient      .     HostClient   Get.       HostClient. </p><br><p><img src="https://habrastorage.org/webt/xd/nf/u8/xdnfu88duh8s5ibm0qx_riwe4go.png"></p><br><p>       HostClient  -  ,      URL.    web-crawling (  ),        .        HostClient       .      net/http,      .    ,    HostClient,      .   fasthttp. </p><br><p><img src="https://habrastorage.org/webt/r2/f7/bk/r2f7bkykq6m6oqcd3ylss9rwdr4.png"></p><br><p>    Client  HostClient,  PipelineClient   .  PipelineClient  connection pool.  PipelineClient    connection,     . PipelineClient         connection.     connection pool. PipelineClient   connection       . </p><br><p><img src="https://habrastorage.org/webt/lj/vw/ew/ljvwewxdpm8ag50y-tcfzthrxia.png"></p><br><p>  PipelineClient   connection   . PipelineConnClient.writer ‚Äî    connection,   . PipelineConnClient.reader ‚Äî     connection     ,     PipelineConnClient.writer. PipelineConnClient.reader   ,     Get. </p><br><p><img src="https://habrastorage.org/webt/nj/9q/lp/nj9qlpw3mexynplnky52vvhcar4.png"></p><br><p>      PipelineClient.Get  PipelineClient.   pipelineWork  url,    ,    response,  channel done,     response. </p><br><p>     Get. C   .    channel,   PipelineConnClient.writer      connection.   channel w.done,   PipelineConnClient.reader,   response   request. </p><br><p><img src="https://habrastorage.org/webt/s4/vf/oq/s4vfoqg_mmutotfdw66gs4nbxvs.png"></p><br><p>   net/http   fasthttp.Client   2 . </p><br><p><img src="https://habrastorage.org/webt/ah/ra/-o/ahra-oaf0uydcje9yqofoh6l-6k.png"></p><br><p> ,     ,   fasthttp.     , , .    fasthttp. ,      fasthttp,          .    allocation  .         . </p><br><p><img src="https://habrastorage.org/webt/q6/c3/ss/q6c3ss7kpmkwwlxk01o_ffyqhs0.png"></p><br><p>     net/http. ,  allocation    net/nttp.       . </p><br><p><img src="https://habrastorage.org/webt/jm/fh/sg/jmfhsgqsqoiwblgnfsliiytqauw.png"></p><br><p> :  PipelineClient      connection? </p><br><p> :     ‚Äî  pending ,      .     .    request,      pending ,   Error. </p><br><p> :    API   ,    fasthttp,  net/http? </p><br><p> :  .     net/http     .        .  string -,  string   .  ,     net/http,   .    -     ,    .  fasthttp     ,     .    .   net/http   fasthttp  ,    net/http     POST-,   response,  () .   fasthttp  ,  request  response    .    10 request   10 response .    ,      .    fasthttp   10 request   10 response?         .           ‚Äî    .            ,     net/http.           . ,  net/http   ‚Äî    . </p><br><p> PS        . </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">    </a> . </p><br><p>     ‚Äî     . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt443378/">https://habr.com/ru/post/pt443378/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt443364/index.html">Como uma holding de m√≠dia pode lan√ßar 12 startups de sucesso por ano</a></li>
<li><a href="../pt443368/index.html">Estamos preparando uma pesquisa de texto completo no Postgres. Parte 2</a></li>
<li><a href="../pt443370/index.html">Conectando o Google reCAPTCHA ao Vue e validando a resposta no servidor</a></li>
<li><a href="../pt443372/index.html">Back-end no CodeFest. Tripas encomendadas?</a></li>
<li><a href="../pt443376/index.html">Conseguiu encontrar dezenas de armazenamentos corporativos da Box.com que divulgam dados da Apple, Herbalife etc.</a></li>
<li><a href="../pt443380/index.html">UDB. O que √© isso? Parte 6. M√≥dulo de Status e Controle</a></li>
<li><a href="../pt443382/index.html">Fintech Digest: Mir Pay para Android, suspendendo a proibi√ß√£o de retirar dinheiro de carteiras an√¥nimas, as startups de IA n√£o s√£o exatamente AI</a></li>
<li><a href="../pt443384/index.html">Slurm e MegaSlerm em Moscou no final de maio</a></li>
<li><a href="../pt443386/index.html">Como obter o log de seguran√ßa com usu√°rio n√£o administrativo</a></li>
<li><a href="../pt443388/index.html">Controle de ilumina√ß√£o multin√≠vel baseado no KTS NPL</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>