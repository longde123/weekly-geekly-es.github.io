<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏂🏼 🤰🏻 💹 Learning go: Schreiben eines P2P-Messenger mit End-to-End-Verschlüsselung 🖖🏽 🐟 👨🏽‍🎤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Noch ein P2P Messenger 


 Das Lesen von Rezensionen und Sprachdokumentationen reicht nicht aus, um zu lernen, wie man mehr oder weniger nützliche Anw...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Learning go: Schreiben eines P2P-Messenger mit End-to-End-Verschlüsselung</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437686/"><h1 id="yet-another-p2p-messenger">  Noch ein P2P Messenger </h1><br><p>  Das Lesen von Rezensionen und Sprachdokumentationen reicht nicht aus, um zu lernen, wie man mehr oder weniger nützliche Anwendungen darauf schreibt. </p><br><p>  Stellen Sie sicher, dass Sie etwas Interessantes erstellen, damit die Entwicklungen für andere Aufgaben verwendet werden können. </p><br><p><img src="https://habrastorage.org/webt/kt/bm/3r/ktbm3rsivunfcdcvcyqvnm14f5u.png" alt="Beispiel für die Chat-Benutzeroberfläche von ReactJs"></p><br><p>  Dieser Artikel richtet sich an Anfänger, die sich für die Go-Sprache und Peer-to-Peer-Netzwerke interessieren. <br>  Und für Profis, die vernünftige Ideen anbieten oder konstruktiv kritisieren können. </p><a name="habracut"></a><br><p>  Ich programmiere seit einiger Zeit mit unterschiedlichem Eintauchen in Java, PHP, JS, Python. <br>  Und jede Programmiersprache ist auf ihrem Gebiet gut. </p><br><p>  Der Hauptbereich für Go ist die Schaffung verteilter Dienste, Microservices. <br>  Meistens ist ein Microservice ein kleines Programm, das seine hochspezialisierte Funktionalität ausführt. </p><br><p> Microservices sollten jedoch weiterhin in der Lage sein, miteinander zu kommunizieren, sodass das Tool zum Erstellen von Microservices eine einfache und schmerzlose Vernetzung ermöglichen sollte. <br>  Um dies zu testen, werden wir eine Anwendung schreiben, die ein dezentrales Netzwerk von Peers (Peer-To-Peer) organisiert. Am einfachsten ist ein P2P-Messenger (gibt es übrigens ein russisches Synonym für dieses Wort?). </p><br><p>  Im Code erfinde ich aktiv Fahrräder und trete auf den Rechen, um mich wie ein Golang zu fühlen, konstruktive Kritik und rationale Vorschläge zu erhalten. </p><br><h2 id="chto-delaem">  Was machen wir? </h2><br><p>  Peer (Peer) - eine einzigartige Instanz des Messenger. </p><br><p>  Unser Bote sollte in der Lage sein: </p><br><ul><li>  Finden Sie in der Nähe Feste </li><li>  Stellen Sie eine Verbindung mit anderen Kollegen her </li><li>  Verschlüsseln Sie den Datenaustausch mit Peers </li><li>  Nachrichten vom Benutzer empfangen </li><li>  Nachrichten dem Benutzer anzeigen </li></ul><br><p>  Um die Aufgabe ein wenig interessanter zu gestalten, lassen Sie uns alles über einen Netzwerkport laufen. </p><br><p><img src="https://habrastorage.org/webt/5b/zo/8g/5bzo8g4eqogveeure4lzgngo5ma.png" alt="Das bedingte Schema des Boten"></p><br><p>  Wenn Sie diesen Port über HTTP ziehen, erhalten wir eine React-Anwendung, die denselben Port durch Herstellen einer Web-Socket-Verbindung abruft. </p><br><p>  Wenn Sie den Port über HTTP nicht vom lokalen Computer abrufen, wird das Banner angezeigt. </p><br><p>  Wenn ein anderer Peer mit diesem Port verbunden ist, wird eine permanente Verbindung mit End-to-End-Verschlüsselung hergestellt. </p><br><h2 id="opredelyaem-tip-vhodyaschego-soedineniya">  Bestimmen Sie den Typ der eingehenden Verbindung </h2><br><p>  Öffnen Sie zuerst den Port zum Abhören und wir warten auf neue Verbindungen. </p><br><pre><code class="go hljs">net.ListenTCP(<span class="hljs-string"><span class="hljs-string">"tcp"</span></span>, tcpAddr)</code> </pre> <br><p>  Lesen Sie bei der neuen Verbindung die ersten 4 Bytes. </p><br><p>  Wir nehmen die Liste der HTTP-Verben und vergleichen unsere 4 Bytes damit. </p><br><p>  Jetzt stellen wir fest, ob eine Verbindung vom lokalen Computer hergestellt wird, und wenn nicht, antworten wir mit einem Banner und legen auf. </p><br><pre> <code class="go hljs"> buf, err := readWriter.Peek(<span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ItIsHttp(buf) { handleHttp(readWriter, conn, p) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { peer := proto.NewPeer(conn) p.HandleProto(readWriter, peer) } <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !strings.EqualFold(s, <span class="hljs-string"><span class="hljs-string">"127"</span></span>) &amp;&amp; !strings.EqualFold(s, <span class="hljs-string"><span class="hljs-string">"[::"</span></span>) { response.Body = ioutil.NopCloser(strings.NewReader(<span class="hljs-string"><span class="hljs-string">"Peer To Peer Messenger. see https://github.com/easmith/p2p-messenger"</span></span>)) }</code> </pre> <br><p>  Wenn die Verbindung lokal ist, antworten wir mit der Datei, die der Anfrage entspricht. </p><br><p>  Dann habe ich beschlossen, die Verarbeitung selbst zu schreiben, obwohl ich den in der Standardbibliothek verfügbaren Handler verwenden konnte. </p><br><pre> <code class="go hljs"> <span class="hljs-comment"><span class="hljs-comment">//   func processRequest(request *http.Request, response *http.Response) {/*    */} //     fileServer := http.FileServer(http.Dir("./front/build/")) fileServer.ServeHTTP(NewMyWriter(conn), request)</span></span></code> </pre> <br><p>  Wenn der Pfad <code>/ws</code> angefordert wird, versuchen wir, eine Websocket-Verbindung herzustellen. </p><br><p>  Da ich das Fahrrad bei der Verarbeitung von Dateianfragen zusammengebaut habe, werde ich die ws-Verbindung mithilfe der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gorilla / Websocket-Bibliothek verarbeiten</a> . </p><br><p>  Erstellen Sie dazu <code>MyWriter</code> und implementieren Sie darin Methoden, die den Schnittstellen <code>http.ResponseWriter</code> und <code>http.Hijacker</code> . </p><br><pre> <code class="go hljs"> <span class="hljs-comment"><span class="hljs-comment">// w - MyWriter func handleWs(w http.ResponseWriter, r *http.Request, p *proto.Proto) { c, err := upgrader.Upgrade(w, r, w.Header()) /*          */ }</span></span></code> </pre> <br><h2 id="obnaruzhenie-pirov">  Peer-Erkennung </h2><br><p>  Um in einem lokalen Netzwerk nach Peers zu suchen, verwenden wir UDP-Multicast. </p><br><p>  Wir senden Pakete mit Informationen über uns an die Multicast-IP-Adresse. </p><br><pre> <code class="go hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">startMeow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(address </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, p *proto.Proto)</span></span></span></span> { conn, err := net.DialUDP(<span class="hljs-string"><span class="hljs-string">"udp"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, addr) <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { _, err := conn.Write([]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>(fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">"meow:%v:%v"</span></span>, hex.EncodeToString(p.PubKey), p.Port))) <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> time.Sleep(<span class="hljs-number"><span class="hljs-number">1</span></span> * time.Second) } }</code> </pre> <br><p>  Und hören Sie alle UDP-Pakete getrennt von Multicast-IP ab. </p><br><pre> <code class="go hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">listenMeow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(address </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, p *proto.Proto, handler </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">func</span></span></span></span><span class="hljs-function"><span class="hljs-params">(p *proto.Proto, peerAddress </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> conn, err := net.ListenMulticastUDP(<span class="hljs-string"><span class="hljs-string">"udp"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, addr) <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> _, src, err := conn.ReadFromUDP(buffer) <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-comment"><span class="hljs-comment">// connectToPeer handler(p, peerAddress) }</span></span></code> </pre> <br><p>  So erklären wir uns und lernen über das Erscheinen anderer Feste. </p><br><p>  Es wäre möglich, dies auf IP-Ebene zu organisieren, und selbst in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">offiziellen Dokumentation des IPv4-Pakets wird</a> nur das Multicast-Datenpaket als Beispiel für Code angegeben. </p><br><h2 id="protokol-vzaimodeystviya-pirov">  Peer-Interaktionsprotokoll </h2><br><p>  Wir werden die gesamte Kommunikation zwischen Kollegen in einen Umschlag (Umschlag) packen. </p><br><p>  Auf jedem Umschlag gibt es immer einen Absender und einen Empfänger. Dazu fügen wir einen Befehl (den er mit sich führt), eine Kennung (soweit dies eine Zufallszahl ist, aber als Hash von Inhalten erfolgen kann), die Länge des Inhalts und den Inhalt des Umschlags selbst hinzu - eine Nachricht oder Befehlsparameter. </p><br><p><img src="https://habrastorage.org/webt/3b/yx/yc/3byxycyif222uk2jslbya9qb1bs.png" alt="Umschlagbytes"></p><br><p>  Der Befehl (oder die Art des Inhalts) wird erfolgreich ganz am Anfang des Umschlags platziert, und wir definieren eine Liste von Befehlen mit 4 Bytes, die sich nicht mit den Namen der HTTP-Verben überschneiden. </p><br><p>  Die gesamte Hüllkurve während der Übertragung wird in ein Array von Bytes serialisiert. </p><br><h3 id="rukopozhatie">  Handschlag </h3><br><p>  Wenn die Verbindung hergestellt ist, greift das Fest sofort nach einem Handschlag und gibt seinen Namen, seinen öffentlichen Schlüssel und seinen kurzlebigen öffentlichen Schlüssel an, um einen gemeinsamen Sitzungsschlüssel zu generieren. </p><br><p>  Als Antwort empfängt der Peer einen ähnlichen Datensatz, registriert den in seiner Liste gefundenen Peer und berechnet (CalcSharedSecret) den gemeinsamen Sitzungsschlüssel. </p><br><pre> <code class="go hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handShake</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(p *proto.Proto, conn net.Conn)</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">proto</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Peer</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> peer := proto.NewPeer(conn) <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> p.SendName(peer) <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> envelope, err := proto.ReadEnvelope(bufio.NewReader(conn)) <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br><h3 id="obmen-pirami">  Festtausch </h3><br><p>  Nach einem Handschlag tauschen Peers ihre Peer-Listen aus =) </p><br><p>  Zu diesem Zweck wird ein Umschlag mit dem Befehl LIST gesendet und eine JSON-Liste von Peers in den Inhalt eingefügt. <br>  Als Antwort erhalten wir einen ähnlichen Umschlag. </p><br><p>  Wir finden in den Listen der neuen und mit jedem von ihnen versuchen wir uns zu verbinden, Hände zu schütteln, Feste auszutauschen und so weiter ... </p><br><h3 id="obmen-polzovatelskimi-soobscheniyami">  User Messaging </h3><br><p>  Benutzerdefinierte Nachrichten sind für uns von größtem Wert, daher verschlüsseln und signieren wir jede Verbindung. </p><br><h4 id="o-shifrovanii">  Über Verschlüsselung </h4><br><p>  In den Standard-Golang-Bibliotheken (Google) aus dem Crypto-Paket sind viele verschiedene Algorithmen implementiert (es gibt keine GOST-Standards). </p><br><p>  Am bequemsten für Signaturen ist meiner Meinung nach die Ed25519-Kurve.  Wir werden die Bibliothek ed25519 verwenden, um Nachrichten zu signieren. </p><br><p>  Ganz am Anfang habe ich darüber nachgedacht, ein Schlüsselpaar aus ed25519 nicht nur zum Signieren, sondern auch zum Generieren eines Sitzungsschlüssels zu verwenden. </p><br><p>  Die Schlüssel zum Signieren gelten jedoch nicht für die Berechnung des gemeinsam genutzten Schlüssels. Sie müssen sie dennoch beschwören: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateKeyExchangePair</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(publicKey [32]</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">, privateKey [32]</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { pub, priv, err := ed25519.GenerateKey(<span class="hljs-literal"><span class="hljs-literal">nil</span></span>) <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">copy</span></span>(publicKey[:], pub[:]) <span class="hljs-built_in"><span class="hljs-built_in">copy</span></span>(privateKey[:], priv[:]) curve25519.ScalarBaseMult(&amp;publicKey, &amp;privateKey) <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br><p>  Aus diesem Grund wurde beschlossen, kurzlebige Schlüssel zu generieren. Im Allgemeinen ist dies der richtige Ansatz, bei dem Angreifer keine Chance haben, einen gemeinsamen Schlüssel zu finden. </p><br><p>  Für Mathematikliebhaber gibt es hier die Wiki-Links: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em>Diffie-</em> Protokoll - Hellman_ auf elliptischen Kurven</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Digitale Signatur EdDSA</a> </p><br><p>  Die Generierung eines gemeinsam genutzten Schlüssels ist Standard: Für eine neue Verbindung generieren wir zunächst kurzlebige Schlüssel und senden einen Umschlag mit einem öffentlichen Schlüssel an den Socket. </p><br><p>  Die gegenüberliegende Seite macht dasselbe, jedoch in einer anderen Reihenfolge: Sie empfängt einen Umschlag mit einem öffentlichen Schlüssel, generiert ein eigenes Paar und sendet den öffentlichen Schlüssel an den Socket. </p><br><p>  Jetzt hat jeder Teilnehmer die öffentlichen und privaten kurzlebigen Schlüssel eines anderen. </p><br><p>  Wenn wir sie multiplizieren, erhalten wir für beide den gleichen Schlüssel, mit dem wir Nachrichten verschlüsseln. </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//CalcSharedSecret Calculate shared secret func CalcSharedSecret(publicKey []byte, privateKey []byte) (secret [32]byte) { var pubKey [32]byte var privKey [32]byte copy(pubKey[:], publicKey[:]) copy(privKey[:], privateKey[:]) curve25519.ScalarMult(&amp;secret, &amp;privKey, &amp;pubKey) return }</span></span></code> </pre> <br><p>  Wir werden Nachrichten mit dem seit langem etablierten AES-Algorithmus im Block Coupling Mode (CBC) verschlüsseln. </p><br><p>  Alle diese Implementierungen sind leicht in der Golang-Dokumentation zu finden. </p><br><p>  Die einzige Verfeinerung besteht darin, die Nachricht automatisch mit Null Bytes für die Vielzahl ihrer Länge mit der Länge des Verschlüsselungsblocks (16 Bytes) zu füllen. </p><br><pre> <code class="go hljs"> <span class="hljs-comment"><span class="hljs-comment">//Encrypt the message func Encrypt(content []byte, key []byte) []byte { padding := len(content) % aes.BlockSize if padding != 0 { repeat := bytes.Repeat([]byte("\x00"), aes.BlockSize-(padding)) content = append(content, repeat...) } /* ... */ } //Decrypt encrypted message func Decrypt(encrypted []byte, key []byte) []byte { /* ... */ encrypted = bytes.Trim(encrypted, string([]byte("\x00"))) return encrypted }</span></span></code> </pre> <br><p>  Bereits 2013 implementierte er im Rahmen eines Wettbewerbs von Pavel Durov AES (mit einem ähnlichen Modus wie CBC) zum Verschlüsseln von Nachrichten in Telegram. </p><br><p>  Zu dieser Zeit wurde das häufigste <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Diffie-Hellman-Protokoll</a> in Telegrammen verwendet, um einen kurzlebigen Schlüssel zu generieren. </p><br><p>  Und um die Last von gefälschten Verbindungen auszuschließen, lösten die Clients vor jedem Schlüsselaustausch das Faktorisierungsproblem. </p><br><h2 id="gui">  GUI </h2><br><p>  Wir müssen eine Liste von Peers und eine Liste von Nachrichten mit ihnen anzeigen und auch auf neue Nachrichten reagieren, indem wir den Zähler neben dem Namen des Peers erhöhen. </p><br><p>  Hier ohne Probleme - ReactJS + Websocket. </p><br><p>  Web-Socket-Nachrichten sind im Wesentlichen eindeutige Umschläge, nur enthalten sie keine Chiffretexte. </p><br><p>  Alle von ihnen sind "Erben" vom Typ <code>WsCmd</code> und werden bei der Übertragung in JSON serialisiert. </p><br><pre> <code class="go hljs"> <span class="hljs-comment"><span class="hljs-comment">//Serializable interface to detect that can to serialised to json type Serializable interface { ToJson() []byte } func toJson(v interface{}) []byte { json, err := json.Marshal(v) /*  err */ return json } /* ... */ //WsCmd WebSocket command type WsCmd struct { Cmd string `json:"cmd"` } //WsMessage WebSocket command: new Message type WsMessage struct { WsCmd From string `json:"from"` To string `json:"to"` Content string `json:"content"` } //ToJson convert to JSON bytes func (v WsMessage) ToJson() []byte { return toJson(v) } /* ... */</span></span></code> </pre> <br><p>  Eine HTTP-Anfrage kommt also zum Stammverzeichnis ("/"). Um nun die Vorderseite anzuzeigen, schauen Sie im Verzeichnis "front / build" nach und geben Sie index.html an </p><br><p>  Nun, die Benutzeroberfläche ist aufgebaut, jetzt haben die Benutzer die Wahl: Führen Sie sie in einem Browser oder in einem separaten Fenster aus - WebView. </p><br><p>  Für die letzte Option wurde <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zserge / webview verwendet</a> </p><br><pre> <code class="go hljs"> e := webview.Open(<span class="hljs-string"><span class="hljs-string">"Peer To Peer Messenger"</span></span>, fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">"http://localhost:%v"</span></span>, initParams.Port), <span class="hljs-number"><span class="hljs-number">800</span></span>, <span class="hljs-number"><span class="hljs-number">600</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>)</code> </pre> <br><p>  Um eine Anwendung damit zu erstellen, müssen Sie ein anderes System installieren </p><br><pre> <code class="bash hljs"> sudo apt install libwebkit2gtk-4.0-dev</code> </pre> <br><p>  Während ich über die GUI nachdachte, fand ich viele Bibliotheken für GTK, QT und die Konsolenschnittstelle würde sehr geeky aussehen - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/jroimartin/gocui</a> - meiner Meinung nach eine sehr interessante Idee. </p><br><h2 id="zapusk-messendzhera">  Messenger-Start </h2><br><h3 id="ustanovka-golang">  Golang Installation </h3><br><p>  Natürlich müssen Sie zuerst go installieren. <br>  Zu diesem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zweck</a> empfehle ich dringend, die Anweisung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">golang.org/doc/install</a> zu verwenden. </p><br><p>  Vereinfachte Anweisungen zum <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bash-Skript</a> </p><br><h3 id="zagruzka-prilozheniya-v-gopath">  Laden Sie eine Anwendung in GOPATH herunter </h3><br><p>  Es ist so angeordnet, dass sich alle Bibliotheken und sogar Ihre Projekte im sogenannten GOPATH befinden sollten. </p><br><p>  Standardmäßig ist dies $ HOME / go.  Mit Go können Sie die Quelle mit einem einfachen Befehl aus dem öffentlichen Repository abrufen: </p><br><pre> <code class="bash hljs"> go get github.com/easmith/p2p-messenger</code> </pre> <br><p>  In Ihrem <code>$HOME/go/src/github.com/easmith/p2p-messenger</code> Quelle aus dem Hauptzweig <code>$HOME/go/src/github.com/easmith/p2p-messenger</code> </p><br><h3 id="ustanovka-npm-i-sborka-fronta">  Npm Installation und Frontmontage </h3><br><p>  Wie ich oben geschrieben habe, ist unsere GUI eine Webanwendung mit einer Front auf ReactJs, daher muss die Front noch zusammengebaut werden. </p><br><p>  Nodejs + npm - hier wie gewohnt. </p><br><p>  Nur für den Fall, hier ist die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Anleitung für Ubuntu</a> </p><br><p>  Jetzt starten wir die Frontmontage als Standard </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> front npm update npm run build</code> </pre> <br><p>  Die Front ist fertig! </p><br><h3 id="zapusk">  Starten </h3><br><p>  Gehen wir zurück zur Wurzel und starten das Fest unseres Boten. </p><br><p>  Beim Start können wir den Namen unseres Peers, Ports, die Datei mit den Adressen anderer Peers und ein Flag angeben, das angibt, ob WebView gestartet werden soll. </p><br><p>  Standardmäßig wird <code>$USER@$HOSTNAME</code> als <code>$USER@$HOSTNAME</code> Name und Port 35035 verwendet. </p><br><p>  Also starten wir und chatten mit Freunden im lokalen Netzwerk. </p><br><pre> <code class="bash hljs"> go run app.go -name Snowden</code> </pre> <br><h2 id="otzyv-o-programmirovanii-na-golang">  Feedback zur Golang-Programmierung </h2><br><ul><li>  Das Wichtigste, was ich beachten möchte: <strong>Unterwegs stellt sich sofort heraus, was ich beabsichtigt habe</strong> . <br>  Fast alles, was Sie brauchen, befindet sich in der Standardbibliothek. </li><li>  Es gab jedoch eine Schwierigkeit, als ich das Projekt in einem anderen Verzeichnis als GOPATH startete. <br>  Ich habe GoLand verwendet, um Code zu schreiben.  Und zunächst war es peinlich, den Code automatisch mit automatisch importierten Bibliotheken zu formatieren. </li><li>  Es gibt <strong>viele Codegeneratoren</strong> in der <strong>IDE</strong> , die es uns ermöglichten, uns eher auf die Entwicklung als auf den <strong>Codesatz</strong> zu konzentrieren. </li><li>  Sie <strong>gewöhnen sich</strong> schnell an häufige Fehlerbehandlungen, aber ein Handgesicht tritt auf, wenn Sie feststellen, dass eine normale Situation für unterwegs darin besteht, das Wesen des Fehlers anhand seiner Zeichenfolgendarstellung zu analysieren. <br><pre> <code class="go hljs">err != io.EOF</code> </pre> </li><li>  Mit der OS-Bibliothek sieht es etwas besser aus.  Solche Konstruktionen helfen, das Wesentliche des Problems zu verstehen. <br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> os.IsNotExist(err) { <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> </li><li>  Nach dem Auspacken lernen wir, Code richtig zu dokumentieren und Tests zu schreiben. <br>  Und es gibt einige aber.  Wir haben die Schnittstelle mit der <code>ToJson()</code> -Methode beschrieben. <br>  Daher dokumentiert der Dokumentationsgenerator die Beschreibung dieser Methode nicht an Methoden, die sie implementieren. Um unnötige Warnungen zu entfernen, müssen Sie die Dokumentation in jede implementierte Methode (proto / mtypes.go) kopieren. </li><li>  Vor kurzem habe ich mich an die Leistung von log4j in Java gewöhnt, daher gibt es nicht genug guten Logger in go. <br>  Wahrscheinlich einen Blick wert auf die Weite des Github, schöne Protokollierung mit Appendern und Formatierern. </li><li>  Ungewöhnliche Arbeit mit Arrays. <br>  Beispielsweise erfolgt die Verkettung durch die <code>append</code> Funktion und die Umwandlung eines Arrays beliebiger Länge in ein Array fester Länge durch <code>copy</code> . </li><li>  <code>switch-case</code> funktioniert wie <code>if-elseif-else</code> - aber dies ist ein interessanter Ansatz, aber wieder Handfläche: <br>  Wenn wir das übliche <code>switch-case</code> Verhalten wünschen, müssen wir jeden Fall <code>fallthrough</code> . <br>  Sie können auch <code>goto</code> , aber bitte nicht! </li><li>  Es gibt keinen ternären Operator und oft ist dies nicht bequem. </li></ul><br><h2 id="chto-dalshe">  Was weiter? </h2><br><p>  So wird der einfachste Peer-To-Peer-Messenger implementiert. </p><br><p>  Die Zapfen sind voll, und Sie können die Benutzerfunktionalität weiter verbessern: Senden von Dateien, Bildern, Audio, Emoticons usw. usw. </p><br><p>  Und Sie können Ihr Protokoll nicht erfinden und die Google-Protokollpuffer verwenden. <br>  Verbinden Sie die Blockchain und schützen Sie sich mit intelligenten Verträgen von Ethereum vor Spam. </p><br><p>  Organisieren Sie bei intelligenten Verträgen Gruppenchats, Kanäle, ein Namenssystem, Avatare und Benutzerprofile. </p><br><p>  Es ist auch wichtig, Seed-Peers auszuführen, NAT-Bypass zu implementieren und Nachrichten von Peer zu Peer zu senden. </p><br><p>  Als Ergebnis erhalten Sie ein gutes Ersatztelegramm / Telefon, Sie müssen nur alle Ihre Freunde dorthin übertragen =) </p><br><h2 id="poleznosti">  Nützlichkeit </h2><br><div class="spoiler">  <b class="spoiler_title">Einige Links</b> <div class="spoiler_text"><p>  Während der Arbeit am Messenger fand ich Seiten interessant für einen Anfänger. <br>  Ich teile sie mit Ihnen: </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">golang.org/doc/</a> - Sprachdokumentation, alles ist einfach, klar und mit Beispielen.  Dieselbe Dokumentation kann lokal mit dem Befehl ausgeführt werden </p><br><pre> <code class="bash hljs">godoc -HTTP=:6060</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gobyexample.com</a> - eine Sammlung einfacher Beispiele </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">golang-book.ru</a> - ein gutes Buch auf Russisch </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">github.com/dariubs/GoBooks</a> ist eine Sammlung von Büchern über Go. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">awesome-go.com</a> - Eine Liste interessanter Bibliotheken, Frameworks und Anwendungen für unterwegs.  Die Kategorisierung ist mehr oder weniger, aber die Beschreibung vieler von ihnen ist sehr selten, was die Suche nach Strg + F nicht erleichtert </p></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de437686/">https://habr.com/ru/post/de437686/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de437674/index.html">3D-Objekterkennungsmethoden für unbemannte Fahrzeuge. Yandex-Bericht</a></li>
<li><a href="../de437676/index.html">Universitäten und Corporate Accelerators als Hebel für den Start eines B2B-Startups in den USA</a></li>
<li><a href="../de437680/index.html">Meine DIY-Sammlung auf Youtube</a></li>
<li><a href="../de437682/index.html">Schreiben eines weiteren Kubernetes-Template-Tools</a></li>
<li><a href="../de437684/index.html">Oberster Algorithmus - Voreingenommenes Kompendium</a></li>
<li><a href="../de437688/index.html">OpenSceneGraph: Grundlegende Programmiertechniken</a></li>
<li><a href="../de437694/index.html">Analyse des Dienstprogramms Files.walkFileTree ();</a></li>
<li><a href="../de437696/index.html">Die Zusammenfassung interessanter Materialien für den mobilen Entwickler # 283 (vom 21. bis 27. Januar)</a></li>
<li><a href="../de437698/index.html">Patentübersetzungsdienst der WIPO - meine Erfahrungen</a></li>
<li><a href="../de437702/index.html">Google Job Interview Parsing: Synonyme Abfragen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>