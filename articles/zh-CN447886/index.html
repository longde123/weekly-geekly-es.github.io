<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔄 🙁 🙋 使用Amazon Athena和Cube.js的Nginx日志分析 👈🏾 🥉 🎳</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="通常，Nginx使用商业产品或开源替代产品（例如Prometheus + Grafana）来监视和分析Nginx的性能。 这对于监视或实时分析是一个不错的选择，但对于历史分析而言却不太方便。 在任何流行的资源上，nginx日志中的数据量都在迅速增长，因此使用更专业的工具来分析大量数据是合乎逻辑的。 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>使用Amazon Athena和Cube.js的Nginx日志分析</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/447886/"><p> 通常，Nginx使用商业产品或开源替代产品（例如Prometheus + Grafana）来监视和分析Nginx的性能。 这对于监视或实时分析是一个不错的选择，但对于历史分析而言却不太方便。 在任何流行的资源上，nginx日志中的数据量都在迅速增长，因此使用更专业的工具来分析大量数据是合乎逻辑的。 </p><br><p>在本文中，我将以Nginx为例，介绍如何使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Athena</a>分析日志，并展示如何使用开源<a href="">cube.js</a>框架从此数据编译分析仪表板。 这是完整的解决方案架构： </p><br><p><img src="https://habrastorage.org/webt/km/xo/3i/kmxo3izommuyzgajw20t6-aolcg.png" alt="建筑学"></p><br><p>  TL：DR； <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">链接到完成的仪表板</a> 。 </p><a name="habracut"></a><br><p> 我们使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Fluentd</a>收集信息，使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">AWS Kinesis Data Firehose</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">AWS Glue</a>进行处理，使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">AWS S3</a>进行存储。 使用此捆绑包，您不仅可以存储nginx日志，还可以存储其他事件以及其他服务的日志。 您可以将某些部分替换为堆栈中的相似部分，例如，您可以直接从nginx将日志写入kinesis，绕过fluentd，或使用logstash做到这一点。 </p><br><h2 id="sobiraem-logi-nginx"> 收集Nginx日志 </h2><br><p> 默认情况下，Nginx日志如下所示： </p><br><pre><code class="bash hljs">4/9/2019 12:58:17 PM1.1.1.1 - - [09/Apr/2019:09:58:17 +0000] <span class="hljs-string"><span class="hljs-string">"GET /sign-up HTTP/2.0"</span></span> 200 9168 <span class="hljs-string"><span class="hljs-string">"https://example.com/sign-in"</span></span> <span class="hljs-string"><span class="hljs-string">"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36"</span></span> <span class="hljs-string"><span class="hljs-string">"-"</span></span> 4/9/2019 12:58:17 PM1.1.1.1 - - [09/Apr/2019:09:58:17 +0000] <span class="hljs-string"><span class="hljs-string">"GET /sign-in HTTP/2.0"</span></span> 200 9168 <span class="hljs-string"><span class="hljs-string">"https://example.com/sign-up"</span></span> <span class="hljs-string"><span class="hljs-string">"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36"</span></span> <span class="hljs-string"><span class="hljs-string">"-"</span></span></code> </pre> <br><p> 可以解析它们，但是修复Nginx配置要容易得多，以便它以JSON显示日志： </p><br><pre> <code class="plaintext hljs">log_format json_combined escape=json '{ "created_at": "$msec", ' '"remote_addr": "$remote_addr", ' '"remote_user": "$remote_user", ' '"request": "$request", ' '"status": $status, ' '"bytes_sent": $bytes_sent, ' '"request_length": $request_length, ' '"request_time": $request_time, ' '"http_referrer": "$http_referer", ' '"http_x_forwarded_for": "$http_x_forwarded_for", ' '"http_user_agent": "$http_user_agent" }'; access_log /var/log/nginx/access.log json_combined;</code> </pre> <br><h3 id="s3-dlya-hraneniya">  S3用于存储 </h3><br><p> 要存储日志，我们将使用S3。 由于Athena可以直接使用S3中的数据，因此您可以在一个地方存储和分析日志。 在本文后面的内容中，我将告诉您如何正确折叠和处理日志，但是首先我们需要在S3中有一个干净的存储桶，该存储桶中不会存储其他任何内容。 提前考虑在哪个区域创建存储桶是值得的，因为Athena并非在所有区域都可用。 </p><br><h3 id="sozdaem-shemu-v-konsoli-athena"> 在Athena控制台中创建图表 </h3><br><p> 在Athena中创建一个用于日志的表。 如果您打算使用Kinesis Firehose，则写作和阅读都需要它。 打开Athena控制台并创建一个表： </p><br><div class="spoiler">  <b class="spoiler_title">SQL表创建</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXTERNAL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> <span class="hljs-string"><span class="hljs-string">`kinesis_logs_nginx`</span></span>( <span class="hljs-string"><span class="hljs-string">`created_at`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>, <span class="hljs-string"><span class="hljs-string">`remote_addr`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-string"><span class="hljs-string">`remote_user`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-string"><span class="hljs-string">`request`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-string"><span class="hljs-string">`status`</span></span> <span class="hljs-built_in"><span class="hljs-built_in">int</span></span>, <span class="hljs-string"><span class="hljs-string">`bytes_sent`</span></span> <span class="hljs-built_in"><span class="hljs-built_in">int</span></span>, <span class="hljs-string"><span class="hljs-string">`request_length`</span></span> <span class="hljs-built_in"><span class="hljs-built_in">int</span></span>, <span class="hljs-string"><span class="hljs-string">`request_time`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>, <span class="hljs-string"><span class="hljs-string">`http_referrer`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-string"><span class="hljs-string">`http_x_forwarded_for`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-string"><span class="hljs-string">`http_user_agent`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">ROW</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FORMAT</span></span> SERDE <span class="hljs-string"><span class="hljs-string">'org.apache.hadoop.hive.ql.io.orc.OrcSerde'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STORED</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> INPUTFORMAT <span class="hljs-string"><span class="hljs-string">'org.apache.hadoop.hive.ql.io.orc.OrcInputFormat'</span></span> OUTPUTFORMAT <span class="hljs-string"><span class="hljs-string">'org.apache.hadoop.hive.ql.io.orc.OrcOutputFormat'</span></span> LOCATION <span class="hljs-string"><span class="hljs-string">'s3://&lt;YOUR-S3-BUCKET&gt;'</span></span> TBLPROPERTIES (<span class="hljs-string"><span class="hljs-string">'has_encrypted_data'</span></span>=<span class="hljs-string"><span class="hljs-string">'false'</span></span>);</code> </pre> </div></div><br><h3 id="sozdaem-kinesis-firehose-stream"> 创建Kinesis Firehose流 </h3><br><p>  Kinesis Firehose将以选定的格式将从Nginx接收的数据写入S3，并分成YYYY / MM / DD / HH格式的目录。 这在读取数据时很有用。 当然，您可以从fluentd直接写入S3，但是在这种情况下，您必须编写JSON，由于文件大而效率低。 此外，在使用PrestoDB或Athena时，JSON是最慢的数据格式。 因此，打开Kinesis Firehose控制台，单击“创建交付流”，在“交付”字段中选择“直接PUT”： </p><br><p><img src="https://habrastorage.org/webt/xe/vb/mc/xevbmcpntl3aqkgg50lh844gxe4.png" alt="Kinesis Firehose控制台1"></p><br><p> 在下一个标签中，选择“记录格式转换”-“启用”，然后选择“ Apache ORC”作为记录格式。 根据<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Owen O'Malley的</a>说法，这是PrestoDB和Athena的最佳格式。 作为图表，我们指出了我们在上面创建的表。 请注意，您可以在运动学中指定任何S3位置，仅使用表中的方案。 但是，如果指定另一个S3位置，则无法从该表读取这些记录。 </p><br><p><img src="https://habrastorage.org/webt/vu/y1/ro/vuy1royrwm3pb3jle5nvclzskd0.png" alt="Kinesis Firehose控制台2"></p><br><p> 我们选择S3进行存储，并选择之前创建的存储桶。 我将在稍后讨论的Aws Glue Crawler不知道如何在S3存储桶中使用前缀，因此将其留空很重要。 </p><br><p><img src="https://habrastorage.org/webt/jq/0u/bs/jq0ubs7jvqmehbfqaaycrmxryso.png" alt="Kinesis消防水带控制台3"></p><br><p> 其余选项可以根据您的负载进行更改，我通常使用默认选项。 请注意，S3压缩不可用，但是ORC默认使用本机压缩。 </p><br><h3 id="fluentd"> 流利的 </h3><br><p> 现在我们已经配置了日志的存储和接收，您需要配置发送。 因为我喜欢Ruby，所以我们将使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Fluentd</a> ，但是您可以使用Logstash或将日志直接发送到kinesis。 您可以通过几种方式启动Fluentd服务器，我将讨论docker，因为它既简单又方便。 </p><br><p> 首先，我们需要fluent.conf配置文件。 创建它并添加源： </p><br><br><p> 向前输入 <br> 端口24224 <br> 绑定0.0.0.0 </p><br><br><p> 现在您可以启动Fluentd服务器。 如果您需要更高级的配置，则<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Docker Hub</a>会提供详细的指南，包括如何组装映像。 </p><br><pre> <code class="bash hljs">$ docker run \ -d \ -p 24224:24224 \ -p 24224:24224/udp \ -v /data:/fluentd/<span class="hljs-built_in"><span class="hljs-built_in">log</span></span> \ -v &lt;PATH-TO-FLUENT-CONF&gt;:/fluentd/etc fluentd \ -c /fluentd/etc/fluent.conf fluent/fluentd:stable</code> </pre> <br><p> 此配置在发送前使用<code>/fluentd/log</code>路径缓存日志。 您可以不这样做，但是随后重新启动时，您可能会丢失过多劳力所缓存的所有内容。 也可以使用任何端口，24224是默认的Fluentd端口。 </p><br><p> 现在我们已经运行了Fluentd，我们可以在此处发送Nginx日志了。 我们通常在Docker容器中运行Nginx，在这种情况下，Docker具有Fluentd的本机日志驱动程序： </p><br><pre> <code class="bash hljs">$ docker run \ --<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>-driver=fluentd \ --<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>-opt fluentd-address=&lt;FLUENTD-SERVER-ADDRESS&gt;\ --<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>-opt tag=\<span class="hljs-string"><span class="hljs-string">"{{.Name}}\" \ -v /some/content:/usr/share/nginx/html:ro \ -d \ nginx</span></span></code> </pre> <br><p> 如果以其他方式运行Nginx，则可以使用日志文件，Fluentd具有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文件尾插件</a> 。 </p><br><p> 将上面配置的日志解析添加到Fluent配置中： </p><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">filter</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">YOUR-NGINX-TAG.</span></span></span><span class="hljs-tag">*&gt;</span></span> @type parser key_name log emit_invalid_record_to_error false <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">parse</span></span></span><span class="hljs-tag">&gt;</span></span> @type json <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">parse</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">filter</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p> 并使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">kinesis firehose插件</a>将日志发送到Kinesis： </p><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">match</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">YOUR-NGINX-TAG.</span></span></span><span class="hljs-tag">*&gt;</span></span> @type kinesis_firehose region region delivery_stream_name <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">YOUR-KINESIS-STREAM-NAME</span></span></span><span class="hljs-tag">&gt;</span></span> aws_key_id <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">YOUR-AWS-KEY-ID</span></span></span><span class="hljs-tag">&gt;</span></span> aws_sec_key <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">YOUR_AWS-SEC_KEY</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">match</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><h2 id="athena"> 雅典娜 </h2><br><p> 如果正确配置了所有内容，则过一会儿（默认情况下，Kinesis会每10分钟写入一次接收到的数据），您应该会在S3中看到日志文件。 在Kinesis Firehose的“监视”菜单中，您可以查看向S3写入了多少数据以及错误。 不要忘记为Kinesis角色授予对S3存储桶的写访问权限。 如果Kinesis无法解析某些内容，他将在同一存储桶中添加错误。 </p><br><p> 现在您可以在Athena中查看数据。 让我们找到一些错误的新查询： </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> <span class="hljs-string"><span class="hljs-string">"db_name"</span></span>.<span class="hljs-string"><span class="hljs-string">"table_name"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">status</span></span> &gt; <span class="hljs-number"><span class="hljs-number">499</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> created_at <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>;</code> </pre> <br><h3 id="skanirovanie-vseh-zapisey-na-kazhdyy-zapros"> 扫描每个请求的所有记录 </h3><br><p> 现在，我们的日志已在ORC中的S3中进行处理和堆叠，压缩并准备进行分析。  Kinesis Firehose甚至每小时都将它们放在目录中。 但是，在不对表进行分区的情况下，Athena会为每个查询加载所有时间的数据（极少数例外）。 这是一个大问题，原因有两个： </p><br><ul><li> 数据量在不断增长，减慢了查询速度； </li><li> 雅典娜是根据扫描的数据量计费的，每个请求至少10 MB。 </li></ul><br><p> 为了解决这个问题，我们使用AWS Glue Crawler，它将扫描S3中的数据并将分区信息记录在Glue Metastore中。 这将使我们能够将分区用作Athena中请求的筛选器，并且仅扫描请求中指定的目录。 </p><br><h3 id="nastraivaem-amazon-glue-crawler"> 自定义Amazon Glue Crawler </h3><br><p>  Amazon Glue Crawler扫描S3存储桶中的所有数据并创建分区表。 从AWS Glue控制台创建一个Glue Crawler，然后添加存储数据的存储桶。 您可以将一个搜寻器用于多个存储桶，在这种情况下，它将在指定的数据库中创建名称与存储桶名称匹配的表。 如果您打算一直使用此数据，请确保调整Crawler启动时间表以适合您的需求。 我们对所有表使用一个Crawler，该表每小时运行一次。 </p><br><h3 id="particirovannye-tablicy"> 分区表 </h3><br><p> 首次启动搜寻器后，每个已扫描存储区的表应出现在设置中指定的数据库中。 打开Athena控制台，找到带有Nginx日志的表。 让我们尝试阅读一些内容： </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> <span class="hljs-string"><span class="hljs-string">"default"</span></span>.<span class="hljs-string"><span class="hljs-string">"part_demo_kinesis_bucket"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span>( partition_0 = <span class="hljs-string"><span class="hljs-string">'2019'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> partition_1 = <span class="hljs-string"><span class="hljs-string">'04'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> partition_2 = <span class="hljs-string"><span class="hljs-string">'08'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> partition_3 = <span class="hljs-string"><span class="hljs-string">'06'</span></span> );</code> </pre> <br><p> 该查询将选择2019年4月8日上午6点至上午7点收到的所有记录。 但是，比仅从非分区表中读取数据更有效？ 让我们通过按时间戳过滤找到并选择相同的记录： </p><br><p><img src="https://habrastorage.org/webt/mu/bg/me/mubgmef262bxyte5dsqsa1q_hag.png" alt="请求无分区"></p><br><p> 数据集上的数据只有3.59秒和244.34兆字节，其中只有一个星期的日志。 让我们尝试按分区进行过滤： </p><br><p><img src="https://habrastorage.org/webt/9-/n4/dc/9-n4dczjdvcrspm0zbypq-ul5cs.png" alt="分区过滤器请求"></p><br><p> 更快一点，但最重要的是-只有1.23兆字节的数据！ 如果价格不低于每个请求10兆字节，则价格会便宜得多。 但无论如何还是要好得多，在大型数据集上，差异将更加明显。 </p><br><h2 id="sobiraem-deshbord-s-pomoschyu-cubejs"> 使用Cube.js构建仪表板 </h2><br><p> 要构建仪表板，我们使用Cube.js分析框架。 它具有很多功能，但我们感兴趣的是两个：在分区上自动使用过滤器和预先聚合数据的功能。 它使用用Javascript编写的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">数据模式</a>来生成SQL并执行数据库查询。 我们所要做的就是指示如何在数据模式中使用分区过滤器。 </p><br><p> 让我们创建一个新的应用程序Cube.js。 由于我们已经使用过AWS堆栈，因此使用Lambda进行部署是合乎逻辑的。 如果计划在Heroku或Docker中托管Cube.js后端，则可以使用express模板进行生成。 该文档描述了其他<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">托管方法</a> 。 </p><br><pre> <code class="bash hljs">$ npm install -g cubejs-cli $ cubejs create nginx-log-analytics -t serverless -d athena</code> </pre> <br><p> 环境变量用于在cube.js中配置对数据库的访问。 生成器将创建一个.env文件，您可以在其中指定<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Athena</a>的密钥。 </p><br><p> 现在我们需要<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">一个数据方案，</a>在其中可以指示日志的存储方式。 您可以在此处指定如何读取仪表板的指标。 </p><br><p> 在<code>schema</code>目录中，创建<code>Logs.js</code>文件。 这是nginx的示例数据模型： </p><br><div class="spoiler">  <b class="spoiler_title">型号代码</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> partitionFilter = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">from</span></span></span></span><span class="hljs-function"><span class="hljs-params">, to</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-string"><span class="hljs-string">` date(from_iso8601_timestamp(</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">from</span></span></span></span><span class="hljs-string"><span class="hljs-subst">}</span></span></span><span class="hljs-string">)) &lt;= date_parse(partition_0 || partition_1 || partition_2, '%Y%m%d') AND date(from_iso8601_timestamp(</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${to}</span></span></span><span class="hljs-string">)) &gt;= date_parse(partition_0 || partition_1 || partition_2, '%Y%m%d') `</span></span> cube(<span class="hljs-string"><span class="hljs-string">`Logs`</span></span>, { <span class="hljs-attr"><span class="hljs-attr">sql</span></span>: <span class="hljs-string"><span class="hljs-string">` select * from part_demo_kinesis_bucket WHERE </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${FILTER_PARAMS.Logs.createdAt.filter(partitionFilter)}</span></span></span><span class="hljs-string"> `</span></span>, <span class="hljs-attr"><span class="hljs-attr">measures</span></span>: { <span class="hljs-attr"><span class="hljs-attr">count</span></span>: { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">`count`</span></span>, }, <span class="hljs-attr"><span class="hljs-attr">errorCount</span></span>: { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">`count`</span></span>, <span class="hljs-attr"><span class="hljs-attr">filters</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">sql</span></span>: <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${CUBE.isError}</span></span></span><span class="hljs-string"> = 'Yes'`</span></span> } ] }, <span class="hljs-attr"><span class="hljs-attr">errorRate</span></span>: { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">`number`</span></span>, <span class="hljs-attr"><span class="hljs-attr">sql</span></span>: <span class="hljs-string"><span class="hljs-string">`100.0 * </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${errorCount}</span></span></span><span class="hljs-string"> / </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${count}</span></span></span><span class="hljs-string">`</span></span>, <span class="hljs-attr"><span class="hljs-attr">format</span></span>: <span class="hljs-string"><span class="hljs-string">`percent`</span></span> } }, <span class="hljs-attr"><span class="hljs-attr">dimensions</span></span>: { <span class="hljs-attr"><span class="hljs-attr">status</span></span>: { <span class="hljs-attr"><span class="hljs-attr">sql</span></span>: <span class="hljs-string"><span class="hljs-string">`status`</span></span>, <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">`number`</span></span> }, <span class="hljs-attr"><span class="hljs-attr">isError</span></span>: { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">`string`</span></span>, <span class="hljs-attr"><span class="hljs-attr">case</span></span>: { <span class="hljs-attr"><span class="hljs-attr">when</span></span>: [{ <span class="hljs-attr"><span class="hljs-attr">sql</span></span>: <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${CUBE}</span></span></span><span class="hljs-string">.status &gt;= 400`</span></span>, <span class="hljs-attr"><span class="hljs-attr">label</span></span>: <span class="hljs-string"><span class="hljs-string">`Yes`</span></span> }], <span class="hljs-attr"><span class="hljs-attr">else</span></span>: { <span class="hljs-attr"><span class="hljs-attr">label</span></span>: <span class="hljs-string"><span class="hljs-string">`No`</span></span> } } }, <span class="hljs-attr"><span class="hljs-attr">createdAt</span></span>: { <span class="hljs-attr"><span class="hljs-attr">sql</span></span>: <span class="hljs-string"><span class="hljs-string">`from_unixtime(created_at)`</span></span>, <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">`time`</span></span> } } });</code> </pre> </div></div><br><p> 在这里，我们使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">FILTER_PARAMS</a>变量来生成带有分区过滤器的SQL查询。 </p><br><p> 我们还指定了要显示在仪表板上的指标和参数，并指定了预聚合。  Cube.js将使用预聚合的数据创建其他表，并将在数据可用时自动更新。 这不仅加快了请求的速度，而且降低了使用Athena的成本。 </p><br><p> 将此信息添加到数据模式文件： </p><br><pre> <code class="javascript hljs">preAggregations: { <span class="hljs-attr"><span class="hljs-attr">main</span></span>: { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">`rollup`</span></span>, <span class="hljs-attr"><span class="hljs-attr">measureReferences</span></span>: [count, errorCount], <span class="hljs-attr"><span class="hljs-attr">dimensionReferences</span></span>: [isError, status], <span class="hljs-attr"><span class="hljs-attr">timeDimensionReference</span></span>: createdAt, <span class="hljs-attr"><span class="hljs-attr">granularity</span></span>: <span class="hljs-string"><span class="hljs-string">`day`</span></span>, <span class="hljs-attr"><span class="hljs-attr">partitionGranularity</span></span>: <span class="hljs-string"><span class="hljs-string">`month`</span></span>, <span class="hljs-attr"><span class="hljs-attr">refreshKey</span></span>: { <span class="hljs-attr"><span class="hljs-attr">sql</span></span>: FILTER_PARAMS.Logs.createdAt.filter(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">from</span></span></span></span><span class="hljs-function"><span class="hljs-params">, to</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-string"><span class="hljs-string">`select CASE WHEN from_iso8601_timestamp(</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${to}</span></span></span><span class="hljs-string">) + interval '3' day &gt; now() THEN date_trunc('hour', now()) END`</span></span> ) } } }</code> </pre> <br><p> 在此模型中，我们指出有必要为所有使用的指标预先汇总数据，并使用每月分区。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">对预聚合</a>进行<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">分区</a>可以大大加快数据收集和更新的速度。 </p><br><p> 现在我们可以组装一个仪表板了！ </p><br><p>  Cube.js后端为流行的前端框架提供了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">REST API</a>和一组客户端库。 我们将使用客户端的React版本来构建仪表板。  Cube.js仅提供数据，因此我们需要一个可视化库-我喜欢<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">recharts</a> ，但是您可以使用任何一个。 </p><br><p>  Cube.js服务器接受<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">JSON格式</a>的请求，该请求指示必要的指标。 例如，要计算Nginx每天给出的错误数量，您需要发送以下请求： </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"measures"</span></span>: [<span class="hljs-string"><span class="hljs-string">"Logs.errorCount"</span></span>], <span class="hljs-attr"><span class="hljs-attr">"timeDimensions"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"dimension"</span></span>: <span class="hljs-string"><span class="hljs-string">"Logs.createdAt"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"dateRange"</span></span>: [<span class="hljs-string"><span class="hljs-string">"2019-01-01"</span></span>, <span class="hljs-string"><span class="hljs-string">"2019-01-07"</span></span>], <span class="hljs-attr"><span class="hljs-attr">"granularity"</span></span>: <span class="hljs-string"><span class="hljs-string">"day"</span></span> } ] }</code> </pre> <br><p> 通过NPM安装Cube.js客户端和React组件库： </p><br><pre> <code class="bash hljs">$ npm i --save @cubejs-client/core @cubejs-client/react</code> </pre> <br><p> 我们导入<code>cubejs</code>和QueryRenderer组件以卸载数据，并收集仪表板： </p><br><div class="spoiler">  <b class="spoiler_title">仪表板代码</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { LineChart, Line, XAxis, YAxis } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'recharts'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cubejs <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@cubejs-client/core'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { QueryRenderer } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@cubejs-client/react'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> cubejsApi = cubejs( <span class="hljs-string"><span class="hljs-string">'YOUR-CUBEJS-API-TOKEN'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">apiUrl</span></span>: <span class="hljs-string"><span class="hljs-string">'http://localhost:4000/cubejs-api/v1'</span></span> }, ); <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> &lt;QueryRenderer query={{ measures: [</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'Logs.errorCount'</span></span></span></span><span class="hljs-function"><span class="hljs-params">], timeDimensions: [{ dimension: </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'Logs.createdAt'</span></span></span></span><span class="hljs-function"><span class="hljs-params">, dateRange: [</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'2019-01-01'</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'2019-01-07'</span></span></span></span><span class="hljs-function"><span class="hljs-params">], granularity: </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'day'</span></span></span></span><span class="hljs-function"><span class="hljs-params"> }] }} cubejsApi={cubejsApi} render={({ resultSet }</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!resultSet) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'Loading...'</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( &lt;LineChart data={resultSet.rawData()}&gt; &lt;XAxis dataKey="Logs.createdAt"/&gt; &lt;YAxis/&gt; &lt;Line type="monotone" dataKey="Logs.errorCount" stroke="#8884d8"/&gt; &lt;/LineChart&gt; ); }} /&gt; ) }</code> </pre> </div></div><br><p> 仪表板源位于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CodeSandbox上</a> 。 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN447886/">https://habr.com/ru/post/zh-CN447886/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN447876/index.html">一切都非常糟糕，或者是一种新型的交通拦截</a></li>
<li><a href="../zh-CN447878/index.html">使用PVS-Studio检查rdesktop和xrdp</a></li>
<li><a href="../zh-CN447880/index.html">使用PVS-Studio分析仪验证rdesktop和xrdp</a></li>
<li><a href="../zh-CN447882/index.html">网络工具，还是从哪里开始？</a></li>
<li><a href="../zh-CN447884/index.html">我们了解了5G如何在街道和室内毫米范围内工作</a></li>
<li><a href="../zh-CN447890/index.html">谢谢上帝，我不是经理</a></li>
<li><a href="../zh-CN447892/index.html">两个新的PHDays竞赛：IDS绕过和工厂入侵</a></li>
<li><a href="../zh-CN447894/index.html">MODX摘要＃3（2019年3月25日至4月8日）</a></li>
<li><a href="../zh-CN447896/index.html">粗略图片的照片：NVIDIA GauGAN神经网络的工作原理</a></li>
<li><a href="../zh-CN447898/index.html">经验丰富的哲学家或有竞争力的.NET编程</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>