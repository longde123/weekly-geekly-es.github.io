<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëÜ ü§òüèº ‚ùóÔ∏è Das Buch "Distributed Systems. Entwurfsmuster üßúüèΩ üëàüèº üíú</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die moderne Welt ist ohne den Einsatz verteilter Systeme einfach nicht denkbar. Selbst die einfachste mobile Anwendung verf√ºgt √ºber eine API, √ºber die...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Das Buch "Distributed Systems. Entwurfsmuster</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/445362/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/3r/m1/uj/3rm1ujuwrrda_3m1tyol46kyfh4.jpeg" align="left" alt="Bild"></a>  Die moderne Welt ist ohne den Einsatz verteilter Systeme einfach nicht denkbar.  Selbst die einfachste mobile Anwendung verf√ºgt √ºber eine API, √ºber die eine Verbindung zum Cloud-Speicher hergestellt wird.  Der Entwurf verteilter Systeme ist jedoch immer noch eine Kunst, keine exakte Wissenschaft.  Die Notwendigkeit, eine ernsthafte Grundlage zu schaffen, ist l√§ngst √ºberf√§llig. Wenn Sie Vertrauen in die Erstellung, Unterst√ºtzung und den Betrieb verteilter Systeme gewinnen m√∂chten, beginnen Sie mit diesem Buch! <br><br>  Brendan Burns, ein renommierter Spezialist f√ºr Cloud-Technologien und Kubernetes, legt in dieser kleinen Arbeit das absolute Minimum fest, das f√ºr das ordnungsgem√§√üe Design verteilter Systeme erforderlich ist.  Dieses Buch beschreibt die zeitlosen Muster beim Entwerfen verteilter Systeme.  Es wird Ihnen helfen, solche Systeme nicht nur von Grund auf neu zu erstellen, sondern auch vorhandene Systeme effektiv zu konvertieren. <br><br><a name="habracut"></a><br><h3>  Auszug.  Dekorateur Muster.  Konvertieren Sie eine Anfrage oder Antwort </h3><br>  FaaS ist ideal, wenn Sie einfache Funktionen ben√∂tigen, die Eingabedaten verarbeiten und dann an andere Dienste √ºbertragen.  Diese Art von Muster kann verwendet werden, um HTTP-Anforderungen zu erweitern oder zu dekorieren, die von einem anderen Dienst gesendet oder empfangen werden.  Dieses Muster ist schematisch in Fig. 1 gezeigt.  8.1. <br><br>  In Programmiersprachen gibt es √ºbrigens mehrere Analogien zu diesem Muster.  Insbesondere verf√ºgt Python √ºber Funktionsdekoratoren, die den Anforderungs- oder Antwortdekoratoren funktional √§hnlich sind.  Da Dekorationstransformationen keinen Status speichern und bei der Entwicklung des Dienstes h√§ufig ex-facto hinzugef√ºgt werden, eignen sie sich ideal f√ºr die Implementierung als FaaS.  Dar√ºber hinaus bedeutet die FaaS-Leichtigkeit, dass Sie mit verschiedenen Dekorateuren experimentieren k√∂nnen, bis Sie einen finden, der sich besser in den Service einf√ºgt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/li/lc/ya/lilcyax3ox52bwtihgtfqb7qm40.png" alt="Bild"></div><br>  Das Hinzuf√ºgen von Standardwerten zu den Eingabeparametern von HTTP-RESTful-API-Anforderungen zeigt die Vorteile des Decorator-Musters.  Viele API-Anforderungen enthalten Felder, die mit angemessenen Werten ausgef√ºllt werden m√ºssen, wenn sie nicht vom Aufrufer angegeben wurden.  Sie m√∂chten beispielsweise, dass das Feld standardm√§√üig auf true gesetzt ist.  Dies ist mit klassischem JSON schwierig zu erreichen, da das standardm√§√üige leere Feld null ist, was normalerweise als falsch interpretiert wird.  Um dieses Problem zu l√∂sen, k√∂nnen Sie die Logik des Ersetzens von Standardwerten entweder vor dem API-Server oder im Anwendungscode hinzuf√ºgen (z. B. if (field == null) field = true).  Beide Ans√§tze sind jedoch nicht optimal, da der Standardsubstitutionsmechanismus konzeptionell unabh√§ngig von der Anforderungsverarbeitung ist.  Stattdessen k√∂nnen wir das FaaS Decorator-Muster verwenden, das die Anforderung auf dem Weg zwischen dem Benutzer und der Service-Implementierung transformiert. <br><br>  In Anbetracht dessen, was weiter oben im Abschnitt √ºber Einzelknotenmuster gesagt wurde, fragen Sie sich m√∂glicherweise, warum wir den Standardsubstitutionsdienst nicht in Form eines Adaptercontainers entworfen haben.  Dieser Ansatz ist sinnvoll, bedeutet aber auch, dass die Skalierung des Standard-Suchdienstes und die Skalierung des API-Dienstes selbst voneinander abh√§ngig werden.  Das Ersetzen von Standardwerten ist eine rechnerisch einfache Operation, f√ºr die Sie h√∂chstwahrscheinlich nicht viele Instanzen des Dienstes ben√∂tigen. <br><br><blockquote> In den Beispielen in diesem Kapitel verwenden wir das kubeless FaaS-Framework (https://github.com/kubeless/kubeless).  Kubeless wird zus√§tzlich zum Kubernetes Container Orchestrator-Dienst bereitgestellt.  Wenn Sie den Kubernetes-Cluster bereits vorbereitet haben, fahren Sie mit der Installation von Kubeless fort, die von der entsprechenden Site (https://github.com/kubeless/kubeless/releases) heruntergeladen werden kann.  Sobald Sie die ausf√ºhrbare Datei kubeless haben, k√∂nnen Sie sie mit dem Befehl kubeless install im Cluster installieren. <br><br>  Kubeless wird als Kubernetes API-Add-On eines Drittanbieters installiert.  Dies bedeutet, dass es nach der Installation als Teil des Befehlszeilentools kubectl verwendet werden kann.  Beispielsweise k√∂nnen die im Cluster bereitgestellten Funktionen durch Ausf√ºhren des Befehls kubectl get functions angezeigt werden.  Derzeit sind in Ihrem Cluster keine Funktionen bereitgestellt. </blockquote><br><h3>  Werkstatt  Ersetzen von Standardwerten vor der Anforderungsverarbeitung </h3><br>  Sie k√∂nnen die N√ºtzlichkeit des Decorator-Musters in FaaS am Beispiel des Ersetzens von Standardwerten in einem RESTful-Aufruf durch Parameter demonstrieren, deren Werte nicht vom Benutzer festgelegt wurden.  Mit FaaS ist das ganz einfach.  Die Standard-Suchfunktion ist in Python geschrieben: <br><br><pre><code class="plaintext hljs">#  -,   #   def handler(context): #    obj = context.json #   "name" ,   #   if obj.get("name", None) is None: obj["name"] = random_name() #    'color',   #   'blue' if obj.get("color", None) is None: obj["color"] = "blue" #  API-     #   #    return call_my_api(obj)</code> </pre> <br>  Speichern Sie diese Funktion in einer Datei namens defaults.py.  Denken Sie daran, den Aufruf call_my_api durch die gew√ºnschte API zu ersetzen.  Diese Standardsubstitutionsfunktion kann mit dem folgenden Befehl als kubeless-Funktion registriert werden: <br><br><pre> <code class="plaintext hljs">kubeless function deploy add-defaults \ --runtime python27 \ --handler defaults.handler \ --from-file defaults.py \ --trigger-http</code> </pre> <br>  Zum Testen k√∂nnen Sie das kubeless-Tool verwenden: <br><br><pre> <code class="plaintext hljs">kubeless function call add-defaults --data '{"name": "foo"}'</code> </pre> <br>  Das Decorator-Muster zeigt, wie einfach es ist, vorhandene APIs anzupassen und um zus√§tzliche Funktionen wie das √úberpr√ºfen oder Ersetzen von Standardwerten zu erweitern. <br><br><h3>  Ereignisbehandlung </h3><br>  Die meisten Systeme sind abfrageorientiert - sie verarbeiten kontinuierliche Fl√ºsse von Benutzer- und API-Anforderungen.  Trotzdem gibt es einige ereignisorientierte Systeme.  Der Unterschied zwischen der Anfrage und dem Ereignis scheint mir im Konzept der Sitzung zu liegen.  Anfragen sind Teil eines gr√∂√üeren Interaktionsprozesses (Sitzung).  Im allgemeinen Fall ist jede Benutzeranforderung Teil des Interaktionsprozesses mit einer Webanwendung oder der API als Ganzes.  Ich sehe Ereignisse als "einmaliger", asynchroner Natur.  Ereignisse sind wichtig und sollten entsprechend behandelt werden, aber sie werden aus dem Hauptkontext der Interaktion herausgerissen und die Antwort darauf kommt erst nach einiger Zeit.  Ein Beispiel f√ºr ein Ereignis ist das Abonnement eines Benutzers f√ºr einen bestimmten Dienst, wodurch ein Begr√º√üungsschreiben gesendet wird.  Hochladen einer Datei in einen freigegebenen Ordner, wodurch Benachrichtigungen an alle Benutzer dieses Ordners gesendet werden;  oder sogar den Computer auf einen Neustart vorzubereiten, der den Bediener oder das automatisierte System dar√ºber informiert, dass geeignete Ma√ünahmen erforderlich sind. <br><br>  Da diese Ereignisse weitgehend unabh√§ngig sind und keinen internen Zustand haben und ihre H√§ufigkeit sehr variabel ist, eignen sie sich ideal f√ºr die Arbeit in ereignisorientierten FaaS-Architekturen.  Sie werden h√§ufig neben dem "Battle" -Anwendungsserver bereitgestellt, um zus√§tzliche Funktionen bereitzustellen oder um Daten im Hintergrund als Reaktion auf neu auftretende Ereignisse zu verarbeiten.  Da dem Service st√§ndig neue Arten von verarbeiteten Ereignissen hinzugef√ºgt werden, sind sie aufgrund der Einfachheit der Funktionsbereitstellung f√ºr die Implementierung von Ereignishandlern geeignet.  Und da jedes Ereignis konzeptionell unabh√§ngig von den anderen ist, k√∂nnen wir durch die erzwungene Schw√§chung der Beziehungen innerhalb eines auf Funktionen basierenden Systems seine konzeptionelle Komplexit√§t reduzieren, sodass sich der Entwickler auf die Schritte konzentrieren kann, die zur Verarbeitung nur eines bestimmten Ereignistyps erforderlich sind. <br><br>  Ein spezielles Beispiel f√ºr die Integration einer ereignisorientierten Komponente in einen vorhandenen Service ist die Implementierung der Zwei-Faktor-Authentifizierung.  In diesem Fall ist das Ereignis die Anmeldung des Benutzers.  Ein Dienst kann ein Ereignis f√ºr diese Aktion generieren und an eine Handlerfunktion √ºbergeben.  Der Prozessor sendet ihm auf der Grundlage des √ºbertragenen Codes und der Kontaktdaten des Benutzers einen Authentifizierungscode in Form einer Textnachricht. <br><br><h3>  Werkstatt  Implementierung der Zwei-Faktor-Authentifizierung </h3><br>  Die Zwei-Faktor-Authentifizierung zeigt an, dass der Benutzer zum Betreten des Systems etwas ben√∂tigt, das er kennt (z. B. ein Kennwort), und etwas, das er hat (z. B. eine Telefonnummer).  Die Zwei-Faktor-Authentifizierung ist viel besser als nur ein Passwort, da ein Angreifer sowohl Ihr Passwort als auch Ihre Telefonnummer stehlen muss, um Zugriff zu erhalten. <br><br>  Wenn Sie die Implementierung der Zwei-Faktor-Authentifizierung planen, m√ºssen Sie eine Anforderung zum Generieren eines Zufallscodes verarbeiten, beim Anmeldedienst registrieren und eine Nachricht an den Benutzer senden.  Sie k√∂nnen Code, der diese Funktionalit√§t implementiert, direkt in den Anmeldedienst selbst einf√ºgen.  Dies kompliziert das System und macht es monolithischer.  Das Senden einer Nachricht sollte gleichzeitig mit dem Code erfolgen, der die Anmeldewebseite generiert, was zu einer gewissen Verz√∂gerung f√ºhren kann.  Diese Verz√∂gerung verschlechtert die Qualit√§t der Benutzerinteraktion mit dem System. <br><br>  Es ist besser, einen FaaS-Dienst zu erstellen, der asynchron eine Zufallszahl generiert, diese beim Anmeldedienst registriert und an das Telefon des Benutzers sendet.  Somit kann der Anmeldeserver einfach eine asynchrone Anforderung an den FaaS-Dienst ausf√ºhren, die parallel die relativ langsame Aufgabe des Registrierens und Sendens des Codes ausf√ºhrt. <br>  Beachten Sie den folgenden Code, um zu sehen, wie dies funktioniert: <br><br><pre> <code class="plaintext hljs">def two_factor(context): #     code = random.randint(1 00000, 9 99999) #        user = context.json["user"] register_code_with_login_service(user, code) #      Twillio account = "my-account-sid" token = "my-token" client = twilio.rest.Client(account, token) user_number = context.json["phoneNumber"] msg = ", {},   : {}.".format(user, code) message = client.api.account.messages.create(to=user_number, from_="+1 20652 51212", body=msg) return {"status": "ok"}</code> </pre> <br>  Dann registrieren Sie FaaS in kubeless: <br><br><pre> <code class="plaintext hljs">kubeless function deploy add-two-factor \ --runtime python27 \ --handler two_factor.two_factor \ --from-file two_factor.py \ --trigger-http</code> </pre> <br>  Eine Instanz dieser Funktion kann asynchron aus clientseitigem JavaScript-Code generiert werden, nachdem der Benutzer das richtige Kennwort eingegeben hat.  Die Weboberfl√§che kann sofort die Seite zur Eingabe des Codes anzeigen, und der Benutzer kann ihn, sobald er den Code erh√§lt, √ºber den Anmeldedienst informieren, bei dem dieser Code bereits registriert ist. <br><br>  Der FaaS-Ansatz hat die Entwicklung eines einfachen, asynchronen, ereignisorientierten Dienstes, der initiiert wird, wenn sich ein Benutzer am System anmeldet, erheblich erleichtert. <br><br><h3>  Eventf√∂rderer </h3><br>  Es gibt eine Reihe von Anwendungen, die in der Tat leichter als Pipeline lose gekoppelter Ereignisse zu betrachten sind.  Ereignis-Pipelines √§hneln oft den guten alten Flussdiagrammen.  Sie k√∂nnen als gerichteter Graph der Synchronisation verwandter Ereignisse dargestellt werden.  Im Rahmen des Ereignis-Pipeline-Musters entsprechen Knoten Funktionen, und die sie verbindenden B√∂gen entsprechen HTTP-Anforderungen oder anderen Arten von Netzwerkaufrufen. <br><br>  Zwischen den Elementen des Containers gibt es in der Regel keinen gemeinsamen Zustand, es kann jedoch einen gemeinsamen Kontext oder einen anderen Bezugspunkt geben, auf dessen Grundlage die Suche im Speicher durchgef√ºhrt wird. <br><br>  Was ist der Unterschied zwischen einer solchen Pipeline- und einer Microservice-Architektur?  Es gibt zwei wichtige Unterschiede.  Der erste und wichtigste Unterschied zwischen Servicefunktionen und st√§ndig laufenden Services besteht darin, dass Ereignis-Pipelines im Wesentlichen ereignisgesteuert sind.  Im Gegensatz dazu impliziert die Microservice-Architektur eine Reihe von st√§ndig funktionierenden Services.  Dar√ºber hinaus k√∂nnen Ereignis-Pipelines asynchron sein und eine Vielzahl von Ereignissen binden.  Es ist schwer vorstellbar, wie die Antragsgenehmigung von Jira in eine Microservice-Anwendung integriert werden kann.  Gleichzeitig ist es leicht vorstellbar, wie es in die Ereignis-Pipeline integriert wird. <br><br>  Betrachten Sie als Beispiel eine Pipeline, in der das Quellereignis das Laden von Code in ein Versionskontrollsystem ist.  Dieses Ereignis f√ºhrt zu einer Neuerstellung des Codes.  Die Montage kann einige Minuten dauern. Danach wird ein Ereignis generiert, das die Testfunktion der zusammengesetzten Anwendung ausl√∂st.  Abh√§ngig vom Erfolg der Montage f√ºhrt die Testfunktion unterschiedliche Aktionen aus.  Wenn die Montage erfolgreich war, wird eine Anwendung erstellt, die von der Person genehmigt werden muss, damit die neue Version der Anwendung in Betrieb genommen werden kann.  Das Schlie√üen der Anwendung dient als Signal f√ºr die Inbetriebnahme der neuen Version.  Wenn die Assembly fehlgeschlagen ist, fordert Jira den erkannten Fehler an und die Pipeline wird beendet. <br><br><h3>  Werkstatt  Implementieren einer Pipeline zum Registrieren eines neuen Benutzers </h3><br>  Betrachten Sie die Aufgabe, eine Folge von Aktionen zum Registrieren eines neuen Benutzers zu implementieren.  Beim Erstellen eines neuen Kontos werden immer eine ganze Reihe von Aktionen ausgef√ºhrt, z. B. das Senden einer Begr√º√üungs-E-Mail.  Es gibt auch eine Reihe von Aktionen, die m√∂glicherweise nicht jedes Mal ausgef√ºhrt werden, z. B. das Abonnieren eines E-Mail-Newsletters √ºber neue Versionen eines Produkts (auch als Spam bezeichnet). <br><br>  Ein Ansatz besteht darin, einen monolithischen Dienst zum Erstellen neuer Konten zu erstellen.  Bei diesem Ansatz ist ein Entwicklungsteam f√ºr den gesamten Service verantwortlich, der auch als Ganzes bereitgestellt wird.  Dies macht es schwierig, Experimente durchzuf√ºhren und √Ñnderungen am Prozess der Benutzerinteraktion mit der Anwendung vorzunehmen. <br><br>  Betrachten Sie die Implementierung der Benutzeranmeldung als Ereignis-Pipeline mehrerer FaaS-Dienste.  Bei dieser Trennung hat die Benutzererstellungsfunktion keine Ahnung, was w√§hrend der Benutzeranmeldung geschieht.  Sie hat zwei Listen: <br><br><ul><li>  eine Liste der erforderlichen Aktionen (z. B. Senden einer Begr√º√üungs-E-Mail); </li><li>  eine Liste optionaler Aktionen (z. B. Abonnieren eines Newsletters). </li></ul><br>  Jede dieser Aktionen wird auch als FaaS implementiert, und die Liste der Aktionen ist nichts weiter als eine Liste der HTTP-R√ºckruffunktionen.  Daher hat die Benutzererstellungsfunktion die folgende Form: <br><br><pre> <code class="plaintext hljs">def create_user(context): #      for key, value in required.items(): call_function(value.webhook, context.json) #    #     for key, value in optional.items(): if context.json.get(key, None) is not None: call_function(value.webhook, context.json)</code> </pre> <br>  Jeder der Handler kann nun auch nach dem FaaS-Prinzip implementiert werden: <br><br><pre> <code class="plaintext hljs">def email_user(context): #    user = context.json['username'] msg = ', {}, ,     !".format(user) send_email(msg, contex.json['email]) def subscribe_user(context): #    email = context.json['email'] subscribe_user(email)</code> </pre> <br>  Auf diese Weise zerlegt, wird der FaaS-Dienst viel einfacher, enth√§lt weniger Codezeilen und konzentriert sich auf die Implementierung einer bestimmten Funktion.  Der Microservice-Ansatz vereinfacht das Schreiben von Code, kann jedoch zu Schwierigkeiten bei der Bereitstellung und Verwaltung von drei verschiedenen Microservices f√ºhren.  Hier erweist sich der FaaS-Ansatz in seiner ganzen Pracht, da es aufgrund seiner Verwendung sehr einfach wird, kleine Codeteile zu verwalten.  Durch die Visualisierung des Prozesses zum Erstellen eines Benutzers in Form einer Ereignispipeline k√∂nnen wir auch allgemein verstehen, was genau passiert, wenn sich ein Benutzer anmeldet, indem wir einfach die √Ñnderung des Kontexts von Funktion zu Funktion innerhalb der Pipeline verfolgen. <br><br>  ¬ªWeitere Informationen zum Buch finden Sie auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der Website des Herausgebers</a> <br>  ¬ª <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Inhalt</a> <br>  ¬ª <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Auszug</a> <br><br>  20% Rabatt auf Gutscheine f√ºr Designer - <b>Designmuster</b> <br><br>  Nach Zahlung der Papierversion des Buches wird eine elektronische Version des Buches per E-Mail verschickt. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de445362/">https://habr.com/ru/post/de445362/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de445352/index.html">Spark Structured Streaming-Anwendungen auf Kubernetes. Erleben Sie FASTEN RUS</a></li>
<li><a href="../de445354/index.html">Objekte in Bildern finden</a></li>
<li><a href="../de445356/index.html">√úberblick √ºber den Bereich Mobile bei DUMP-2019: Maximal angewendet und n√ºtzlich in der t√§glichen Arbeit</a></li>
<li><a href="../de445358/index.html">Organisation des Ereignissystems in Unity - mit den Augen eines Spieledesigners</a></li>
<li><a href="../de445360/index.html">5 typische Aufgaben f√ºr JavaScript-Interviews: Analyse und L√∂sungen</a></li>
<li><a href="../de445366/index.html">So beschleunigen Sie die Verschl√ºsselung gem√§√ü GOST 28147-89 auf dem Baikal-T1-Prozessor aufgrund des SIMD-Blocks</a></li>
<li><a href="../de445368/index.html">Laden Sie ein Spiel mit ein paar Hunderttausenden von virtuellen Benutzern</a></li>
<li><a href="../de445370/index.html">TSDB-Analyse in Prometheus 2</a></li>
<li><a href="../de445372/index.html">Bildverarbeitung vs. menschliche Intuition: Algorithmen zur Unterbrechung des Betriebs von Objekterkennungsprogrammen</a></li>
<li><a href="../de445378/index.html">Labyrinthe: Klassifizierung, Erzeugung, Suche nach L√∂sungen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>