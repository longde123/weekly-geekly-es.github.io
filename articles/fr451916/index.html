<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧑🏿‍🤝‍🧑🏼 👩🏿‍🏭 🤠 PHP asynchrone et l'histoire d'un vélo 🍊 👨🏻‍🎓 👨‍👩‍👦‍👦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Après la sortie de PHP7, il est devenu possible d'écrire des applications à longue durée de vie à un coût relativement faible. Pour les programmeurs, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>PHP asynchrone et l'histoire d'un vélo</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/451916/"><p> Après la sortie de PHP7, il est devenu possible d'écrire des applications à longue durée de vie à un coût relativement faible.  Pour les programmeurs, des projets tels que <code>prooph</code> , <code>broadway</code> , <code>tactician</code> , <code>messenger</code> sont devenus disponibles, dont les auteurs prennent la solution aux problèmes les plus courants.  Mais que se passe-t-il si vous faites un petit pas en avant, en plongeant dans la question? </p><br><p>  Essayons de comprendre le sort d'un autre vélo, ce qui vous permet de mettre en œuvre l'application Publier / S'abonner. </p><a name="habracut"></a><br><p>  Pour commencer, nous allons essayer de passer brièvement en revue les tendances actuelles dans le monde de PHP, ainsi qu'un bref aperçu du fonctionnement asynchrone. </p><br><h3 id="php-sozdan-chtoby-umirat">  PHP créé pour mourir </h3><br><p>  Pendant longtemps, PHP a été principalement utilisé dans le workflow de demande / réponse.  Du point de vue des développeurs, c'est assez pratique, car il n'y a pas besoin de s'inquiéter des fuites de mémoire, des connexions de moniteur. </p><br><p>  Toutes les requêtes seront exécutées isolément les unes des autres, les ressources utilisées seront libérées et les connexions, par exemple, à la base de données seront fermées lorsque le processus sera terminé. </p><br><p>  À titre d'exemple, vous pouvez prendre une application CRUD régulière écrite sur la base du framework Symfony.  Pour lire à partir de la base de données et renvoyer JSON, il est nécessaire d'effectuer un certain nombre d'étapes (pour économiser de l'espace et du temps, exclure les étapes de génération / exécution des opcodes): </p><br><ul><li>  Analyse de la configuration; </li><li>  Compilation de conteneurs; </li><li>  Acheminement des demandes </li><li>  Accomplissement; </li><li>  Rendu du résultat. </li></ul><br><p>  Comme dans le cas de PHP (utilisant des accélérateurs), le framework utilise activement la mise en cache (certaines tâches ne seront pas terminées à la prochaine requête), ainsi qu'une initialisation retardée.  À partir de la version 7.4, une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">précharge</a> sera disponible, ce qui optimisera davantage l'initialisation de l'application. </p><br><p>  Cependant, il n'est pas possible de supprimer complètement tous les frais généraux pour l'initialisation. </p><br><h3 id="pomozhem-php-vyzhit">  Aidons PHP à survivre </h3><br><p>  La solution au problème semble assez simple: si vous exécutez l'application à chaque fois trop cher, vous devez l'initialiser une fois, puis lui transmettre des demandes, en contrôlant leur exécution. </p><br><p>  Il existe des projets dans l'écosystème PHP tels que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">php-pm</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">RoadRunner</a> .  Conceptuellement, les deux font la même chose: </p><br><ul><li>  Un processus parent est créé qui agit en tant que superviseur; </li><li>  Un pool de processus enfants est créé; </li><li>  Lorsqu'une demande est reçue, le maître extrait le processus du pool et lui transmet la demande.  Le client est en attente à ce moment; </li><li>  Une fois la tâche terminée, le maître renvoie le résultat au client et le processus enfant est renvoyé au pool. </li></ul><br><p>  Si un processus enfant meurt, le superviseur le crée à nouveau et l'ajoute au pool.  Nous avons créé un démon à partir de notre application avec un seul objectif: supprimer la surcharge d'initialisation, augmentant considérablement la vitesse de traitement des demandes.  C'est le moyen le plus indolore d'augmenter la productivité, mais pas le seul. </p><br><blockquote>  Remarque: <br>  de nombreux exemples de la série «prenez ReactPHP et accélérez Laravel N fois» marchent sur le réseau.  Il est important de comprendre la différence entre diaboliser (et, par conséquent, gagner du temps lors du démarrage de l'application) et multitâche. <br>  Lorsque vous utilisez php-pm ou roadrunner, votre code ne devient pas non bloquant.  Vous gagnez simplement du temps lors de l'initialisation. <br>  La comparaison de php-pm, roadrunner et ReactPHP / Amp / Swoole est incorrecte par définition. </blockquote><br><h5 id="php-i-io">  PHP et E / S </h5><br><p>  L'interaction avec les E / S en PHP est exécutée par défaut en mode blocage.  Cela signifie que si nous exécutons une demande de mise à jour des informations dans la table, le flux d'exécution s'arrêtera en attendant une réponse de la base de données.  Plus ces appels sont en cours de traitement de la demande, plus les ressources du serveur sont inactives.  En effet, dans le processus de traitement de la demande, nous devons aller plusieurs fois dans la base de données, écrire quelque chose dans le journal et rendre le résultat au client, au final - également une opération de blocage. </p><br><blockquote>  Imaginez que vous êtes un opérateur de centre d'appels et que vous devez appeler 50 clients en une heure. <br>  Vous composez le premier numéro, et là, il est occupé (l'abonné discute par téléphone de la dernière série de Game of Thrones et de la suite de la série). <br>  Et maintenant vous êtes assis et essayez de l'atteindre avant la victoire.  Le temps passe, le décalage touche à sa fin.  Après avoir perdu 40 minutes en essayant d'atteindre le premier abonné, vous avez raté l'occasion de contacter les autres et naturellement reçu du patron. <br>  Mais vous pouvez faire autrement: n'attendez pas que le premier abonné soit libre et dès que vous entendez un bip, raccrochez et commencez à composer le numéro suivant.  Vous pouvez revenir au premier un peu plus tard. <br>  Avec cette approche, les chances de téléphoner au nombre maximum de personnes sont considérablement augmentées, et la vitesse de votre travail ne repose pas sur la tâche la plus lente. </blockquote><p>  Le code qui ne bloque pas le thread d'exécution (n'utilise pas le blocage des appels d'E / S, ainsi que des fonctions comme <code>sleep()</code> ), est appelé asynchrone. </p><br><p>  Revenons à notre application Symfony CRUD.  Il est presque impossible de le faire fonctionner en mode asynchrone en raison de l'abondance de l'utilisation des fonctions de blocage: tous fonctionnent avec des configurations, des caches, une journalisation, un rendu de la réponse, une interaction avec la base de données. </p><br><p>  Mais ce sont toutes des conventions, essayons de lancer Symfony et d'utiliser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Amp</a> , qui fournit une implémentation d'Event Loop (y compris un certain nombre de classeurs), Promises et Coroutines, comme une cerise sur le gâteau pour résoudre notre problème. </p><br><p>  La promesse est une façon d'organiser le code asynchrone.  Par exemple, nous devons accéder à une ressource http. </p><br><p>  Nous créons un objet de demande et le transmettons au transport, que Promise nous renvoie contenant l'état actuel.  Il existe trois états possibles: </p><br><ul><li>  Succès: notre demande a été traitée avec succès; </li><li>  Erreur: lors de l'exécution de la demande, un problème est survenu (par exemple, le serveur a renvoyé une réponse 500); </li><li>  En attente: le traitement de la demande n'a pas encore commencé. </li></ul><br><p>  Chaque Promise a une méthode (dans l'exemple, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Promise est</a> analysée <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">par Amp</a> ) - <code>onResolve()</code> , dans laquelle une fonction de rappel avec deux arguments est passée </p><br><pre> <code class="php hljs">$promise-&gt;onResolve( <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(?/Throwable $throwable, $result)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span> !== $throwable) { <span class="hljs-comment"><span class="hljs-comment">/**   */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/**  */</span></span> } );</code> </pre> <br><p>  Après avoir reçu Promise, la question se pose: qui surveillera son statut et nous informera du changement de statut? </p><br><p>  Pour cela, Event Loop est utilisé. </p><br><p>  En substance, une boucle d'événement est un planificateur qui surveille l'exécution.  Dès que la tâche est terminée (peu importe comment), l'appelable que nous avons transmis à Promise sera appelé. </p><br><p>  En ce qui concerne les nuances, je recommanderais de lire un article de Nikita Popov: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Multitâche coopératif utilisant des coroutines</a> .  Cela aidera à clarifier ce qui se passe et où sont les générateurs. </p><br><p>  Armés de nouvelles connaissances, essayons de revenir à notre tâche de rendu JSON. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://github.com/amphp/">Un exemple de</a> traitement d'une requête http entrante en utilisant <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://github.com/amphp/">amphp / http-server</a> . <br>  Dès que nous recevons la demande, une lecture asynchrone de la base de données est effectuée (nous obtenons une promesse) et à la fin, l'utilisateur recevra le JSON convoité, formé sur la base des données reçues. </p><br><blockquote>  Si nous devons écouter un port de plusieurs processus, nous pouvons regarder vers <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">amphp / cluster</a> </blockquote><p>  La principale différence est qu'un même processus peut servir plusieurs requêtes à la fois car le thread d'exécution n'est pas bloqué.  Le client recevra sa réponse lorsque la lecture de la base de données sera terminée, et s'il n'y a pas de réponse, vous pouvez commencer à traiter la demande suivante. </p><br><h3 id="divnyy-mir-asinhronnogo-php">  Le monde merveilleux du PHP asynchrone </h3><br><blockquote>  Clause de non-responsabilité <br>  Le PHP asynchrone est considéré dans le contexte des espèces exotiques et n'est pas considéré comme quelque chose de sain / normal.  Fondamentalement, ils attendront des rires dans le style de "prendre GO / Kotlin, un fou", etc.  Je ne dirais pas que ces gens ont tort, mais ... </blockquote><p>  Il existe un certain nombre de projets qui aident à écrire du code PHP non bloquant.  Dans le cadre de l'article, je n'analyserai pas complètement tous les avantages et les inconvénients, mais j'essaierai simplement de les examiner superficiellement. </p><br><h5 id="swoolehttpswwwswoolecouk">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Swoole</a> </h5><br><p>  Un framework asynchrone écrit contrairement aux autres en C et livré comme une extension de PHP.  Il possède peut-être les meilleurs indicateurs de performance pour le moment. </p><br><p>  Il y a une implémentation de canaux, de corutine et d'autres choses savoureuses, mais il a un gros inconvénient - la documentation.  Bien qu'il soit en partie en anglais, à mon avis, il n'est pas très détaillé et l'api lui-même n'est pas très évident. </p><br><p>  Quant à la communauté, elle n'est pas non plus toute simple et sans ambiguïté.  Personnellement, je ne connais pas une seule personne vivante qui utilise Swoole au combat.  Je vais peut-être surmonter mes peurs et migrer vers lui, mais cela ne se produira pas dans un avenir proche. </p><br><p>  Aux inconvénients, vous pouvez également ajouter que contribuer au projet (en utilisant la demande de tirage) avec des modifications est également difficile si vous ne connaissez pas C au niveau approprié. </p><br><h5 id="workermanhttpsgithubcomwalkorworkerman">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Workerman</a> </h5><br><p>  S'il perd de la vitesse par rapport à son concurrent (en parlant de Swoole), alors il n'est pas très visible et la différence dans un certain nombre de scénarios peut être négligée. </p><br><p>  Il a une intégration avec ReactPHP, qui à son tour augmente le nombre d'implémentations de problèmes d'infrastructure.  Pour économiser de l'espace, je décrirai les inconvénients avec ReactPHP. </p><br><h5 id="reactphphttpsreactphporg">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ReactPHP</a> </h5><br><p>  Les avantages comprennent une communauté assez importante et un grand nombre d'exemples.  Les inconvénients commencent à apparaître dans le processus d'utilisation - c'est le concept de promesse. <br>  Si vous devez effectuer plusieurs opérations asynchrones, le code se transforme alors en une corbeille sans fin d'appels (voici <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un exemple de connexion simple à RabbiqMQ</a> sans créer d'échange / file d'attente et leurs liants). </p><br><p>  Avec un certain raffinement avec un fichier (considéré comme la norme), vous pouvez obtenir une implémentation de corutine qui vous aidera à vous débarrasser de l'enfer Promise. </p><br><p>  Sans le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">projet recoilphp / recoil, l'</a> utilisation de ReactPHP, à mon avis, n'est pas possible dans une application saine. </p><br><p>  De plus, outre tout le reste, on a l'impression que son développement a beaucoup ralenti.  Pas assez, par exemple, un travail normal avec PostgreSQL. </p><br><h5 id="amphttpsamphporgamp">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ampli</a> </h5><br><p>  À mon avis, la meilleure des options qui existent à l'heure actuelle. <br>  En plus de la promesse habituelle, il existe une implémentation de Coroutine, qui facilite grandement le processus de développement et le code semble le plus familier aux programmeurs PHP. </p><br><p>  Les développeurs complètent et améliorent constamment le projet, avec des commentaires, il n'y a pas non plus de problèmes. </p><br><p>  Malheureusement, avec tous les avantages du framework, la communauté est relativement petite, mais en même temps il existe des implémentations, par exemple, travaillant avec PostgreSQL, ainsi que toutes les choses de base (système de fichiers, client http, DNS, etc.). </p><br><p>  Je ne comprends toujours pas très bien le sort du projet ext-async, mais les gars le suivent.  Ce qui en résultera dans la 3ème version, le temps nous le dira. </p><br><h3 id="pristupaem-k-realizacii">  Pour commencer </h3><br><p>  Donc, nous avons un peu réglé la partie théorique, il est temps de passer à la pratique et de remplir les bosses. </p><br><p>  Tout d'abord, nous formalisons un peu les exigences: </p><br><ul><li>  Messagerie asynchrone (le concept de <code>message</code> lui-même peut être divisé en 2 types) <br><ul><li>  <code>command</code> : indique la nécessité de terminer la tâche.  Ne renvoie pas de résultat (au moins dans le cas d'une communication asynchrone); </li><li>  <code>event</code> : signale tout changement d'état (par exemple, à la suite d'une commande). </li></ul></li><li>  Format non bloquant pour travailler avec les E / S; </li><li>  La possibilité d'augmenter facilement le nombre de processeurs; </li><li>  Capacité à écrire des gestionnaires de messages dans n'importe quelle langue. </li></ul><br><blockquote>  Tout message est intrinsèquement une structure simple et partagé uniquement par la sémantique.  La dénomination des messages est extrêmement importante du point de vue de la compréhension du type et du but (bien que ce point soit ignoré dans l'exemple). </blockquote><p>  Pour une liste d'exigences, une implémentation simple du modèle de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">publication / abonnement</a> est la mieux adaptée. <br>  Pour assurer une exécution distribuée, nous utiliserons RabbitMQ comme courtier de messages. </p><br><p>  Le prototype a été écrit en utilisant <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ReactPHP</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Bunny</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">DoctrineDBAL</a> . <br>  Un lecteur attentif pourrait remarquer que Dbal utilise les appels de blocage pdo / mysqli en interne, mais au stade actuel, cela n'était pas particulièrement important, car il fallait comprendre ce qui devait se passer à la fin. </p><br><p>  L'un des problèmes était le manque de bibliothèques pour travailler avec PostgreSQL.  Il existe quelques brouillons, mais cela ne suffit pas pour un travail à part entière (plus de détails ci-dessous). </p><br><p>  Après une courte recherche, ReactPHP a été retiré au profit d'Amp, car il est relativement simple et se développe très activement. </p><br><h5 id="rabbitmq-transport">  Transport RabbitMQ </h5><br><p>  Mais avec tous les avantages d'Amp, il y avait 1 problème: Amp n'a pas de pilote pour RabbitMQ ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Bunny</a> ne supporte que ReactPHP). </p><br><p>  En théorie, Amp vous permet d'utiliser Promise d'un concurrent.  Il semblerait que tout devrait être simple, mais ReactPHP utilise Event Loop pour travailler avec les sockets de la bibliothèque. <br>  À un moment donné, évidemment, deux boucles d'événements différentes n'ont pas pu être démarrées, donc je n'ai pas pu utiliser la fonction <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">adapt ()</a> . </p><br><p>  Malheureusement, la qualité du code dans bunny laissait beaucoup à désirer et il n'était pas possible de remplacer correctement une implémentation par une autre.  Afin de ne pas arrêter le travail, il a été décidé de réécrire un peu la bibliothèque afin qu'elle fonctionne avec Amp et ne conduise pas à bloquer le flux d'exécution. </p><br><p>  Cette adaptation avait l'air très effrayante, tout le temps j'en avais extrêmement honte, mais surtout, ça fonctionnait.  Eh bien, puisqu'il n'y a rien de plus permanent que temporaire, l'adaptateur est resté en prévision d'une personne qui n'est pas trop paresseuse pour faire face à la mise en œuvre du pilote. </p><br><p>  Et un tel homme a été trouvé.  Le projet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PHPinnacle</a> , entre autres, fournit une implémentation d'un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">adaptateur</a> adapté pour Amp. </p><br><blockquote>  Le nom de l'auteur est Anton Shabovta, qui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">parlera de php asynchrone</a> dans le cadre de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PHP Russie</a> et du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">développement de pilotes</a> pour <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PHP fwdays</a> . </blockquote><br><h5 id="postgresql">  PostgreSQL </h5><br><p>  La deuxième caractéristique du travail est l'interaction avec la base de données.  Dans les conditions du PHP «traditionnel», tout est simple: nous avons une connexion et toutes les requêtes sont exécutées séquentiellement. </p><br><p>  Dans le cas d'une exécution asynchrone, nous devons pouvoir exécuter simultanément plusieurs requêtes (par exemple, 3 transactions).  Pour ce faire, une implémentation de pool de connexions est requise. </p><br><p>  Le mécanisme de travail est assez simple: </p><br><ul><li>  nous ouvrons <em>N</em> connexions au démarrage (ou initialisation retardée, pas le point); </li><li>  si nécessaire, nous prenons la connexion de la piscine, en veillant à ce que personne d'autre ne puisse l'utiliser; </li><li>  Nous exécutons la demande et détruisons la connexion ou la renvoyons au pool (de préférence). </li></ul><br><p>  Premièrement, cela nous permet de démarrer plusieurs transactions en même temps, et deuxièmement, cela accélère le travail en raison de la présence de connexions déjà ouvertes.  L'ampli a un composant <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">amphp / postgres</a> .  Il s'occupe des connexions: surveille leur nombre, leur durée de vie, et tout cela sans bloquer le flux d'exécution. </p><br><p>  Par ailleurs, lorsque vous utilisez, par exemple, ReactPHP, vous devrez l'implémenter vous-même si vous souhaitez travailler avec une base de données. </p><br><h5 id="mutex">  Mutex </h5><br><p>  Pour un fonctionnement efficace et, surtout, correct de l'application, il est nécessaire de mettre en œuvre quelque chose de similaire aux mutex.  On peut distinguer 3 scénarios pour leur utilisation: </p><br><ul><li>  Dans le cadre d'un processus, un mécanisme simple en mémoire convient sans excédent; </li><li>  Si nous voulons fournir le verrouillage dans plusieurs processus, nous pouvons utiliser le système de fichiers (bien sûr, en mode non bloquant); </li><li>  Si dans le contexte de plusieurs serveurs, vous devez déjà penser à quelque chose comme Zookeeper. </li></ul><br><p>  Des mutex sont nécessaires pour résoudre les problèmes de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">conditions de</a> concurrence.  Après tout, nous ne savons pas (et nous ne pouvons pas savoir) dans quel ordre nos tâches seront exécutées, mais nous devons néanmoins garantir l'intégrité des données. </p><br><h5 id="logirovaniekonteksty">  Journalisation / Contextes </h5><br><p>  Pour la journalisation, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Monolog</a> est déjà devenu standard, mais avec quelques mises en garde: nous ne pouvons pas utiliser les gestionnaires intégrés, car ils entraîneront des verrous. <br>  Pour écrire dans stdOut, vous pouvez prendre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">amphp / log</a> , ou écrire un simple message envoyé à un Graylog. </p><br><p>  Étant donné qu'à un moment donné, nous pouvons traiter de nombreuses tâches et lorsque vous enregistrez des journaux, vous devez comprendre dans quel contexte les données sont écrites.  Au cours des expériences, il a été décidé de faire <code>trace_id</code> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">traçage distribué</a> ).  L'essentiel est que toute la chaîne d'appels doit être accompagnée d'un identifiant d'intercommunication qui peut être suivi.  De plus, au moment de la réception du message, <code>package_id</code> généré, ce qui indique exactement le message reçu. </p><br><p>  Ainsi, en utilisant les deux identifiants, nous pouvons facilement suivre à quoi se réfère un enregistrement particulier.  Le fait est qu'en PHP traditionnel, tous les enregistrements que nous obtenons dans le journal sont principalement dans l'ordre dans lequel ils ont été écrits.  Dans le cas d'une exécution asynchrone, il n'y a pas de modèle dans l'ordre des entrées. </p><br><h5 id="terminating">  Résiliation </h5><br><p>  Une autre des nuances du développement asynchrone est le contrôle de l'arrêt de notre démon.  Si vous venez de tuer le processus, toutes les tâches en cours ne seront pas terminées et les données seront perdues. Dans l'approche habituelle, il y a aussi un tel problème, mais ce n'est pas si grave, car une seule tâche est effectuée à la fois. </p><br><p>  Pour terminer correctement l'exécution, nous avons besoin de: </p><br><ul><li>  Se désinscrire de la file d'attente.  En d'autres termes, il est impossible de recevoir de nouveaux messages; </li><li>  Terminez toutes les tâches restantes (attendez la résolution des promesses); </li><li>  Et seulement après cela, terminer le script. </li></ul><br><h5 id="utechki-otladka">  Fuites, débogage </h5><br><p>  Contrairement à la croyance populaire, en PHP moderne, il n'est pas si simple de faire face à des situations dans lesquelles une fuite de mémoire se produit.  Il faut faire quelque chose d'absolument mauvais. </p><br><p>  Cependant, une fois confronté à cela, mais à cause de la négligence banale.  Pendant l'implémentation de Heartbeat, un nouveau temporisateur a été ajouté toutes les 40 secondes pour interroger la connexion.  Il n'est pas difficile de deviner qu'après un certain temps, l'utilisation de la mémoire a commencé à remonter et assez rapidement. </p><br><p>  Entre autres choses, il a écrit un simple observateur qui démarrera éventuellement toutes les 10 minutes et appellera <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">gc_collect_cycles ()</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">gc_mem_caches ()</a> . <br>  Mais le démarrage forcé du ramasse-miettes n'est pas quelque chose de nécessaire et de fondamental. </p><br><p>  Afin de voir constamment l'utilisation de la mémoire, un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">MemoryUsageProcessor</a> standard <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">a</a> été ajouté à la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">journalisation</a> . </p><br><p>  Si vous avez l'idée que Event Loop se bloque avec quelque chose, cela peut également être facilement vérifié: connectez simplement <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">LoopBlockWatcher</a> . </p><br><p>  Mais vous devez vous assurer que cet observateur ne démarre pas dans l'environnement de production.  Cette fonctionnalité est utilisée exclusivement pendant le développement. </p><br><h3 id="rezultaty">  Résultats </h3><br><p>     : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">php-service-bus</a> ,    Message Based . </p><br><p>    ,         : </p><br><pre> <code class="plaintext hljs">composer create-project php-service-bus/skeleton pub-sub-example cd pub-sub-example docker-compose up --build -d</code> </pre> <br><p>   ,      ,   . </p><br><p>   <code>/bin/consumer</code>   ,    . <br>   <code>/src</code>  3 : <code>Ping</code>   ; <code>Pong</code> :    ; <code>PingService</code> : ,   . <br>     <code>PingService</code> ,      2 : </p><br><pre> <code class="php hljs"> <span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@CommandHandler</span></span></span><span class="hljs-comment">() */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Ping $command, KernelContext $context)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Promise</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $context-&gt;delivery(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Pong()); } <span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@EventListener</span></span></span><span class="hljs-comment">() */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">whenPong</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Pong $event, KernelContext $context)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span></span>{ $context-&gt;logContextMessage(<span class="hljs-string"><span class="hljs-string">'Pong message received'</span></span>); }</code> </pre> <br><ul><li> <code>handle</code>    (        1 ).      <code>@CommandHandler</code> ; <br><ul><li>   Promise ,        RabbitMQ (   <code>delivery()</code> ).       ,   RabbitMQ    . </li></ul></li><li> <code>whenPong</code> —   <code>Pong</code> .            .     <code>@EventListener</code> ; <br><blockquote>  ,     —   . , , ,     .     php-service-bus  , ,            . <br></blockquote></li></ul><br><p>     2 : ,   (  )  .          ,     ,     (, ). </p><br><p>     <code>Ping</code> ,      <code>Pong</code> .     . </p><br><p>    ,       RabbitMQ: </p><br><pre> <code class="plaintext hljs">tools/ping</code> </pre> <br><p>    ,  php-service-bus     ,  Message based . </p><br><p> Ping\Pong,    — ,  ,  <code>Hello, world</code>       . </p><br><p>     ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> . </p><br><p>     - ,    , , Saga pattern (Process manager)        . </p><br><h3 id="nu-i-kak-zhe-ne-pomeryatsya">       </h3><br><p>   ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">  symfony/messenger</a> . </p><br><p>    ,      ,      . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr451916/">https://habr.com/ru/post/fr451916/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr451902/index.html">Camp de développeurs Microsoft Azure Russie</a></li>
<li><a href="../fr451904/index.html">Parfois, plus c'est moins. Quand une diminution de la charge entraîne une augmentation du retard</a></li>
<li><a href="../fr451906/index.html">Vulnérabilité dans Exchange: comment détecter l'élévation de privilèges à un administrateur de domaine</a></li>
<li><a href="../fr451908/index.html">L'histoire des ordinateurs: une nuit au Musée Yandex</a></li>
<li><a href="../fr451912/index.html">Le réseau de neurones profonds MuseNet écrit de la musique</a></li>
<li><a href="../fr451918/index.html">A la question de TI</a></li>
<li><a href="../fr451920/index.html">Optimiser le stockage du courrier dans Zimbra Collaboration Suite</a></li>
<li><a href="../fr451922/index.html">Arithmétique à virgule fixe en C ++</a></li>
<li><a href="../fr451926/index.html">À propos du code en direct après 130 flux</a></li>
<li><a href="../fr451928/index.html">Comment configurer l'analyse Web sur les pages AMP</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>