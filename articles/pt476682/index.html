<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéÖüèΩ ‚õÑÔ∏è üßöüèª Como escrever um sapador no Phaser e executar uma tarefa de teste do desenvolvedor HTML5 üôéüèæ üë®üèø‚Äçüöí üî§</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Boa tarde, queridos colegas! 

 Meu nome √© Alexander, sou desenvolvedor de jogos HTML5. 

 Em uma das empresas para as quais enviei meu curr√≠culo, fui...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Como escrever um sapador no Phaser e executar uma tarefa de teste do desenvolvedor HTML5</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/476682/"> Boa tarde, queridos colegas! <br><br>  Meu nome √© Alexander, sou desenvolvedor de jogos HTML5. <br><br>  Em uma das empresas para as quais enviei meu curr√≠culo, fui solicitado a concluir uma tarefa de teste.  Concordei e, ap√≥s 1 dia, enviei como resultado o jogo desenvolvido de acordo com o TOR HTML5. <br><br><img src="https://habrastorage.org/webt/4t/ng/dn/4tngdnvlxq3izqrpk2nykww2dvs.png"><br><br>  Como estou treinando em programa√ß√£o de jogos, bem como para um uso mais eficiente do meu c√≥digo, decidi que seria √∫til escrever um artigo de treinamento sobre o projeto conclu√≠do.  E como o teste conclu√≠do recebeu uma avalia√ß√£o positiva e levou a um convite para uma entrevista, provavelmente minha decis√£o tem o direito de existir e, possivelmente, ajudar√° algu√©m no futuro. <br><br>  Este artigo dar√° uma id√©ia da quantidade de trabalho suficiente para concluir com √™xito a tarefa de teste m√©dia para a posi√ß√£o HTML5 do desenvolvedor.  O material tamb√©m pode ser de interesse para quem deseja se familiarizar com a estrutura da Phaser.  E se voc√™ j√° estiver trabalhando com a Phaser e escrevendo em JS - veja como desenvolver um projeto no TypeScript. <br><br>  Portanto, no cat, h√° muito c√≥digo TypeScript! <br><a name="habracut"></a><br><h2>  1. Introdu√ß√£o </h2><br>  Damos uma breve declara√ß√£o do problema. <br><br><ol><li>  Vamos desenvolver um jogo HTML5 simples - um sapador cl√°ssico. </li><li>  Como principais ferramentas, usaremos o phaser 3, typescript e webpack. </li><li>  O jogo ser√° projetado para a √°rea de trabalho e ser√° executado no navegador. </li></ol><br>  Fornecemos links para o projeto final. <br><br><div class="spoiler">  <b class="spoiler_title">Links para a demonstra√ß√£o e fonte</b> <div class="spoiler_text">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Demonstra√ß√£o reproduz√≠vel</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">C√≥digo fonte do GitHub</a> <br></div></div><br>  E lembre-se da mec√¢nica do sapador, se de repente algu√©m esquecer as regras do jogo.  Mas, como esse √© um caso improv√°vel, as regras s√£o colocadas sob o spoiler :) <br><br><div class="spoiler">  <b class="spoiler_title">Regras do Sapper</b> <div class="spoiler_text">  O campo de jogo consiste em c√©lulas dispostas em uma mesa.  Por padr√£o, quando o jogo √© iniciado, todas as c√©lulas s√£o fechadas.  Bombas s√£o colocadas em algumas c√©lulas. <br><br>  Ao clicar com o bot√£o esquerdo em uma c√©lula fechada, ela √© aberta.  Se houve uma bomba em uma c√©lula aberta, o jogo termina em derrota. <br><br>  Se n√£o havia bomba na c√©lula, um n√∫mero √© exibido dentro dela, indicando o n√∫mero de bombas que est√£o nas c√©lulas vizinhas em rela√ß√£o √† corrente aberta.  Se n√£o houver bombas por perto, a c√©lula parecer√° vazia. <br><br>  Clicar com o bot√£o direito do mouse em uma c√©lula fechada define uma sinaliza√ß√£o nela.  A tarefa do jogador √© organizar todas as bandeiras dispon√≠veis para que ele marque todas as c√©lulas minadas.  Depois de colocar todas as bandeiras, o jogador pressiona o bot√£o esquerdo do mouse em uma das c√©lulas abertas para verificar se ganhou. <br></div></div><br>  Em seguida, vamos diretamente ao pr√≥prio manual.  Todo o material √© dividido em pequenas etapas, cada uma das quais descreve a implementa√ß√£o de uma tarefa espec√≠fica em um curto espa√ßo de tempo.  Assim, realizando pequenos objetivos passo a passo, no final, criaremos um jogo completo.  Use o √≠ndice se decidir ir rapidamente para uma etapa espec√≠fica. <br><br><div class="spoiler">  <b class="spoiler_title">Sum√°rio</b> <div class="spoiler_text">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">1. Prepara√ß√£o</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">1.1 Modelo de Projeto</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">1.2 Configura√ß√£o da compila√ß√£o</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">1.3 Instalando m√≥dulos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">1.4 Prepara√ß√£o de ativos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">2. Criando cenas</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">2.1 Ponto de entrada</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">2.2 Cena Inicial</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">2.3 Textos da cena inicial</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">2.4 Transi√ß√£o para o n√≠vel do jogo</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Cena de 2,5 n√≠veis</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">2.6 Configurando cenas no ponto de entrada</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">3. Objetos do jogo</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">3.1 Tabuleiro de jogo</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">3.2 Modelo Celular</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">3.3 Visualiza√ß√£o de c√©lula</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">3.4 Criando um sprite em uma classe de exibi√ß√£o</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">3.5 Posicionamento de Sprite</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">3.6 Criando uma inst√¢ncia do FieldView</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">3.7 Exibir campos do quadro.</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">3.8 Fazendo bombas</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">3.9 Valores de configura√ß√£o</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">4. Manipulando Eventos de Entrada</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">4.1 Rastreando eventos de clique do mouse</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">4.2</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Processamento do clique esquerdo</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">4.4 Processamento com o bot√£o direito</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">4.5 Objeto GameSceneView</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">5. Anima√ß√µes</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">5.1 Anima√ß√£o de preenchimento de quadro</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">5.2 Anima√ß√µes de flip de c√©lula</a> <br></div></div><br><a name="section-1"></a><h2>  <font color="#008080">1. Prepara√ß√£o</font> </h2><br><a name="section-1-1"></a><h3>  <font color="#008080">1.1 Modelo de Projeto</font> </h3><br>  Fa√ßa o download do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">modelo de projeto phaser padr√£o</a> .  Este √© o modelo recomendado pelo autor da estrutura e oferece a seguinte estrutura de diret√≥rios: <br><div class="scrollable-table"><table><tbody><tr><td>  index.html </td><td colspan="2">  P√°gina HTML iniciando o jogo </td></tr><tr><td rowspan="2">  webpack / </td><td>  base.js </td><td>  construir configura√ß√£o para ambiente de teste </td></tr><tr><td>  prod.js </td><td>  construir configura√ß√£o para produ√ß√£o </td></tr><tr><td rowspan="2">  src / </td><td>  ativos / </td><td>  recursos do jogo (sprites, sons, fontes) </td></tr><tr><td>  index.js </td><td>  ponto de entrada </td></tr></tbody></table></div> Para o nosso projeto, n√£o precisamos do arquivo <code>index.js</code> atual; portanto, exclua-o.  Em seguida, crie o diret√≥rio <code>/src/scripts/</code> e coloque o arquivo <code>index.ts</code> vazio nele.  Adicionaremos todos os nossos scripts a esta pasta. <br>  Tamb√©m √© importante ter em mente que, ao criar um projeto para produ√ß√£o, um diret√≥rio <code>dist</code> ser√° criado na raiz, no qual a compila√ß√£o do release ser√° colocada. <br><br><a name="section-1-2"></a><h3>  <font color="#008080">1.2 Configura√ß√£o da compila√ß√£o</font> </h3><br>  Usaremos o webpack para montagem.  Como nosso modelo foi originalmente preparado para trabalhar com JavaScript e escrevemos no TypeScript, precisamos fazer pequenas altera√ß√µes na configura√ß√£o do coletor. <br><br>  No <code>webpack/base.js</code> adicione a chave de <code>entry</code> , que indica o ponto de entrada ao criar nosso projeto, bem como a configura√ß√£o do <code>ts-loader</code> que descreve as regras para a cria√ß√£o de scripts TS: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// webpack/base.js //... module.exports = { entry: './src/scripts/index.ts', // ... resolve: { extensions: [ '.ts', '.tsx', '.js' ] }, module: { rules: [{ test: /\.tsx?$/, use: 'ts-loader', exclude: /node_modules/ }, //...</span></span></code> </pre><br>  Tamb√©m precisaremos criar o arquivo tsconfig.json na raiz do projeto.  Para mim, tem o seguinte conte√∫do: <br><br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"compilerOptions"</span></span>: { <span class="hljs-string"><span class="hljs-string">"module"</span></span>: <span class="hljs-string"><span class="hljs-string">"commonjs"</span></span>, <span class="hljs-string"><span class="hljs-string">"lib"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"dom"</span></span>, <span class="hljs-string"><span class="hljs-string">"es5"</span></span>, <span class="hljs-string"><span class="hljs-string">"es6"</span></span>, <span class="hljs-string"><span class="hljs-string">"es2015"</span></span>, <span class="hljs-string"><span class="hljs-string">"es2017"</span></span>, <span class="hljs-string"><span class="hljs-string">"es2015.promise"</span></span> ], <span class="hljs-string"><span class="hljs-string">"target"</span></span>: <span class="hljs-string"><span class="hljs-string">"es5"</span></span>, <span class="hljs-string"><span class="hljs-string">"skipLibCheck"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }, <span class="hljs-string"><span class="hljs-string">"exclude"</span></span>: [<span class="hljs-string"><span class="hljs-string">"node_modules"</span></span>, <span class="hljs-string"><span class="hljs-string">"dist"</span></span>] }</code> </pre> <br><a name="section-1-3"></a><h3>  <font color="#008080">1.3 Instalando m√≥dulos</font> </h3><br>  Instale todas as depend√™ncias do package.json e adicione os m√≥dulos typescript e ts-loader a eles: <br><br><pre> <code class="plaintext hljs">npm i npm i typescript --save-dev npm i ts-loader --save-dev</code> </pre><br>  Agora o projeto est√° pronto para iniciar o desenvolvimento.  Temos 2 comandos √† nossa disposi√ß√£o que j√° est√£o definidos na propriedade <code>scripts</code> no arquivo <code>package.json</code> . <br><br><ol><li>  Crie um projeto para depura√ß√£o e abra em um navegador por meio de um servidor local <br><br><pre> <code class="plaintext hljs">npm start</code> </pre> </li><li>  Execute a compila√ß√£o para venda e coloque a compila√ß√£o de lan√ßamento na pasta dist / <br><br><pre> <code class="plaintext hljs">npm run build</code> </pre> </li></ol><br><a name="section-1-4"></a><h3>  <font color="#008080">1.4 Prepara√ß√£o de ativos</font> </h3><br>  Todos os recursos deste jogo s√£o honestamente baixados do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">OpenGameArt</a> (vers√£o 61x61) e possuem as licen√ßas mais amig√°veis, denominadas <i>Sinta-se livre para usar</i> , o que a p√°gina com o pacote nos informa cuidadosamente).  A prop√≥sito, o c√≥digo apresentado no artigo tem a mesma licen√ßa!  ;) <br><br>  Eu apaguei a imagem do rel√≥gio do conjunto baixado e renomeei o restante dos arquivos para obter nomes de quadros f√°ceis de usar.  A lista de nomes e os arquivos correspondentes s√£o exibidos na tela abaixo. <br><br>  A partir dos sprites resultantes, criaremos um atlas do formato <code>Phaser JSONArray</code> no programa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">TexturePacker</a> (h√° uma vers√£o gratuita mais do que suficiente, ainda n√£o consegui trabalhar) e colocaremos os arquivos <code>spritesheet.json</code> e <code>spritesheet.png</code> gerados no diret√≥rio <code>src/assets/</code> project. <br><br><img src="https://habrastorage.org/webt/ms/ki/z9/mskiz9zmuidbxk8hhcbksfmny4k.png"><br><br><a name="section-2"></a><h2>  <font color="#008080">2. Criando cenas</font> </h2><br><a name="section-2-1"></a><h3>  <font color="#008080">2.1 Ponto de entrada</font> </h3><br>  Iniciamos o desenvolvimento criando o ponto de entrada descrito na configura√ß√£o do webpack. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// src/scripts/index.ts import * as Phaser from "phaser"; new Phaser.Game({ type: Phaser.AUTO, parent: "minesweeper", width: window.innerWidth, height: window.innerHeight, backgroundColor: "#F0FFFF", scene: [] });</span></span></code> </pre><br>  Como o jogo que temos foi projetado para a √°rea de trabalho e preencher√° a tela inteira, usamos com ousadia toda a largura e altura do navegador nos campos de <code>width</code> e <code>height</code> . <br>  Atualmente, o campo de <code>scene</code> √© um array vazio e vamos corrigi-lo! <br><br><a name="section-2-2"></a><h3>  <font color="#008080">2.2 Cena Inicial</font> </h3><br>  Crie a classe da primeira cena no <code>src/scripts/scenes/StartScene.ts</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StartScene</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Phaser</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Scene</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(<span class="hljs-string"><span class="hljs-string">'Start'</span></span>); } public preload(): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> { } public create(): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> { } }</code> </pre><br>  Para heran√ßa v√°lida de <code>Phaser.Scene</code> passamos o nome da cena como um par√¢metro para o construtor da classe pai. <br><br>  Esta cena combinar√° a funcionalidade de pr√©-carregamento de recursos e a tela inicial, convidando o usu√°rio ao jogo. <br><br>  Normalmente, em meus projetos, um jogador passa por duas cenas antes de chegar √† inicial, nesta ordem: <br><br><pre> <code class="plaintext hljs">Boot =&gt; Preload =&gt; Start</code> </pre><br>  Mas, neste caso, o jogo √© t√£o simples, e h√° t√£o poucos recursos que n√£o h√° raz√£o para colocar a pr√©-carga em uma cena separada, e mais ainda o carregador de <code>Boot</code> inicial separado. <br><br>  Carregaremos todos os ativos no m√©todo de <code>preload</code> - <code>preload</code> .  Para poder trabalhar com o atlas criado no futuro, precisamos executar 2 etapas: <br><br><ol><li>  obtenha os arquivos <code>png</code> e <code>json</code> atlas usando o <code>require</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// StartScene.ts const spritesheetPng = require("./../../assets/spritesheet.png"); const spritesheetJson = require("./../../assets/spritesheet.json"); // ...</span></span></code> </pre><br></li><li>  carregue-os no m√©todo de <code>preload</code> - <code>preload</code> da cena inicial: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// StartScene.ts // ... public preload(): void { this.load.atlas("spritesheet", spritesheetPng, spritesheetJson); } // ...</span></span></code> </pre><br></li></ol><br><a name="section-2-3"></a><h3>  <font color="#008080">2.3 Textos da cena inicial</font> </h3><br>  H√° duas coisas a serem feitas na cena inicial: <br><br><ol><li>  diga ao jogador como iniciar o jogo </li><li>  iniciar o jogo por iniciativa do jogador </li></ol><br>  Para cumprir o primeiro ponto, primeiro crie duas enumera√ß√µes no in√≠cio do arquivo de cena para descrever os textos e seus estilos: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// StartScene.js enum Texts { Title = 'Minesweeper HTML5', Message = 'Click anywhere to start' } enum Styles { Color = '#008080', Font = 'Arial' } //...</span></span></code> </pre><br>  E, em seguida, crie os dois textos como objetos no m√©todo <code>create</code> .  Deixe-me lembr√°-lo de que o m√©todo de <code>create</code> de cenas na <code>Phaser</code> ser√° chamado somente ap√≥s o carregamento de todos os recursos no m√©todo de <code>preload</code> - <code>preload</code> , e isso √© bastante adequado para n√≥s. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// StartScene.js //... public create(): void { this.add.text( this.cameras.main.centerX, this.cameras.main.centerY - 100, Texts.Title, {font: `52px ${Styles.Font}`, fill: Styles.Color}) .setOrigin(0.5); this.add.text( this.cameras.main.centerX, this.cameras.main.centerY + 100, Texts.Message, {font: `28px ${Styles.Font}`, fill: Styles.Color}) .setOrigin(0.5); } //...</span></span></code> </pre><br>  Em outro projeto maior, poder√≠amos levar os textos e os estilos para arquivos json locale ou para configura√ß√µes separadas, mas, como agora temos apenas duas linhas, considero essa etapa redundante e, neste caso, sugiro n√£o complicar nossas vidas, nos limitando a listagens no in√≠cio do arquivo de cena. <br><br><a name="section-2-4"></a><h3>  <font color="#008080">2.4 Transi√ß√£o para o n√≠vel do jogo</font> </h3><br>  A √∫ltima coisa que faremos nesta cena antes de prosseguir √© rastrear o evento de clique do mouse para iniciar o jogador no jogo: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// StartScene.js //... public create(): void { //... this.input.once('pointerdown', () =&gt; { this.scene.start('Game'); }); } //...</span></span></code> </pre> <br><a name="section-2-5"></a><h3>  <font color="#008080">Cena de 2,5 n√≠veis</font> </h3><br>  A julgar pelo par√¢metro <code>"Game"</code> passado para o m√©todo <code>this.scene.start</code> voc√™ j√° imaginou que era hora de criar uma segunda cena, que processaria a l√≥gica principal do jogo.  Crie o <code>src/scripts/scenes/GameScene.ts</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GameScene</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Phaser</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Scene</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(<span class="hljs-string"><span class="hljs-string">'Game'</span></span>); } public create(): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> { } }</code> </pre><br>  Nesta cena, n√£o precisamos do m√©todo de <code>preload</code> - <code>preload</code> , porque  j√° carregamos todos os recursos necess√°rios na cena anterior. <br><br><a name="section-2-6"></a><h3>  <font color="#008080">2.6 Configurando cenas no ponto de entrada</font> </h3><br>  Agora que as duas cenas foram criadas, adicione-as ao nosso ponto de entrada <br>  <code>src/scripts/index.ts</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//... import { StartScene } from "./scenes/StartScene"; import { GameScene } from "./scenes/GameScene"; //... new Phaser.Game({ // ... scene: [StartScene, GameScene] });</span></span></code> </pre><br><a name="section-3"></a><h2>  <font color="#008080">3. Objetos do jogo</font> </h2><br>  Portanto, a classe <code>GameScene</code> implementar√° a l√≥gica no n√≠vel do jogo.  E o que esperamos do n√≠vel do jogo de sapadores?  Visualmente, esperamos ver um campo de jogo com c√©lulas fechadas.  Sabemos que o campo √© uma tabela, o que significa que possui um determinado n√∫mero de linhas e colunas, em v√°rias das quais bombas s√£o confortavelmente colocadas.  Assim, temos informa√ß√µes suficientes para criar uma entidade separada que descreve o campo de jogo. <br><br><a name="section-3-1"></a><h3>  <font color="#008080">3.1 Tabuleiro de jogo</font> </h3><br>  Crie o <code>src/scripts/models/Board.ts</code> no qual colocamos a classe <code>Board</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Field } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./Field"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Board</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Phaser</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Events</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EventEmitter</span></span></span><span class="hljs-class"> </span></span>{ private _scene: Phaser.Scene = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; private _rows: number = <span class="hljs-number"><span class="hljs-number">0</span></span>; private _cols: number = <span class="hljs-number"><span class="hljs-number">0</span></span>; private _bombs: number = <span class="hljs-number"><span class="hljs-number">0</span></span>; private _fields: Field[] = []; <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(scene: Phaser.Scene, rows: number, cols: number, bombs: number) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._scene = scene; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._rows = rows; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._cols = cols; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._bombs = bombs; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._fields = []; } public get cols(): number { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._cols; } public get rows(): number { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._rows; } }</code> </pre> <br>  Vamos fazer da classe o sucessor do Phaser.Events.EventEmitter para acessar a interface para registrar e chamar eventos, que precisaremos no futuro. <br><br>  Uma matriz de objetos da classe <code>Field</code> ser√° armazenada na propriedade privada <code>_fields</code> .  Implementaremos esse modelo mais tarde. <br><br>  Configuramos as propriedades num√©ricas privadas <code>_rows</code> e <code>_cols</code> para indicar o n√∫mero de linhas e colunas do campo de jogo.  Crie getters p√∫blicos para ler <code>_rows</code> e <code>_cols</code> . <br><br>  O campo <code>_bombs</code> nos diz o n√∫mero de bombas que precisar√£o ser geradas para o n√≠vel.  E no par√¢metro <code>_scene</code> passamos uma refer√™ncia ao objeto da cena do jogo <code>GameScene</code> , na qual criaremos uma inst√¢ncia da classe <code>Board</code> . <br><br>  √â importante notar que transferimos o objeto de cena para o modelo apenas para transmiss√£o posterior √†s vistas, onde o usaremos apenas para exibir a vista.  O fato √© que o phaser usa diretamente o objeto de cena para renderizar sprites e, portanto, obriga a fornecer um link para a cena atual ao criar pr√©-fabricados para sprites, que iremos desenvolver no futuro.  E por n√≥s mesmos, aceitaremos o acordo de que transferiremos o link para a cena apenas para uso posterior como um mecanismo de exibi√ß√£o e concordaremos que n√£o chamaremos diretamente os m√©todos personalizados da cena em modelos e visualiza√ß√µes. <br><br>  Depois de decidirmos sobre a interface de cria√ß√£o do tabuleiro, proponho inicializ√°-la na cena do n√≠vel, finalizando a classe <code>GameScene</code> : <br><br><pre> <code class="javascript hljs"> <span class="hljs-comment"><span class="hljs-comment">// GameScene.ts import { Board } from "../models/Board"; const Rows = 8; const Cols = 8; const Bombs = 8; export class GameScene extends Phaser.Scene { private _board: Board = null; //... public create(): void { this._board = new Board(this, Rows, Cols, Bombs); } }</span></span></code> </pre> <br>  Tomamos os par√¢metros do quadro para constantes no in√≠cio do arquivo de cena e os passamos para o construtor do <code>Board</code> ao criar uma inst√¢ncia desta classe. <br><br><a name="section-3-2"></a><h3>  <font color="#008080">3.2 Modelo Celular</font> </h3><br>  O quadro consiste em c√©lulas, que voc√™ deseja exibir na tela.  Cada c√©lula deve ser colocada na posi√ß√£o correspondente, determinada pela linha e coluna. <br><br>  As c√©lulas tamb√©m s√£o selecionadas como uma entidade separada.  Crie o <code>src/scripts/models/Field.ts</code> no qual colocaremos a classe que descreve a c√©lula: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Board } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./Board"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Field</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Phaser</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Events</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EventEmitter</span></span></span><span class="hljs-class"> </span></span>{ private _scene: Phaser.Scene = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; private _board: Board = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; private _row: number = <span class="hljs-number"><span class="hljs-number">0</span></span>; private _col: number = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(scene: Phaser.Scene, board: Board, row: number, col: number) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._init(scene, board, row, col); } public get col(): number { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._col; } public get row(): number { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._row; } public get board(): Board { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._board; } private _init(scene: Phaser.Scene, <span class="hljs-attr"><span class="hljs-attr">board</span></span>: Board, <span class="hljs-attr"><span class="hljs-attr">row</span></span>: number, <span class="hljs-attr"><span class="hljs-attr">col</span></span>: number): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._scene = scene; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._board = board; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._row = row; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._col = col; } }</code> </pre><br>  Cada c√©lula deve ter m√©tricas de linha e coluna em que est√° localizada.  N√≥s configuramos os par√¢metros <code>_board</code> e <code>_scene</code> para definir links para objetos do quadro e da cena.  Implementamos getters para ler os <code>_row</code> , <code>_col</code> e <code>_board</code> . <br><br><a name="section-3-3"></a><h3>  <font color="#008080">3.3 Visualiza√ß√£o de c√©lula</font> </h3><br>  A c√©lula abstrata √© criada e agora queremos visualiz√°-la.  Para exibir uma c√©lula na tela, voc√™ precisa criar sua exibi√ß√£o.  Crie o <code>src/scripts/views/FieldView.ts</code> e coloque a classe de exibi√ß√£o nele: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Field } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"../models/Field"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FieldView</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Phaser</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GameObjects</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sprite</span></span></span><span class="hljs-class"> </span></span>{ private _model: Field = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(scene: Phaser.Scene, model: Field) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(scene, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'spritesheet'</span></span>, <span class="hljs-string"><span class="hljs-string">'closed'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._model = model; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._init(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._create(); } private _init(): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> { } private _create(): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> { } }</code> </pre><br>  Observe que fizemos dessa classe o descendente de <code>Phaser.GameObjects.Sprite</code> .  Em termos de fases, essa classe se tornou uma pr√©-fabricada de sprites.  Ou seja, obtive a funcionalidade do objeto de jogo do sprite, que expandiremos ainda mais com nossos pr√≥prios m√©todos. <br><br>  Vejamos o construtor desta classe.  Aqui, primeiro, devemos chamar o construtor da classe pai com os seguintes conjuntos de par√¢metros: <br><br><ul><li>  link para o objeto de cena (como avisei na se√ß√£o 3.1: phaser exige que vinculemos √† cena atual para renderizar sprites) </li><li>  coordenadas <code>x</code> e <code>y</code> na tela </li><li>  a chave da string para a qual o atlas est√° dispon√≠vel, que carregamos no m√©todo de <code>preload</code> - <code>preload</code> da cena inicial </li><li>  a chave de sequ√™ncia de quadros neste atlas que voc√™ deseja selecionar para exibir o sprite </li></ul><br>  Defina uma refer√™ncia ao modelo (ou seja, uma inst√¢ncia da classe <code>Field</code> ) na propriedade <code>_model</code> privada. <br><br>  Tamb√©m prudentemente iniciamos 2 <code>_create</code> <code>_init</code> e <code>_create</code> atualmente vazios, que implementaremos um pouco mais tarde. <br><br><a name="section-3-4"></a><h3>  <font color="#008080">3.4 Criando um sprite em uma classe de exibi√ß√£o</font> </h3><br>  Ent√£o, a vis√£o foi criada, mas ela ainda n√£o sabe desenhar um sprite.  Para colocar o sprite com o quadro que precisamos na tela, voc√™ precisar√° modificar nosso pr√≥prio m√©todo <code>_create</code> privado: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.js //... private _create(): void { this.scene.add.existing(this); //      this.setOrigin(0.5); //  pivot point    } //...</span></span></code> </pre><br><a name="section-3-5"></a><h3>  <font color="#008080">3.5 Posicionamento de Sprite</font> </h3><br>  No momento, todos os sprites criados ser√£o colocados nas coordenadas (0, 0) da tela.  Tamb√©m precisamos colocar cada c√©lula em sua posi√ß√£o correspondente no quadro.  Ou seja, para o local que corresponde √† linha e coluna desta c√©lula.  Para fazer isso, precisamos escrever um c√≥digo para calcular as coordenadas de cada inst√¢ncia da classe <code>FieldView</code> . <br><br>  Adicione a propriedade <code>_position</code> √† classe, respons√°vel pelas coordenadas finais da c√©lula no campo de jogo: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts //... interface Vec2 {x: number, y: number}; export class FieldView extends Phaser.GameObjects.Sprite { private _position: Vec2 = {x: 0, y: 0}; //...</span></span></code> </pre><br>  Como queremos alinhar a placa e, consequentemente, as c√©lulas nela, em rela√ß√£o ao centro da tela, tamb√©m precisamos da propriedade <code>_offset</code> , indicando o deslocamento dessa c√©lula espec√≠fica em rela√ß√£o √†s bordas esquerda e superior da tela.  Adicione-o com um getter privado: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts //... private get _offset(): Vec2 { return { x: (this.scene.cameras.main.width - this._model.board.cols * this.width) / 2, y: (this.scene.cameras.main.height - this._model.board.rows * this.height) / 2 }; } //...</span></span></code> </pre><br>  Assim, n√≥s: <br><br><ol><li>  Tem a largura total da tela em <code>this._scene.cameras.main.width</code> . </li><li>  Obtivemos a largura total do quadro multiplicando o n√∫mero de c√©lulas pela largura de uma c√©lula: <code>this._board.cols * this.width</code> . </li><li>  Tirando a largura da placa da largura da tela, conseguimos um lugar na tela, n√£o ocupado pela placa. </li><li>  Dividindo o n√∫mero resultante por 2, obtivemos o valor do recuo √† esquerda e √† direita do quadro. </li><li>  Ao mudar cada c√©lula pelo valor desse recuo, garantimos o alinhamento de toda a placa ao longo do eixo <code>x</code> . </li></ol><br>  Realizamos a√ß√µes absolutamente semelhantes para obter deslocamento vertical. <br><br>  Resta adicionar o c√≥digo necess√°rio no m√©todo <code>_init</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts // ... private _init(): void { const offset = this._offset; this.x = this._position.x = offset.x + this.width * this._model.col + this.width / 2; this.y = this._position.y = offset.y + this.height * this._model.row + this.height / 2; } // ...</span></span></code> </pre><br>  As propriedades <code>this.x</code> , <code>this.y</code> , <code>this.width</code> e <code>this.height</code> aqui s√£o as propriedades herdadas da classe pai <code>Phaser.GameObjects.Sprite</code> .  Alterar as propriedades de <code>this.x</code> e <code>this.y</code> leva ao posicionamento correto do sprite na tela. <br><br><a name="section-3-6"></a><h3>  <font color="#008080">3.6 Criando uma inst√¢ncia do FieldView</font> </h3><br>  Crie uma exibi√ß√£o na classe <code>Field</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Field.ts // ... private _view: FieldView = null; public get view(): FieldView { return this._view; } private _init(scene: Phaser.Scene, board: Board, row: number, col: number): void { //... this._view = new FieldView(this._scene, this); } // ...</span></span></code> </pre><br><a name="section-3-7"></a><h3>  <font color="#008080">3.7 Exibir campos do quadro.</font> </h3><br>  Vamos voltar √† classe <code>Board</code> , que √© essencialmente uma cole√ß√£o de objetos <code>Field</code> e criar√° c√©lulas. <br><br>  <code>_create</code> c√≥digo de cria√ß√£o da placa em um m√©todo <code>_create</code> separado e chamaremos esse m√©todo do construtor.  Sabendo que no m√©todo <code>_create</code> n√£o apenas criaremos c√©lulas, <code>_createFields</code> o c√≥digo para criar c√©lulas em um m√©todo <code>_createFields</code> separado. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts constructor(scene: Phaser.Scene, rows: number, cols: number, bombs: number) { // ... this._create(); } private _create(): void { this._createFields(); } private _createFields(): void { }</span></span></code> </pre><br>  √â nesse m√©todo que criaremos o n√∫mero desejado de c√©lulas em um loop aninhado: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts // ... private _createFields(): void { for (let row = 0; row &lt; this._rows; row++) { for (let col = 0; col &lt; this._cols; col++) { this._fields.push(new Field(this._scene, this, row, col)); } } } //...</span></span></code> </pre><br>  √â hora da primeira vez de executar o assembly para depura√ß√£o com o comando <br><br><pre> <code class="plaintext hljs">npm start</code> </pre> <br>  Certifique-se de que, no centro da tela, esperamos ver 64 c√©lulas em 8 linhas. <br><br><a name="section-3-8"></a><h3>  <font color="#008080">3.8 Fazendo bombas</font> </h3><br>  Anteriormente, relatei que no m√©todo <code>_create</code> da classe <code>Board</code> , n√£o apenas criaremos campos.  O que mais?  Tamb√©m haver√° a cria√ß√£o de bombas e a defini√ß√£o das c√©lulas criadas para o n√∫mero de bombas vizinhas.  Vamos come√ßar pelas pr√≥prias bombas. <br><br>  Precisamos colocar N bombas no tabuleiro em c√©lulas aleat√≥rias.  Descrevemos o processo de cria√ß√£o de bombas com um algoritmo aproximado: <br><br><pre> <code class="plaintext hljs">                        </code> </pre><br>  A cada itera√ß√£o do loop, obteremos uma c√©lula aleat√≥ria da propriedade <code>this._fields</code> at√© criarmos tantas bombas quanto indicado no campo <code>this._bombs</code> .  Se a c√©lula recebida estiver vazia, instalaremos uma bomba nela e atualizaremos o contador das bombas necess√°rias para a gera√ß√£o. <br><br>  Para gerar um n√∫mero aleat√≥rio, usamos o m√©todo est√°tico <code>Phaser.Math.Between</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts //... private _createBombs(): void { let count = this._bombs; //      while (count &gt; 0) { //       let field = this._fields[Phaser.Math.Between(0, this._fields.length - 1)]; //    if (field.empty) { //     field.setBomb(); //     --count; //    } } }</span></span></code> </pre><br>  N√£o esque√ßa de escrever a chamada para <code>this._createBombs();</code> no arquivo <code>Board.ts</code> <code>this._createBombs();</code>  no final do m√©todo <code>_create</code> <br><br>  Como voc√™ j√° percebeu, para que esse c√≥digo funcione corretamente, voc√™ precisa refinar a classe <code>Field</code> adicionando o getter <code>empty</code> e o m√©todo <code>setBomb</code> a <code>setBomb</code> . <br><br>  Adicione um campo <code>_value</code> privado √† <code>_value</code> Field, que regular√° o conte√∫do da c√©lula.  Aceitamos os seguintes acordos. <br><div class="scrollable-table"><table><tbody><tr><td>  <code>_value</code> === 0 </td><td>  a c√©lula est√° vazia e n√£o h√° minas ou valores nela </td></tr><tr><td>  <code>_value</code> === -1 </td><td>  existe uma mina na cela </td></tr><tr><td>  <code>_value</code> &gt; 0 </td><td>  na c√©lula √© o n√∫mero de minas localizadas ao lado da c√©lula atual </td></tr></tbody></table></div><br>  Seguindo essas regras, desenvolveremos m√©todos na classe <code>Field</code> que funcionam com a propriedade <code>_value</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Field.ts // ... private _value: number = 0; // ... public get value(): number { return this._value; } public set value(value) { this._value = value; } public get empty(): boolean { return this._value === 0; } public get mined(): boolean { return this._value === -1; } public get filled(): boolean { return this._value &gt; 0; } public setBomb(): void { this._value = -1; } // ...</span></span></code> </pre><br><a name="section-3-9"></a><h3>  <font color="#008080">3.9 Valores de configura√ß√£o</font> </h3><br>  As bombas est√£o organizadas e agora temos todos os dados para definir os valores num√©ricos em todas as c√©lulas que precisam dele. <br><br>  Deixe-me lembr√°-lo de que, de acordo com as regras do sapador, a c√©lula deve ter o n√∫mero que corresponde ao n√∫mero de bombas localizadas pr√≥ximas a essa c√©lula.  Com base nessa regra, escrevemos o pseudoc√≥digo correspondente. <br><br><pre> <code class="plaintext hljs">                  </code> </pre><br>  Na classe <code>Board</code> , crie um novo m√©todo e traduza o pseudoc√≥digo especificado em c√≥digo real: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts //... private _createValues() { //      this._fields.forEach(field =&gt; { //      if (field.mined) { //     field.getClosestFields().forEach(item =&gt; { //      if (item.value &gt;= 0) { ++item.value; } }); } }); } //...</span></span></code> </pre><br>  Vamos ver qual das interfaces que usamos n√£o est√° implementada.  Voc√™ precisa adicionar o m√©todo <code>getClosestFields</code> para obter as c√©lulas vizinhas. <br><br>  Como identificar c√©lulas vizinhas? <br><br>  Por exemplo, considere qualquer c√©lula da placa que n√£o esteja na borda, ou seja, n√£o na linha extrema nem na coluna extrema.  Essas c√©lulas t√™m um n√∫mero m√°ximo de vizinhos: 1 na parte superior, 1 na parte inferior, 3 √† esquerda e 3 √† direita (incluindo c√©lulas na diagonal). <br><br>  Assim, em cada uma das c√©lulas vizinhas, os indicadores <code>_row</code> e <code>_col</code> n√£o diferem em mais de 1. Isso significa que podemos especificar antecipadamente a diferen√ßa entre os par√¢metros <code>_row</code> e <code>_col</code> com o campo atual.  Adicione uma constante no in√≠cio do arquivo √† descri√ß√£o da classe: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Field.ts const Positions = [ {row : 0, col : 1}, //  {row : 0, col : -1}, //  {row : 1, col : 0}, //  {row : 1, col : 1}, //   {row : 1, col : -1}, //   {row : -1, col : 0}, //  {row : -1, col : 1}, //   {row : -1, col : -1} //   ]; //...</span></span></code> </pre><br>  E agora podemos adicionar o m√©todo ausente, no qual percorreremos esse array: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Field.ts //... public getClosestFields(): Field[] { let results = []; //      Positions.forEach(position =&gt; { //      let field = this._board.getField(this._row + position.row, this._col + position.col); //       if (field) { //     results.push(field); } }); return results; }; //...</span></span></code> </pre><br>  N√£o se esque√ßa de verificar a vari√°vel de <code>field</code> a cada itera√ß√£o, pois nem todas as c√©lulas na placa t√™m 8 vizinhos.  Por exemplo, a c√©lula superior esquerda n√£o ter√° vizinhos √† sua esquerda e assim por diante. <br><br>  Resta implementar o m√©todo <code>getField</code> e adicionar todas as chamadas necess√°rias ao m√©todo <code>_create</code> na classe <code>Board</code> <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts //... public getField(row: number, col: number): Field { return this._fields.find(field =&gt; field.row === row &amp;&amp; field.col === col); } //... private _create(): void { this._createFields(); this._createBombs(); this._createValues(); } //...</span></span></code> </pre><br><a name="section-4"></a><h2> <font color="#008080"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. Manipulando Eventos de Entrada</font></font></font> </h2><br><a name="section-4-1"></a><h3> <font color="#008080"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.1 Rastreando eventos de clique do mouse</font></font></font> </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No momento, o painel est√° completamente inicializado, possui bombas e h√° c√©lulas com n√∫meros, mas todas est√£o atualmente fechadas e n√£o h√° como abri-las. </font><font style="vertical-align: inherit;">Vamos corrigir isso e implementar a abertura de c√©lulas clicando no bot√£o esquerdo do mouse. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Primeiro, precisamos rastrear esse mesmo clique. </font><font style="vertical-align: inherit;">Na classe, </font></font><code>FieldView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">adicione o </font></font><code>_create</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">seguinte c√≥digo </font><font style="vertical-align: inherit;">ao final do m√©todo </font><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FielView.ts //... private _create(): void { // ... this.setInteractive(); } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No phaser, voc√™ pode se inscrever em objetos do namespace para diferentes eventos </font></font><code>Phaser.GameObjects</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Em particular, assinaremos o evento click ( </font></font><code>pointerdown</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), a pr√©-fabricada do pr√≥prio sprite, ou seja, um objeto de uma classe </font></font><code>FieldView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">herdada </font></font><code>Phaser.GameObjects.Sprite</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por√©m, antes de fazer isso, devemos indicar explicitamente que o sprite √© potencialmente interativo, ou seja, voc√™ geralmente precisa ouvir as informa√ß√µes do usu√°rio. Voc√™ precisa fazer isso chamando o m√©todo </font></font><code>setInteractive</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sem par√¢metros no pr√≥prio sprite, como fizemos no exemplo acima. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora que nosso sprite se tornou interativo, voltemos √† classe </font></font><code>Board</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no local em que novos objetos de modelo s√£o criados </font></font><code>Field</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ou seja, ao m√©todo </font></font><code>_createFields</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e registramos o retorno de chamada para eventos de entrada para a exibi√ß√£o:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts //... private _createFields(): void { for (let row = 0; row &lt; this._rows; row++) { for (let col = 0; col &lt; this._cols; col++) { const field = new Field(this._scene, this, row, col) field.view.on('pointerdown', this._onFieldClick.bind(this, field)); this._fields.push(field); } } } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Depois de estabelecermos que, clicando no sprite, queremos executar o m√©todo </font></font><code>_onFieldClick</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, precisamos implement√°-lo. Mas removeremos a l√≥gica de processar o clique da classe </font></font><code>Board</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Acredita-se que √© melhor processar o modelo dependendo da entrada e alterar seus dados em um controlador separado, cuja similaridade temos √© a classe da cena do jogo </font></font><code>GameScene</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Portanto, precisamos encaminhar o evento de clique ainda mais, da classe </font></font><code>Board</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para a pr√≥pria cena. Ent√£o vamos fazer:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts //... private _onFieldClick(field: Field, pointer: Phaser.Input.Pointer): void { if (pointer.leftButtonDown()) { this.emit(`left-click`, field); } else if (pointer.rightButtonDown()) { this.emit(`right-click`, field); } } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqui n√£o estamos apenas lan√ßando o evento click como estava, mas tamb√©m especificando qual clique foi. </font><font style="vertical-align: inherit;">Isso ser√° √∫til no futuro, quando na aula de cena processaremos cada op√ß√£o de maneira diferente. </font><font style="vertical-align: inherit;">Obviamente, seria poss√≠vel enviar o evento click como est√°, mas simplificaremos o c√≥digo da cena, deixando parte da l√≥gica do evento em si na classe </font></font><code>Field</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bem, agora vamos voltar √† classe da cena do jogo </font></font><code>GameScene</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e adicionar um </font></font><code>_create</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c√≥digo </font><font style="vertical-align: inherit;">no final do m√©todo </font><font style="vertical-align: inherit;">que rastreia eventos de um clique nas c√©lulas:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts //... import { Field } from "../models/Field"; //... public create(): void { this._board = new Board(this, Rows, Cols, Bombs); this._board.on('left-click', this._onFieldClickLeft, this); this._board.on('right-click', this._onFieldClickRight, this); } private _onFieldClickLeft(field: Field): void { } private _onFieldClickRight(field: Field): void { } //...</span></span></code> </pre><br><a name="section-4-2"></a><h3> <font color="#008080"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.2 </font><font style="vertical-align: inherit;">Processamento do clique esquerdo</font></font></font> </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prosseguimos para implementar o processamento de eventos de clique do mouse. </font><font style="vertical-align: inherit;">E comece abrindo as c√©lulas. </font><font style="vertical-align: inherit;">As c√©lulas devem ser abertas pressionando o bot√£o esquerdo. </font><font style="vertical-align: inherit;">E antes de come√ßarmos a programar, vamos expressar as condi√ß√µes que devem ser atendidas:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ao clicar em uma c√©lula fechada, ela deve ser aberta </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> se houver uma mina em uma c√©lula aberta - o jogo est√° perdido </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> se n√£o houver minas ou valores na c√©lula aberta, min n√£o estar√° nas c√©lulas vizinhas; nesse caso, voc√™ precisar√° abrir todas as c√©lulas vizinhas e continuar fazendo isso at√© que o valor apare√ßa na c√©lula aberta </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> quando voc√™ clica em uma c√©lula aberta, deve verificar se todas as bandeiras est√£o definidas corretamente e, se sim, terminar o jogo com uma vit√≥ria </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> E agora, para simplificar o entendimento da funcionalidade necess√°ria, traduzimos a l√≥gica acima em pseudo-c√≥digo: </font></font><br><br><pre> <code class="plaintext hljs">                         </code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora temos uma compreens√£o do que precisa ser programado. </font><font style="vertical-align: inherit;">Implementamos o m√©todo </font></font><code>_onFieldClickLeft</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// GameScene.ts //... private _onFieldClickLeft(field: Field): void { if (field.closed) { //    field.open(); //   if (field.mined) { //    field.exploded = true; this._onGameOver(false); //   } else if (field.empty) { //    this._board.openClosestFields(field); //   } } else if (field.opened) { //    if (this._board.completed) { //       this._onGameOver(true); //   } } } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E ent√£o, como sempre, finalizaremos as classes </font></font><code>Field</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>Board</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">implementaremos os m√©todos que chamamos no manipulador. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Indicamos 3 estados poss√≠veis da c√©lula na enumera√ß√£o </font></font><code>States</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, adicionamos um campo </font></font><code>_state</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e implementamos um getter para cada estado poss√≠vel:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Field.ts enum States { Closed = 'closed', Opened = 'opened', Marked = 'flag' }; export class Field extends Phaser.Events.EventEmitter { private _state: string = States.Closed; //... public get marked(): boolean { return this._state === States.Marked; } public get closed(): boolean { return this._state === States.Closed; } public get opened(): boolean { return this._state === States.Opened; } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora que temos estados indicando se a c√©lula est√° fechada ou n√£o, podemos adicionar um m√©todo </font></font><code>open</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que alterar√° o estado:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Field.ts //... public open(): void { this._setState(States.Opened); } private _setState(state: string): void { if (this._state !== state) { this._state = state; this.emit('change'); } } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cada altera√ß√£o no estado do modelo deve acionar um evento que relate isso. </font><font style="vertical-align: inherit;">Portanto, introduzimos um m√©todo privado adicional </font></font><code>_setState</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no qual toda a l√≥gica da mudan√ßa de estado ser√° implementada. </font><font style="vertical-align: inherit;">Este m√©todo ser√° chamado em todos os m√©todos p√∫blicos do modelo, que devem mudar de estado. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adicione um sinalizador booleano </font></font><code>_exploded</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para indicar explicitamente exatamente o objeto Field que foi explodido:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Field.ts private _exploded: boolean = false; //... public set exploded(exploded: boolean) { this._exploded = exploded; this.emit('change'); } public get exploded(): boolean { return this._exploded; } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora abra a classe </font></font><code>Board</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e implemente o m√©todo nela </font></font><code>openClosestFields</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Este m√©todo √© recursivo e sua tarefa ser√° abrir todos os campos vizinhos vazios em rela√ß√£o √† c√©lula aceita no par√¢metro. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O algoritmo ser√° o seguinte:</font></font><br><br><pre> <code class="plaintext hljs"> :                </code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> E desta vez j√° temos todas as interfaces necess√°rias para a implementa√ß√£o completa deste m√©todo: </font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts //... public openClosestFields(field: Field): void { field.getClosestFields().forEach(item =&gt; {//     if (item.closed) {//    item.open();//   if (item.empty) {//    this.openClosestFields(item);//     } } }); } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adicione um getter </font></font><code>completed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√† classe </font></font><code>Board</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para indicar o posicionamento correto das bandeiras no quadro. </font><font style="vertical-align: inherit;">Como podemos determinar se um quadro foi liberado com sucesso? </font><font style="vertical-align: inherit;">O n√∫mero de campos marcados corretamente deve ser igual ao n√∫mero total de bombas no tabuleiro.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts //... public get completed(): boolean { return this._fields.filter(field =&gt; field.completed).length === this._bombs; } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este m√©todo filtra a matriz </font></font><code>_fields</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pelo getter </font></font><code>completed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, o que deve indicar a validade da marca do campo. </font><font style="vertical-align: inherit;">Se o comprimento da matriz filtrada (na qual somente os campos marcados corretamente ca√≠rem, pelos quais o getter </font></font><code>completed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">j√° </font><font style="vertical-align: inherit;">√© respons√°vel </font><font style="vertical-align: inherit;">pela classe </font></font><code>Field</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) for igual ao valor do campo </font></font><code>_bombs</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(ou seja, o n√∫mero de bombas no tabuleiro), ent√£o retornaremos </font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, em outras palavras, consideraremos o jogo ganho. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tamb√©m n√£o nos importamos com a oportunidade de abrir todo o quadro com uma chamada, o que temos que fazer no final do n√≠vel. </font><font style="vertical-align: inherit;">Tamb√©m adicionaremos esse recurso √† classe </font></font><code>Board</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts //... public open(): void { this._fields.forEach(field =&gt; field.open()); } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Resta adicionar um getter </font></font><code>completed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√† pr√≥pria classe </font></font><code>Field</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Nesse caso, o campo ser√° considerado limpo com √™xito? </font><font style="vertical-align: inherit;">Se for extra√≠do e sinalizado. </font><font style="vertical-align: inherit;">Ambos os getters necess√°rios j√° est√£o l√° e podemos adicionar este m√©todo:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Field.ts //... public get completed(): boolean { return this.marked &amp;&amp; this.mined; } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para concluir o processamento do clique esquerdo do mouse, criaremos um m√©todo </font></font><code>_onGameOver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no qual desativamos o rastreamento de eventos do tabuleiro e mostraremos ao jogador o tabuleiro inteiro. </font><font style="vertical-align: inherit;">Mais tarde, n√≥s tamb√©m adicionar o c√≥digo para a presta√ß√£o de relat√≥rios sobre o estado de conclus√£o do n√≠vel com base no par√¢metro </font></font><code>status</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// GameScene.ts //... private _onGameOver(status: boolean) { this._board.off('left-click', this._onFieldClickLeft, this); this._board.off('right-click', this._onFieldClickRight, this); this._board.open(); } //...</span></span></code> </pre><br><a name="section-4-3"></a><h3> <font color="#008080"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.3 Exibi√ß√£o em campo</font></font></font> </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Antes de come√ßar a processar o clique com o bot√£o direito, aprenderemos como redesenhar as c√©lulas rec√©m-abertas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anteriormente, </font></font><code>Field</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">desenvolvemos um m√©todo </font></font><code>_setState</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que dispara um evento </font></font><code>change</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">quando o estado do modelo √© alterado. Usaremos isso e, na classe, </font></font><code>FieldView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rastrearemos este evento:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts //... private _init(): void { //... this._model.on('change', this._onStateChange, this); } private _onStateChange(): void { this._render(); } private _render(): void { this.setFrame(this._frameName); } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tornamos especificamente o m√©todo intermedi√°rio um </font></font><code>_onStateChange</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">retorno de chamada do evento de altera√ß√£o do modelo. </font><font style="vertical-align: inherit;">No futuro, precisaremos verificar como o modelo foi alterado para entender se √© necess√°rio executar </font></font><code>_render</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para mostrar o sprite atual de uma c√©lula em um novo estado, voc√™ precisa alterar seu quadro. </font><font style="vertical-align: inherit;">Como carregamos o atlas como ativo, podemos chamar o m√©todo </font></font><code>setFrame</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para alterar o quadro atual para um novo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para obter o quadro em uma linha, usamos astuciosamente o getter </font></font><code>_frameName</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que agora precisa ser implementado. </font><font style="vertical-align: inherit;">Primeiro, descrevemos todos os valores poss√≠veis que um quadro de c√©lula pode assumir.</font></font><br><div class="scrollable-table"><table><tbody><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Moldura </font></font></td><td>  Condi√ß√£o </td></tr><tr><td> <code>closed</code> </td> <td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> O campo est√° fechado </font></font><br></td></tr><tr><td> <code>flag</code> </td> <td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Campo sinalizado </font></font><br></td></tr><tr><td> <code>empty</code> </td> <td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> O campo est√° aberto, n√£o √© extra√≠do ou preenchido com valor </font></font><br></td></tr><tr><td> <code>exploded</code> <br> </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> o campo est√° aberto, minado e explodido </font></font><br></td></tr><tr><td> <code>mined</code> <br> </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> o campo est√° aberto, minado, mas n√£o explodido </font></font><br></td></tr><tr><td> <code>1...9</code> <br> </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> o campo est√° aberto e exibe um valor de 1 a 9, indicando o n√∫mero de bombas ao lado desse campo </font></font><br></td></tr></tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Temos uma descri√ß√£o de todos os estados e j√° temos todos os m√©todos do modelo, gra√ßas aos quais esses estados podem ser obtidos. </font><font style="vertical-align: inherit;">Vamos fazer uma pequena configura√ß√£o no in√≠cio do arquivo:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts const States = { 'closed': field =&gt; field.closed, 'flag': field =&gt; field.marked, 'empty': field =&gt; field.opened &amp;&amp; !field.mined &amp;&amp; !field.filled, 'exploded': field =&gt; field.opened &amp;&amp; field.mined &amp;&amp; field.exploded, 'mined': field =&gt; field.opened &amp;&amp; field.mined &amp;&amp; !field.exploded } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As chaves neste objeto ser√£o os valores dos quadros e os valores dessas chaves s√£o os retornos de chamada que retornam um resultado booleano. </font><font style="vertical-align: inherit;">Com base nessa configura√ß√£o, podemos desenvolver um m√©todo para obter o quadro desejado (ou seja, a chave da configura√ß√£o):</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts //... private get _frameName(): string { for (let key in States) { if (States[key](this._model)) { return key; } } return this._model.value.toString(); }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Assim, por enumera√ß√£o simples em um loop, examinamos todas as chaves do objeto de configura√ß√£o e chamamos cada retorno de chamada por vez. </font><font style="vertical-align: inherit;">A fun√ß√£o que nos retorna primeiro </font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">indica que a chave </font></font><code>key</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">na itera√ß√£o atual √© o quadro correto para o estado atual do modelo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se nenhuma chave for adequada, para o estado padr√£o, consideraremos um campo aberto com um valor </font></font><code>_value</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, pois </font></font><code>States</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n√£o definimos </font><font style="vertical-align: inherit;">esse estado na configura√ß√£o </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora podemos testar completamente o clique esquerdo nos campos do quadro e verificar como as c√©lulas se abrem e o que √© exibido depois de abri-las.</font></font><br><br><a name="section-4-4"></a><h3> <font color="#008080"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.4 Processamento com o bot√£o direito</font></font></font> </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como no caso de criar o manipulador com o bot√£o esquerdo, primeiro definimos claramente a funcionalidade esperada. </font><font style="vertical-align: inherit;">Ao clicar com o bot√£o direito do mouse, devemos marcar a c√©lula selecionada com um sinalizador. </font><font style="vertical-align: inherit;">Mas existem certas condi√ß√µes.</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Apenas um campo fechado que n√£o est√° marcado no momento pode ser sinalizado </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Se o campo estiver marcado, clique novamente com o bot√£o direito do mouse para remover o sinalizador do campo </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ao definir / remover um sinalizador, √© necess√°rio atualizar o n√∫mero de sinalizadores dispon√≠veis no n√≠vel e exibir o texto com o n√∫mero atual </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Traduzindo essas condi√ß√µes em pseudo-c√≥digo, obtemos as seguintes linhas de coment√°rios: </font></font><br><br><pre> <code class="plaintext hljs">                              </code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Agora podemos traduzir esse algoritmo em chamadas para os m√©todos de que precisamos, mesmo que eles ainda n√£o tenham sido desenvolvidos: </font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// GameScene.ts private _flags: number = 0; //... private _onFieldClickRight(field: Field): void { if (field.closed &amp;&amp; this._flags &gt; 0) { //        field.addFlag(); //     } else if (field.marked) { //     field.removeFlag(); //   } this._flags = Bombs - this._board.countMarked; } //... public create(): void { this._flags = Bombs; //... } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqui tamb√©m iniciamos um novo campo </font></font><code>_flags</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que no in√≠cio do n√≠vel do jogo √© igual ao n√∫mero de bombas no tabuleiro, pois no in√≠cio do jogo nenhuma bandeira foi definida. </font><font style="vertical-align: inherit;">Esse campo √© for√ßado a ser atualizado a cada clique direito, pois nesse caso o sinalizador √© adicionado ou removido do quadro. </font><font style="vertical-align: inherit;">Adicione um </font></font><code>Board</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">getter </font><font style="vertical-align: inherit;">√† classe </font></font><code>countMarked</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Board.ts //... public get countMarked(): number { return this._fields.filter(field =&gt; field.marked).length; } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Definir e remover o sinalizador √© uma altera√ß√£o no estado do modelo </font></font><code>Field</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">; portanto, implementamos esses m√©todos na classe correspondente de maneira semelhante ao m√©todo </font></font><code>open</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Field.ts //... public addFlag(): void { this._setState(States.Marked); } public removeFlag(): void { this._setState(States.Closed); } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deixe-me lembr√°-lo de que ele </font></font><code>_setState</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">acionar√° um evento </font></font><code>change</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que √© rastreado na exibi√ß√£o e, portanto, o sprite ser√° redesenhado automaticamente desta vez quando o modelo for alterado. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ao testar a funcionalidade desenvolvida, voc√™ certamente descobrir√° que sempre que clicar no bot√£o direito do mouse, um menu de contexto √© aberto. </font><font style="vertical-align: inherit;">Adicione o c√≥digo que desativa esse comportamento ao construtor da cena do jogo:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// GameScene.ts //... constructor() { super('Game'); //        document.querySelector("canvas").oncontextmenu = e =&gt; e.preventDefault(); } //...</span></span></code> </pre><br><a name="section-4-5"></a><h3> <font color="#008080"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.5 Objeto GameSceneView</font></font></font> </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para exibir a interface do usu√°rio na cena do jogo, criaremos uma classe </font></font><code>GameSceneView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e a colocaremos </font></font><code>src/scripts/views/GameSceneView.ts</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nesse caso, agiremos de maneira diferente da cria√ß√£o </font></font><code>FieldView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e n√£o faremos desta classe um pr√©-fabricado e um herdeiro </font></font><code>GameObjects</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nesse caso, precisamos gerar os seguintes elementos da exibi√ß√£o da cena:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> texto no n√∫mero de sinalizadores </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bot√£o sair </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mensagem de status de conclus√£o do jogo (vit√≥ria / derrota) </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos transformar cada elemento da interface do usu√°rio em um campo separado na classe </font></font><code>GameSceneView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos preparar um esbo√ßo.</font></font><br><br><pre> <code class="javascript hljs">enum Styles { Color = <span class="hljs-string"><span class="hljs-string">'#008080'</span></span>, Font = <span class="hljs-string"><span class="hljs-string">'Arial'</span></span> } enum Texts { Flags = <span class="hljs-string"><span class="hljs-string">'FLAGS: '</span></span>, Exit = <span class="hljs-string"><span class="hljs-string">'EXIT'</span></span>, Success = <span class="hljs-string"><span class="hljs-string">'YOU WIN!'</span></span>, Failure = <span class="hljs-string"><span class="hljs-string">'YOU LOOSE'</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GameSceneView</span></span></span><span class="hljs-class"> </span></span>{ private _scene: Phaser.Scene = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; private _style: {<span class="hljs-attr"><span class="hljs-attr">font</span></span>: string, <span class="hljs-attr"><span class="hljs-attr">fill</span></span>: string}; <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(scene: Phaser.Scene) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._scene = scene; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._style = {<span class="hljs-attr"><span class="hljs-attr">font</span></span>: <span class="hljs-string"><span class="hljs-string">`28px </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${Styles.Font}</span></span></span><span class="hljs-string">`</span></span>, <span class="hljs-attr"><span class="hljs-attr">fill</span></span>: Styles.Color}; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._create(); } private _create(): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> { } public render() { } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Adicione texto com o n√∫mero de sinalizadores. </font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// GameSceneView.ts //... private _txtFlags: Phaser.GameObjects.Text = null; //... private _createTxtFlags(): void { this._txtFlags = this._scene.add.text( 50, 50, Texts.Flags, this._style ).setOrigin(0, 1); } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esse c√≥digo colocar√° o texto que precisamos em uma posi√ß√£o recuada 50px dos lados superior e esquerdo e o definir√° no estilo especificado. </font><font style="vertical-align: inherit;">Al√©m disso, o m√©todo </font></font><code>setOrigin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">define o ponto de articula√ß√£o do texto para as coordenadas (0, 1). </font><font style="vertical-align: inherit;">Isso significa que o texto ficar√° alinhado com sua borda esquerda. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adicione uma mensagem de status.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// GameSceneView.ts //... private _txtStatus: Phaser.GameObjects.Text = null; //... private _createTxtStatus(): void { this._txtStatus = this._scene.add.text( this._scene.cameras.main.centerX, 50, Texts.Success, this._style ).setOrigin(0.5, 1); this._txtStatus.visible = false; } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Colocamos o texto de status no centro da tela e o alinhamos com o meio da linha, chamando </font></font><code>setOrigin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">com o par√¢metro 0.5 para a coordenada x. </font><font style="vertical-align: inherit;">Al√©m disso, por padr√£o, esse texto precisa ser oculto, pois somente o mostraremos ap√≥s a conclus√£o do jogo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Crie um bot√£o de sa√≠da, que em ess√™ncia tamb√©m √© um objeto de texto.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// GameSceneView.ts //... private _btnExit: Phaser.GameObjects.Text = null; //... private _createBtnExit(): void { this._btnExit = this._scene.add.text( this._scene.cameras.main.width - 50, 50, Texts.Exit, this._style ).setOrigin(1); this._btnExit.setInteractive(); this._btnExit.once('pointerdown', () =&gt; { this._scene.scene.start('Start'); }); } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Colocamos o bot√£o no canto superior direito da tela e o usamos novamente </font></font><code>setOrigin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para alinhar o texto dessa vez com a borda direita. </font><font style="vertical-align: inherit;">Tornamos o bot√£o interativo e adicionamos um retorno de chamada ao evento click, que envia o player para a cena inicial. </font><font style="vertical-align: inherit;">Assim, damos ao jogador a oportunidade de sair do n√≠vel a qualquer momento. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Resta desenvolver um m√©todo </font></font><code>render</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para atualizar corretamente todos os elementos da interface do usu√°rio e adicionar chamadas a todos os m√©todos criados no </font></font><code>_create</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// GameSceneView.ts //... private _create(): void { this._createTxtFlags(); this._createTxtStatus(); this._createBtnExit(); } public render(data: {flags?: number, status?: boolean}) { if (typeof data.flags !== 'undefined') { this._txtFlags.text = Texts.Flags + data.flags.toString(); } if (typeof data.status !== 'undefined') { this._txtStatus.text = data.status ? Texts.Success : Texts.Failure; this._txtStatus.visible = true; } } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dependendo da propriedade transmitida no par√¢metro, atualizamos a interface do usu√°rio, exibindo as altera√ß√µes necess√°rias. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Crie uma representa√ß√£o na cena do jogo na classe GameScene e escreva a chamada no m√©todo _render sempre que necess√°rio, por significado:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// GameScene.ts //... import { GameSceneView } from "../views/GameSceneView"; //... export class GameScene extends Phaser.Scene { private _view: GameSceneView = null; //... private _onGameOver(status: boolean) { //... this._view.render({status}); } //... private _onFieldClickRight(field: Field): void { //... this._flags = Bombs - this._board.countMarked; this._view.render({flags: this._flags}); } //... public create(): void { //... this._view = new GameSceneView(this); this._view.render({flags: this._flags}); } //... }</span></span></code> </pre><br><a name="section-5"></a><h2> <font color="#008080"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5. Anima√ß√µes</font></font></font> </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Que tipo de f√£ criando um jogo, mesmo que simples como o nosso, se n√£o houver anima√ß√µes ?! </font><font style="vertical-align: inherit;">Al√©m disso, desde que come√ßamos a estudar o phaser, vamos nos familiarizar com os recursos mais b√°sicos das anima√ß√µes e considerar a funcionalidade dos g√™meos. </font><font style="vertical-align: inherit;">G√™meos s√£o implementados na pr√≥pria estrutura e nenhuma biblioteca de terceiros √© necess√°ria. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adicione 2 anima√ß√µes ao jogo: encher o tabuleiro com c√©lulas no in√≠cio e virar a c√©lula na abertura. </font><font style="vertical-align: inherit;">Vamos come√ßar com o primeiro deles.</font></font><br><br><a name="section-5-1"></a><h3> <font color="#008080"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.1 Anima√ß√£o de preenchimento de quadro</font></font></font> </h3><br><img src="https://habrastorage.org/webt/7r/uu/1v/7ruu1vtppaw26sp-fapxbahgm9q.gif"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Garantimos que todas as c√©lulas da placa voem no lugar a partir da borda superior esquerda da tela. </font><font style="vertical-align: inherit;">Ao iniciar o n√≠vel do jogo, precisamos mudar todas as c√©lulas para o canto superior esquerdo da tela e para cada c√©lula iniciar a anima√ß√£o do movimento para as coordenadas correspondentes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Na classe, </font></font><code>FiledView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">adicione a </font></font><code>_create</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">chamada </font><font style="vertical-align: inherit;">ao final dos m√©todos </font></font><code>_animateShow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts //... private _create(): void { //... this._animateShow(); } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B implementamos o novo m√©todo que precisamos. </font><font style="vertical-align: inherit;">Nele, como concordamos acima, √© necess√°rio executar duas coisas:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mova a c√©lula para tr√°s do canto superior esquerdo para que n√£o fique vis√≠vel na tela </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> inicie o movimento duplo com as coordenadas desejadas com o atraso correto </font></font></li></ol><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts //... private _animateShow(): Promise&lt;void&gt; { this.x = -this.width; this.y = -this.height; const delay = this._model.row * 50 + this._model.col * 10; return this._moveTo(this._position, delay); } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como o canto superior esquerdo da tela possui coordenadas (0, 0), se definirmos a c√©lula com as coordenadas iguais aos seus valores negativos de largura e altura, isso colocar√° a c√©lula atr√°s do canto superior esquerdo e ocultar√° a tela. </font><font style="vertical-align: inherit;">Assim, conclu√≠mos nossa primeira tarefa. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O segundo objetivo a alcan√ßar, chamando o m√©todo </font></font><code>_moveTo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts //... private _moveTo(position: Vec2, delay: number): Promise&lt;void&gt; { return new Promise(resolve =&gt; { this.scene.tweens.add({ targets: this, x: position.x, y: position.y, duration: 600, ease: 'Elastic', easeParams: [1, 1], delay, onComplete: () =&gt; { resolve(); } }); }); } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para criar uma anima√ß√£o, usamos a propriedade scene </font></font><code>tweens</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">No m√©todo dele, </font></font><code>add</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">passamos o objeto de configura√ß√£o com as configura√ß√µes:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A propriedade </font></font><code>targets</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqui deve conter como valor os objetos de jogo aos quais voc√™ deseja aplicar efeitos de anima√ß√£o. </font><font style="vertical-align: inherit;">No nosso caso, este √© um link </font></font><code>this</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para o objeto atual, pois √© uma pr√©-fabricada do sprite.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> O segundo e o terceiro par√¢metros passam pelas coordenadas do destino. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A propriedade </font></font><code>duration</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√© respons√°vel pela dura√ß√£o da anima√ß√£o, no nosso caso - 600ms.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Par√¢metros </font></font><code>ease</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>easeParams</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">defina a fun√ß√£o de atenua√ß√£o.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No campo atraso, substitu√≠mos o valor do segundo argumento, gerado para cada c√©lula individual, levando em considera√ß√£o sua posi√ß√£o no quadro. </font><font style="vertical-align: inherit;">Isso √© feito para que as c√©lulas n√£o voem ao mesmo tempo. </font><font style="vertical-align: inherit;">Em vez disso, cada c√©lula aparecer√° com um pequeno atraso em rela√ß√£o √† anterior.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por fim, </font></font><code>onComplete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">colocamos um retorno de chamada </font><font style="vertical-align: inherit;">na propriedade </font><font style="vertical-align: inherit;">, que ser√° chamado no final da a√ß√£o de interpola√ß√£o.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√â razo√°vel envolver o g√™meo em uma promessa para que, no futuro, seja capaz de atracar maravilhosamente diferentes anima√ß√µes, para que, no retorno de chamada, fa√ßamos uma chamada de fun√ß√£o </font></font><code>resolve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">indicando a execu√ß√£o bem-sucedida da anima√ß√£o.</font></font><br><br><a name="section-5-2"></a><h3> <font color="#008080"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.2 Anima√ß√µes de flip de c√©lula</font></font></font> </h3><br><img src="https://habrastorage.org/webt/uc/d-/yw/ucd-yw-nq6a4veixb-npp0mdyqy.gif"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ser√° √≥timo se, quando a c√©lula foi aberta, o efeito de sua revers√£o foi reproduzido. Como podemos conseguir isso? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A abertura de uma c√©lula √© atualmente realizada alterando o quadro quando o m√©todo √© chamado </font></font><code>_render</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">na exibi√ß√£o. Se verificarmos o estado do modelo neste m√©todo, veremos se a c√©lula estava aberta. Se a c√©lula estiver aberta, inicie a anima√ß√£o em vez de exibir instantaneamente um novo quadro de revers√£o.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts //... private _onStateChange(): void { if (this._model.opened) { this._animateFlip(); } else { this._render(); } } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para obter o efeito desejado, utilizar transforma√ß√£o do sprite atrav√©s da propriedade </font></font><code>scale</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Se escalarmos o sprite ao longo do eixo </font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para zero </font><font style="vertical-align: inherit;">com o tempo </font><font style="vertical-align: inherit;">, ele diminuir√°, conectando os lados esquerdo e direito. </font><font style="vertical-align: inherit;">E vice-versa, se voc√™ escalar o sprite ao longo do eixo </font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de zero a sua largura total, o esticaremos para o tamanho m√°ximo. </font><font style="vertical-align: inherit;">N√≥s implementar esta l√≥gica no m√©todo </font></font><code>_animateFlip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts //... private _animateFlip(): void { this._scaleXTo(0).then(() =&gt; { this._render(); this._scaleXTo(1); }) } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por analogia com o m√©todo, </font></font><code>_moveTo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">implementamos </font></font><code>_scaleTo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// FieldView.ts //... private _scaleXTo(scaleX: number): Promise&lt;void&gt; { return new Promise(resolve =&gt; { this.scene.tweens.add({ targets: this, scaleX, ease: 'Elastic.easeInOut', easeParams: [1, 1], duration: 150, onComplete: () =&gt; { resolve() } }); }); } //...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Neste m√©todo, como par√¢metro, pegamos o valor da escala, que usaremos para alterar o tamanho do sprite em ambas as dire√ß√µes e pass√°-lo como um segundo par√¢metro para o objeto de configura√ß√£o da anima√ß√£o. </font><font style="vertical-align: inherit;">Todos os outros par√¢metros de configura√ß√£o j√° nos s√£o familiares da anima√ß√£o anterior. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora iniciaremos o projeto para teste e, ap√≥s a depura√ß√£o, consideraremos nosso jogo conclu√≠do e a tarefa de teste conclu√≠da!</font></font> :) <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Agrade√ßo sinceramente a todos por terem chegado a este momento comigo! </font></font><br><br><h2>  Conclus√£o </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Colegas, ficarei muito satisfeito se o material apresentado no artigo for √∫til para voc√™ e voc√™ pode usar essas ou as abordagens descritas em seus pr√≥prios projetos. Voc√™ sempre pode recorrer a mim com qualquer pergunta, tanto neste artigo quanto na programa√ß√£o fasorial ou no gamedev em geral. Congratulo-me com a comunica√ß√£o e ficarei feliz em fazer novos conhecidos e trocar experi√™ncias! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E eu tenho uma pergunta para voc√™ agora. Desde que estou criando tutoriais em v√≠deo sobre desenvolvimento de jogos, naturalmente acumulei uma d√∫zia desses pequenos jogos. Cada jogo abre a estrutura √† sua maneira. Por exemplo, neste jogo, abordamos o tema dos g√™meos, mas existem muitos outros recursos, como f√≠sica, mapa de pe√ßas, coluna, etc.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A esse respeito, a pergunta √©: voc√™ gostou deste artigo e, em caso afirmativo, estaria interessado em continuar a ler artigos como este, mas sobre outros pequenos jogos cl√°ssicos? </font><font style="vertical-align: inherit;">Se a resposta for afirmativa, traduzirei com prazer os materiais dos meus tutoriais em v√≠deo para o formato de texto e continuarei publicando novos manuais ao longo do tempo, mas para outros jogos. </font><font style="vertical-align: inherit;">Eu trago a pesquisa correspondente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obrigado a todos pela aten√ß√£o! </font><font style="vertical-align: inherit;">Terei o maior prazer em feedback e at√© breve!</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt476682/">https://habr.com/ru/post/pt476682/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt476670/index.html">Vis√£o geral do CAD no n√∫cleo geom√©trico C3D - 2</a></li>
<li><a href="../pt476674/index.html">Implementa√ß√£o r√°pida do ReportPortal para familiariza√ß√£o</a></li>
<li><a href="../pt476676/index.html">48 recursos de c√≥digo aberto para JavaScript (2019)</a></li>
<li><a href="../pt476678/index.html">API para busca ass√≠ncrona remota usando o Apple Combine</a></li>
<li><a href="../pt476680/index.html">O sistema de planejamento cont√≠nuo da produ√ß√£o de Rodov √© o Lean / MRP sovi√©tico de 1961. Decolagem, p√¥r do sol e novo nascimento</a></li>
<li><a href="../pt476686/index.html">Desenvolvimento de um gateway IoT baseado em Raspberry CM3 +</a></li>
<li><a href="../pt476688/index.html">Novo curso da OTUS. ‚ÄúDesenvolvedor de iOS. Curso Avan√ßado V 2.0 ¬ª</a></li>
<li><a href="../pt476692/index.html">Princ√≠pios de Marketing de Conte√∫do</a></li>
<li><a href="../pt476694/index.html">Sobre rob√≥tica comercial com Farida Roslovets e diretora da empresa RPA electroNeek</a></li>
<li><a href="../pt476696/index.html">Como criar e implantar full-stack Reagir aplica√ß√£o</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>