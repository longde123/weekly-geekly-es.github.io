<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘©ğŸ¿â€ğŸ­ ğŸ¤·ğŸ¼ âºï¸ Ketikkan semuanya âœ‹ğŸ¼ â™ï¸ ğŸ§‘ğŸ¿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo semuanya! 


 Kami sudah memiliki satu artikel tentang pengembangan pengetikan di Ostrovok.ru . Ini menjelaskan mengapa kita beralih dari pyContr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ketikkan semuanya</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ostrovok/blog/480930/"><p>  Halo semuanya! </p><br><p>  Kami sudah memiliki <a href="https://habr.com/ru/company/ostrovok/blog/443470/">satu artikel</a> tentang pengembangan pengetikan di <a href="https://www.habr.com/%3Futm_source%3Dhabr%26utm_medium%3Dpr%26utm_campaign%3Dbogdanova_dec19%26utm_content%3Darticle">Ostrovok.ru</a> .  Ini menjelaskan mengapa kita beralih dari pyContracts ke typeguard, mengapa kita beralih ke typeguard dan berakhir dengan apa.  Dan hari ini saya akan memberi tahu Anda lebih banyak tentang bagaimana transisi ini terjadi. </p><br><img src="https://habrastorage.org/webt/xk/gm/wn/xkgmwnrl0mygmpduhrg879p-nhe.jpeg"><a name="habracut"></a><br><p>  Deklarasi fungsi dengan pyContracts umumnya terlihat seperti ini: </p><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> contracts <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> new_contract <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> datetime @new_contract <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">User</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> models <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> User <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> isinstance(x, User) @new_contract <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dt_datetime</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> isinstance(x, datetime.datetime) @contract <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(user_list, amount, dt=None)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" :type user_list: list(User) :type amount: int|float :type dt: dt_datetime|None :rtype: bool """</span></span> â€¦</code> </pre> <br><p>  Ini adalah contoh abstrak, karena dalam proyek kami saya tidak menemukan definisi fungsi yang pendek dan bermakna dalam hal jumlah kasus untuk pemeriksaan jenis.  Biasanya, definisi untuk pyContracts disimpan dalam file yang tidak mengandung logika lain.  Perhatikan bahwa di sini Pengguna adalah kelas pengguna tertentu, dan tidak diimpor secara langsung. </p><br><p>  Dan ini adalah hasil yang diinginkan dengan typeguard: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> typechecked <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> typechecked <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> typing <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> List, Optional, Union <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> models <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> User <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> datetime @typechecked <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(user_list: List[User], amount: Union[int, float], dt: Optional[datetime.datetime]=None)</span></span></span><span class="hljs-function"> -&gt; bool:</span></span> ...</code> </pre> <br><p>  Secara umum, ada begitu banyak fungsi dan metode dengan pengecekan tipe dalam proyek sehingga jika Anda menumpuknya dalam tumpukan, Anda dapat mencapai bulan.  Jadi menerjemahkannya secara manual dari pyContracts ke typeguard sama sekali tidak mungkin (saya sudah mencoba!).  Jadi saya memutuskan untuk menulis naskah. </p><br><p>  Script dibagi menjadi dua bagian: satu cache impor kontrak baru, dan yang kedua berkaitan dengan kode refactoring. </p><br><p>  Saya ingin mencatat bahwa tidak satu pun dari skrip lain mengklaim sebagai universal.  Kami tidak bermaksud untuk menulis alat untuk menyelesaikan semua kasus yang diperlukan.  Oleh karena itu, saya sering menghilangkan pemrosesan otomatis dari beberapa kasus khusus, jika jarang ditemukan dalam proyek, lebih cepat untuk memperbaikinya dengan tangan.  Misalnya, skrip untuk menghasilkan kontrak pemetaan dan impor mengumpulkan 90% dari nilai, 10% sisanya adalah pemetaan kerajinan tangan. </p><br><p>  Logika skrip untuk menghasilkan pemetaan: </p><br><p>  Langkah 1. Telusuri semua file proyek, bacalah.  Untuk setiap file: </p><br><ul><li>  jika substring "@new_contract" tidak ada, lewati file ini, </li><li>  jika ada, maka bagi file dengan baris "@new_contract".  Untuk setiap item: <br>  - parse untuk definisi dan impor, <br>  - jika berhasil, tulis ke file keberhasilan, <br>  - jika tidak, tulis ke file kesalahan. </li></ul><br><p>  Langkah 2. Secara manual memproses kesalahan </p><br><p>  Sekarang kita memiliki nama-nama semua jenis yang digunakan pyContracts (mereka didefinisikan dengan dekorator new_contract), dan kita memiliki semua impor yang diperlukan, kita dapat menulis kode untuk refactoring.  Ketika saya menerjemahkan dari pyContracts untuk mengetikkan secara manual, saya menyadari apa yang saya butuhkan dari skrip: </p><br><ol><li>  Ini adalah perintah yang mengambil nama modul sebagai argumen (beberapa dapat digunakan), di mana sintaks penjelasan fungsi harus diganti. </li><li>  Bacalah semua file modul, bacalah.  Untuk setiap file: <br><ul><li>  jika tidak ada substring "@ kontrak", lewati file ini; </li><li>  jika demikian, ubah kode menjadi ast (pohon sintaksis abstrak); </li><li>  temukan semua fungsi yang ada di bawah dekorator kontrak untuk masing-masing: <br><ul><li>  dapatkan dockstring, parse, lalu hapus, </li><li>  buat kamus formulir {arg_name: arg_type}, gunakan untuk menggantikan anotasi fungsi, </li><li>  ingat impor baru, </li></ul></li><li>  tulis pohon yang dimodifikasi ke file melalui astunparse; </li><li>  tambahkan impor baru ke bagian atas file; </li><li>  ganti baris "kontrak @" dengan "tanda centang" karena lebih mudah daripada melalui ast. </li></ul></li></ol><br><p>  Pecahkan pertanyaan "apakah nama ini sudah diimpor dalam file ini?"  Saya tidak berniat dari awal: dengan masalah ini kita akan mengatasi menjalankan tambahan perpustakaan isort. </p><br><p>  Tetapi setelah menjalankan versi pertama skrip, muncul pertanyaan yang masih harus diselesaikan.  Ternyata 1) ast tidak maha kuasa, 2) astunparse lebih maha kuasa dari yang kita inginkan.  Ini dimanifestasikan sebagai berikut: </p><br><ul><li>  pada saat transisi ke pohon sintaks, semua komentar baris tunggal hilang dari kode; </li><li>  garis kosong juga menghilang; </li><li>  ast tidak membedakan antara fungsi dan metode kelas, kami harus menambahkan logika; </li><li>  sebaliknya, ketika pindah dari pohon ke kode, komentar multi-baris dalam tanda kutip tiga ditulis dalam komentar tanda kutip tunggal dan menempati satu baris, dan baris baru digantikan oleh \ n; </li><li>  tanda kurung yang tidak perlu muncul, misalnya jika A dan B dan C atau D menjadi jika ((A dan B dan C) atau D). </li></ul><br><p>  Kode yang melewati ast dan astunparse tetap berfungsi, tetapi keterbacaannya berkurang. </p><br><p>  Kelemahan paling serius dari hal di atas adalah menghilangnya komentar satu baris (dalam kasus lain, kita tidak kehilangan apa-apa, tetapi hanya mendapatkan - tanda kurung, misalnya).  Perpustakaan mengerikan berdasarkan ast, astunparse, dan tokenize janji untuk mencari tahu ini.  Janji dan janji. </p><br><p>  Sekarang baris kosong.  Ada dua solusi yang mungkin: </p><br><ol><li>  tokenize tahu bagaimana menentukan "bagian bicara" dari python, dan horast mengambil keuntungan darinya ketika mendapat token jenis komentar.  Tetapi tokenize juga memiliki token seperti NewLine dan NL.  Jadi, Anda perlu melihat bagaimana horor mengembalikan komentar, dan menyalin, mengganti jenis token. <br>  <em>- disarankan Anya, pengalaman dalam mengembangkan 2 bulan</em> </li><li>  Karena horast dapat mengembalikan komentar, pertama-tama kami mengganti semua baris kosong dengan komentar tertentu, kemudian melewati horast dan mengganti komentar kami dengan baris kosong. <br>  <em>- datang dengan Eugene, pengalaman dalam mengembangkan 8 tahun</em> </li></ol><br><p>  Saya akan mengatakan sedikit lebih rendah tentang tanda kutip tiga dalam komentar, dan itu cukup mudah untuk memasang tanda kurung tambahan, terutama karena beberapa dari mereka dihapus oleh pemformatan otomatis. </p><br><p>  Dalam horast kami menggunakan dua fungsi: parse dan unparse, tetapi keduanya tidak ideal - parse mengandung kesalahan internal yang aneh, dalam kasus yang jarang terjadi tidak dapat mengurai kode sumber, dan unparse tidak dapat menulis sesuatu yang memiliki tipe ketik (jenis yang Ternyata jika Anda mengetik (any_other_type)). </p><br><p>  Saya memutuskan untuk tidak berurusan dengan parse, karena logika kerja agak membingungkan, dan pengecualian jarang terjadi - prinsip non-universalitas bekerja di sini. </p><br><p>  Tetapi pekerjaan yang tidak jelas sangat jelas dan cukup elegan.  Fungsi unparse membuat turunan dari kelas Unparser, yang <strong>init</strong> memproses pohon dan kemudian menulisnya ke file.  Horast.Unparser berturut-turut diwarisi dari banyak Unparser lainnya, di mana kelas paling dasar adalah astunparse.Unparser.  Semua kelas turunan hanya memperluas fungsionalitas kelas dasar, tetapi logika pekerjaan tetap sama, jadi pertimbangkan astunparse.Unparser.  Ini memiliki lima metode penting: </p><br><ol><li>  tulis - hanya menulis sesuatu ke file. </li><li>  fill - uses write berdasarkan jumlah indentasi (jumlah indentasi disimpan sebagai bidang kelas). </li><li>  enter - meningkatkan indentasi. </li><li>  meninggalkan - mengurangi indentasi. </li><li>  dispatch - menentukan jenis simpul pohon (katakanlah T), memanggil metode yang sesuai dengan nama jenis simpul, tetapi dengan garis bawah (mis. _T).  Ini adalah metode meta. </li></ol><br><p>  Semua metode lain adalah metode bentuk _T, misalnya, _Module atau _Str.  Dalam setiap metode seperti itu, dapat: 1) mengirimkan secara rekursif untuk node subtree, atau 2) menggunakan menulis untuk menulis isi node atau menambahkan karakter dan kata kunci sehingga hasilnya adalah ekspresi yang valid dalam python. </p><br><p>  Sebagai contoh, kami menemukan sebuah simpul bertipe arg, di mana ia menyimpan nama argumen dan simpul anotasi.  Kemudian pengiriman akan memanggil metode _arg, yang pertama-tama akan menuliskan nama argumen, kemudian menulis titik dua dan menjalankan pengiriman untuk node anotasi, di mana subtree penjelasan akan diuraikan, dan pengiriman dan menulis masih akan dipanggil untuk subtree ini. </p><br><p>  Mari kita kembali ke masalah kita tentang ketidakmungkinan jenis tipe pemrosesan.  Sekarang Anda memahami cara kerja yang tidak umum, membuat jenis Anda mudah.  Mari kita buat beberapa jenis: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NewType</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, t)</span></span></span><span class="hljs-function">:</span></span> self.s = ts</code> </pre> <br><p>  Ini menyimpan string dalam dirinya sendiri, dan bukan hanya seperti itu: kita perlu mengetikkan argumen fungsi, dan kita mendapatkan jenis argumen dalam bentuk string dari docking.  Oleh karena itu, mari kita ganti anotasi argumen tidak dengan tipe yang kita butuhkan, tetapi dengan objek NewType yang hanya menyimpan nama tipe yang diinginkan di dalamnya. </p><br><p>  Untuk melakukan ini, perluas horast.Unparser - tulis UnparserWithType Anda, warisan dari horast.Unparser, dan tambahkan pemrosesan jenis baru kami. </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UnparserWithType</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(horast.Unparser)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_NewType</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, t)</span></span></span><span class="hljs-function">:</span></span> self.write(ts)</code> </pre> <br><p>  Ini menggabungkan dengan semangat perpustakaan.  Nama-nama variabel dibuat dalam gaya ast, dan itulah sebabnya mereka terdiri dari satu huruf, dan bukan karena saya tidak bisa memikirkan nama.  Saya pikir t adalah kependekan dari tree, dan s untuk string.  Omong-omong, NewType bukan string.  Jika kita ingin itu ditafsirkan sebagai tipe string, maka kita harus menulis tanda kutip sebelum dan sesudah panggilan tulis. </p><br><p>  Dan sekarang <del>  keajaiban </del>  patch monyet: ganti horast.Unparser dengan UnparserWithType kami. </p><br><p>  Cara kerjanya sekarang: kita memiliki pohon sintaksis, ia memiliki beberapa fungsi, fungsi memiliki argumen, argumen memiliki jenis anotasi, jarum disembunyikan dalam jenis anotasi, dan kematian Koshcheev tersembunyi di dalamnya.  Sebelumnya, tidak ada simpul anotasi sama sekali, kami membuatnya, dan simpul semacam itu adalah turunan dari NewType.  Kami memanggil fungsi unparse untuk pohon kami, dan untuk setiap node itu disebut pengiriman, yang mengklasifikasikan simpul itu dan memanggil fungsi yang sesuai.  Segera setelah fungsi pengiriman menerima simpul argumen, ia menulis nama argumen, kemudian melihat apakah ada anotasi (dulu tidak ada, tetapi kami menempatkan NewType di sana), jika ya, ia menulis titik dua dan memanggil pengiriman untuk anotasi, yang memanggil _NewType kami, yang hanya menulis string yang disimpannya - ini adalah nama tipe.  Hasilnya, kita mendapatkan argumen tertulis: type. </p><br><p>  Sebenarnya, ini tidak sepenuhnya legal.  Dari sudut pandang kompiler, kami menuliskan anotasi argumen dengan beberapa kata yang tidak didefinisikan di mana pun, jadi ketika unparse menyelesaikan pekerjaannya, kami mendapatkan kode yang salah: kami membutuhkan impor.  Saya cukup membentuk garis format yang benar dan menambahkannya ke awal file, dan kemudian menambahkan hasilnya ke unparse, meskipun saya bisa menambahkan impor sebagai node ke pohon sintaks, karena ast mendukung Impor dan ImportFrom node. </p><br><p>  Memecahkan masalah tanda kutip tiga tidak lebih sulit daripada menambahkan tipe baru.  Kami akan membuat kelas StrType dan metode _StrType.  Metode ini tidak berbeda dengan metode _NewType yang digunakan untuk membubuhi keterangan tipe, tetapi definisi kelas telah berubah: kita tidak hanya akan menyimpan string itu sendiri, tetapi juga level tab di mana ia harus ditulis.  Jumlah lekukan didefinisikan sebagai berikut: jika baris ini ditemukan dalam suatu fungsi, maka satu, jika dalam suatu metode, maka dua, dan tidak ada kasus ketika fungsi tersebut didefinisikan dalam tubuh fungsi lain dan didekorasi pada saat yang sama, dalam proyek kami. </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StrType</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, s, indent)</span></span></span><span class="hljs-function">:</span></span> self.s = s self.indent = indent <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__repr__</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'"""\n'</span></span> + self.s + <span class="hljs-string"><span class="hljs-string">'\n'</span></span> + <span class="hljs-string"><span class="hljs-string">' '</span></span> * <span class="hljs-number"><span class="hljs-number">4</span></span> * self.indent + <span class="hljs-string"><span class="hljs-string">'"""\n'</span></span></code> </pre> <br><p>  Dalam <strong>repr</strong> kita mendefinisikan seperti apa garis kita seharusnya.  Saya pikir ini jauh dari satu-satunya solusi, tetapi berhasil.  Seseorang dapat bereksperimen dengan astunparse.fill dan indunparse.Unparser.indent, maka itu akan menjadi lebih universal, tetapi ide ini muncul di benak saya pada saat menulis artikel ini. </p><br><p>  Kesulitan yang diselesaikan ini berakhir.  Setelah menjalankan skrip saya, masalah impor siklik terkadang muncul, tetapi ini adalah masalah arsitektur.  Saya tidak menemukan solusi pihak ketiga yang siap pakai, dan untuk menangani kasus-kasus seperti itu dalam kerangka skrip saya tampaknya merupakan komplikasi serius dari tugas tersebut.  Mungkin, dengan bantuan ast, dimungkinkan untuk mendeteksi dan menyelesaikan impor siklik, tetapi gagasan ini perlu dipertimbangkan secara terpisah.  Secara umum, jumlah insiden semacam itu yang dapat diabaikan dalam proyek kami sepenuhnya memungkinkan saya untuk tidak memprosesnya secara otomatis. </p><br><p>  Kesulitan lain yang saya temui adalah kurangnya pemrosesan ekspresi ast dari impor astro karena pembaca yang teliti telah mengetahui bahwa patch monyet adalah obat untuk semua penyakit.  Biarkan ini menjadi pekerjaan rumahnya untuknya, tetapi saya memutuskan untuk melakukan ini: tambahkan saja impor tersebut ke file pemetaan, karena konstruksi ini biasanya digunakan untuk memotong konflik nama, dan kami memiliki beberapa di antaranya. </p><br><p>  Terlepas dari ketidaksempurnaan yang ditemukan, skrip melakukan apa yang seharusnya dilakukan.  Apa hasilnya: </p><br><ol><li>  Waktu peluncuran proyek telah berkurang dari 10 menjadi 3 detik; </li><li>  Jumlah file telah berkurang karena penghapusan definisi new_contract.  File-file itu sendiri berkurang: Saya tidak mengukur, tetapi rata-rata git berjumlah n baris yang ditambahkan dan yang dihapus 2n; </li><li>  IDE cerdas mulai membuat isyarat yang berbeda, karena sekarang itu bukan komentar, tetapi impor jujur; </li><li>  Keterbacaan telah meningkat; </li><li>  Kurung di suatu tempat muncul. </li></ol><br><p>  Terima kasih </p><br><p>  Tautan yang bermanfaat: </p><br><ol><li>  <a href="https://docs.python.org/3/library/ast.html">Ast</a> </li><li>  <a href="https://pypi.org/project/horast/">Mengerikan</a> </li><li>  <a href="https://greentreesnakes.readthedocs.io/en/latest/nodes.html">Semua jenis node ast dan apa yang disimpan di dalamnya</a> </li><li>  <a href="https://python-ast-explorer.com/">Indah menunjukkan pohon sintaksis</a> </li><li>  <a href="https://pypi.org/project/isort/">Isort</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id480930/">https://habr.com/ru/post/id480930/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id480920/index.html">Uji sakelar TP-Link dengan PoE jarak jauh. Dan sedikit tentang peningkatan model lama</a></li>
<li><a href="../id480922/index.html">Evgeny Usvitsky: "Semua orang di dunia tahu di mana mendapatkan geodata secara bebas - hanya di OSM"</a></li>
<li><a href="../id480924/index.html">Bagaimana dan mengapa pembuat remake MediEvil mendesain ulang bos sekte permainan</a></li>
<li><a href="../id480926/index.html">Teori Probabilitas untuk Rendering yang Akurat Secara Fisik</a></li>
<li><a href="../id480928/index.html">Apache Hadoop Code Quality: uji VS produksi</a></li>
<li><a href="../id480936/index.html">IntelliJ IDEA konversi cepat UPPER_CASE ke camelCase</a></li>
<li><a href="../id480938/index.html">Cryptocurrency melalui mata para hakim Rusia</a></li>
<li><a href="../id480940/index.html">Jalankan uji UI lintas-browser dengan Mentimun dan Selenoid di Gitlab CI dengan laporan Allure</a></li>
<li><a href="../id480944/index.html">5 Tren Teratas dalam Pemasaran Email pada tahun 2020</a></li>
<li><a href="../id480946/index.html">Log di Kubernetes (dan tidak hanya) hari ini: harapan dan kenyataan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>