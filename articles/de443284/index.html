<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üñåÔ∏è ü§æüèº üëû Indizes in PostgreSQL - 4 (Btree) ‚õ≤Ô∏è üò∑ üéê</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wir haben bereits die PostgreSQL- Indexierungs-Engine und die Schnittstelle der Zugriffsmethoden sowie den Hash-Index , eine der Zugriffsmethoden, er√∂...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Indizes in PostgreSQL - 4 (Btree)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/443284/">  Wir haben bereits die PostgreSQL- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Indexierungs-Engine</a> und die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schnittstelle der Zugriffsmethoden</a> sowie den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hash-Index</a> , eine der Zugriffsmethoden, er√∂rtert.  Wir werden nun B-Tree betrachten, den traditionellsten und am weitesten verbreiteten Index.  Dieser Artikel ist gro√ü, seien Sie also geduldig. <br><br><h1>  Btree </h1><br><h2>  Struktur </h2><br>  Der als "btree" -Zugriffsmethode implementierte B-Tree-Indextyp eignet sich f√ºr Daten, die sortiert werden k√∂nnen.  Mit anderen Worten, f√ºr den Datentyp m√ºssen die Operatoren "gr√∂√üer", "gr√∂√üer oder gleich", "kleiner", "kleiner oder gleich" und "gleich" definiert werden.  Beachten Sie, dass dieselben Daten manchmal unterschiedlich sortiert werden k√∂nnen, was <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">uns</a> zum Konzept der Operatorfamilie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zur√ºckf√ºhrt</a> . <br><a name="habracut"></a><br>  Wie immer werden Indexzeilen des B-Baums in Seiten gepackt.  Auf Blattseiten enthalten diese Zeilen zu indizierende Daten (Schl√ºssel) und Verweise auf Tabellenzeilen (TIDs).  Auf internen Seiten verweist jede Zeile auf eine untergeordnete Seite des Index und enth√§lt den Mindestwert auf dieser Seite. <br><br>  B-B√§ume haben einige wichtige Eigenschaften: <br><br><ul><li>  B-B√§ume sind ausgeglichen, dh jede Blattseite ist durch die gleiche Anzahl interner Seiten vom Stamm getrennt.  Daher dauert die Suche nach einem Wert dieselbe Zeit. <br></li><li>  B-B√§ume sind mehrfach verzweigt, dh jede Seite (normalerweise 8 KB) enth√§lt viele (Hunderte) TIDs.  Infolgedessen ist die Tiefe von B-B√§umen ziemlich gering, bei sehr gro√üen Tischen sogar bis zu 4‚Äì5. <br></li><li>  Die Daten im Index werden in nicht abnehmender Reihenfolge (sowohl zwischen den Seiten als auch innerhalb jeder Seite) sortiert, und Seiten derselben Ebene sind durch eine bidirektionale Liste miteinander verbunden.  Daher k√∂nnen wir einen geordneten Datensatz nur durch eine Liste erhalten, die in die eine oder andere Richtung geht, ohne jedes Mal zur Wurzel zur√ºckzukehren. <br></li></ul><br>  Unten finden Sie ein vereinfachtes Beispiel f√ºr den Index eines Felds mit Ganzzahlschl√ºsseln. <br><br><img src="https://habrastorage.org/web/2e4/4f4/003/2e44f400317048c78e4cec04ab45e48e.png"><br><br>  Die allererste Seite des Index ist eine Metapage, die auf den Indexstamm verweist.  Interne Knoten befinden sich unterhalb des Stamms, und Blattseiten befinden sich in der untersten Zeile.  Abw√§rtspfeile repr√§sentieren Verweise von Blattknoten auf Tabellenzeilen (TIDs). <br><br><h3>  Suche nach Gleichheit </h3><br>  Betrachten wir die Suche nach einem Wert in einem Baum nach der Bedingung " <em>indexed-field</em> = <em>expression</em> ".  Sagen wir, wir interessieren uns f√ºr den Schl√ºssel von 49. <br><br><img src="https://habrastorage.org/web/9fd/814/c9e/9fd814c9e79443b2a774403a817bf734.png"><br><br>  Die Suche beginnt mit dem Wurzelknoten, und wir m√ºssen bestimmen, zu welchem ‚Äã‚Äãder untergeordneten Knoten abzusteigen ist.  Da wir die Schl√ºssel im Stammknoten (4, 32, 64) kennen, ermitteln wir die Wertebereiche in untergeordneten Knoten.  Da 32 ‚â§ 49 &lt;64 ist, m√ºssen wir zum zweiten untergeordneten Knoten absteigen.  Als n√§chstes wird der gleiche Vorgang rekursiv wiederholt, bis wir einen Blattknoten erreichen, von dem die ben√∂tigten TIDs erhalten werden k√∂nnen. <br><br>  In Wirklichkeit erschweren eine Reihe von Einzelheiten diesen scheinbar einfachen Prozess.  Ein Index kann beispielsweise nicht eindeutige Schl√ºssel enthalten und es k√∂nnen so viele gleiche Werte vorhanden sein, dass sie nicht auf eine Seite passen.  Zur√ºck zu unserem Beispiel: Es scheint, dass wir vom internen Knoten √ºber den Verweis auf den Wert 49 absteigen sollten. Wie aus der Abbildung hervorgeht, √ºberspringen wir auf diese Weise einen der "49" -Schl√ºssel auf der vorhergehenden Blattseite .  Sobald wir auf einer internen Seite einen genau gleichen Schl√ºssel gefunden haben, m√ºssen wir eine Position nach links absteigen und dann die Indexzeilen der zugrunde liegenden Ebene von links nach rechts durchsuchen, um nach dem gesuchten Schl√ºssel zu suchen. <br><br>  (Eine weitere Komplikation besteht darin, dass w√§hrend der Suche andere Prozesse die Daten √§ndern k√∂nnen: Der Baum kann neu erstellt werden, Seiten k√∂nnen in zwei Teile geteilt werden usw. Alle Algorithmen sind so konzipiert, dass diese gleichzeitigen Vorg√§nge sich nicht gegenseitig st√∂ren und keine zus√§tzlichen Sperren verursachen wo immer m√∂glich. Aber wir werden es vermeiden, darauf einzugehen.) <br><br><h3>  Suche nach Ungleichung </h3><br>  Bei der Suche nach der Bedingung " <em>indiziertes Feld</em> ‚â§ <em>Ausdruck</em> " (oder " <em>indiziertes Feld</em> ‚â• <em>Ausdruck</em> ") finden wir zuerst einen Wert (falls vorhanden) im Index durch die Gleichheitsbedingung " <em>indiziertes Feld</em> = <em>Ausdruck</em> " und gehen dann durch Blattseiten in die entsprechende Richtung bis zum Ende. <br><br>  Die Abbildung zeigt diesen Vorgang f√ºr n ‚â§ 35: <br><br><img src="https://habrastorage.org/web/35e/62a/f80/35e62af80ca44349b7728ad806226208.png"><br><br>  Die Operatoren "gr√∂√üer" und "kleiner" werden auf √§hnliche Weise unterst√ºtzt, au√üer dass der urspr√ºnglich gefundene Wert gel√∂scht werden muss. <br><br><h3>  Suche nach Bereich </h3><br>  Wenn wir nach dem Bereich " <em>Ausdruck1</em> ‚â§ <em>indiziertes Feld</em> ‚â§ <em>Ausdruck2</em> " suchen, finden wir einen Wert nach Bedingung " <em>indiziertes Feld</em> = <em>Ausdruck1</em> " und gehen dann weiter durch Blattseiten, w√§hrend die Bedingung " <em>indiziertes Feld</em> ‚â§ <em>Ausdruck2</em> " erf√ºllt ist.  oder umgekehrt: Beginnen Sie mit dem zweiten Ausdruck und gehen Sie in die entgegengesetzte Richtung, bis wir den ersten Ausdruck erreichen. <br><br>  Die Abbildung zeigt diesen Vorgang f√ºr Bedingung 23 ‚â§ n ‚â§ 64: <br><br><img src="https://habrastorage.org/web/2d6/b24/d86/2d6b24d86fb24c9ab437cc8155658e58.png"><br><br><h2>  Beispiel </h2><br>  Schauen wir uns ein Beispiel an, wie Abfragepl√§ne aussehen.  Wie √ºblich verwenden wir die Demo-Datenbank und dieses Mal betrachten wir die Flugzeugtabelle.  Es enth√§lt nur neun Zeilen, und der Planer w√ºrde den Index nicht verwenden, da die gesamte Tabelle auf eine Seite passt.  Diese Tabelle ist jedoch zur Veranschaulichung f√ºr uns interessant. <br><br><pre><code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> aircrafts;</code> </pre> <pre> <code class="plaintext hljs"> aircraft_code | model | range ---------------+---------------------+------- 773 | Boeing 777-300 | 11100 763 | Boeing 767-300 | 7900 SU9 | Sukhoi SuperJet-100 | 3000 320 | Airbus A320-200 | 5700 321 | Airbus A321-200 | 5600 319 | Airbus A319-100 | 6700 733 | Boeing 737-300 | 4200 CN1 | Cessna 208 Caravan | 1200 CR2 | Bombardier CRJ-200 | 2700 (9 rows)</code> </pre><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> aircrafts(range); demo=# <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> enable_seqscan = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>;</code> </pre><br>  (Oder explizit "Index f√ºr Flugzeuge mit btree (range) erstellen", aber es ist ein B-Baum, der standardm√§√üig erstellt wird.) <br><br>  Suche nach Gleichheit: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> aircrafts <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> range = <span class="hljs-number"><span class="hljs-number">3000</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN --------------------------------------------------- Index Scan using aircrafts_range_idx on aircrafts Index Cond: (range = 3000) (2 rows)</code> </pre><br>  Suche nach Ungleichung: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> aircrafts <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> range &lt; <span class="hljs-number"><span class="hljs-number">3000</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN --------------------------------------------------- Index Scan using aircrafts_range_idx on aircrafts Index Cond: (range &lt; 3000) (2 rows)</code> </pre><br>  Und nach Reichweite: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> aircrafts <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> <span class="hljs-keyword"><span class="hljs-keyword">between</span></span> <span class="hljs-number"><span class="hljs-number">3000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-number"><span class="hljs-number">5000</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ----------------------------------------------------- Index Scan using aircrafts_range_idx on aircrafts Index Cond: ((range &gt;= 3000) AND (range &lt;= 5000)) (2 rows)</code> </pre><br><h2>  Sortieren </h2><br>  Lassen Sie uns noch einmal den Punkt hervorheben, dass bei jeder Art von Scan (Index, Nur-Index oder Bitmap) die Zugriffsmethode "btree" geordnete Daten zur√ºckgibt, die wir in den obigen Abbildungen deutlich sehen k√∂nnen. <br><br>  Wenn eine Tabelle einen Index f√ºr die Sortierbedingung hat, ber√ºcksichtigt der Optimierer daher beide Optionen: Index-Scan der Tabelle, die leicht sortierte Daten zur√ºckgibt, und sequentieller Scan der Tabelle mit anschlie√üender Sortierung des Ergebnisses. <br><br><h3>  Sortierreihenfolge </h3><br>  Beim Erstellen eines Index k√∂nnen wir die Sortierreihenfolge explizit angeben.  Zum Beispiel k√∂nnen wir auf diese Weise einen Index nach Flugbereichen erstellen, insbesondere: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> aircrafts(range <span class="hljs-keyword"><span class="hljs-keyword">desc</span></span>);</code> </pre><br>  In diesem Fall werden links im Baum gr√∂√üere Werte angezeigt, w√§hrend rechts kleinere Werte angezeigt werden.  Warum kann dies erforderlich sein, wenn wir indizierte Werte in beide Richtungen durchlaufen k√∂nnen? <br><br>  Der Zweck sind mehrspaltige Indizes.  Erstellen wir eine Ansicht, um Flugzeugmodelle mit einer konventionellen Unterteilung in Kurz-, Mittel- und Langstreckenfahrzeuge zu zeigen: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">view</span></span> aircrafts_v <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> model, <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> range &lt; <span class="hljs-number"><span class="hljs-number">4000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> range &lt; <span class="hljs-number"><span class="hljs-number">10000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> aircrafts; demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> aircrafts_v;</code> </pre><pre> <code class="plaintext hljs"> model | class ---------------------+------- Boeing 777-300 | 3 Boeing 767-300 | 2 Sukhoi SuperJet-100 | 1 Airbus A320-200 | 2 Airbus A321-200 | 2 Airbus A319-100 | 2 Boeing 737-300 | 2 Cessna 208 Caravan | 1 Bombardier CRJ-200 | 1 (9 rows)</code> </pre><br>  Und lassen Sie uns einen Index erstellen (mit dem Ausdruck): <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> aircrafts( (<span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> range &lt; <span class="hljs-number"><span class="hljs-number">4000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> range &lt; <span class="hljs-number"><span class="hljs-number">10000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>), model);</code> </pre><br>  Jetzt k√∂nnen wir diesen Index verwenden, um Daten nach beiden Spalten in aufsteigender Reihenfolge zu sortieren: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>, model <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> aircrafts_v <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>, model;</code> </pre><pre> <code class="plaintext hljs"> class | model -------+--------------------- 1 | Bombardier CRJ-200 1 | Cessna 208 Caravan 1 | Sukhoi SuperJet-100 2 | Airbus A319-100 2 | Airbus A320-200 2 | Airbus A321-200 2 | Boeing 737-300 2 | Boeing 767-300 3 | Boeing 777-300 (9 rows)</code> </pre><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>, model <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> aircrafts_v <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>, model;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN -------------------------------------------------------- Index Scan using aircrafts_case_model_idx on aircrafts (1 row)</code> </pre><br>  Ebenso k√∂nnen wir die Abfrage ausf√ºhren, um Daten in absteigender Reihenfolge zu sortieren: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>, model <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> aircrafts_v <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-keyword"><span class="hljs-keyword">desc</span></span>, model <span class="hljs-keyword"><span class="hljs-keyword">desc</span></span>;</code> </pre><pre> <code class="plaintext hljs"> class | model -------+--------------------- 3 | Boeing 777-300 2 | Boeing 767-300 2 | Boeing 737-300 2 | Airbus A321-200 2 | Airbus A320-200 2 | Airbus A319-100 1 | Sukhoi SuperJet-100 1 | Cessna 208 Caravan 1 | Bombardier CRJ-200 (9 rows)</code> </pre><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>, model <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> aircrafts_v <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-keyword"><span class="hljs-keyword">desc</span></span>, model <span class="hljs-keyword"><span class="hljs-keyword">desc</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ----------------------------------------------------------------- Index Scan BACKWARD using aircrafts_case_model_idx on aircrafts (1 row)</code> </pre><br>  Wir k√∂nnen diesen Index jedoch nicht verwenden, um Daten nach einer Spalte in absteigender Reihenfolge und nach der anderen Spalte in aufsteigender Reihenfolge zu sortieren.  Dies erfordert eine separate Sortierung: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>, model <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> aircrafts_v <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ASC</span></span>, model <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------------------------------- Sort Sort Key: (CASE ... END), aircrafts.model DESC -&gt; Seq Scan on aircrafts (3 rows)</code> </pre><br>  (Beachten Sie, dass der Planer als letzten Ausweg den sequentiellen Scan unabh√§ngig von der zuvor vorgenommenen Einstellung "enable_seqscan = off" gew√§hlt hat. Dies liegt daran, dass diese Einstellung das Scannen von Tabellen nicht verbietet, sondern nur die astronomischen Kosten festlegt - sehen Sie sich den Plan mit an "Kosten an".) <br><br>  Damit diese Abfrage den Index verwendet, muss dieser mit der erforderlichen Sortierrichtung erstellt werden: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> aircrafts_case_asc_model_desc_idx <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> aircrafts( (<span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> range &lt; <span class="hljs-number"><span class="hljs-number">4000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> range &lt; <span class="hljs-number"><span class="hljs-number">10000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">ASC</span></span>, model <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span>); demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>, model <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> aircrafts_v <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ASC</span></span>, model <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ----------------------------------------------------------------- Index Scan using aircrafts_case_asc_model_desc_idx on aircrafts (1 row)</code> </pre><br><h3>  Reihenfolge der Spalten </h3><br>  Ein weiteres Problem, das bei der Verwendung mehrspaltiger Indizes auftritt, ist die Reihenfolge der Auflistung der Spalten in einem Index.  F√ºr B-Tree ist diese Reihenfolge von gro√üer Bedeutung: Die Daten innerhalb der Seiten werden nach dem ersten Feld, dann nach dem zweiten usw. sortiert. <br><br>  Wir k√∂nnen den Index, den wir auf Entfernungsintervallen und Modellen aufgebaut haben, symbolisch wie folgt darstellen: <br><br><img src="https://habrastorage.org/web/90c/71b/c8b/90c71bc8b51441b7b3c0df21b6a8888b.png"><br><br>  Tats√§chlich passt ein so kleiner Index mit Sicherheit auf eine Stammseite.  In der Abbildung ist es der √úbersichtlichkeit halber bewusst auf mehrere Seiten verteilt. <br><br>  Aus diesem Diagramm geht hervor, dass die Suche nach Pr√§dikaten wie "class = 3" (Suche nur nach dem ersten Feld) oder "class = 3 und model = 'Boeing 777-300'" (Suche nach beiden Feldern) effizient funktioniert. <br><br>  Die Suche nach dem Pr√§dikat "model = 'Boeing 777-300'" ist jedoch weitaus weniger effizient: Ausgehend von der Wurzel k√∂nnen wir nicht bestimmen, zu welchem ‚Äã‚Äãuntergeordneten Knoten abzusteigen ist, daher m√ºssen wir zu allen absteigen.  Dies bedeutet nicht, dass ein solcher Index niemals verwendet werden kann - es geht um seine Effizienz.  Wenn wir zum Beispiel drei Flugzeugklassen und sehr viele Modelle in jeder Klasse h√§tten, m√ºssten wir ungef√§hr ein Drittel des Index durchsehen, und dies w√§re m√∂glicherweise effizienter gewesen als der vollst√§ndige Tabellenscan ... oder nicht. <br><br>  Wenn wir jedoch einen Index wie diesen erstellen: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> aircrafts( model, (<span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> range &lt; <span class="hljs-number"><span class="hljs-number">4000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> range &lt; <span class="hljs-number"><span class="hljs-number">10000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>));</code> </pre><br>  Die Reihenfolge der Felder √§ndert sich: <br><br><img src="https://habrastorage.org/web/458/c5f/d22/458c5fd22e26467d9f0c56e308d8db5f.png"><br><br>  Mit diesem Index funktioniert die Suche nach dem Pr√§dikat "model = 'Boeing 777-300'" effizient, die Suche nach dem Pr√§dikat "class = 3" jedoch nicht. <br><br><h3>  Nullen </h3><br>  Die Zugriffsmethode "Btree" indiziert NULL-Werte und unterst√ºtzt die Suche nach den Bedingungen IS NULL und IS NOT NULL. <br><br>  Betrachten wir die Tabelle der Fl√ºge, in denen NULL-Werte auftreten: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> flights(actual_arrival); demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flights <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> actual_arrival <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------------------------------------- Bitmap Heap Scan on flights Recheck Cond: (actual_arrival IS NULL) -&gt; Bitmap Index Scan on flights_actual_arrival_idx Index Cond: (actual_arrival IS NULL) (4 rows)</code> </pre><br>  NULL-Werte befinden sich am einen oder anderen Ende der Blattknoten, je nachdem, wie der Index erstellt wurde (NULLS FIRST oder NULLS LAST).  Dies ist wichtig, wenn eine Abfrage eine Sortierung enth√§lt: Der Index kann verwendet werden, wenn der Befehl SELECT in seiner ORDER BY-Klausel dieselbe Reihenfolge von NULL-Werten angibt wie die f√ºr den erstellten Index angegebene Reihenfolge (NULLS FIRST oder NULLS LAST). <br><br>  Im folgenden Beispiel sind diese Ordnungen gleich, daher k√∂nnen wir den Index verwenden: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flights <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> actual_arrival <span class="hljs-keyword"><span class="hljs-keyword">NULLS LAST</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN -------------------------------------------------------- Index Scan using flights_actual_arrival_idx on flights (1 row)</code> </pre><br>  Und hier sind diese Reihenfolgen unterschiedlich, und der Optimierer w√§hlt den sequentiellen Scan mit anschlie√üender Sortierung: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flights <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> actual_arrival <span class="hljs-keyword"><span class="hljs-keyword">NULLS FIRST</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ---------------------------------------- Sort Sort Key: actual_arrival NULLS FIRST -&gt; Seq Scan on flights (3 rows)</code> </pre><br>  Um den Index verwenden zu k√∂nnen, muss er mit NULL-Werten am Anfang erstellt werden: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> flights_nulls_first_idx <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> flights(actual_arrival <span class="hljs-keyword"><span class="hljs-keyword">NULLS FIRST</span></span>); demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flights <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> actual_arrival <span class="hljs-keyword"><span class="hljs-keyword">NULLS FIRST</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ----------------------------------------------------- Index Scan using flights_nulls_first_idx on flights (1 row)</code> </pre><br>  Probleme wie dieses werden sicherlich dadurch verursacht, dass NULL-Werte nicht sortierbar sind, dh das Ergebnis des Vergleichs f√ºr NULL und andere Werte ist undefiniert: <br><br><pre> <code class="pgsql hljs">demo=# \pset <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span> demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &lt; <span class="hljs-number"><span class="hljs-number">42</span></span>;</code> </pre><pre> <code class="plaintext hljs"> ?column? ---------- NULL (1 row)</code> </pre><br>  Dies widerspricht dem Konzept des B-Baums und passt nicht in das allgemeine Muster.  NULL-Werte spielen jedoch in Datenbanken eine so wichtige Rolle, dass wir immer Ausnahmen f√ºr sie machen m√ºssen. <br><br>  Da NULL-Werte indiziert werden k√∂nnen, ist es m√∂glich, einen Index auch ohne Bedingungen f√ºr die Tabelle zu verwenden (da der Index sicher Informationen zu allen Tabellenzeilen enth√§lt).  Dies kann sinnvoll sein, wenn f√ºr die Abfrage eine Datenreihenfolge erforderlich ist und der Index die erforderliche Reihenfolge sicherstellt.  In diesem Fall kann der Planer eher den Indexzugriff ausw√§hlen, um bei einer separaten Sortierung zu speichern. <br><br><h2>  Eigenschaften </h2><br>  Schauen wir uns die Eigenschaften der Zugriffsmethode "btree" an (Abfragen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wurden bereits bereitgestellt</a> ). <br><br><pre> <code class="plaintext hljs"> amname | name | pg_indexam_has_property --------+---------------+------------------------- btree | can_order | t btree | can_unique | t btree | can_multi_col | t btree | can_exclude | t</code> </pre><br>  Wie wir gesehen haben, kann B-tree Daten bestellen und unterst√ºtzt die Eindeutigkeit - und dies ist die einzige Zugriffsmethode, die uns solche Eigenschaften bietet.  Mehrspaltige Indizes sind ebenfalls zul√§ssig, aber andere Zugriffsmethoden (obwohl nicht alle) unterst√ºtzen m√∂glicherweise auch solche Indizes.  Wir werden das n√§chste Mal die Unterst√ºtzung der EXCLUDE-Einschr√§nkung diskutieren, und das nicht ohne Grund. <br><br><pre> <code class="plaintext hljs"> name | pg_index_has_property ---------------+----------------------- clusterable | t index_scan | t bitmap_scan | t backward_scan | t</code> </pre><br>  Die Zugriffsmethode "Btree" unterst√ºtzt beide Techniken zum Abrufen von Werten: Index-Scan sowie Bitmap-Scan.  Und wie wir sehen konnten, kann die Zugriffsmethode sowohl "vorw√§rts" als auch "r√ºckw√§rts" durch den Baum laufen. <br><br><pre> <code class="plaintext hljs"> name | pg_index_column_has_property --------------------+------------------------------ asc | t desc | f nulls_first | f nulls_last | t orderable | t distance_orderable | f returnable | t search_array | t search_nulls | t</code> </pre><br>  Die ersten vier Eigenschaften dieser Ebene erkl√§ren, wie genau die Werte einer bestimmten Spalte geordnet sind.  In diesem Beispiel werden die Werte in aufsteigender Reihenfolge ("asc") sortiert und die NULL-Werte werden zuletzt angegeben ("nulls_last").  Aber wie wir bereits gesehen haben, sind andere Kombinationen m√∂glich. <br><br>  Die Eigenschaft "Search_array" gibt die Unterst√ºtzung solcher Ausdr√ºcke durch den Index an: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> aircrafts <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> aircraft_code <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (<span class="hljs-string"><span class="hljs-string">'733'</span></span>,<span class="hljs-string"><span class="hljs-string">'763'</span></span>,<span class="hljs-string"><span class="hljs-string">'773'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ----------------------------------------------------------------- Index Scan using aircrafts_pkey on aircrafts Index Cond: (aircraft_code = ANY ('{733,763,773}'::bpchar[])) (2 rows)</code> </pre><br>  Die Eigenschaft "Returnable" gibt die Unterst√ºtzung des Nur-Index-Scans an, was sinnvoll ist, da Zeilen des Index selbst indizierte Werte speichern (im Gegensatz zum Beispiel im Hash-Index).  Hier ist es sinnvoll, ein paar Worte zum Abdecken von Indizes zu sagen, die auf dem B-Baum basieren. <br><br><h3>  Eindeutige Indizes mit zus√§tzlichen Zeilen </h3><br>  Wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bereits erw√§hnt</a> , ist ein Abdeckungsindex derjenige, der alle f√ºr eine Abfrage erforderlichen Werte speichert, wobei der Zugriff auf die Tabelle selbst (fast) nicht erforderlich ist.  Ein eindeutiger Index kann speziell abdecken. <br><br>  Nehmen wir jedoch an, wir m√∂chten dem eindeutigen Index zus√§tzliche Spalten hinzuf√ºgen, die f√ºr eine Abfrage erforderlich sind.  Die Eindeutigkeit solcher zusammengesetzter Werte garantiert jedoch nicht die Eindeutigkeit des Schl√ºssels, und dann werden zwei Indizes f√ºr dieselben Spalten ben√∂tigt: einer eindeutig zur Unterst√ºtzung der Integrit√§tsbeschr√§nkung und ein anderer zur Abdeckung.  Dies ist sicher ineffizient. <br><br>  In unserer Firma hat Anastasiya Lubennikova <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">lubennikovaav</a> die "btree" -Methode verbessert, sodass zus√§tzliche, nicht eindeutige Spalten in einen eindeutigen Index aufgenommen werden k√∂nnen.  Wir hoffen, dass dieser Patch von der Community √ºbernommen wird, um Teil von PostgreSQL zu werden. Dies wird jedoch nicht bereits in Version 10 geschehen. Derzeit ist der Patch in Pro Standard 9.5+ verf√ºgbar, und so sieht er aus wie. <br><br><blockquote>  Tats√§chlich wurde dieser Patch f√ºr PostgreSQL 11 festgelegt. <br></blockquote><br>  Betrachten wir die Buchungstabelle: <br><br><pre> <code class="pgsql hljs">demo=# \d bookings</code> </pre><pre> <code class="plaintext hljs"> Table "bookings.bookings" Column | Type | Modifiers --------------+--------------------------+----------- book_ref | character(6) | not null book_date | timestamp with time zone | not null total_amount | numeric(10,2) | not null Indexes: "bookings_pkey" PRIMARY KEY, btree (book_ref) Referenced by: TABLE "tickets" CONSTRAINT "tickets_book_ref_fkey" FOREIGN KEY (book_ref) REFERENCES bookings(book_ref)</code> </pre><br>  In dieser Tabelle wird der Prim√§rschl√ºssel (book_ref, Buchungscode) durch einen regul√§ren "btree" -Index bereitgestellt.  Erstellen wir einen neuen eindeutigen Index mit einer zus√§tzlichen Spalte: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unique</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> bookings_pkey2 <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> bookings(book_ref) <span class="hljs-keyword"><span class="hljs-keyword">INCLUDE</span></span> (book_date);</code> </pre><br>  Jetzt ersetzen wir den vorhandenen Index durch einen neuen (in der Transaktion, um alle √Ñnderungen gleichzeitig anzuwenden): <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span>; demo=# <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> bookings <span class="hljs-keyword"><span class="hljs-keyword">drop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constraint</span></span> bookings_pkey <span class="hljs-keyword"><span class="hljs-keyword">cascade</span></span>; demo=# <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> bookings <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> <span class="hljs-keyword"><span class="hljs-keyword">primary key</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> bookings_pkey2; demo=# <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> tickets <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> <span class="hljs-keyword"><span class="hljs-keyword">foreign key</span></span> (book_ref) <span class="hljs-keyword"><span class="hljs-keyword">references</span></span> bookings (book_ref); demo=# <span class="hljs-keyword"><span class="hljs-keyword">commit</span></span>;</code> </pre><br>  Das bekommen wir: <br><br><pre> <code class="pgsql hljs">demo=# \d bookings</code> </pre><pre> <code class="plaintext hljs"> Table "bookings.bookings" Column | Type | Modifiers --------------+--------------------------+----------- book_ref | character(6) | not null book_date | timestamp with time zone | not null total_amount | numeric(10,2) | not null Indexes: "bookings_pkey2" PRIMARY KEY, btree (book_ref) INCLUDE (book_date) Referenced by: TABLE "tickets" CONSTRAINT "tickets_book_ref_fkey" FOREIGN KEY (book_ref) REFERENCES bookings(book_ref)</code> </pre><br>  Jetzt funktioniert ein und derselbe Index als eindeutig und dient als Deckungsindex f√ºr diese Abfrage, zum Beispiel: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> book_ref, book_date <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> bookings <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> book_ref = <span class="hljs-string"><span class="hljs-string">'059FC4'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN -------------------------------------------------- Index Only Scan using bookings_pkey2 on bookings Index Cond: (book_ref = '059FC4'::bpchar) (2 rows)</code> </pre><br><h2>  Erstellung des Index </h2><br>  Es ist bekannt, aber nicht weniger wichtig, dass es f√ºr eine gro√üe Tabelle besser ist, dort Daten ohne Indizes zu laden und die erforderlichen Indizes sp√§ter zu erstellen.  Dies ist nicht nur schneller, sondern der Index wird h√∂chstwahrscheinlich auch kleiner sein. <br><br>  Die Sache ist, dass die Erstellung des "btree" -Index einen effizienteren Prozess verwendet als das zeilenweise Einf√ºgen von Werten in den Baum.  Grob gesagt werden alle in der Tabelle verf√ºgbaren Daten sortiert und Blattseiten dieser Daten erstellt.  Dann werden interne Seiten √ºber diese Basis "aufgebaut", bis die gesamte Pyramide zur Wurzel konvergiert. <br><br>  Die Geschwindigkeit dieses Vorgangs h√§ngt von der Gr√∂√üe des verf√ºgbaren Arbeitsspeichers ab, die durch den Parameter "tenance_work_mem "begrenzt wird.  Das Erh√∂hen des Parameterwerts kann den Prozess beschleunigen.  Bei eindeutigen Indizes wird zus√§tzlich zu "tenance_work_mem "Speicher der Gr√∂√üe" work_mem "zugewiesen. <br><br><h3>  Vergleichssemantik </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Das letzte Mal haben</a> wir erw√§hnt, dass PostgreSQL wissen muss, welche Hash-Funktionen Werte verschiedener Typen aufrufen sollen, und dass diese Zuordnung in der "Hash" -Zugriffsmethode gespeichert ist.  Ebenso muss das System herausfinden, wie Werte bestellt werden.  Dies wird f√ºr Sortierungen, Gruppierungen (manchmal), Zusammenf√ºhren von Verkn√ºpfungen usw. ben√∂tigt.  PostgreSQL bindet sich nicht an Operatornamen (wie&gt;, &lt;, =), da Benutzer ihren eigenen Datentyp definieren und entsprechenden Operatoren unterschiedliche Namen geben k√∂nnen.  Eine von der Zugriffsmethode "btree" verwendete Operatorfamilie definiert stattdessen Operatornamen. <br><br>  Diese Vergleichsoperatoren werden beispielsweise in der Operatorfamilie "bool_ops" verwendet: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> amop.amopopr::<span class="hljs-type"><span class="hljs-type">regoperator</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> opfamily_operator, amop.amopstrategy <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_am am, pg_opfamily opf, pg_amop amop <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> opf.opfmethod = am.oid <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amopfamily = opf.oid <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.amname = <span class="hljs-string"><span class="hljs-string">'btree'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> opf.opfname = <span class="hljs-string"><span class="hljs-string">'bool_ops'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> amopstrategy;</code> </pre><pre> <code class="plaintext hljs"> opfamily_operator | amopstrategy ---------------------+-------------- &lt;(boolean,boolean) | 1 &lt;=(boolean,boolean) | 2 =(boolean,boolean) | 3 &gt;=(boolean,boolean) | 4 &gt;(boolean,boolean) | 5 (5 rows)</code> </pre><br>  Hier sehen wir f√ºnf Vergleichsoperatoren, aber wie bereits erw√§hnt, sollten wir uns nicht auf deren Namen verlassen.  Um herauszufinden, welchen Vergleich jeder Bediener durchf√ºhrt, wird das Strategiekonzept eingef√ºhrt.  Zur Beschreibung der Operatorsemantik sind f√ºnf Strategien definiert: <br><br><ul><li>  1 - weniger </li><li>  2 - weniger oder gleich </li><li>  3 - gleich </li><li>  4 - gr√∂√üer oder gleich </li><li>  5 - gr√∂√üer </li></ul><br>  Einige Operatorfamilien k√∂nnen mehrere Operatoren enthalten, die eine Strategie implementieren.  Beispielsweise enth√§lt die Operatorfamilie "integer_ops" die folgenden Operatoren f√ºr Strategie 1: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> amop.amopopr::<span class="hljs-type"><span class="hljs-type">regoperator</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> opfamily_operator <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_am am, pg_opfamily opf, pg_amop amop <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> opf.opfmethod = am.oid <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amopfamily = opf.oid <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.amname = <span class="hljs-string"><span class="hljs-string">'btree'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> opf.opfname = <span class="hljs-string"><span class="hljs-string">'integer_ops'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amopstrategy = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> opfamily_operator;</code> </pre><pre> <code class="plaintext hljs"> opfamily_operator ---------------------- &lt;(integer,bigint) &lt;(smallint,smallint) &lt;(integer,integer) &lt;(bigint,bigint) &lt;(bigint,integer) &lt;(smallint,integer) &lt;(integer,smallint) &lt;(smallint,bigint) &lt;(bigint,smallint) (9 rows)</code> </pre><br>  Dank dessen kann der Optimierer beim Vergleichen von Werten verschiedener Typen, die in einer Operatorfamilie enthalten sind, Typumwandlungen vermeiden. <br><br><h3>  Indexunterst√ºtzung f√ºr einen neuen Datentyp </h3><br>  Die Dokumentation enth√§lt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ein Beispiel</a> f√ºr die Erstellung eines neuen Datentyps f√ºr komplexe Zahlen und einer Operatorklasse zum Sortieren von Werten dieses Typs.  In diesem Beispiel wird die Sprache C verwendet, was bei kritischer Geschwindigkeit absolut sinnvoll ist.  Nichts hindert uns jedoch daran, reines SQL f√ºr dasselbe Experiment zu verwenden, um nur zu versuchen, die Vergleichssemantik besser zu verstehen. <br><br>  Erstellen wir einen neuen zusammengesetzten Typ mit zwei Feldern: Real- und Imagin√§rteil. <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> complex <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> (re <span class="hljs-type"><span class="hljs-type">float</span></span>, im <span class="hljs-type"><span class="hljs-type">float</span></span>);</code> </pre><br>  Wir k√∂nnen eine Tabelle mit einem Feld des neuen Typs erstellen und der Tabelle einige Werte hinzuf√ºgen: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> numbers(x complex); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> numbers <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> ((<span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">10.0</span></span>)), ((<span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">3.0</span></span>)), ((<span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>));</code> </pre><br>  Nun stellt sich die Frage: Wie ordne ich komplexe Zahlen, wenn f√ºr sie keine Ordnungsbeziehung im mathematischen Sinne definiert ist? <br><br>  Wie sich herausstellt, sind f√ºr uns bereits Vergleichsoperatoren definiert: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> numbers <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> x;</code> </pre><pre> <code class="plaintext hljs"> x -------- (0,10) (1,1) (1,3) (3 rows)</code> </pre><br>  Standardm√§√üig erfolgt die Sortierung f√ºr einen zusammengesetzten Typ komponentenweise: Erste Felder werden verglichen, dann zweite Felder usw., ungef√§hr so, wie Textzeichenfolgen zeichenweise verglichen werden.  Wir k√∂nnen aber eine andere Reihenfolge definieren.  Beispielsweise k√∂nnen komplexe Zahlen als Vektoren behandelt und nach dem Modul (L√§nge) geordnet werden, der als Quadratwurzel der Quadratsumme der Koordinaten berechnet wird (Satz von Pythagoras).  Um eine solche Reihenfolge zu definieren, erstellen wir eine Hilfsfunktion, die den Modul berechnet: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> modulus(a complex) <span class="hljs-keyword"><span class="hljs-keyword">returns</span></span> <span class="hljs-type"><span class="hljs-type">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">select</span></span></span><span class="pgsql"> sqrt(a.re*a.re + a.im*a.im); $$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span> <span class="hljs-keyword"><span class="hljs-keyword">immutable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">language</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>;</code> </pre><br>  Jetzt definieren wir systematisch Funktionen f√ºr alle f√ºnf Vergleichsoperatoren, die diese Hilfsfunktion verwenden: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> complex_lt(a complex, b complex) <span class="hljs-keyword"><span class="hljs-keyword">returns</span></span> <span class="hljs-type"><span class="hljs-type">boolean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">select</span></span></span><span class="pgsql"> modulus(a) &lt; modulus(b); $$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span> <span class="hljs-keyword"><span class="hljs-keyword">immutable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">language</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>; postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> complex_le(a complex, b complex) <span class="hljs-keyword"><span class="hljs-keyword">returns</span></span> <span class="hljs-type"><span class="hljs-type">boolean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">select</span></span></span><span class="pgsql"> modulus(a) &lt;= modulus(b); $$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span> <span class="hljs-keyword"><span class="hljs-keyword">immutable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">language</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>; postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> complex_eq(a complex, b complex) <span class="hljs-keyword"><span class="hljs-keyword">returns</span></span> <span class="hljs-type"><span class="hljs-type">boolean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">select</span></span></span><span class="pgsql"> modulus(a) = modulus(b); $$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span> <span class="hljs-keyword"><span class="hljs-keyword">immutable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">language</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>; postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> complex_ge(a complex, b complex) <span class="hljs-keyword"><span class="hljs-keyword">returns</span></span> <span class="hljs-type"><span class="hljs-type">boolean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">select</span></span></span><span class="pgsql"> modulus(a) &gt;= modulus(b); $$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span> <span class="hljs-keyword"><span class="hljs-keyword">immutable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">language</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>; postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> complex_gt(a complex, b complex) <span class="hljs-keyword"><span class="hljs-keyword">returns</span></span> <span class="hljs-type"><span class="hljs-type">boolean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">select</span></span></span><span class="pgsql"> modulus(a) &gt; modulus(b); $$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span> <span class="hljs-keyword"><span class="hljs-keyword">immutable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">language</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>;</code> </pre><br>  Und wir erstellen entsprechende Operatoren.  Um zu veranschaulichen, dass sie nicht "&gt;", "&lt;" usw. hei√üen m√ºssen, geben wir ihnen "seltsame" Namen. <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> #&lt;#(leftarg=complex, rightarg=complex, procedure=complex_lt); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> #&lt;=#(leftarg=complex, rightarg=complex, procedure=complex_le); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> #=#(leftarg=complex, rightarg=complex, procedure=complex_eq); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> #&gt;=#(leftarg=complex, rightarg=complex, procedure=complex_ge); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> #&gt;#(leftarg=complex, rightarg=complex, procedure=complex_gt);</code> </pre><br>  An dieser Stelle k√∂nnen wir Zahlen vergleichen: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> (<span class="hljs-number"><span class="hljs-number">1.0</span></span>,<span class="hljs-number"><span class="hljs-number">1.0</span></span>)::complex #&lt;# (<span class="hljs-number"><span class="hljs-number">1.0</span></span>,<span class="hljs-number"><span class="hljs-number">3.0</span></span>)::complex;</code> </pre><pre> <code class="plaintext hljs"> ?column? ---------- t (1 row)</code> </pre><br>  Zus√§tzlich zu f√ºnf Operatoren muss f√ºr die Zugriffsmethode "btree" eine weitere Funktion (√ºberm√§√üig, aber praktisch) definiert werden: Sie muss -1, 0 oder 1 zur√ºckgeben, wenn der erste Wert kleiner, gleich oder gr√∂√üer als der zweite ist eins.  Diese Hilfsfunktion wird als Unterst√ºtzung bezeichnet.  F√ºr andere Zugriffsmethoden m√ºssen m√∂glicherweise andere Unterst√ºtzungsfunktionen definiert werden. <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> complex_cmp(a complex, b complex) <span class="hljs-keyword"><span class="hljs-keyword">returns</span></span> <span class="hljs-type"><span class="hljs-type">integer</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">select</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">case</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">when</span></span></span><span class="pgsql"> modulus(a) &lt; modulus(b) </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">then</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">-1</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">when</span></span></span><span class="pgsql"> modulus(a) &gt; modulus(b) </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">then</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">1</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">else</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">end</span></span></span><span class="pgsql">; $$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span> <span class="hljs-keyword"><span class="hljs-keyword">language</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>;</code> </pre><br>  Jetzt k√∂nnen wir eine Operatorklasse erstellen (und die gleichnamige Operatorfamilie wird automatisch erstellt): <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> complex_ops <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> complex <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> btree <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> #&lt;#, <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> #&lt;=#, <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> #=#, <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> #&gt;=#, <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> #&gt;#, <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> complex_cmp(complex,complex);</code> </pre><br>  Jetzt funktioniert das Sortieren wie gew√ºnscht: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> numbers <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> x;</code> </pre><pre> <code class="plaintext hljs"> x -------- (1,1) (1,3) (0,10) (3 rows)</code> </pre><br>  Und es wird sicherlich vom "btree" -Index unterst√ºtzt. <br><br>  Um das Bild zu vervollst√§ndigen, k√∂nnen Sie mithilfe dieser Abfrage Supportfunktionen erhalten: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> amp.amprocnum, amp.amproc, amp.amproclefttype::<span class="hljs-type"><span class="hljs-type">regtype</span></span>, amp.amprocrighttype::<span class="hljs-type"><span class="hljs-type">regtype</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_opfamily opf, pg_am am, pg_amproc amp <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> opf.opfname = <span class="hljs-string"><span class="hljs-string">'complex_ops'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> opf.opfmethod = am.oid <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.amname = <span class="hljs-string"><span class="hljs-string">'btree'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amp.amprocfamily = opf.oid;</code> </pre><pre> <code class="plaintext hljs"> amprocnum | amproc | amproclefttype | amprocrighttype -----------+-------------+----------------+----------------- 1 | complex_cmp | complex | complex (1 row)</code> </pre><br><h2>  Interna </h2><br>  Wir k√∂nnen die interne Struktur des B-Baums mit der Erweiterung "pageinspect" untersuchen. <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extension</span></span> pageinspect;</code> </pre><br>  Index-Metapage: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> bt_metap(<span class="hljs-string"><span class="hljs-string">'ticket_flights_pkey'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> magic | version | root | level | fastroot | fastlevel --------+---------+------+-------+----------+----------- 340322 | 2 | 164 | 2 | 164 | 2 (1 row)</code> </pre><br>  Am interessantesten ist hier die Indexebene: Der Index f√ºr zwei Spalten f√ºr eine Tabelle mit einer Million Zeilen erfordert nur zwei Ebenen (ohne Root). <br><br>  Statistische Informationen zu Block 164 (root): <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>, live_items, dead_items, avg_item_size, page_size, free_size <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> bt_page_stats(<span class="hljs-string"><span class="hljs-string">'ticket_flights_pkey'</span></span>,<span class="hljs-number"><span class="hljs-number">164</span></span>);</code> </pre><pre> <code class="plaintext hljs"> type | live_items | dead_items | avg_item_size | page_size | free_size ------+------------+------------+---------------+-----------+----------- r | 33 | 0 | 31 | 8192 | 6984 (1 row)</code> </pre><br>  Und die Daten im Block (das Feld "Daten", das hier der Bildschirmbreite geopfert wird, enth√§lt den Wert des Indexschl√ºssels in bin√§rer Darstellung): <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> itemoffset, ctid, itemlen, left(data,<span class="hljs-number"><span class="hljs-number">56</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> data <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> bt_page_items(<span class="hljs-string"><span class="hljs-string">'ticket_flights_pkey'</span></span>,<span class="hljs-number"><span class="hljs-number">164</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span>;</code> </pre><pre> <code class="plaintext hljs"> itemoffset | ctid | itemlen | data ------------+---------+---------+---------------------------------------------------------- 1 | (3,1) | 8 | 2 | (163,1) | 32 | 1d 30 30 30 35 34 33 32 33 30 35 37 37 31 00 00 ff 5f 00 3 | (323,1) | 32 | 1d 30 30 30 35 34 33 32 34 32 33 36 36 32 00 00 4f 78 00 4 | (482,1) | 32 | 1d 30 30 30 35 34 33 32 35 33 30 38 39 33 00 00 4d 1e 00 5 | (641,1) | 32 | 1d 30 30 30 35 34 33 32 36 35 35 37 38 35 00 00 2b 09 00 (5 rows)</code> </pre><br>  Das erste Element bezieht sich auf Techniken und gibt die Obergrenze aller Elemente im Block an (ein Implementierungsdetail, das wir nicht besprochen haben), w√§hrend die Daten selbst mit dem zweiten Element beginnen.  Es ist klar, dass der unterste Knoten ganz links Block 163 ist, gefolgt von Block 323 und so weiter.  Sie k√∂nnen wiederum mit denselben Funktionen untersucht werden. <br><br>  Nach einer guten Tradition ist es nun sinnvoll, die Dokumentation, die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">README-Datei</a> und den Quellcode zu lesen. <br><br>  Eine weitere potenziell n√ºtzliche Erweiterung ist " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">amcheck</a> ", die in PostgreSQL 10 enthalten sein wird. F√ºr niedrigere Versionen k√∂nnen Sie sie von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">github herunterladen</a> .  Diese Erweiterung √ºberpr√ºft die logische Konsistenz von Daten in B-B√§umen und erm√∂glicht es uns, Fehler im Voraus zu erkennen. <br><blockquote>  Das stimmt, "amcheck" ist ein Teil von PostgreSQL ab Version 10. <br></blockquote>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lesen Sie weiter</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de443284/">https://habr.com/ru/post/de443284/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de443274/index.html">Zusammenstellung der Nachrichten aus der Spielebranche vom 8. M√§rz bis Sonntag</a></li>
<li><a href="../de443276/index.html">Surprise Query Scheduler in der PostgreSQL-Datenbank</a></li>
<li><a href="../de443278/index.html">Coinbase Crypto-Exchange verliert Benutzer aufgrund des Kaufs eines Startups f√ºr die Entwickler von Spyware vom Hacking-Team</a></li>
<li><a href="../de443280/index.html">Die Geschichte, wie ich ein 120-Zoll-Heimkino aus Rohren, Seilen, einem Paravent und schwarzem Samt zusammengebaut habe</a></li>
<li><a href="../de443282/index.html">Was sollen wir eine Blockchain bauen?</a></li>
<li><a href="../de443286/index.html">TDMS Fairway. Autofill-Mechanismus f√ºr die Hauptbeschriftungen auf den Zeichnungen und Details der Dokumente</a></li>
<li><a href="../de443288/index.html">Navigation in Projekten mit mehreren Modulen</a></li>
<li><a href="../de443290/index.html">Zen Erlang [und Elixier - ca. √úbersetzer]</a></li>
<li><a href="../de443292/index.html">Wir untersuchen das Funktionsprinzip von em-Einheiten am Beispiel der Aufgabe ‚ÄûAufbau eines flexiblen Vorladers‚Äú.</a></li>
<li><a href="../de443294/index.html">Was erlaubt Jupyter?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>