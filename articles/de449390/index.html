<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😬 🏤 🛌 Benchmarking Emely 🤙 😹 👇🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hauptidee 


 Es wurden viele Bücher, Artikel und Tutorials über Benchmarking-Anwendungen, Engines und verschiedene Softwaresysteme geschrieben. 


 F...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Benchmarking Emely</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/449390/"><h1 id="osnovnaya-zadumka">  Hauptidee </h1><br><p>  Es wurden viele Bücher, Artikel und Tutorials über Benchmarking-Anwendungen, Engines und verschiedene Softwaresysteme geschrieben. </p><br><p>  Folgendes gibt uns die alte Wikipedia zu diesem Thema: </p><br><blockquote>  Leistungstest, Benchmark (englischer Benchmark) - die Kontrollaufgabe, die zur Bestimmung der vergleichenden Leistungsmerkmale eines Computersystems erforderlich ist. </blockquote><p>  Aber was ist, wenn wir ein wenig von der anderen Seite zum Thema Benchmarking von Game-Engines kommen?  Alle Game Engines und SDKs für die Spieleentwicklung (und nicht nur) bewerben sich häufig als sehr intuitive und leicht verdauliche Tools.  Wir verkaufen Einfachheit zum Lernen, eine erstaunliche Lern- und Einstiegskurve, leichte und schöne Beispiele, bei denen ein Bildschirm mit Code beim Start eine Art wunderbare Magie erzeugt.  In Vorbereitung auf das bevorstehende <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ludum Dare-</a> Event habe ich mich erneut entschlossen, mich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">umzuschauen</a> und zu sehen, was die „Märkte“ für die einfache Emele bieten - jemanden, der seit einer Woche ohne ein Jahr im Spielentwickler ist.  Das heißt, eine der Personengruppen der CA, die diese erstaunlichen Eigenschaften der leichten Verdaulichkeit des Motors verkauft. </p><br><p><img src="https://habrastorage.org/webt/ke/mu/zr/kemuzrdhuns3k-oyijzd6kvhkxu.png" alt="Peter Griffin, genau wie wir denken, welche Spiel-Engine für die Entwicklung benötigt wird"></p><a name="habracut"></a><br><p>  Was ist, wenn wir ... versuchen, uns selbst zu messen, während wir mit verschiedenen Engines zum Schreiben von Spielen arbeiten?  Ja, ja, das heißt, ihre Produktivität auf sie.  Nehmen Sie buchstäblich ein paar davon, schließen Sie sich mit einem Laptop, Internet und einer Stoppuhr in eine Höhle ein, schreiben Sie alle unsere Ergebnisse auf ein ordentliches Tablet und versuchen Sie dann, einige Schlussfolgerungen zu ziehen.  Gleichzeitig stellen wir fest, dass es mir gefallen hat, was mich bei der Arbeit mit dem einen oder anderen Motor überrascht oder belastet hat. </p><br><h1 id="pro-benchmark">  Über Benchmark </h1><br><p>  Die Testobjekte sind also drei Spiel-Engines.  Hier lohnt es sich wahrscheinlich, Ihre "Konfiguration" mehr oder weniger formal (so weit wie möglich) zu beschreiben (ja, wie bei typischen Benchmark-Ergebnissen schreiben sie die Eisenkonfiguration, in der sie die Läufe, die Benchmark-Beschreibung usw. durchgeführt haben). </p><br><h1 id="konfiguraciya-ili-o-sebe">  "Konfiguration" oder Über mich </h1><br><p>  Ich bin ein Java-Entwickler.  Erfahrung in der industriellen Entwicklung 5+ Jahre.  Auch in der Arbeit habe ich ein wenig in JavaScript geschrieben, Lua (sehr, sehr leicht), Shell.  Höhere technische Ausbildung.  Ich habe keine Designkurse absolviert, ich habe kein Spieledesign gelernt, ich war nur ein begeisterter Fan verschiedener PC-Spiele.  Letztes Jahr interessierte er sich für die einfachsten Computerspiele. </p><br><h1 id="pro-zadachu">  Über die Aufgabe </h1><br><p>  Ein Testprojekt des Klons des Spiels Doodle Jump wurde ausgewählt.  Ich bin sicher, dass viele Leute es wissen oder gespielt haben. Dies ist ein sehr cooles und sehr gut entwickeltes Spiel für Android. </p><br><p><img src="https://habrastorage.org/webt/gh/7c/t2/gh7ct2uueypr-xwublm6wbpvo0m.png" alt="Original Doodle Jump Game"></p><br><p>  Die Regelung lautet wie folgt: </p><br><ol><li>  Jeder Motor hat <strong>4</strong> Stunden Zeit.  Dies beinhaltet das Lernen, Bekanntschaften, Nasenpicken, den Versuch, einen Prototyp zu schreiben, das Debuggen des Spiels im Allgemeinen den gesamten Zyklus der Erstellung des Spiels. </li><li>  In einer kurzen Pause werde ich jede halbe Stunde versuchen, das zu korrigieren, was getan wurde, um meine Arbeit irgendwie zu korrigieren, einen weiteren Arbeitsplan zu skizzieren, Notizen, Notizen usw. zu machen. </li><li>  Bevor wir mit dem Testen jeder Engine beginnen, werden wir versuchen, das Spielprojekt in seine Bestandteile zu zerlegen, um ihnen konventionelle Einheiten zuzuweisen.  Daher messen wir unsere "Produktivität" des Spieleentwicklers für jede Engine in Papageien und können die Ergebnisse nicht in Worten, sondern zumindest in Zahlen vergleichen. </li></ol><br><h1 id="dekompoziciya-igry-na-sostavlyayuschie">  Zerlegung des Spiels in Komponenten </h1><br><p>  In einer sehr abstrakten und Top-Level-Form sehe ich mich als Bestandteile des Spiels wie folgt: </p><br><ol><li>  Spieler (Sprite, Sprungverhalten, Reaktion auf die gedrückten Tasten) </li><li>  Level-Objekte: Plattformen, Feinde usw. </li><li>  Physik: Sprunggeschwindigkeit des Spielers, Beschleunigung des freien Falls, Plattformen sollten <strong>nur dann</strong> mit Kollisionen umgehen, <strong>wenn sie von oben gesprungen wurden, und den Spieler durch ihn hindurchlassen,</strong> wenn er sie vom Boden der Plattform aus überquert. </li><li>  Prozedurale Level-Generierung: Initialisierung und Erweiterung des Levels (an beliebigen Orten, jedoch mit bestimmten Regeln und Einschränkungen) im Handumdrehen neuer Plattformen und Feinde, wodurch eine verlockende Spielsituation für den Spieler entsteht </li><li>  Eine „Kamera“, die dem Spieler folgt, wenn er das Level nach oben bewegt.  Die Kamera sollte den Player für den Player sichtbar halten und schrittweise mit ihm „springen“, wobei neue Plattformen im Rendering-Bereich (in der Sichtbarkeit der Kamera) angezeigt werden. </li><li> <code>Game Over</code> Auslösemechanismus.  Ein Spieler verliert, wenn er den unteren Rand des sichtbaren Bereichs erreicht (nachdem er bereits mindestens einmal gesprungen ist). </li><li>  Einen Spieler punkten.  Wir werden nur den Höhenzähler des Spielers aktualisieren.  Wir werden den Zähler entsprechend der zuletzt erreichten Plattform aktualisieren (die, von der er das letzte Mal abgestoßen hat). </li><li>  <code>HUD</code> : Spielerfortschritt anzeigen.  Höhenanzeige. </li></ol><br><p>  Der Einfachheit halber weisen wir jeder Komponente einen Punkt unserer Papageieneinheiten zu.  Gesamtmaximum - d.h.  Die spielbare Vollversion des Projekts beträgt <strong>8</strong> Punkte. </p><br><p>  Nachfolgend sind die in der Anzeige verwendeten Assets aufgeführt.  Dies sind handgezeichnete Sprites (ich bin kein Künstler, wie Sie sehen können) und Plattform-Sprites mit den Abmessungen 64x64, * .png-Format. </p><br><p><img src="https://habrastorage.org/webt/ap/6q/6s/ap6q6s-9nmbpn5rei2qivwdgyvq.png" alt="Unser springender Charakter"></p><br><p><img src="https://habrastorage.org/webt/4i/t9/ax/4it9axv7jqhakv3phhewgb3350e.png" alt="Die besten Plattformen der Welt"></p><br><p>  Und geben Sie auch ein paar Flussdiagramme: </p><br><ol><li>  Somit wird die Berechnung des "Geschlechts" für den Spieler implementiert (denken Sie daran, dass sich der Bildschirm mit einem Sprung nach oben verschiebt und eine Abweichung über den Bildschirmrand einen Graben bedeutet). <br><img src="https://habrastorage.org/webt/0i/jx/vv/0ijxvvvvj1ag_jjuk87ao5lx16e.png"></li><li>  Und so berechnen und aktualisieren wir die vertikale Geschwindigkeit ( <code>y_velocity</code> ) und die <code>y</code> Koordinate des Spielers bei jedem Schlag. Sie wird von zwei Faktoren beeinflusst: der Schwerkraftbeschleunigung ( <code>GRAVITY</code> ) und den Plattformen, bei deren Erreichen der Spieler mit vollständig wiederhergestellter Geschwindigkeit abgestoßen wird <br><img src="https://habrastorage.org/webt/ty/bs/br/tybsbrzi5persd_i-vyggqrzs5y.png"></li><li>  Der Algorithmus zur Berechnung der Horizontalgeschwindigkeit wurde wie andere Mechanismen nicht in den Geltungsbereich des Artikels aufgenommen. </li></ol><br><p>  Ich habe übrigens noch Fragen: </p><br><ol><li>  Wie ist es überhaupt besser, Kamera-Tracking für einen Spieler zu implementieren?  Bisher wird es an die vertikale Koordinate der letzten, höchsten Plattform gebunden, die der Spieler erreichen konnte, sodass sich diese Plattform im unteren Teil des sichtbaren Bereichs befindet und wir neue Teile des generierten Levels sehen. </li><li>  Der Plattformgenerierungsalgorithmus selbst.  Nach meiner Idee wird dies eine Art „Plattformfabrik“ sein, die in jedem Zyklus des Spielzyklus ( <code>dt</code> ) die höchste Plattform kennt, die auf der Ebene existiert, und einen zufälligen Höhenwert aufweist (ein bestimmter Schwellenwert, nicht mehr als die Sprunghöhe des Spielers, aber auch nicht weniger als ein bestimmter Bruchteil von seine Höhen, damit die Plattformen nicht nahe beieinander haften) fügt dem Level eine neue Plattform hinzu, wenn der Spieler fortgeschritten ist.  Interessant ist auch hier die Frage nach der zunehmenden Komplexität des Spiels, wie sich die Art der Generierung dieser Plattformen ändern soll. </li></ol><br><p>  Ich würde mich sehr über Ihre Ideen, Life-Hacks und Vorschläge in den Kommentaren und PM zu diesen beiden zweifellos spielerischen Themen freuen. </p><br><h1 id="pro-dvizhki">  Über Motoren </h1><br><p>  Drei Kandidaten wurden mit sehr interessanten Eigenschaften für mich ausgewählt.  Die Parameter, die bei der Analyse der Testergebnisse hilfreich sein sollten, sind nachstehend zusammengefasst. </p><br><div class="scrollable-table"><table><thead><tr><th>  Motor </th><th>  YaP </th><th>  Erfahrung in der Engine (0 - nein, 1 - es gibt Erfahrung und einige einfache geschriebene Spiele, 2 - die Engine wird entlang und quer gemeistert </th><th>  Erfahrung in YP (0 - nein, 1 - es gibt Erfahrung und gute Kenntnisse und Verständnis der Syntax, Redewendungen der Sprache, 2 - Profis für diese YP </th></tr></thead><tbody><tr><td>  Entfalten </td><td>  Lua </td><td>  0 </td><td>  1 </td></tr><tr><td>  Love2d </td><td>  Lua </td><td>  1 </td><td>  1 </td></tr><tr><td>  FXGL </td><td>  Java </td><td>  0 </td><td>  2 </td></tr></tbody></table></div><br><p>  Wir sehen also, dass die Auswahl sehr interessant ist.  Es ist insofern interessant, als wir uns mit verschiedenen Kombinationen unserer Qualitäten und Eigenschaften der Motoren befassen werden.  Und mal sehen, was sich am Ende auflöst: ein Motor, in dem ich schon ein bisschen Hand in Hand habe, ein gepumpter YP oder ein völlig frischer und neuer Motor für mich mit vielversprechenden Chips, der aber überhaupt nicht beherrscht wird und auch nicht in meiner Hauptentwicklungssprache. </p><br><h1 id="pochemu-ne-unityunreal-engineother-awesome-engine-etc">  Warum nicht Unity / Unreal Engine / Other Awesome Engine usw.? </h1><br><p>  Viele würden sich wahrscheinlich fragen, warum ich nicht den Standardweg gegangen bin und nicht die gängigsten Flaggschiffe unserer Zeit genommen habe: Unity oder Unreal Engine?  Ich würde meine Gedanken so formulieren: Ich möchte ein sehr einfaches, minimalistisches und winziges Spiel bauen.  Mit ein paar Spielelementen, die die Spielmechanik ausmachen, einem spielbaren Charakter, einer einfachen Generierung von Levels und ohne Spezialeffekte oder sehr konventionelle Spezialeffekte, wie bei alten Arcade-Automaten.  Im übertragenen Sinne ist es meine Aufgabe, einen roten Kreis auf ein schwarzes Quadrat zu zeichnen, und dazu bin ich eingeladen, <code>Photoshop</code> zu nehmen.  Einfach ausgedrückt, eine Reihe von Funktionen, Modi und Fähigkeiten von <code>Unity</code> mich erschreckt.  Zu diesem Zeitpunkt möchte ich jedes Detail meines Spiels verstehen. </p><br><p><img src="https://habrastorage.org/webt/9p/fv/tx/9pfvtxikfd6mmhsfp_gwqx0_g0u.jpeg" alt="Auswahl einer Spieleentwicklungs-Engine"></p><br><p>  Dies geschieht am besten mit einfachen und kleinen Motoren mit einer begrenzten Anzahl von Funktionen, möglicherweise nicht mit dem besten Tuning und Ökosystem, aber Einfachheit und Einschränkung haben auch ihre eigene Schönheit.  Mit nur einer begrenzten Anzahl von Werkzeugen - und im Fall von Love2D ist Ihr Werkzeug Ihr Code und nichts weiter. Sie konzentrieren sich auf den Fan, darauf, etwas Cooles zu schreiben, den Charakter oder die Umgebung des Spielers wiederzubeleben.  Bereits kompliziertere Engines erweitern Ihre Auswahl, und das Schreiben von Code fließt reibungslos in viele Dinge ein: Schreiben von Skripten (Code), Verknüpfen von Skripten, Zuordnen von Assets, Hinzufügen von Konfigurationen, Neudefinieren von Konfigurationen, Mischen von Plugins von Drittanbietern, Schreiben von Skripten und Konfigurationen für Plugins von Drittanbietern, mehrfaches Klicken Dutzende und Dutzende von Dialogen und Fenstern ... Sagen wir einfach, dass ich vorerst immer noch Angst vor solch hoch entwickelten und zweifellos fortschrittlichen und leistungsstarken Spieleentwicklungs-Engines habe.  Nun, ich möchte mich nicht noch einmal an C # / JS / C ++ erinnern und darauf schreiben. </p><br><p>  Ich fasse meine Motivation bei der Auswahl der Engine mit einem Link zu diesem Video zusammen. Mir scheint, dass der Autor das, was ich die ganze Zeit versucht habe, mit Worten für mich und andere zu formulieren, buchstäblich aus meiner Sprache entfernt hat: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://www.youtube.com/watch v = JH8xwNOQ0TM</a> </p><br><h1 id="defold">  Entfalten </h1><br><p>  <code>Defold</code> ist eine plattformübergreifende Engine von King. <br>  Unterstützte Plattformen: </p><br><ul><li>  HTML5 (WebGl) </li><li>  Android 2.3 (API Level 9) + </li><li>  iOS 8.0+ </li><li>  Windows Vista + </li><li>  OSX 10.7+ </li><li>  Linux </li></ul><br><p>  Die merkwürdige Tatsache ist, dass King <strong>Activision Blizzard gehört</strong> . <br>  In der Engine hat mich die Entwicklungssprache angezogen - <code>Lua</code> , Unterstützung für eine Reihe von Plattformen für Spiele-Builds sowie die Verteilung ihrer eigenen plattformübergreifenden <code>IDE</code> - kann auch unter Linux installiert werden.  Dies bestach mich bei der Wahl zwischen <code>Defold</code> vs.  <code>Corona SDK</code> . <br>  Und unten ist das Protokoll dessen, was an den Kontrollpunkten getan wurde: </p><br><div class="scrollable-table"><table><thead><tr><th>  Nein, nein. </th><th>  Zeit </th><th>  Kommentar </th></tr></thead><tbody><tr><td>  1 </td><td>  30m </td><td>  Wir haben 1 Tutorial, ein paar einführende Beschreibungen des Editors, ein Testprojekt getestet (Codierung eines Klick-Handlers, Lesen der Docks eines Trainingsprojekts). </td></tr><tr><td>  2 </td><td>  1h </td><td>  Dem Testtrainingsprojekt wurden einige Änderungen hinzugefügt.  Vielleicht ist es Zeit, Ihr Projekt aufzugreifen und dort zumindest etwas umzusetzen? </td></tr><tr><td>  3 </td><td>  1h 30m </td><td>  Springen von Menschen gemacht (Sprite mit Verhalten).  Nicht schlecht!  :) :) </td></tr><tr><td>  4 </td><td>  2h </td><td>  Es ist Zeit, Kontrolle hinzuzufügen.  Und es ist auch Zeit, Plattformen und Kollisionen hinzuzufügen?  Management und Plattform hinzugefügt, aber leider habe ich es nicht geschafft, Kollisionen zu behandeln. </td></tr><tr><td>  5 </td><td>  2h 30m </td><td>  Kollisionen!  Es ist notwendig, dass ein Mann weiß, wie man auf Plattformen springt und sich dann weiter von ihnen nach oben drückt.  Na dann.  Es gibt Konflikte, aber bisher arbeiten die Mechaniker schief :) </td></tr><tr><td>  6 </td><td>  3h </td><td>  Hurra, es gibt einen Konflikt und es scheint wahr.  Ich habe versucht, mehrere Kopien der Plattformen zu platzieren. </td></tr><tr><td>  7 </td><td>  3h 30m </td><td>  Jetzt sollten wir an eine schwebende Kamera denken, die auf und ab schwebt, wenn der Spieler zu neuen höheren Plattformen springt.  Ich bin nicht weitergekommen, sondern habe mich nur mit den Feinheiten des Schraubens der Kamera beschäftigt ... Es scheint ein Kinderspiel zu sein und es ist nicht so einfach, die Kamera einzurichten. </td></tr><tr><td>  8 </td><td>  4h </td><td>  HUD.  Zeigt die aktuelle Höhe des Players über dem Boden an. </td></tr></tbody></table></div><br><p>  Unten im Spoiler gibt es einige GIF-Animationen, die den zeitlichen Fortschritt zeigen: </p><br><div class="spoiler">  <b class="spoiler_title">Versteckter Text</b> <div class="spoiler_text"><p>  <strong>0-1h</strong> <br><img src="https://habrastorage.org/webt/p4/q7/wd/p4q7wdhlra-wxbgwmcdowldjuqm.gif" alt="0-1h"><br>  <strong>1-2h</strong> <br><img src="https://habrastorage.org/webt/ag/cx/3j/agcx3j6vk7jpmqac-eo8lnvfv8i.gif" alt="1-2h"><br>  <strong>4h</strong> <br><img src="https://habrastorage.org/webt/ai/k3/4-/aik34-vbwqrioxv1nqrki55tpqi.gif" alt="4h"></p></div></div><br><p>  Ergebnis, Benchmark-Punkte: </p><br><ol><li>  Spieler (Sprite, Sprungverhalten, Reaktion auf gedrückte Tasten) <code>(V) Yes</code> </li><li>  Level-Objekte: Plattformen, Feinde usw. <code>(V) Yes</code> </li><li>  Physik: Sprunggeschwindigkeit des Spielers, Beschleunigung des freien Falls. Plattformen sollten nur dann mit Kollisionen umgehen, wenn sie von oben gesprungen sind, und den Spieler durch ihn hindurchlassen, wenn er sie von der Unterseite der Plattform aus überquert. <code>(V) Yes</code> </li><li>  Prozedurale Level-Generierung: Initialisierung und Hinzufügen des Levels (an beliebigen Orten, jedoch mit bestimmten Regeln und Einschränkungen) im laufenden Betrieb neuer Plattformen und Feinde, wodurch für den Spieler eine verlockende Spielsituation entsteht <code>(X) No</code> </li><li>  Eine „Kamera“, die dem Spieler folgt, wenn er das Level nach oben bewegt.  Die Kamera sollte den Player für den Player sichtbar halten und nach und nach mit ihm „springen“, wobei neue Plattformen im Rendering-Bereich (in der Sichtbarkeit der Kamera) angezeigt werden <code>(X) No</code> </li><li>  Game Over-Auslösemechanismus.  Ein Spieler verliert, wenn er den unteren Rand des sichtbaren Bereichs erreicht (nachdem er bereits mindestens einmal gesprungen ist) <code>(X) No</code> </li><li>  Einen Spieler punkten.  Wir werden nur den Höhenzähler des Spielers aktualisieren.  Wir werden den Zähler entsprechend der zuletzt erreichten Plattform aktualisieren (von der er das letzte Mal abgestoßen hat) <code>(V) Yes</code> </li><li>  HUD: Spielerfortschritt anzeigen.  Höhenanzeige.  Optional scheint es im ursprünglichen Spiel keine Fortschrittsanzeigen zu geben. <code>(V) Yes</code> </li></ol><br><p>  <strong>Benchmark-Punktzahl: 5/8</strong> </p><br><h1 id="love2d">  Love2d </h1><br><p>  Dies ist eine sehr minimalistische, aber leistungsstarke und flexible Engine zum Erstellen von Prototypen.  Im Allgemeinen eignet es sich mit der gebotenen Geschicklichkeit sogar für die Veröffentlichung vollwertiger Spiele auf dem Markt.  Es gibt einige gute inspirierende Beispiele.  Nebenbei <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eins</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zwei</a> . </p><br><p>  Im Allgemeinen empfehle ich für diese Engine eine sehr geeignete Reihe von Tutorials von Habr, die mich anspornten und einen starken Impuls für die Entwicklung dieser Engine gaben. Ich werde nur einen Link zum ersten Teil geben, dann wird es möglich sein, von dort zu den verbleibenden Teilen zu gelangen: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erstellen eines Spiels auf Lua und LÖVE - 1</a> </p><br><p>  Im Folgenden finden Sie ein Protokoll darüber, was an den Kontrollpunkten getan wurde: </p><br><div class="scrollable-table"><table><thead><tr><th>  Nein, nein. </th><th>  Zeit </th><th>  Kommentar </th></tr></thead><tbody><tr><td>  1 </td><td>  30m </td><td>  Einrichten eines Projekts, Erstellen grundlegender Handler, Erstellen einer Spielerklasse (Framework mit Sprunglogik und Schwerkraft funktioniert immer noch nicht) </td></tr><tr><td>  2 </td><td>  1h </td><td>  Es wurde eine Fabrik gebaut, die Plattformen darstellt, ein springender Mann wurde gebaut.  Hurra! </td></tr><tr><td>  3 </td><td>  1h 30m </td><td>  Der Versuch, die Hardoncollider-Bibliothek zu verschrauben.  Frust verbunden mit der Tatsache, dass das Dock auf der offiziellen Website nach der veralteten Version geschrieben ist, sucht nach aktuellen Docks, schraubt Kollisionen ein.  Es wurden noch keine Kollisionen implementiert </td></tr><tr><td>  4 </td><td>  2h </td><td>  Es gibt Konflikte, aber es sind Kurven :( </td></tr><tr><td>  5 </td><td>  2h 30m </td><td>  Kollisionen werden gemacht, es gibt ein paar Mängel, aber im Allgemeinen - die Normen.  Versuchen Sie, die Kamera zu befestigen, um den Spieler zu verfolgen, und folgen Sie seinen Sprüngen.  Noch nicht sehr erfolgreich .. </td></tr><tr><td>  6 </td><td>  3h </td><td>  Es gibt eine Generation von Plattformen, aber Kollisionen sind immer noch fehlerhaft und lahm :( </td></tr><tr><td>  7 </td><td>  3h 30m </td><td>  Die Definition von Game Over wird implementiert - die Feststellung, dass ein Spieler über den unteren Rand des sichtbaren Bereichs gefallen ist.  Die Bewertung wird implementiert - d.h.  Anzeige in der oberen linken Ecke der zuletzt aufgenommenen Höhe </td></tr><tr><td>  8 </td><td>  4h </td><td>  In der folgenden Tabelle finden Sie Informationen darüber, was nach 4 Stunden Entwicklung des Doodle Jump-Klons auf der Love2d-Engine erreicht wurde. </td></tr></tbody></table></div><br><p><img src="https://habrastorage.org/webt/oo/zk/si/oozksiscybfmanckw7llj6sohjy.gif" alt="Die endgültige Version des Spiels auf Love2D in 4 Stunden"></p><br><p>  Berechnen Sie die "Leistung" des Motors: </p><br><ol><li>  Spieler (Sprite, Sprungverhalten, Reaktion auf gedrückte Tasten) <code>(V) Yes</code> </li><li>  Level-Objekte: Plattformen, Feinde usw. <code>(V) Yes</code> </li><li>  Physik: Sprunggeschwindigkeit des Spielers, Beschleunigung des freien Falls. Plattformen sollten nur dann mit Kollisionen umgehen, wenn sie von oben gesprungen sind, und den Spieler durch ihn hindurchlassen, wenn er sie von der Unterseite der Plattform aus überquert. <br>  <code>(V) Yes</code> / <code>(X) No</code> // * Implementiert, aber nicht ganz perfekt, mit erheblichen Fehlern.  Ich würde hier <strong>0,5</strong> Punkte für die Vervollständigung des Artikels setzen. </li><li>  Prozedurale Level-Generierung: Initialisierung und Ergänzung des Levels (an beliebigen Orten, jedoch mit bestimmten Regeln und Einschränkungen) im Handumdrehen neuer Plattformen und Feinde, wodurch für den Spieler eine verlockende Spielsituation entsteht <code>(V) Yes</code> </li><li>  Eine „Kamera“, die dem Spieler folgt, wenn er das Level nach oben bewegt.  Die Kamera sollte den Player für den Player sichtbar halten und schrittweise mit ihm „springen“, wobei neue Plattformen im Rendering-Bereich (in der Sichtbarkeit der Kamera) angezeigt werden <code>(V) Yes</code> </li><li>  Game Over-Auslösemechanismus.  Ein Spieler verliert, wenn er den unteren Rand des sichtbaren Bereichs erreicht (nachdem er bereits mindestens einmal gesprungen ist) <code>(V) Yes</code> </li><li>  Einen Spieler punkten.  Wir werden nur den Höhenzähler des Spielers aktualisieren.  Wir werden den Zähler entsprechend der zuletzt erreichten Plattform aktualisieren (von der er das letzte Mal abgestoßen hat) <code>(V) Yes</code> </li><li>  HUD: Spielerfortschritt anzeigen.  Höhenanzeige.  Optional scheint es im ursprünglichen Spiel keine Fortschrittsanzeigen zu geben. <code>(V) Yes</code> </li></ol><br><p>  <strong>Benchmark-Punktzahl:</strong> <strong>7,5 / 8</strong> </p><br><h1 id="java">  Java </h1><br><p>  Vielleicht wäre es ein logischer und logischer Schritt, sich die Engines genauer anzusehen, in denen die Entwicklungssprache diejenige ist, in der ich die meiste Erfahrung und Geschicklichkeit habe, nicht wahr?  Eigentlich haben mich Intuition und einige innere Empfindungen ein wenig davon abgehalten.  Tatsache ist, dass ich als Student meinen Klassenkameraden mit der <code>jMonkey</code> Engine irgendwie <code>jMonkey</code> .  Werkzeuge, Arbeiten mit dem Motor, Dokumentation, all dies zusammen ergab ein nicht sehr angenehmes Bild.  Es schien, als hätte der Motor Ihnen einfach keine Gelegenheit gegeben, sich mit ihm anzufreunden, und seine Verwendung sah irgendwie unangenehm aus. </p><br><p>  Trotzdem habe ich mich entschlossen, mir anzusehen, was heute verfügbar ist, und ich habe nur in Richtung Motoren geschaut, die nur <code>2D</code> garantieren. Die <code>3D</code> Unterstützung war mir egal.  Eine der Engines, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lightweight Java Game Library 3</a> , hat ihren Namen und das einleitende Wort <code>Lightweight</code> .  Ironischerweise wurden die einfachsten grundlegenden Beispiele auf der Hauptseite, mehrere Bildschirme lang, einfach verängstigt. </p><br><p>  Ja, natürlich ist <code>Java</code> sehr ausführlich, was Sie wollten, sagen Sie.  Aber ich weiß, dass man sehr kompakte und sehr ausdrucksstarke Dinge darauf schreiben kann.  Ich habe eine schöne und kompakte API gesehen. <br>  Und am Ende fiel die Wahl auf <code>FXGL</code> .  Anfangs hatte ich keine Begeisterung und keine angenehme Aufregung, was vor dem Beginn der Entwicklung einer interessanten Sache oder Bibliothek passiert.  Aber schon von den ersten Beispielen und kurzen Seiten mit Dokumentationen und Beispielen hat mich diese Engine immer mehr positiv überrascht.  Alles war logisch, verständlich und konsistent in dem von ihm vorgeschlagenen Ansatz und der API.  Es hat Ihnen definitiv geholfen, eine klare und flexible Schleife für Ihr Spiel, Ihre <code>HUD</code> , Ihr <code>HUD</code> , Ihre <code>AI</code> , Ihre Kollisionen und andere Elemente zu erstellen. </p><br><h2 id="interesnye-momenty-i-fishki-fxgl">  Interessante Momente und FXGL-Chips: </h2><br><ul><li><p>  Wie der Name vielleicht andeutet, verwendet die Engine für den visuellen Teil die JavaFX-API ( <code>JavaFX</code> wird als Grafik-Framework verwendet) mit all ihren Extras und Anti-Goodies für das Rendern und Layout.  Im Allgemeinen halte ich dies für eine gute und recht fundierte Entscheidung.  Auf diese Weise hat der Autor eine Reihe von Problemen vermieden (es ist nicht erforderlich, Ihre Rendering-Komponente zu implementieren und zu warten, Sie können eine verfeinerte Lösung aus dem <code>Java</code> Ökosystem verwenden).  Folgendes sagt der Autor selbst in einem seiner ersten Tutorials, und dieser Satz hat mir sehr gut gefallen: </p><br><blockquote>  "Für die meisten UI-Objekte verwenden wir einfach JavaFX-Objekte, da das Rad nicht neu erfunden werden muss." </blockquote><p>  Aber im Allgemeinen erhalten Sie natürlich auch eine Reihe von Funktionen und einige Nachteile von <code>JavaFX</code> (ich kenne die Details nicht sehr gut), aber soweit ich weiß, gibt es einige Lizenzbeschränkungen für die Verwendung von <code>JavaFX</code> in Ihren Projekten, und es scheint, dass <code>JavaFX</code> geht und geht nur in begrenzten Lieferungen von <code>JDK</code> ( <code>Oracle</code> , vielleicht noch mehr). </p><br></li><li><p>  Ein Testprojekt aus dem Repository, auf dessen Grundlage ich mit der Gestaltung des Spiels begonnen habe, legt die Protokolle freundlicherweise nach jedem Spielstart im <code>logs/</code> project ab.  Dies ist sehr praktisch, Sie können sofort über die Debug-Informationen hinausschauen. Es ist sehr nützlich für die Diagnose und um zu verstehen, wo Sie Fehler gemacht haben, wenn Sie plötzlich einen Stecker in der Studie des Motors gefunden haben. </p><br></li><li><p>  Außerdem (anscheinend wieder mit Grundeinstellungen) bietet das Spiel ein Popup-Menü durch Drücken der <code>Esc</code> .  Auch ein schöner Bonus, ich hoffe es ist angepasst oder zumindest durch Code oder Konfigurationen deaktiviert. </p><br></li><li><p>  <strong>Debag</strong> funktioniert endlich <strong>hier</strong> !  Endlich!  In <code>Love2D</code> , gelinde gesagt, unpraktisch und unangenehm. </p><br><h2 id="log-razrabotki">  Entwicklungsprotokoll </h2><br><p>  Im Folgenden finden Sie eine kurze Zusammenfassung meiner Fortschritte, in der ich kurz notierte, was nach dem 30-minütigen Intervall erreicht wurde, sowie einige meiner Gedanken und Kommentare.  Seht das Protokoll meines Bewusstseins in diesen 4 Stunden! </p><br></li></ul><br><div class="scrollable-table"><table><thead><tr><th>  Nein, nein. </th><th>  Zeit </th><th>  Kommentar </th></tr></thead><tbody><tr><td>  1 </td><td>  30m </td><td>  Ich habe ein paar Tutorials gelernt.  Basis-API und Game-Loop-Struktur.  Erfahren Sie, wie Sie Sprites zeichnen, Objekte verschieben, HUDs anzeigen und aktualisieren.  Begann Kollisionen ins Spiel zu schrauben. </td></tr><tr><td>  2 </td><td>  1h </td><td>  Es gibt eine Sprungbox mit einem Kollisionskörper (Bounding Box), die "vom Boden abstoßen kann" (dh es gibt eine Definition des unteren Randes des Bildschirms). </td></tr><tr><td>  3 </td><td>  1h 30m </td><td>  Der Grundstein für die Plattformfabrik wird gelegt (PlatformFactory.java).  Es scheint sogar möglich zu sein, die Kollision zu „zähmen“ und es zu schaffen, den Charakter von der Plattform abzustoßen.  Dies ist zweifellos ein Erfolg für die neue Engine und mit der Erfahrung in einem halb gelesenen GitHubWiki-Tutorial. </td></tr><tr><td>  4 </td><td>  2h </td><td>  Ein wenig abgeschlossene Kollisionen mit den Plattformen, aber immer noch fehlerhaft und nicht perfekt.  Ziemlich schnell habe ich es geschafft, mit einer Kamera zu verfolgen, wieder ist es auch ein wenig scharf und ungeschickt, aber die Polierglätte wird den Rahmen des Benchmarks und insbesondere der Erfahrung mit FXGL sprengen.  Es war auch nicht schwierig, den Code für die Plattformgenerierungsfactory hinzuzufügen, sodass die Plattformen in einem akzeptablen zufälligen Abstand von der zuletzt generierten Plattform generiert wurden.  Und der Code, der sie im Verlauf des Spielers erzeugte, wurde auch in den Hauptspielzyklus integriert.  Ziemlich gute Fortschritte, was mich betrifft. </td></tr><tr><td>  5 </td><td>  2h 30m </td><td>  Na dann.  Zu diesem Zeitpunkt ist praktisch das gesamte Spiel fertig.  Alle Grundkomponenten sind implementiert.  Und selbst der richtige Mechanismus, um den Player von den Plattformen wegzuschieben (wow!), Wurde poliert und mit einer Datei finalisiert, die mit den beiden vorherigen Motoren nicht perfekt erreicht wurde.  Vielleicht haben sich hier bereits gesammelte Erfahrungen und Intuitionen ausgewirkt, argumentiere ich nicht.  Außerdem wurde der Randomizer zum Berechnen von Positionen für neue Plattformen etwas stummgeschaltet, da mit den vorherigen Parametern absolut unerreichbare Plattformen erschienen, was zu Game Over führte. </td></tr><tr><td>  6 </td><td>  3h </td><td>  Ein weiteres wichtiges Merkmal des Doodle Jump wurde implementiert (das außerhalb des Rahmens der Hauptaufgabe lag). Wenn ein Spieler über den linken oder rechten Rand des Levels springt, erscheint er auf der anderen Seite, während er seine Geschwindigkeit beibehält (Impuls).  Dieses Gameplay ist eine sehr wichtige Komponente von Doodle Jump.  Was macht das Spiel unter anderem vielfältig und eingängig.  Außerdem wurde die Funktion zum Zurücksetzen des Spiels schnell aufgerollt und der Code der Feinde und der feindlichen KI wurde aufgerollt.  Bisher ist dies nicht im Spiel, sondern auf Prototypenebene. </td></tr><tr><td>  7 </td><td>  3h 30m </td><td>  Ein Algorithmus zur zufälligen Erzeugung von Feinden auf der Ebene ist implementiert.  Es ist überhaupt nicht perfekt, aber es fügt dem Spieler bereits ein Element von Spaß und Herausforderung hinzu. AI ,         —    -  ,   ,      .      . </td></tr><tr><td>  8 </td><td> 4h </td><td>    .      —    .  ,       .   ,     ,           <code>Space</code> . </td></tr></tbody></table></div><br><p>        GIF-    ,    . </p><br><div class="spoiler">  <b class="spoiler_title">Versteckter Text</b> <div class="spoiler_text"><p> <em>0-1h</em> <br><img src="https://habrastorage.org/webt/ri/v0/mg/riv0mgwefn6xb7rxlkujgxd4vhy.gif" alt="*0-1h*"><br> <em>1h-1h 30m</em> <br><img src="https://habrastorage.org/webt/1o/wc/m-/1owcm-hu43iasjopd5zt5e4rs2m.gif" alt="*1h-1h 30m*"><br> <em>2h 30m (      )</em> <br><img src="https://habrastorage.org/webt/mz/cr/vg/mzcrvgyflbw08px8j76g4gnud14.gif" alt="2h 30m"><br> <em>3h 30m</em> <br><img src="https://habrastorage.org/webt/qh/wk/_9/qhwk_9zk522fbvcyhigxemlicw4.gif" alt="3h 30m"><br> <em>4h</em> <br><img src="https://habrastorage.org/webt/ml/jq/mt/mljqmt9wumswmmtyelzka9jdpcu.gif" alt="*4h*"></p></div></div><br><p>  "" …  ,     ,   ,          ?    . </p><br><p> <strong>Benchmark Score:</strong> <strong>8</strong> </p><br><h1 id="vyvody-mysli-idei"> , ,  </h1><br><p>        : </p><br><div class="scrollable-table"><table><thead><tr><th>  </th><th>  </th><th>    (0 — , 1 —       , 2 —      </th><th>    (0 — , 1 —        ,  , 2 —     </th><th> Benchmark Score </th><th>   </th></tr></thead><tbody><tr><td> Defold </td><td> Lua </td><td>  0 </td><td>  1 </td><td> <strong>5/8</strong> </td><td>  <strong>166</strong> </td></tr><tr><td> Love2D </td><td> Lua </td><td>  1 </td><td>  1 </td><td> 7.5/8 </td><td>  701 </td></tr><tr><td> FXGL </td><td>  Java </td><td>  0 </td><td>  <strong>2</strong> </td><td>  <strong>8</strong> </td><td>  582 </td></tr></tbody></table></div><br><p> ,     ,         ,       (     ). ,  ,  Java       <code>FXGL</code> ,        ,     <code>Lua</code> ,     .  ,   , . </p><br><p>     : </p><br><ol><li>   <code>FXGL</code>    ?     . <code>Love2D</code>   ,     <code>Defold</code>      ,   ,    ,          ,  <code>Love2D</code>   -  ,              . </li><li>   ,   . ,   .      (, ),      . ,         -  .   ,   ,   ,        ,         .   ,  ,     ,          .       . </li><li>       gif-,     .        .  ,          , ""         ,            . </li></ol><br><h1 id="chto-eto-vsyo-dalo-mne">     ? </h1><br><p> ,   - ,              ? </p><br><p>  Also: </p><br><ol><li> ,  .  ,      , , ,     . -      , -      ( <code>Love2D</code> ). </li><li>     -    ,    <code>Love2D</code> ,     .  <code>F to pay respect</code> . </li><li>       .    ,      ,   ,    -       -    ,     ,   (, ,  ) </li><li>    .     <strong>4</strong>    ,       .  - <code>Game Jam</code> ,   . </li><li>  ! ,         ,     - Roadmap  ,     ,      .    (!)      (?)        .      <strong>30</strong>          .     ,                    . ,          ,  ! ,            pet-       <strong>44</strong> - <code>Ludum Dare</code> . </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de449390/">https://habr.com/ru/post/de449390/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de449380/index.html">Ist der Berater kompetent? Problemempfehlungen „Rad nicht neu erfinden“</a></li>
<li><a href="../de449382/index.html">Forschung: Medien folgen Inhalten in Telegrammkanälen</a></li>
<li><a href="../de449384/index.html">Test: Ist Udalenka für Sie geeignet (nicht freiberuflich!)?</a></li>
<li><a href="../de449386/index.html">Internet für den Sommerbewohner. Wir erreichen die maximale Geschwindigkeit in 4G-Netzen. Teil 1. Auswahl des richtigen Routers</a></li>
<li><a href="../de449388/index.html">Drucken ... Leidenschaft?</a></li>
<li><a href="../de449392/index.html">Abrufen von Statistiken für alle Clients aus der Yandex.Direct-API nach Tagen mithilfe von Python</a></li>
<li><a href="../de449398/index.html">Mikhail Larionov, Circles.is: Über Karrieren auf Facebook, Unternehmertum, Community Building und Produktdenken</a></li>
<li><a href="../de449408/index.html">Advantech HMI-basiertes HMI-Bedienfeld</a></li>
<li><a href="../de449410/index.html">Interview: Schnell. Fragen und Antworten</a></li>
<li><a href="../de449412/index.html">Was die Verbrauchergemeinschaft tut, um Open Source-Software zu zerstören</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>