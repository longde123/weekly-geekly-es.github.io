<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üè¥Û†ÅßÛ†Å¢Û†Å∑Û†Å¨Û†Å≥Û†Åø üìø üë©üèº Syst√®me d'emploi et chemin de recherche üï∂Ô∏è üèè üçî</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La carte 
 Dans un article pr√©c√©dent, j'ai examin√© ce qu'est le nouveau syst√®me de travail , comment il fonctionne, comment cr√©er des t√¢ches, les remp...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Syst√®me d'emploi et chemin de recherche</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/423601/"><h3>  La carte </h3><br>  Dans un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article pr√©c√©dent,</a> j'ai examin√© ce qu'est le nouveau <b>syst√®me de travail</b> , comment il fonctionne, comment cr√©er des t√¢ches, les remplir avec des donn√©es et effectuer des calculs multithread, et je n'ai expliqu√© que bri√®vement o√π vous pouvez utiliser ce syst√®me.  Dans cet article, je vais essayer d'analyser un exemple sp√©cifique de l'endroit o√π vous pouvez utiliser ce syst√®me pour obtenir plus de performances. <br><a name="habracut"></a><br>  √âtant donn√© que le syst√®me a √©t√© initialement d√©velopp√© dans le but de travailler avec des donn√©es, il est id√©al pour r√©soudre les t√¢ches de recherche de chemin. <br><br>  <b>Unity</b> poss√®de d√©j√† un bon <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">explorateur NavMesh</a> , mais il ne fonctionne pas dans les projets 2D, bien qu'il existe de nombreuses solutions pr√™tes √† l'emploi sur le m√™me <i>actif</i> .  Eh bien, et nous essaierons de cr√©er non seulement un syst√®me qui cherchera des moyens sur la carte cr√©√©e, mais rendra cette carte tr√®s dynamique, de sorte que chaque fois que quelque chose change, le syst√®me cr√©e une nouvelle carte, et tout cela, bien s√ªr, nous calculerons en utilisant un nouveau syst√®me de t√¢ches, afin de ne pas charger le thread principal. <br><br><div class="spoiler">  <b class="spoiler_title">Exemple de fonctionnement du syst√®me</b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/527/a69/ec1/527a69ec1543218ffe1df7c4b1deddb0.gif" alt="image"><br></div></div><br>  Dans l'exemple, une grille est construite sur la carte, il y a un bot et un obstacle.  La grille est reconstruite chaque fois que nous modifions les propri√©t√©s de la carte, que ce soit sa taille ou sa position. <br><br>  Pour les avions, j'ai utilis√© un simple <b>SpriteRenderer</b> , ce composant a une excellente propri√©t√© de <b>limites</b> avec laquelle vous pouvez facilement trouver la taille de la carte. <br><br>  C'est essentiellement tout pour commencer, mais nous ne nous arr√™terons pas et nous passerons imm√©diatement aux choses s√©rieuses. <br><br>  Commen√ßons par les scripts.  Et le premier est le script d'obstruction <b>Obstacle</b> . <br><br><div class="spoiler">  <b class="spoiler_title">Obstacle</b> <div class="spoiler_text"><pre><code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MonoBehaviour</span></span></span><span class="hljs-class"> </span></span>{ }</code> </pre> <br></div></div><br>  √Ä l'int√©rieur de la classe <b>Obstacle</b> , nous verrons tous les changements dans les obstacles sur la carte, par exemple, en changeant la position ou la taille d'un objet. <br>  Ensuite, vous pouvez cr√©er la classe <b>Map</b> map, sur laquelle la grille sera construite, et l'h√©riter de la classe <b>Obstacle</b> . <br><br><div class="spoiler">  <b class="spoiler_title">La carte</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> </span></span>{ }</code> </pre> <br></div></div><br>  La classe <b>Map</b> suivra √©galement toutes les modifications sur la carte afin de reconstruire la grille si n√©cessaire. <br><br>  Pour ce faire, remplissez la classe de base <b>Obstacle</b> avec toutes les variables et m√©thodes n√©cessaires pour suivre les modifications d'objets. <br><br><div class="spoiler">  <b class="spoiler_title">Obstacle</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MonoBehaviour</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SpriteRenderer renderer { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Vector2 tempSize; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Vector2 tempPos; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> virtual <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Awake() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.renderer = GetComponent&lt;SpriteRenderer&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempSize = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.size; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempPos = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.position; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> virtual bool CheckChanges() { Vector2 newSize = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.size; float diff = (newSize - <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempSize).sqrMagnitude; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (diff &gt; <span class="hljs-number"><span class="hljs-number">0.01</span></span>f) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempSize = newSize; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } Vector2 newPos = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.position; diff = (newPos - <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempPos).sqrMagnitude; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (diff &gt; <span class="hljs-number"><span class="hljs-number">0.01</span></span>f) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempPos = newPos; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2 size { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.renderer.bounds.size;} } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2 position { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.transform.position;} } }</code> </pre> <br></div></div><br>  Ici, la variable de <b>rendu</b> aura une r√©f√©rence au composant <b>SpriteRenderer</b> , et les <b>variables</b> <b>tempSize</b> et <b>tempPos</b> seront utilis√©es pour suivre les changements de taille et de position de l'objet. <br><br>  La m√©thode virtuelle <b>Awake</b> sera utilis√©e pour initialiser les variables, et la m√©thode virtuelle <b>CheckChanges</b> suivra les changements actuels dans la taille et la position de l'objet et retournera un r√©sultat <b>bool√©en</b> . <br><br>  Pour l'instant, laissons le script <b>Obstacle</b> et passons au script <b>Map</b> map lui-m√™me, o√π nous le remplissons √©galement avec les param√®tres n√©cessaires pour le travail. <br><br><div class="spoiler">  <b class="spoiler_title">La carte</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> </span></span>{ [Range(<span class="hljs-number"><span class="hljs-number">0.1</span></span>f, <span class="hljs-number"><span class="hljs-number">1</span></span>f)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> float nodeSize = <span class="hljs-number"><span class="hljs-number">0.5</span></span>f; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2 offset = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5</span></span>f, <span class="hljs-number"><span class="hljs-number">0.5</span></span>f); }</code> </pre> <br></div></div><br>  La variable <b>nodeSize</b> indiquera la taille des cellules sur la carte, ici j'ai limit√© sa taille de 0,1 √† 1 pour que les cellules de la grille ne soient pas trop petites, mais aussi trop grandes.  La variable de <b>d√©calage</b> sera utilis√©e pour indenter la carte lors de la construction de la grille afin que la grille ne se construise pas le long des bords de la carte. <br><br>  Comme il y a maintenant deux nouvelles variables sur la carte, il s'av√®re que leurs changements devront √©galement √™tre suivis.  Pour ce faire, ajoutez quelques variables et surchargez la m√©thode <b>CheckChanges</b> dans la classe <b>Map</b> . <br><br><div class="spoiler">  <b class="spoiler_title">La carte</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> </span></span>{ [Range(<span class="hljs-number"><span class="hljs-number">0.1</span></span>f, <span class="hljs-number"><span class="hljs-number">1</span></span>f)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> float nodeSize = <span class="hljs-number"><span class="hljs-number">0.5</span></span>f; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2 offset = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5</span></span>f, <span class="hljs-number"><span class="hljs-number">0.5</span></span>f); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> float tempNodeSize; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Vector2 tempOffset; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Awake() { base.Awake(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempNodeSize = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempOffset = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.offset; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> bool CheckChanges() { float diff = Mathf.Abs(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempNodeSize - <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (diff &gt; <span class="hljs-number"><span class="hljs-number">0.01</span></span>f) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempNodeSize = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } diff = (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempOffset - <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.offset).sqrMagnitude; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (diff &gt; <span class="hljs-number"><span class="hljs-number">0.01</span></span>f) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempOffset = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.offset; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> base.CheckChanges(); } }</code> </pre> <br></div></div><br>  C'est fait.  Vous pouvez maintenant cr√©er un sprite de carte sur la sc√®ne et lancer un script de <b>carte</b> dessus. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d75/60f/db8/d7560fdb8abeb5f00a7a5e1ec5e444df.png" alt="image"><br><br>  Nous ferons de m√™me avec un obstacle - cr√©ez un simple sprite sur sc√®ne et lancez le script <b>Obstacle</b> dessus. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/347/ffa/e8d/347ffae8dd2b4cd3a3a50c881d5674df.png" alt="image"><br><br>  Nous avons maintenant des objets cartographiques et des obstacles sur sc√®ne. <br><br>  Le script de <b>carte</b> sera responsable du suivi de toutes les modifications sur la carte, o√π dans la m√©thode de <b>mise √† jour</b> , nous v√©rifierons chaque cadre pour les modifications. <br><br><div class="spoiler">  <b class="spoiler_title">La carte</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*... ‚Ä¶*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> bool requireRebuild; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Update() { UpdateChanges(); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> UpdateChanges() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.requireRebuild) { print(‚Äú  ,   !‚Äù); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.requireRebuild = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.requireRebuild = CheckChanges(); } } <span class="hljs-comment"><span class="hljs-comment">/*... ‚Ä¶*/</span></span> }</code> </pre> <br></div></div><br>  Ainsi, dans la m√©thode <b>UpdateChanges, la</b> carte ne suivra que ses modifications jusqu'√† pr√©sent.  Vous pouvez m√™me d√©marrer le jeu maintenant et essayer de modifier la taille de la carte ou le <b>d√©calage de d√©calage</b> pour vous assurer que tous les changements sont suivis. <br><br>  Maintenant, vous devez en quelque sorte suivre les changements des obstacles eux-m√™mes sur la carte.  Pour ce faire, nous mettrons chaque obstacle dans une liste sur la carte, qui √† son tour mettra √† jour chaque cadre dans la m√©thode <b>Update</b> . <br><br>  Dans la classe <b>Map</b> , cr√©ez une liste de tous les obstacles possibles sur la carte et quelques m√©thodes statiques pour les enregistrer. <br><br><div class="spoiler">  <b class="spoiler_title">La carte</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*... ‚Ä¶*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Map ObjInstance; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;Obstacle&gt; obstacles = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Obstacle&gt;(); <span class="hljs-comment"><span class="hljs-comment">/*... ‚Ä¶*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> bool RegisterObstacle(Obstacle obstacle) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obstacle == Instance) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Instance.obstacles.Contains(obstacle) == <span class="hljs-literal"><span class="hljs-literal">false</span></span>) { Instance.obstacles.Add(obstacle); Instance.requireRebuild = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> bool UnregisterObstacle(Obstacle obstacle) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Instance.obstacles.Remove(obstacle)) { Instance.requireRebuild = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Map Instance { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ObjInstance == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) ObjInstance = FindObjectOfType&lt;Map&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ObjInstance; } } }</code> </pre> <br></div></div><br>  Dans la m√©thode <b>RegisterObstacle</b> statique, nous allons enregistrer un nouvel <b>obstacle Obstacle</b> sur la carte et l'ajouter √† la liste, mais tout d'abord, il est important de consid√©rer que la carte elle-m√™me est √©galement h√©rit√©e de la classe <b>Obstacle</b> et nous devons donc v√©rifier si nous essayons d'enregistrer la carte elle-m√™me comme obstacle. <br><br>  La m√©thode statique <b>UnregisterObstacle</b> , au contraire, √©limine l'obstacle de la carte et le supprime de la liste lorsque nous permettons qu'il soit d√©truit. <br><br>  Dans le m√™me temps, chaque fois que nous ajoutons ou supprimons un obstacle de la carte, il est n√©cessaire de recr√©er la carte elle- <b>m√™me.Ainsi</b> , apr√®s avoir ex√©cut√© ces m√©thodes statiques, d√©finissez la variable <b>requireRebuild</b> sur <b>true</b> . <br><br>  De plus, pour avoir un acc√®s facile au script <b>Map √†</b> partir de n'importe quel script, j'ai cr√©√© une propri√©t√© <b>Instance</b> statique qui me rendra cette instance m√™me de <b>Map</b> . <br><br>  Revenons maintenant au script <b>Obstacle</b> o√π nous allons enregistrer un obstacle sur la carte. Pour ce faire, ajoutez-y quelques m√©thodes <b>OnEnable</b> et <b>OnDisable</b> . <br><br><div class="spoiler">  <b class="spoiler_title">Obstacle</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MonoBehaviour</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*... ‚Ä¶*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> virtual <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnEnable() { Map.RegisterObstacle(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> virtual <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnDisable() { Map.UnregisterObstacle(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } }</code> </pre> <br></div></div><br>  Chaque fois que nous cr√©ons un nouvel obstacle en jouant sur la carte, il s'enregistrera automatiquement dans la m√©thode <b>OnEnable</b> , o√π il sera pris en compte lors de la construction d'une nouvelle grille et nous supprimera de la carte dans la m√©thode <b>OnDisable</b> lorsqu'il sera d√©truit ou d√©sactiv√©. <br><br>  Il ne reste plus qu'√† suivre les changements des obstacles eux-m√™mes dans le script <b>Map</b> dans la m√©thode <b>CheckChanges</b> surcharg√©e. <br><br><div class="spoiler">  <b class="spoiler_title">La carte</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*... ‚Ä¶*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> bool CheckChanges() { float diff = Mathf.Abs(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempNodeSize - <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (diff &gt; <span class="hljs-number"><span class="hljs-number">0.01</span></span>f) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempNodeSize = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } diff = (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempOffset - <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.offset).sqrMagnitude; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (diff &gt; <span class="hljs-number"><span class="hljs-number">0.01</span></span>f) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tempOffset = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.offset; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } foreach(Obstacle obstacle <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.obstacles) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obstacle.CheckChanges()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> base.CheckChanges(); } <span class="hljs-comment"><span class="hljs-comment">/*... ‚Ä¶*/</span></span> }</code> </pre> <br></div></div><br>  Nous avons maintenant une carte, des obstacles - en g√©n√©ral, tout ce dont vous avez besoin pour construire une grille et maintenant vous pouvez passer √† la chose la plus importante. <br><br><h4>  Maillage </h4><br>  La grille, dans sa forme la plus simple, est un tableau bidimensionnel de points.  Pour le construire, vous devez conna√Ætre la taille de la carte et la taille des points dessus, apr√®s quelques calculs, nous obtenons le nombre de points horizontalement et verticalement, voici notre grille. <br><br>  Il existe de nombreuses fa√ßons de trouver un chemin sur une grille.  Dans cet article, cependant, l'essentiel est de comprendre comment utiliser correctement les capacit√©s du syst√®me de t√¢ches, donc ici je ne consid√©rerai pas diff√©rentes options pour trouver le chemin, leurs avantages et leurs inconv√©nients, mais je prendrai l'option de recherche la plus simple <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">A *</a> . <br><br>  Dans ce cas, tous les points de la grille doivent avoir, en plus de la position, les coordonn√©es et la propri√©t√© de perm√©abilit√©. <br><br>  Avec perm√©abilit√©, je pense que tout est clair pourquoi il est n√©cessaire, mais les coordonn√©es indiqueront l'ordre du point sur la grille, ces coordonn√©es ne sont pas li√©es sp√©cifiquement √† la position du point dans l'espace.  L'image ci-dessous montre une grille simple montrant les diff√©rences de coordonn√©es d'une position. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7c1/c12/466/7c1c124662f7c41ecb2a1c55939a1a64.png" alt="image"><br>  <i>Pourquoi les coordonn√©es?</i> <br>  Le fait est que dans l'unit√©, pour indiquer la position d'un objet dans l'espace, un <b>flottant</b> simple est tr√®s inexact et peut √™tre un nombre fractionnaire ou n√©gatif, il sera donc difficile de l'utiliser pour impl√©menter une recherche de chemin sur la carte.  Les coordonn√©es sont faites sous la forme d'un <b>int</b> clair qui sera toujours positif et avec lequel il est beaucoup plus facile de travailler lors de la recherche de points voisins. <br><br>  Tout d'abord, d√©finissons un objet point, ce sera une structure de <b>n≈ìud</b> simple. <br><br><div class="spoiler">  <b class="spoiler_title">Noeud</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct Node { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> int id; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2 position; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2Int coords; }</code> </pre> <br></div></div><br>  Cette structure contiendra la position <b>position</b> sous la forme de <b>Vector2</b> , o√π avec cette variable nous dessinerons un point dans l'espace.  La <b>variable de</b> coordonn√©es <b>coords</b> sous la forme de <b>Vector2Int</b> indiquera les coordonn√©es d'un point sur la carte, et la variable <b>id</b> , son num√©ro de compte num√©rique, en l'utilisant, nous comparerons diff√©rents points sur la grille et v√©rifierons l'existence d'un point. <br><br>  La perm√©abilit√© du point sera indiqu√©e sous la forme de sa propri√©t√© <b>bool√©enne</b> , mais comme nous ne pouvons pas utiliser les <i>types de</i> donn√©es <i>convertibles</i> dans le syst√®me de t√¢ches, nous indiquerons sa perm√©abilit√© sous la forme d'un nombre <b>entier</b> , pour cela j'ai utilis√© une √©num√©ration simple <b>NodeType</b> , o√π: 0 n'est pas un point passable, et 1 est passable. <br><br><div class="spoiler">  <b class="spoiler_title">NodeType et Node</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> enum NodeType { NonWalkable = <span class="hljs-number"><span class="hljs-number">0</span></span>, Walkable = <span class="hljs-number"><span class="hljs-number">1</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct Node { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> int id; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2 position; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2Int coords; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> int nodeType; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> bool isWalkable { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeType == (int)NodeType.Walkable;} } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Node(int id, Vector2 position, Vector2Int coords, NodeType type) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.id = id; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.position = position; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.coords = coords; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeType = (int)type; } }</code> </pre> <br></div></div><br>  De plus, pour la commodit√© de travailler avec un point, je surchargerai la m√©thode <b>Equals</b> pour faciliter la comparaison des points et compl√©ter la m√©thode de v√©rification de l'existence d'un point. <br><br><div class="spoiler">  <b class="spoiler_title">Noeud</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct Node { <span class="hljs-comment"><span class="hljs-comment">/*... ‚Ä¶*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> bool Equals(object obj) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obj <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Node) { Node other = (Node)obj; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.id == other.id; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> base.Equals(obj); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> implicit operator bool(Node node) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> node.id &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; } }</code> </pre> <br></div></div><br>  √âtant donn√© que le num√©ro d' <b>identification</b> du point sur la grille commencera par 1 unit√©, je v√©rifierai l'existence du point comme condition que son <b>identifiant soit</b> sup√©rieur √† 0. <br><br>  Allez dans la classe <b>Map</b> o√π nous allons tout pr√©parer pour cr√©er une carte. <br>  Nous avons d√©j√† une v√©rification pour changer les param√®tres de la carte, maintenant nous devons d√©terminer comment le processus de construction de la grille sera ex√©cut√©.  Pour ce faire, cr√©ez une nouvelle variable et plusieurs m√©thodes. <br><br><div class="spoiler">  <b class="spoiler_title">La carte</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*... ‚Ä¶*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> bool rebuilding { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Rebuild() {} <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnRebuildStart() {} <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnRebuildFinish() {} <span class="hljs-comment"><span class="hljs-comment">/*... ‚Ä¶*/</span></span> }</code> </pre> <br></div></div><br>  La propri√©t√© de <b>reconstruction</b> indiquera si le processus de <b>maillage</b> est en cours.  La m√©thode <b>Rebuild</b> collectera les donn√©es et les t√¢ches pour la construction de la grille, puis la m√©thode <b>OnRebuildStart</b> d√©marrera le processus de construction de la grille et la m√©thode <b>OnRebuildFinish</b> collectera les donn√©es des t√¢ches. <br><br>  <b>Modifions maintenant</b> un <b>peu la</b> m√©thode <b>UpdateChanges</b> pour que l'√©tat de la grille soit pris en compte. <br><br><div class="spoiler">  <b class="spoiler_title">La carte</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*... ‚Ä¶*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> bool rebuilding { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> UpdateChanges() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.rebuilding) { print(‚Äú  ...‚Äù); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.requireRebuild) { print(‚Äú  ,   !‚Äù); Rebuild(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.requireRebuild = CheckChanges(); } } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Rebuild() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.rebuilding) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; print(‚Äú !‚Äù); OnRebuildStart(); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnRebuildStart() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.rebuilding = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnRebuildFinish() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.rebuilding = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/*... ‚Ä¶*/</span></span> }</code> </pre> <br></div></div><br>  Comme vous pouvez le voir maintenant dans la m√©thode <b>UpdateChanges</b> , <b>il</b> y a une condition que lors de la construction de l'ancien maillage ne commence pas √† commencer √† en cr√©er un nouveau, et √©galement dans la m√©thode <b>Rebuild</b> , la premi√®re action v√©rifie si le processus de maillage est d√©j√† en cours. <br><br><h4>  R√©solution de probl√®mes </h4><br>  Maintenant, un peu sur le processus de construction d'une carte. <br>  Comme nous allons utiliser le syst√®me de t√¢ches et construire la grille en parall√®le pour construire la carte, j'ai utilis√© le type de la t√¢che <b>IJobParallelFor</b> , qui sera ex√©cut√©e un certain nombre de fois.  Afin de ne pas charger le processus de construction avec une seule t√¢che distincte, nous utiliserons le pool de t√¢ches regroup√©es dans un <b>JobHandle</b> . <br><br>  Le plus souvent, pour construire une grille, utilisez deux cycles imbriqu√©s l'un dans l'autre pour construire, par exemple, horizontalement et verticalement.  Dans cet exemple, nous allons √©galement construire la grille d'abord horizontalement puis verticalement.  Pour ce faire, nous calculons le nombre de points horizontaux et verticaux dans la m√©thode <b>Reconstruire</b> , puis dans la m√©thode <b>Reconstruire</b> , nous parcourons le cycle le long des points verticaux, et nous construirons des points horizontaux en parall√®le dans la t√¢che.  Pour mieux imaginer le processus de construction, regardez l'animation ci-dessous. <br><br><div class="spoiler">  <b class="spoiler_title">Maillage</b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/101/625/183/10162518305232afb889f9d8a45b70da.gif" alt="image"><br></div></div><br>  Le nombre de points verticaux indiquera le nombre de t√¢ches, √† son tour, chaque t√¢che ne construira des points que horizontalement, apr√®s avoir termin√© toutes les t√¢ches, les points sont additionn√©s dans une liste.  C'est pourquoi j'ai besoin d'utiliser une t√¢che comme <b>IJobParallelFor</b> pour passer <b>horizontalement</b> l'index du point sur la grille dans la m√©thode <b>Execute</b> . <br><br>  Et donc nous avons la structure de points, maintenant vous pouvez cr√©er la structure de la t√¢che <b>Job</b> et l'h√©riter de l'interface <b>IJobParallelFor</b> , tout est simple ici. <br><br><div class="spoiler">  <b class="spoiler_title">Job</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct Job : IJobParallelFor { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute(int index) {} }</code> </pre> <br></div></div><br>  Nous revenons √† la m√©thode de <b>reconstruction de la</b> classe <b>Map</b> , o√π nous effectuerons les calculs n√©cessaires pour la mesure de la grille. <br><br><div class="spoiler">  <b class="spoiler_title">La carte</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*... ...*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Rebuild() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.rebuilding) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; print(‚Äú !‚Äù); Vector2 mapSize = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.size - <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.offset * <span class="hljs-number"><span class="hljs-number">2</span></span>f; int horizontals = Mathf.RoundToInt(mapSize.x / <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize); int verticals = Mathf.RoundToInt(mapSize.y / <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (horizontals &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { OnRebuildFinish(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } Vector2 center = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.position; Vector2 origin = center - (mapSize / <span class="hljs-number"><span class="hljs-number">2</span></span>f); OnRebuildStart(); } <span class="hljs-comment"><span class="hljs-comment">/*... ...*/</span></span> }</code> </pre> <br></div></div><br>  Dans la m√©thode <b>Rebuild</b> , nous calculons la taille exacte de la carte <b>mapSize</b> , en tenant compte de l'indentation, puis dans les <b>verticales</b> nous √©crivons le nombre de points verticalement, et en <b>horizontal le</b> nombre de points horizontalement.  Si le nombre de points verticaux est √©gal √† 0, nous arr√™tons de construire la carte et appelons la m√©thode <b>OnRebuildFinish</b> pour terminer le processus.  La variable d' <b>origine</b> indiquera l'endroit √† partir duquel nous commencerons √† construire la grille - dans l'exemple, il s'agit du point inf√©rieur gauche sur la carte. <br><br>  Vous pouvez maintenant acc√©der aux t√¢ches elles-m√™mes et les remplir de donn√©es. <br>  Lors de la construction de la grille, la t√¢che aura besoin d'un tableau <b>NativeArray</b> o√π nous <b>placerons</b> les points, √©galement puisque nous avons des obstacles sur la carte, nous devrons √©galement les passer √† la t√¢che, pour cela nous utiliserons un autre tableau <b>NativeArray</b> , puis nous aurons besoin de la taille des points dans le probl√®me , la position initiale √† partir de laquelle nous allons construire les points, ainsi que les coordonn√©es initiales de la s√©rie. <br><br><div class="spoiler">  <b class="spoiler_title">Job</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct Job : IJobParallelFor { [WriteOnly] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> NativeArray&lt;Node&gt; array; [ReadOnly] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> NativeArray&lt;Rect&gt; bounds; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> float nodeSize; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2 startPos; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2Int startCoords; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Execute(int index) {} }</code> </pre> <br></div></div><br>  J'ai marqu√© le tableau de points avec l'attribut <b>WriteOnly,</b> car dans la t√¢che, il ne sera n√©cessaire que d '¬´ <i>√©crire</i> ¬ª les points re√ßus dans le tableau, au contraire, le tableau des <b>limites d'</b> obstacles <b>est</b> marqu√© avec l'attribut <b>ReadOnly</b> car dans la t√¢che, nous ne ¬´ <i>lirons</i> ¬ª que les donn√©es de ce tableau. <br><br>  Eh bien, pour l'instant, proc√©dons au calcul des points eux-m√™mes plus tard. <br><br>  Revenons maintenant √† la classe <b>Map</b> , o√π nous d√©signons toutes les variables impliqu√©es dans les t√¢ches. <br>  Ici, tout d'abord, nous avons besoin d'une <b>poign√©e de</b> t√¢che globale, d'un tableau d'obstacles sous la forme d'un <b>tableau natif</b> , d'une liste de t√¢ches qui contiendra tous les points re√ßus sur la grille et du <b>dictionnaire</b> avec toutes les coordonn√©es et les points sur la carte, de sorte qu'il serait plus pratique de les rechercher plus tard. <br><br><div class="spoiler">  <b class="spoiler_title">La carte</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*... ...*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> JobHandle handle; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> NativeArray&lt;Rect&gt; bounds; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> HashSet&lt;NativeArray&lt;Node&gt;&gt; jobs = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashSet&lt;NativeArray&lt;Node&gt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Dictionary&lt;Vector2Int, Node&gt; nodes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;Vector2Int, Node&gt;(); <span class="hljs-comment"><span class="hljs-comment">/*... ...*/</span></span> }</code> </pre> <br></div></div><br>  Maintenant, nous revenons √† la m√©thode <b>Rebuild</b> et continuons √† construire la grille. <br>  Tout d'abord, initialisez le tableau des <b>limites</b> des obstacles pour le passer √† la t√¢che. <br><br><div class="spoiler">  <b class="spoiler_title">Reconstruire</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Rebuild() { <span class="hljs-comment"><span class="hljs-comment">/*... ...*/</span></span> Vector2 center = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.position; Vector2 origin = center - (mapSize / <span class="hljs-number"><span class="hljs-number">2</span></span>f); int count = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.obstacles.Count; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bounds = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Rect&gt;(count, Allocator.TempJob, NativeArrayOptions.UninitializedMemory); } OnRebuildStart(); }</code> </pre> <br></div></div><br>  Ici, nous cr√©ons une instance de <b>NativeArray</b> via un nouveau constructeur avec trois param√®tres.  J'ai examin√© les deux premiers param√®tres dans un article pr√©c√©dent, mais le troisi√®me param√®tre nous aidera √† gagner un peu de temps en cr√©ant un tableau.  Le fait est que nous allons √©crire des donn√©es dans le tableau imm√©diatement apr√®s sa cr√©ation, ce qui signifie que nous n'avons pas besoin de nous assurer qu'elles sont effac√©es.  Ce param√®tre est utile pour <b>NativeArray</b> qui ne sera utilis√© qu'en mode <i>lecture</i> dans la t√¢che. <br><br>  Et donc, nous remplissons le tableau de <b>limites</b> avec des donn√©es. <br><br><div class="spoiler">  <b class="spoiler_title">Reconstruire</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Rebuild() { <span class="hljs-comment"><span class="hljs-comment">/*... ...*/</span></span> Vector2 center = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.position; Vector2 origin = center - (mapSize / <span class="hljs-number"><span class="hljs-number">2</span></span>f); int count = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.obstacles.Count; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bounds = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Rect&gt;(count, Allocator.TempJob, NativeArrayOptions.UninitializedMemory); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; count; i++) { Obstacle obs = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.obstacles[i]; Vector2 position = obs.position; Rect rect = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Rect(Vector2.zero, obs.size); rect.center = position; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bounds[i] = rect; } } OnRebuildStart(); }</code> </pre> <br></div></div><br>  Nous pouvons maintenant passer √† la cr√©ation de t√¢ches, pour cela nous allons parcourir un cycle √† travers toutes les lignes verticales de la grille. <br><br><div class="spoiler">  <b class="spoiler_title">Reconstruire</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Rebuild() { <span class="hljs-comment"><span class="hljs-comment">/*... ...*/</span></span> Vector2 center = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.position; Vector2 origin = center - (mapSize / <span class="hljs-number"><span class="hljs-number">2</span></span>f); int count = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.obstacles.Count; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bounds = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Rect&gt;(count, Allocator.TempJob, NativeArrayOptions.UninitializedMemory); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; count; i++) { Obstacle obs = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.obstacles[i]; Vector2 position = obs.position; Rect rect = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Rect(Vector2.zero, obs.size); rect.center = position; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bounds[i] = rect; } } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; verticals; i++) { float xPos = origin.x; float yPos = origin.y + (i * <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize) + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize / <span class="hljs-number"><span class="hljs-number">2</span></span>f; } OnRebuildStart(); }</code> </pre> <br></div></div><br>  Pour commencer, dans <b>xPos</b> et <b>yPos,</b> nous obtenons la position horizontale initiale de la s√©rie. <br><br><div class="spoiler">  <b class="spoiler_title">Reconstruire</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Rebuild() { <span class="hljs-comment"><span class="hljs-comment">/*... ...*/</span></span> Vector2 center = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.position; Vector2 origin = center - (mapSize / <span class="hljs-number"><span class="hljs-number">2</span></span>f); int count = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.obstacles.Count; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bounds = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Rect&gt;(count, Allocator.TempJob, NativeArrayOptions.UninitializedMemory); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; count; i++) { Obstacle obs = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.obstacles[i]; Vector2 position = obs.position; Rect rect = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Rect(Vector2.zero, obs.size); rect.center = position; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bounds[i] = rect; } } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; verticals; i++) { float xPos = origin.x; float yPos = origin.y + (i * <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize) + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize / <span class="hljs-number"><span class="hljs-number">2</span></span>f; NativeArray&lt;Node&gt; array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Node&gt;(horizontals, Allocator.Persistent); Job job = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Job(); job.startCoords = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2Int(i * horizontals, i); job.startPos = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(xPos, yPos); job.nodeSize = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize; job.bounds = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bounds; job.array = array; } OnRebuildStart(); }</code> </pre> <br></div></div><br>  Ensuite, nous cr√©ons un tableau <b>NativeArray</b> simple o√π les points de la t√¢che seront plac√©s, ici pour le tableau de <b>tableau,</b> vous devez sp√©cifier le nombre de points qui seront cr√©√©s horizontalement et le type d'allocation <b>Persistant</b> , car la t√¢che peut prendre plus d'une image. <br>  Apr√®s cela, cr√©ez l'instance de t√¢che <b>Job</b> elle-m√™me, placez les coordonn√©es initiales de la s√©rie <b>startCoords</b> , la position initiale de la s√©rie <b>startPos</b> , la taille des points <b>nodeSize</b> , le tableau de <b>limites</b> des obstacles et le tableau de points lui-m√™me √† la fin. <br>  Il ne reste plus qu'√† mettre la t√¢che en <b>poign√©e</b> et la liste globale des t√¢ches. <br><br><div class="spoiler">  <b class="spoiler_title">Reconstruire</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Rebuild() { <span class="hljs-comment"><span class="hljs-comment">/*... ...*/</span></span> Vector2 center = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.position; Vector2 origin = center - (mapSize / <span class="hljs-number"><span class="hljs-number">2</span></span>f); int count = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.obstacles.Count; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bounds = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Rect&gt;(count, Allocator.TempJob, NativeArrayOptions.UninitializedMemory); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; count; i++) { Obstacle obs = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.obstacles[i]; Vector2 position = obs.position; Rect rect = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Rect(Vector2.zero, obs.size); rect.center = position; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bounds[i] = rect; } } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; verticals; i++) { float xPos = origin.x; float yPos = origin.y + (i * <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize) + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize / <span class="hljs-number"><span class="hljs-number">2</span></span>f; NativeArray&lt;Node&gt; array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NativeArray&lt;Node&gt;(horizontals, Allocator.Persistent); Job job = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Job(); job.startCoords = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2Int(i * horizontals, i); job.startPos = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(xPos, yPos); job.nodeSize = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize; job.bounds = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bounds; job.array = array; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handle = job.Schedule(horizontals, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handle); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.jobs.Add(array); } OnRebuildStart(); }</code> </pre> <br></div></div><br>  C'est fait.  Nous avons une liste de t√¢ches et leur <b>handle</b> commun, maintenant nous pouvons ex√©cuter ce <b>handle en</b> appelant sa m√©thode <b>Complete</b> dans la m√©thode <b>OnRebuildStart</b> . <br><br><div class="spoiler">  <b class="spoiler_title">Onrebuildstart</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnRebuildStart() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.rebuilding = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handle.Complete(); }</code> </pre> <br></div></div><br>  √âtant donn√© que la variable de <b>reconstruction</b> indiquera que le processus de <b>maillage</b> est en cours, la m√©thode <b>UpdateChanges elle-m√™me</b> doit √©galement sp√©cifier la condition √† laquelle ce processus se terminera √† l'aide de <b>handle</b> et de sa propri√©t√© <b>IsCompleted</b> . <br><br><div class="spoiler">  <b class="spoiler_title">Mises √† jour</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> UpdateChanges() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.rebuilding) { print(‚Äú  ...‚Äù); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handle.IsCompleted) OnRebuildFinish(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.requireRebuild) { print(‚Äú  ,   !‚Äù); Rebuild(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.requireRebuild = CheckChanges(); } } }</code> </pre> <br></div></div><br>  Apr√®s avoir termin√© les t√¢ches, la m√©thode <b>OnRebuildFinish</b> sera appel√©e o√π nous rassemblerons d√©j√† les points re√ßus dans une liste de <b>dictionnaires</b> g√©n√©rale, et surtout, pour effacer les ressources occup√©es. <br><br><div class="spoiler">  <b class="spoiler_title">OnRebuildFinish</b> <div class="spoiler_text"><pre> <code class="actionscript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnRebuildFinish() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodes.Clear(); foreach (NativeArray&lt;Node&gt; array <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.jobs) { foreach (Node node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> array) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodes.Add(node.coords, node); array.Dispose(); } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.jobs.Clear(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bounds.IsCreated) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bounds.Dispose(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.requireRebuild = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.rebuilding = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tout d'abord, nous effa√ßons le dictionnaire </font><font style="vertical-align: inherit;">de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n≈ìuds</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> des points pr√©c√©dents, puis utilisons la </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">boucle foreach pour</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> trier tous les points que nous avons re√ßus des t√¢ches et les mettons dans le dictionnaire de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n≈ìuds</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , o√π la cl√© est les coordonn√©es ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PAS la position</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> !) Du point, et la valeur est le point lui-m√™me. </font><font style="vertical-align: inherit;">Avec l'aide de ce dictionnaire, il nous sera plus facile de rechercher des points voisins sur la carte. </font><font style="vertical-align: inherit;">Apr√®s le remplissage, nous effa√ßons le tableau </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tableau</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √† l'aide de la m√©thode </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dispose</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et √† la fin, nous effa√ßons la liste des t√¢ches de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">travaux</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> elle-m√™me </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous devrez √©galement effacer le tableau des </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">limites</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> des obstacles </font><font style="vertical-align: inherit;">s'il a √©t√© cr√©√© pr√©c√©demment. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apr√®s toutes ces actions, nous obtenons une liste de tous les points sur la carte et maintenant vous pouvez les dessiner sur la sc√®ne.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quelque chose comme √ßa</font></font></b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/65f/2d0/5a8/65f2d05a86a6a508900fcf321d546089.gif" alt="image"><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour ce faire, dans la classe </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Map</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font><font style="vertical-align: inherit;">cr√©ez la m√©thode </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OnDrawGizmos</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> o√π nous allons dessiner les points.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La carte</font></font></b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*... ‚Ä¶*/</span></span> #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> UNITY_EDITOR <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnDrawGizmos() {} #endif }</code> </pre> <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Maintenant, dans la boucle, nous dessinons chaque point. </font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La carte</font></font></b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*... ‚Ä¶*/</span></span> #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> UNITY_EDITOR <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnDrawGizmos() { foreach (Node node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodes.Values) { Gizmos.DrawWireSphere(node.position, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize / <span class="hljs-number"><span class="hljs-number">10</span></span>f); } } #endif }</code> </pre> <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Apr√®s toutes ces actions, notre carte semble en quelque sorte ennuyeuse, afin d'avoir vraiment une grille, vous avez besoin que les points soient connect√©s les uns aux autres. </font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mesh</font></font></b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/460/01d/f10/46001df105fcb2bd9fb90ef382888f26.gif" alt="image"><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour rechercher des points voisins, nous avons juste besoin de trouver le point souhait√© par ses coordonn√©es dans 8 directions, donc dans la classe </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Map</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , nous allons </font><font style="vertical-align: inherit;">cr√©er un simple tableau statique de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">directions</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Directions </font><font style="vertical-align: inherit;">et une m√©thode de recherche de cellules par ses coordonn√©es </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GetNode</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La carte</font></font></b> <div class="spoiler_text"><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obstacle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> readonly Vector2Int[] Directions = { Vector2Int.up, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2Int(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), Vector2Int.right, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2Int(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>), Vector2Int.down, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2Int(<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>), Vector2Int.left, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2Int(<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), }; <span class="hljs-comment"><span class="hljs-comment">/*... ‚Ä¶*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Node GetNode(Vector2Int coords) { Node result = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>(Node); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { result = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodes[coords]; } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> {} <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> UNITY_EDITOR <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnDrawGizmos() {} #endif }</code> </pre> <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La m√©thode </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GetNode</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> renverra un point par coordonn√©es de la liste des </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n≈ìuds</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , mais vous devez le faire avec pr√©caution, car si les coordonn√©es </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vector2Int</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sont incorrectes, une erreur se produira, nous utilisons donc ici le </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bloc try</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bypass exception </font><font style="vertical-align: inherit;">, qui aidera √† contourner l'exception et √† ne pas " </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bloquer</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> " l'application enti√®re avec une erreur. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ensuite, nous allons parcourir le cycle dans toutes les directions et essayer de trouver des points voisins dans la m√©thode </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OnDrawGizmos</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , et surtout, n'oubliez pas de consid√©rer la perm√©abilit√© du point.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ondrawgizmos</font></font></b> <div class="spoiler_text"><pre> <code class="actionscript hljs"> #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> UNITY_EDITOR <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnDrawGizmos() { Color c = Gizmos.color; foreach (Node node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodes.Values) { Color newColor = Color.white; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node.isWalkable) newColor = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color32(<span class="hljs-number"><span class="hljs-number">153</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">51</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> newColor = Color.red; Gizmos.color = newColor; Gizmos.DrawWireSphere(node.position, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodeSize / <span class="hljs-number"><span class="hljs-number">10</span></span>f); newColor = Color.green; Gizmos.color = newColor; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node.isWalkable) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; Directions.Length; i++) { Vector2Int coords = node.coords + Directions[i]; Node connection = GetNode(coords); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (connection) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (connection.isWalkable) Gizmos.DrawLine(node.position, connection.position); } } } } Gizmos.color = c; } #endif</code> </pre> <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vous pouvez maintenant d√©marrer le jeu en toute s√©curit√© et voir ce qui s'est pass√©. </font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Carte dynamique</font></font></b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/302/3ae/4e3/3023ae4e31ba9b2f888c27c4a9144ab7.gif" alt="image"><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans cet exemple, nous avons construit uniquement le graphique lui-m√™me √† l'aide de t√¢ches, mais c'est ce qui s'est produit apr√®s avoir viss√© sur le syst√®me l'algorithme </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A *</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lui </font><font style="vertical-align: inherit;">- </font><font style="vertical-align: inherit;">m√™me </font><font style="vertical-align: inherit;">, qui utilise √©galement le </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">syst√®me Job</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour trouver le chemin, la </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">source √† la fin de l'article</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Recherche de carte et de chemin</font></font></b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/b2a/769/46c/b2a76946c68d7af5dc30d3226e27b5a1.gif" alt="image"><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous pouvez donc utiliser le nouveau syst√®me de t√¢ches pour vos objectifs et cr√©er des syst√®mes int√©ressants sans trop d'effort. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme dans l'article pr√©c√©dent, le syst√®me de t√¢ches est utilis√© sans </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ECS</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , mais si vous utilisez ce syst√®me en conjonction avec </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ECS</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , vous pouvez obtenir des r√©sultats tout simplement incroyables en termes de gains de performances. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bonne chance</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ! </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Source du projet Path Finder</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr423601/">https://habr.com/ru/post/fr423601/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr423589/index.html">Comment nous avons choisi TTS pour les sons d'exemple dans le dictionnaire</a></li>
<li><a href="../fr423591/index.html">De vieilles chansons sur l'essentiel. Java et requ√™tes sortantes</a></li>
<li><a href="../fr423593/index.html">Google annonce un concours d'attaques contre les algorithmes de vision industrielle</a></li>
<li><a href="../fr423595/index.html">Frango Anomaly, Interchange</a></li>
<li><a href="../fr423597/index.html">Comment et quels clusters peuvent √™tre allou√©s dans la base de clients</a></li>
<li><a href="../fr423603/index.html">RxSwift partie 1</a></li>
<li><a href="../fr423607/index.html">Linus Torvalds abandonne le style dur et prend du temps</a></li>
<li><a href="../fr423609/index.html">O√π vont les sites Web apr√®s la mort? Exp√©rience personnelle</a></li>
<li><a href="../fr423611/index.html">Paiement en un clic - bon ou mauvais?</a></li>
<li><a href="../fr423615/index.html">Comp√©tences professionnelles exig√©es des sp√©cialistes UX (tranche 2018)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>