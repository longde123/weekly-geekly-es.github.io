<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌐 🤹🏻 👍🏿 Event Generation, CQRS und Laravel 🤰🏾 🚴🏼 👌🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die Übersetzung des Artikels wurde für Studenten des Fachkurses "Framework Laravel" vorbereitet. 
 



 Einführung 
 Dieser Artikel befasst sich mit d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Event Generation, CQRS und Laravel</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/461899/">  <i>Die Übersetzung des Artikels wurde für Studenten des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fachkurses "Framework Laravel"</a> vorbereitet.</i> <i><br></i> <br><img src="https://habrastorage.org/webt/h8/4u/y5/h84uy5i5spnt3rdmpaiw2aynd0s.png"><br><br><hr><br><h2>  Einführung </h2><br>  Dieser Artikel befasst sich mit den Grundlagen der Erstellung von Event-CQRS-Systemen in der PHP-Sprache und im Laravel-Framework.  Es wird davon ausgegangen, dass Sie mit dem Entwicklungsschema über den Befehlsbus vertraut sind und eine Vorstellung von Ereignissen haben (insbesondere die Veröffentlichung von Ereignissen für eine Reihe von Listenern).  Um dieses Wissen aufzufrischen, können Sie den Laracasts-Dienst verwenden.  Darüber hinaus wird davon ausgegangen, dass Sie das CQRS-Prinzip genau kennen.  Wenn nicht, empfehle ich dringend, zwei Vorträge <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">anzuhören</a> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mathias Verraes Workshop zur Ereignisgenerierung</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Greg Youngs CQRS und Ereignisgenerierung</a> . <br><a name="habracut"></a><br>  Verwenden Sie den hier angegebenen Code nicht in Ihren Projekten!  Es ist eine Lernplattform zum Verständnis der Ideen hinter CQRS.  Dieser Code kann nicht als zuverlässig bezeichnet werden, er ist schlecht getestet, und außerdem programmiere ich selten Schnittstellen, sodass es viel schwieriger sein wird, einzelne Teile des Codes zu ändern.  Ein viel besseres Beispiel für ein CQRS-Paket, das Sie verwenden können, ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Broadway, entwickelt von Qandidate Lab</a> .  Dies ist sauberer, lose gekoppelter Code. Einige Abstraktionen machen jedoch nicht ganz klar, ob Sie noch nie auf Ereignissysteme gestoßen sind. <br><br>  Und das letzte - mein Code ist mit Ereignissen und dem Laravel-Befehlsbus verbunden.  Ich wollte sehen, wie der Code in Laravel aussehen würde (ich verwende dieses Framework normalerweise für Projekte kleiner Agenturen). Rückblickend denke ich jedoch, dass ich meine eigenen Implementierungen erstellen sollte.  Ich hoffe, dass mein Code auch für diejenigen klar ist, die keine Frameworks verwenden. <br><br>  Auf github befindet sich der Code unter <a href="">https://github.com/scazz/cqrs-tutorial.git</a> , und in unserem Handbuch werden wir seine Komponenten zur Erhöhung der Logik betrachten. <br><br>  Wir werden ein Erstregistrierungssystem für eine Surfschule erstellen.  Mit seiner Hilfe können sich Schulkunden für Klassen anmelden.  Für den Aufnahmevorgang formulieren wir folgende Regeln: <br><br><ul><li>  Jede Lektion muss mindestens einen Kunden haben ... </li><li>  ... aber nicht mehr als drei. </li></ul><br>  Eine der beeindruckendsten Funktionen ereignisbasierter CQRS-Systeme ist die Erstellung von Lesemodellen, die für jede vom System benötigte Metrik spezifisch sind.  Beispiele für die Projektion von Lesemodellen finden Sie in ElasticSearch. Greg Young hat in seinem Event Store eine themenorientierte Sprache für die Behandlung komplexer Ereignisse implementiert.  Der Einfachheit halber wird unsere Leseprojektion jedoch eine Standard-SQL-Datenbank zur Verwendung mit Eloquent sein.  Als Ergebnis haben wir eine Tabelle für Klassen und eine für Kunden. <br><br>  Mit dem Konzept der Ereignisgenerierung können Sie Ereignisse auch offline verarbeiten.  In diesem Artikel werde ich mich jedoch (zur Vereinfachung) maximal an die „traditionellen“ Entwicklungsmodelle halten und unsere Leseprojektionen werden in Echtzeit aktualisiert, unmittelbar nachdem die Ereignisse im Repository gespeichert wurden. <br><br><h2>  Projekteinrichtung und erster Test </h2><br><pre><code class="plaintext hljs">git clone https://github.com/scazz/cqrs-tutorial</code> </pre> <br>  Erstellen Sie ein neues Laravel 5-Projekt <br><br><pre> <code class="plaintext hljs">$&gt; laravel new cqrs-tutorial</code> </pre> <br>  Und für den Anfang brauchen wir einen Test.  Wir werden den Integrationstest verwenden, der sicherstellt, dass die Registrierung des Kunden für Klassen dazu führt, dass die Lektion in unserem eloquenten Modell erstellt wird. <br><br>  Listing tests / CQRSTest.php: <br><br><pre> <code class="plaintext hljs">use Illuminate\Foundation\Bus\DispatchesCommands; class CQRSTest extends TestCase { use DispatchesCommands;</code> </pre><br><pre> <code class="bash hljs">/** *  ,   BookLesson       * @<span class="hljs-built_in"><span class="hljs-built_in">return</span></span> void */ public <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testFiringEventUpdatesReadModel</span></span></span></span>() { <span class="hljs-variable"><span class="hljs-variable">$testLessonId</span></span> = <span class="hljs-string"><span class="hljs-string">'123e4567-e89b-12d3-a456-426655440000'</span></span>; <span class="hljs-variable"><span class="hljs-variable">$clientName</span></span> = <span class="hljs-string"><span class="hljs-string">"George"</span></span>; <span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span> = new LessonId(<span class="hljs-variable"><span class="hljs-variable">$testLessonId</span></span>); <span class="hljs-variable"><span class="hljs-variable">$command</span></span> = new BookLesson(<span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span>, <span class="hljs-variable"><span class="hljs-variable">$clientName</span></span>); <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;dispatch(<span class="hljs-variable"><span class="hljs-variable">$command</span></span>); <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;assertNotNull(Lesson::find(<span class="hljs-variable"><span class="hljs-variable">$testLessonId</span></span>)); <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;assertEquals( Lesson::find(<span class="hljs-variable"><span class="hljs-variable">$testLessonId</span></span>)-&gt;clientName, <span class="hljs-variable"><span class="hljs-variable">$clientName</span></span> ); } }</code> </pre> <br>  Wir weisen die neue Aktivität einer ID zu, erstellen ein Team, um sich für eine neue Aktivität anzumelden, und weisen Laravel an, sie zu senden.  In der Lektionstabelle müssen wir einen neuen Datensatz erstellen, den wir mit dem Eloquent-Modell lesen können.  Wir brauchen eine Datenbank, also füllen Sie Ihre .env-Datei richtig aus. <br><br>  Jedes in unserem Ereignisspeicher aufgezeichnete Ereignis wird an die Wurzel des Aggregats angehängt, die wir einfach als Entität (Entität) bezeichnen - eine Abstraktion für Bildungszwecke sorgt nur für Verwirrung.  ID ist eine universelle eindeutige Kennung (UUID).  Dem Ereignisspeicher ist es egal, ob das Ereignis für die Lektion oder den Kunden gilt.  Er weiß nur, dass es mit einer ID verbunden ist. <br><br>  Basierend auf den beim Testen festgestellten Fehlern können wir fehlende Klassen erstellen.  Zuerst erstellen wir die LessonId-Klasse und dann den BookLesson-Befehl (machen Sie sich noch keine Gedanken über die Handler-Methode, führen Sie den Test einfach weiter aus).  Die Lesson-Klasse ist ein Lesemodell außerhalb des Lesson-Namespace.  Ein exklusives Lesemodell - die Logik des Themenbereichs wird hier niemals gespeichert.  Abschließend müssen wir eine Migration für die Lektionstabelle erstellen. <br><br>  Um die Klarheit des Codes zu gewährleisten, werde ich die Assertion Verification Library verwenden.  Es kann mit dem folgenden Befehl hinzugefügt werden: <br><br><pre> <code class="plaintext hljs">$&gt; composer require beberlei/assert</code> </pre> <br>  Betrachten Sie den Prozess, der mit diesem Befehl initiiert werden soll: <br><br><ol><li>  Validierung: Imperative Befehle können fehlschlagen, und Ereignisse sind bereits aufgetreten und sollten daher nicht fehlschlagen. </li><li>  Erstellen Sie ein neues LessonWasBooked-Ereignis (für eine Lektion angemeldet). </li><li>  Aktualisieren Sie den Aktivitätsstatus.  (Das Datensatzmodell muss den Status des Modells kennen, damit es eine Validierung durchführen kann.) </li><li>  Fügen Sie dieses Ereignis dem Stream nicht festgeschriebener Ereignisse hinzu, die im Aktivitätsdatensatzmodell gespeichert sind. </li><li>  Speichern Sie den Stream nicht festgeschriebener Ereignisse im Repository. </li><li>  Lösen Sie das LessonWasBooked-Ereignis global aus, um alle Leseprojektoren über die Aktualisierung der Lektionstabelle zu informieren. </li></ol><br>  Zuerst müssen Sie ein Aufzeichnungsmodell für die Lektion erstellen.  Wir werden die statische Factory-Methode <code>Lesson::bookClientOntoNewLesson()</code> .  Es generiert ein neues <code>LessonWasOpened</code> Ereignis (die Lektion ist geöffnet), wendet dieses Ereignis auf sich selbst an (legt nur seine ID fest) und fügt das neue Ereignis in Form von <code>DomainEventMessage</code> (das Ereignis plus einige Metadaten, die wir beim Speichern im Ereignisspeicher verwenden) zur Liste der nicht <code>DomainEventMessage</code> Ereignisse hinzu. <br><br>  Der Vorgang wird wiederholt, um dem Ereignis einen Client hinzuzufügen.  Beim Anwenden des <code>ClientWasBookedOntoLesson</code> Ereignisses (der Client wurde in der Lektion registriert) verfolgt das Aufzeichnungsmodell nicht die <code>ClientWasBookedOntoLesson</code> , sondern nur die Anzahl der registrierten Clients.  Datensatzmodelle müssen keine Kundennamen kennen, um die Konsistenz sicherzustellen. <br><br>  Die Methoden <code>applyLessonWasOpened</code> und <code>applyClientWasBookedOntoLesson</code> scheinen <code>applyClientWasBookedOntoLesson</code> etwas seltsam.  Wir werden sie später verwenden, wenn wir alte Ereignisse reproduzieren müssen, um den Status des Aufzeichnungsmodells zu bilden.  Es ist nicht einfach zu erklären, daher gebe ich einen Code, der Ihnen hilft, diesen Prozess zu verstehen.  Später werden wir den Code extrahieren, der nicht festgeschriebene Ereignisse verarbeitet und Domänenereignismeldungen generiert. <br><br><pre> <code class="bash hljs">app/School/Lesson/Lesson.php public <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> openLesson( LessonId <span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span> ) { /*      ,      ,       */ <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;apply( new LessonWasOpened( <span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span>) ); } protected <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> applyLessonWasOpened( LessonWasOpened <span class="hljs-variable"><span class="hljs-variable">$event</span></span> ) { <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;lessonId = <span class="hljs-variable"><span class="hljs-variable">$event</span></span>-&gt;getLessonId(); <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;numberOfClients = 0; } public <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> bookClient( <span class="hljs-variable"><span class="hljs-variable">$clientName</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;numberOfClients &gt;= 3) { throw new TooManyClientsAddedToLesson(); } <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;apply( new ClientBookedOntoLesson( <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;lessonId, <span class="hljs-variable"><span class="hljs-variable">$clientName</span></span>) ); } /** *       — *  ,       *      ,       , *      . */ protected <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> applyClientBookedOntoLesson( ClientBookedOntoLesson <span class="hljs-variable"><span class="hljs-variable">$event</span></span> ) { <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;numberOfClients++; }</code> </pre> <br>  Wir können die CQRS-Komponenten aus unserem Aufzeichnungsmodell extrahieren - Fragmente der Klasse, die an der Verarbeitung nicht festgeschriebener Ereignisse beteiligt sind.  Sie können die API auch für eine ereignisgenerierte Entität löschen, indem Sie eine sichere Funktion <code>apply()</code> erstellen, die das Ereignis akzeptiert, die entsprechende Methode <code>applyEventName()</code> <code>DomainEventMessage</code> und der Liste der nicht <code>DomainEventMessage</code> Ereignisse ein neues <code>DomainEventMessage</code> Ereignis hinzufügt.  Die extrahierte Klasse ist ein Detail der CQRS-Implementierung und enthält keine Domänenlogik. Daher können wir einen neuen Namespace erstellen: App \ CQRS: <br><br>  <i><code>app/CQRS/EventSourcedEntity.php</code> die Code- <code>app/CQRS/EventSourcedEntity.php</code></i> <i><br></i>  <i>Damit der Code funktioniert, müssen wir die <code>DomainEventMessage</code> Klasse hinzufügen, bei der es sich um ein einfaches DTO handelt. Sie finden sie in <code>app/CQRS/DomainEventMessage.php</code></i> <br><br>  So haben wir ein System, das Ereignisse für jeden Schreibversuch generiert und Ereignisse verwendet, um die Änderungen aufzuzeichnen, die erforderlich sind, um Invarianten zu verhindern.  Der nächste Schritt besteht darin, diese Ereignisse im Store (EventStore) zu speichern.  Zunächst muss dieses Ereignis-Repository erstellt werden.  Zur Vereinfachung verwenden wir das Eloquent-Modell, eine einfache SQL-Tabelle mit den folgenden Feldern: * <code>UUID</code> (um zu wissen, auf welche Entität das Ereignis <code>event_payload</code> ) * <code>event_payload</code> (serialisierte Nachricht, die alles enthält, was zum <code>event_payload</code> des Ereignisses erforderlich ist) * <code>event_payload</code> - Zeitstempel, um zu wissen, wann das Ereignis <code>event_payload</code> passiert ist.  Wenn Sie den Code sorgfältig prüfen, werden Sie feststellen, dass ich zwei Befehle erstellt habe - zum Erstellen und Zerstören unserer Ereignisspeichertabelle: <br><br><ul><li>  php artisan eloquenteventstore: create (App \ CQRS \ EloquentEventStore \ CreateEloquentEventStore) </li><li>  php artisan eloquenteventstore: drop (App \ CQRS \ EloquentEventStore \ DropEloquentEventStore) (vergessen Sie nicht, sie zu App \ Console \ Kernel.php hinzuzufügen, damit sie geladen werden). </li></ul><br>  Es gibt zwei sehr gute Gründe, SQL nicht als Ereignisspeicher zu verwenden: Es implementiert nicht das Nur-Anhängen-Modell (nur das Hinzufügen von Daten, Ereignisse müssen unveränderlich sein) und auch, weil SQL keine ideale Abfragesprache für temporäre Datenbanken ist.  Wir programmieren die Schnittstelle, um den Austausch des Ereignisspeichers in nachfolgenden Veröffentlichungen zu erleichtern. <br><br>  Verwenden Sie das Repository, um Ereignisse zu speichern.  Immer wenn <code>save()</code> für das Aufzeichnungsmodell aufgerufen wird, speichern wir die Liste der nicht festgeschriebenen Ereignisse im Ereignisspeicher.  Zum Speichern von Ereignissen benötigen wir einen Mechanismus für deren Serialisierung und Deserialisierung.  Erstellen Sie dazu einen Serializer.  Wir benötigen Metadaten wie eine Ereignisklasse (z. B. <code>App\School\Lesson\Events\LessonWasOpened</code> ) und eine Ereignisnutzlast (Daten, die zum Rekonstruieren eines Ereignisses benötigt werden). <br><br>  All dies wird im JSON-Format codiert und dann zusammen mit der UUID der Entität und dem Zeitstempel in unsere Datenbank geschrieben.  Wir möchten unsere Lesemodelle nach der Erfassung von Ereignissen aktualisieren, damit das Repository jedes Ereignis nach dem Speichern auslöst.  Der Serializer ist für das Schreiben der Ereignisklasse verantwortlich, während das Ereignis für die Serialisierung seiner Nutzdaten verantwortlich ist.  Ein vollständig serialisiertes Ereignis sieht ungefähr so ​​aus: <br><br><pre> <code class="plaintext hljs"> { class: "App\\School\\Lesson\\Events\\", event: $event-&gt;serialize() }</code> </pre> <br>  Da für alle Ereignisse eine Serialisierungs- und Deserialisierungsmethode erforderlich ist, können wir eine <code>SerializableEvent</code> Schnittstelle erstellen und einen Hinweis auf den Typ des erwarteten Werts hinzufügen.  Aktualisieren Sie unser <code>LessonWasOpened</code> Ereignis: <br><br><pre> <code class="bash hljs">app/School/Lesson/Events/LessonWasOpened.php class LessonWasOpened implements SerializableEvent { public <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">serialize</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> array( <span class="hljs-string"><span class="hljs-string">'lessonId'</span></span>=&gt; (string) <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;getLessonId() ); } }</code> </pre> <br>  Erstellen Sie ein <code>LessonRepository</code> Repository.  Wir können die CQRS-Kernkomponenten später umgestalten und extrahieren. <br><br> <code>app/School/Lesson/LessonRepository.php</code> <br> <pre> <code class="plaintext hljs">eventStoreRepository = new EloquentEventStoreRepository( new EventSerializer() ); } public function save(Lesson $lesson) { /** @var DomainEventMessage $domainEventMessage */ foreach( $lesson-&gt;getUncommittedDomainEvents() as $domainEventMessage ) { $this-&gt;eventStoreRepository-&gt;append( $domainEventMessage-&gt;getId(), $domainEventMessage-&gt;getEvent(), $domainEventMessage-&gt;getRecordedAt() ); Event::fire($domainEventMessage-&gt;getEvent()); } } }</code> </pre> <br>  Wenn Sie den Integrationstest erneut <code>domain_events</code> und dann die SQL-Tabelle <code>domain_events</code> überprüfen, sollten zwei Ereignisse in der Datenbank <code>domain_events</code> werden. <br><br>  Unser letzter Schritt zum erfolgreichen Bestehen des Tests besteht darin, die Sendeereignisse abzuhören und die Projektion des Unterrichtslesemodells zu aktualisieren.  Lektionssendungsereignisse werden vom <code>LessonProjector</code> abgefangen, der die erforderlichen Änderungen an <code>LessonProjection</code> ( <code>LessonProjection</code> Modelle der Lektionstabelle) <code>LessonProjection</code> : <br><br><pre> <code class="bash hljs"> app/School/Lesson/Projections/LessonProjector.php class LessonProjector { public <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> applyLessonWasOpened( LessonWasOpened <span class="hljs-variable"><span class="hljs-variable">$event</span></span> ) { <span class="hljs-variable"><span class="hljs-variable">$lessonProjection</span></span> = new LessonProjection(); <span class="hljs-variable"><span class="hljs-variable">$lessonProjection</span></span>-&gt;id = <span class="hljs-variable"><span class="hljs-variable">$event</span></span>-&gt;getLessonId(); <span class="hljs-variable"><span class="hljs-variable">$lessonProjection</span></span>-&gt;save(); } public <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> subscribe(Dispatcher <span class="hljs-variable"><span class="hljs-variable">$events</span></span>) { <span class="hljs-variable"><span class="hljs-variable">$fullClassName</span></span> = self::class; <span class="hljs-variable"><span class="hljs-variable">$events</span></span>-&gt;listen( LessonWasOpened::class, <span class="hljs-variable"><span class="hljs-variable">$fullClassName</span></span>.<span class="hljs-string"><span class="hljs-string">'@applyLessonWasOpened'</span></span>); } }  app/School/Lesson/Projections/LessonProjection.php class LessonProjection extends Model { public <span class="hljs-variable"><span class="hljs-variable">$timestamps</span></span> = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; protected <span class="hljs-variable"><span class="hljs-variable">$table</span></span> = <span class="hljs-string"><span class="hljs-string">"lessons"</span></span>; }</code> </pre> <br>  Wenn Sie den Test ausführen, sehen Sie, dass ein SQL-Fehler aufgetreten ist: <br><br><pre> <code class="plaintext hljs">Unknown column 'clientName' in 'field list'</code> </pre> <br>  Sobald wir eine Migration erstellen, um <code>clientName</code> zur Lektionstabelle hinzuzufügen, bestehen wir den Test erfolgreich.  Wir haben die Grundfunktionalität von CQRS implementiert: Teams erstellen Ereignisse, mit denen Lesemodelle generiert werden. <br><br><h2>  Verbesserung des Lesemodells mit Links </h2><br>  Wir haben einen bedeutenden Meilenstein erreicht, aber das ist noch nicht alles!  Bisher unterstützt das Lesemodell nur einen Client (wir haben drei in unseren Domänenregeln angegeben).  Die Änderungen, die wir am <code>ClientBookedOntoLesson</code> <code>ClientProjector</code> , sind recht einfach: Wir erstellen lediglich ein Client-Projektionsmodell und einen <code>ClientProjector</code> , der das <code>ClientBookedOntoLesson</code> Ereignis <code>ClientBookedOntoLesson</code> .  Zunächst aktualisieren wir unseren Test, um die Änderungen widerzuspiegeln, die wir in unserem Lesemodell sehen möchten: <br><br><pre> <code class="bash hljs">tests/CQRSTest.php public <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testFiringEventUpdatesReadModel</span></span></span></span>() { <span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span> = new LessonId( (string) \Rhumsaa\Uuid\Uuid::uuid1() ); <span class="hljs-variable"><span class="hljs-variable">$clientName</span></span> = <span class="hljs-string"><span class="hljs-string">"George"</span></span>; <span class="hljs-variable"><span class="hljs-variable">$command</span></span> = new BookLesson(<span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span>, <span class="hljs-variable"><span class="hljs-variable">$clientName</span></span>); <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;dispatch(<span class="hljs-variable"><span class="hljs-variable">$command</span></span>); <span class="hljs-variable"><span class="hljs-variable">$lesson</span></span> = Lesson::find( (string) <span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span>); <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;assertEquals( <span class="hljs-variable"><span class="hljs-variable">$lesson</span></span>-&gt;id, (string) <span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span> ); <span class="hljs-variable"><span class="hljs-variable">$client</span></span> = <span class="hljs-variable"><span class="hljs-variable">$lesson</span></span>-&gt;clients()-&gt;first(); <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;assertEquals(<span class="hljs-variable"><span class="hljs-variable">$client</span></span>-&gt;name, <span class="hljs-variable"><span class="hljs-variable">$clientName</span></span>); }</code> </pre><br>  Dies ist eine klare Demonstration, wie einfach es ist, Lesemodelle zu ändern.  Bis auf das Ereignis-Repository bleibt alles unverändert.  Als Bonus erhalten wir bei Verwendung des Ereignissystems Daten für grundlegende Tests. Wenn Sie den Projektor des Lesemodells ändern, hören wir jedes Ereignis, das jemals in unserem System aufgetreten ist. <br><br>  Wir reproduzieren diese Ereignisse mit dem neuen Projektor, suchen nach Ausnahmen und vergleichen die Ergebnisse mit früheren Projektionen.  Nachdem das System einige Zeit funktioniert hat, haben wir eine ziemlich repräsentative Auswahl an Ereignissen zum Testen unserer Projektoren. <br><br>  Unser Aufzeichnungsmodell kann derzeit den aktuellen Status nicht laden.  Wenn wir der Lektion einen zweiten Client hinzufügen möchten, können wir einfach ein zweites ClientWasAddedToLesson-Ereignis erstellen, aber keinen Schutz gegen Invarianten bieten.  Zur besseren Übersichtlichkeit schlage ich vor, einen zweiten Test zu schreiben, der die Aufzeichnung von zwei Kunden pro Lektion simuliert. <br><br><pre> <code class="bash hljs">tests/CQRSTest.php public <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testLoadingWriteModel</span></span></span></span>() { <span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span> = new LessonId( (string) \Rhumsaa\Uuid\Uuid::uuid1() ); <span class="hljs-variable"><span class="hljs-variable">$clientName_1</span></span> = <span class="hljs-string"><span class="hljs-string">"George"</span></span>; <span class="hljs-variable"><span class="hljs-variable">$clientName_2</span></span> = <span class="hljs-string"><span class="hljs-string">"Fred"</span></span>; <span class="hljs-variable"><span class="hljs-variable">$command</span></span> = new BookLesson(<span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span>, <span class="hljs-variable"><span class="hljs-variable">$clientName_1</span></span>); <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;dispatch(<span class="hljs-variable"><span class="hljs-variable">$command</span></span>); <span class="hljs-variable"><span class="hljs-variable">$command</span></span> = new BookClientOntoLesson(<span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span>, <span class="hljs-variable"><span class="hljs-variable">$clientName_2</span></span>); <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;dispatch(<span class="hljs-variable"><span class="hljs-variable">$command</span></span>); <span class="hljs-variable"><span class="hljs-variable">$lesson</span></span> = Lesson::find( (string) <span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span> ); <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;assertClientCollectionContains(<span class="hljs-variable"><span class="hljs-variable">$lesson</span></span>-&gt;clients, <span class="hljs-variable"><span class="hljs-variable">$clientName_1</span></span>); <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;assertClientCollectionContains(<span class="hljs-variable"><span class="hljs-variable">$lesson</span></span>-&gt;clients, <span class="hljs-variable"><span class="hljs-variable">$clientName_2</span></span>); }</code> </pre> <br>  Für unser Aufzeichnungsmodell müssen wir eine Methode zum „Laden“ einer Entität implementieren, für die bereits Ereignisse im Ereignisspeicher gelten.  Wir können dies erreichen, indem wir jedes Ereignis wiedergeben, das sich auf die UUID der Entität bezieht.  Im Allgemeinen ist der Prozess wie folgt: <br><br><ol><li>  Wir erhalten alle relevanten Ereignismeldungen vom Ereignisspeicher. </li><li>  Für jede Nachricht erstellen wir das entsprechende Ereignis neu. </li><li>  Wir erstellen ein neues Entity-Record-Modell und spielen jedes Ereignis ab. </li></ol><br>  Im Moment <code>BookClientOntoLesson</code> unsere Tests Ausnahmen aus. <code>BookClientOntoLesson</code> erstellen wir zunächst den erforderlichen <code>BookClientOntoLesson</code> (registrieren Sie einen Client für die Lektion) und verwenden den <code>BookLesson</code> Befehl als Vorlage.  Die Handler-Methode sieht folgendermaßen aus: <br><br><pre> <code class="bash hljs"> app/School/Lesson/Commands/BookClientOntoLesson.php public <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> handle(LessonRepository <span class="hljs-variable"><span class="hljs-variable">$repository</span></span>) { /** @var Lesson <span class="hljs-variable"><span class="hljs-variable">$lesson</span></span> */ <span class="hljs-variable"><span class="hljs-variable">$lesson</span></span> = <span class="hljs-variable"><span class="hljs-variable">$repository</span></span>-&gt;load(<span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;lessonId); <span class="hljs-variable"><span class="hljs-variable">$lesson</span></span>-&gt;bookClient(<span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;clientName); <span class="hljs-variable"><span class="hljs-variable">$repository</span></span>-&gt;save(<span class="hljs-variable"><span class="hljs-variable">$lesson</span></span>); }      : app/School/Lesson/LessonRepository.php public <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> load(LessonId <span class="hljs-variable"><span class="hljs-variable">$id</span></span>) { <span class="hljs-variable"><span class="hljs-variable">$events</span></span> = <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;eventStoreRepository-&gt;load(<span class="hljs-variable"><span class="hljs-variable">$id</span></span>); <span class="hljs-variable"><span class="hljs-variable">$lesson</span></span> = new Lesson(); <span class="hljs-variable"><span class="hljs-variable">$lesson</span></span>-&gt;initializeState(<span class="hljs-variable"><span class="hljs-variable">$events</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> <span class="hljs-variable"><span class="hljs-variable">$lesson</span></span>; }</code> </pre> <br>  Die Repository-Ladefunktion gibt ein Array neu erstellter Ereignisse zurück.  Zu diesem Zweck findet sie zuerst Nachrichten zu Ereignissen im Repository und leitet sie dann an den <code>Serializer</code> , um jede Nachricht in ein Ereignis umzuwandeln.  <code>Serializer</code> erstellt Nachrichten aus Ereignissen, daher müssen wir die Methode <code>deserialize()</code> hinzufügen, um die inverse Transformation durchzuführen.  Denken Sie daran, dass der <code>Serializer</code> an jedes Ereignis übergeben wird, um die Ereignisdaten (z. B. den Clientnamen) zu serialisieren.  Wir werden dasselbe tun, um die inverse Transformation durchzuführen, während unsere <code>SerializableEvent</code> Schnittstelle mit der <code>deserialize()</code> -Methode aktualisiert werden muss.  Schauen wir uns den Code an, damit alles passt.  Zunächst die <code>EventStoreRepository</code> : <br><br><pre> <code class="bash hljs">app/CQRS/EloquentEventStore/EloquentEventStoreRepository.php public <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> load(<span class="hljs-variable"><span class="hljs-variable">$uuid</span></span>) { <span class="hljs-variable"><span class="hljs-variable">$eventMessages</span></span> = EloquentEventStoreModel::<span class="hljs-built_in"><span class="hljs-built_in">where</span></span>(<span class="hljs-string"><span class="hljs-string">'uuid'</span></span>, <span class="hljs-variable"><span class="hljs-variable">$uuid</span></span>)-&gt;get(); <span class="hljs-variable"><span class="hljs-variable">$events</span></span> = []; foreach(<span class="hljs-variable"><span class="hljs-variable">$eventMessages</span></span> as <span class="hljs-variable"><span class="hljs-variable">$eventMessage</span></span>) { /*       event_payload,        . */ <span class="hljs-variable"><span class="hljs-variable">$events</span></span>[] = <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;eventSerializer-&gt;deserialize( json_decode(<span class="hljs-variable"><span class="hljs-variable">$eventMessage</span></span>-&gt;event_payload)); } <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> <span class="hljs-variable"><span class="hljs-variable">$events</span></span>; }</code> </pre><br>  Verwenden der entsprechenden Deserialisierungsfunktion in <code>eventSerializer</code> : <br><br><pre> <code class="bash hljs">app/CQRS/Serializer/EventSerializer.php public <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> serialize( SerializableEvent <span class="hljs-variable"><span class="hljs-variable">$event</span></span> ) { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> array( <span class="hljs-string"><span class="hljs-string">'class'</span></span> =&gt; get_class(<span class="hljs-variable"><span class="hljs-variable">$event</span></span>), <span class="hljs-string"><span class="hljs-string">'payload'</span></span> =&gt; <span class="hljs-variable"><span class="hljs-variable">$event</span></span>-&gt;serialize() ); } public <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> deserialize( <span class="hljs-variable"><span class="hljs-variable">$serializedEvent</span></span> ) { <span class="hljs-variable"><span class="hljs-variable">$eventClass</span></span> = <span class="hljs-variable"><span class="hljs-variable">$serializedEvent</span></span>-&gt;class; <span class="hljs-variable"><span class="hljs-variable">$eventPayload</span></span> = <span class="hljs-variable"><span class="hljs-variable">$serializedEvent</span></span>-&gt;payload; <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> <span class="hljs-variable"><span class="hljs-variable">$eventClass</span></span>::deserialize(<span class="hljs-variable"><span class="hljs-variable">$eventPayload</span></span>); }</code> </pre> <br>  Abschließend verwenden wir die statische Factory-Methode <code>deserialize()</code> in <code>LessonWasOpened</code> (wir müssen diese Methode jedem Ereignis hinzufügen). <br><br><pre> <code class="bash hljs">app/School/Lesson/Events/LessonWasOpened.php public static <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> deserialize(<span class="hljs-variable"><span class="hljs-variable">$data</span></span>) { <span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span> = new LessonId(<span class="hljs-variable"><span class="hljs-variable">$data</span></span>-&gt;lessonId); <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> new self(<span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span>); }</code> </pre> <br>  Jetzt haben wir ein Array aller Ereignisse, die wir gerade relativ zu unserem Entity-Datensatzmodell reproduziert haben, um den Status in der <code>initializeState</code> Methode in <code>app/CQRS/EventSouredEntity.php</code> <br><br>  Führen Sie jetzt unseren Test aus.  Bingo! <br>  Tatsächlich haben wir derzeit keinen Test, um die Einhaltung unserer Domain-Regeln zu überprüfen. Schreiben wir ihn also: <br><br><pre> <code class="bash hljs">tests/CQRSTest.php public <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testMoreThan3ClientsCannotBeAddedToALesson</span></span></span></span>() { <span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span> = new LessonId( (string) \Rhumsaa\Uuid\Uuid::uuid1() ); <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;dispatch( new BookLesson(<span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span>, <span class="hljs-string"><span class="hljs-string">"bob"</span></span>) ); <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;dispatch( new BookClientOntoLesson(<span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span>, <span class="hljs-string"><span class="hljs-string">"george"</span></span>) ); <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;dispatch( new BookClientOntoLesson(<span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span>, <span class="hljs-string"><span class="hljs-string">"fred"</span></span>) ); <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;setExpectedException( TooManyClientsAddedToLesson::class ); <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;dispatch( new BookClientOntoLesson(<span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span>, <span class="hljs-string"><span class="hljs-string">"emma"</span></span>) ); }</code> </pre> <br>  Bitte beachten Sie, dass wir nur die <code>lessonId</code> benötigen. Dieser Test initialisiert den Status der Lektion bei jedem Befehl neu. <br><br>  Im Moment übertragen wir einfach manuell erstellte <code>UUID</code> , während wir sie in Wirklichkeit automatisch generieren möchten.  Ich werde das <code>Ramsy\UUID</code> Paket verwenden, also installieren wir es mit <code>composer</code> : <br><br><pre> <code class="plaintext hljs">$&gt; composer require ramsey/uuid</code> </pre> <br>  Aktualisieren Sie jetzt unsere Tests, um das neue Paket zu verwenden: <br><br><pre> <code class="bash hljs">tests/CQRSTest.php public <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testEntityCreationWithUUIDGenerator</span></span></span></span>() { <span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span> = new LessonId( (string) \Rhumsaa\Uuid\Uuid::uuid1() ); <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;dispatch( new BookLesson(<span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span>, <span class="hljs-string"><span class="hljs-string">"bob"</span></span>) ); <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;assertInstanceOf( Lesson::class, Lesson::find( (string) <span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span>) ); }</code> </pre><br>  Jetzt kann der neue Projektentwickler den Code <code>App\School\ReadModels</code> , siehe <code>App\School\ReadModels</code> , der eine Reihe von eloquenten Modellen enthält, und diese Modelle verwenden, um Änderungen in die Lektionstabelle zu schreiben.  Wir können dies verhindern, indem wir eine <code>ImmutableModel</code> Klasse erstellen, die die Eloquent Model-Klasse erweitert und die Speichermethode in <code>app/CQRS/ReadModelImmutableModel.php</code> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de461899/">https://habr.com/ru/post/de461899/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de461885/index.html">EDS ist eine andere Art von Betrug</a></li>
<li><a href="../de461887/index.html">Eingabe von Aeronet Episode 2: Homing Drone</a></li>
<li><a href="../de461891/index.html">Wie wir mit ManageIQ Freunde in der Bankinfrastruktur gefunden haben</a></li>
<li><a href="../de461895/index.html">Lernen Sie während der Reise - wie wir am 1. European Business Analysis Day gefahren sind</a></li>
<li><a href="../de461897/index.html">Wie wir die Stabilität der Lamoda-Anwendung aufrechterhalten</a></li>
<li><a href="../de461901/index.html">Drei Jahre Autotests: Wie man die Geschwindigkeit erhöht und nicht nur</a></li>
<li><a href="../de461903/index.html">Geheimnisvoller Gegner: Fuzzy-Ausleihe</a></li>
<li><a href="../de461905/index.html">Tic Tac Toe, Teil 7: Pytest und Travis CI</a></li>
<li><a href="../de461907/index.html">Produktanalyse in einem Studio mit vollem Zyklus</a></li>
<li><a href="../de461913/index.html">Mobile Usability im E-Commerce: Analyse der TOP-20-Online-Shops in Russland</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>