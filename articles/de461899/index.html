<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üåê ü§πüèª üëçüèø Event Generation, CQRS und Laravel ü§∞üèæ üö¥üèº üëåüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die √úbersetzung des Artikels wurde f√ºr Studenten des Fachkurses "Framework Laravel" vorbereitet. 
 



 Einf√ºhrung 
 Dieser Artikel befasst sich mit d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Event Generation, CQRS und Laravel</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/461899/">  <i>Die √úbersetzung des Artikels wurde f√ºr Studenten des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fachkurses "Framework Laravel"</a> vorbereitet.</i> <i><br></i> <br><img src="https://habrastorage.org/webt/h8/4u/y5/h84uy5i5spnt3rdmpaiw2aynd0s.png"><br><br><hr><br><h2>  Einf√ºhrung </h2><br>  Dieser Artikel befasst sich mit den Grundlagen der Erstellung von Event-CQRS-Systemen in der PHP-Sprache und im Laravel-Framework.  Es wird davon ausgegangen, dass Sie mit dem Entwicklungsschema √ºber den Befehlsbus vertraut sind und eine Vorstellung von Ereignissen haben (insbesondere die Ver√∂ffentlichung von Ereignissen f√ºr eine Reihe von Listenern).  Um dieses Wissen aufzufrischen, k√∂nnen Sie den Laracasts-Dienst verwenden.  Dar√ºber hinaus wird davon ausgegangen, dass Sie das CQRS-Prinzip genau kennen.  Wenn nicht, empfehle ich dringend, zwei Vortr√§ge <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">anzuh√∂ren</a> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mathias Verraes Workshop zur Ereignisgenerierung</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Greg Youngs CQRS und Ereignisgenerierung</a> . <br><a name="habracut"></a><br>  Verwenden Sie den hier angegebenen Code nicht in Ihren Projekten!  Es ist eine Lernplattform zum Verst√§ndnis der Ideen hinter CQRS.  Dieser Code kann nicht als zuverl√§ssig bezeichnet werden, er ist schlecht getestet, und au√üerdem programmiere ich selten Schnittstellen, sodass es viel schwieriger sein wird, einzelne Teile des Codes zu √§ndern.  Ein viel besseres Beispiel f√ºr ein CQRS-Paket, das Sie verwenden k√∂nnen, ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Broadway, entwickelt von Qandidate Lab</a> .  Dies ist sauberer, lose gekoppelter Code. Einige Abstraktionen machen jedoch nicht ganz klar, ob Sie noch nie auf Ereignissysteme gesto√üen sind. <br><br>  Und das letzte - mein Code ist mit Ereignissen und dem Laravel-Befehlsbus verbunden.  Ich wollte sehen, wie der Code in Laravel aussehen w√ºrde (ich verwende dieses Framework normalerweise f√ºr Projekte kleiner Agenturen). R√ºckblickend denke ich jedoch, dass ich meine eigenen Implementierungen erstellen sollte.  Ich hoffe, dass mein Code auch f√ºr diejenigen klar ist, die keine Frameworks verwenden. <br><br>  Auf github befindet sich der Code unter <a href="">https://github.com/scazz/cqrs-tutorial.git</a> , und in unserem Handbuch werden wir seine Komponenten zur Erh√∂hung der Logik betrachten. <br><br>  Wir werden ein Erstregistrierungssystem f√ºr eine Surfschule erstellen.  Mit seiner Hilfe k√∂nnen sich Schulkunden f√ºr Klassen anmelden.  F√ºr den Aufnahmevorgang formulieren wir folgende Regeln: <br><br><ul><li>  Jede Lektion muss mindestens einen Kunden haben ... </li><li>  ... aber nicht mehr als drei. </li></ul><br>  Eine der beeindruckendsten Funktionen ereignisbasierter CQRS-Systeme ist die Erstellung von Lesemodellen, die f√ºr jede vom System ben√∂tigte Metrik spezifisch sind.  Beispiele f√ºr die Projektion von Lesemodellen finden Sie in ElasticSearch. Greg Young hat in seinem Event Store eine themenorientierte Sprache f√ºr die Behandlung komplexer Ereignisse implementiert.  Der Einfachheit halber wird unsere Leseprojektion jedoch eine Standard-SQL-Datenbank zur Verwendung mit Eloquent sein.  Als Ergebnis haben wir eine Tabelle f√ºr Klassen und eine f√ºr Kunden. <br><br>  Mit dem Konzept der Ereignisgenerierung k√∂nnen Sie Ereignisse auch offline verarbeiten.  In diesem Artikel werde ich mich jedoch (zur Vereinfachung) maximal an die ‚Äûtraditionellen‚Äú Entwicklungsmodelle halten und unsere Leseprojektionen werden in Echtzeit aktualisiert, unmittelbar nachdem die Ereignisse im Repository gespeichert wurden. <br><br><h2>  Projekteinrichtung und erster Test </h2><br><pre><code class="plaintext hljs">git clone https://github.com/scazz/cqrs-tutorial</code> </pre> <br>  Erstellen Sie ein neues Laravel 5-Projekt <br><br><pre> <code class="plaintext hljs">$&gt; laravel new cqrs-tutorial</code> </pre> <br>  Und f√ºr den Anfang brauchen wir einen Test.  Wir werden den Integrationstest verwenden, der sicherstellt, dass die Registrierung des Kunden f√ºr Klassen dazu f√ºhrt, dass die Lektion in unserem eloquenten Modell erstellt wird. <br><br>  Listing tests / CQRSTest.php: <br><br><pre> <code class="plaintext hljs">use Illuminate\Foundation\Bus\DispatchesCommands; class CQRSTest extends TestCase { use DispatchesCommands;</code> </pre><br><pre> <code class="bash hljs">/** *  ,   BookLesson       * @<span class="hljs-built_in"><span class="hljs-built_in">return</span></span> void */ public <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testFiringEventUpdatesReadModel</span></span></span></span>() { <span class="hljs-variable"><span class="hljs-variable">$testLessonId</span></span> = <span class="hljs-string"><span class="hljs-string">'123e4567-e89b-12d3-a456-426655440000'</span></span>; <span class="hljs-variable"><span class="hljs-variable">$clientName</span></span> = <span class="hljs-string"><span class="hljs-string">"George"</span></span>; <span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span> = new LessonId(<span class="hljs-variable"><span class="hljs-variable">$testLessonId</span></span>); <span class="hljs-variable"><span class="hljs-variable">$command</span></span> = new BookLesson(<span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span>, <span class="hljs-variable"><span class="hljs-variable">$clientName</span></span>); <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;dispatch(<span class="hljs-variable"><span class="hljs-variable">$command</span></span>); <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;assertNotNull(Lesson::find(<span class="hljs-variable"><span class="hljs-variable">$testLessonId</span></span>)); <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;assertEquals( Lesson::find(<span class="hljs-variable"><span class="hljs-variable">$testLessonId</span></span>)-&gt;clientName, <span class="hljs-variable"><span class="hljs-variable">$clientName</span></span> ); } }</code> </pre> <br>  Wir weisen die neue Aktivit√§t einer ID zu, erstellen ein Team, um sich f√ºr eine neue Aktivit√§t anzumelden, und weisen Laravel an, sie zu senden.  In der Lektionstabelle m√ºssen wir einen neuen Datensatz erstellen, den wir mit dem Eloquent-Modell lesen k√∂nnen.  Wir brauchen eine Datenbank, also f√ºllen Sie Ihre .env-Datei richtig aus. <br><br>  Jedes in unserem Ereignisspeicher aufgezeichnete Ereignis wird an die Wurzel des Aggregats angeh√§ngt, die wir einfach als Entit√§t (Entit√§t) bezeichnen - eine Abstraktion f√ºr Bildungszwecke sorgt nur f√ºr Verwirrung.  ID ist eine universelle eindeutige Kennung (UUID).  Dem Ereignisspeicher ist es egal, ob das Ereignis f√ºr die Lektion oder den Kunden gilt.  Er wei√ü nur, dass es mit einer ID verbunden ist. <br><br>  Basierend auf den beim Testen festgestellten Fehlern k√∂nnen wir fehlende Klassen erstellen.  Zuerst erstellen wir die LessonId-Klasse und dann den BookLesson-Befehl (machen Sie sich noch keine Gedanken √ºber die Handler-Methode, f√ºhren Sie den Test einfach weiter aus).  Die Lesson-Klasse ist ein Lesemodell au√üerhalb des Lesson-Namespace.  Ein exklusives Lesemodell - die Logik des Themenbereichs wird hier niemals gespeichert.  Abschlie√üend m√ºssen wir eine Migration f√ºr die Lektionstabelle erstellen. <br><br>  Um die Klarheit des Codes zu gew√§hrleisten, werde ich die Assertion Verification Library verwenden.  Es kann mit dem folgenden Befehl hinzugef√ºgt werden: <br><br><pre> <code class="plaintext hljs">$&gt; composer require beberlei/assert</code> </pre> <br>  Betrachten Sie den Prozess, der mit diesem Befehl initiiert werden soll: <br><br><ol><li>  Validierung: Imperative Befehle k√∂nnen fehlschlagen, und Ereignisse sind bereits aufgetreten und sollten daher nicht fehlschlagen. </li><li>  Erstellen Sie ein neues LessonWasBooked-Ereignis (f√ºr eine Lektion angemeldet). </li><li>  Aktualisieren Sie den Aktivit√§tsstatus.  (Das Datensatzmodell muss den Status des Modells kennen, damit es eine Validierung durchf√ºhren kann.) </li><li>  F√ºgen Sie dieses Ereignis dem Stream nicht festgeschriebener Ereignisse hinzu, die im Aktivit√§tsdatensatzmodell gespeichert sind. </li><li>  Speichern Sie den Stream nicht festgeschriebener Ereignisse im Repository. </li><li>  L√∂sen Sie das LessonWasBooked-Ereignis global aus, um alle Leseprojektoren √ºber die Aktualisierung der Lektionstabelle zu informieren. </li></ol><br>  Zuerst m√ºssen Sie ein Aufzeichnungsmodell f√ºr die Lektion erstellen.  Wir werden die statische Factory-Methode <code>Lesson::bookClientOntoNewLesson()</code> .  Es generiert ein neues <code>LessonWasOpened</code> Ereignis (die Lektion ist ge√∂ffnet), wendet dieses Ereignis auf sich selbst an (legt nur seine ID fest) und f√ºgt das neue Ereignis in Form von <code>DomainEventMessage</code> (das Ereignis plus einige Metadaten, die wir beim Speichern im Ereignisspeicher verwenden) zur Liste der nicht <code>DomainEventMessage</code> Ereignisse hinzu. <br><br>  Der Vorgang wird wiederholt, um dem Ereignis einen Client hinzuzuf√ºgen.  Beim Anwenden des <code>ClientWasBookedOntoLesson</code> Ereignisses (der Client wurde in der Lektion registriert) verfolgt das Aufzeichnungsmodell nicht die <code>ClientWasBookedOntoLesson</code> , sondern nur die Anzahl der registrierten Clients.  Datensatzmodelle m√ºssen keine Kundennamen kennen, um die Konsistenz sicherzustellen. <br><br>  Die Methoden <code>applyLessonWasOpened</code> und <code>applyClientWasBookedOntoLesson</code> scheinen <code>applyClientWasBookedOntoLesson</code> etwas seltsam.  Wir werden sie sp√§ter verwenden, wenn wir alte Ereignisse reproduzieren m√ºssen, um den Status des Aufzeichnungsmodells zu bilden.  Es ist nicht einfach zu erkl√§ren, daher gebe ich einen Code, der Ihnen hilft, diesen Prozess zu verstehen.  Sp√§ter werden wir den Code extrahieren, der nicht festgeschriebene Ereignisse verarbeitet und Dom√§nenereignismeldungen generiert. <br><br><pre> <code class="bash hljs">app/School/Lesson/Lesson.php public <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> openLesson( LessonId <span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span> ) { /*      ,      ,       */ <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;apply( new LessonWasOpened( <span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span>) ); } protected <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> applyLessonWasOpened( LessonWasOpened <span class="hljs-variable"><span class="hljs-variable">$event</span></span> ) { <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;lessonId = <span class="hljs-variable"><span class="hljs-variable">$event</span></span>-&gt;getLessonId(); <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;numberOfClients = 0; } public <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> bookClient( <span class="hljs-variable"><span class="hljs-variable">$clientName</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;numberOfClients &gt;= 3) { throw new TooManyClientsAddedToLesson(); } <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;apply( new ClientBookedOntoLesson( <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;lessonId, <span class="hljs-variable"><span class="hljs-variable">$clientName</span></span>) ); } /** *       ‚Äî *  ,       *      ,       , *      . */ protected <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> applyClientBookedOntoLesson( ClientBookedOntoLesson <span class="hljs-variable"><span class="hljs-variable">$event</span></span> ) { <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;numberOfClients++; }</code> </pre> <br>  Wir k√∂nnen die CQRS-Komponenten aus unserem Aufzeichnungsmodell extrahieren - Fragmente der Klasse, die an der Verarbeitung nicht festgeschriebener Ereignisse beteiligt sind.  Sie k√∂nnen die API auch f√ºr eine ereignisgenerierte Entit√§t l√∂schen, indem Sie eine sichere Funktion <code>apply()</code> erstellen, die das Ereignis akzeptiert, die entsprechende Methode <code>applyEventName()</code> <code>DomainEventMessage</code> und der Liste der nicht <code>DomainEventMessage</code> Ereignisse ein neues <code>DomainEventMessage</code> Ereignis hinzuf√ºgt.  Die extrahierte Klasse ist ein Detail der CQRS-Implementierung und enth√§lt keine Dom√§nenlogik. Daher k√∂nnen wir einen neuen Namespace erstellen: App \ CQRS: <br><br>  <i><code>app/CQRS/EventSourcedEntity.php</code> die Code- <code>app/CQRS/EventSourcedEntity.php</code></i> <i><br></i>  <i>Damit der Code funktioniert, m√ºssen wir die <code>DomainEventMessage</code> Klasse hinzuf√ºgen, bei der es sich um ein einfaches DTO handelt. Sie finden sie in <code>app/CQRS/DomainEventMessage.php</code></i> <br><br>  So haben wir ein System, das Ereignisse f√ºr jeden Schreibversuch generiert und Ereignisse verwendet, um die √Ñnderungen aufzuzeichnen, die erforderlich sind, um Invarianten zu verhindern.  Der n√§chste Schritt besteht darin, diese Ereignisse im Store (EventStore) zu speichern.  Zun√§chst muss dieses Ereignis-Repository erstellt werden.  Zur Vereinfachung verwenden wir das Eloquent-Modell, eine einfache SQL-Tabelle mit den folgenden Feldern: * <code>UUID</code> (um zu wissen, auf welche Entit√§t das Ereignis <code>event_payload</code> ) * <code>event_payload</code> (serialisierte Nachricht, die alles enth√§lt, was zum <code>event_payload</code> des Ereignisses erforderlich ist) * <code>event_payload</code> - Zeitstempel, um zu wissen, wann das Ereignis <code>event_payload</code> passiert ist.  Wenn Sie den Code sorgf√§ltig pr√ºfen, werden Sie feststellen, dass ich zwei Befehle erstellt habe - zum Erstellen und Zerst√∂ren unserer Ereignisspeichertabelle: <br><br><ul><li>  php artisan eloquenteventstore: create (App \ CQRS \ EloquentEventStore \ CreateEloquentEventStore) </li><li>  php artisan eloquenteventstore: drop (App \ CQRS \ EloquentEventStore \ DropEloquentEventStore) (vergessen Sie nicht, sie zu App \ Console \ Kernel.php hinzuzuf√ºgen, damit sie geladen werden). </li></ul><br>  Es gibt zwei sehr gute Gr√ºnde, SQL nicht als Ereignisspeicher zu verwenden: Es implementiert nicht das Nur-Anh√§ngen-Modell (nur das Hinzuf√ºgen von Daten, Ereignisse m√ºssen unver√§nderlich sein) und auch, weil SQL keine ideale Abfragesprache f√ºr tempor√§re Datenbanken ist.  Wir programmieren die Schnittstelle, um den Austausch des Ereignisspeichers in nachfolgenden Ver√∂ffentlichungen zu erleichtern. <br><br>  Verwenden Sie das Repository, um Ereignisse zu speichern.  Immer wenn <code>save()</code> f√ºr das Aufzeichnungsmodell aufgerufen wird, speichern wir die Liste der nicht festgeschriebenen Ereignisse im Ereignisspeicher.  Zum Speichern von Ereignissen ben√∂tigen wir einen Mechanismus f√ºr deren Serialisierung und Deserialisierung.  Erstellen Sie dazu einen Serializer.  Wir ben√∂tigen Metadaten wie eine Ereignisklasse (z. B. <code>App\School\Lesson\Events\LessonWasOpened</code> ) und eine Ereignisnutzlast (Daten, die zum Rekonstruieren eines Ereignisses ben√∂tigt werden). <br><br>  All dies wird im JSON-Format codiert und dann zusammen mit der UUID der Entit√§t und dem Zeitstempel in unsere Datenbank geschrieben.  Wir m√∂chten unsere Lesemodelle nach der Erfassung von Ereignissen aktualisieren, damit das Repository jedes Ereignis nach dem Speichern ausl√∂st.  Der Serializer ist f√ºr das Schreiben der Ereignisklasse verantwortlich, w√§hrend das Ereignis f√ºr die Serialisierung seiner Nutzdaten verantwortlich ist.  Ein vollst√§ndig serialisiertes Ereignis sieht ungef√§hr so ‚Äã‚Äãaus: <br><br><pre> <code class="plaintext hljs"> { class: "App\\School\\Lesson\\Events\\", event: $event-&gt;serialize() }</code> </pre> <br>  Da f√ºr alle Ereignisse eine Serialisierungs- und Deserialisierungsmethode erforderlich ist, k√∂nnen wir eine <code>SerializableEvent</code> Schnittstelle erstellen und einen Hinweis auf den Typ des erwarteten Werts hinzuf√ºgen.  Aktualisieren Sie unser <code>LessonWasOpened</code> Ereignis: <br><br><pre> <code class="bash hljs">app/School/Lesson/Events/LessonWasOpened.php class LessonWasOpened implements SerializableEvent { public <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">serialize</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> array( <span class="hljs-string"><span class="hljs-string">'lessonId'</span></span>=&gt; (string) <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;getLessonId() ); } }</code> </pre> <br>  Erstellen Sie ein <code>LessonRepository</code> Repository.  Wir k√∂nnen die CQRS-Kernkomponenten sp√§ter umgestalten und extrahieren. <br><br> <code>app/School/Lesson/LessonRepository.php</code> <br> <pre> <code class="plaintext hljs">eventStoreRepository = new EloquentEventStoreRepository( new EventSerializer() ); } public function save(Lesson $lesson) { /** @var DomainEventMessage $domainEventMessage */ foreach( $lesson-&gt;getUncommittedDomainEvents() as $domainEventMessage ) { $this-&gt;eventStoreRepository-&gt;append( $domainEventMessage-&gt;getId(), $domainEventMessage-&gt;getEvent(), $domainEventMessage-&gt;getRecordedAt() ); Event::fire($domainEventMessage-&gt;getEvent()); } } }</code> </pre> <br>  Wenn Sie den Integrationstest erneut <code>domain_events</code> und dann die SQL-Tabelle <code>domain_events</code> √ºberpr√ºfen, sollten zwei Ereignisse in der Datenbank <code>domain_events</code> werden. <br><br>  Unser letzter Schritt zum erfolgreichen Bestehen des Tests besteht darin, die Sendeereignisse abzuh√∂ren und die Projektion des Unterrichtslesemodells zu aktualisieren.  Lektionssendungsereignisse werden vom <code>LessonProjector</code> abgefangen, der die erforderlichen √Ñnderungen an <code>LessonProjection</code> ( <code>LessonProjection</code> Modelle der Lektionstabelle) <code>LessonProjection</code> : <br><br><pre> <code class="bash hljs"> app/School/Lesson/Projections/LessonProjector.php class LessonProjector { public <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> applyLessonWasOpened( LessonWasOpened <span class="hljs-variable"><span class="hljs-variable">$event</span></span> ) { <span class="hljs-variable"><span class="hljs-variable">$lessonProjection</span></span> = new LessonProjection(); <span class="hljs-variable"><span class="hljs-variable">$lessonProjection</span></span>-&gt;id = <span class="hljs-variable"><span class="hljs-variable">$event</span></span>-&gt;getLessonId(); <span class="hljs-variable"><span class="hljs-variable">$lessonProjection</span></span>-&gt;save(); } public <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> subscribe(Dispatcher <span class="hljs-variable"><span class="hljs-variable">$events</span></span>) { <span class="hljs-variable"><span class="hljs-variable">$fullClassName</span></span> = self::class; <span class="hljs-variable"><span class="hljs-variable">$events</span></span>-&gt;listen( LessonWasOpened::class, <span class="hljs-variable"><span class="hljs-variable">$fullClassName</span></span>.<span class="hljs-string"><span class="hljs-string">'@applyLessonWasOpened'</span></span>); } }  app/School/Lesson/Projections/LessonProjection.php class LessonProjection extends Model { public <span class="hljs-variable"><span class="hljs-variable">$timestamps</span></span> = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; protected <span class="hljs-variable"><span class="hljs-variable">$table</span></span> = <span class="hljs-string"><span class="hljs-string">"lessons"</span></span>; }</code> </pre> <br>  Wenn Sie den Test ausf√ºhren, sehen Sie, dass ein SQL-Fehler aufgetreten ist: <br><br><pre> <code class="plaintext hljs">Unknown column 'clientName' in 'field list'</code> </pre> <br>  Sobald wir eine Migration erstellen, um <code>clientName</code> zur Lektionstabelle hinzuzuf√ºgen, bestehen wir den Test erfolgreich.  Wir haben die Grundfunktionalit√§t von CQRS implementiert: Teams erstellen Ereignisse, mit denen Lesemodelle generiert werden. <br><br><h2>  Verbesserung des Lesemodells mit Links </h2><br>  Wir haben einen bedeutenden Meilenstein erreicht, aber das ist noch nicht alles!  Bisher unterst√ºtzt das Lesemodell nur einen Client (wir haben drei in unseren Dom√§nenregeln angegeben).  Die √Ñnderungen, die wir am <code>ClientBookedOntoLesson</code> <code>ClientProjector</code> , sind recht einfach: Wir erstellen lediglich ein Client-Projektionsmodell und einen <code>ClientProjector</code> , der das <code>ClientBookedOntoLesson</code> Ereignis <code>ClientBookedOntoLesson</code> .  Zun√§chst aktualisieren wir unseren Test, um die √Ñnderungen widerzuspiegeln, die wir in unserem Lesemodell sehen m√∂chten: <br><br><pre> <code class="bash hljs">tests/CQRSTest.php public <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testFiringEventUpdatesReadModel</span></span></span></span>() { <span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span> = new LessonId( (string) \Rhumsaa\Uuid\Uuid::uuid1() ); <span class="hljs-variable"><span class="hljs-variable">$clientName</span></span> = <span class="hljs-string"><span class="hljs-string">"George"</span></span>; <span class="hljs-variable"><span class="hljs-variable">$command</span></span> = new BookLesson(<span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span>, <span class="hljs-variable"><span class="hljs-variable">$clientName</span></span>); <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;dispatch(<span class="hljs-variable"><span class="hljs-variable">$command</span></span>); <span class="hljs-variable"><span class="hljs-variable">$lesson</span></span> = Lesson::find( (string) <span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span>); <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;assertEquals( <span class="hljs-variable"><span class="hljs-variable">$lesson</span></span>-&gt;id, (string) <span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span> ); <span class="hljs-variable"><span class="hljs-variable">$client</span></span> = <span class="hljs-variable"><span class="hljs-variable">$lesson</span></span>-&gt;clients()-&gt;first(); <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;assertEquals(<span class="hljs-variable"><span class="hljs-variable">$client</span></span>-&gt;name, <span class="hljs-variable"><span class="hljs-variable">$clientName</span></span>); }</code> </pre><br>  Dies ist eine klare Demonstration, wie einfach es ist, Lesemodelle zu √§ndern.  Bis auf das Ereignis-Repository bleibt alles unver√§ndert.  Als Bonus erhalten wir bei Verwendung des Ereignissystems Daten f√ºr grundlegende Tests. Wenn Sie den Projektor des Lesemodells √§ndern, h√∂ren wir jedes Ereignis, das jemals in unserem System aufgetreten ist. <br><br>  Wir reproduzieren diese Ereignisse mit dem neuen Projektor, suchen nach Ausnahmen und vergleichen die Ergebnisse mit fr√ºheren Projektionen.  Nachdem das System einige Zeit funktioniert hat, haben wir eine ziemlich repr√§sentative Auswahl an Ereignissen zum Testen unserer Projektoren. <br><br>  Unser Aufzeichnungsmodell kann derzeit den aktuellen Status nicht laden.  Wenn wir der Lektion einen zweiten Client hinzuf√ºgen m√∂chten, k√∂nnen wir einfach ein zweites ClientWasAddedToLesson-Ereignis erstellen, aber keinen Schutz gegen Invarianten bieten.  Zur besseren √úbersichtlichkeit schlage ich vor, einen zweiten Test zu schreiben, der die Aufzeichnung von zwei Kunden pro Lektion simuliert. <br><br><pre> <code class="bash hljs">tests/CQRSTest.php public <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testLoadingWriteModel</span></span></span></span>() { <span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span> = new LessonId( (string) \Rhumsaa\Uuid\Uuid::uuid1() ); <span class="hljs-variable"><span class="hljs-variable">$clientName_1</span></span> = <span class="hljs-string"><span class="hljs-string">"George"</span></span>; <span class="hljs-variable"><span class="hljs-variable">$clientName_2</span></span> = <span class="hljs-string"><span class="hljs-string">"Fred"</span></span>; <span class="hljs-variable"><span class="hljs-variable">$command</span></span> = new BookLesson(<span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span>, <span class="hljs-variable"><span class="hljs-variable">$clientName_1</span></span>); <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;dispatch(<span class="hljs-variable"><span class="hljs-variable">$command</span></span>); <span class="hljs-variable"><span class="hljs-variable">$command</span></span> = new BookClientOntoLesson(<span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span>, <span class="hljs-variable"><span class="hljs-variable">$clientName_2</span></span>); <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;dispatch(<span class="hljs-variable"><span class="hljs-variable">$command</span></span>); <span class="hljs-variable"><span class="hljs-variable">$lesson</span></span> = Lesson::find( (string) <span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span> ); <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;assertClientCollectionContains(<span class="hljs-variable"><span class="hljs-variable">$lesson</span></span>-&gt;clients, <span class="hljs-variable"><span class="hljs-variable">$clientName_1</span></span>); <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;assertClientCollectionContains(<span class="hljs-variable"><span class="hljs-variable">$lesson</span></span>-&gt;clients, <span class="hljs-variable"><span class="hljs-variable">$clientName_2</span></span>); }</code> </pre> <br>  F√ºr unser Aufzeichnungsmodell m√ºssen wir eine Methode zum ‚ÄûLaden‚Äú einer Entit√§t implementieren, f√ºr die bereits Ereignisse im Ereignisspeicher gelten.  Wir k√∂nnen dies erreichen, indem wir jedes Ereignis wiedergeben, das sich auf die UUID der Entit√§t bezieht.  Im Allgemeinen ist der Prozess wie folgt: <br><br><ol><li>  Wir erhalten alle relevanten Ereignismeldungen vom Ereignisspeicher. </li><li>  F√ºr jede Nachricht erstellen wir das entsprechende Ereignis neu. </li><li>  Wir erstellen ein neues Entity-Record-Modell und spielen jedes Ereignis ab. </li></ol><br>  Im Moment <code>BookClientOntoLesson</code> unsere Tests Ausnahmen aus. <code>BookClientOntoLesson</code> erstellen wir zun√§chst den erforderlichen <code>BookClientOntoLesson</code> (registrieren Sie einen Client f√ºr die Lektion) und verwenden den <code>BookLesson</code> Befehl als Vorlage.  Die Handler-Methode sieht folgenderma√üen aus: <br><br><pre> <code class="bash hljs"> app/School/Lesson/Commands/BookClientOntoLesson.php public <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> handle(LessonRepository <span class="hljs-variable"><span class="hljs-variable">$repository</span></span>) { /** @var Lesson <span class="hljs-variable"><span class="hljs-variable">$lesson</span></span> */ <span class="hljs-variable"><span class="hljs-variable">$lesson</span></span> = <span class="hljs-variable"><span class="hljs-variable">$repository</span></span>-&gt;load(<span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;lessonId); <span class="hljs-variable"><span class="hljs-variable">$lesson</span></span>-&gt;bookClient(<span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;clientName); <span class="hljs-variable"><span class="hljs-variable">$repository</span></span>-&gt;save(<span class="hljs-variable"><span class="hljs-variable">$lesson</span></span>); }      : app/School/Lesson/LessonRepository.php public <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> load(LessonId <span class="hljs-variable"><span class="hljs-variable">$id</span></span>) { <span class="hljs-variable"><span class="hljs-variable">$events</span></span> = <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;eventStoreRepository-&gt;load(<span class="hljs-variable"><span class="hljs-variable">$id</span></span>); <span class="hljs-variable"><span class="hljs-variable">$lesson</span></span> = new Lesson(); <span class="hljs-variable"><span class="hljs-variable">$lesson</span></span>-&gt;initializeState(<span class="hljs-variable"><span class="hljs-variable">$events</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> <span class="hljs-variable"><span class="hljs-variable">$lesson</span></span>; }</code> </pre> <br>  Die Repository-Ladefunktion gibt ein Array neu erstellter Ereignisse zur√ºck.  Zu diesem Zweck findet sie zuerst Nachrichten zu Ereignissen im Repository und leitet sie dann an den <code>Serializer</code> , um jede Nachricht in ein Ereignis umzuwandeln.  <code>Serializer</code> erstellt Nachrichten aus Ereignissen, daher m√ºssen wir die Methode <code>deserialize()</code> hinzuf√ºgen, um die inverse Transformation durchzuf√ºhren.  Denken Sie daran, dass der <code>Serializer</code> an jedes Ereignis √ºbergeben wird, um die Ereignisdaten (z. B. den Clientnamen) zu serialisieren.  Wir werden dasselbe tun, um die inverse Transformation durchzuf√ºhren, w√§hrend unsere <code>SerializableEvent</code> Schnittstelle mit der <code>deserialize()</code> -Methode aktualisiert werden muss.  Schauen wir uns den Code an, damit alles passt.  Zun√§chst die <code>EventStoreRepository</code> : <br><br><pre> <code class="bash hljs">app/CQRS/EloquentEventStore/EloquentEventStoreRepository.php public <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> load(<span class="hljs-variable"><span class="hljs-variable">$uuid</span></span>) { <span class="hljs-variable"><span class="hljs-variable">$eventMessages</span></span> = EloquentEventStoreModel::<span class="hljs-built_in"><span class="hljs-built_in">where</span></span>(<span class="hljs-string"><span class="hljs-string">'uuid'</span></span>, <span class="hljs-variable"><span class="hljs-variable">$uuid</span></span>)-&gt;get(); <span class="hljs-variable"><span class="hljs-variable">$events</span></span> = []; foreach(<span class="hljs-variable"><span class="hljs-variable">$eventMessages</span></span> as <span class="hljs-variable"><span class="hljs-variable">$eventMessage</span></span>) { /*       event_payload,        . */ <span class="hljs-variable"><span class="hljs-variable">$events</span></span>[] = <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;eventSerializer-&gt;deserialize( json_decode(<span class="hljs-variable"><span class="hljs-variable">$eventMessage</span></span>-&gt;event_payload)); } <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> <span class="hljs-variable"><span class="hljs-variable">$events</span></span>; }</code> </pre><br>  Verwenden der entsprechenden Deserialisierungsfunktion in <code>eventSerializer</code> : <br><br><pre> <code class="bash hljs">app/CQRS/Serializer/EventSerializer.php public <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> serialize( SerializableEvent <span class="hljs-variable"><span class="hljs-variable">$event</span></span> ) { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> array( <span class="hljs-string"><span class="hljs-string">'class'</span></span> =&gt; get_class(<span class="hljs-variable"><span class="hljs-variable">$event</span></span>), <span class="hljs-string"><span class="hljs-string">'payload'</span></span> =&gt; <span class="hljs-variable"><span class="hljs-variable">$event</span></span>-&gt;serialize() ); } public <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> deserialize( <span class="hljs-variable"><span class="hljs-variable">$serializedEvent</span></span> ) { <span class="hljs-variable"><span class="hljs-variable">$eventClass</span></span> = <span class="hljs-variable"><span class="hljs-variable">$serializedEvent</span></span>-&gt;class; <span class="hljs-variable"><span class="hljs-variable">$eventPayload</span></span> = <span class="hljs-variable"><span class="hljs-variable">$serializedEvent</span></span>-&gt;payload; <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> <span class="hljs-variable"><span class="hljs-variable">$eventClass</span></span>::deserialize(<span class="hljs-variable"><span class="hljs-variable">$eventPayload</span></span>); }</code> </pre> <br>  Abschlie√üend verwenden wir die statische Factory-Methode <code>deserialize()</code> in <code>LessonWasOpened</code> (wir m√ºssen diese Methode jedem Ereignis hinzuf√ºgen). <br><br><pre> <code class="bash hljs">app/School/Lesson/Events/LessonWasOpened.php public static <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> deserialize(<span class="hljs-variable"><span class="hljs-variable">$data</span></span>) { <span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span> = new LessonId(<span class="hljs-variable"><span class="hljs-variable">$data</span></span>-&gt;lessonId); <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> new self(<span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span>); }</code> </pre> <br>  Jetzt haben wir ein Array aller Ereignisse, die wir gerade relativ zu unserem Entity-Datensatzmodell reproduziert haben, um den Status in der <code>initializeState</code> Methode in <code>app/CQRS/EventSouredEntity.php</code> <br><br>  F√ºhren Sie jetzt unseren Test aus.  Bingo! <br>  Tats√§chlich haben wir derzeit keinen Test, um die Einhaltung unserer Domain-Regeln zu √ºberpr√ºfen. Schreiben wir ihn also: <br><br><pre> <code class="bash hljs">tests/CQRSTest.php public <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testMoreThan3ClientsCannotBeAddedToALesson</span></span></span></span>() { <span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span> = new LessonId( (string) \Rhumsaa\Uuid\Uuid::uuid1() ); <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;dispatch( new BookLesson(<span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span>, <span class="hljs-string"><span class="hljs-string">"bob"</span></span>) ); <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;dispatch( new BookClientOntoLesson(<span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span>, <span class="hljs-string"><span class="hljs-string">"george"</span></span>) ); <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;dispatch( new BookClientOntoLesson(<span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span>, <span class="hljs-string"><span class="hljs-string">"fred"</span></span>) ); <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;setExpectedException( TooManyClientsAddedToLesson::class ); <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;dispatch( new BookClientOntoLesson(<span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span>, <span class="hljs-string"><span class="hljs-string">"emma"</span></span>) ); }</code> </pre> <br>  Bitte beachten Sie, dass wir nur die <code>lessonId</code> ben√∂tigen. Dieser Test initialisiert den Status der Lektion bei jedem Befehl neu. <br><br>  Im Moment √ºbertragen wir einfach manuell erstellte <code>UUID</code> , w√§hrend wir sie in Wirklichkeit automatisch generieren m√∂chten.  Ich werde das <code>Ramsy\UUID</code> Paket verwenden, also installieren wir es mit <code>composer</code> : <br><br><pre> <code class="plaintext hljs">$&gt; composer require ramsey/uuid</code> </pre> <br>  Aktualisieren Sie jetzt unsere Tests, um das neue Paket zu verwenden: <br><br><pre> <code class="bash hljs">tests/CQRSTest.php public <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testEntityCreationWithUUIDGenerator</span></span></span></span>() { <span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span> = new LessonId( (string) \Rhumsaa\Uuid\Uuid::uuid1() ); <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;dispatch( new BookLesson(<span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span>, <span class="hljs-string"><span class="hljs-string">"bob"</span></span>) ); <span class="hljs-variable"><span class="hljs-variable">$this</span></span>-&gt;assertInstanceOf( Lesson::class, Lesson::find( (string) <span class="hljs-variable"><span class="hljs-variable">$lessonId</span></span>) ); }</code> </pre><br>  Jetzt kann der neue Projektentwickler den Code <code>App\School\ReadModels</code> , siehe <code>App\School\ReadModels</code> , der eine Reihe von eloquenten Modellen enth√§lt, und diese Modelle verwenden, um √Ñnderungen in die Lektionstabelle zu schreiben.  Wir k√∂nnen dies verhindern, indem wir eine <code>ImmutableModel</code> Klasse erstellen, die die Eloquent Model-Klasse erweitert und die Speichermethode in <code>app/CQRS/ReadModelImmutableModel.php</code> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de461899/">https://habr.com/ru/post/de461899/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de461885/index.html">EDS ist eine andere Art von Betrug</a></li>
<li><a href="../de461887/index.html">Eingabe von Aeronet Episode 2: Homing Drone</a></li>
<li><a href="../de461891/index.html">Wie wir mit ManageIQ Freunde in der Bankinfrastruktur gefunden haben</a></li>
<li><a href="../de461895/index.html">Lernen Sie w√§hrend der Reise - wie wir am 1. European Business Analysis Day gefahren sind</a></li>
<li><a href="../de461897/index.html">Wie wir die Stabilit√§t der Lamoda-Anwendung aufrechterhalten</a></li>
<li><a href="../de461901/index.html">Drei Jahre Autotests: Wie man die Geschwindigkeit erh√∂ht und nicht nur</a></li>
<li><a href="../de461903/index.html">Geheimnisvoller Gegner: Fuzzy-Ausleihe</a></li>
<li><a href="../de461905/index.html">Tic Tac Toe, Teil 7: Pytest und Travis CI</a></li>
<li><a href="../de461907/index.html">Produktanalyse in einem Studio mit vollem Zyklus</a></li>
<li><a href="../de461913/index.html">Mobile Usability im E-Commerce: Analyse der TOP-20-Online-Shops in Russland</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>