<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë¥üèø üë®üèº‚Äç‚úàÔ∏è üóΩ Bus digital "M√∫sica" con interfaz UART üõÅ üî± üë©‚ÄçüöÄ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola geektimes! ¬øAlguna vez se ha preguntado c√≥mo suena una "se√±al el√©ctrica" ‚Äã‚Äãa lo largo de las pistas de las placas de circuito impreso entre micro...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bus digital "M√∫sica" con interfaz UART</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/408485/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/hw/tj/x4/hwtjx4znykkrp5_poz3bx1xfpae.jpeg" alt="imagen"></div><br>  Hola geektimes!  ¬øAlguna vez se ha preguntado c√≥mo suena una "se√±al el√©ctrica" ‚Äã‚Äãa lo largo de las pistas de las placas de circuito impreso entre microcircuitos, transistores, diodos, resistencias y condensadores?  Una de las variantes de dicha se√±al en la electr√≥nica moderna es un bus digital, y una de las interfaces populares para el intercambio de datos a trav√©s del bus es UART.  A menudo se usa en microcontroladores para comunicarse con una computadora o alg√∫n tipo de periferia.  Para obtener sonido en el bus, no es necesario conectar un altavoz con un amplificador a un bus real con <i>UART</i> ohm, porque puede simularse en el programa.  ¬øLe interesan los sonidos con los que termin√≥ o necesita un programa para experimentar?  Entonces pido gato. <br><a name="habracut"></a><br><h3>  <b>Escuchamos archivos en el autob√∫s con UART</b> </h3><br>  ¬øQu√© sonido resultar√° si transfieres archivos a trav√©s de <i>UART</i> ?  Aqu√≠ hay algunos ejemplos obtenidos con los siguientes par√°metros <i>UART</i> : <br><br><ul><li>  115200 baudios </li><li>  Bit 8 bits </li><li>  Bit de paridad: ninguno </li><li>  Stop Bit Longitud: 1 </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Sonido del juego Stalker Shadow of Chernobyl</a> (archivo XR_3DA.exe, al final de la pista, a partir de las 2:36, hay una melod√≠a). <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El sonido del texto y el c√≥digo del art√≠culo sobre el sintetizador de voz</a> (el art√≠culo en s√≠ est√° <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> ). <br><br>  ¬øC√≥mo suena la foto de Lena? <br><br><img src="https://habrastorage.org/storage2/d1e/664/833/d1e6648335210462583267c43d4d3941.png" alt="imagen"><br><br>  El resultado fue solo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ruido</a> . <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El sonido del libro "Entrop√≠a y pron√≥stico de series de tiempo en la teor√≠a de sistemas din√°micos" en formato pdf.</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El sonido del firmware del microcontrolador de la serie Atmega para un reproductor wav.</a> <br><br><h3>  <b>¬øPara qu√© se puede usar?</b> </h3><br>  Te√≥ricamente, puede haber dicha informaci√≥n en forma de texto, imagen, video o programa que tendr√° no solo un significado funcional o un significado est√©tico, sino tambi√©n el sonido "hermoso" de un bus digital, y luego resultar√° en alg√∫n tipo de poes√≠a "digital" .  <s>Tambi√©n puede diversificar muestras para dubstep.</s> En general, en mi opini√≥n, escuchar los sonidos de un bus digital es casi tan interesante como escuchar el ruido de las ondas de radio en ondas cortas, en general, para un aficionado. <br><br><h3>  <b>C√≥mo funciona o un poco sobre UART</b> </h3><br>  Lo que es <i>UART</i> se puede leer en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Wikipedia</a> .  <i>UART es</i> muy f√°cil de simular en un programa.  De hecho, solo necesita poder crear una ca√≠da de se√±al de 0 a 1 y viceversa (en el caso de un archivo <i>WAV</i> con una capacidad de 16 bits, estos son valores de - <i>A</i> a + <i>A</i> , donde <i>A</i> es la amplitud de la se√±al) y grabarlo en un archivo de audio.  La interfaz <i>UART</i> funciona de esta manera: despu√©s del bit de inicio, que es l√≥gico "cero", debe establecer el nivel en funci√≥n de los datos proporcionados, de menor a mayor.  Luego viene un bit de paridad que no puedes usar.  Al final del mensaje hay un bit de parada ("unidad" l√≥gica), cuya longitud puede ser diferente.  El c√≥digo de muestra se puede encontrar en el c√≥digo fuente, que se encuentra al final del art√≠culo.  Se puede encontrar m√°s informaci√≥n sobre UART en la red, una gran cantidad de material.  UART se puede utilizar para otros fines, por ejemplo, como PWM, pero en nuestro caso, esto significa que, en teor√≠a, incluso puede transferir una se√±al de sonido completa directamente al altavoz, como se hace en reproductores wav en el microcontrolador.  Sin embargo, sugerir√≠a usarlo como un generador de meandros.  La frecuencia de tono y la fase de la se√±al se pueden proporcionar en forma de bits de datos, por ejemplo, <i>00001111</i> crear√° un meandro cuyo per√≠odo ser√° igual a 10 per√≠odos de tiempo de transmisi√≥n de un bit (ya que en este caso tambi√©n hay un bit de inicio igual a 0 y un bit de parada igual a 1)  Debido a los bits de inicio y parada, no todos los per√≠odos de meandro se pueden transmitir, por ejemplo, en este caso <i>01100110</i> , ya que en esencia escucharemos dicha secuencia en el bus <i>0011001101</i> .  Si utiliza una alta velocidad de transferencia de datos, por ejemplo, 115200 baudios, tiene sentido crear frecuencias de sonido audibles estirando los per√≠odos de los meadras en varios bytes. <br><br><h3>  <b>...</b> </h3><br>  Usando este <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">enlace</a> puede descargar el programa para convertir el archivo al sonido del bus <i>UART</i> .  Tambi√©n hay una versi√≥n que usa OpenAL para reproducir sonido durante la operaci√≥n del programa, aqu√≠ est√° el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">enlace</a> . <br><br>  El c√≥digo fuente del programa se proporciona a continuaci√≥n: <br><br><div class="spoiler">  <b class="spoiler_title">Archivo de encabezado SoundsDigitalBus.h</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> SOUNDS_DIGITAL_BUS_H_INCLUDED #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SOUNDS_DIGITAL_BUS_H_INCLUDED #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SDB_WAV_FILE_NAME </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"sdb_output.wav"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SDB_UART_BIT 8 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SDB_UART_PARITY 0 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SDB_UART_STOP_BIT 1 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SDB_UART_BAUDRATE 9600 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SDB_UART_BAUDRATE_MAX 921600 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">///   ()   #define SDB_MAX_DATA 30000 ///    #define SDB_CANNEL 1 /// -  ()  #define SDB_BIT 16 ///    #define SDB_FREQUENCY 96000 ///     OpenAL #define OPENAL_NUM_OF_DYNBUF 32 ///  OpenAL #define SDB_OPENAL_BIT SDB_BIT #define SDB_OPENAL_CANNEL SDB_CANNEL #define SDB_OPENAL_FREQUENCY SDB_FREQUENCY #define SDB_OPENAL_FORMAT AL_FORMAT_MONO16 ///     #define SDB_BUFFER_MAX 4800 ///  OpenAL    ( ,   1) #define SDB_WITH_OPENAL 1 ///   ( ,   1) #define SDB_WITH_DEBUG_MODE 0 #if SDB_WITH_OPENAL == 1 //   OpenAL    #include &lt;openal/al.h&gt; #include &lt;openal/alc.h&gt; #endif #if SDB_WITH_DEBUG_MODE == 1 //    #include &lt;stdio.h&gt; #include &lt;locale.h&gt; #endif //    #include &lt;stdio.h&gt; //    #include &lt;string.h&gt; class sdb { private: #if SDB_WITH_OPENAL == 1 //   openAl    //   speesy ALCdevice* openAlDevice; ALCcontext* openAlContext; ALuint openAlSource; signed char openAlnBuf; //  #endif // ---------------------------------------- //    WAV  FILE *fpSave; unsigned short wavBlockAlign; unsigned long wavSubchunk2Size; unsigned long wavChunkSize; unsigned char wavLenDataType; // ---------------------------------------- //      double dTime; //    ,  . double allTime; //    short busState; //   ( ) short busDataOne[SDB_BUFFER_MAX]; // ,   wav short busDataTwo[SDB_BUFFER_MAX]; unsigned char switchBuffer; //    unsigned int posBufferOne, posBufferTwo; //    unsigned int posAllBuffer; //   char wavFileName[512]; //  wav  char isCreateWavFileFlag; // ,  wav    char isBufferOneFlag; // ,     char isBufferTwoFlag; unsigned int uartBaudrate; //  UART   unsigned int uartT; unsigned char uartBit; //   unsigned char uartStopBit; //    unsigned char uartParityBit; unsigned char isAudioOutput; unsigned char isWavFileOutput; #if SDB_WITH_OPENAL == 1 ALboolean CheckALCError(void); ALboolean CheckALError(void); char initOpenAL(void); void destroyOpenAL(void); void playOpenAlSound(void); void stopOpenAlSound(void); void closeOpenAlSound(void); int getBufferStatusOpenAl(void); void setBufferOpenAl(signed short *buf,unsigned long siz); char updateOpenAl(void); #endif char createWavFile(char * filename,unsigned long sampleRate,unsigned short bitsPerSample, unsigned short numChannels); void writeSampleWavFile(void *data); void writeDataBlockWavFile(void *data,unsigned long len); void closeWavFile(void); void busDelay(unsigned short us); public: sdb(void); ~sdb(void); /** @brief       1-wire @param[in] data     1-wire */ void oneWireSendByte(unsigned char data); /** @brief     1-wire */ void oneWireReset(void); /** @brief    1- wire */ void oneWireStop(void); /** @brief      UART @param[in] data    UART */ void uartSendByte(unsigned char data); /** @brief     UART @param[in] data    UART */ void uartSend(unsigned long data); /** @brief   UART @param[in] baudrate   UART */ void uartSetBaudrate(unsigned long baudrate); /** @brief     @param[in] bit  ,   UART    */ void uartSetBit(unsigned char bit); /** @brief          .     1. @param[in] bit    */ void uartSetStopBit(unsigned char bit); /** @brief          UART  .   1,     ,   0,     UART     . @param[in] state ,   . */ void uartSetParityBit(unsigned char state); /** @brief    UART     UART,     .         . */ void uartStop(void); /** @brief    wav  @param[in] filename  wav  */ void setWavFileName(char* filename); /** @brief     OpenAL */ void playAudioOn(void); /** @brief     OpenAL */ void playAudioOff(void); /** @brief     wav  */ void recordOn(void); /** @brief     wav  */ void recordOff(void); }; #endif // MUSICDIGITALBUS_H_INCLUDED</span></span></span></span></code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">C√≥digo fuente del archivo SoundsDigitalBus.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SoundsDigitalBus.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> SDB_WITH_OPENAL == 1 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//   ALboolean sdb::CheckALCError(void) { ALenum ErrCode; ErrCode = alcGetError(openAlDevice); if (ErrCode != ALC_NO_ERROR) { return AL_FALSE; } return AL_TRUE; } ALboolean sdb::CheckALError(void) { ALenum ErrCode; if ((ErrCode = alGetError()) != AL_NO_ERROR) { return AL_FALSE; } return AL_TRUE; } //  OpenAL char sdb::initOpenAL(void) { ALfloat SourcePos[] = {0.0, 0.0, 0.0}; ALfloat SourceVel[] = {0.0, 0.0, 0.0}; //  . ALfloat ListenerPos[] = { 0.0, 0.0, 0.0 }; //  . ALfloat ListenerVel[] = { 0.0, 0.0, 0.0 }; //  . ( 3  ‚Äì  ¬´¬ª,  3 ‚Äì ¬´¬ª) ALfloat ListenerOri[] = { 0.0, 0.0, -1.0, 0.0, 1.0, 0.0 }; #if SDB_WITH_DEBUG_MODE == 1 printf("alcOpenDevice\n"); #endif openAlDevice = alcOpenDevice(0); // open default device if (openAlDevice != 0) { openAlContext = alcCreateContext(openAlDevice,0); // create context if (openAlContext != 0) { #if SDB_WITH_DEBUG_MODE == 1 printf("alcMakeContextCurrent\n"); #endif alcMakeContextCurrent(openAlContext); // set active context } else { #if SDB_WITH_DEBUG_MODE == 1 printf("Error context\n"); #endif return 0; } } else { #if SDB_WITH_DEBUG_MODE == 1 printf("Error Open Device\n"); #endif return 0; } //  alListenerfv(AL_POSITION, ListenerPos); //  alListenerfv(AL_VELOCITY, ListenerVel); //  alListenerfv(AL_ORIENTATION, ListenerOri); alGenSources(1, &amp;openAlSource); if (!CheckALError()) return false; alSourcef (openAlSource, AL_PITCH, 1.0f); alSourcef (openAlSource, AL_GAIN, 1.0f); alSourcefv(openAlSource, AL_POSITION, SourcePos); alSourcefv(openAlSource, AL_VELOCITY, SourceVel); alSourcei (openAlSource, AL_LOOPING, AL_FALSE); alSourcei(openAlSource, AL_LOOPING, AL_FALSE); openAlnBuf = 0; return 1; } void sdb::destroyOpenAL(void) { alSourceStop(openAlSource); //    alcMakeContextCurrent(0); //   alcDestroyContext(openAlContext); //    alcCloseDevice(openAlDevice); } void sdb::playOpenAlSound(void) { alSourcePlay(openAlSource); } void sdb::stopOpenAlSound(void) { alSourceStop(openAlSource); } void sdb::closeOpenAlSound(void) { alSourceStop(openAlSource); if (alIsSource(openAlSource)) alDeleteSources(1, &amp;openAlSource); } int sdb::getBufferStatusOpenAl(void) { int processed = 0; if (openAlnBuf == 0) return 1; alGetSourcei(openAlSource, AL_BUFFERS_PROCESSED, &amp;processed); CheckALError(); #if SDB_WITH_DEBUG_MODE == 1 printf("getBufferStatus: %d\n",processed); #endif if (processed != 0) { return processed; } return 0; } void sdb::setBufferOpenAl(signed short* buf, unsigned long siz) { int processed = 0; ALuint BufID = 0; #if _OPENAL_FORMAT == AL_FORMAT_MONO16 siz = siz*2; #endif // _OPENAL_FORMAT #if _OPENAL_FORMAT == AL_FORMAT_STEREO16 siz = siz*4; #endif // _OPENAL_FORMAT #if _OPENAL_FORMAT == AL_FORMAT_STEREO8 siz = siz*2; #endif // _OPENAL_FORMAT //     alGetSourcei(openAlSource, AL_BUFFERS_PROCESSED, &amp;processed); CheckALError(); //   ,          if ((processed == 0) &amp;&amp; (openAlnBuf &lt; OPENAL_NUM_OF_DYNBUF)) { openAlnBuf++; //   alGenBuffers(1, &amp;BufID); //   alBufferData(BufID,SDB_OPENAL_FORMAT,buf,siz,SDB_OPENAL_FREQUENCY); //     alSourceQueueBuffers(openAlSource, 1, &amp;BufID); //    if (openAlnBuf == 1) alSourcePlay(openAlSource); } else { #if SDB_WITH_DEBUG_MODE == 1 printf("processed: %d openAlnBuf: %d\n",processed,openAlnBuf); #endif // ,        while (getBufferStatusOpenAl() == 0); //     alSourceUnqueueBuffers(openAlSource, 1, &amp;BufID); CheckALError(); //    alBufferData(BufID,SDB_OPENAL_FORMAT,buf,siz,SDB_OPENAL_FREQUENCY); CheckALError(); alSourceQueueBuffers(openAlSource, 1, &amp;BufID); CheckALError(); } } //        ,    //  1       char sdb::updateOpenAl(void) { int processed = 0; ALuint BufID; //     alGetSourcei(openAlSource, AL_BUFFERS_PROCESSED, &amp;processed); #if SDB_WITH_DEBUG_MODE == 1 printf("updateOpenAl: %d\n",processed); #endif //     if (openAlnBuf == processed) { //     while (processed--) { //     alSourceUnqueueBuffers(openAlSource, 1, &amp;BufID); if (!CheckALError()) return 0; alDeleteBuffers(1, &amp;BufID); openAlnBuf--; } alSourceStop(openAlSource); #if SDB_WITH_DEBUG_MODE == 1 printf("alSourceStop: %d\n",openAlnBuf); #endif return 0; } return 1; } #endif //    .    void sdb::busDelay(unsigned short us) { double Time = (double)us/1000000.0; double locTime = allTime; char isFlag = 0; //  wav ,       if (isCreateWavFileFlag == 0) { if (isWavFileOutput == 1) { isFlag = createWavFile(wavFileName,SDB_FREQUENCY,SDB_BIT,SDB_CANNEL); //     ,    if (isFlag == 1) isCreateWavFileFlag = 1; } if (isAudioOutput == 1) { initOpenAL(); if (isWavFileOutput == 0) isCreateWavFileFlag = 1; } } allTime = allTime + Time; //     if (isCreateWavFileFlag == 1) //     while(locTime &lt; allTime) { if (switchBuffer == 0) { if (posBufferOne &gt;= SDB_BUFFER_MAX) { posBufferOne = 0; posBufferTwo = 0; busDataTwo[posBufferTwo++] = busState; isBufferOneFlag = 1; switchBuffer = 1; if (isWavFileOutput == 1) writeDataBlockWavFile(busDataOne,SDB_BUFFER_MAX); #if SDB_WITH_OPENAL == 1 if (isAudioOutput == 1) setBufferOpenAl(busDataOne,SDB_BUFFER_MAX); #endif } else { busDataOne[posBufferOne++] = busState; } } else if (switchBuffer == 1) { if (posBufferTwo &gt;= SDB_BUFFER_MAX) { posBufferOne = 0; posBufferTwo = 0; busDataOne[posBufferOne++] = busState; isBufferTwoFlag = 1; switchBuffer = 0; if (isWavFileOutput == 1) writeDataBlockWavFile(busDataTwo,SDB_BUFFER_MAX); #if SDB_WITH_OPENAL == 1 if (isAudioOutput == 1) setBufferOpenAl(busDataTwo,SDB_BUFFER_MAX); #endif } else { busDataTwo[posBufferTwo++] = busState; } } posAllBuffer++; locTime = locTime + dTime; } } char sdb::createWavFile(char * filename,unsigned long sampleRate,unsigned short bitsPerSample, unsigned short numChannels) { char type[4]; const unsigned long subchunk1Size = 16; unsigned long byteRate; const unsigned short audioFormat = 1; unsigned short len_str = 0; char str_filename[512] = {0}; unsigned short i; //        wavLenDataType = bitsPerSample/8; wavSubchunk2Size = 0; wavChunkSize = wavSubchunk2Size + 44 - 8; //      wavBlockAlign = bitsPerSample / (8 * numChannels); // ,    . byteRate = sampleRate * wavBlockAlign; strcpy(str_filename,filename); len_str = strlen(str_filename); if (len_str &lt; 4) return 0; //       .wav i = 0; while(i &lt; len_str) { if (filename[i] == '.' &amp;&amp; (i + 3) &lt; len_str) { if (((filename[i + 1] == 'w') &amp;&amp; (filename[i + 2] == 'a') &amp;&amp; (filename[i + 3] == 'v')) || ((filename[i + 1] == 'W') &amp;&amp; (filename[i + 2] == 'A') &amp;&amp; (filename[i + 3] == 'V'))) { //     wav break; } else { if ((i + 3) &gt;= 512) return 0; filename[i + 1] = 'w'; filename[i + 2] = 'a'; filename[i + 3] = 'v'; len_str = i + 4; break; } } else if ((i + 1) == len_str) { if ((i + 3) &gt;= 512) return 0; filename[i + 1] = '.'; filename[i + 2] = 'w'; filename[i + 3] = 'a'; filename[i + 4] = 'v'; len_str = i + 5; break; } i++; } type[0] = filename[len_str - 4]; type[1] = filename[len_str - 3]; type[2] = filename[len_str - 2]; type[3] = filename[len_str - 1]; if (type[0]!='.'||type[1]!='w'||type[2]!='a'||type[3]!='v') { if (type[0]!='.'||type[1]!='W'||type[2]!='A'||type[3]!='V') { return 0; } } fpSave=fopen(str_filename,"wb"); type[0]='R'; type[1]='I'; type[2]='F'; type[3]='F'; fwrite(&amp;type,sizeof(char),4,fpSave); fwrite(&amp;wavChunkSize,sizeof(unsigned long),1,fpSave); type[0]='W'; type[1]='A'; type[2]='V'; type[3]='E'; fwrite(&amp;type,sizeof(char),4,fpSave); type[0]='f'; type[1]='m'; type[2]='t'; type[3]=' '; fwrite(&amp;type,sizeof(char),4,fpSave); fwrite(&amp;subchunk1Size,sizeof(unsigned long),1,fpSave); fwrite(&amp;audioFormat,sizeof(unsigned short),1,fpSave); fwrite(&amp;numChannels,sizeof(unsigned short),1,fpSave); fwrite(&amp;sampleRate,sizeof(unsigned long),1,fpSave); fwrite(&amp;byteRate,sizeof(unsigned long),1,fpSave); fwrite(&amp;wavBlockAlign,sizeof(unsigned short),1,fpSave); //    .   ‚Äú‚Äù   . 8 , 16   .. fwrite(&amp;bitsPerSample,sizeof(unsigned short),1,fpSave); type[0]='d'; type[1]='a'; type[2]='t'; type[3]='a'; // subchunk2Id //   ‚Äúdata‚Äù (0x64617461  big-endian ) fwrite(&amp;type, sizeof(char), 4,fpSave); wavSubchunk2Size = 0; //    . fwrite(&amp;wavSubchunk2Size, sizeof(unsigned long), 1,fpSave); return 1; } void sdb::writeSampleWavFile(void* data) { fwrite(data, wavLenDataType, wavBlockAlign, fpSave); wavSubchunk2Size = wavSubchunk2Size + wavLenDataType*wavBlockAlign; } void sdb::writeDataBlockWavFile(void* data, unsigned long len) { fwrite(data, wavLenDataType, len, fpSave); wavSubchunk2Size = wavSubchunk2Size + len*wavLenDataType; } //         . void sdb::closeWavFile(void) { wavChunkSize = wavSubchunk2Size + 44 - 8; fseek(fpSave,4,SEEK_SET); fwrite(&amp;wavChunkSize,4,1,fpSave); fseek(fpSave,40,SEEK_SET); fwrite(&amp;wavSubchunk2Size,4,1,fpSave); fclose(fpSave); } //  sdb::sdb(void) { openAlnBuf = 0; wavBlockAlign = 0; wavSubchunk2Size = 0; wavChunkSize = 0; wavLenDataType = 0; fpSave = NULL; strcat(wavFileName,SDB_WAV_FILE_NAME); dTime = 1.0/(double)SDB_OPENAL_FREQUENCY; allTime = 0.0; //      switchBuffer = 0; //    () posAllBuffer = 0; //     posBufferOne = 0; posBufferTwo = 0; isBufferOneFlag = 0; isBufferTwoFlag = 0; isCreateWavFileFlag = 0; busState = SDB_MAX_DATA; uartSetBaudrate(SDB_UART_BAUDRATE); uartSetBit(SDB_UART_BIT); uartSetStopBit(SDB_UART_STOP_BIT); uartSetParityBit(SDB_UART_PARITY); recordOn(); playAudioOn(); } //  sdb::~sdb() { if (isCreateWavFileFlag == 1) { if (posBufferOne &gt; 0) { if (isWavFileOutput == 1) writeDataBlockWavFile(busDataOne,posBufferOne); #if SDB_WITH_OPENAL == 1 if (isAudioOutput == 1) setBufferOpenAl(busDataOne,posBufferTwo); #endif } else if (posBufferTwo &gt; 0) { if (isWavFileOutput == 1) writeDataBlockWavFile(busDataTwo,posBufferTwo); #if SDB_WITH_OPENAL == 1 if (isAudioOutput == 1) setBufferOpenAl(busDataTwo,posBufferTwo); #endif } if (isWavFileOutput == 1) closeWavFile(); isCreateWavFileFlag = 0; #if SDB_WITH_OPENAL == 1 if (isAudioOutput == 1) { while (1) { // ,      if (updateOpenAl() == 0) break; } closeOpenAlSound(); destroyOpenAL(); } #endif } } //      one wire void sdb::oneWireSendByte(unsigned char data) { for (register unsigned char i = 0; i &lt; 8; i++) { if((data &amp; (1 &lt;&lt; i)) == 1 &lt;&lt; i) { busState = 0; busDelay(12); busState = SDB_MAX_DATA; busDelay(65); } else { busState = 0; busDelay(65); busState = SDB_MAX_DATA; busDelay(12); } } busState = SDB_MAX_DATA; } //       uart void sdb::uartSendByte(unsigned char data) { unsigned short pBit = 0; //     //   busState = SDB_MAX_DATA; busDelay(uartT); busState = -SDB_MAX_DATA; //  for (register unsigned char i = 0; i &lt; 8; i++) { if((data &amp; (1&lt;&lt;i)) == 1&lt;&lt;i) { busState = -SDB_MAX_DATA; busDelay(uartT); busState = -SDB_MAX_DATA; pBit++; } else { busState = SDB_MAX_DATA; busDelay(uartT); busState = -SDB_MAX_DATA; } } //   if (uartParityBit != 0) { if ((pBit &amp; 0x0001) == 0) { busState = -SDB_MAX_DATA; busDelay(uartT); busState = -SDB_MAX_DATA; } else { busState = SDB_MAX_DATA; busDelay(uartT); busState = -SDB_MAX_DATA; } } //   busState = -SDB_MAX_DATA; for (register unsigned char i = 0; i &lt; uartStopBit; i++) busDelay(uartT); busState = -SDB_MAX_DATA; } //      uart void sdb::uartSend(unsigned long data) { unsigned short pBit = 0; //     //   busState = SDB_MAX_DATA; busDelay(uartT); busState = -SDB_MAX_DATA; //  for (register unsigned char i = 0; i &lt; uartBit; i++) { if((data &amp; (1&lt;&lt;i)) == 1&lt;&lt;i) { busState = -SDB_MAX_DATA; busDelay(uartT); busState = -SDB_MAX_DATA; } else { busState = SDB_MAX_DATA; busDelay(uartT); busState = -SDB_MAX_DATA; } } //   if (uartParityBit != 0) { if ((pBit &amp; 0x0001) == 0) { busState = -SDB_MAX_DATA; busDelay(uartT); busState = -SDB_MAX_DATA; } else { busState = SDB_MAX_DATA; busDelay(uartT); busState = -SDB_MAX_DATA; } } //   busState = -SDB_MAX_DATA; for (register unsigned char i = 0; i &lt; uartStopBit; i++) busDelay(uartT); busState = -SDB_MAX_DATA; } //    UART void sdb::uartSetBaudrate(unsigned long baudrate) { if (baudrate &gt; SDB_UART_BAUDRATE_MAX) baudrate = SDB_UART_BAUDRATE_MAX; uartBaudrate = baudrate; uartT = 1000000 / baudrate; } void sdb::uartSetBit(unsigned char bit) { if (bit &gt; 32) bit = 32; if (bit == 0) bit = 1; if (bit &lt; 8) bit = 8; uartBit = bit; } void sdb::uartSetStopBit(unsigned char bit) { if (bit == 0) bit = 1; uartStopBit = bit; } void sdb::uartSetParityBit(unsigned char state) { if (state &gt; 1) state = 1; uartParityBit = state; } //       void sdb::oneWireReset(void) { busState = SDB_MAX_DATA; busDelay(100); busState = 0;// "0" busDelay(485);//  480 busState = SDB_MAX_DATA; busDelay(65);//  60      busState = 0;// "0" busDelay(400); busState = SDB_MAX_DATA; busDelay(100); } //    1-wire void sdb::oneWireStop(void) { if (isCreateWavFileFlag == 1) { if (posBufferOne &gt; 0) { if (isWavFileOutput == 1) writeDataBlockWavFile(busDataOne,posBufferOne); #if SDB_WITH_OPENAL == 1 if (isAudioOutput == 1) setBufferOpenAl(busDataOne,posBufferOne); #endif } else if (posBufferTwo &gt; 0) { if (isWavFileOutput == 1) writeDataBlockWavFile(busDataTwo,posBufferTwo); #if SDB_WITH_OPENAL == 1 if (isAudioOutput == 1) setBufferOpenAl(busDataTwo,posBufferTwo); #endif } #if SDB_WITH_OPENAL == 1 while (1) { // ,      if (updateOpenAl() == 0) break; } closeOpenAlSound(); destroyOpenAL(); #endif if (isWavFileOutput == 1) closeWavFile(); isCreateWavFileFlag = 0; } } void sdb::uartStop(void) { if (isCreateWavFileFlag == 1) { if (posBufferOne &gt; 0) { if (isWavFileOutput == 1) writeDataBlockWavFile(busDataOne,posBufferOne); #if SDB_WITH_OPENAL == 1 if (isAudioOutput == 1) setBufferOpenAl(busDataOne,posBufferOne); #endif } else if (posBufferTwo &gt; 0) { if (isWavFileOutput == 1) writeDataBlockWavFile(busDataTwo,posBufferTwo); #if SDB_WITH_OPENAL == 1 if (isAudioOutput == 1) setBufferOpenAl(busDataTwo,posBufferTwo); #endif } #if SDB_WITH_OPENAL == 1 if (isAudioOutput == 1) { while (1) { // ,      if (updateOpenAl() == 0) break; } closeOpenAlSound(); destroyOpenAL(); } #endif if (isWavFileOutput == 1) closeWavFile(); isCreateWavFileFlag = 0; } } void sdb::setWavFileName(char* filename) { strcat(wavFileName,filename); } void sdb::playAudioOn(void) { if (isCreateWavFileFlag == 0) isAudioOutput = 1; } void sdb::playAudioOff(void) { if (isCreateWavFileFlag == 0) isAudioOutput = 0; } void sdb::recordOn(void) { if (isCreateWavFileFlag == 0) isWavFileOutput = 1; } void sdb::recordOff(void) { if (isCreateWavFileFlag == 0) { if (isAudioOutput == 1) isWavFileOutput = 0; else isWavFileOutput = 1; } }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Archivo main.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H_INCLUDED #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H_INCLUDED #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> LINUX 0x00 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> WINDOWS 0x01 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RU 0x00 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> EN 0x01 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">///    #define TYPE_OS WINDOWS ///   #define LANGUAGE_PROGRAM RU #define UART_BUS 0x01 #define ONE_WIRE_BUS 0x02 #include &lt;iostream&gt; #include "SoundsDigitalBus.h" #include "stdlib.h" #include &lt;stdio.h&gt; #endif // MAIN_H_INCLUDED</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Archivo main.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> sdb soundsDigitalBus; int main() { static FILE *fp = NULL; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//    char strData[512]; //    char strChar = 0; //  unsigned char busType; //    int strPos = 0; //    int uartBaudrate = 0; //  UART int uartBit = 8; int uartStopBit = 0; //int uartParityBit = 0; #if TYPE_OS==WINDOWS and LANGUAGE_PROGRAM==RU setlocale(LC_ALL, "Russian"); printf("  UART  ,   0,   1-wire.\n"); #else printf("Enter the UART baud rate, or specify 0 if you want 1-wire.\n"); #endif printf("UART Baudrate: "); memset(strData,0,512); while(1) { strChar = getchar(); if ((strChar &gt;= '0') &amp;&amp; (strChar &lt;= '9')) { strData[strPos++] = strChar; } else break; } uartBaudrate = atoi(strData); if (uartBaudrate == 0) { busType = ONE_WIRE_BUS; } else { busType = UART_BUS; soundsDigitalBus.uartSetBaudrate(uartBaudrate); } printf("\n"); if (busType == UART_BUS) { #if TYPE_OS==WINDOWS and LANGUAGE_PROGRAM==RU printf("   UART\n"); #else printf("Enter the number of bits UART.\n"); #endif printf("UART bit: "); memset(strData,0,512); while(1) { strChar = getchar(); if ((strChar &gt;= '0') &amp;&amp; (strChar &lt;= '9')) { strData[strPos++] = strChar; } else break; } uartBit = atoi(strData); soundsDigitalBus.uartSetBit(uartBit); printf("\n"); #if TYPE_OS==WINDOWS and LANGUAGE_PROGRAM==RU printf("    UART\n"); #else printf("Enter the number of stop bits UART.\n"); #endif printf("UART stop bit: "); memset(strData,0,512); while(1) { strChar = getchar(); if ((strChar &gt;= '0') &amp;&amp; (strChar &lt;= '9')) { strData[strPos++] = strChar; } else break; } uartStopBit = atoi(strData); soundsDigitalBus.uartSetStopBit(uartStopBit); printf("\n"); #if TYPE_OS==WINDOWS and LANGUAGE_PROGRAM==RU printf("    UART? (Y/n)\n"); #else printf("Use the parity bit in the UART? (Y/n)\n"); #endif strChar = getchar(); if ((strChar == 'n') || (strChar == 'N') || (strChar == '') || (strChar == '')) { soundsDigitalBus.uartSetParityBit(0); printf("not used\n"); } else { soundsDigitalBus.uartSetParityBit(1); printf("Yes, use\n"); } getchar(); printf("\n"); } FILE_M: printf("\n"); #if TYPE_OS==WINDOWS printf("        .\n"); printf(": D: \\ Games \\ SR2 \\ Rangers.txt\n"); printf(": "); #else printf("Specify the file to convert it to record digital bus.\n"); printf("For example: D: \\ Games \\ SR2 \\ Rangers.txt\n"); printf("File: "); #endif memset(strData,0,512); strPos = 0; while(1) { strChar = getchar(); if (strChar != '\n') { strData[strPos++] = strChar; } else break; } fp = fopen(strData,"rb"); if (fp == NULL) { printf("\n"); #if TYPE_OS==WINDOWS printf("!  %s  !\n",strData); printf("     .\n"); printf("...\n"); #else printf("Error! File %s not found!\n",strData); printf("Try to correctly specify the path to the file.\n"); printf("...\n"); #endif getchar(); goto FILE_M; } //soundsDigitalBus.setWavFileName(strData); printf("\n"); #if SDB_WITH_OPENAL == 1 #if TYPE_OS==WINDOWS printf("      ? (Y/n)\n"); #else printf("Play audio while working digital bus? (Y/n)\n"); #endif strChar = getchar(); if ((strChar == 'n') || (strChar == 'N') || (strChar == '') || (strChar == '')) { soundsDigitalBus.playAudioOff(); printf("not used\n"); } else { soundsDigitalBus.playAudioOn(); printf("Yes, use\n"); } getchar(); printf("\n"); #if TYPE_OS==WINDOWS printf("      ? (Y/n)\n"); #else printf("Record audio while working digital bus? (Y/n)\n"); #endif strChar = getchar(); if ((strChar == 'n') || (strChar == 'N') || (strChar == '') || (strChar == '')) { soundsDigitalBus.recordOff(); printf("not used\n"); } else { soundsDigitalBus.recordOn(); printf("Yes, use\n"); } getchar(); #else soundsDigitalBus.recordOn(); #endif printf("\n"); #if TYPE_OS==WINDOWS printf(" .\n"); #else printf("The transformation started.\n"); #endif unsigned char uartData[8]; if (busType == ONE_WIRE_BUS) { soundsDigitalBus.oneWireReset(); } while(1) { if (fread(uartData,sizeof(unsigned char),1,fp) &gt; 0) { if (busType == UART_BUS) { if (uartBit == 8) { soundsDigitalBus.uartSendByte(uartData[0]); } else { soundsDigitalBus.uartSend(uartData[0]); } } else if (busType == ONE_WIRE_BUS) { soundsDigitalBus.oneWireSendByte(uartData[0]); } } else break; } fclose(fp); if (busType == ONE_WIRE_BUS) { soundsDigitalBus.oneWireStop(); } else if (busType == UART_BUS) { soundsDigitalBus.uartStop(); } #if TYPE_OS==WINDOWS printf(" .\n"); #else printf("Conversion completed.\n"); #endif return 0; //soundsDigitalBus.oneWireReset(); soundsDigitalBus.uartSetBaudrate(1200); for (int i = 0; i &lt; 256; i ++) { for (int len = 0; len &lt; 8; len++) { soundsDigitalBus.uartSendByte(i); } printf("%d\n",i); } soundsDigitalBus.oneWireStop(); return 0; }</span></span></span></span></code> </pre><br></div></div><br>  <b>PD</b> : Not√© un error que en el c√≥digo fuente el bit de inicio es l√≥gico 1, no 0, y el bit de parada es 0, no 1. Quien necesita una coincidencia b√°sica de la se√±al de sonido de la realidad puede corregir el error en s√≠. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es408485/">https://habr.com/ru/post/es408485/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es408475/index.html">Como llegu√© al monociclo</a></li>
<li><a href="../es408477/index.html">"Maldita sea, un error gigante vol√≥ sobre m√≠": lanzamiento del SDK para sonido envolvente</a></li>
<li><a href="../es408479/index.html">Cient√≠ficos: debido a que Pok√©mon Go en un accidente de tr√°fico mat√≥ a miles de personas en todo el mundo</a></li>
<li><a href="../es408481/index.html">Teor√≠as y aspiradoras</a></li>
<li><a href="../es408483/index.html">Aprendemos ingl√©s de los juegos de computadora.</a></li>
<li><a href="../es408487/index.html">No habr√° sellos sin nuevos gadgets: YouTube dejar√° de funcionar en dispositivos antiguos-2</a></li>
<li><a href="../es408489/index.html">Un juguete o no. ¬øQu√© pasa con el cine interactivo?</a></li>
<li><a href="../es408491/index.html">Lanzamiento de ICO Descrow hoy</a></li>
<li><a href="../es408493/index.html">Los pa√≠ses m√°s "amigables con Bitcoin" del mundo</a></li>
<li><a href="../es408495/index.html">El fideicomiso y su evoluci√≥n en custodia descentralizada</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>