<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôåüèº üåÑ ‚û∞ Come√ßamos a estudar microcontroladores usando o exemplo de STM32F030f4p6 üë®‚Äç‚öñÔ∏è ‚ñ´Ô∏è ‚ôåÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="0. Antes de ler o artigo 
 Este artigo tem os seguintes objetivos: 



1. mostre como trabalhar especificamente com este quadro; 
2. mostre a abordage...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Come√ßamos a estudar microcontroladores usando o exemplo de STM32F030f4p6</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437234/"><img src="https://habrastorage.org/webt/ex/dh/0-/exdh0-6tdd7sj-4usxbip9chsz0.jpeg"><br><br><h1>  0. Antes de ler o artigo </h1><br>  Este artigo tem os seguintes objetivos: <br><br><ol><li>  mostre como trabalhar especificamente com este quadro; </li><li>  mostre a abordagem pela qual voc√™ pode escrever um programa de LED piscando, confiando apenas na documenta√ß√£o e na l√≥gica; </li><li>  Apresente o material em um idioma compreens√≠vel para uma pessoa pouco familiarizada com os microcontroladores. </li></ol><br>  O c√≥digo ser√° minimalista em termos de uso de arquivos adicionais - n√£o incluiremos um √∫nico arquivo, exceto os necess√°rios para criar um firmware vazio, mas v√°lido.  I.e.  com base no c√≥digo do firmware, que funciona, mas n√£o faz nada √∫til. <br><a name="habracut"></a><br>  Vamos precisar da seguinte documenta√ß√£o: <br><br><ol><li>  Folha de dados STM32F030x4 (eu uso o documento de janeiro de 2017 DocID024849 Rev 3); </li><li>  RM0360 Manual de refer√™ncia STM32F030x4 / x6 / x8 / xC (eu uso o documento de abril de 2017 DocID025023 Rev 4); </li><li>  placa de circuito. </li></ol><br>  Voc√™ pode baixar esses documentos da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">nuvem</a> . <br>  O cron√¥metro no artigo <i>n√£o</i> ser√° considerado e <i>n√£o</i> estar√° envolvido no c√≥digo. <br>  O programador ST-LINK <i>n√£o</i> foi usado.  Para trabalhar com a placa, foi utilizado um adaptador USB-COM (RS232 baseado em PL2303HX), que emula uma porta COM. <br><br><div class="spoiler">  <b class="spoiler_title">Adaptador de foto</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/wp/em/u8/wpemu8n1juvbuipavxu-mzfa2eq.jpeg"></div></div><br>  Tudo foi coletado em uma m√°quina virtual do Windows XP Professional 2002 SP3 executando o VirtualBox vers√£o 5.2.22r126460 em um host do Windows X. <br><br><h1>  1. Instalando o driver para o adaptador USB-COM </h1><br>  O Windows n√£o ajuda, fa√ßa o download no site oficial <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Prolific</a> (o primeiro link para a solicita√ß√£o de "driver prol√≠fico" no Google) USB para UART / Serial / Printer <b>PL2303 Windows Driver</b> (voc√™ precisa daquele <i>Driver Padr√£o</i> ).  Ou voc√™ pode baixar da minha <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">nuvem</a> . <br><br>  Instale o driver, reinicie e veja a nova porta COM. <br><br><div class="spoiler">  <b class="spoiler_title">Captura de tela com o nome do instalador e a nova porta COM</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/tq/tt/dh/tqttdhvov6eiov75df-pqcycz0s.png"></div></div><br>  As configura√ß√µes da porta deixaram o padr√£o.  Voc√™ pode alterar o n√∫mero da porta COM a seu crit√©rio.  Na minha experi√™ncia, apenas uma vez na vida vi um programa ver apenas as 4 primeiras portas COM; se n√£o me engano, era algum tipo de terminal Bluetooth no Windows. <br><br><div class="spoiler">  <b class="spoiler_title">Configura√ß√µes da porta COM</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/ak/ad/ep/akadepan2w3tldshsr6sys69jo4.png"><br></div></div><br><h1>  2. Preenchendo o firmware dentro e fora da placa </h1><br><h2>  2.0 Utilit√°rio de download para trabalhar com o quadro </h2><br>  Fazemos o download do utilit√°rio <b>FLASHER-STM32</b> no site do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">STM</a> (na descri√ß√£o √© chamado de demonstrador de carregador STM32 Flash (UM0462)), voc√™ dever√° se registrar para isso, mas n√£o √© assustador - no final, removeremos o arquivo zip com o instalador;  Pr√≥ximo-&gt; Pr√≥ximo-&gt; Pr√≥ximo ... e tudo est√° instalado.  Por conveni√™ncia, crio um atalho para esse aplicativo na pasta de trabalho. <br><br><div class="spoiler">  <b class="spoiler_title">Aqui est√° o utilit√°rio (captura de tela do site)</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/oa/4a/xz/oa4axzxm4eljcbpzubyspqghcbe.png"><br></div></div><br>  Por padr√£o, o caminho para o utilit√°rio <i>C: Arquivos de Programas \ STMicroelectronics \ Software \ Flash Loader Demo \ STMFlashLoader Demo.exe</i> . <br><br><h2>  2.1 nuance de inicializa√ß√£o </h2><br>  H√° um jumper BOOT no quadro. <br><br><ul><li>  Quando o jumper √© <b>fechado</b> , o microcontrolador carrega instru√ß√µes da mem√≥ria (ou seja, um programa escrito por um programador). </li><li>  Quando o jumper est√° <b>aberto</b> , o microcontrolador receber√° informa√ß√µes nas linhas RX e TX, ou seja,  Ele piscar√° na porta COM (do adaptador no meu caso). </li></ul><br><h2>  2.2 Configurando o utilit√°rio </h2><br><img src="https://habrastorage.org/webt/pu/oc/h3/puoch3mqjkqfryjvcnxfg9zeycq.png"><br><br>  Execute este aplicativo, ele √© realmente o mais simples (cont√©m um m√≠nimo de configura√ß√µes).  Na primeira janela, selecione: <br><br><ol><li>  interface (eu tenho COM-3); </li><li>  a velocidade com a qual o computador e o microcontrolador se comunicar√£o (IMHO, valor normal de 9600); </li><li>  o n√∫mero de bits de dados (por algum motivo, essa janela n√£o est√° dispon√≠vel para mim, mas at√© agora isso n√£o √© importante); </li><li>  paridade (n√£o tenho paridade, ou seja, Nenhuma); </li><li>  eco (desativei); </li><li>  tempo de espera (eu tenho 10 segundos). </li></ol><br>  Clique em Avan√ßar e, se tudo estiver em ordem, veremos uma luz verde e "O alvo est√° leg√≠vel";  se virmos uma luz vermelha, o computador n√£o p√¥de se conectar. <br><br><div class="spoiler">  <b class="spoiler_title">O alvo √© leg√≠vel se o microcontrolador for detectado com sucesso</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/gd/9y/hw/gd9yhwnpu15asiupizayeozvsfo.png"><br></div></div><br>  A ordem das etapas que sempre ajudam: <br><br><ol><li>  Primeiro, voc√™ precisa verificar se o jumper BOOT na placa est√° fechado. </li><li>  Em segundo lugar, em qualquer caso, desligue a energia do microcontrolador e, de prefer√™ncia, as linhas TX e RX vindas do adaptador para a placa (voc√™ n√£o pode desconectar o terra). </li><li>  Em terceiro lugar, no programa, pressione Voltar at√© o fim, ou seja,  para a primeira p√°gina, ou at√© fech√°-la e reinici√°-la (em geral, √†s vezes congela)  √â importante come√ßar sempre da primeira p√°gina antes de cada conex√£o √† placa atrav√©s deste programa. </li><li>  Quarto, pegue os fios do adaptador na placa e tente conectar-se novamente no programa (certifique-se da primeira p√°gina!). </li></ol><br>  Se tudo mais falhar, tente desligar tudo, reinicie o computador e reconecte-se √† placa. <br><br>  Porque  Trabalho em uma m√°quina virtual, preciso reconectar o adaptador USB-COM v√°rias vezes para que seja detectado pela m√°quina virtual e a m√°quina host n√£o tenha tempo para instalar drivers danificados. <br><br>  Outra op√ß√£o que encontrei trabalhando enquanto escrevia este artigo √© pressionar um bot√£o no quadro em vez de puxar constantemente os fios.  No entanto, voc√™ precisar√° fechar e abrir o jumper BOOT em qualquer caso.  Esta op√ß√£o funciona porque o bot√£o √© colocado no p√© da redefini√ß√£o <abbr title="RESULTADO EXTERNO">NRST</abbr> externa. <br><br>  Na pr√≥xima janela, selecione o dispositivo de destino Destino.  A prop√≥sito, √†s vezes aqui voc√™ pode ver (talvez um bug) o dispositivo esquerdo em geral, por exemplo, em vez de STM32 ver STM8 - em algum lugar houve algum tipo de falha, o procedimento de tratamento √© descrito acima.  Portanto, nesta etapa, voc√™ n√£o pode se apressar em clicar em Avan√ßar, mas sempre preste aten√ß√£o no fato de que o dispositivo desejado est√° selecionado no Target. <br><br><div class="spoiler">  <b class="spoiler_title">Sele√ß√£o de dispositivo de destino</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/zz/p8/83/zzp88341ayrb95ymtn1bf3-elvq.png"><br></div></div><br>  Como determinar qual dispositivo temos?  - olhamos para o chip e reescrevemos tudo o que est√° escrito nele.  Abrimos a <i>folha</i> de <i>dados</i> em nosso chip, a se√ß√£o <i>Informa√ß√µes sobre pedidos</i> descreve qual letra √© respons√°vel por qu√™.  No meu caso √©: <br><br><img src="https://habrastorage.org/webt/pa/kn/ga/pakngat6l5tahlk-y75nledccuy.png"><img src="https://habrastorage.org/webt/f0/fb/jk/f0fbjkrbe8a-g5uqbjdovxzr_fc.png"><br><br><div class="spoiler">  <b class="spoiler_title">Seleciono meu chip (16K) no Target e seguirei em frente.</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/qs/u4/v2/qsu4v2uhtvft1sj1uhp2bnount4.png"><br></div></div><br>  √â oferecida uma escolha de 4 a√ß√µes com um chip: <br><br><ol><li>  apagar mem√≥ria (inteira ou selecionar uma √°rea espec√≠fica); </li><li>  escreva o firmware no dispositivo; </li><li>  leia o firmware do dispositivo; </li><li>  ativar / desativar a prote√ß√£o contra grava√ß√£o ou leitura. </li></ol><br><h2>  2.3 Leia o firmware do quadro </h2><br>  Quando conectei a placa pela primeira vez, decidi manter o firmware original, uma esp√©cie de backup - faremos isso agora.  Ser√° necess√°rio indicar onde salvar este firmware e quais p√°ginas de mem√≥ria salvar; tamb√©m √© proposto o uso de um formato de arquivo <i>hex</i> , <i>bin</i> ou <i>s19</i> para sua <i>escolha</i> . <br><br><div class="spoiler">  <b class="spoiler_title">Selecione as p√°ginas de mem√≥ria para ler</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/b_/vs/yq/b_vsyqyslqo1sib02nymmymvy_m.png"><br></div></div><br>  Se voc√™ acabou de fazer o upload do firmware para a placa ou ler o firmware da placa, n√£o haver√° diferen√ßa entre esses formatos de arquivo.  A seguir, √© apresentada uma p√°gina de progresso, na qual, √†s vezes, o processo congela por 99% por um longo tempo (n√£o necessariamente 99), mas ap√≥s alguns segundos ele supostamente √© conclu√≠do com √™xito - na verdade, depois disso, a placa n√£o divulgou o comportamento que corresponderia ao firmware carregado.  Simplificando, voc√™ precisa reconectar tudo e reencher o firmware, n√£o h√° nada cr√≠tico nisso. <br><br>  O arquivo do firmware foi salvo e, no futuro, poder√° ser carregado na placa. <br><br>  No entanto, se a prote√ß√£o de leitura estiver instalada, o firmware n√£o poder√° ser lido. <br><br><div class="spoiler">  <b class="spoiler_title">Janela de progresso</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/nb/ta/rs/nbtarsmjtb1-ylmcxaesykldlv0.png"><br></div></div><br><h2>  2.4 Piscando o quadro </h2><br>  Agora preencha o arquivo de firmware, cuja escrita do c√≥digo fonte √© fornecida abaixo.  Olhando para o futuro, direi que enviaremos arquivos <i>bin</i> e <i>hex</i> , porque  o ambiente de desenvolvimento os emitir√°.  Configura√ß√µes adicionais para arquivos <i>s19</i> e <i>hexadecimais</i> s√£o id√™nticas;  ao contr√°rio deles, no arquivo <i>bin</i> , voc√™ pode selecionar o endere√ßo no qual o firmware ser√° gravado; por padr√£o, no utilit√°rio √© 8000000 (adequado para n√≥s). <br><br><div class="spoiler">  <b class="spoiler_title">Preparando para gravar</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/1k/u8/cf/1ku8cfxnzt_bjob1szyix3u2xpw.png"><br></div></div><br>  Antes da grava√ß√£o, voc√™ pode limpar a mem√≥ria flash do microcontrolador escolhendo uma das tr√™s op√ß√µes: <br><br><ul><li>  Apague as p√°ginas necess√°rias (limpe as se√ß√µes necess√°rias da mem√≥ria); </li><li>  Sem apagamento (sem purifica√ß√£o); </li><li>  Apagamento global (limpeza completa). </li></ul><br>  De fato, a limpeza √© o processo de gravar zeros na mem√≥ria. <br><br>  Ainda existem bytes opcionais, mas at√© agora voc√™ n√£o pode toc√°-los.  Clique em Avan√ßar, aguarde a conclus√£o do processo e pronto. <br><br>  Caso queira gravar meu firmware, voc√™ pode encontr√°-lo na nuvem, o arquivo <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">blink.bin</a></i> .  Ao usar este firmware, o LED embutido que pisca no p√© PA4 deve piscar. <br><br><h1>  3. Escrita de c√≥digo </h1><br><h2>  3.0 Instalando o ambiente de desenvolvimento CooCox CoIDE </h2><br>  Voc√™ pode fazer o download do IDE no site da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SoftPedia.com</a> , antes de poder baix√°-lo no site do STM e no pr√≥prio site do IDE, mas como os IDEs deixaram de ser compat√≠veis, tornou-se imposs√≠vel.  N√£o h√° nada cr√≠tico que o IDE n√£o seja mais suportado, n√£o, porque  para escrever c√≥digo, o principal √© o compilador.  Baixei as duas vers√µes, mas uso a vers√£o 1.7.8. <br>  O primeiro lan√ßamento do ambiente est√° bem descrito <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> , Pr√≥ximo-&gt; Pr√≥ximo-&gt; Pr√≥ximo ... e nada complicado.  Acrescentarei apenas que primeiro √© melhor criar um projeto e depois todo o resto. <br><br>  E, no entanto, se voc√™ perdeu a guia Reposit√≥rio, pode encontr√°-la no menu <i>Exibir -&gt; Reposit√≥rio</i> . <br>  Voc√™ pode baixar ferramentas (compilador) para o ambiente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> ou pedir ao Google "gnu tools for arm";  Eu baixei uma op√ß√£o que tem sha1.exe no final. <br><br><h2>  3.1 Estrutura de origem </h2><br>  Assim, o projeto foi criado, o chip foi selecionado, agora vamos adicionar o conjunto m√≠nimo de fontes ao projeto, sem o qual ele n√£o poder√° viver sem. <br><br><div class="spoiler">  <b class="spoiler_title">√â assim que o projeto deve ficar quando for criado, ou seja,</b>  <b class="spoiler_title">existe apenas o arquivo main.c principal e nada mais</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/db/rf/qh/dbrfqhef0pg7j3perjtzm3b3okc.png"><br></div></div><br>  <b>Selecione CMSIS BOOT</b> e o ambiente <b>selecionar√°</b> automaticamente <b>M0 Cmsis Core</b> , porque  depend√™ncias exigem isso. <br><br><div class="spoiler">  <b class="spoiler_title">Agora temos o conjunto m√≠nimo de fontes</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/fk/u8/qt/fku8qtl8uhcttxq_xswbovf-10c.png"><br></div></div><br>  Monte o projeto (√≠cone Compilar ou tecla F7).  Por motivos desconhecidos para mim, o arquivo hexadecimal n√£o foi coletado (h√° um aviso no console);  Reinstalei o IDE e o compilador v√°rias vezes, recriei o projeto, mas por algum motivo esse resultado foi feito na m√°quina virtual;  em outro computador (n√£o virtual, mas real), tudo √© individual e a sa√≠da est√° funcionando hexadecimal.  Felizmente, h√° bin. <br><br><div class="spoiler">  <b class="spoiler_title">O projeto foi montado com sucesso</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/ap/zn/ct/apznctscxqdbgullp11rzqxtyj4.png"><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Aconselho que voc√™ preste aten√ß√£o ao tamanho do arquivo, ele pode ser visto no final da sa√≠da no console ou voc√™ pode v√™-lo por meios padr√£o (aqui, a prop√≥sito, voc√™ pode ver que hex est√° vazio);</b>  <b class="spoiler_title">Ao mesmo tempo, esta captura de tela mostra que os arquivos de firmware est√£o na pasta do projeto e, em seguida, Debug / bin /</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/ho/ue/wd/houewdyn-cyjvmn-js5sbah-yru.png"><br></div></div><br>  Embora o c√≥digo n√£o fa√ßa nada, carrego-o no quadro para garantir que voc√™ possa carreg√°-lo (que, por exemplo, o utilit√°rio n√£o o rejeita).  Aconselho o leitor a fazer isso.  Se n√£o funcionar, tente novamente e escreva coment√°rios. <br><br><h2>  3.2 Algoritmo de Dedo </h2><br>  Para come√ßar, esbo√ßamos um algoritmo de como, do ponto de vista humano, o microcontrolador pisca um LED.  E por isso um pouco de racioc√≠nio. <br><br>  Cada equipamento funciona devido √† energia armazenada, por exemplo, alguns motores podem funcionar com diferentes tipos de combust√≠vel, mas, para isso, o motor precisa ser ajustado ao tipo de combust√≠vel com o qual vamos aliment√°-lo.  Da mesma forma, o microcontrolador precisa ser ajustado (sintonizado) para a fonte de energia - este ser√° o <i>primeiro bloco do</i> algoritmo. <br>  N√≥s raciocinamos mais.  O computador de mesa possui um monitor, alto-falantes, teclado, mouse ... e voc√™ pode ver que alguns dispositivos nos fornecem informa√ß√µes e, com a ajuda de outros, fornecemos informa√ß√µes ao computador, mas todos eles est√£o conectados a uma caixa comum a todos eles (a unidade de sistema).  Voc√™ pode adivinhar que o microcontrolador pode receber e fornecer informa√ß√µes, o que significa que suas pernas podem receber um sinal ou emitir um sinal - este ser√° o <i>pr√≥ximo bloco do</i> algoritmo. <br><br>  Em seguida, o microcontrolador deve acender o LED, aguardar um pouco, desligar o LED, aguardar um pouco e lig√°-lo-esperar-desligar ... <br><br>  Como resultado, o algoritmo ser√° mais ou menos assim <br><br><img src="https://habrastorage.org/webt/h1/m4/oo/h1m4oou5txdafrybbwobj69vahm.png" height="361" width="192"><br><br>  O objetivo deste fluxograma √© mostrar claramente o que o algoritmo faz;  Primeiro de tudo, o esquema √© escrito para voc√™, para que todos sejam livres para escrev√™-lo / desenh√°-lo como quiser (por si mesmo).  Eu acredito que o esquema deve ter como objetivo ser o mais simples, leg√≠vel e intuitivo poss√≠vel, ter um alto n√≠vel de abstra√ß√£o. <br><br>  De acordo com este algoritmo, escreveremos c√≥digo. <br><br><h2>  3.3 Trabalhando com documenta√ß√£o </h2><br>  Eu recomendo a leitura desta parte do artigo com o arquivo aberto <i>stm32f0xx.h</i> , que fica na pasta <i>cmsis_boot</i> do nosso projeto e na documenta√ß√£o aberta. <br><br><h3>  3.3.1 Selecionando uma fonte de rel√≥gio </h3><br>  Primeiro, voc√™ precisa fornecer energia ao microcontrolador.  O microcontrolador recebe 5 Volts do adaptador (medido com um mult√≠metro), mas surge a quest√£o de "em que frequ√™ncia o microcontrolador trabalha", porque √© sabido que a eletr√¥nica funciona em diferentes frequ√™ncias.  Primeiro, abra a <i>folha de dados</i> ; no conte√∫do, voc√™ pode ver duas se√ß√µes relevantes em significado: <i>Gerenciamento de energia</i> , <i>Rel√≥gios e inicializa√ß√£o</i> .  O primeiro √© sobre os modos de tens√£o e baixa pot√™ncia.  A segunda se√ß√£o esconde o que nos interessa no momento.  J√° na primeira frase, ele diz que ‚Äúo oscilador RC 8 MHz interno √© selecionado como clock padr√£o da CPU na reinicializa√ß√£o‚Äù, o que significa que, <i>por padr√£o, ap√≥s a redefini√ß√£o do MC, a cadeia RC interna de 8 MHz</i> √© selecionada como a <i>principal fonte de clock</i> . <br>  Em seguida, vem um esquema incompreens√≠vel de √°rvore do Rel√≥gio, que consideraremos um pouco mais tarde. <br><a name="Clock_tree"></a><br><br><div class="spoiler">  <b class="spoiler_title">√Årvore do rel√≥gio</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/sg/nl/ul/sgnlul1krp_mdiqntf5it8a0eni.png"></div></div><br>  A rigor, voc√™ pode confiar na frase "por padr√£o, ap√≥s redefinir o MK ..." e ler esta parte do artigo na diagonal. <br><br>  Agora voc√™ precisa se distrair com a placa e procurar o LED interno.  Eu sei que os diodos nos circuitos s√£o indicados por <i>D1</i> , <i>D2</i> ..., ou seja,  <i>D == diodo</i> , na minha placa perto do resistor <i>R7</i> √© o diodo <i>D1</i> . <br><br><div class="spoiler">  <b class="spoiler_title">Foto do quadro</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/ma/ze/ke/mazekeve26x9-imexuqb2k1knb8.png" width="462" height="330"><br></div></div><br>  Talvez, depois de examinar cuidadosamente a placa, voc√™ possa tra√ßar em qual perna o diodo est√° conectado, mas voltarei para a placa de circuito.  Infelizmente, os elementos do quadro n√£o correspondem exatamente aos elementos do circuito em sua localiza√ß√£o;  mas fico feliz por ter encontrado esse esquema na Internet (caso contr√°rio, n√£o conseguiria encontrar nada por um longo tempo). <br><br><img src="https://habrastorage.org/webt/id/gz/tw/idgztwbtwraskhguvq-9alkrp18.png"><br><br>  No diagrama, vemos que o c√°todo do diodo √© conectado ao terra atrav√©s do jumper <i>J2</i> , e o √¢nodo √© conectado ao pino <i>PA4</i> atrav√©s de um resistor.  <i>PA4</i> significa a quarta sa√≠da da porta <i>A</i> , o que significa que, para acender e desligar o LED, ser√° necess√°rio fornecer tens√£o √† sa√≠da do <i>PA4</i> . <br><br>  Em seguida, voc√™ precisa determinar como aplicar tens√£o a esta sa√≠da.  Isso n√£o foi nada intuitivo para mim e, durante muito tempo, vasculhei a documenta√ß√£o longitudinalmente at√© encontrar o <b>diagrama de blocos</b> na se√ß√£o <i>Descri√ß√£o</i> , no in√≠cio da folha de dados.  E nele vi a preciosa faixa <i>PA [15: 0] &lt;=&gt; porta GPIO A &lt;=&gt; decodificador AHB &lt;=&gt; Bus matrix &lt;=&gt; Cortex-M0</i> , ou seja,  <i>A</i> porta <i>A</i> √© uma porta de E / S de uso geral e est√° conectada ao barramento <abbr title="Barramento avan√ßado de alto desempenho"><i>AHB</i></abbr> . <br><br><div class="spoiler">  <b class="spoiler_title">Diagrama de blocos</b> <div class="spoiler_text">  (A imagem √© clic√°vel) <br> <a href=""><img src="https://habrastorage.org/webt/_e/hf/d0/_ehfd0kdf5v87xxud5yj4abp3xu.png"></a> <br></div></div><br>  Observo que na eletr√¥nica √© habitual dividir as sa√≠das do microcontrolador em portas, e geralmente a porta possui 16 sa√≠das.  O diagrama mostra que as portas <i>A</i> , <i>B</i> e <i>C</i> t√™m apenas 16, mas as portas <i>D</i> e <i>F</i> t√™m menos (menos de 16 pinos podem ser, mais - n√£o). <br><br>  Vamos voltar ao esquema da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">√°rvore</a> do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">rel√≥gio</a> e encontrar a sa√≠da assinada pelo <i>AHB</i> .  Vamos descobrir com que frequ√™ncia essa sa√≠da funciona.  Para o <i>AHB est√°</i> o sinal <i>HCLK</i> , que sai do divisor <i>HPRE</i> .  Este divisor recebe o sinal <abbr title="REL√ìGIO DE SISTEMA"><i>SYSCLK</i></abbr> do comutador <abbr title="Rel√≥gio do sistema sWitch"><i>SW</i></abbr> .  Quais dos sinais na entrada <i>SW</i> ser√£o usados ‚Äã‚Äãquando o <i>SYSCLK</i> estiver <i>programado</i> , <i>especificaremos</i> isso mais no c√≥digo.  A escolha √© oferecida: <br><br><ol><li>  <i><abbr title="Interno de alta velocidade">HSI</abbr></i> - um sinal de um gerador interno de alta frequ√™ncia, √© produzido por um ressonador de quartzo de 8 MHz, que soldei antes de trabalhar com esta placa; </li><li>  <i><abbr title="REL√ìGIO de loop de bloqueio de fase">PLLCLK</abbr></i> - sinal do multiplicador de frequ√™ncia <i>PLLMUL</i> ; </li><li>  <i><abbr title="Externo de alta velocidade">HSE</abbr></i> - sinal de um gerador externo de alta frequ√™ncia. </li></ol><br>  Qualquer op√ß√£o √© adequada para a nossa tarefa, sugiro escolher a mais simples e mais barata delas - <i>HSI</i> . <br><br>  Iremos para o <i>manual de refer√™ncia</i> e abriremos a se√ß√£o <i>7 Redefini√ß√£o e controle de rel√≥gio (RCC)</i> , especificamente <i>7.2.6 Sele√ß√£o do rel√≥gio do sistema</i> , onde mais uma vez encontramos uma reda√ß√£o semelhante encontrada na folha de dados: "ap√≥s uma redefini√ß√£o do sistema, o oscilador <i>HSI</i> √© selecionado como sistema rel√≥gio "- ou seja,  nem precisamos fazer nada, o MK come√ßar√° no <i>HSI</i> . <br><br>  Para garantir que o MK realmente funcione a partir dessa fonte, escreverei isso explicitamente no programa;  Role at√© os registros respons√°veis ‚Äã‚Äãpela redefini√ß√£o e pela contagem de horas (se√ß√£o <i>7.4 registros RCC</i> ).  O primeiro registro descrito na documenta√ß√£o √© o <b>registro de controle do rel√≥gio (RCC_CR)</b> ;  Abaixo est√° uma descri√ß√£o dos bits, que √© respons√°vel por qu√™. <br><br><div class="spoiler">  <b class="spoiler_title">Registro de controle do rel√≥gio</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/qq/i4/ll/qqi4llshdqrtgidy2_x-hxx9yhe.png"><br></div></div><br>  Estamos interessados ‚Äã‚Äãno bit zero <i>HSION</i> , respons√°vel por ligar o ressonador ( <i>0</i> - desligado, <i>1</i> - ligado). <br><br>  Assim, ser√° necess√°rio escrever um no registro <i>RCC_CR</i> .  (zero bit √© um ou 2 <sup>0</sup> = 1). <br><br>  Agora, encontramos no arquivo <i>stm32f0xx.h</i> a defini√ß√£o de <b>RCC</b> ( <i>#define RCC</i> ). <br><br><div class="spoiler">  <b class="spoiler_title">RCC-&gt; RC</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/vn/ej/0x/vnej0xmqlqnrgeprbgyjo9cpjt8.png"><br></div></div><br>  Como voc√™ pode ver, esta √© a estrutura localizada em <i>RCC_BASE</i> ;  endere√ßo <i>0x40021000</i> , se voc√™ expandir todas as <i>defini√ß√µes</i> , o mesmo endere√ßo poder√° ser visto no <i>manual de refer√™ncia</i> na se√ß√£o <i>2.2.2 Mapa de mem√≥ria e endere√ßos de limite de registro</i> e na folha de dados na se√ß√£o <i>5 Mapeamento de mem√≥ria</i> (√°rea <i>AHB</i> ). <br><br>  Para escrever uma unidade para ativar o <i>HSI</i> no registro <i>CR do</i> bloco <i>RCC</i> , voc√™ precisa de uma linha de c√≥digo <br><br><pre><code class="plaintext hljs">RCC-&gt;CR |= 0x1;</code> </pre> <br><h3>  3.3.2 Ajustando as pernas </h3><br>  Enviar um sinal para a perna do microcontrolador para acender o LED e interromper o sinal para que o LED apague s√£o a√ß√µes simples e, portanto, isso se refere √†s fun√ß√µes <i><abbr title="Entradas / sa√≠das de uso geral">GPIO</abbr></i> (portas de entrada e sa√≠da de uso geral). <br><br>  Por padr√£o, as pernas do MK n√£o est√£o conectadas, ou seja,  o resultado √© incerteza.  √â necess√°rio conectar uma porta, cuja perna ir√° alimentar o LED.  Anteriormente, determinamos que as portas <i>GPIO</i> est√£o conectadas ao barramento <i>AHB</i> - voc√™ precisa instal√°-lo.  Continuando a percorrer a se√ß√£o <i>7.4 registros RCC</i> (controle e redefinir registros de controle), encontramos a se√ß√£o <i>7.4.6 Registro de habilita√ß√£o de rel√≥gio perif√©rico AHB</i> ( <i>registro de habilita√ß√£o de rel√≥gio de</i> barramento <b>RCC_AHBENR</b> , <i>AHB</i> ).  Anteriormente, determinei que meu LED estava conectado √† perna do <i>PA4</i> - portanto, preciso gravar uma unidade no 17¬∫ bit do registro para acessar a porta <i>A.</i> <br><br><div class="spoiler">  <b class="spoiler_title">Registro de habilita√ß√£o do rel√≥gio perif√©rico AHB</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/u7/s5/vs/u7s5vsoduvggexg9chpopozlzdw.png"><br></div></div><br>  Assim, o c√≥digo deve ser <br><br><pre> <code class="plaintext hljs">RCC-&gt;AHBENR |= (1 &lt;&lt; 17);</code> </pre> <br>  ou, que √© a mesma coisa <br><br><pre> <code class="plaintext hljs">RCC-&gt;AHBENR |= 0x20000;</code> </pre> <br>  usando o arquivo <i>#define</i> <i>stm32f0xx.h</i> write <br><br><pre> <code class="plaintext hljs">RCC-&gt;AHBENR |= RCC_AHBENR_GPIOAEN;</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">RCC-&gt; AHBENR</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/19/ex/ke/19exkey4g-yyfkz4pmvrrgilnlk.png"><br></div></div><br>  Temos alimentado a porta <i>A</i> , agora precisamos informar ao MK que o <i>PA4</i> funcionar√° na <i>sa√≠da</i> - leremos a se√ß√£o <i>8 E / S de uso geral (GPIO)</i> ;  a introdu√ß√£o da se√ß√£o j√° diz "Cada porta de E / S de uso geral possui quatro registros de configura√ß√£o de 32 bits ( <b>GPIOx_MODER</b> , <b>GPIOx_OTYPER</b> , <b>GPIOx_OTYPER</b> , <b>GPIOx_OSPEEDR</b> e <b>GPIOx_PUPDR</b> ), dois registros de dados de 32 bits ( <b>GPIOx_IDR</b> e <b>GPIOx_ODR</b> ) ..." - <i>para cada GPIO A porta possui 4 registros de ajuste e 2 registros de dados</i> - √© disso que precisamos (configure a porta <i>A</i> , ou melhor, a sa√≠da <i>PA4</i> e envie periodicamente <i>0</i> e <i>1</i> ).  Para uma melhor compreens√£o (teoria) do que est√° acontecendo, voc√™ pode ler esta se√ß√£o, mas eu des√ßo at√© a se√ß√£o <i>8.4 Registros GPIO</i> e configuro a porta de acordo com as descri√ß√µes. <br><br><ol><li>  <b>modo de</b> porta - saia.  De acordo com a documenta√ß√£o, √© necess√°rio escrever <i>01</i> na √°rea correspondente ( <i>MODER4</i> ) do registro correspondente ( <i>GPIOA_MODER</i> ), ou seja,  bits <i>9</i> e <i>8</i> : no 9¬∫ bit deve ser zero, na 8¬™ unidade: <br><br><pre> <code class="plaintext hljs">GPIOA-&gt;MODER |= (1 &lt;&lt; 8); // </code> </pre> <br><pre> <code class="plaintext hljs">GPIOA-&gt;MODER |= 0x100; // </code> </pre> <br><pre> <code class="plaintext hljs">GPIOA-&gt;MODER |= GPIO_MODER_MODER4_0;</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Registro do modo de porta GPIO</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/tv/xf/vt/tvxfvtoiw91rguuz-rtmgcrk8fo.png"><br></div></div><br><div class="spoiler">  <b class="spoiler_title">GPIOA-&gt; MODER</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/co/df/x5/codfx50xu4hopklififyeecpiqu.png"><br></div></div><br></li><li>  <b>tipo de</b> sa√≠da.  Honestamente, ainda n√£o descobri completamente o circuito deste caso (vou entender, reler os f√≥runs novamente etc.), mas estudar outros recursos sobre a configura√ß√£o da sa√≠da MK, al√©m de l√≥gica e intui√ß√£o, sugere que deve haver um <b>empurr√£o -puxar</b> e depois deve ser <i>puxado para cima</i> .  De qualquer forma, o c√≥digo est√° escrito, tudo funciona e nada queimado.  Existe um risco real de queimadura se voc√™ selecionar o tipo de <b>dreno aberto e causar um</b> curto-circuito nessa sa√≠da com outro dispositivo, como  Esta √© uma sa√≠da aberta e n√£o est√° protegida por nada.  Al√©m disso, temos um resistor limitador de corrente na frente do diodo - ele certamente n√£o queima aqui. <br><br>  Seguindo a documenta√ß√£o, √© necess√°rio escrever zero no 4¬∫ bit;  a documenta√ß√£o tamb√©m afirma que ap√≥s a redefini√ß√£o haver√° zero. <br><br><pre> <code class="plaintext hljs">GPIOA-&gt;OTYPER &amp;= ~(1 &lt;&lt; 4); // </code> </pre> <br><pre> <code class="plaintext hljs">GPIOA-&gt;OTYPER &amp;= ~0x10; // </code> </pre> <br><pre> <code class="plaintext hljs">GPIOA-&gt;OTYPER &amp;= ~GPIO_OTYPER_OT_4;</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Registro do tipo de sa√≠da da porta GPIO</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/ii/3k/ch/ii3kcht4jvsbnd7yybouiilgmhk.png"><br></div></div><br></li><li>  <b>velocidade de</b> sa√≠da.  No nosso caso, isso n√£o importa, mas por uma quest√£o de fidelidade, escreverei aqui zero. <br><br><pre> <code class="plaintext hljs">GPIOA-&gt;OSPEEDR &amp;= ~(1 &lt;&lt; 8); // </code> </pre> <br><pre> <code class="plaintext hljs">GPIOA-&gt;OSPEEDR &amp;= ~0x100; // </code> </pre> <br><pre> <code class="plaintext hljs">GPIOA-&gt;OSPEEDR &amp;= ~GPIO_OSPEEDER_OSPEEDR4_0;</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Registro de velocidade de sa√≠da da porta GPIO</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/47/xg/fr/47xgfrtfqdl5ai0eztsrqej1i1k.png"><br></div></div><br></li><li>  <b>um elevador</b> .  Porque  a sa√≠da energizar√° o LED, √© necess√°rio pux√°-lo para cima, ou seja,  <b>pull-up</b> . <br><br>  √â necess√°rio apertar o 4¬∫ pino da porta <i>A</i> ;  a documenta√ß√£o diz que, para isso, √© necess√°rio escrever zero e um em <i>9</i> e <i>8</i> bits, respectivamente. <br><br><pre> <code class="plaintext hljs">GPIOA-&gt;PUPDR |= (1 &lt;&lt; 8); // </code> </pre> <br><pre> <code class="plaintext hljs">GPIOA-&gt;PUPDR |= 0x100; // </code> </pre> <br><pre> <code class="plaintext hljs">GPIOA-&gt;PUPDR |= GPIO_PUPDR_PUPDR4_0;</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Registro pull-up / pull-down da porta GPIO</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/pg/pa/zk/pgpazkwfltwme4jy0wwrhp9imqi.png"><br></div></div><br><div class="spoiler">  <b class="spoiler_title">GPIOA-&gt; PUPDR</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/bo/ee/na/boeenaff6fxjiemjuiky9ukhb6w.png"><br></div></div><br></li></ol><br><h3>  3.3.3 LED ligado / desligado e atraso </h3><br>  Anteriormente, lemos que cada porta possui registros, incluindo registros de dados <i><abbr title="Registro de dados de entrada">IDR</abbr></i> e <i><abbr title="Registro de dados de sa√≠da">ODR</abbr></i> - registros de dados de entrada e sa√≠da, respectivamente.  Zeros l√≥gicos e outros na perna MK - s√£o esses dados?  Sim, dados.  Os dados podem vir de fora do microcontrolador ( <i>entrada</i> ) e sair do microcontrolador e ir para outro dispositivo ( <i>sa√≠da</i> ).  A unidade na perna MK √© a presen√ßa de um n√≠vel de alta tens√£o, ou seja,  se voc√™ trouxer um para a sa√≠da, haver√° tens√£o e esse LED poder√° alimentar nosso LED.  A sa√≠da de uma unidade para a perna do microcontrolador √© outra coisa que gravar esta unidade no registro de sa√≠da do <i>ODR</i> . <br><br><div class="spoiler">  <b class="spoiler_title">Registro de dados de sa√≠da da porta GPIO</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/or/vw/el/orvwel6seyhwvx6pbxdcow6ufpm.png"><br></div></div><br>  De acordo com a documenta√ß√£o, vemos que, para cada porta ( <i>A</i> , <i>B</i> , <i>C</i> , <i>D</i> , <i>F</i> ), h√° um registro de 32 bits.  a porta n√£o pode ter mais de 16 pinos; somente os primeiros 16 bits do registro s√£o usados.  Cada bit corresponde a um n√∫mero de porta (pino).  Para enviar uma unidade para o trecho <i>PA4</i> , √© necess√°rio escrever uma unidade no 4¬∫ bit, gerar um zero - escrever um zero no 4¬∫ bit, ou seja,  remova a tens√£o da sa√≠da. <br><br><img src="https://habrastorage.org/webt/pr/0n/pr/pr0npr4jplwjahmcflj_nlksq5i.png" width="400" height="156"><br><br><div class="spoiler">  <b class="spoiler_title">GPIOA-&gt; ODR</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/hs/yy/v4/hsyyv4z5u2kf6fkqqe5wk9t6ti4.png"><br></div></div><br>  O c√≥digo para ligar o LED ficar√° assim <br><br><pre> <code class="plaintext hljs">GPIOA-&gt;ODR |= (1 &lt;&lt; 4); // </code> </pre> <br><pre> <code class="plaintext hljs">GPIOA-&gt;ODR |= 0x10; // </code> </pre> <br><pre> <code class="plaintext hljs">GPIOA-&gt;ODR |= GPIO_ODR_4;</code> </pre> <br>  C√≥digo para desligar o LED <br><br><pre> <code class="plaintext hljs">GPIOA-&gt;ODR &amp;= ~(1 &lt;&lt; 4); // </code> </pre> <br><pre> <code class="plaintext hljs">GPIOA-&gt;ODR &amp;= ~0x10; // </code> </pre> <br><pre> <code class="plaintext hljs">GPIOA-&gt;ODR &amp;= ~GPIO_ODR_4;</code> </pre> <br>  Mas se voc√™ escrever a linha para desligar o LED ap√≥s a linha para ligar, o LED n√£o piscar√° (se voc√™ estiver interessado no que acontece - voc√™ pode tentar; nada ser√° queimado, isso j√° foi discutido acima) -, voc√™ precisar√° atrasar.  Os temporizadores s√£o usados ‚Äã‚Äãpara atraso, mas os temporizadores s√£o dignos de um artigo separado (devido √† complexidade), portanto, faremos um atraso na muleta: conduziremos o ciclo de inatividade.  H√° um ponto: <b>se a otimiza√ß√£o do compilador estiver ativada</b> , o <b>compilador cortar√°</b> nosso ciclo inativo e n√£o haver√° atraso.  Verifique se a otimiza√ß√£o n√£o est√° ativada.  Para fazer isso, vamos para a configura√ß√£o do projeto (clique com o bot√£o direito do mouse no nome do projeto na √°rvore do projeto) e verifique a linha <i>Compilar Control String</i> na guia <i>Compile</i> : ele deve ter o argumento <i>-O0</i> ("about zero" significa que a otimiza√ß√£o est√° desativada).  Se voc√™ coletou tudo de acordo com minhas instru√ß√µes, provavelmente tamb√©m ter√° <i>-O0</i> , porque  era por padr√£o e eu n√£o toquei em nada aqui.  Os argumentos <i>-O1 -O2 -O3</i> significam que a otimiza√ß√£o do n√≠vel correspondente est√° ativada. <br><br><div class="spoiler">  <b class="spoiler_title">Verifica√ß√£o de otimiza√ß√£o do compilador</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/vc/ps/pu/vcpspuz5xfupw1pa5n-e5at9_nm.png"><br></div></div><br>  Um ciclo inativo pode ser escrito assim: <br><br><pre> <code class="plaintext hljs">int t = 4000000; while(t &gt; 0) t--;</code> </pre><br>  Eu n√£o defini o valor de <i>t</i> como tal, raciocinei assim: se o microcontrolador rodar em 8MHz, ele executar√° aproximadamente 8.000.000 de instru√ß√µes em um segundo, se voc√™ exagerar profundamente, e por um atraso de meio segundo, precisar√° executar o ciclo 4.000.000 de vezes. <br>  O ciclo de inatividade precisar√° ser executado ap√≥s ligar o LED e depois de deslig√°-lo, e todo esse loop. <br><br><h3>  3.4 Escrevendo c√≥digo e executando </h3><br>  Vamos montar todas as linhas de c√≥digo que escrevemos antes.  Voc√™ tamb√©m precisa incluir o arquivo de cabe√ßalho <i>stm32f0xx.h</i> , como  confiamos nele e extra√≠mos defini√ß√µes de estruturas, endere√ßos e valores.  O resultado deve ser: <br><br><pre> <code class="plaintext hljs">#include "stm32f0xx.h" int main(void) { int t; //  '' RCC-&gt;CR |= 0x1; //   HSI RCC-&gt;AHBENR |= RCC_AHBENR_GPIOAEN; //   A GPIOA-&gt;MODER |= GPIO_MODER_MODER4_0; // PA4   GPIOA-&gt;OTYPER &amp;= ~GPIO_OTYPER_OT_4; //  push-pull  PA4 GPIOA-&gt;OSPEEDR &amp;= ~GPIO_OSPEEDER_OSPEEDR4_0; //    PA4 GPIOA-&gt;PUPDR |= GPIO_PUPDR_PUPDR4_0; //  pull-up  PA4 while(1) { GPIOA-&gt;ODR |= GPIO_ODR_4; //    PA4 t = 4000000; while(t &gt; 0) t--; //  GPIOA-&gt;ODR &amp;= ~GPIO_ODR_4; //    PA4 t = 4000000; while(t &gt; 0) t--; //  } }</code> </pre><br>  Clique em Reconstruir e preencha o c√≥digo no quadro por meio do utilit√°rio. <br><br><img src="https://habrastorage.org/webt/fo/rr/1d/forr1d6ruw6sohn7eyomgs4yb_g.png"><br><br>  Para que a placa inicie um novo firmware, n√£o esque√ßa de fechar o jumper BOOT e fazer um reset (RESET). <br><br><h1>  4. Conclus√£o </h1><br>  O c√≥digo est√° escrito, tudo funciona.  For√ßas gastas sem medida.  Fico feliz que, com base na documenta√ß√£o, ele tenha escrito c√≥digo de trabalho, em grande parte devido ao fato de o STM possuir documenta√ß√£o de alta qualidade. <br><br>  Os planos s√£o escrever um artigo sobre como montar tudo manualmente, sem um IDE, atrav√©s do console, <i>verdadeira velha escola</i> , idealmente para que tudo isso possa ser feito no Linux.  Agora estou trabalhando em PWM e ADCs (tamb√©m neste quadro) - tamb√©m escreverei um artigo sobre eles. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt437234/">https://habr.com/ru/post/pt437234/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt437224/index.html">Traduzindo modelos de poeira para JSX</a></li>
<li><a href="../pt437226/index.html">Kelvin Point Shadow</a></li>
<li><a href="../pt437228/index.html">Bitcoin, como moeda, levar√° a uma crise econ√¥mica</a></li>
<li><a href="../pt437230/index.html">Uma publicidade online t√£o diferente. Tr√™s eixos vs. AI, Ad Tech e DOOH</a></li>
<li><a href="../pt437232/index.html">Psto bom</a></li>
<li><a href="../pt437236/index.html">ESET: Uma an√°lise de novos componentes de zebr√≥citos</a></li>
<li><a href="../pt437238/index.html">Lan√ßamento do Orange Pi 3 - um mini-pc completo de US $ 30 no Linux</a></li>
<li><a href="../pt437240/index.html">Como integrar o Zimbra Collaboration Suite ao Active Directory</a></li>
<li><a href="../pt437242/index.html">Dom√≠nio do gerente de produto. Solicita√ß√µes de recursos</a></li>
<li><a href="../pt437244/index.html">Google ensina usu√°rios a reconhecer e-mails de phishing</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>