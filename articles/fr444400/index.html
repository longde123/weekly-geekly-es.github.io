<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçÇ üèùÔ∏è üó£Ô∏è Comment j'ai r√©√©crit un moteur de recherche de vols de PHP vers NodeJS üë©‚Äçüë©‚Äçüëß üëçüèæ ‚õπüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Salut Je m'appelle Andrey, je suis un √©tudiant dipl√¥m√© dans l'une des universit√©s techniques de Moscou et √† temps partiel  tr√®s modeste  entrepreneur ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment j'ai r√©√©crit un moteur de recherche de vols de PHP vers NodeJS</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444400/"><p>  Salut  Je m'appelle Andrey, je suis un √©tudiant dipl√¥m√© dans l'une des universit√©s techniques de Moscou et √† temps partiel <del>  tr√®s modeste </del>  entrepreneur et d√©veloppeur novice.  Dans cet article, j'ai d√©cid√© de partager mon exp√©rience de passage de PHP (que j'aimais autrefois en raison de sa simplicit√©, mais que j'ai finalement d√©test√© - j'explique pourquoi sous la coupe) √† NodeJS.  Des t√¢ches tr√®s triviales et apparemment √©l√©mentaires peuvent √™tre donn√©es ici, que j'ai n√©anmoins √©t√© personnellement curieux de r√©soudre lors de ma connaissance de NodeJS et des fonctionnalit√©s de d√©veloppement c√¥t√© serveur en JavaScript.  J'essaierai d'expliquer et de d√©montrer clairement que PHP est finalement entr√© dans le coucher du soleil et a c√©d√© la place √† NodeJS.  Peut-√™tre qu'il sera m√™me utile pour quelqu'un d'apprendre certaines fonctionnalit√©s du rendu des pages HTML dans Node, qui ne sont pas du tout adapt√©es √† cela √† partir du mot. </p><a name="habracut"></a><br><h2 id="vvedenie">  Pr√©sentation </h2><br><p>  Lors de l'√©criture du moteur, j'ai utilis√© les techniques les plus simples.  Pas de gestionnaires de paquets, pas de routage.  Seuls les dossiers inconditionnels, dont le nom correspond √† l'itin√©raire demand√©, et <strong>index.php</strong> dans chacun d'eux, configur√©s par PHP-FPM pour prendre en charge le pool de processus.  Plus tard, il est devenu n√©cessaire d'utiliser Composer et Laravel, qui a √©t√© la derni√®re goutte pour moi.  Avant de passer √† l'histoire de la raison pour laquelle j'ai m√™me d√©cid√© de tout r√©√©crire, de PHP √† NodeJS, je vais vous parler un peu de l'arri√®re-plan. </p><br><h3 id="menedzher-paketov">  Gestionnaire de paquets </h3><br><p>  Fin 2018, il m'est arriv√© de travailler sur un projet √©crit en Laravel.  Il a fallu corriger plusieurs bugs, apporter des modifications aux fonctionnalit√©s existantes, ajouter quelques nouveaux boutons dans l'interface.  Le processus a commenc√© par l'installation du package et du gestionnaire de d√©pendances.  En PHP, Composer est utilis√© pour cela.  Ensuite, le client a fourni un serveur avec 1 c≈ìur et 512 m√©gaoctets de RAM et c'√©tait ma premi√®re exp√©rience avec Composer.  Lors de l'installation de d√©pendances sur un serveur priv√© virtuel avec 512 m√©gaoctets de m√©moire, le processus s'est bloqu√© en raison d'un manque de m√©moire. </p><br><p><img src="https://habrastorage.org/webt/pg/jm/hh/pgjmhhg0efngekrokj1yryvdzxg.png" alt="Wut?"></p><br><p> Pour moi, en tant que personne famili√®re avec Linux et exp√©riment√©e dans le travail avec Debian et Ubuntu, la solution √† ce probl√®me √©tait √©vidente - installer un fichier SWAP (un fichier d'√©change - pour ceux qui ne sont pas familiers avec l'administration Linux).  Un d√©veloppeur novice et inexp√©riment√© qui a install√© sa premi√®re distribution Laravel sur Digital Ocean, par exemple, va simplement au panneau de contr√¥le et augmente le tarif jusqu'√† ce que l'installation des d√©pendances s'arr√™te avec une erreur de segmentation de la m√©moire.  Et NodeJS? <br>  Et NodeJS a son propre gestionnaire de packages - npm.  Il est beaucoup plus facile √† utiliser, plus compact, peut fonctionner m√™me dans un environnement avec un minimum de RAM.  En g√©n√©ral, il n'y a rien √† reprocher √† Composer contre NPM, cependant, en cas d'erreur lors de l'installation des packages, Composer se bloquera comme une application PHP ordinaire et vous ne saurez jamais quelle partie du package a √©t√© install√©e et si elle a √©t√© install√©e √† la fin se termine.  En g√©n√©ral, pour l'administrateur Linux, l'installation <code>dpkg --configure -a</code> = flashbacks en mode Rescue et <code>dpkg --configure -a</code> .  Au moment o√π ces ¬´surprises¬ª m'ont d√©pass√©, je n'aimais pas PHP, mais ce sont les derniers clous dans le cercueil de mon grand amour pour PHP. </p><br><h2 id="long-term-support-i-problema-versionirovaniya">  Probl√®me de support et de version √† long terme </h2><br><p>  Rappelez-vous quel type de battage m√©diatique et d'√©tonnement a caus√© PHP7 lorsque les d√©veloppeurs l'ont pr√©sent√© pour la premi√®re fois?  Augmentation de la productivit√© de plus de 2 fois, et dans certains composants jusqu'√† 5 fois!  Rappelez-vous quand la septi√®me version de PHP est n√©e?  Et √† quelle vitesse WordPress a gagn√©!  C'√©tait en d√©cembre 2015.  Saviez-vous que PHP 7.0 est d√©sormais consid√©r√© comme une version obsol√®te de PHP et il est fortement recommand√© de le mettre √† jour ... Non, pas √† la version 7.1, mais √† la version 7.2.  Selon les d√©veloppeurs, la version 7.1 est d√©j√† priv√©e de support actif et ne re√ßoit que des mises √† jour de s√©curit√©.  Et apr√®s 8 mois, cela s'arr√™tera.  Il cessera, avec le support actif et la version 7.2.  Il s'av√®re qu'√† la fin de cette ann√©e, PHP n'aura qu'une seule version actuelle - 7.3. </p><br><p><img src="https://habrastorage.org/webt/zd/0p/me/zd0pmebltmchxqafrdw5yfpdfta.png" alt="Versions PHP actuelles"></p><br><p>  En fait, ce ne serait pas compliqu√© et je n'attribuerais pas cela aux raisons de mon d√©part de PHP si les projets que j'ai √©crits en PHP 7.0.  Revenons au projet o√π l'installation des d√©pendances s'est √©cras√©e.  Il s'agit d'un projet √©crit en 2015 sur Laravel 4 avec PHP 5.6.  Il semblait que seulement 4 ans s'√©taient √©coul√©s, mais non - un tas d'avertissements de d√©pr√©ciation, des modules obsol√®tes, l'impossibilit√© de mettre √† niveau vers Laravel 5 normalement en raison d'un tas de mises √† jour du moteur racine. </p><br><p>  Et cela ne s'applique pas seulement √† Laravel.  Essayez d'obtenir n'importe quelle application PHP √©crite pendant le support actif des premi√®res versions de PHP 7.0 et pr√©parez-vous √† passer votre soir√©e √† chercher des solutions aux probl√®mes survenus dans les modules PHP obsol√®tes.  Enfin, un fait int√©ressant: la prise en charge de PHP 7.0 a √©t√© interrompue plus t√¥t que la prise en charge de PHP 5.6.  Une seconde. </p><br><p>  Et NodeJS?  Je ne dirais pas que tout va bien mieux ici et que les p√©riodes de support pour NodeJS sont fondamentalement diff√©rentes de PHP.  Non, c'est √† peu pr√®s la m√™me chose ici - chaque version LTS est prise en charge pendant 3 ans.  Mais NodeJS a un peu plus de ces versions les plus r√©centes. </p><br><p><img src="https://habrastorage.org/webt/ff/xf/x_/ffxfx_rhvieo0jmad4wnabdrwuy.png" alt="Versions actuelles de NodeJS"></p><br><p>  Si vous devez d√©ployer une application √©crite en 2016, assurez-vous que vous n'aurez absolument aucun probl√®me avec cela.  Par ailleurs, la version 6. * ne sera plus prise en charge uniquement en avril de cette ann√©e.  Et devant, il y a 8, 10, 11 et les 12 prochains. </p><br><h2 id="o-trudnostyah-i-syurprizah-pri-perehode-na-nodejs">  Difficult√©s et surprises lors du passage √† NodeJS </h2><br><p>  Je vais peut-√™tre commencer par la question la plus int√©ressante pour moi sur la fa√ßon de rendre les pages HTML dans NodeJS.  Mais rappelons-nous d'abord comment cela se fait en PHP: </p><br><ol><li>  Int√©grez du HTML directement dans le code PHP.  Il en va de m√™me pour tous les d√©butants qui n'ont pas encore atteint MVC.  Et c'est donc fait dans WordPress, ce qui est absolument horrible. </li><li>  Utilisez MVC, qui devrait simplifier l'interaction du d√©veloppeur et fournir une sorte de division du projet en parties, mais en r√©alit√©, cette approche ne fait que tout compliquer √† certains moments. </li><li>  Utilisez un moteur de mod√®le.  L'option la plus pratique, mais pas en PHP.  Regardez simplement la syntaxe sugg√©r√©e dans Twig ou Blade avec des accolades et des pourcentages boucl√©s. </li></ol><br><p>  Je suis un ardent opposant √† la combinaison ou √† la fusion de plusieurs technologies.  HTML doit exister s√©par√©ment, les styles s√©par√©ment, JavaScript s√©par√©ment (dans React, cela semble g√©n√©ralement monstrueux - HTML et JavaScript sont m√©lang√©s).  C'est pourquoi l'option id√©ale pour les d√©veloppeurs ayant des pr√©f√©rences comme la mienne est un moteur de mod√®le.  Je n'ai pas eu √† le rechercher depuis longtemps pour une application web sur NodeJS et j'ai opt√© pour Jade (PugJS).  Appr√©ciez simplement la simplicit√© de sa syntaxe: </p><br><pre> <code class="plaintext hljs"> div.row.links div.col-lg-3.col-md-3.col-sm-4 h4.footer-heading . div.copyright div.copy-text 2017 - #{current_year} . div.contact-link span : a(href='mailto:hello@flaut.ru') hello@flaut.ru</code> </pre> <br><p>  Tout est assez simple ici: j'ai √©crit un mod√®le, je l'ai t√©l√©charg√© dans l'application, je l'ai compil√© une fois et je l'utilise ensuite √† n'importe quel endroit et √† n'importe quel moment.  √Ä mon avis, les performances de PugJS sont environ 2 fois meilleures que le rendu en incorporant du HTML dans du code PHP.  Si auparavant, en PHP, une page statique √©tait g√©n√©r√©e par le serveur en environ 200-250 millisecondes, cette fois-ci est d'environ 90-120 millisecondes (nous ne parlons pas du rendu dans PugJS, mais du temps pris entre la demande de page et la r√©ponse du serveur au client avec le code HTML pr√™t) )  Voici √† quoi ressemble le chargement et la compilation de mod√®les et de leurs composants au stade du lancement de l'application: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pugs = {} fs.readdirSync(__dirname + <span class="hljs-string"><span class="hljs-string">'/templates/'</span></span>).forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">file</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(file.endsWith(<span class="hljs-string"><span class="hljs-string">'.pug'</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> filepath = __dirname + <span class="hljs-string"><span class="hljs-string">'/templates/'</span></span> + file pugs[file.split(<span class="hljs-string"><span class="hljs-string">'.pug'</span></span>)[<span class="hljs-number"><span class="hljs-number">0</span></span>]] = pug.compile(fs.readFileSync(filepath, <span class="hljs-string"><span class="hljs-string">'utf-8'</span></span>), { <span class="hljs-attr"><span class="hljs-attr">filename</span></span>: filepath }) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(e) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(e) } } }) <span class="hljs-comment"><span class="hljs-comment">//       return pugs.tickets({ ...config })</span></span></code> </pre> <br><p>  Cela semble incroyablement simple, mais avec Jade, il y avait un peu de complexit√© au stade du travail avec du code HTML d√©j√† compil√©.  Le fait est que pour impl√©menter des scripts sur la page, une fonction asynchrone est utilis√©e, qui prend tous les fichiers <code>.js</code> du r√©pertoire et ajoute la date de leur derni√®re modification √† chacun d'eux.  La fonction a la forme suivante: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; files.length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> period = files[i].lastIndexOf(<span class="hljs-string"><span class="hljs-string">'.'</span></span>) <span class="hljs-comment"><span class="hljs-comment">// get last dot in filename let filename = files[i].substring(0, period) let extension = files[i].substring(period + 1) if(extension === 'js') { let fullFilename = filename + '.' + extension if(env === 'production') { scripts.push({ path: paths.production.web + fullFilename, mtime: await getMtime(paths.production.code + fullFilename)}) } else { if(files[i].startsWith('common') || files[i].startsWith('search')) { scripts.push({ path: paths.developer.scripts.web + fullFilename, mtime: await getMtime(paths.developer.scripts.code + fullFilename)}) } else { scripts.push({ path: paths.developer.vendor.web + fullFilename, mtime: await getMtime(paths.developer.vendor.code + fullFilename)}) } } } }</span></span></code> </pre> <br><p>  En sortie, nous obtenons un tableau d'objets avec deux propri√©t√©s - le chemin d'acc√®s au fichier et l'heure de sa derni√®re modification dans l'horodatage (pour la mise √† jour du cache client).  Le probl√®me est que m√™me au stade de la collecte des fichiers de script √† partir d'un r√©pertoire, ils sont tous charg√©s en m√©moire strictement alphab√©tiquement (car ils sont situ√©s dans le r√©pertoire lui-m√™me et les fichiers y sont collect√©s de haut en bas - du premier au dernier).  Cela a conduit au fait que le fichier <strong>app.js a</strong> √©t√© charg√© en premier, et d√©j√† apr√®s il est venu le fichier <strong>core.min.js</strong> avec des polyfills et vendor.min.js √† la toute fin.  Ce probl√®me a √©t√© r√©solu tout simplement - tri tr√®s banal: </p><br><pre> <code class="javascript hljs">scripts.sort(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(a.path.includes(<span class="hljs-string"><span class="hljs-string">'core.min.js'</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(a.path.includes(<span class="hljs-string"><span class="hljs-string">'vendor.min.js'</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> })</code> </pre> <br><p>  En PHP, tout cela avait une apparence monstrueuse sous la forme de chemins vers des fichiers JS pr√©-√©crits dans une cha√Æne.  Simple mais peu pratique. </p><br><h3 id="nodejs-derzhit-svoyo-prilozhenie-v-operativnoy-pamyati">  NodeJS conserve son application en RAM </h3><br><p>  C'est un √©norme avantage.  Tout est arrang√© pour moi pour que sur le serveur en parall√®le et ind√©pendamment l'un de l'autre il y ait deux sites distincts - la version pour le d√©veloppeur et la version de production.  Imaginez que j'ai apport√© des modifications aux fichiers PHP sur le site de d√©veloppement et que j'ai besoin de d√©ployer ces modifications en production.  Pour ce faire, vous devez arr√™ter le serveur ou mettre un stub "d√©sol√©, tech. Work" et √† ce moment copier les fichiers individuellement du dossier d√©veloppeur vers le dossier de production.  Cela provoque une sorte de temps d'arr√™t et peut entra√Æner une perte de conversions.  L'avantage de l' <strong>application</strong> en <strong>m√©moire</strong> dans NodeJS est pour moi que toutes les modifications apport√©es aux fichiers du moteur ne seront effectu√©es qu'apr√®s son red√©marrage.  C'est tr√®s pratique, car vous pouvez copier tous les fichiers n√©cessaires avec les modifications, puis red√©marrer le serveur.  Le processus ne prend pas plus de 1 √† 2 secondes et ne provoque pas de temps d'arr√™t. <br>  La m√™me approche est utilis√©e dans nginx, par exemple.  Vous modifiez d'abord la configuration, v√©rifiez-la avec <code>nginx -t</code> puis apportez des modifications avec le <code>service nginx reload</code> </p><br><h3 id="klasterizaciya-nodejs-prilozheniya">  Mise en cluster d'une application NodeJS </h3><br><p>  NodeJS a un outil tr√®s pratique - <strong>gestionnaire de</strong> processus <strong>pm2</strong> .  Comment ex√©cutons-nous g√©n√©ralement les applications dans Node?  Nous allons dans la console et √©crivons le <code>node index.js</code> .  D√®s que nous fermons la console, l'application se ferme.  C'est du moins ce qui se passe sur un serveur avec Ubuntu.  Pour √©viter cela et maintenir l'application toujours op√©rationnelle, ajoutez-la simplement √† <strong>pm2 avec la</strong> simple commande <code>pm2 start index.js --name production</code> .  Mais ce n'est pas tout.  L'outil permet la surveillance ( <code>pm2 monit</code> ) et le clustering d'applications. </p><br><p>  Rappelons-nous comment les processus sont organis√©s en PHP.  Supposons que nginx traite les requ√™tes http et que nous devons transmettre la requ√™te √† PHP.  Vous pouvez soit le faire directement, puis √† chaque demande, un nouveau processus PHP appara√Ætra et, une fois termin√©, il sera tu√©.  Ou vous pouvez utiliser un serveur fastcgi.  Je pense que tout le monde sait ce que c'est et il n'est pas n√©cessaire d'entrer dans les d√©tails, mais juste au cas o√π, je pr√©ciserai que PHP-FPM est le plus souvent utilis√© comme fastcgi et sa t√¢che consiste √† g√©n√©rer de nombreux processus PHP pr√™ts √† accepter et √† traiter une nouvelle demande √† tout moment.  Quel est l'inconv√©nient de cette approche? </p><br><p>  La premi√®re est que vous ne savez jamais combien de m√©moire votre application consommera.  Deuxi√®mement, vous serez toujours limit√© dans le nombre maximal de processus, et en cons√©quence, avec un bond important du trafic, votre application PHP utilisera toute la m√©moire disponible et plantera, ou reposera sur la limite autoris√©e de processus et commencera √† tuer les anciens.  Cela peut √™tre √©vit√© en d√©finissant Je ne me souviens pas quel param√®tre dans le fichier de configuration PHP-FPM en <strong>dynamique</strong> , puis autant de processus seront g√©n√©r√©s que n√©cessaire √† ce stade.  Mais encore une fois, une attaque DDoS √©l√©mentaire va consommer toute la RAM et mettre votre serveur.  Ou, par exemple, un script de bogue va manger toute la RAM et le serveur se fige pendant un certain temps (il y avait des pr√©c√©dents dans le processus de d√©veloppement). </p><br><p>  La diff√©rence fondamentale dans NodeJS est que l'application ne peut pas consommer plus de 1,5 gigaoctets de RAM.  Il n'y a aucune restriction de processus, il n'y a qu'une limite de m√©moire.  Cela vous encourage √† √©crire des programmes aussi l√©gers que possible.  De plus, il est tr√®s simple de calculer le nombre de clusters que nous pouvons nous permettre, en fonction de la ressource CPU disponible.  Il est recommand√© de ne pas suspendre plus d'un cluster sur chaque c≈ìur (exactement comme dans nginx, pas plus d'un travailleur par c≈ìur de processeur). </p><br><p><img src="https://habrastorage.org/webt/rk/z4/hp/rkz4hp9g8jkptpmq_tbc-_gpdpu.png" alt="Regroupement dans PM2"></p><br><p>  Un avantage de cette approche est que PM2 recharge successivement tous les clusters.  Revenons au paragraphe pr√©c√©dent, qui parlait de 1 √† 2 secondes d'arr√™t pendant le red√©marrage.  En mode cluster, lorsque vous red√©marrez le serveur, votre application ne conna√Ætra pas une milliseconde de temps d'arr√™t. </p><br><h3 id="nodejs---eto-horoshiy-shveycarskiy-nozh">  NodeJS est un bon couteau suisse </h3><br><p>  Maintenant, il y a une telle situation o√π PHP agit comme un langage pour √©crire des sites, et Python agit comme un outil pour explorer ces sites.  NodeJS est 2 en 1, d'une part est une fourchette, de l'autre est une cuill√®re.  Vous pouvez √©crire des applications et des robots d'indexation rapides et puissants sur le m√™me serveur au sein de la m√™me application.  Cela semble tentant.  Mais comment cela peut-il se r√©aliser, demandez-vous?  Google lui-m√™me a d√©ploy√© l'API Chromium officielle - Puppeteer.  Vous pouvez lancer Headless Chrome (un navigateur sans interface utilisateur - Chrome "sans t√™te") et obtenir le plus large acc√®s possible √† l'API du navigateur pour explorer les pages.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">La fa√ßon la plus simple et la plus accessible de travailler avec Puppeteer</a> . </p><br><p>  Par exemple, dans notre groupe VKontakte, il y a r√©guli√®rement des remises et des offres sp√©ciales vers diverses destinations √† partir des villes de la CEI.  Nous g√©n√©rons des images pour les articles en mode automatique, et pour les rendre belles, nous avons besoin de belles images.  Je n'aime pas associer diff√©rentes API et cr√©er des comptes sur des dizaines de sites.J'ai donc √©crit une application simple qui imite un utilisateur ordinaire avec le navigateur Google Chrome qui parcourt le site avec des images stock et r√©cup√®re au hasard l'image trouv√©e par le mot cl√©.  J'avais l'habitude d'utiliser Python et BeautifulSoup pour cela, mais maintenant ce n'est plus n√©cessaire.  Et la principale caract√©ristique et avantage de Puppeteer est que vous pouvez facilement tricher m√™me sur les sites SPA, car vous avez √† votre disposition un navigateur complet qui comprend et ex√©cute le code JavaScript sur les sites.  C'est douloureusement simple: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> browser = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> puppeteer.launch({<span class="hljs-attr"><span class="hljs-attr">headless</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">args</span></span>:[<span class="hljs-string"><span class="hljs-string">'--no-sandbox'</span></span>]}) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> page = (<span class="hljs-keyword"><span class="hljs-keyword">await</span></span> browser.pages())[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> page.goto(<span class="hljs-string"><span class="hljs-string">`https://pixabay.com/photos/search/</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${imageKeyword}</span></span></span><span class="hljs-string">/?cat=buildings&amp;orientation=horizontal`</span></span>, { <span class="hljs-attr"><span class="hljs-attr">waitUntil</span></span>: <span class="hljs-string"><span class="hljs-string">'networkidle0'</span></span> })</code> </pre> <br><p>  Donc, en 3 lignes de code, nous avons lanc√© le navigateur et ouvert la page du site avec des images de stock.  Maintenant, nous pouvons s√©lectionner un bloc al√©atoire avec l'image sur la page et y ajouter une classe, dans laquelle plus tard nous pouvons tourner de la m√™me mani√®re et aller √† la page directement avec l'image elle-m√™me pour un chargement suppl√©mentaire: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> imagesLength = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> page.evaluate(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> photos = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelectorAll(<span class="hljs-string"><span class="hljs-string">'.search_results &gt; .item'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(photos.length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { photos[<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor(<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random() * photos.length)].className += <span class="hljs-string"><span class="hljs-string">' --anomaly_selected'</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> photos.length })</code> </pre> <br><p>  Rappelez-vous combien de code il faudrait pour √©crire ceci dans PhantomJS (qui, incidemment, a ferm√© et est entr√© en √©troite collaboration avec l'√©quipe de d√©veloppement de Puppeteer).  Un outil aussi merveilleux peut-il emp√™cher quiconque de passer √† NodeJS? </p><br><h3 id="v-nodejs-zalozhena-asinhronnost-na-fundamentalnom-urovne">  NodeJS fournit une asynchronie fondamentale </h3><br><p>  Cela peut √™tre consid√©r√© comme un √©norme avantage de NodeJS et JavaScript, en particulier avec l'av√®nement de l'async / wait dans ES2017.  Contrairement √† PHP, o√π tout appel est effectu√© de mani√®re synchrone.  Je vais donner un exemple simple.  Auparavant, dans le moteur de recherche, des pages √©taient g√©n√©r√©es sur le serveur, mais quelque chose devait √™tre affich√© sur la page d√©j√† dans le client √† l'aide de JavaScript, mais √† ce moment-l√†, Yandex n'√©tait pas encore en mesure d'utiliser JavaScript sur les sites Web et devait impl√©menter un m√©canisme d'instantan√© (instantan√©s de page) sp√©cifiquement pour cela. en utilisant Prerender.  Des instantan√©s ont √©t√© stock√©s sur notre serveur et ont √©t√© envoy√©s au robot sur demande.  Le dilemme √©tait que ces images ont √©t√© g√©n√©r√©es en 3 √† 5 secondes, ce qui est totalement inacceptable et peut affecter le classement du site dans les r√©sultats de recherche.  Pour r√©soudre ce probl√®me, un algorithme simple a √©t√© invent√©: lorsque le robot demande une page, un instantan√© dont nous disposons d√©j√†, nous lui donnons simplement l'instantan√© existant, apr√®s quoi nous effectuons l'op√©ration pour cr√©er un nouvel instantan√© en arri√®re-plan et le remplacer d√©j√† disponible.  Comment cela a √©t√© fait en PHP: </p><br><pre> <code class="php hljs">exec(<span class="hljs-string"><span class="hljs-string">'/usr/bin/php '</span></span> . <span class="hljs-keyword"><span class="hljs-keyword">__DIR__</span></span> . <span class="hljs-string"><span class="hljs-string">'/snapshot.php -a '</span></span> . $affiliation_type . <span class="hljs-string"><span class="hljs-string">' -l '</span></span> . urlencode($full_uri) . <span class="hljs-string"><span class="hljs-string">' &gt; /dev/null 2&gt;/dev/null &amp;'</span></span>);</code> </pre> <br><p>  Ne fais jamais √ßa. <br>  Dans NodeJS, cela peut √™tre r√©alis√© en appelant la fonction asynchrone: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">saveSnapshot</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ getSnapshot().then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">res</span></span></span><span class="hljs-function">) =&gt;</span></span> { db.saveSnapshot().then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">status</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(status.err) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err) }) }) } <span class="hljs-comment"><span class="hljs-comment">/** *     await * ..    resolve()   */</span></span> saveSnapshot()</code> </pre> <br><p>  En bref, vous n'essayez pas de contourner le synchronisme, mais vous d√©cidez quand utiliser l'ex√©cution de code synchrone et quand utiliser asynchrone.  Et c'est vraiment pratique.  Surtout lorsque vous d√©couvrez les possibilit√©s de <strong>Promise.all ()</strong> </p><br><p>  Le moteur de recherche de vols lui-m√™me est con√ßu de telle mani√®re qu'il envoie une demande √† un deuxi√®me serveur qui collecte et agr√®ge les donn√©es, puis se tourne vers lui pour des donn√©es pr√™tes √† √™tre √©mises.  Les pages de direction sont utilis√©es pour attirer du trafic organique. </p><br><p>  Par exemple, pour la requ√™te "Vols Moscou Saint-P√©tersbourg", une page sera √©mise avec l'adresse <em>/ tickets / moscou / saint-petersburg /</em> , et elle a besoin de donn√©es: </p><br><ol><li>  Prix ‚Äã‚Äãdes compagnies a√©riennes dans cette direction pour le mois en cours </li><li>  Prix ‚Äã‚Äãdes compagnies a√©riennes dans cette direction pour l'ann√©e √† venir (prix moyen pour chaque mois pour les 12 prochains mois) </li><li>  Planifiez des vols dans cette direction </li><li>  Destinations populaires de la ville d'exp√©dition - de Moscou (pour la liaison) </li><li>  Les destinations populaires de la ville d'arriv√©e sont de Saint-P√©tersbourg (pour la liaison) </li></ol><br><p>  En PHP, toutes ces requ√™tes ont √©t√© ex√©cut√©es de mani√®re synchrone - l'une apr√®s l'autre.  Le temps de r√©ponse API moyen par demande est de 150 √† 200 millisecondes.  Nous multiplions 200 par 5 et obtenons, en moyenne, une seconde seulement pour r√©pondre aux demandes du serveur avec des donn√©es.  NodeJS a une grande fonction <strong>appel√©e Promise.all</strong> , qui ex√©cute toutes les demandes en parall√®le, mais √©crit le r√©sultat un par un.  Par exemple, le code d'ex√©cution pour les cinq demandes ci-dessus ressemblerait √† ceci: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> [montlyPrices, yearlyPrices, flightsSchedule, originPopulars, destPopulars] = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all([ getMontlyPrices(), getYearlyPrices(), getFlightSchedule(), getOriginPopulars(), getDestPopulars() ])</code> </pre> <br><p>  Et nous obtenons toutes les donn√©es en 200-300 millisecondes, r√©duisant le temps de g√©n√©ration de donn√©es pour la page de 1-1,5 secondes √† ~ 500 millisecondes. </p><br><h3 id="zaklyuchenie">  Conclusion </h3><br><p>  Le passage de PHP √† NodeJS m'a aid√© √† me familiariser avec le JavaScript asynchrone, √† apprendre √† travailler avec les promesses et √† asynchroniser / attendre.  Apr√®s la r√©√©criture du moteur, la vitesse de chargement des pages a √©t√© optimis√©e et diff√©rait consid√©rablement des r√©sultats affich√©s par le moteur en PHP.  Dans cet article, nous pourrions √©galement parler de la fa√ßon dont les modules simples sont utilis√©s pour travailler avec le cache (Redis) et pg-promise (PostgreSQL) dans NodeJS et pour les comparer avec Memcached et php-pgsql, mais cet article s'est av√©r√© assez volumineux.  Et connaissant mon "talent" pour l'√©criture, elle s'est √©galement av√©r√©e mal structur√©e.  Le but de cet article est d'attirer l'attention des d√©veloppeurs qui travaillent toujours avec PHP et ne sont pas conscients des d√©lices de NodeJS et du d√©veloppement d'applications Web sur celui-ci en utilisant un exemple d'un projet r√©el qui a √©t√© √©crit en PHP, mais √† cause des pr√©f√©rences son propri√©taire est all√© sur une autre plateforme. </p><br><p>  J'esp√®re avoir pu transmettre mes pens√©es et plus ou moins structur√©es pour les exprimer dans ce mat√©riel.  Au moins j'ai essay√© :) </p><br><p>  √âcrivez des commentaires - amicaux ou en col√®re.  Je r√©pondrai √† tout constructif. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr444400/">https://habr.com/ru/post/fr444400/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr444390/index.html">Syst√®me DeviceLock 8.3 DLP: un an s'est √©coul√©, Billy, mais vous n'avez pas chang√© du tout</a></li>
<li><a href="../fr444392/index.html">Rayonnement: risques, s√©curit√©, protection</a></li>
<li><a href="../fr444394/index.html">Linux Foundation lance un nouveau projet DevOps avec Jenkins et Spinnaker</a></li>
<li><a href="../fr444396/index.html">Stand Epson √† l'ISE 2019 - l'exposition est pass√©e, les impressions restent</a></li>
<li><a href="../fr444398/index.html">Pourquoi les magasins non alimentaires ont-ils besoin d'une organisation en libre-service?</a></li>
<li><a href="../fr444402/index.html">R√©action du fractionnement du code en 2019</a></li>
<li><a href="../fr444404/index.html">Pourquoi avons-nous peur des robots?</a></li>
<li><a href="../fr444406/index.html">Italie num√©rique. Quoi et comment √ßa marche</a></li>
<li><a href="../fr444408/index.html">Apple a sorti hier de nouveaux iPads et a des questions.</a></li>
<li><a href="../fr444410/index.html">Cartes r√©seau. Un bref aper√ßu des logiciels de cr√©ation de cartes r√©seau</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>