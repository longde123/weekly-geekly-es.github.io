<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏾‍🤝‍👨🏼 👨🏼‍🔬 👩🏻‍🤝‍👨🏿 Criando um gerador de quebra-cabeças procedural 👩🏽‍🤝‍👩🏼 🏄 ⛑️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Este post descreve o gerador de nível para o meu jogo de quebra-cabeça Linjat . Uma postagem pode ser lida sem preparação, mas é mais fácil assimilar ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Criando um gerador de quebra-cabeças procedural</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/452090/"> Este post descreve o gerador de nível para o meu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">jogo de</a> quebra-cabeça <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Linjat</a> .  Uma postagem pode ser lida sem preparação, mas é mais fácil assimilar se você jogar em vários níveis.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Publiquei o</a> código fonte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">no github</a> ;  tudo o que foi discutido no artigo está no <code>src/main.cc</code> <br><br>  Exemplo de plano de postagem: <br><br><ul><li>  Linjat é um jogo de lógica em que você precisa fechar todos os números e pontos da grade com linhas. </li><li>  Os quebra-cabeças são gerados proceduralmente usando uma combinação de solucionador, gerador e otimizador. </li><li>  O Solver tenta resolver os quebra-cabeças da maneira que uma pessoa faria e atribui a cada quebra-cabeça uma classificação de interesse. </li><li>  O gerador de quebra-cabeças é projetado de tal maneira que é possível alterar facilmente uma parte do quebra-cabeça (número), enquanto todas as outras partes (pontos) são alteradas para que o quebra-cabeça permaneça solucionável. </li><li>  O otimizador de quebra-cabeças resolve repetidamente os níveis e gera novas variações das mais interessantes encontradas no momento. </li></ul><br><h3>  As regras </h3><br>  Para entender como o gerador de níveis funciona, você precisa, infelizmente, entender as regras do jogo.  Felizmente, eles são muito simples.  O quebra-cabeça consiste em uma grade contendo quadrados, números e pontos vazios.  Um exemplo: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/641/0d0/547/6410d0547bc14faae51beb3942867cb0.png"></div><br>  O objetivo do jogador é desenhar uma linha vertical ou horizontal através de cada um dos números, sujeita a três condições: <br><br><ul><li>  Uma linha através de um número deve ter o mesmo comprimento que o número. </li><li>  As linhas não podem se cruzar. </li><li>  Todos os pontos devem ser fechados com linhas. </li></ul><br>  Solução de exemplo: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7e1/3ce/91c/7e13ce91c2da2e2d64bd98f523010671.png"></div><br>  Viva!  O design do jogo está pronto, a interface do usuário está implementada e agora só resta encontrar centenas de bons quebra-cabeças.  E para esses jogos, geralmente não faz sentido tentar criar esses quebra-cabeças manualmente.  Este é um trabalho de computador. <br><a name="habracut"></a><br><h3>  Exigências </h3><br>  O que torna o quebra-cabeça desse jogo bom?  Estou inclinado a acreditar que os jogos de quebra-cabeça podem ser divididos em duas categorias.  Existem jogos nos quais você explora um espaço de estado complexo do começo ao fim (por exemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Sokoban</a> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Hora do Rush</a> ) e nos quais pode não ser óbvio quais estados existem no jogo.  E há jogos nos quais todos os estados são conhecidos desde o início, e gradualmente modelamos o espaço de estados usando o processo de eliminar os desnecessários (por exemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Sudoku</a> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Picross</a> ).  Meu jogo definitivamente se enquadra na segunda categoria. <br><br>  Os jogadores têm requisitos muito diferentes para esses diferentes tipos de quebra-cabeças.  No segundo caso, eles esperam que o quebra-cabeça possa ser resolvido apenas por dedução e que nunca precisarão voltar atrás / adivinhar / tentar e errar <sup>[0]</sup> <sup>[1]</sup> . <br><br>  Não basta saber se um quebra-cabeça só pode ser resolvido pela lógica.  Além disso, precisamos entender de alguma forma como os quebra-cabeças criados são bons.  Caso contrário, a maioria dos níveis será apenas escória trivial.  Em uma situação ideal, esse princípio também pode ser usado para criar uma curva de progresso suave, para que, à medida que o jogador avance no jogo, os níveis se tornem gradualmente mais difíceis. <br><br><h3>  Solver </h3><br>  O primeiro passo para atender a esses requisitos é criar um solucionador de jogos otimizado para essa finalidade.  O solucionador de retrocesso permite determinar com rapidez e precisão se o quebra-cabeça é solucionável;  Além disso, ele pode ser modificado para determinar se a solução é única.  Mas ele não pode dar uma idéia de quão complicado é o quebra-cabeça, porque as pessoas os resolvem de maneira diferente.  O solucionador deve imitar o comportamento humano. <br><br>  Como uma pessoa resolve esse quebra-cabeça?  Aqui estão alguns movimentos óbvios que o tutorial do jogo ensina: <br><br><ul><li>  Se um ponto puder ser alcançado a partir de apenas um número, para fechar um ponto, você precisará desenhar uma linha a partir desse número.  Neste exemplo, o ponto pode ser alcançado apenas entre os três, mas não entre os quatro: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/76d/1d4/e3e/76d1d4e3e87a0cc9efdebbd586420c84.png"></div><br>  E isso leva a esta situação: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a15/db3/05f/a15db305fa78a149ee614de0b4b8ed54.png"></div></li><li>  Se a linha não couber em uma direção, ela deverá ser colocada em outra.  No exemplo acima, os quatro não podem mais ser posicionados verticalmente, então sabemos que será horizontal: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5ef/048/99f/5ef04899f1c9da5a5b8492e1316ddcbf.png"></div></li><li>  Se for sabido que a linha de comprimento X deve estar em uma determinada posição (vertical / horizontal) e não houver espaço vazio suficiente para colocar uma linha de X células vazias em ambos os lados, será necessário cobrir vários quadrados no meio.  Se os quatro fossem três no exemplo mostrado acima, não saberíamos se estenderia todo o caminho para a direita ou esquerda.  Mas saberíamos que a linha deve cobrir dois quadrados do meio: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/02c/bfa/021/02cbfa02113362bc6e3c5217baee3ff3.png"></div></li></ul><br>  Raciocínio semelhante é a própria base do jogo.  O jogador procura maneiras de esticar uma pequena linha e, em seguida, examina o campo novamente, porque pode fornecer informações para outra conclusão lógica.  Criar um solucionador que siga essas regras será suficiente para determinar <i>se uma</i> pessoa pode resolver o quebra-cabeça sem voltar atrás. <br><br>  No entanto, isso não nos diz nada sobre a complexidade ou interesse do nível.  Além da solvabilidade, precisamos de alguma forma quantificar a complexidade. <br><br>  Uma primeira idéia óbvia para a função de classificação: quanto mais movimentos você precisar para resolver o quebra-cabeça, mais difícil será.  Essa é provavelmente uma boa métrica em outros jogos, mas a minha, provavelmente, é mais importante do que o número de jogadas permitidas que um jogador possui.  Se um jogador pode tirar 10 conclusões lógicas, ele provavelmente encontrará uma delas muito rapidamente.  Se houver apenas um movimento certo, levará mais tempo. <br><br>  Ou seja, como primeira aproximação, precisamos que a árvore de decisão seja profunda e estreita: há uma longa dependência de movimentos do começo ao fim, e a cada momento há apenas um pequeno número de maneiras de subir a cadeia <sup>[2]</sup> . <br><br>  Como determinamos a largura e a profundidade de uma árvore?  Uma solução única para o quebra-cabeça e a avaliação da árvore criada não fornecerá uma resposta exata.  A ordem exata em que os movimentos são feitos afeta a forma da árvore.  Precisamos considerar todas as soluções possíveis e fazer com elas algo como otimização para os melhores e os piores casos.  Eu estou familiarizado com a técnica de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pesquisa aproximada de gráficos de pesquisa em jogos de quebra-cabeça</a> , mas para este projeto eu queria criar um solucionador de uma passagem, e não uma pesquisa exaustiva.  Devido à fase de otimização, tentei garantir que o tempo de execução do solucionador fosse medido não em segundos, mas em milissegundos. <br><br>  Eu decidi não.  Em vez disso, meu solucionador não faz um movimento de cada vez, mas resolve o quebra-cabeça em camadas: assumindo um estado, ele encontra todos os movimentos válidos que podem ser feitos.  Então ele aplica todos esses movimentos ao mesmo tempo e começa de novo em um novo estado.  O número de camadas e o número máximo de movimentos encontrados em uma camada são usados ​​como valores aproximados da profundidade e largura da árvore de pesquisa como um todo. <br><br>  Veja como resolver um dos quebra-cabeças difíceis com este modelo.  Linhas pontilhadas são linhas esticadas nessa camada do solucionador, linhas sólidas são aquelas que não foram alteradas.  As linhas verdes têm o comprimento correto, as vermelhas ainda não estão completas. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2af/1de/cfb/2af1decfbc170ec8965ae8b1cce2cbea.png"></div><br>  O próximo problema é que todos os movimentos feitos pelo jogador são criados iguais.  O que listamos no início desta seção é apenas senso comum.  Aqui está um exemplo de uma regra de dedução mais complexa, cuja pesquisa exigirá um pouco mais de reflexão.  Considere o seguinte campo: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9c4/c18/772/9c4c187726bf50f03bbffa748137cf44.png"></div><br>  Os pontos em C e D podem ser cobertos apenas pelos cinco e pelos quatro do meio (e nem um único número pode cobrir os dois pontos ao mesmo tempo).  Isso significa que os quatro no meio devem cobrir um ponto de dois e, portanto, não podem ser usados ​​para cobrir A. Portanto, o ponto A deve fechar os quatro no canto inferior esquerdo. <br><br>  Obviamente, seria tolice considerar essa cadeia de raciocínio igual à simples conclusão de que "este ponto só pode ser alcançado a partir desse número".  É possível dar mais peso a essas regras mais complexas na função de avaliação?  Infelizmente, em um solucionador baseado em camadas, isso não é possível, porque não é garantido que você encontre uma solução pelo menor custo.  Este não é apenas um problema teórico - na prática, muitas vezes acontece que parte do campo pode ser resolvida por um único argumento complexo ou por uma cadeia de movimentos muito mais simples.  De fato, um solucionador baseado em camada encontra o caminho mais curto e não menos oneroso, e isso não pode ser refletido na função de avaliação. <br><br>  Como resultado, cheguei a essa decisão: alterei o solucionador para que cada camada consistisse em apenas um tipo de raciocínio.  O algoritmo ignora as regras de raciocínio em uma ordem aproximada de complexidade.  Se a regra encontrar algumas jogadas, elas serão aplicadas, a iteração será encerrada e a próxima iteração iniciará a lista desde o início. <br><br>  Em seguida, a decisão recebe uma avaliação: cada camada recebe custos com base em uma regra que foi usada nela.  Isso ainda não garante que a solução seja a mais barata, mas se os pesos forem selecionados corretamente, o algoritmo pelo menos não encontrará uma solução cara se houver uma barata. <br><br>  Além disso, é muito parecido com o modo como as pessoas resolvem quebra-cabeças.  Eles primeiro tentam encontrar soluções fáceis e começam a mover ativamente seus cérebros apenas se não houver movimentos simples. <br><br><h3>  Gerador </h3><br>  A seção anterior determinou se um determinado nível era bom ou ruim.  Mas isso não basta, ainda precisamos gerar níveis para que o solucionador possa avaliá-los.  É muito improvável que um mundo gerado aleatoriamente seja solucionável, sem mencionar interessante. <br><br>  A idéia principal (não é de forma alguma nova) é o uso alternativo do solucionador e do gerador.  Vamos começar com um quebra-cabeça, que provavelmente é insolúvel: basta colocar dois a cinco números em quadrados aleatórios da célula: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8cf/164/3c5/8cf1643c568477bc2c774d33a0994f96.png"></div><br>  O Solver funciona até que ele possa se desenvolver ainda mais: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/64f/9b4/a5c/64f9b4a5c022b2560c1a26746a0c3539.png"></div><br>  Em seguida, o gerador adiciona mais informações ao quebra-cabeça na forma de um ponto, após o qual a execução do solucionador continua. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1b4/397/23f/1b439723f7d229887c8392ebc07053f3.png"></div><br>  Nesse caso, o ponto adicionado ao solucionador não é suficiente para desenvolvimento adicional.  Em seguida, o gerador continuará adicionando novos pontos até satisfazer o solucionador: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6b2/3a0/48d/6b23a048dc66700a3eadf94206705c7c.png"></div><br>  E então o solucionador continua seu trabalho habitual: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b8e/b9a/77a/b8eb9a77a027a741ce259a1b95fe9c89.png"></div><br>  Esse processo continua até que o quebra-cabeça seja resolvido ou até que haja mais informações a serem adicionadas (por exemplo, quando cada célula que pode ser alcançada a partir do número já contém um ponto). <br><br>  Este método funciona apenas se as novas informações adicionadas não puderem tornar incorretas nenhuma das conclusões feitas anteriormente.  Isso seria difícil de fazer ao adicionar números à grade <sup>[3]</sup> .  Mas adicionar novos pontos ao campo tem essa propriedade;  pelo menos para as regras de raciocínio que eu uso neste programa. <br><br>  Onde o algoritmo deve adicionar pontos?  No final, decidi adicioná-los ao espaço vazio, que pode ser fechado no estado inicial com o maior número possível de linhas, para que cada ponto procure fornecer o mínimo de informações possível.  Não tentei colocar especificamente o ponto no local em que seria útil para avançar na solução do quebra-cabeça no momento em que o solucionador fica preso.  Isso cria um efeito muito conveniente: a maioria dos pontos no início do quebra-cabeça parece completamente inútil, o que torna o quebra-cabeça mais difícil do que realmente é.  Se tudo isso for um monte de jogadas óbvias que um jogador pode fazer, mas por algum motivo, nenhuma delas não funciona corretamente.  Como resultado, verificou-se que o gerador de quebra-cabeças se comporta um pouco como um porco. <br><br>  Esse processo nem sempre cria uma solução, mas é bastante rápido (cerca de 50 a 100 milissegundos); portanto, para gerar um nível, basta repeti-lo várias vezes.  Infelizmente, ele geralmente cria quebra-cabeças medíocres.  Desde o início, existem movimentos óbvios demais, o campo se enche muito rapidamente e a árvore de decisão acaba sendo rasa. <br><br><h3>  Optimizer </h3><br>  O processo descrito acima criou quebra-cabeças medíocres.  No último estágio, utilizo esses níveis como base para o processo de otimização.  Funciona da seguinte maneira. <br><br>  O otimizador cria um pool que contém até 10 opções de quebra-cabeça.  O pool é inicializado com um novo quebra-cabeça aleatório gerado.  A cada iteração, o otimizador seleciona um quebra-cabeça da piscina e executa sua mutação. <br><br>  A mutação exclui todos os pontos e depois altera ligeiramente os números (ou seja, diminui / aumenta o valor de um número selecionado aleatoriamente ou move o número para outra célula na grade).  Você pode aplicar várias mutações ao campo ao mesmo tempo.  Em seguida, executamos o solucionador no modo de geração de nível especial descrito na seção anterior.  Ele adiciona pontos suficientes ao quebra-cabeça para que ele se torne solucionável novamente. <br><br>  Depois disso, iniciamos o solucionador novamente, desta vez no modo normal.  Durante essa execução, o solucionador monitora a) a profundidade da árvore de decisão, b) a frequência da necessidade de diferentes tipos de regras; c) a largura da árvore de decisão em diferentes momentos no tempo.  O quebra-cabeça é avaliado com base nos critérios descritos acima.  A função de avaliação prefere soluções profundas e estreitas, e níveis de complexidade aumentada também agregam mais peso aos quebra-cabeças nos quais são necessárias regras mais complexas de raciocínio. <br><br>  Em seguida, um novo quebra-cabeça é adicionado à piscina.  Se a piscina contiver mais de 10 quebra-cabeças, o pior será descartado. <br><br>  Esse processo é repetido várias vezes (aproximadamente 10.000-5.000 iterações me levaram).  Depois disso, a versão mais alta do quebra-cabeça é salva no banco de dados no nível do quebra-cabeça.  Veja como é o progresso do melhor quebra-cabeça em uma execução de otimização: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/504/e61/40c/504e6140c20049ca3424456de0985aaf.png"></div><br>  Tentei usar outras maneiras de estruturar a otimização.  Em uma versão, o recozimento simulado foi utilizado, outros eram algoritmos genéticos com várias operações de cruzamento.  Nenhuma das soluções foi executada, assim como um algoritmo ingênuo, com um conjunto de opções voltando ao topo. <br><br><h3>  Solução única e única </h3><br>  Quando um quebra-cabeça tem uma solução única, surge uma dificuldade interessante.  É possível permitir ao jogador assumir que existe uma solução e tirar conclusões com base nisso?  Seria justo se o gerador de quebra-cabeças sugerisse que o jogador o fez? <br><br>  Em um post no HackerNews, eu disse que existem quatro opções para abordar essa situação: <br><br><ul><li>  Declare a exclusividade da solução desde o início e force o gerador a criar níveis que exijam esse tipo de raciocínio.  Esta é uma péssima decisão porque complica o entendimento das regras.  E geralmente esses são os detalhes que as pessoas esquecem. </li><li>  Não garanta a exclusividade de uma decisão: potencialmente, tenha muitas decisões e tome todas elas.  De fato, isso não resolve o problema, mas o afasta. </li><li>  Apenas suponha que este é um evento muito raro, que na prática não é importante.  (Essa é a solução usada na implementação inicial.) </li><li>  Mude o gerador de quebra-cabeças para que não gere quebra-cabeças nos quais o conhecimento da singularidade da solução ajudaria.  (Provavelmente a solução certa, mas exigindo trabalho adicional.) </li></ul><br>  Inicialmente, escolhi a última opção, e esse foi um erro terrível.  Aconteceu que eu levei em conta apenas uma maneira pela qual a singularidade da solução levou ao vazamento de informações, e na verdade é bastante raro.  Mas existem outros;  um deles estava de fato presente em todos os níveis que gerava e muitas vezes levava ao fato de que a solução se tornava trivial.  Portanto, em maio de 2019, alterei os modos Difícil e Especialista usando a terceira opção. <br><br>  O caso mais irritante é um empate com uma linha tracejada neste campo: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/af9/ecf/34f/af9ecf34f96e0d74ae1f514207940020.png"></div><br>  Por que um jogador astuto pode tirar essa conclusão?  Um empate pode cobrir qualquer um dos quatro quadrados vizinhos.  Nenhum deles tem pontos, portanto não precisa ser coberto por uma linha.  E o quadrado abaixo não tem sobreposições com outros números.  Se houver uma solução única, esse deve ser o caso quando outros números cobrirem os três quadrados restantes e os dois fecharem o quadrado abaixo dele. <br><br>  A solução é adicionar mais alguns pontos ao reconhecer esses casos: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d7d/d45/ebd/d7dd45ebd5d0a7aebbc78e7da61e1cd9.png"></div><br>  Outro caso comum é um traço com uma linha pontilhada neste campo: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/252/fc8/13e/252fc813e342f503a2c189645590e7f1.png"></div><br>  Os quadrados à esquerda e em cima dos dois não são diferentes.  Nenhum deles tem um ponto, e nenhum pode ser alcançado a partir de qualquer outro número.  Qualquer solução em que um empate cubra o quadrado superior terá uma solução correspondente na qual fecha o quadrado esquerdo e vice-versa.  Se houvesse uma única solução única, não seria possível, e o empate deveria ter coberto o quadrado inferior. <br><br>  Decidi esse tipo de caso da maneira "se doer, não toque".  O Solver aplicou essa regra em um estágio inicial da lista de prioridades e atribuiu um peso negativo a esses movimentos.  Os quebra-cabeças com esse recurso geralmente são descartados pelo otimizador, e os poucos restantes são descartados no estágio da seleção final de níveis para o jogo publicado. <br><br>  Esta não é uma lista completa: durante o teste de reprodução com uma busca deliberada por erros, encontrei muitas outras regras para soluções exclusivas.  Mas a maioria deles parecia rara e eles eram suficientes para encontrar, então eles não simplificaram muito o jogo.  Se alguém resolver o quebra-cabeça usando esse raciocínio, não vou culpá-lo. <br><br><h3>  Conclusão </h3><br>  Inicialmente, o jogo foi desenvolvido como um experimento na geração processual de quebra-cabeças.  O design e o gerador do jogo andaram de mãos dadas, por isso é difícil aplicar as próprias técnicas diretamente a outros jogos. <br><br>  A pergunta à qual não tenho resposta: o investimento de tais esforços na geração processual se justificou?<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O feedback dos jogadores sobre o design de níveis foi muito controverso. Nos comentários positivos, costumava-se dizer que alguns truques complicados sempre são sentidos nos quebra-cabeças. Na maioria das críticas negativas, eles me escreveram que o jogo carece de um gradiente de complexidade. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ainda tenho alguns quebra-cabeças na infância, e gostei tanto do gerador que provavelmente usarei uma abordagem processual semelhante para eles. Vou mudar apenas uma coisa: desde o início, conduzirei testes ativos com a busca de erros.</font></font><br><br><h3>  Anotações </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[0] Ou, pelo menos, me pareceu. Mas quando eu assisti os jogadores ao vivo, quase metade deles apenas fez palpites e depois iterou através deles. Oh bem. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[1] Os leitores do meu artigo também devem ler o artigo </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Resolvendo Campo Minado e melhorando</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Magnus Hoff. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[2] Esclarecerei que a profundidade / estreiteza de uma árvore é uma métrica que considerei significativa para o meu jogo, e não para todos os outros quebra-cabeças. Por exemplo, há um </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://web.archive.org/web/20130703141244/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bom argumento de</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> que o quebra-cabeça da Hora do Rush é interessante se tiver várias maneiras de resolver quase, mas não exatamente do mesmo tamanho. Mas aconteceu porque o Rush Hour é um jogo para encontrar a solução mais curta, e não apenas qualquer solução.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[3] Excluindo a adição de unidades. </font><font style="vertical-align: inherit;">Não havia pontos na primeira versão do quebra-cabeça, e o plano era o gerador adicionar unidades, se necessário. </font><font style="vertical-align: inherit;">Mas isso parecia muito restritivo.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt452090/">https://habr.com/ru/post/pt452090/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt452076/index.html">Quebrando o navegador UC</a></li>
<li><a href="../pt452078/index.html">Reserva de Kubernetes: Existe</a></li>
<li><a href="../pt452082/index.html">Fluxo flexível de atualizações no aplicativo: acelere o processo de atualização de aplicativos no Android</a></li>
<li><a href="../pt452086/index.html">O que há no meu pixel para você: criação de nanopixels usando metassuperfícies de plasmon</a></li>
<li><a href="../pt452088/index.html">Reconhecimento de estradas por segmentação semântica</a></li>
<li><a href="../pt452092/index.html">Atualizações no aplicativo: Acelerando as atualizações de aplicativos Android</a></li>
<li><a href="../pt452094/index.html">.NET: Ferramentas para trabalhar com multithreading e assincronia. Parte 1</a></li>
<li><a href="../pt452098/index.html">Logs do desenvolvedor front-end Habr: refator e reflexo</a></li>
<li><a href="../pt452102/index.html">Jogo de fotos para quem gosta de drones: brevemente sobre o AirSelfie 2</a></li>
<li><a href="../pt452106/index.html">Convidamos palestrantes para a reunião de bricolage de verão em 16 de junho de 2019</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>