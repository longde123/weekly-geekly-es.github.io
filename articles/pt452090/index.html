<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèæ‚Äçü§ù‚Äçüë®üèº üë®üèº‚Äçüî¨ üë©üèª‚Äçü§ù‚Äçüë®üèø Criando um gerador de quebra-cabe√ßas procedural üë©üèΩ‚Äçü§ù‚Äçüë©üèº üèÑ ‚õëÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Este post descreve o gerador de n√≠vel para o meu jogo de quebra-cabe√ßa Linjat . Uma postagem pode ser lida sem prepara√ß√£o, mas √© mais f√°cil assimilar ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Criando um gerador de quebra-cabe√ßas procedural</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/452090/"> Este post descreve o gerador de n√≠vel para o meu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">jogo de</a> quebra-cabe√ßa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Linjat</a> .  Uma postagem pode ser lida sem prepara√ß√£o, mas √© mais f√°cil assimilar se voc√™ jogar em v√°rios n√≠veis.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Publiquei o</a> c√≥digo fonte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">no github</a> ;  tudo o que foi discutido no artigo est√° no <code>src/main.cc</code> <br><br>  Exemplo de plano de postagem: <br><br><ul><li>  Linjat √© um jogo de l√≥gica em que voc√™ precisa fechar todos os n√∫meros e pontos da grade com linhas. </li><li>  Os quebra-cabe√ßas s√£o gerados proceduralmente usando uma combina√ß√£o de solucionador, gerador e otimizador. </li><li>  O Solver tenta resolver os quebra-cabe√ßas da maneira que uma pessoa faria e atribui a cada quebra-cabe√ßa uma classifica√ß√£o de interesse. </li><li>  O gerador de quebra-cabe√ßas √© projetado de tal maneira que √© poss√≠vel alterar facilmente uma parte do quebra-cabe√ßa (n√∫mero), enquanto todas as outras partes (pontos) s√£o alteradas para que o quebra-cabe√ßa permane√ßa solucion√°vel. </li><li>  O otimizador de quebra-cabe√ßas resolve repetidamente os n√≠veis e gera novas varia√ß√µes das mais interessantes encontradas no momento. </li></ul><br><h3>  As regras </h3><br>  Para entender como o gerador de n√≠veis funciona, voc√™ precisa, infelizmente, entender as regras do jogo.  Felizmente, eles s√£o muito simples.  O quebra-cabe√ßa consiste em uma grade contendo quadrados, n√∫meros e pontos vazios.  Um exemplo: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/641/0d0/547/6410d0547bc14faae51beb3942867cb0.png"></div><br>  O objetivo do jogador √© desenhar uma linha vertical ou horizontal atrav√©s de cada um dos n√∫meros, sujeita a tr√™s condi√ß√µes: <br><br><ul><li>  Uma linha atrav√©s de um n√∫mero deve ter o mesmo comprimento que o n√∫mero. </li><li>  As linhas n√£o podem se cruzar. </li><li>  Todos os pontos devem ser fechados com linhas. </li></ul><br>  Solu√ß√£o de exemplo: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7e1/3ce/91c/7e13ce91c2da2e2d64bd98f523010671.png"></div><br>  Viva!  O design do jogo est√° pronto, a interface do usu√°rio est√° implementada e agora s√≥ resta encontrar centenas de bons quebra-cabe√ßas.  E para esses jogos, geralmente n√£o faz sentido tentar criar esses quebra-cabe√ßas manualmente.  Este √© um trabalho de computador. <br><a name="habracut"></a><br><h3>  Exig√™ncias </h3><br>  O que torna o quebra-cabe√ßa desse jogo bom?  Estou inclinado a acreditar que os jogos de quebra-cabe√ßa podem ser divididos em duas categorias.  Existem jogos nos quais voc√™ explora um espa√ßo de estado complexo do come√ßo ao fim (por exemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Sokoban</a> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Hora do Rush</a> ) e nos quais pode n√£o ser √≥bvio quais estados existem no jogo.  E h√° jogos nos quais todos os estados s√£o conhecidos desde o in√≠cio, e gradualmente modelamos o espa√ßo de estados usando o processo de eliminar os desnecess√°rios (por exemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Sudoku</a> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Picross</a> ).  Meu jogo definitivamente se enquadra na segunda categoria. <br><br>  Os jogadores t√™m requisitos muito diferentes para esses diferentes tipos de quebra-cabe√ßas.  No segundo caso, eles esperam que o quebra-cabe√ßa possa ser resolvido apenas por dedu√ß√£o e que nunca precisar√£o voltar atr√°s / adivinhar / tentar e errar <sup>[0]</sup> <sup>[1]</sup> . <br><br>  N√£o basta saber se um quebra-cabe√ßa s√≥ pode ser resolvido pela l√≥gica.  Al√©m disso, precisamos entender de alguma forma como os quebra-cabe√ßas criados s√£o bons.  Caso contr√°rio, a maioria dos n√≠veis ser√° apenas esc√≥ria trivial.  Em uma situa√ß√£o ideal, esse princ√≠pio tamb√©m pode ser usado para criar uma curva de progresso suave, para que, √† medida que o jogador avance no jogo, os n√≠veis se tornem gradualmente mais dif√≠ceis. <br><br><h3>  Solver </h3><br>  O primeiro passo para atender a esses requisitos √© criar um solucionador de jogos otimizado para essa finalidade.  O solucionador de retrocesso permite determinar com rapidez e precis√£o se o quebra-cabe√ßa √© solucion√°vel;  Al√©m disso, ele pode ser modificado para determinar se a solu√ß√£o √© √∫nica.  Mas ele n√£o pode dar uma id√©ia de qu√£o complicado √© o quebra-cabe√ßa, porque as pessoas os resolvem de maneira diferente.  O solucionador deve imitar o comportamento humano. <br><br>  Como uma pessoa resolve esse quebra-cabe√ßa?  Aqui est√£o alguns movimentos √≥bvios que o tutorial do jogo ensina: <br><br><ul><li>  Se um ponto puder ser alcan√ßado a partir de apenas um n√∫mero, para fechar um ponto, voc√™ precisar√° desenhar uma linha a partir desse n√∫mero.  Neste exemplo, o ponto pode ser alcan√ßado apenas entre os tr√™s, mas n√£o entre os quatro: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/76d/1d4/e3e/76d1d4e3e87a0cc9efdebbd586420c84.png"></div><br>  E isso leva a esta situa√ß√£o: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a15/db3/05f/a15db305fa78a149ee614de0b4b8ed54.png"></div></li><li>  Se a linha n√£o couber em uma dire√ß√£o, ela dever√° ser colocada em outra.  No exemplo acima, os quatro n√£o podem mais ser posicionados verticalmente, ent√£o sabemos que ser√° horizontal: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5ef/048/99f/5ef04899f1c9da5a5b8492e1316ddcbf.png"></div></li><li>  Se for sabido que a linha de comprimento X deve estar em uma determinada posi√ß√£o (vertical / horizontal) e n√£o houver espa√ßo vazio suficiente para colocar uma linha de X c√©lulas vazias em ambos os lados, ser√° necess√°rio cobrir v√°rios quadrados no meio.  Se os quatro fossem tr√™s no exemplo mostrado acima, n√£o saber√≠amos se estenderia todo o caminho para a direita ou esquerda.  Mas saber√≠amos que a linha deve cobrir dois quadrados do meio: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/02c/bfa/021/02cbfa02113362bc6e3c5217baee3ff3.png"></div></li></ul><br>  Racioc√≠nio semelhante √© a pr√≥pria base do jogo.  O jogador procura maneiras de esticar uma pequena linha e, em seguida, examina o campo novamente, porque pode fornecer informa√ß√µes para outra conclus√£o l√≥gica.  Criar um solucionador que siga essas regras ser√° suficiente para determinar <i>se uma</i> pessoa pode resolver o quebra-cabe√ßa sem voltar atr√°s. <br><br>  No entanto, isso n√£o nos diz nada sobre a complexidade ou interesse do n√≠vel.  Al√©m da solvabilidade, precisamos de alguma forma quantificar a complexidade. <br><br>  Uma primeira id√©ia √≥bvia para a fun√ß√£o de classifica√ß√£o: quanto mais movimentos voc√™ precisar para resolver o quebra-cabe√ßa, mais dif√≠cil ser√°.  Essa √© provavelmente uma boa m√©trica em outros jogos, mas a minha, provavelmente, √© mais importante do que o n√∫mero de jogadas permitidas que um jogador possui.  Se um jogador pode tirar 10 conclus√µes l√≥gicas, ele provavelmente encontrar√° uma delas muito rapidamente.  Se houver apenas um movimento certo, levar√° mais tempo. <br><br>  Ou seja, como primeira aproxima√ß√£o, precisamos que a √°rvore de decis√£o seja profunda e estreita: h√° uma longa depend√™ncia de movimentos do come√ßo ao fim, e a cada momento h√° apenas um pequeno n√∫mero de maneiras de subir a cadeia <sup>[2]</sup> . <br><br>  Como determinamos a largura e a profundidade de uma √°rvore?  Uma solu√ß√£o √∫nica para o quebra-cabe√ßa e a avalia√ß√£o da √°rvore criada n√£o fornecer√° uma resposta exata.  A ordem exata em que os movimentos s√£o feitos afeta a forma da √°rvore.  Precisamos considerar todas as solu√ß√µes poss√≠veis e fazer com elas algo como otimiza√ß√£o para os melhores e os piores casos.  Eu estou familiarizado com a t√©cnica de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pesquisa aproximada de gr√°ficos de pesquisa em jogos de quebra-cabe√ßa</a> , mas para este projeto eu queria criar um solucionador de uma passagem, e n√£o uma pesquisa exaustiva.  Devido √† fase de otimiza√ß√£o, tentei garantir que o tempo de execu√ß√£o do solucionador fosse medido n√£o em segundos, mas em milissegundos. <br><br>  Eu decidi n√£o.  Em vez disso, meu solucionador n√£o faz um movimento de cada vez, mas resolve o quebra-cabe√ßa em camadas: assumindo um estado, ele encontra todos os movimentos v√°lidos que podem ser feitos.  Ent√£o ele aplica todos esses movimentos ao mesmo tempo e come√ßa de novo em um novo estado.  O n√∫mero de camadas e o n√∫mero m√°ximo de movimentos encontrados em uma camada s√£o usados ‚Äã‚Äãcomo valores aproximados da profundidade e largura da √°rvore de pesquisa como um todo. <br><br>  Veja como resolver um dos quebra-cabe√ßas dif√≠ceis com este modelo.  Linhas pontilhadas s√£o linhas esticadas nessa camada do solucionador, linhas s√≥lidas s√£o aquelas que n√£o foram alteradas.  As linhas verdes t√™m o comprimento correto, as vermelhas ainda n√£o est√£o completas. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2af/1de/cfb/2af1decfbc170ec8965ae8b1cce2cbea.png"></div><br>  O pr√≥ximo problema √© que todos os movimentos feitos pelo jogador s√£o criados iguais.  O que listamos no in√≠cio desta se√ß√£o √© apenas senso comum.  Aqui est√° um exemplo de uma regra de dedu√ß√£o mais complexa, cuja pesquisa exigir√° um pouco mais de reflex√£o.  Considere o seguinte campo: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9c4/c18/772/9c4c187726bf50f03bbffa748137cf44.png"></div><br>  Os pontos em C e D podem ser cobertos apenas pelos cinco e pelos quatro do meio (e nem um √∫nico n√∫mero pode cobrir os dois pontos ao mesmo tempo).  Isso significa que os quatro no meio devem cobrir um ponto de dois e, portanto, n√£o podem ser usados ‚Äã‚Äãpara cobrir A. Portanto, o ponto A deve fechar os quatro no canto inferior esquerdo. <br><br>  Obviamente, seria tolice considerar essa cadeia de racioc√≠nio igual √† simples conclus√£o de que "este ponto s√≥ pode ser alcan√ßado a partir desse n√∫mero".  √â poss√≠vel dar mais peso a essas regras mais complexas na fun√ß√£o de avalia√ß√£o?  Infelizmente, em um solucionador baseado em camadas, isso n√£o √© poss√≠vel, porque n√£o √© garantido que voc√™ encontre uma solu√ß√£o pelo menor custo.  Este n√£o √© apenas um problema te√≥rico - na pr√°tica, muitas vezes acontece que parte do campo pode ser resolvida por um √∫nico argumento complexo ou por uma cadeia de movimentos muito mais simples.  De fato, um solucionador baseado em camada encontra o caminho mais curto e n√£o menos oneroso, e isso n√£o pode ser refletido na fun√ß√£o de avalia√ß√£o. <br><br>  Como resultado, cheguei a essa decis√£o: alterei o solucionador para que cada camada consistisse em apenas um tipo de racioc√≠nio.  O algoritmo ignora as regras de racioc√≠nio em uma ordem aproximada de complexidade.  Se a regra encontrar algumas jogadas, elas ser√£o aplicadas, a itera√ß√£o ser√° encerrada e a pr√≥xima itera√ß√£o iniciar√° a lista desde o in√≠cio. <br><br>  Em seguida, a decis√£o recebe uma avalia√ß√£o: cada camada recebe custos com base em uma regra que foi usada nela.  Isso ainda n√£o garante que a solu√ß√£o seja a mais barata, mas se os pesos forem selecionados corretamente, o algoritmo pelo menos n√£o encontrar√° uma solu√ß√£o cara se houver uma barata. <br><br>  Al√©m disso, √© muito parecido com o modo como as pessoas resolvem quebra-cabe√ßas.  Eles primeiro tentam encontrar solu√ß√µes f√°ceis e come√ßam a mover ativamente seus c√©rebros apenas se n√£o houver movimentos simples. <br><br><h3>  Gerador </h3><br>  A se√ß√£o anterior determinou se um determinado n√≠vel era bom ou ruim.  Mas isso n√£o basta, ainda precisamos gerar n√≠veis para que o solucionador possa avali√°-los.  √â muito improv√°vel que um mundo gerado aleatoriamente seja solucion√°vel, sem mencionar interessante. <br><br>  A id√©ia principal (n√£o √© de forma alguma nova) √© o uso alternativo do solucionador e do gerador.  Vamos come√ßar com um quebra-cabe√ßa, que provavelmente √© insol√∫vel: basta colocar dois a cinco n√∫meros em quadrados aleat√≥rios da c√©lula: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8cf/164/3c5/8cf1643c568477bc2c774d33a0994f96.png"></div><br>  O Solver funciona at√© que ele possa se desenvolver ainda mais: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/64f/9b4/a5c/64f9b4a5c022b2560c1a26746a0c3539.png"></div><br>  Em seguida, o gerador adiciona mais informa√ß√µes ao quebra-cabe√ßa na forma de um ponto, ap√≥s o qual a execu√ß√£o do solucionador continua. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1b4/397/23f/1b439723f7d229887c8392ebc07053f3.png"></div><br>  Nesse caso, o ponto adicionado ao solucionador n√£o √© suficiente para desenvolvimento adicional.  Em seguida, o gerador continuar√° adicionando novos pontos at√© satisfazer o solucionador: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6b2/3a0/48d/6b23a048dc66700a3eadf94206705c7c.png"></div><br>  E ent√£o o solucionador continua seu trabalho habitual: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b8e/b9a/77a/b8eb9a77a027a741ce259a1b95fe9c89.png"></div><br>  Esse processo continua at√© que o quebra-cabe√ßa seja resolvido ou at√© que haja mais informa√ß√µes a serem adicionadas (por exemplo, quando cada c√©lula que pode ser alcan√ßada a partir do n√∫mero j√° cont√©m um ponto). <br><br>  Este m√©todo funciona apenas se as novas informa√ß√µes adicionadas n√£o puderem tornar incorretas nenhuma das conclus√µes feitas anteriormente.  Isso seria dif√≠cil de fazer ao adicionar n√∫meros √† grade <sup>[3]</sup> .  Mas adicionar novos pontos ao campo tem essa propriedade;  pelo menos para as regras de racioc√≠nio que eu uso neste programa. <br><br>  Onde o algoritmo deve adicionar pontos?  No final, decidi adicion√°-los ao espa√ßo vazio, que pode ser fechado no estado inicial com o maior n√∫mero poss√≠vel de linhas, para que cada ponto procure fornecer o m√≠nimo de informa√ß√µes poss√≠vel.  N√£o tentei colocar especificamente o ponto no local em que seria √∫til para avan√ßar na solu√ß√£o do quebra-cabe√ßa no momento em que o solucionador fica preso.  Isso cria um efeito muito conveniente: a maioria dos pontos no in√≠cio do quebra-cabe√ßa parece completamente in√∫til, o que torna o quebra-cabe√ßa mais dif√≠cil do que realmente √©.  Se tudo isso for um monte de jogadas √≥bvias que um jogador pode fazer, mas por algum motivo, nenhuma delas n√£o funciona corretamente.  Como resultado, verificou-se que o gerador de quebra-cabe√ßas se comporta um pouco como um porco. <br><br>  Esse processo nem sempre cria uma solu√ß√£o, mas √© bastante r√°pido (cerca de 50 a 100 milissegundos); portanto, para gerar um n√≠vel, basta repeti-lo v√°rias vezes.  Infelizmente, ele geralmente cria quebra-cabe√ßas med√≠ocres.  Desde o in√≠cio, existem movimentos √≥bvios demais, o campo se enche muito rapidamente e a √°rvore de decis√£o acaba sendo rasa. <br><br><h3>  Optimizer </h3><br>  O processo descrito acima criou quebra-cabe√ßas med√≠ocres.  No √∫ltimo est√°gio, utilizo esses n√≠veis como base para o processo de otimiza√ß√£o.  Funciona da seguinte maneira. <br><br>  O otimizador cria um pool que cont√©m at√© 10 op√ß√µes de quebra-cabe√ßa.  O pool √© inicializado com um novo quebra-cabe√ßa aleat√≥rio gerado.  A cada itera√ß√£o, o otimizador seleciona um quebra-cabe√ßa da piscina e executa sua muta√ß√£o. <br><br>  A muta√ß√£o exclui todos os pontos e depois altera ligeiramente os n√∫meros (ou seja, diminui / aumenta o valor de um n√∫mero selecionado aleatoriamente ou move o n√∫mero para outra c√©lula na grade).  Voc√™ pode aplicar v√°rias muta√ß√µes ao campo ao mesmo tempo.  Em seguida, executamos o solucionador no modo de gera√ß√£o de n√≠vel especial descrito na se√ß√£o anterior.  Ele adiciona pontos suficientes ao quebra-cabe√ßa para que ele se torne solucion√°vel novamente. <br><br>  Depois disso, iniciamos o solucionador novamente, desta vez no modo normal.  Durante essa execu√ß√£o, o solucionador monitora a) a profundidade da √°rvore de decis√£o, b) a frequ√™ncia da necessidade de diferentes tipos de regras; c) a largura da √°rvore de decis√£o em diferentes momentos no tempo.  O quebra-cabe√ßa √© avaliado com base nos crit√©rios descritos acima.  A fun√ß√£o de avalia√ß√£o prefere solu√ß√µes profundas e estreitas, e n√≠veis de complexidade aumentada tamb√©m agregam mais peso aos quebra-cabe√ßas nos quais s√£o necess√°rias regras mais complexas de racioc√≠nio. <br><br>  Em seguida, um novo quebra-cabe√ßa √© adicionado √† piscina.  Se a piscina contiver mais de 10 quebra-cabe√ßas, o pior ser√° descartado. <br><br>  Esse processo √© repetido v√°rias vezes (aproximadamente 10.000-5.000 itera√ß√µes me levaram).  Depois disso, a vers√£o mais alta do quebra-cabe√ßa √© salva no banco de dados no n√≠vel do quebra-cabe√ßa.  Veja como √© o progresso do melhor quebra-cabe√ßa em uma execu√ß√£o de otimiza√ß√£o: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/504/e61/40c/504e6140c20049ca3424456de0985aaf.png"></div><br>  Tentei usar outras maneiras de estruturar a otimiza√ß√£o.  Em uma vers√£o, o recozimento simulado foi utilizado, outros eram algoritmos gen√©ticos com v√°rias opera√ß√µes de cruzamento.  Nenhuma das solu√ß√µes foi executada, assim como um algoritmo ing√™nuo, com um conjunto de op√ß√µes voltando ao topo. <br><br><h3>  Solu√ß√£o √∫nica e √∫nica </h3><br>  Quando um quebra-cabe√ßa tem uma solu√ß√£o √∫nica, surge uma dificuldade interessante.  √â poss√≠vel permitir ao jogador assumir que existe uma solu√ß√£o e tirar conclus√µes com base nisso?  Seria justo se o gerador de quebra-cabe√ßas sugerisse que o jogador o fez? <br><br>  Em um post no HackerNews, eu disse que existem quatro op√ß√µes para abordar essa situa√ß√£o: <br><br><ul><li>  Declare a exclusividade da solu√ß√£o desde o in√≠cio e force o gerador a criar n√≠veis que exijam esse tipo de racioc√≠nio.  Esta √© uma p√©ssima decis√£o porque complica o entendimento das regras.  E geralmente esses s√£o os detalhes que as pessoas esquecem. </li><li>  N√£o garanta a exclusividade de uma decis√£o: potencialmente, tenha muitas decis√µes e tome todas elas.  De fato, isso n√£o resolve o problema, mas o afasta. </li><li>  Apenas suponha que este √© um evento muito raro, que na pr√°tica n√£o √© importante.  (Essa √© a solu√ß√£o usada na implementa√ß√£o inicial.) </li><li>  Mude o gerador de quebra-cabe√ßas para que n√£o gere quebra-cabe√ßas nos quais o conhecimento da singularidade da solu√ß√£o ajudaria.  (Provavelmente a solu√ß√£o certa, mas exigindo trabalho adicional.) </li></ul><br>  Inicialmente, escolhi a √∫ltima op√ß√£o, e esse foi um erro terr√≠vel.  Aconteceu que eu levei em conta apenas uma maneira pela qual a singularidade da solu√ß√£o levou ao vazamento de informa√ß√µes, e na verdade √© bastante raro.  Mas existem outros;  um deles estava de fato presente em todos os n√≠veis que gerava e muitas vezes levava ao fato de que a solu√ß√£o se tornava trivial.  Portanto, em maio de 2019, alterei os modos Dif√≠cil e Especialista usando a terceira op√ß√£o. <br><br>  O caso mais irritante √© um empate com uma linha tracejada neste campo: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/af9/ecf/34f/af9ecf34f96e0d74ae1f514207940020.png"></div><br>  Por que um jogador astuto pode tirar essa conclus√£o?  Um empate pode cobrir qualquer um dos quatro quadrados vizinhos.  Nenhum deles tem pontos, portanto n√£o precisa ser coberto por uma linha.  E o quadrado abaixo n√£o tem sobreposi√ß√µes com outros n√∫meros.  Se houver uma solu√ß√£o √∫nica, esse deve ser o caso quando outros n√∫meros cobrirem os tr√™s quadrados restantes e os dois fecharem o quadrado abaixo dele. <br><br>  A solu√ß√£o √© adicionar mais alguns pontos ao reconhecer esses casos: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d7d/d45/ebd/d7dd45ebd5d0a7aebbc78e7da61e1cd9.png"></div><br>  Outro caso comum √© um tra√ßo com uma linha pontilhada neste campo: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/252/fc8/13e/252fc813e342f503a2c189645590e7f1.png"></div><br>  Os quadrados √† esquerda e em cima dos dois n√£o s√£o diferentes.  Nenhum deles tem um ponto, e nenhum pode ser alcan√ßado a partir de qualquer outro n√∫mero.  Qualquer solu√ß√£o em que um empate cubra o quadrado superior ter√° uma solu√ß√£o correspondente na qual fecha o quadrado esquerdo e vice-versa.  Se houvesse uma √∫nica solu√ß√£o √∫nica, n√£o seria poss√≠vel, e o empate deveria ter coberto o quadrado inferior. <br><br>  Decidi esse tipo de caso da maneira "se doer, n√£o toque".  O Solver aplicou essa regra em um est√°gio inicial da lista de prioridades e atribuiu um peso negativo a esses movimentos.  Os quebra-cabe√ßas com esse recurso geralmente s√£o descartados pelo otimizador, e os poucos restantes s√£o descartados no est√°gio da sele√ß√£o final de n√≠veis para o jogo publicado. <br><br>  Esta n√£o √© uma lista completa: durante o teste de reprodu√ß√£o com uma busca deliberada por erros, encontrei muitas outras regras para solu√ß√µes exclusivas.  Mas a maioria deles parecia rara e eles eram suficientes para encontrar, ent√£o eles n√£o simplificaram muito o jogo.  Se algu√©m resolver o quebra-cabe√ßa usando esse racioc√≠nio, n√£o vou culp√°-lo. <br><br><h3>  Conclus√£o </h3><br>  Inicialmente, o jogo foi desenvolvido como um experimento na gera√ß√£o processual de quebra-cabe√ßas.  O design e o gerador do jogo andaram de m√£os dadas, por isso √© dif√≠cil aplicar as pr√≥prias t√©cnicas diretamente a outros jogos. <br><br>  A pergunta √† qual n√£o tenho resposta: o investimento de tais esfor√ßos na gera√ß√£o processual se justificou?<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O feedback dos jogadores sobre o design de n√≠veis foi muito controverso. Nos coment√°rios positivos, costumava-se dizer que alguns truques complicados sempre s√£o sentidos nos quebra-cabe√ßas. Na maioria das cr√≠ticas negativas, eles me escreveram que o jogo carece de um gradiente de complexidade. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ainda tenho alguns quebra-cabe√ßas na inf√¢ncia, e gostei tanto do gerador que provavelmente usarei uma abordagem processual semelhante para eles. Vou mudar apenas uma coisa: desde o in√≠cio, conduzirei testes ativos com a busca de erros.</font></font><br><br><h3>  Anota√ß√µes </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[0] Ou, pelo menos, me pareceu. Mas quando eu assisti os jogadores ao vivo, quase metade deles apenas fez palpites e depois iterou atrav√©s deles. Oh bem. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[1] Os leitores do meu artigo tamb√©m devem ler o artigo </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Resolvendo Campo Minado e melhorando</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Magnus Hoff. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[2] Esclarecerei que a profundidade / estreiteza de uma √°rvore √© uma m√©trica que considerei significativa para o meu jogo, e n√£o para todos os outros quebra-cabe√ßas. Por exemplo, h√° um </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://web.archive.org/web/20130703141244/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bom argumento de</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> que o quebra-cabe√ßa da Hora do Rush √© interessante se tiver v√°rias maneiras de resolver quase, mas n√£o exatamente do mesmo tamanho. Mas aconteceu porque o Rush Hour √© um jogo para encontrar a solu√ß√£o mais curta, e n√£o apenas qualquer solu√ß√£o.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[3] Excluindo a adi√ß√£o de unidades. </font><font style="vertical-align: inherit;">N√£o havia pontos na primeira vers√£o do quebra-cabe√ßa, e o plano era o gerador adicionar unidades, se necess√°rio. </font><font style="vertical-align: inherit;">Mas isso parecia muito restritivo.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt452090/">https://habr.com/ru/post/pt452090/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt452076/index.html">Quebrando o navegador UC</a></li>
<li><a href="../pt452078/index.html">Reserva de Kubernetes: Existe</a></li>
<li><a href="../pt452082/index.html">Fluxo flex√≠vel de atualiza√ß√µes no aplicativo: acelere o processo de atualiza√ß√£o de aplicativos no Android</a></li>
<li><a href="../pt452086/index.html">O que h√° no meu pixel para voc√™: cria√ß√£o de nanopixels usando metassuperf√≠cies de plasmon</a></li>
<li><a href="../pt452088/index.html">Reconhecimento de estradas por segmenta√ß√£o sem√¢ntica</a></li>
<li><a href="../pt452092/index.html">Atualiza√ß√µes no aplicativo: Acelerando as atualiza√ß√µes de aplicativos Android</a></li>
<li><a href="../pt452094/index.html">.NET: Ferramentas para trabalhar com multithreading e assincronia. Parte 1</a></li>
<li><a href="../pt452098/index.html">Logs do desenvolvedor front-end Habr: refator e reflexo</a></li>
<li><a href="../pt452102/index.html">Jogo de fotos para quem gosta de drones: brevemente sobre o AirSelfie 2</a></li>
<li><a href="../pt452106/index.html">Convidamos palestrantes para a reuni√£o de bricolage de ver√£o em 16 de junho de 2019</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>