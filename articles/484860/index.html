<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üåº ü§≤ üßò Nombre de implementaci√≥n y nombre del resultado üì§ „ÄΩÔ∏è ‚è´</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Quer√≠a escribir esta publicaci√≥n en julio, pero no pod√≠a, oh iron√≠a , decidir c√≥mo llamarla. Me vinieron a la mente buenos t√©rminos despu√©s de la char...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Nombre de implementaci√≥n y nombre del resultado</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/484860/"><p><img src="https://habrastorage.org/webt/sw/9a/fb/sw9afbxo38dofpspvffb0c_jrq4.jpeg"></p><br><p>  Quer√≠a escribir esta publicaci√≥n en julio, pero no pod√≠a, <em>oh iron√≠a</em> , decidir c√≥mo llamarla.  Me vinieron a la mente buenos t√©rminos despu√©s de <a href="https://www.youtube.com/watch%3Fv%3DMBRoCdtZOYg">la charla de Kate Gregory en CppCon</a> , y ahora finalmente puedo decirte c√≥mo llamar a las funciones. </p><br><p> Por supuesto, hay nombres que no llevan informaci√≥n en absoluto, como <code>int f(int x)</code> .  Tampoco necesitan ser utilizados, pero no se trata de ellos.  A veces sucede que parece que la informaci√≥n en el t√≠tulo est√° completa, pero no tiene ning√∫n beneficio. </p><a name="habracut"></a><br><h2 id="primer-1-stdlog2p1">  Ejemplo 1: std :: log2p1 () </h2><br><p>  En C ++ 20, se agregaron varias funciones nuevas para operaciones de bit al encabezado, entre otras <code>std::log2p1</code> .  Se ve as√≠: <br><br><br></p><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log2p1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::log2(x)); }</code> </pre><br><p>  Es decir, para cualquier n√∫mero natural, la funci√≥n devuelve su logaritmo binario m√°s 1, y para 0 devuelve 0. Y esto no es un problema escolar para el operador if / else, esto es realmente algo √∫til: la cantidad m√≠nima de bits en los que se ajustar√° este valor.  Solo adivinarlo por el nombre de la funci√≥n es casi imposible. </p><br><h2 id="primer-2-stdbless">  Ejemplo 2: std :: bless () </h2><br><p>  <em>Ahora no ser√° sobre el nombre</em> </p><br><p>  Una peque√±a digresi√≥n: en C ++, la aritm√©tica de puntero solo funciona con punteros para agrupar elementos.  Lo cual, en principio, es l√≥gico: en el caso general, el conjunto de objetos vecinos es desconocido y "cualquier cosa puede suceder en diez bytes a la derecha de la variable <code>i</code> ".  Este es un comportamiento inequ√≠vocamente vago. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> obj = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* ptr = &amp;obj; ++ptr; <span class="hljs-comment"><span class="hljs-comment">//  </span></span></code> </pre> <br><p>  Pero tal restricci√≥n declara una gran cantidad de comportamiento de c√≥digo indefinido existente.  Por ejemplo, aqu√≠ hay una implementaci√≥n simplificada de <code>std::vector&lt;T&gt;::reserve()</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reserve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//      auto new_memory = (T*) ::operator new(n * sizeof(T)); //    ‚Ä¶ //   auto size = this-&gt;size(); begin_ = new_memory; //   end_ = new_memory + size; //     end_capacity_ = new_memory + n; //    }</span></span></code> </pre> <br><p>  Hemos asignado memoria, movido todos los objetos y ahora tratamos de asegurarnos de que los punteros indiquen a d√≥nde ir.  ¬°Aqu√≠ est√°n solo las √∫ltimas tres l√≠neas que no est√°n definidas, porque contienen operaciones aritm√©ticas en punteros fuera de la matriz! </p><br><p>  Por supuesto, no es el programador quien tiene la culpa.  El problema est√° en el est√°ndar C ++ en s√≠, que declara que este c√≥digo obviamente razonable es un comportamiento indefinido.  Por lo tanto, <a href="https://wg21.link/p0593">P0593</a> sugiere corregir el est√°ndar agregando algunas funciones (como <code>::operator new</code> y <code>std::malloc</code> ) la capacidad de crear matrices seg√∫n sea necesario.  Todos los punteros creados por ellos se convertir√°n m√°gicamente en punteros de matrices, y se pueden realizar operaciones aritm√©ticas con ellos. </p><br><p>  <em>A√∫n no se trata de los nombres, espera un segundo.</em> </p><br><p>  Pero a veces, se requieren operaciones en punteros cuando se trabaja con memoria que una de estas funciones no asign√≥.  Por ejemplo, la funci√≥n <code>deallocate()</code> funciona esencialmente con memoria muerta, en la que no hay ning√∫n objeto, pero a√∫n debe sumar el puntero y el tama√±o del √°rea.  Para este caso, P0593 ofreci√≥ la funci√≥n <code>std::bless(void* ptr, std::size_t n)</code> (hab√≠a otra funci√≥n all√≠, que tambi√©n se llama <code>bless</code> , pero no se trata de eso).  No tiene ning√∫n efecto en una computadora f√≠sica de la vida real, pero crea objetos para una m√°quina abstracta que permitir√≠a el uso de la aritm√©tica de puntero. </p><br><p>  El nombre <code>std::bless</code> fue temporal. </p><br><p>  <em>Entonces, el nombre.</em> </p><br><p>  En Colonia, LEWG recibi√≥ la tarea de encontrar un nombre para esta funci√≥n.  Se propusieron las opciones <code>implicitly_create_objects()</code> y <code>implicitly_create_objects_as_needed()</code> , porque esto es lo que hace la funci√≥n. </p><br><p>  No me gustaron estas opciones. </p><br><h2 id="primer-3-stdpartial_sort_copy">  Ejemplo 3: std :: partial_sort_copy () </h2><br><p>  <em>Ejemplo tomado de <a href="https://www.youtube.com/watch%3Fv%3DMBRoCdtZOYg">la presentaci√≥n</a> de <a href="https://www.youtube.com/watch%3Fv%3DMBRoCdtZOYg">Kate</a></em> </p><br><p>  Hay una funci√≥n <code>std::sort</code> , que ordena los elementos del contenedor: </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; vec = {<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>}; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::sort(vec.begin(), vec.end()); <span class="hljs-comment"><span class="hljs-comment">// vec == {1, 2, 3, 4, 5}</span></span></code> </pre> <br><p>  Tambi√©n hay <code>std::partial_sort</code> , que clasifica solo parte de los elementos: </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; vec = {<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>}; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::partial_sort(vec.begin(), vec.begin() + <span class="hljs-number"><span class="hljs-number">3</span></span>, vec.end()); <span class="hljs-comment"><span class="hljs-comment">// vec == {1, 2, 3, ?, ?} ( ...4,5,  ...5,4)</span></span></code> </pre> <br><p>  Y todav√≠a hay <code>std::partial_sort_copy</code> , que tambi√©n clasifica parte de los elementos, pero al mismo tiempo el contenedor anterior no cambia, pero transfiere los valores al nuevo: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; vec = {<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>}; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; out; out.resize(<span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::partial_sort_copy(vec.begin(), vec.end(), out.begin(), out.end()); <span class="hljs-comment"><span class="hljs-comment">// out == {1, 2, 3}</span></span></code> </pre> <br><p>  Kate afirma que <code>std::partial_sort_copy</code> es un nombre regular, y estoy de acuerdo con ella. </p><br><h2 id="nazvanie-implementacii-i-nazvanie-rezultata">  Nombre de implementaci√≥n y nombre del resultado </h2><br><p>  Ninguno de los nombres enumerados es, estrictamente hablando, <em>incorrecto</em> : todos describen perfectamente lo que hace la funci√≥n.  <code>std::log2p1()</code> realmente cuenta el logaritmo binario y le agrega uno;  <code>implicitly_create_objects()</code> crea impl√≠citamente objetos, y <code>std::partial_sort_copy()</code> ordena parcialmente el contenedor y copia el resultado.  Sin embargo, no me gustan todos estos nombres, porque son <em>in√∫tiles</em> . </p><br><p>  Ning√∫n programador se sienta y piensa: "Me gustar√≠a poder tomar el logaritmo binario y agregarle uno".  Necesita saber cu√°ntos bits encajar√° el valor dado, y busca sin √©xito en los muelles algo como <code>bit_width</code> .  Para cuando llega al usuario de la biblioteca, qu√© tiene que ver el logaritmo binario con √©l, ya escribi√≥ su implementaci√≥n (y probablemente perdi√≥ la verificaci√≥n de cero).  Incluso si <code>std::log2p1</code> result√≥ ser un milagro en el c√≥digo, el siguiente en ver este c√≥digo deber√≠a comprender nuevamente qu√© es y por qu√© es necesario.  <code>bit_width(max_value)</code> no tendr√≠a ese problema. </p><br><p>  Del mismo modo, nadie necesita "crear objetos impl√≠citamente" u "ordenar parcialmente la copia del vector"; necesitan reutilizar la memoria u obtener los 5 valores m√°s grandes en orden descendente.  Algo as√≠ como <code>recycle_storage()</code> (que tambi√©n se sugiri√≥ como el nombre <code>std::bless</code> ) y <code>top_n_sorted()</code> ser√≠a mucho m√°s claro. </p><br><p>  Kate usa el t√©rmino <em>nombre de implementaci√≥n</em> para <code>std::partial_sort_copy()</code> , pero tambi√©n se ajusta a otras dos funciones.  La implementaci√≥n de su nombre se describe realmente perfectamente.  Eso es solo que el usuario necesita el nombre del resultado, lo que obtiene al llamar a la funci√≥n.  Para su estructura interna, no le importa, solo quiere saber el tama√±o en bits o reutilizar la memoria. </p><br><p>  <strong>Nombrar una funci√≥n basada en su especificaci√≥n significa crear de la nada un malentendido entre el desarrollador de la biblioteca y su usuario.</strong>  <strong>Siempre debe recordar cu√°ndo y c√≥mo se utilizar√° la funci√≥n.</strong> </p><br><p>  Eso suena cursi, s√≠.  Pero a juzgar por <code>std::log2p1()</code> , esto est√° lejos de ser obvio para todos.  Adem√°s, a veces no es tan simple. </p><br><h2 id="primer-4-stdpopcount">  Ejemplo 4: std :: popcount () </h2><br><p>  <code>std::popcount()</code> , como <code>std::log2p1()</code> , en C ++ 20 se propone agregar a <code>&lt;bit&gt;</code> .  Y esto, por supuesto, es un nombre monstruosamente malo.  Si no sabe qu√© hace esta funci√≥n, es imposible adivinar.  La abreviatura no solo es confusa (hay pop en el nombre, pero pop / push no tiene nada que ver con eso), descifrar el recuento de la poblaci√≥n (¬øcontar la poblaci√≥n? ¬øEl n√∫mero de poblaciones?) Tampoco ayuda. </p><br><p>  Por otro lado, <code>std::popcount()</code> ideal para esta funci√≥n porque llama a la instrucci√≥n de ensamblaje popcount.  Este no es solo el <em>nombre de la</em> implementaci√≥n, es su descripci√≥n completa. </p><br><p>  Sin embargo, en este caso, la brecha entre los desarrolladores de lenguaje y los programadores no es tan grande.  Una instrucci√≥n que cuenta el n√∫mero de unidades en una palabra binaria se llama popcount de los a√±os sesenta.  Para una persona que sabe algo sobre operaciones con bits, dicho nombre es absolutamente obvio. </p><br><p>  <em>Por cierto, una buena pregunta: ¬øpiensas en nombres que sean convenientes para los principiantes, o los dejas familiarizados para los viejos?</em> </p><br><h2 id="heppi-end">  Final feliz? </h2><br><p>  <a href="https://wg21.link/P1956">P1956</a> sugiere cambiar el nombre de <code>std::log2p1()</code> a <code>std::bit_width()</code> .  Es probable que esta propuesta sea aceptada en C ++ 20.  <code>std::ceil2</code> y <code>std::floor2</code> tambi√©n se renombrar√°n a std :: bit_ceil () y std :: bit_floor () respectivamente.  Sus antiguos nombres tampoco eran muy, pero por otras razones. </p><br><p>  LEWG en Colonia no seleccion√≥ <code>implicitly_create_objects[_as_needed]</code> ni <code>recycle_storage</code> como el nombre de <code>std::bless</code> .  Decidieron no incluir esta funci√≥n en el est√°ndar en absoluto.  Se puede lograr el mismo efecto creando expl√≠citamente una matriz de bytes, por lo tanto, dicen, la funci√≥n no es necesaria.  No me gusta esto porque llamar a <code>std::recycle_storage()</code> ser√≠a m√°s legible.  Todav√≠a existe otro <code>std::bless()</code> , pero ahora se llama <code>start_lifetime_as</code> .  Eso me gusta  Deber√≠a ir a C ++ 23. </p><br><p>  Por supuesto, <code>std::partial_sort_copy()</code> ya no ser√° renombrado; bajo este nombre ingres√≥ al est√°ndar en 1998. Pero al menos <code>std::log2p1</code> reparado, y eso no est√° mal. </p><br><p>  Al idear los nombres de las funciones, debe pensar en qui√©n las usar√° y qu√© quiere de ellas.  Como dijo Kate, <strong>nombrar requiere empat√≠a</strong> . </p></div></div><p>Source: <a href="https://habr.com/ru/post/484860/">https://habr.com/ru/post/484860/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../484836/index.html">C√°lculo de rentabilidad del Arancel Verde en 2020, Ucrania</a></li>
<li><a href="../484838/index.html">13 ejemplos de configuraci√≥n de reglas en Google Ads [instrucci√≥n]</a></li>
<li><a href="../484840/index.html">GOTO Volver</a></li>
<li><a href="../484846/index.html">Mi relaci√≥n con el c√≥digo abierto.</a></li>
<li><a href="../484854/index.html">Ejecuta el juego en C # en MS-DOS</a></li>
<li><a href="../484862/index.html">Migraci√≥n de AngularJS a Angular7 a trav√©s de una aplicaci√≥n h√≠brida</a></li>
<li><a href="../484866/index.html">Uso de Astra Linux en una computadora integrada ARM</a></li>
<li><a href="../484868/index.html">¬øC√≥mo medir la mejora del equipo? Parte 2</a></li>
<li><a href="../484870/index.html">C√≥mo los ingleses han cambiado a Ilona Mask durante 20 a√±os</a></li>
<li><a href="../484874/index.html">"Su especialista en TI est√° roto, traiga uno nuevo": c√≥mo construir una carrera en TI y no volverse loco</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>