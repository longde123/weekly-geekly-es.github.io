<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üóÉÔ∏è üèÇüèº üëì Arduin dan LED, atau cara meningkatkan perancang anak-anak üõ∏ üç§ üéÅ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Anak saya dengan kuat "terpikat" pada Magformers konstruktor magnetik . Setelah melihat serangkaian Fixiks di mana konstruktor yang sama ditampilkan, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Arduin dan LED, atau cara meningkatkan perancang anak-anak</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435198/"><img src="https://habrastorage.org/webt/wp/c4/ox/wpc4oxeubxh_dsoa07dy5wfccoa.jpeg"><br><br>  Anak saya dengan kuat "terpikat" pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Magformers konstruktor magnetik</a> .  Setelah melihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">serangkaian Fixiks di mana konstruktor yang sama ditampilkan,</a> anak itu bertanya: "Ayah, mengapa fixics memiliki detail yang bersinar, tetapi kami tidak melakukannya?". <br><br>  Ternyata benar-benar ada "Magformers Neon LED Set", di mana selain blok bangunan biasa, ada juga elemen dengan LED.  Karena pada saat ini kami telah mengumpulkan sekotak penuh magnet dengan segala bentuk dan ukuran yang memungkinkan (bagi saya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">magformer China sama</a> sekali tidak kalah dengan aslinya), saya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">entah bagaimana</a> tidak mau membeli set lain hanya demi bola lampu.  Selain itu, set ini harganya jauh lebih mahal daripada yang sama tanpa lampu latar. <br><br>  Setelah memperkirakan bahwa hanya ada beberapa dolar dalam komponen, yang sebagian besar sudah saya miliki, saya memutuskan untuk mengumpulkan morgulka saya.  Ya, dan dengan efek yang tidak dimiliki aslinya. <br><br>  Di bawah kucing, Anda akan menemukan opsi tanda bahayanya pada ATTiny85 dan panel LED pada LED WS8212.  Saya akan berbicara tentang sirkuit, bagaimana saya menghidupkan semua ini dari baterai, serta masalah-masalah yang tidak saya sadari sepanjang jalan.  Saya juga akan berbicara secara rinci tentang komponen perangkat lunak proyek. <br><a name="habracut"></a><br><h2>  Langkah pertama </h2><br>  Tampak bagi saya bahwa cahaya pada LED biasa (bahkan RGB) membosankan dan dangkal.  Tetapi merasakan sesuatu seperti WS8212 tampak menarik.  Di ebee, baik LED individu maupun matriks berukuran hingga 16x16 ditawarkan.  Setelah membeli beberapa modul yang berbeda, saya memutuskan untuk matriks 4x4.  Ada banyak LED di dalamnya untuk menikmati berbagai efek visual, sedangkan modul ini sebanding ukurannya dengan jendela blok persegi perancang. <br><br><img src="https://habrastorage.org/webt/f8/wj/kv/f8wjkvhcyj5zvrzyp81xb0zslu4.jpeg"><br><br>  Untuk mengontrol matriks LED, hanya satu pin dari mikrokontroler sudah cukup, sehingga arduino nano terlihat seperti bust (selain itu, tidak akan masuk ke dalam case).  Tetapi klon digispark pada pengontrol ATTiny85 ternyata tepat - ia tidak memiliki banyak memori dan pin, tetapi lebih dari cukup untuk lampu tanda LED.  Modul ini terintegrasi sempurna dengan IDE Arduino dan memiliki bootloader USB, sehingga pemrograman modul ini sangat sederhana dan nyaman.  Saya sudah lama ingin mencobanya. <br><br>  Dimulai dengan skema paling sederhana. <br><br><img src="https://habrastorage.org/webt/-8/yx/5b/-8yx5b02f2dxtqaps1tw6aoj_io.png"><br><br>  Dalam formulir ini, dimungkinkan untuk dengan cepat men-debug semua algoritma cahaya / blink (tentang mereka di bawah).  Tapi mainan bertenaga kawat bukan itu masalahnya - Anda harus memikirkan daya baterai.  Selain itu, agar tidak bangkrut pada baterai jari (yang, apalagi, tidak muat dalam amplop), diputuskan untuk menggunakan lithium.  Dan karena ada baterai lithium, Anda perlu memikirkan cara mengisi ulang.  Di nampan, kami baru saja menemukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pengendali muatan "populer" pada chip TP4056 yang</a> dibeli pada kesempatan itu. <br><br>  Tapi itu tidak berhasil segera.  Sirkuit modul Digispark ATTiny85 tidak terlalu dirancang untuk ini - ada daya USB, tetapi daya disuplai langsung ke mikrokontroler (melalui bus +5), atau dari input VIN, tetapi daya mengalir melalui stabilisator linier 7805. Opsi saat modul pengisian daya lithium dimasukkan ke celah antara konektor USB dan mikrokontroler tidak disediakan.  Saya harus memodifikasi rangkaian sedikit dan menghapus detail tambahan. <br><br><img src="https://habrastorage.org/webt/99/ta/ab/99taabsud7cdoakqixa8ah4ee0y.png"><br><br>  Jadi, sekarang daya USB disuplai ke pin VIN dan kemudian masuk ke input pengisi daya.  Output pengisi daya (pada kenyataannya, baterai terhubung langsung) kembali ke papan melalui kaki 5V.  Dan meskipun sebenarnya akan ada dari 3 ke 4.2V (tegangan baterai) ini cukup normal - kisaran tegangan operasi mikrokontroler adalah 1,8-5,5V.  Dan bahkan modul LED bekerja secara normal dari 2.7V, meskipun di bawah 3.2V LED biru sedikit kurang dan warna-warna "mengambang" sedikit berwarna kuning. <br><br>  Untuk menghemat energi, LED D2 yang selalu aktif juga hilang.  Skema umum sekarang terlihat seperti ini <br><br><img src="https://habrastorage.org/webt/pr/d_/fq/prd_fqhsjwulccuuw-1aissl52k.png"><br><br>  Dimungkinkan untuk memberi makan sirkuit melalui konektor USB di pengisi daya, tetapi kemudian kemampuan untuk mengunggah firmware melalui konektor USB pada papan pengontrol akan hilang.  Mungkin saja untuk meninggalkan dua konektor USB untuk berbagai keperluan - satu untuk mengisi daya, yang lain untuk firmware, tetapi ini entah bagaimana salah. <br><br>  Saya membeli baterai ukuran 6x25x35 di ebay, tetapi ternyata cacat, atau saya membunuhnya dengan korsleting atau arus muatan besar (secara default arus muatan diatur ke 1A dan Anda perlu menyolder satu resistor untuk mengurangi arus).  Bagaimanapun, ketika beban terhubung, bahkan pada 10 mA, tegangan pada baterai turun menjadi 1V.  Pada saat pengujian, saya beralih ke baterai LiPo setengah mati dari quadrocopter kecil.  Beberapa saat kemudian saya memesan baterai dari penjual lain dan ternyata bagus. <br><br>  Pada prinsipnya, mungkin untuk berhenti pada hal ini, menyolder kabel penghubung dan dengan lembut mendorong segala sesuatu ke dalam beberapa jenis perumahan, tetapi saya memutuskan untuk mengukur konsumsi rangkaian.  Dan kemudian aku menangis.  Nah, dalam kondisi kerja (ketika umbi bersinar penuh) hal ini memakan hingga 130mA, jadi saat istirahat, konsumsi lebih dari 25mA!  Yaitu  penutup mata ini memakan baterai 600mAh saya dalam waktu kurang dari sehari! <br><br>  Ternyata sekitar 10 mA mengkonsumsi LED.  Bahkan jika mereka tidak menyala, mikrokontroler masih berfungsi di masing-masing dan menunggu perintah.  Yaitu  Anda harus membuat sirkuit power-down untuk LED. <br><br>  Sisanya 15 mA dikonsumsi oleh mikrokontroler.  Ya, itu bisa diletakkan di tempat tidur dan menurut datasheet, konsumsi akan diukur dengan microamps, tetapi pada kenyataannya itu tidak mungkin untuk mendapatkan kurang dari 1 mA.  Saya mematikan ADC dan menerjemahkan pin menjadi input.  Tampaknya di suatu tempat di sirkuit ada semacam kebocoran, tetapi pengetahuan sederhana saya tentang elektronik tidak cukup untuk menemukan dan memahaminya. <br><br><h2>  Kami menyulitkan skema </h2><br>  Kemudian saya ingat bahwa saya membeli chip PT1502 untuk tes.  Chip ini adalah pengontrol pengisian daya baterai lithium lengkap dengan catu daya dengan beberapa input kontrol.  Satu-satunya kesulitan adalah bahwa microcircuit datang dalam paket QFN20 4x4 mm dan membutuhkan beberapa pengikat.  Menyolder ini di rumah memang sulit, tetapi memungkinkan.  Biaya sulit untuk LUT reguler dan harus dipesan dari Cina.  Tapi kita tidak takut kesulitan, kan? <br><br>  Dalam beberapa kotak, skema dapat dijelaskan sebagai berikut. <br><br><img src="https://habrastorage.org/webt/t9/c5/rg/t9c5rgauskpsz1momglwordnf0o.png"><br><br>  Dalam kondisi mati, daya tidak diberikan ke pengontrol dan LED.  Perangkat ini memiliki tombol 'Daya' yang menyalakan blinker (itu juga beralih mode).  LED bersinar, katakanlah, satu menit, dan jika tidak ada aktivitas pengguna (tidak ada yang menekan tombol), perangkat mati.  Yaitu  Ini tidak hanya akan tidur, tetapi mematikan daya dengan sendirinya oleh sinyal Power Hold.  Dan itu mematikan semuanya sekaligus - baik mikrokontroler dan LED.  Fungsi hidup dan mati diimplementasikan di dalam chip PT1502 <br><br>  Yang tersisa adalah menggambar diagram sirkuit dan membuat papan sirkuit.  Sirkuit ini, untuk sebagian besar, dicampur dengan lembar data PT1502, serta modul Digispark ATTiny85.  Microcircuit dari pengendali daya PT1502 secara fungsional dibagi menjadi beberapa bagian, oleh karena itu dibagi menjadi beberapa blok dalam rangkaian. <br><br><img src="https://habrastorage.org/webt/fc/s6/qu/fcs6qu4zqgfja5p4hjacywrds8k.png"><br><br>  Ini, pada kenyataannya, adalah pengontrol pengisian daya baterai lithium dengan harnessnya sendiri.  LED1 menunjukkan status pengisian aktif, kemudian pengisian aktif.  Resistor R6 menetapkan arus muatan ke 470mA.  Karena saya memiliki baterai 600mAh, pada prinsipnya, Anda dapat meningkatkan arus dan meletakkan resistor pada 780-800 Ohm hingga 600mA.  Namun, saya tidak yakin dengan kualitas khusus baterai saya - lebih baik mengisi daya lebih lambat, tetapi akan bertahan lebih lama. <br><br>  Pertimbangkan rencana daya <br><br><img src="https://habrastorage.org/webt/z1/rb/_a/z1rb_a2zu2a95pvxzk629o1tsjm.png"><br><br>  Tombol SW1 memulai seluruh sistem - chip PT1502 bangun sendiri dan kemudian mulai semua sumber daya (yang memiliki 3).  Ketika daya dipasang, sirkuit mikro akan memulai mikrokontroler dengan melepaskan sinyal RESET.  Untuk memudahkan debugging, saya juga menambahkan tombol Reset terpisah. <br><br>  Sinyal HOLD digunakan untuk mematikan seluruh sistem.  Ketika mikrokontroler mulai, itu harus mengatur unit pada baris ini.  Ketika tiba saatnya untuk mematikan, mikrokontroler menetapkan nol pada saluran HOLD dan chip daya PT1502 akan menghentikan semua sumber daya. <br><br>  Mungkin saja masih melacak pengisian baterai rendah menggunakan output BAT_LOW, tetapi dalam artikel ini saya mencetaknya - Anda tidak perlu menyimpan data apa pun dan tidak ada yang akan meledak jika Anda tidak melihat baterai yang mati pada waktunya.  Mati begitu mati.  Tapi untuk jaga-jaga, dewan memberikan kontak untuk bisnis ini. <br><br>  Mari kita kembali ke tombol SW1 sebentar.  Saya memutuskan untuk tidak membuat 2 tombol terpisah untuk menyalakan dan mengendalikan.  Oleh karena itu, tombol yang sama juga terhubung ke ATTiny85 dan selama operasi mengalihkan mode berkedip.  Nilai dari pembagi R7-R8 dipilih agar tidak membakar port mikrokontroler PB2.  Untuk semua rentang tegangan baterai (3.3 - 4.2V), tegangan akan dipasok ke kaki pengontrol dalam batas lembar data yang ditentukan (0,7 * VCC - VCC + 0,5V) <br><br>  Pertimbangkan sumber daya <br><br><img src="https://habrastorage.org/webt/u1/3q/kf/u13qkfyn6g7gffo_qb8j9licy4w.png"><br><br>  Ini adalah konverter DC-DC berdenyut.  Tegangan keluaran diatur oleh resistor R10-R11 dan, sesuai dengan rumus dari datasheet, diatur ke 3.3V.  Yang lainnya adalah pengikat sederhana. <br><br>  Demi kebaikan, sumber daya yang ditipu seperti itu tidak benar-benar dibutuhkan - akan mungkin untuk memberi daya mikrokontroler secara umum langsung dari baterai.  Hanya saja sumber ini sudah diimplementasikan dalam chip PT1502 dan dapat dinyalakan / dimatikan saat kita membutuhkannya - mengapa tidak menggunakannya? <br><br><img src="https://habrastorage.org/webt/ad/8w/0z/ad8w0zewrcux0hdetprifertqss.png"><br><br>  Chip ini juga memiliki 2 stabilisator linier, tetapi saya tidak akan menggunakannya.  Sayangnya, ternyata, masih perlu untuk memasok tegangan input ke sumber ini, jika tidak, rangkaian mikro berpikir bahwa daya masih belum cukup stabil dan tidak memulai mikrokontroler (pengetahuan ini diberikan kepada saya oleh seminggu menyolder papan tes bolak-balik - saya tidak bisa mengerti mengapa itu tidak bekerja ) <br><br>  Mari kita beralih ke bagian logis. <br><br><img src="https://habrastorage.org/webt/sq/su/xj/sqsuxjeblb7507pz8ej2h1t3yui.png"><br><br>  Kabel USB tersusun dari papan Digispark tidak berubah.  Ini diperlukan untuk mengoordinasikan tegangan USB (yang menjalankan 3.3V) dan sinyal-sinyal mikrokontroler (yang aslinya didukung oleh 5V).  Karena dalam kasus saya mikrokontroler juga ditenagai oleh 3.3V, sirkuit dapat disederhanakan, tetapi untuk berjaga-jaga, saya menceraikan sirkuit asli di papan tulis. <br><br><img src="https://habrastorage.org/webt/qe/q8/xr/qeq8xr1bwr-ux0jnsk5na1p6eaw.png"><br><br>  Tidak ada yang menarik dalam pengikatan mikrokontroler. <br><br>  Sentuhan terakhir adalah konektor <br><br><img src="https://habrastorage.org/webt/ic/vt/ey/icvtey-cwulcyqozyphkmglv-0m.png"><br><br>  Bahkan, saya mendapatkan papan debugging untuk saya sendiri di ATTiny85 dengan dukungan USB dan pengontrol daya dengan baterai lithium.  Karena itu, saya tidak membatasi diri untuk hanya mengeluarkan garis ke LED.  Sebagai gantinya, saya membawa semua lini mikrokontroler ke sisir - pada saat yang sama nyaman untuk terhubung ke programmer. <br><br>  Dan biarkan hampir semua garis terikat secara kaku ke fungsi tertentu (PB1 - Tahan saluran, PB2 - tombol power, PB3 / PB4 - USB, PB5 - Reset) di masa depan akan dimungkinkan untuk melewati beberapa batasan.  Misalnya, jangan solder kabel USB dan lepaskan garis PB3 / PB4.  Atau, misalnya, menolak reset dan lepaskan PB5.  Sementara itu, hanya PB0 yang tetap bebas - dan hubungkan LED kami ke sana. <br><br>  Kami lolos ke papan.  Mengingat keterbatasan pada ukuran papan di 40x40mm, jumlah komponen dan perumahan QFN20 dari chip PT1502, saya bahkan tidak mempertimbangkan membuat papan di rumah.  Oleh karena itu, saya segera mulai membiakkan papan dua lapis yang paling ringkas.  Itu yang saya dapat <br><br><img src="https://habrastorage.org/webt/yt/6q/wh/yt6qwhfd9zkia64yyejpjx9litu.png"><br><br>  Untuk kemudahan penggunaan, di sisi sebaliknya saya menandatangani semua fungsi output yang mungkin (saya mendapat ide dari papan Digispark) <br><br><img src="https://habrastorage.org/webt/q-/on/8t/q-on8tdmxq_bvht8egr5ilipb4s.png"><br><br>  Saya memesan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">board</a> di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JLCPCB</a> .  Sejujurnya, saya tidak terlalu puas dengan kualitasnya - jika Anda menyolder chip berkali-kali, maka topeng di dekat kontak kecil PT1502 sedikit mendung.  Nah, prasasti kecil sedikit melayang.  Namun, jika semuanya disolder pertama kali, maka norma. <br><br>  Untuk menyolder QFN20 Anda membutuhkan besi solder, yang lainnya dapat disolder dengan besi solder tertentu dengan keterampilan tertentu.  Inilah yang terlihat seperti papan solder <br><br><img src="https://habrastorage.org/webt/ct/km/4g/ctkm4gs_myfjjfeoukwn4ijuuc4.jpeg"><br><br><h2>  Perumahan </h2><br>  Sudah waktunya untuk pindah ke lambung.  Saya mencetaknya pada printer 3D.  Desain tanpa embel-embel - kotak dan tombol.  Kait khusus disediakan pada kotak untuk memasang kunang-kunang dalam modul kotak standar perancang. <br><br><img src="https://habrastorage.org/webt/g9/bz/yd/g9bzydcnm7bwonoo6rhe-1hby7k.png"><br><br>  Papan utama dan baterai hidup dalam kasing. <br><br><img src="https://habrastorage.org/webt/zp/4u/x-/zp4ux-vaqurrmg9yqe3jb3jkry8.jpeg"><br><br><img src="https://habrastorage.org/webt/4f/oa/dw/4foadwyytzwav_lfiyvqrl5lcxs.jpeg"><br><br>  Panel LED dipasang pada penutup, yang pada gilirannya disekrup ke kotak utama dengan sekrup <br><br>  Pada awalnya saya berpikir untuk memasang panel LED pada penutup dengan sekrup, tetapi pada akhirnya saya hanya menempelkannya pada selotip dua sisi.  Ternyata begini <br><br><img src="https://habrastorage.org/webt/vy/ks/y2/vyksy2ccuvrwcrjmxgvzolhlia0.jpeg"><br><br>  Dalam bentuk ini, perangkat sudah dapat digunakan, tetapi masih terlihat jelek - tidak ada cukup diffuser. <br><br>  Saya mencoba membuat versi pertama dari diffuser menggunakan teknologi penyusutan botol PET dengan pengering rambut konstruksi (mengintip model pesawat terbang). <br><br>  Jadi, pertama kamu perlu yang kosong.  Saya membuatnya dari gypsum, yang saya tuangkan ke dalam bentuk yang saya cetak pada printer 3D.  Dalam versi pertama, formulir itu one-piece dan saya tidak pernah bisa mengeluarkan disc dari dalamnya.  Karena itu, saya harus membuat bentuk dua potong. <br><br><img src="https://habrastorage.org/webt/gb/x0/0i/gbx00iokd8ea_lfquvmbbfebed4.jpeg"><br><br>  Gagasan metode ini adalah sebagai berikut.  Anda meletakkan botol yogurt bayi di tempat kosong dan duduk dengan pengering rambut konstruksi.  Berikut ini hanya porting ulang 20 kontainer berbeda dari susu berbeda yang saya tidak pernah berhasil meletakkannya dengan baik, tanpa lipatan dan gelembung.  Rupanya Anda perlu pagar semacam instalasi vakum dan kursi plastik.  Secara umum, itu ternyata terlalu sulit untuk kerajinan seperti itu. <br><br>  Setelah menggerutu melalui gophers, saya menemukan sepasang meter plastik Verbatim PET Transparan.  Saya memutuskan untuk mencoba diffuser hanya untuk mencetak.  Dan meskipun di pintu masuk ke printer, plastik tampak jernih, bagian yang sebenarnya membosankan.  Ini mungkin karena struktur internal, seperti  lapisan tidak mengisi volume sepenuhnya tetapi tumpang tindih dengan celah dan celah.  Selain itu, jika Anda mencoba untuk memproses bagian dengan amplas untuk permukaan yang lebih halus, kami mendapatkan lebih banyak anyaman.  Namun, inilah tepatnya yang saya butuhkan. <br><br>  Saya terlalu malas untuk repot dengan mount untuk diffuser, jadi saya menambahkannya ke lem panas.  Jadi desain saya sekarang kondisional dapat dilipat.  Saya bisa bingung dengan penemuan semacam kait, tapi saya sudah kehabisan probe plastik transparan.  Jadi biarkan panas meleleh. <br><br><img src="https://habrastorage.org/webt/xb/vy/49/xbvy49czm3mqdgjrexvvrcsm25m.jpeg"><br><br><img src="https://habrastorage.org/webt/fz/tx/tx/fztxtxljbgq0uwqnhlne0-mvcdc.jpeg"><br><br><h2>  Firmware </h2><br>  Untuk lampu tanda LED, Anda tidak perlu secara khusus masuk ke pinggiran mikrokontroler - cukup beberapa fungsi untuk bekerja dengan GPIO sudah cukup.  Tetapi karena modul ini merapat dengan platform Arduino, lalu mengapa tidak mengambil keuntungan dari ini? <br><br>  Pertama, beberapa definisi dan konstanta <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Number of total LEDs on the board. Mine has 4x4 LEDs #define NUM_HW_PIXELS 16 // Pin number where LED data pin is attached #define DATA_PIN 0 // Pin number where mode switch button is attached #define BUTTON_PIN 2 // Power Enabled pin #define POWER_EN_PIN 1 // Max brightness (dimming the light for debugging) #define MAX_VAL 255</span></span></code> </pre> <br>  Ini menentukan jumlah piksel dalam matriks saya, nomor pin dan kecerahan maksimum LED (selama debugging, nyaman untuk mengaturnya pada 50 sehingga tidak akan membutakan mataku) <br><br>  LED di matriks saya diatur dengan cara yang agak tidak jelas - zigzag.  Karena itu, untuk efek yang berbeda, saya harus memberi nomor baru. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// LED indexes for different patterns uint8_t circleLEDIndexes[] = {0, 1, 2, 3, 4, 11, 12, 13, 14, 15, 8, 7}; uint8_t beaconLEDIndexes[] = {6, 5, 10, 9}; uint8_t policeLEDIndexes[] = {7, 6, 10, 11, 4, 5, 9, 8};</span></span></code> </pre> <br>  Untuk mengontrol LED, saya tidak menemukan kembali roda dan mengambil <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">perpustakaan yang sudah jadi untuk bekerja dengan LED WS8211</a> .  Antarmuka perpustakaan sedikit dikapur.  Beberapa fungsi tambahan (misalnya, mengkonversi HSV ke RGB) juga macet di sana. <br><br>  Pertama, papan dan perpustakaan WS8211 perlu diinisialisasi. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Driver Ai_WS2811 ws2811; void setup() { // Set up power pinMode(POWER_EN_PIN, OUTPUT); digitalWrite(POWER_EN_PIN, HIGH); // initialize LED data pin pinMode(LED_PIN, OUTPUT); // Initialize button pin pinMode(BUTTON_PIN, INPUT); // Initialize WS8211 library static CRGB ledsBuf[NUM_HW_PIXELS]; ws2811.init(DATA_PIN, NUM_HW_PIXELS, ledsBuf); // Set the watchdog timer to 2 sec wdt_enable(WDTO_2S); }</span></span></code> </pre> <br>  Langkah pertama adalah mengatur sinyal POWER HOLD ke kesatuan - ini akan menjadi sinyal ke chip PT1502 bahwa mikrokontroler telah berakhir dan berfungsi dengan baik.  Microcircuit, pada gilirannya, akan secara teratur memasok listrik ke mikrokontroler dan LED selama sinyal HOLD diatur ke satu. <br><br>  Selanjutnya, kaki untuk mengontrol LED pada output dan tombol pada input dikonfigurasi.  Setelah itu, Anda dapat menginisialisasi perpustakaan WS8211. <br><br>  Karena ini adalah perangkat yang cukup otonom, tidak mungkin untuk membiarkan mikrokontroler tetap dalam keadaan yang tidak dapat dipahami dan melahap seluruh baterai.  Untuk melakukan ini, saya memulai pengawas waktu selama 2 detik.  Penghitung waktu akan dimulai kembali dalam loop program utama. <br><br>  Sekarang Anda perlu mendefinisikan beberapa fungsi tambahan.  Perpustakaan WS8211 menyimpan buffer dengan nilai warna setiap LED.  Bekerja dengan buffer secara langsung sangat tidak nyaman, karena saya menulis fungsi sederhana untuk menulis nilai RGB ke LED tertentu <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setRgb</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> led_idx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> r, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> g, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b)</span></span></span><span class="hljs-function"> </span></span>{ CRGB * leds = ws2811.getRGBData(); leds[led_idx].r = r; leds[led_idx].g = g; leds[led_idx].b = b; }</code> </pre> <br>  Tetapi dalam kebanyakan kasus, dalam model warna RGB, penghitungan warna tidak terlalu nyaman, atau bahkan tidak mungkin.  Misalnya, saat menggambar pelangi apa pun, akan lebih mudah digunakan dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">model warna HSV</a> .  Warna setiap piksel diatur oleh nilai nada warna dan kecerahan.  Kejenuhan dihilangkan karena kesederhanaan (maksimum digunakan).  Nilai rona dikurangi hingga kisaran 0-255 (bukan standar 0-359). <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** * HVS to RGB conversion (simplified to the range 0-255) **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setHue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> led_idx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hue, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> brightness)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//this is the algorithm to convert from RGB to HSV double r = 0; double g = 0; double b = 0; double hf = hue/42.6; // Not /60 as range is _not_ 0-360 int i=(int)floor(hue/42.6); double f = hue/42.6 - i; double qv = 1 - f; double tv = f; switch (i) { case 0: r = 1; g = tv; break; case 1: r = qv; g = 1; break; case 2: g = 1; b = tv; break; case 3: g = qv; b = 1; break; case 4: r = tv; b = 1; break; case 5: r = 1; b = qv; break; } brightness = constrain(brightness, 0, MAX_VAL); setRgb(led_idx, constrain(brightness*r, 0, MAX_VAL), constrain(brightness*g, 0, MAX_VAL), constrain(brightness*b, 0, MAX_VAL) ); }</span></span></code> </pre><br>  Fungsi ini diambil dari perpustakaan Ai_WS8211 dan sedikit diajukan.  Dalam versi asli fungsi ini dari perpustakaan ada beberapa bug karena warna pada pelangi ditampilkan dengan tersentak. <br><br>  Mari beralih ke implementasi berbagai efek.  Setiap fungsi dipanggil dari loop utama untuk menggambar satu "bingkai".  Karena setiap efek beroperasi dengan parameter yang berbeda di antara panggilan, mereka disimpan dalam variabel statis. <br><br>  Ini adalah efek paling sederhana - semua LED diisi dengan satu warna, yang berubah dengan mulus. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rainbow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> hue = <span class="hljs-number"><span class="hljs-number">0</span></span>; hue++; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> led = <span class="hljs-number"><span class="hljs-number">0</span></span>; led &lt; NUM_HW_PIXELS; led++) setHue(led, hue, MAX_VAL); ws2811.sendLedData(); delay(<span class="hljs-number"><span class="hljs-number">80</span></span>); }</code> </pre> <br>  Efek selanjutnya lebih menarik - ini menampilkan pelangi di sepanjang kontur matriks, dan warna-warna dalam pelangi secara bertahap bergeser dalam lingkaran. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">slidingRainbow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> pos = <span class="hljs-number"><span class="hljs-number">0</span></span>; pos++; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> led = <span class="hljs-number"><span class="hljs-number">0</span></span>; led &lt; ARRAY_SIZE(circleLEDIndexes); led++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> hue = (pos + led*<span class="hljs-number"><span class="hljs-number">256</span></span>/ARRAY_SIZE(circleLEDIndexes)) % <span class="hljs-number"><span class="hljs-number">256</span></span>; setHue(circleLEDIndexes[led], hue, MAX_VAL); } ws2811.sendLedData(); delay(<span class="hljs-number"><span class="hljs-number">10</span></span>); }</code> </pre> <br>  Dan efek ini mengisi seluruh matriks dengan warna acak, yang pertama kali menyala dengan lancar, dan kemudian juga keluar dengan lancar. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">randomColorsFadeInOut</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> color = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> goesUp = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> curLevel = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(curLevel == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; !goesUp) { color = rand() % <span class="hljs-number"><span class="hljs-number">256</span></span>; goesUp = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(curLevel == MAX_VAL &amp;&amp; goesUp) { goesUp = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> led = <span class="hljs-number"><span class="hljs-number">0</span></span>; led &lt; NUM_HW_PIXELS; led++) setHue(led, color, curLevel); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(goesUp) curLevel++; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> curLevel--; ws2811.sendLedData(); delay(<span class="hljs-number"><span class="hljs-number">10</span></span>); }</code> </pre><br>  Kelompok efek berikutnya menarik beacon berkedip berbeda.  Jadi, misalnya, seorang anak suka membuat buldoser dari magnet dan flasher oranye akan sangat berguna di sana. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">orangeBeacon</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ORANGE_HUE = <span class="hljs-number"><span class="hljs-number">17</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> pos = <span class="hljs-number"><span class="hljs-number">0</span></span>; pos+=<span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> led = <span class="hljs-number"><span class="hljs-number">0</span></span>; led &lt; ARRAY_SIZE(circleLEDIndexes); led++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> brightness = brightnessByPos(pos, led*<span class="hljs-number"><span class="hljs-number">255</span></span>/ARRAY_SIZE(circleLEDIndexes), <span class="hljs-number"><span class="hljs-number">70</span></span>); setHue(circleLEDIndexes[led], ORANGE_HUE, brightness); } ws2811.sendLedData(); delay(<span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre> <br>  Secara teknis, efeknya terlihat seperti titik terang yang bergerak di sepanjang matriks.  Tetapi untuk membuatnya tampak indah, LED tetangga secara bertahap memudar saat Anda menjauh dari titik utama.  Oleh karena itu, saya memerlukan fungsi yang menghitung kecerahan yang sama ini. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">brightnessByPos</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pos, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ledPos, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> delta)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> diff = <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(pos - ledPos); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(diff &gt; <span class="hljs-number"><span class="hljs-number">127</span></span>) diff = <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(<span class="hljs-number"><span class="hljs-number">256</span></span>-diff); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> brightness = MAX_VAL - constrain(MAX_VAL*diff/delta, <span class="hljs-number"><span class="hljs-number">0</span></span>, MAX_VAL); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> brightness; }</code> </pre><br>  Pos adalah posisi bersyarat tertentu dari titik kecerahan bercahaya, dipetakan ke kisaran loopback 0-255.  ledPos adalah posisi LED (ditampilkan pada rentang yang sama) yang kecerahannya perlu Anda hitung.  Jika perbedaan posisi lebih besar dari delta, maka LED tidak menyala, dan semakin dekat ke posisi, semakin terang itu bersinar. <br><br>  Atau, misalnya, lampu berkedip polisi merah-biru <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">policeBeacon</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> RED_HUE = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> BLUE_HUE = <span class="hljs-number"><span class="hljs-number">170</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> pos = <span class="hljs-number"><span class="hljs-number">0</span></span>; pos += <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> led = <span class="hljs-number"><span class="hljs-number">0</span></span>; led &lt; ARRAY_SIZE(policeLEDIndexes); led++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ledPos = led*<span class="hljs-number"><span class="hljs-number">255</span></span>/ARRAY_SIZE(policeLEDIndexes); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> brightness = brightnessByPos(pos, ledPos, <span class="hljs-number"><span class="hljs-number">50</span></span>); setHue(policeLEDIndexes[led], RED_HUE, brightness); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(brightness == <span class="hljs-number"><span class="hljs-number">0</span></span>) { brightness = brightnessByPos((pos+<span class="hljs-number"><span class="hljs-number">100</span></span>) % <span class="hljs-number"><span class="hljs-number">256</span></span>, ledPos, <span class="hljs-number"><span class="hljs-number">50</span></span>); setHue(policeLEDIndexes[led], BLUE_HUE, brightness); } } ws2811.sendLedData(); delay(<span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre><br>  Karena kita berbicara tentang mobil, maka lampu lalu lintas di sini bukan masalah untuk diterapkan. <br><br>  Ini adalah fungsi yang mencakup berbagai sinyal lalu lintas di berbagai posisi. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clearPixels</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;NUM_HW_PIXELS; i++) { setRgb(i, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">redTrafficLights</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;<span class="hljs-number"><span class="hljs-number">4</span></span>; i++) setRgb(i, MAX_VAL, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); ws2811.sendLedData(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">yellowTrafficLights</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">4</span></span>; i&lt;<span class="hljs-number"><span class="hljs-number">8</span></span>; i++) setRgb(i, MAX_VAL, MAX_VAL, <span class="hljs-number"><span class="hljs-number">0</span></span>); ws2811.sendLedData(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">greenTrafficLights</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">8</span></span>; i&lt;<span class="hljs-number"><span class="hljs-number">16</span></span>; i++) setRgb(i, <span class="hljs-number"><span class="hljs-number">0</span></span>, MAX_VAL, <span class="hljs-number"><span class="hljs-number">0</span></span>); ws2811.sendLedData(); }</code> </pre> <br>  Sudah waktunya untuk menghidupkannya kembali.  Lampu lalu lintas beroperasi sesuai dengan program khusus yang didefinisikan dalam semacam bytecode.  Pelat menggambarkan mode dan waktu mode ini harus dihidupkan. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> TRAFFIC_LIGHTS { NONE, RED, YELLOW, GREEN }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">trafficLightState</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> state; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> duration; }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> trafficLightState trafficLightStates[] = { {NONE, <span class="hljs-number"><span class="hljs-number">1</span></span>}, <span class="hljs-comment"><span class="hljs-comment">// clear yellow {RED, 7000}, // red {YELLOW, 2000}, // red + yellow {NONE, 1}, // clear red+yellow {GREEN, 7000}, // green {NONE, 300}, // Blinking green {GREEN, 300}, // Blinking green {NONE, 300}, // Blinking green {GREEN, 300}, // Blinking green {NONE, 300}, // Blinking green {GREEN, 300}, // Blinking green {NONE, 1}, // clear green {YELLOW, 2000}, // yellow };</span></span></code> </pre> <br>  Sebenarnya fungsi itu memproses semuanya <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">trafficLights</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> curStateIdx = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> curStateTimeStamp = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Switch to a new state when time comes if(millis() - curStateTimeStamp &gt; (unsigned long)trafficLightStates[curStateIdx].duration) { curStateIdx++; curStateIdx %= ARRAY_SIZE(trafficLightStates); curStateTimeStamp = millis(); } switch(trafficLightStates[curStateIdx].state) { case NONE: clearPixels(); ws2811.sendLedData(); break; case RED: redTrafficLights(); break; case YELLOW: yellowTrafficLights(); break; case GREEN: greenTrafficLights(); break; default: break; } // Just waiting delay(10); }</span></span></code> </pre><br>  Setelah mencapai interval waktu yang ditentukan, mode lampu lalu lintas berikutnya dihidupkan dan hitungan mundur dimulai lagi. <br><br>  Efek terakhir yang cukup membuat imajinasi saya adalah tanda bintang.  5 LED acak menyala pada kecerahan acak dan kemudian mati dengan lancar.  Jika satu bintang padam, maka bintang lain di tempat acak akan menyala. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stars</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> numleds = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> ledIndexes[numleds] = {<span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> curVal[numleds] = {<span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> maxVal[numleds] = {<span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;numleds; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(ledIndexes[i] == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> led = rand() % (NUM_HW_PIXELS+<span class="hljs-number"><span class="hljs-number">1</span></span>); CRGB * leds = ws2811.getRGBData(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(leds[led].r == <span class="hljs-number"><span class="hljs-number">0</span></span>) { ledIndexes[i] = led; maxVal[i] = rand() % (MAX_VAL<span class="hljs-number"><span class="hljs-number">-1</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span>; curVal[i] = <span class="hljs-number"><span class="hljs-number">0</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> led = ledIndexes[i]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(curVal[i] &lt; maxVal[i]) curVal[i]++; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(curVal[i] == maxVal[i]) maxVal[i] = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(curVal[i] == <span class="hljs-number"><span class="hljs-number">0</span></span> || --curVal[i] == <span class="hljs-number"><span class="hljs-number">0</span></span>) ledIndexes[i] = <span class="hljs-number"><span class="hljs-number">0</span></span>; setRgb(led<span class="hljs-number"><span class="hljs-number">-1</span></span>, curVal[i], curVal[i], curVal[i]); } } ws2811.sendLedData(); delay(<span class="hljs-number"><span class="hljs-number">80</span></span>); }</code> </pre> <br>  Di suatu tempat di sini serangga jahat merayap masuk.  Terkadang bintang-bintang menyala dengan tajam, atau sebaliknya tiba-tiba padam.  Tapi jujur ‚Äã‚Äãsaja, saya terlalu malas untuk mengetahuinya - itu terlihat sangat normal. <br><br>  Sudah waktunya untuk berpikir tentang menghemat baterai.  Saya sudah memberikan nilai konsumsi dari semua ini.  Jika Anda tidak berpikir untuk mematikan daya, LED akan memakan baterai dalam beberapa jam.  Fungsi ini bertanggung jawab untuk mematikan daya setelah 90 detik tidak aktif.  Awalnya, itu 60 detik, tetapi dengan permainan nyata ini tidak cukup, dan 2 menit entah bagaimana panjang. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shutdownOnTimeOut</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> resetTimer = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> periodStartTime = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(periodStartTime == <span class="hljs-number"><span class="hljs-number">0</span></span> || resetTimer) { periodStartTime = millis(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(millis() - periodStartTime &gt;= <span class="hljs-number"><span class="hljs-number">90000U</span></span>L) { periodStartTime = <span class="hljs-number"><span class="hljs-number">0</span></span>; shutDown(); } }</code> </pre> <br>  Sebenarnya matikan terjadi sebagai berikut. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shutDown</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ clearPixels(); ws2811.sendLedData(); wdt_disable(); digitalWrite(POWER_EN_PIN, LOW); <span class="hljs-comment"><span class="hljs-comment">// No power after this point while(true) ; }</span></span></code> </pre> <br>  Jika pengguna menekan tombol, timer diset ulang.  Setelah waktu yang disetel berlalu, fungsi ini mengatur sinyal HOLD ke nol, yang merupakan perintah PT1502 untuk mematikan daya.  Watchdog, omong-omong, juga perlu dihentikan, jika tidak setelah 2 detik akan membangunkan sistem dan menyalakan daya lagi. <br><br>  Akhirnya, loop utama yang memulai semuanya <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// List of pointers to functions that serve different modes void (*Modes[])() = { rainbow, slidingRainbow, orangeBeacon, policeBeacon, trafficLights, stars, randomColorsFadeInOut }; void loop() { static uint8_t mode = eeprom_read_byte( (uint8_t*) 10 ); static bool waitingForBtnUp = false; static long btnPressTimeStamp; // Button switches mode if(digitalRead(BUTTON_PIN) == HIGH &amp;&amp; !waitingForBtnUp) { delay(20); if(digitalRead(BUTTON_PIN) == HIGH) { mode++; mode %= ARRAY_SIZE(Modes); // num modes clearPixels(); ws2811.sendLedData(); delay(1); eeprom_write_byte( (uint8_t*) 10, mode ); waitingForBtnUp = true; btnPressTimeStamp = millis(); shutdownOnTimeOut(true); } } // Shut down on long press over 5s if(digitalRead(BUTTON_PIN) == HIGH &amp;&amp; waitingForBtnUp &amp;&amp; millis() - btnPressTimeStamp &gt; 5000) shutDown(); // Detect button release if(digitalRead(BUTTON_PIN) == LOW &amp;&amp; waitingForBtnUp) waitingForBtnUp = false; // display LEDs according to current mode Modes[mode](); // pong shutdown timer shutdownOnTimeOut(); // Yes, we still alive wdt_reset(); }</span></span></code> </pre><br>  Menekan tombol akan mengubah mode dan mengatur ulang timer mati otomatis.  Tergantung pada mode saat ini, salah satu fungsi efek dari daftar Mode diluncurkan.  Pada setiap siklus, anjing penjaga juga diatur ulang. <br><br>  Jika seorang anak, katakanlah, sedang bermain mobil polisi dan setelah 1,5 menit lampu darurat dimatikan, maka kemungkinan besar setelah giliran kedua pada anak itu akan ingin terus bermain mobil polisi.  Untuk melakukan ini, mode yang dipilih disimpan dalam EEPROM (nomor sel 10 dipilih dari bulldozer). <br><br>  Berikut adalah video yang menunjukkan cara kerjanya. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/5MLX1hc8Jz4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2>  Bootloader </h2><br>  Hampir semuanya siap.  Tetapi ada satu hal lagi yang perlu diajukan - bootloader.  Faktanya adalah bootloader standar tidak cocok untuk kita. <br><br>  Pertama, ketika Anda menghidupkan daya, ia menunggu selama 6 detik - mungkin firmware akan mulai mengalir ke dalamnya.  Hanya setelah kontrol ini ditransfer ke firmware utama.  Ini nyaman pada tahap pengembangan, tetapi akan mengganggu pada perangkat yang sudah selesai. <br><br>  Dan kedua, bootloader standar tidak tahu apa-apa tentang chip PT1502, yang akan lebih baik untuk memberikan sinyal TAHAN.  Tanpa sinyal ini, rangkaian mikro berpikir bahwa mikrokontroler tidak memulai, atau, sebaliknya, ingin mematikan.  Dan jika demikian, maka setelah beberapa milidetik, PT1502 akan memutus daya ke seluruh rangkaian. <br><br>  Manfaat memperbaiki kedua masalah itu tidak sulit.  Digispark ATTiny85 menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mikronukleus bootloader</a> .  Bootloader ini cukup mudah untuk memenuhi kebutuhan kita.  Hanya perlu untuk memperbaiki definisi yang sesuai dalam file konfigurasi. <br><br>  Pertama-tama, saya menyalin konfigurasi firmware standar \ konfigurasi \ t85_default ke direktori saya sendiri dan sudah membuat semua perubahan di dalamnya.  Jadi kalau-kalau mudah untuk kembali ke bootloader asli. <br><br>  Dalam file bootloaderconfig.h, ada pilihan cara untuk masuk ke bootloader.  Dari apa yang ditawarkan di luar kotak, tidak ada yang cocok dengan kami, tetapi opsi terdekat adalah ENTRY_JUMPER.  Dalam opsi ini, bootloader diakses hanya jika level tertentu muncul pada pin tertentu (jumper ditutup di papan). <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ENTRYMODE ENTRY_JUMPER</span></span></code> </pre> <br>  Kami tidak memiliki jumper, tetapi ada tombol di kaki PB2.  Biarkan bootloader masuk jika tombol ditahan selama 5-7 detik saat daya dihidupkan.  Tetapi jika ditekan dan dilepaskan, maka transisi ke firmware utama terjadi segera. <br><br>  Kita perlu mendefinisikan 3 fungsi - inisialisasi, deinisialisasi, dan benar-benar memeriksa apakah sudah waktunya untuk memasuki bootloader.  Dalam aslinya, semuanya sederhana dan diimplementasikan dengan makro.  Hanya 2 yang pertama akan sederhana <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> HOLD_PIN PB1 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> JUMPER_PIN PB2 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> JUMPER_PORT PORTB #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> JUMPER_DDR DDRB #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> JUMPER_INP PINB #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> bootLoaderInit() {JUMPER_DDR &amp;= ~_BV(JUMPER_PIN); JUMPER_DDR |= _BV(HOLD_PIN); JUMPER_PORT &amp;= ~_BV(JUMPER_PIN); JUMPER_PORT |= _BV(HOLD_PIN); _delay_ms(1);} #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> bootLoaderExit() {;}</span></span></code> </pre> <br>  bootLoaderInit () mengkonfigurasi pin tombol (JUMPER_PIN) ke input dan mematikan suspender di atasnya.  Kami sudah memiliki pull-up di papan tulis, dan ke tanah, dan ketika Anda menekan tombol pada pin, sebaliknya, akan ada satu.  Pada saat yang sama, Anda dapat segera mengkonfigurasi sinyal TAHAN untuk output dan mengatur unit untuk itu ... <br><br>  Untuk penjelasan tentang aritmatika bit, misalnya, buka di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> , dan pemahaman tentang register pengaturan GPIO di pengontrol AVR dapat diperoleh, misalnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dari sini</a> . <br><br>  Fungsi bootLoaderExit () kosong karena  konfigurasi yang terbuka cukup cocok untuk transisi selanjutnya ke firmware utama <br><br>  Fungsi bootLoaderStartCondition (), yang bertanggung jawab untuk memasukkan bootloader dalam format makro, belum cocok, dan karenanya telah menjadi fungsi penuh <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> __ASSEMBLER__ </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// Bootloader condition is to hold the button for 5 seconds inline unsigned char bootLoaderStartCondition() { long int i; for(i=0; i&lt;10000000; i++) if( !(JUMPER_INP &amp; _BV(JUMPER_PIN))) return 0; return 1; } #endif</span></span></span></span></code> </pre> <br>  Fungsi dalam beberapa detik (bahkan sekitar 6-7) memeriksa status tombol.  Jika tombol ini dirilis sebelumnya, maka kita tidak perlu masuk ke bootloader.  Pasien dan gigih diizinkan masuk ke bootloader. <br><br>  Ternyata, file bootloaderconfig.h terlibat dalam kompilasi file assembler dan kode dalam file ini menyebabkan kesalahan.  Saya harus meletakkan fungsi di blok #ifndef __ASSEMBLER__ <br><br>  Parameter lain yang saya sesuaikan memberitahu bootloader apa yang harus dilakukan jika tidak terhubung ke USB - keluar setelah satu detik.  Faktanya adalah selama break-in, sang putra sering menekan tombol dan secara tidak sengaja masuk ke bootloader.  Saya tidak tahu betapa ajaibnya, tetapi jika bootloader tidak melihat koneksi USB, itu bisa secara tidak sengaja menimpa beberapa halaman memori.  Karena itu, jika tidak ada koneksi, kita cukup keluar dari program utama. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* * Define bootloader timeout value. * * The bootloader will only time out if a user program was loaded. * * AUTO_EXIT_NO_USB_MS The bootloader will exit after this delay if no USB is connected. * Set to 0 to disable * Adds ~6 bytes. * (This will wait for an USB SE0 reset from the host) * * All values are approx. in milliseconds */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> AUTO_EXIT_NO_USB_MS 1000</span></span></code> </pre> <br>  Kami mengkompilasi ... dan kami mendapatkan kesalahan bahwa kode tidak sesuai dengan ruang bootloader yang dialokasikan untuk itu.  Karena memori flash di controller sangat kecil, bootloader ditekan hingga maksimum untuk memberikan lebih banyak ruang untuk program utama.  Tapi ini mudah diperbaiki di file Makefile.inc dengan mengikuti instruksi. <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># hexadecimal address for bootloader section to begin. To calculate the best value: # - make clean; make main.hex; ### output will list data: 2124 (or something like that) # - for the size of your device (8kb = 1024 * 8 = 8192) subtract above value 2124... = 6068 # - How many pages in is that? 6068 / 64 (tiny85 page size in bytes) = 94.8125 # - round that down to 94 - our new bootloader address is 94 * 64 = 6016, in hex = 1780 BOOTLOADER_ADDRESS = 1940</span></span></code> </pre> <br>  Kemudian saya hanya mengurangi alamat mulai bootloader menjadi satu halaman (64 byte), sehingga menambah ruang bootloader. <br><br>  Jika tidak, mengkompilasi dan mengunggah bootloader menggunakan programmer USBAsp bukanlah masalah. <br><br><h2>  Kesimpulan </h2><br>  Itu cara yang sangat menarik dari prototipe di papan tempat memotong roti ke perangkat jadi.  Tampaknya seperti tanda bahayanya biasa dari pelajaran arduino, tetapi pada kenyataannya, dalam proses kerja, saya harus menyelesaikan sejumlah masalah menarik - ini adalah perjuangan dengan konsumsi, pilihan basis elemen, dan desain kasing, dan membawa firmware dengan bootloader ke pikiran.  Saya sangat berharap bahwa pengalaman saya akan bermanfaat bagi seseorang. <br><br>  Mungkinkah ini lebih mudah?  Tentu saja bisa.  Saya pikir semuanya bisa dilakukan dengan transistor.  Sayangnya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">,</a> saya membaca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel ini</a> setelah saya menyolder papan.  Saya akan melihat artikel sebelumnya - saya akan melakukan segalanya pada TP4056 populer yang sama - lebih mudah untuk menyoldernya.  Bagaimanapun, konverter DC-DC, yang ada di dalam PT1502 pada perangkat ini, untuk kebaikan, tidak diperlukan.  Namun, sebuah studi praktis tentang rangkaian mikro PT1502 berguna bagi saya untuk proyek saya yang lain, serta kemampuan untuk menyolder rangkaian mikro dalam paket QFN20. <br><br>  Akhirnya, inilah tautan ke proyek saya: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kode firmware</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sirkuit dan papan</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Model housing dan diffuser</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Model STL siap untuk dicetak</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id435198/">https://habr.com/ru/post/id435198/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id435184/index.html">Kecerdasan Buatan Dipelajari untuk Menemukan Penyakit Alzheimer di Otak 6 Tahun Sebelum Diagnosis</a></li>
<li><a href="../id435186/index.html">Rolls-Royce mengembangkan pesawat listrik tercepat di dunia</a></li>
<li><a href="../id435190/index.html">Google telah berhasil menarik pajak dari $ 22,7 miliar melalui Irlandia dan Bermuda</a></li>
<li><a href="../id435194/index.html">Sederhanakan menulis resume pengembang</a></li>
<li><a href="../id435196/index.html">Peneliti lulus ReCAPTCHA menggunakan layanan Google</a></li>
<li><a href="../id435202/index.html">Kami menulis bahasa pemrograman kami, bagian 1: kami menulis bahasa VM</a></li>
<li><a href="../id435204/index.html">Penerimaan untuk pengembang untuk mengatasi penundaan</a></li>
<li><a href="../id435206/index.html">Eropa menyetujui arahan hak cipta - mengapa platform streaming menentang</a></li>
<li><a href="../id435208/index.html">Internet hal-hal ... yang menangis untuk UI / UX yang bagus</a></li>
<li><a href="../id435210/index.html">Pekerjaan Xamarin dengan C SDK</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>