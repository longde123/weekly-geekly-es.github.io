<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🖐🏼 👇 🚅 Unity3D: Arsitektur Game, ScriptableObjects, Singletones 👨🏽‍🏭 🔵 🌾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hari ini kita akan berbicara tentang cara menyimpan, menerima dan mengirimkan data di dalam game. Tentang hal luar biasa yang disebut ScriptableObject...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Unity3D: Arsitektur Game, ScriptableObjects, Singletones</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/414361/">  Hari ini kita akan berbicara tentang cara menyimpan, menerima dan mengirimkan data di dalam game.  Tentang hal luar biasa yang disebut ScriptableObject, dan mengapa itu indah.  Mari kita bicara sedikit tentang manfaat singleton ketika mengatur adegan dan transisi di antara mereka. <br><br>  Artikel ini menjelaskan cara yang panjang dan menyakitkan untuk mengembangkan game, berbagai pendekatan yang digunakan dalam proses.  Kemungkinan besar, akan ada banyak informasi berguna untuk pemula dan tidak ada yang baru untuk "veteran". <br><a name="habracut"></a><br><h3>  Tautan antara skrip dan objek </h3><br>  Pertanyaan pertama yang dihadapi pengembang pemula adalah bagaimana menghubungkan semua kelas tertulis bersama dan mengkonfigurasi interaksi di antara mereka. <br><br>  Cara termudah adalah dengan menentukan tautan ke kelas secara langsung: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MyScript</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> OtherScript otherScript; }</code> </pre> <br>  Dan kemudian - secara manual mengikat skrip melalui inspektur. <br><br>  Pendekatan ini memiliki setidaknya satu kelemahan signifikan - ketika jumlah skrip melebihi beberapa puluh, dan masing-masing membutuhkan dua atau tiga tautan satu sama lain, permainan dengan cepat berubah menjadi web.  Satu lirikan padanya sudah cukup untuk menyebabkan sakit kepala. <br><br>  Jauh lebih baik (menurut saya) untuk mengatur sistem pesan dan langganan, di mana objek kita akan menerima informasi yang mereka butuhkan - dan hanya itu!  - tanpa memerlukan setengah lusin tautan satu sama lain. <br><br>  Namun, setelah menyelidiki topik tersebut, saya menemukan bahwa solusi yang sudah jadi di Unity dimarahi oleh semua orang yang tidak malas.  Bagi saya itu adalah tugas nontrivial untuk menulis sistem seperti itu dari awal, dan karena itu saya akan mencari solusi yang lebih sederhana. <br><br><h3>  Objek skrip </h3><br>  Pada dasarnya ada dua hal yang perlu diketahui tentang ScriptableObject: <br><br><ul><li>  Mereka adalah bagian dari fungsionalitas yang diterapkan di dalam Unity, seperti MonoBehaviour. </li><li>  Tidak seperti MonoBehaviour, mereka tidak terikat pada objek adegan, tetapi ada sebagai aset yang terpisah dan <b>dapat menyimpan dan mentransfer data di antara sesi permainan</b> . </li></ul><br>  Saya langsung jatuh cinta dengan cinta panas mereka.  Mereka, dengan cara tertentu, telah menjadi obat mujarab saya untuk masalah apa pun: <br><br><ul><li>  Perlu menyimpan pengaturan game?  ScriptableObject! </li><li>  Buat inventaris?  ScriptableObject! </li><li>  Menulis AI?  ScriptableObject! </li><li>  Catat informasi tentang karakter, musuh, barang?  ScriptableObject tidak akan pernah mengecewakan Anda! </li></ul><br>  Tanpa berpikir dua kali, saya membuat beberapa kelas tipe ScriptableObject, dan kemudian repositori untuk mereka: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Database</span></span>: <span class="hljs-title"><span class="hljs-title">ScriptableObject</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> PlayerData playerData; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameSettings gameSettings; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> SpellController spellController; }</code> </pre> <br>  Masing-masing menyimpan sendiri semua informasi yang berguna dan, mungkin, tautan ke objek lain.  Masing-masing cukup mengikat sekali melalui inspektur - mereka tidak akan pergi ke tempat lain. <br><br>  Sekarang saya tidak perlu menentukan jumlah tautan di antara skrip!  Untuk setiap skrip, saya <b>pernah</b> dapat menentukan tautan ke repositori saya - dan itu akan menerima semua informasi dari sana. <br><br>  Dengan demikian, perhitungan kecepatan karakter mengambil tampilan yang sangat elegan: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//   float speed = database.playerData.speed; //    if (database.spellController.haste.active) speed = speed * database.spellController.haste.speedModifier; // ,     if (database.playerData.health&lt;database.playerData.healthThreshold) speed = speed * database.playerData.woundedModifier;</span></span></code> </pre> <br>  Dan jika, katakanlah, jebakan seharusnya hanya menembak karakter yang sedang berjalan: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (database.playerData.isSprinting) Activate();</code> </pre> <br>  Selain itu, karakter tidak perlu tahu apa-apa tentang mantra atau jebakan.  Itu hanya mengambil data dari penyimpanan.  Tidak buruk?  Tidak buruk. <br><br>  Tapi segera saya mengalami masalah.  ScriptableOnjects tidak dapat menyimpan tautan ke objek pemandangan secara langsung.  Dengan kata lain, saya tidak dapat membuat tautan ke pemain, mengikatnya melalui inspektur dan melupakan pertanyaan tentang koordinat pemain selamanya. <br><br>  Dan jika Anda memikirkannya, itu masuk akal!  Aset ada di luar panggung dan dapat diakses di salah satu layar.  Dan apa yang terjadi jika Anda meninggalkan tautan ke objek yang terletak di adegan lain di dalam aset? <br><br>  Tidak ada yang baik. <br><br>  Untuk waktu yang lama, sebuah penopang bekerja untuk saya: tautan publik dibuat di repositori, dan kemudian setiap objek, tautan yang ingin Anda ingat, mengisi tautan ini: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">PlayerController</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { database.playerData.player = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.gameObject; } }</code> </pre> <br>  Dengan demikian, terlepas dari adegannya, repositori saya pertama-tama menerima tautan ke pemain dan mengingatnya.  Sekarang siapa pun, katakanlah, musuh tidak boleh menyimpan tautan ke pemain, tidak boleh mencarinya melalui FindWithTag () (yang merupakan proses intensif sumber daya).  Yang dia lakukan hanyalah mengakses repositori: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Database database; Vector3 destination; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { destination = database.playerData.player.transform.position; }</code> </pre> <br>  Tampaknya: sistemnya sempurna!  Tapi tidak.  Kami masih memiliki 2 masalah. <br><br><ol><li>  Saya masih harus secara manual menentukan tautan ke repositori untuk setiap skrip. </li><li>  Canggung untuk menetapkan referensi ke objek pemandangan di dalam ScriptableObject. </li></ol><br>  Tentang yang kedua lebih terinci.  Misalkan seorang pemain memiliki mantra cahaya.  Pemain melemparkannya, dan permainan berkata ke toko: lampu dilemparkan! <br><br><pre> <code class="cs hljs">database.spellController.light.CastSpell();</code> </pre> <br>  Dan ini menimbulkan serangkaian reaksi: <br><br><ul><li>  Lampu objek game baru (atau lama) dibuat pada titik kursor. </li><li>  Modul GUI diluncurkan, memberi tahu kami bahwa lampu aktif. </li><li>  Musuh mendapatkan, katakanlah, bonus sementara untuk menemukan pemain. </li></ul><br>  Bagaimana cara melakukan semua ini? <br><br>  Dimungkinkan untuk setiap objek yang tertarik pada cahaya, langsung di Perbarui () dan menulis, kata mereka, dengan cara ini dan itu, setiap frame mengikuti cahaya (jika (database.spellController.light.isActive)), dan ketika menyala, bereaksi!  Dan tidak peduli bahwa 90% dari waktu pemeriksaan ini akan bekerja menganggur.  Pada beberapa ratus benda. <br><br>  Atau atur semua ini dalam bentuk tautan yang disiapkan.  Ternyata fungsi CastSpell () yang sederhana harus memiliki akses ke tautan ke pemain, ke cahaya, dan ke daftar musuh.  Dan ini yang terbaik.  Banyak tautan, ya? <br><br>  Anda dapat, tentu saja, menyimpan semua yang penting dalam repositori kami ketika adegan dimulai, menyebarkan tautan pada aset, yang, secara umum, tidak dimaksudkan untuk ini ... Tetapi sekali lagi, saya melanggar prinsip repositori tunggal, mengubahnya menjadi web tautan. <br><br><h3>  Singleton </h3><br>  Di sinilah singleton berperan.  Bahkan, ini adalah objek yang ada (dan bisa ada) hanya dalam satu salinan. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">GameController</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> GameController Instance; <span class="hljs-comment"><span class="hljs-comment">//   ,      public Database database; public GameObject player; public GameObject GUI; public List&lt;Enemy&gt; enemies; public List&lt;Spell&gt; spells; void Awake () { if (Instance == null) { DontDestroyOnLoad (gameObject); Instance = this; } else if (Instance != this) { Destroy (gameObject); } } }</span></span></code> </pre> <br>  Saya pasang ke objek pemandangan kosong.  Sebut saja GameController. <br><br>  Jadi, saya memiliki objek dalam adegan yang menyimpan <b>semua</b> informasi tentang permainan.  Selain itu, ia dapat bergerak di antara adegan, menghancurkan gandanya (jika sudah ada GameController lain di adegan baru), mentransfer data antar adegan, dan, jika diinginkan, menerapkan save / load game. <br><br>  Dari semua skrip yang sudah ditulis, Anda dapat menghapus tautan ke gudang data.  Lagi pula, sekarang saya tidak perlu mengkonfigurasi secara manual.  Semua referensi ke objek adegan dihapus dari toko dan ditransfer ke GameController kami (kami kemungkinan besar akan membutuhkannya untuk menyimpan keadaan adegan ketika kami keluar dari game).  Dan kemudian saya mengisinya dengan semua informasi yang diperlukan dengan cara yang nyaman bagi saya.  Misalnya, pada Sedarlah () pemain dan musuh (dan objek penting dari adegan), itu diresepkan untuk menambahkan tautan ke diri mereka sendiri di GameController.  Karena saya sekarang bekerja dengan Monobehaviour, referensi ke objek dalam adegan sangat cocok secara organik. <br><br>  Apa yang kita dapatkan <br><br>  Objek <b>apa pun</b> dapat memperoleh informasi <b>apa pun</b> tentang game yang ia butuhkan: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GameController.Instance.database.playerData.isSprinting) ActivateTrap();</code> </pre> <br>  Dalam hal ini, sama sekali tidak perlu mengkonfigurasi tautan antara objek, semuanya disimpan di GameController kami. <br><br>  Sekarang tidak akan ada yang rumit dalam mempertahankan keadaan tempat kejadian.  Bagaimanapun, kami sudah memiliki semua informasi yang diperlukan: musuh, item, posisi pemain, gudang data.  Cukup dengan memilih informasi tentang adegan yang ingin Anda simpan, dan menulisnya ke file menggunakan FileStream saat keluar dari adegan. <br><br><h3>  Bahaya </h3><br>  Jika Anda membaca sampai titik ini, saya harus memperingatkan Anda tentang bahaya dari pendekatan ini. <br><br>  Situasi yang sangat buruk adalah ketika banyak skrip merujuk satu variabel di dalam ScriptableObject kami.  Tidak ada yang salah dengan mendapatkan nilai, tetapi ketika mereka mulai mempengaruhi variabel dari tempat yang berbeda, ini merupakan ancaman potensial. <br><br>  Jika kita memiliki variabel playerSpeed ​​yang disimpan, dan kita membutuhkan pemain untuk bergerak dengan kecepatan yang berbeda, kita seharusnya tidak mengubah playerSpeed ​​di penyimpanan, kita harus mendapatkannya, simpan dalam variabel sementara dan sudah menerapkan pengubah kecepatan untuk itu. <br><br>  Poin kedua - jika benda apa pun memiliki akses ke apa pun - ini adalah kekuatan besar.  Dan tanggung jawab besar.  Dan Anda perlu mendekatinya dengan hati-hati agar beberapa skrip jamur secara tidak sengaja tidak menghancurkan semua musuh AI Anda.  Enkapsulasi yang dikonfigurasi dengan benar akan mengurangi risiko, tetapi tidak akan menyelamatkan Anda dari mereka. <br><br>  Juga, jangan lupa bahwa singletone adalah makhluk yang lembut.  Jangan menyalahgunakan mereka. <br><br>  Itu saja untuk hari ini. <br><br>  <i>Banyak yang telah diperoleh dari tutorial resmi Unity, beberapa dari yang tidak resmi.</i>  <i>Saya harus mendapatkan sesuatu sendiri.</i>  <i>Jadi, pendekatan di atas mungkin memiliki bahaya dan kerugian, yang saya lewatkan.</i> <i><br><br></i>  <i>Dan karena itu - diskusi ini disambut baik!</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id414361/">https://habr.com/ru/post/id414361/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id414351/index.html">Alat Musik Paling Tidak Biasa: Organ Hammond, Vako Orchestron dan Synclavier</a></li>
<li><a href="../id414353/index.html">Kivy. Dari penciptaan ke produksi adalah satu langkah. Bagian 2</a></li>
<li><a href="../id414355/index.html">Kehidupan setelah ledakan</a></li>
<li><a href="../id414357/index.html">Kami menggunakan Web Bluetooth API untuk menghubungkan monitor detak jantung dan mengembangkan aplikasi menggunakan Vue.js</a></li>
<li><a href="../id414359/index.html">Interaksi dengan server melalui API di iOS pada Swift 3. Bagian 1</a></li>
<li><a href="../id414363/index.html">Intisari bahan-bahan segar dari dunia front-end untuk minggu terakhir No. 319 (11-17 Juni 2018)</a></li>
<li><a href="../id414367/index.html">Berderap dalam tiga tahun: apa yang menarik untuk dibaca kembali di blog HashFlare</a></li>
<li><a href="../id414369/index.html">Print Server Windows yang toleran</a></li>
<li><a href="../id414371/index.html">Kelas sekolah dan sketsa kecil rekayasa sosial</a></li>
<li><a href="../id414373/index.html">Desain async / menunggu JavaScript: kekuatan, jebakan, dan pola penggunaan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>