<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐬 🍟 😝 Pengujian Kotak Putih 🧀 🍇 ☝🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pengembangan program berkualitas tinggi menyiratkan bahwa program dan bagian-bagiannya diuji. Pengujian unit klasik melibatkan memecah program besar m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pengujian Kotak Putih</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/422283/"><p>  Pengembangan program berkualitas tinggi menyiratkan bahwa program dan bagian-bagiannya diuji.  Pengujian unit klasik melibatkan memecah program besar menjadi blok-blok kecil yang nyaman untuk pengujian.  Atau, jika pengembangan tes berlangsung secara paralel dengan pengembangan kode atau tes dikembangkan sebelum program, maka program tersebut awalnya dikembangkan dalam blok kecil yang cocok untuk persyaratan tes. </p><br><p>  Salah satu jenis pengujian unit dapat dianggap pengujian berbasis layak (pendekatan ini diterapkan, misalnya, di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">QuickCheck</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">perpustakaan ScalaCheck</a> ).  Pendekatan ini didasarkan pada penemuan properti universal yang harus valid untuk input data apa pun.  Misalnya, <em>serialisasi diikuti oleh deserialisasi harus menghasilkan objek yang sama</em> .  Atau, <em>pengurutan ulang tidak boleh mengubah urutan item dalam daftar</em> .  Untuk memverifikasi properti universal seperti itu, perpustakaan di atas mendukung mekanisme untuk menghasilkan data input acak.  Pendekatan ini bekerja sangat baik untuk program yang didasarkan pada hukum matematika yang berfungsi sebagai properti universal yang valid untuk kelas program yang luas.  Bahkan ada perpustakaan properti matematika yang sudah jadi - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">disiplin</a> - yang memungkinkan Anda untuk memeriksa kinerja properti ini dalam program baru (contoh yang baik dari tes menggunakan kembali). </p><br><p>  Kadang-kadang ternyata perlu untuk menguji program yang kompleks tanpa dapat menguraikannya menjadi bagian-bagian yang dapat diverifikasi secara independen.  Dalam hal ini, program pengujian adalah <del>  hitam </del>  white box (putih - karena kami memiliki kesempatan untuk mempelajari struktur internal program). </p><br><p>  Di bawah cut, beberapa pendekatan untuk menguji program yang kompleks dengan satu input dengan berbagai tingkat kompleksitas (keterlibatan) dan berbagai tingkat cakupan dijelaskan. </p><a name="habracut"></a><br><p>  * <em>Dalam artikel ini, kami menganggap bahwa program yang sedang diuji dapat direpresentasikan sebagai fungsi murni tanpa kondisi internal.</em>  <em>(Beberapa pertimbangan di bawah ini dapat diterapkan jika keadaan internal ada, tetapi dimungkinkan untuk mengatur ulang keadaan ini ke nilai tetap.)</em> </p><br><h3 id="testovyy-stend-test-bench">  Bangku tes </h3><br><p> Pertama-tama, karena hanya satu fungsi yang diuji, kode panggilan yang selalu sama, kita tidak perlu membuat unit test terpisah.  Semua tes semacam itu akan sama, akurat untuk input dan pemeriksaan.  Cukup cukup untuk mengirimkan data sumber ( <code>input</code> ) dalam satu lingkaran dan memeriksa hasilnya ( <code>expectedOutput</code> ).  Untuk mengidentifikasi set masalah dari data pengujian dalam hal deteksi kesalahan, semua data pengujian harus diberi label.  Dengan demikian, satu set data uji dapat direpresentasikan sebagai tiga: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestCase</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">B</span></span></span><span class="hljs-class">](</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">label: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">, input: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">A</span></span></span></span><span class="hljs-class"><span class="hljs-params">, expectedOutput: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">B</span></span></span></span></span><span class="hljs-class">)</span></span></code> </pre> <br><p>  Hasil dari satu proses dapat direpresentasikan sebagai <code>TestCaseResult</code> : </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestCaseResult</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">B</span></span></span><span class="hljs-class">](</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">testCase: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">TestCase</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">A</span></span></span></span><span class="hljs-class"><span class="hljs-params">, </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">B</span></span></span></span><span class="hljs-class"><span class="hljs-params">], actualOutput: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Try</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">B</span></span></span></span><span class="hljs-class"><span class="hljs-params">]</span></span></span><span class="hljs-class">)</span></span></code> </pre> <br><p>  (Kami menyajikan hasil peluncuran menggunakan <code>Try</code> untuk menangkap kemungkinan pengecualian.) </p><br><p>  Untuk menyederhanakan menjalankan semua data uji melalui program yang sedang diuji, Anda dapat menggunakan fungsi pembantu yang akan memanggil program untuk setiap nilai input: </p><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">runTestCases</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>, <span class="hljs-type"><span class="hljs-type">B</span></span>](cases: <span class="hljs-type"><span class="hljs-type">Seq</span></span>[<span class="hljs-type"><span class="hljs-type">TestCase</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>, <span class="hljs-type"><span class="hljs-type">B</span></span>])(f: <span class="hljs-type"><span class="hljs-type">A</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">B</span></span>): <span class="hljs-type"><span class="hljs-type">Seq</span></span>[<span class="hljs-type"><span class="hljs-type">TestCaseResult</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>, <span class="hljs-type"><span class="hljs-type">B</span></span>]] = cases .map{ testCase =&gt; <span class="hljs-type"><span class="hljs-type">TestCaseResult</span></span>(testCase, <span class="hljs-type"><span class="hljs-type">Try</span></span>{ f(testCase.input) } ) } .filter(r =&gt; r.actualOutput != <span class="hljs-type"><span class="hljs-type">Success</span></span>(r.testCase.expectedOutput))</code> </pre> <br><p>  Fungsi pembantu ini akan mengembalikan data dan hasil yang bermasalah yang berbeda dari yang diharapkan. </p><br><p>  Untuk kenyamanan, Anda dapat memformat hasil tes. </p><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">report</span></span></span></span>(results: <span class="hljs-type"><span class="hljs-type">Seq</span></span>[<span class="hljs-type"><span class="hljs-type">TestCaseResult</span></span>[_, _]]): <span class="hljs-type"><span class="hljs-type">String</span></span> = <span class="hljs-string"><span class="hljs-string">s"Failed </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${results.length}</span></span></span><span class="hljs-string">:\n"</span></span> + results .map(r =&gt; r.testCase.label + <span class="hljs-string"><span class="hljs-string">": expected "</span></span> + r.testCase.expectedOutput + <span class="hljs-string"><span class="hljs-string">", but got "</span></span> + r.actualOutput) .mkString(<span class="hljs-string"><span class="hljs-string">"\n"</span></span>)</code> </pre> <br><p>  dan tampilkan laporan hanya jika ada kesalahan: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> testCases = <span class="hljs-type"><span class="hljs-type">Seq</span></span>( <span class="hljs-type"><span class="hljs-type">TestCase</span></span>(<span class="hljs-string"><span class="hljs-string">"1"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) ) test(<span class="hljs-string"><span class="hljs-string">"all test cases"</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> testBench = runTestCases(testCases) _ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> results = testBench(f) assert(results.isEmpty, report(results)) }</code> </pre> <br><h3 id="podgotovka-vhodnyh-dannyh">  Persiapan input </h3><br><p>  Dalam kasus yang paling sederhana, Anda dapat secara manual membuat data uji untuk menguji program, menuliskannya langsung dalam kode uji, dan menggunakannya, seperti yang ditunjukkan di atas.  Sering kali ternyata bahwa kasus-kasus data uji yang menarik memiliki banyak kesamaan dan dapat disajikan sebagai beberapa contoh dasar, dengan perubahan kecil. </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> baseline = <span class="hljs-type"><span class="hljs-type">MyObject</span></span>(...) <span class="hljs-comment"><span class="hljs-comment">//        val testCases = Seq( TestCase("baseline", baseline, ???), TestCase("baseline + (field1 = 123)", baseline.copy(field1 = "123"), ???) )</span></span></code> </pre> <br><p>  Saat bekerja dengan struktur data yang tidak dapat diubah yang bersarang, lensa sangat membantu, misalnya, dari perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Monocle</a> : </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> baseline = ??? <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> testObject1 = (field1 composeLens field2).set(<span class="hljs-string"><span class="hljs-string">"123"</span></span>)(baseline) <span class="hljs-comment"><span class="hljs-comment">//    : val testObject1 = baseline.copy(field1 = baseline.field1.copy(field2 = "123"))</span></span></code> </pre> <br><p>  Lensa memungkinkan Anda untuk "secara elegan" memodifikasi bagian struktur data yang bersarang: Setiap lensa adalah pengambil dan penyetel untuk satu properti.  Lensa dapat digabungkan untuk menghasilkan lensa yang "fokus" pada level selanjutnya. </p><br><h3 id="ispolzovanie-dsl-dlya-predstavleniya-izmeneniy">  Menggunakan DSL untuk Menampilkan Perubahan </h3><br><p>  Selanjutnya, kami akan mempertimbangkan pembentukan data uji dengan membuat perubahan pada beberapa objek input awal.  Biasanya, untuk mendapatkan objek tes yang kita butuhkan, kita perlu membuat beberapa perubahan.  Dalam hal ini, sangat berguna untuk memasukkan daftar perubahan dalam deskripsi teks dari TestCase: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> testCases = <span class="hljs-type"><span class="hljs-type">Seq</span></span>( <span class="hljs-type"><span class="hljs-type">TestCase</span></span>(<span class="hljs-string"><span class="hljs-string">"baseline"</span></span>, baseline, ???), <span class="hljs-type"><span class="hljs-type">TestCase</span></span>(<span class="hljs-string"><span class="hljs-string">"baseline + "</span></span> + <span class="hljs-string"><span class="hljs-string">"(field1 = 123) + "</span></span> + <span class="hljs-comment"><span class="hljs-comment">//  1-  "(field2 = 456) + " + // 2- "(field3 = 789)", // 3- baseline .copy(field1 = "123") // 1-  .copy(field2 = "456") // 2-  .copy(field3 = "789"), // 3-  ???) )</span></span></code> </pre> <br><p>  Maka kita akan selalu tahu untuk data uji apa pengujian dilakukan. </p><br><p>  Agar daftar perubahan tekstual tidak menyimpang dari perubahan yang sebenarnya, Anda harus mengikuti prinsip "satu versi kebenaran."  (Jika informasi yang sama diperlukan / digunakan di beberapa titik, maka harus ada satu sumber utama informasi unik, dan informasi harus didistribusikan ke semua titik penggunaan lainnya secara otomatis, dengan transformasi yang diperlukan. Jika prinsip ini dilanggar dan penyalinan informasi secara manual tidak dapat dihindari . informasi versi perbedaan di berbagai titik dalam kata lain dalam deskripsi data uji, kita melihat satu, dan data uji -. contoh lain, menyalin perubahan <code>field2 = "456"</code> dan menyesuaikan dalam <code>field3 = "789"</code> kita Mauger  sengaja lupa untuk memperbaiki deskripsi. Akibatnya, deskripsi hanya akan mencerminkan dua perubahan dari tiga.) </p><br><p>  Dalam kasus kami, sumber utama informasi adalah perubahan itu sendiri, atau lebih tepatnya, kode sumber program yang membuat perubahan.  Kami ingin menyimpulkan dari mereka teks yang menjelaskan perubahan.  Begitu saja, sebagai opsi pertama, Anda dapat menyarankan menggunakan makro yang akan menangkap kode sumber perubahan, dan menggunakan kode sumber sebagai dokumentasi.  Tampaknya, ini adalah cara yang baik dan relatif tidak rumit untuk mendokumentasikan perubahan aktual dan mungkin juga diterapkan dalam beberapa kasus.  Sayangnya, jika kami menyajikan perubahan dalam teks biasa, kami kehilangan kemampuan untuk membuat transformasi yang berarti dari daftar perubahan.  Misalnya, mendeteksi dan menghilangkan perubahan duplikat atau tumpang tindih, buatlah daftar perubahan dengan cara yang nyaman bagi pengguna akhir. </p><br><p>  Untuk dapat menangani perubahan, Anda harus memiliki model terstruktur darinya.  Model tersebut harus cukup ekspresif untuk menggambarkan semua perubahan yang menarik minat kita.  Bagian dari model ini, misalnya, akan menjadi pengalamatan bidang objek, konstanta, operasi penugasan. </p><br><p>  Model perubahan harus memungkinkan untuk menyelesaikan tugas-tugas berikut: </p><br><ol><li>  Memunculkan contoh model perubahan.  (Yaitu, sebenarnya membuat daftar perubahan tertentu.) </li><li>  Pembentukan deskripsi tekstual dari perubahan. </li><li>  Menerapkan perubahan pada objek domain. </li><li>  Melakukan transformasi optimasi pada model. </li></ol><br><p>  Jika bahasa pemrograman universal digunakan untuk membuat perubahan, maka mungkin sulit untuk mewakili perubahan ini dalam model.  Kode sumber program dapat menggunakan konstruksi kompleks yang tidak didukung oleh model.  Program semacam itu dapat menggunakan pola-pola sekunder, seperti lensa atau metode <code>copy</code> , untuk mengubah bidang suatu objek, yang merupakan abstraksi tingkat rendah relatif terhadap level model perubahan.  Akibatnya, analisis tambahan dari pola tersebut mungkin diperlukan untuk menampilkan contoh perubahan.  Jadi, awalnya pilihan yang baik menggunakan makro tidak terlalu nyaman. </p><br><p>  Cara lain untuk membuat instance dari model perubahan bisa menjadi bahasa khusus (DSL), yang membuat objek model perubahan menggunakan serangkaian metode ekstensi dan operator tambahan.  Nah, dalam kasus yang paling sederhana, contoh dari model perubahan dapat dibuat langsung melalui konstruktor. </p><br><div class="spoiler">  <b class="spoiler_title">Ubah Detail Bahasa</b> <div class="spoiler_text"><p>  Bahasa ganti adalah konstruksi yang agak rumit yang mencakup beberapa komponen, yang, pada gilirannya, nontrivial. </p><br><ol><li>  Model struktur data. </li><li>  Ubah Model. </li><li>  Sebenarnya Embedded (?) DSL - konstruksi tambahan, metode ekstensi, untuk konstruksi perubahan yang nyaman. </li><li>  Penerjemah perubahan yang memungkinkan Anda untuk benar-benar "memodifikasi" suatu objek (sebenarnya, tentu saja, membuat salinan yang dimodifikasi). </li></ol><br><p>  Berikut adalah contoh program yang ditulis menggunakan DSL: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> target: <span class="hljs-type"><span class="hljs-type">Entity</span></span>[<span class="hljs-type"><span class="hljs-type">Target</span></span>] <span class="hljs-comment"><span class="hljs-comment">// ,     val updateField1 = target \ field1 := "123" val updateField2 = target \ subobject \ field2 := "456" // ,   DSL: val updateField1 = SetProperty(PropertyAccess(target, Property(field1, typeTag[String])), LiftedString("123")) val updateField2 = SetProperty(PropertyAccess(PropertyAccess(target, Property(subobject, typeTag[SubObject])), Property(field2, typeTag[String])), LiftedString("456"))</span></span></code> </pre> <br><p>  Yaitu, menggunakan metode ekstensi <code>\</code> dan <code>:=</code> , <code>PropertyAccess</code> , objek <code>SetProperty</code> dibentuk dari <code>target</code> dibuat sebelumnya, <code>field1</code> , <code>subobject</code> , <code>field2</code> .  Selain itu, karena konversi tersirat (berbahaya), string "123" dimasukkan ke <code>LiftedString</code> (Anda dapat melakukannya tanpa konversi implisit dan memanggil metode yang terkait secara eksplisit: <code>lift("123")</code> ). </p><br><p>  Ontologi yang diketik dapat digunakan sebagai model data (lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://habr.com/post/229035/</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://habr.com/post/222553/</a> ).  (Singkatnya: nama objek dideklarasikan yang mewakili properti dari semua jenis domain: <code>val field1: Property[Target, String]</code> .) Dalam kasus ini, data aktual dapat disimpan, misalnya, dalam bentuk JSON.  Kenyamanan ontologi yang diketik dalam kasus kami terletak pada kenyataan bahwa model perubahan biasanya beroperasi dengan properti individual dari objek, dan ontologi hanya menyediakan alat yang sesuai untuk mengatasi properti. </p><br><p>  Untuk mewakili perubahan, Anda memerlukan seperangkat kelas dari paket yang sama dengan kelas <code>SetProperty</code> atas: </p><br><ul><li>  <code>Modify</code> - aplikasi fungsi, </li><li>  <code>Changes</code> - menerapkan beberapa perubahan secara berurutan </li><li>  <code>ForEach</code> - terapkan perubahan pada setiap item dalam koleksi, </li><li>  dll. </li></ul><br><p>  Penerjemah bahasa perubahan adalah evaluator ekspresi rekursif reguler berdasarkan PatternMatching.  Sesuatu seperti: </p><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eval</span></span></span></span>(expression: <span class="hljs-type"><span class="hljs-type">DslExpression</span></span>, gamma: <span class="hljs-type"><span class="hljs-type">Map</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">Any</span></span>]): <span class="hljs-type"><span class="hljs-type">Any</span></span> = expression <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">LiftedString</span></span>(str) =&gt; str <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">PropertyAccess</span></span>(obj, prop) =&gt; <span class="hljs-type"><span class="hljs-type">Getter</span></span>(prop)(gamma).get(obj) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">change</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>] (expression: <span class="hljs-type"><span class="hljs-type">DslChangeExpression</span></span>, gamma: <span class="hljs-type"><span class="hljs-type">Map</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">Any</span></span>], target: <span class="hljs-type"><span class="hljs-type">T</span></span>): <span class="hljs-type"><span class="hljs-type">T</span></span> = expression <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">SetProperty</span></span>(path, valueExpr) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> value = eval(valueExpr, gamma) <span class="hljs-type"><span class="hljs-type">Setter</span></span>(path)(gamma).set(value)(target) }</code> </pre> <br><p>  Untuk langsung beroperasi pada properti objek, Anda harus menentukan pengambil dan penyetel untuk setiap properti yang digunakan dalam model perubahan.  Ini dapat dicapai dengan mengisi peta antara sifat ontologis dan lensa yang sesuai. </p></div></div><br><p>  Pendekatan ini secara keseluruhan bekerja, dan memang memungkinkan Anda untuk menggambarkan perubahan sekali, tetapi secara bertahap ada kebutuhan untuk mewakili perubahan yang semakin kompleks dan model perubahan semakin berkembang.  Misalnya, jika Anda perlu mengubah properti menggunakan nilai properti lain dari objek yang sama (misalnya, <code>field1 = field2 + 1</code> ), maka Anda perlu mendukung variabel di tingkat DSL.  Dan jika mengubah properti adalah nontrivial, maka pada tingkat DSL, dukungan untuk ekspresi dan fungsi aritmatika diperlukan. </p><br><h3 id="testirovanie-vetvey">  Pengujian cabang </h3><br><p>  Kode uji bisa linear, dan kemudian, pada umumnya, satu set data uji cukup untuk memahami apakah itu berfungsi.  Jika ada cabang ( <code>if-then-else</code> ), Anda harus menjalankan kotak putih setidaknya dua kali dengan data input yang berbeda sehingga kedua cabang dieksekusi.  Jumlah set input data yang cukup untuk mencakup semua cabang tampaknya secara numerik sama dengan kompleksitas cyclomatic dari kode dengan cabang. </p><br><p>  Bagaimana cara membentuk semua set data input?  Karena kita berhadapan dengan kotak putih, kita dapat mengisolasi kondisi percabangan dan memodifikasi objek input dua kali sehingga dalam satu kasus satu cabang dieksekusi, dalam kasus lain yang lain.  Pertimbangkan sebuah contoh: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">field1</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">==</span></span></span><span class="hljs-class"> "123") </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">else</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span></span></code> </pre> <br><p>  Memiliki kondisi seperti itu, kami dapat membentuk dua kasus uji: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> testCase1 = <span class="hljs-type"><span class="hljs-type">TestCase</span></span>(<span class="hljs-string"><span class="hljs-string">"A"</span></span>, field1.set(<span class="hljs-string"><span class="hljs-string">"123"</span></span>)(baseline), <span class="hljs-comment"><span class="hljs-comment">/* result of A */</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> testCase2 = <span class="hljs-type"><span class="hljs-type">TestCase</span></span>(<span class="hljs-string"><span class="hljs-string">"B"</span></span>, field1.set(<span class="hljs-comment"><span class="hljs-comment">/*  "123", , , */</span></span><span class="hljs-string"><span class="hljs-string">"123"</span></span> + <span class="hljs-string"><span class="hljs-string">"1"</span></span>&gt;)(baseline), <span class="hljs-comment"><span class="hljs-comment">/*result of B*/</span></span>)</code> </pre> <br><p>  <em>(Jika salah satu skenario pengujian tidak dapat dibuat, maka kita dapat mengasumsikan bahwa kode mati telah terdeteksi, dan kondisi, bersama dengan cabang yang sesuai, dapat dihapus dengan aman.)</em> </p><br><p>  Jika properti independen suatu objek diperiksa di beberapa cabang, maka cukup mudah untuk membentuk set lengkap objek pengujian yang dimodifikasi yang sepenuhnya mencakup semua kombinasi yang mungkin. </p><br><div class="spoiler">  <b class="spoiler_title">DSL untuk membentuk semua kombinasi perubahan</b> <div class="spoiler_text"><p>  Mari kita pertimbangkan secara lebih terperinci mekanisme yang memungkinkan untuk membentuk semua daftar kemungkinan perubahan yang menyediakan cakupan penuh dari semua cabang.  Untuk menggunakan daftar perubahan selama pengujian, kita perlu menggabungkan semua perubahan menjadi satu objek, yang akan kita serahkan ke input dari kode yang diuji, yaitu, dukungan untuk komposisi diperlukan.  Untuk melakukan ini, Anda bisa menggunakan DSL di atas untuk memodelkan perubahan, dan kemudian daftar perubahan sederhana sudah cukup, atau Anda dapat menyajikan satu perubahan sebagai fungsi modifikasi <code>T =&gt; T</code> : </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> change1: <span class="hljs-type"><span class="hljs-type">T</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">T</span></span> = field1.set(<span class="hljs-string"><span class="hljs-string">"123"</span></span>)(_) <span class="hljs-comment"><span class="hljs-comment">// val change1: T =&gt; T = _.copy(field1 = "123") val change2: T =&gt; T = field2.set("456")</span></span></code> </pre> <br><p>  maka rantai perubahan hanya akan menjadi komposisi fungsi: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> changes = change1 compose change2</code> </pre> <br><p>  atau, untuk daftar perubahan: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> rawChangesList: <span class="hljs-type"><span class="hljs-type">Seq</span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">T</span></span>] = <span class="hljs-type"><span class="hljs-type">Seq</span></span>(change1, change2) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> allChanges: <span class="hljs-type"><span class="hljs-type">T</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">T</span></span> = rawChangesList.foldLeft(identity)(_ compose _)</code> </pre> <br><p>  Untuk secara kompak merekam semua perubahan yang terkait dengan semua cabang yang memungkinkan, Anda dapat menggunakan DSL dengan level abstraksi berikut, yang mensimulasikan struktur kotak putih yang diuji: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> tests: <span class="hljs-type"><span class="hljs-type">Seq</span></span>[(<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">T</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">T</span></span>)] = <span class="hljs-type"><span class="hljs-type">IF</span></span>(<span class="hljs-string"><span class="hljs-string">"field1 == '123'"</span></span>) <span class="hljs-comment"><span class="hljs-comment">//  ,    THEN( field1.set("123"))( //  target \ field1 := "123" IF("field2 == '456') THEN(field2.set("456"))(TERMINATE) ELSE(field2.set("456" + "1"))(TERMINATE) ) ELSE( field1.set("123" + "1") )(TERMINATE)</span></span></code> </pre> <br><p>  Di sini koleksi <code>tests</code> berisi perubahan agregat yang sesuai dengan semua kemungkinan kombinasi cabang.  Parameter tipe <code>String</code> akan berisi semua nama kondisi dan semua deskripsi dari perubahan dari mana fungsi perubahan agregat terbentuk.  Dan elemen kedua dari sepasang tipe <code>T =&gt; T</code> hanyalah fungsi agregat dari perubahan yang diperoleh sebagai hasil dari komposisi perubahan individu. </p><br><p>  Untuk mendapatkan objek yang diubah, Anda perlu menerapkan semua fungsi perubahan agregat ke objek dasar: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> tests2: <span class="hljs-type"><span class="hljs-type">Seq</span></span>[(<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">T</span></span>)] = tests.map(_.map_2(_(baseline)))</code> </pre> <br><p>  Sebagai hasilnya, kami mendapatkan koleksi pasangan, dan garis akan menjelaskan perubahan yang diterapkan, dan elemen kedua dari pasangan akan menjadi objek di mana semua perubahan ini digabungkan. </p><br><p>  Berdasarkan pada struktur model kode yang diuji dalam bentuk pohon, daftar perubahan akan mewakili jalur dari root ke lembaran pohon ini.  Dengan demikian, sebagian besar perubahan akan digandakan.  Anda dapat menyingkirkan duplikasi ini menggunakan opsi DSL, di mana perubahan diterapkan langsung ke objek dasar saat Anda bergerak di sepanjang cabang.  Dalam hal ini, lebih sedikit perhitungan yang tidak perlu akan dilakukan. </p></div></div><br><h3 id="avtomaticheskoe-formirovanie-testovyh-dannyh">  Pembuatan data uji secara otomatis </h3><br><p>  Karena kita berurusan dengan kotak putih, kita bisa melihat semua cabang.  Ini memungkinkan untuk membangun model logika yang terkandung dalam kotak putih dan menggunakan model untuk menghasilkan data uji.  Jika kode tes ditulis dalam Scala, Anda dapat, misalnya, menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">scalameta</a> untuk membaca kode, dengan konversi selanjutnya ke model logika.  Sekali lagi, seperti dalam masalah pemodelan logika perubahan yang dibahas sebelumnya, sulit bagi kita untuk memodelkan semua kemungkinan bahasa universal.  Lebih lanjut, kami akan menganggap bahwa kode yang diuji diimplementasikan menggunakan subset terbatas dari bahasa, atau dalam bahasa lain atau DSL, yang pada awalnya terbatas.  Ini memungkinkan kami untuk fokus pada aspek-aspek bahasa yang menarik bagi kami. </p><br><p>  Pertimbangkan contoh kode yang berisi satu cabang: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">field1</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">==</span></span></span><span class="hljs-class"> "123") </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">else</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span></span></code> </pre> <br><p>  Kondisi ini membagi set nilai <code>field1</code> menjadi dua kelas kesetaraan: <code>== "123"</code> dan <code>!= "123"</code> .  Dengan demikian, seluruh rangkaian data input juga dibagi menjadi dua kelas kesetaraan sehubungan dengan kondisi ini - <code>ClassCondition1IsTrue</code> dan <code>ClassCondition1IsFalse</code> .  Dari sudut pandang kelengkapan cakupan, cukup bagi kita untuk mengambil setidaknya satu contoh dari dua kelas ini untuk mencakup cabang <code>A</code> dan <code>B</code>  Untuk kelas pertama, kita bisa membuat contoh, dalam arti tertentu, dengan cara yang unik: ambil objek acak, tetapi ubah <code>field1</code> ke <code>"123"</code> .  Selain itu, objek pasti akan <code>ClassCondition1IsTrue</code> di kelas ekivalensi <code>ClassCondition1IsTrue</code> dan perhitungan akan pergi bersama cabang <code>A</code>  Ada lebih banyak contoh untuk kelas kedua.  Salah satu cara untuk menghasilkan beberapa contoh dari kelas kedua adalah dengan menghasilkan objek input sewenang-wenang dan membuang yang dengan <code>field1 == "123"</code> .  Cara lain: untuk mengambil objek acak, tetapi ubah <code>field1</code> ke <code>"123" + "*"</code> (untuk modifikasi, Anda dapat menggunakan perubahan apa pun di baris kontrol untuk memastikan bahwa baris baru tidak sama dengan garis kontrol). </p><br><p>  <a href=""><code>  Arbitrary</code> - <code>  Arbitrary</code> dan <code>Gen</code> dari perpustakaan ScalaCheck</a> sangat cocok sebagai <a href=""><code>  Arbitrary</code></a> data acak. </p><br><p>  Pada dasarnya, kita <strong>memanggil</strong> fungsi boolean yang digunakan dalam <code>if</code> .  Yaitu, kami menemukan semua nilai objek input yang fungsi Boolean ini dievaluasi menjadi <code>true</code> - <code>ClassCondition1IsTrue</code> , dan semua nilai objek input yang diterima <code>false</code> - <code>ClassCondition1IsFalse</code> . </p><br><p>  Dengan cara yang serupa, dimungkinkan untuk menghasilkan data yang cocok untuk kendala yang dihasilkan oleh operator kondisional sederhana dengan konstanta (lebih / kurang dari konstanta, termasuk dalam himpunan, dimulai dengan konstanta).  Kondisi seperti itu mudah dibalik.  Bahkan jika fungsi-fungsi sederhana dipanggil dalam kode uji, kita dapat mengganti panggilan mereka dengan definisi mereka (sebaris) dan masih membalikkan ekspresi kondisional. </p><br><h4 id="trudno-obratimye-funkcii">  Fungsi yang sulit dibalik </h4><br><p>  Situasi berbeda ketika kondisi menggunakan fungsi yang sulit untuk dibalik.  Misalnya, jika fungsi hash digunakan, maka sepertinya tidak mungkin untuk secara otomatis menghasilkan contoh yang memberikan nilai yang diinginkan dari kode hash. </p><br><p>  Dalam hal ini, Anda dapat menambahkan parameter tambahan ke objek input yang mewakili hasil perhitungan fungsi, mengganti panggilan fungsi dengan panggilan ke parameter ini, dan memperbarui parameter ini, meskipun ada pelanggaran koneksi fungsional: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sha(<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">field1</span></span></span><span class="hljs-class">)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">==</span></span></span><span class="hljs-class">"</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a9403</span></span></span><span class="hljs-class">...") ... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">//</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title"></span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title"></span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title"></span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title"></span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">==&gt;</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">if</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">object.sha_field1 == "a9403..."</span></span></span><span class="hljs-class">) ...</span></span></code> </pre> <br><p>  Parameter tambahan memungkinkan untuk eksekusi kode di dalam cabang, tetapi, jelas, itu dapat menyebabkan hasil yang sebenarnya salah.  Artinya, program uji akan menghasilkan hasil yang tidak pernah bisa diamati dalam kenyataan.  Namun demikian, memeriksa bagian dari kode yang tidak dapat diakses oleh kami masih bermanfaat dan dapat dianggap sebagai bentuk pengujian unit.  Bagaimanapun, bahkan selama pengujian unit, subfungsi dipanggil dengan argumen yang mungkin tidak pernah digunakan dalam program. </p><br><p>  Dengan manipulasi seperti itu, kami mengganti (mengganti) objek uji.  Namun, dalam arti tertentu, program yang baru dibangun ini termasuk logika dari program lama.  Memang, jika sebagai nilai dari parameter buatan baru kita mengambil hasil penghitungan fungsi yang kita ganti dengan parameter, program akan menghasilkan hasil yang sama.  Tampaknya menguji program yang dimodifikasi mungkin masih menarik.  Anda hanya perlu mengingat dalam kondisi apa program yang diubah akan berperilaku sama dengan yang asli. </p><br><h4 id="zavisimye-usloviya">  Kondisi tergantung </h4><br><p>         ,      .        ,  ,   ,      .        ,     . (,  , <code>x &gt; 0</code> ,   — <code>x &lt;= 1</code> .         ,           — <code>(-∞, 0]</code> , <code>(0, 1]</code> , <code>(1, +∞)</code> , —      .) </p><br><p>       ,     ,   ,        <code>true</code>  <code>false</code>     .   ,    ,  " "         . </p><br><h4 id="svyazannye-parametry">   </h4><br><p>  ,        ,   : </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(x &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(y &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (y &gt; x)</code> </pre> <br><p> (     <code>&gt; 0</code> ,       — <code>y &gt; x</code> .) <br>    "", ,   ,      ,    ,     .             ,             "  "     . <br>  ,   "",  ( <code>y == x + 1</code> ),    ,        . <br>   "" ( <code>y &gt; x + 1 &amp;&amp; y &lt; x + 2</code> ),     ,        . </p><br><h4 id="simvolnoe-vypolnenie">   </h4><br><p>  ,    ,    -  ,   "c " ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Symbolic Execution</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">  </a> ),     .        ( <code>field1 = field1_initial_value</code> ).       ,    .       : </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> a = field1 + <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-comment"><span class="hljs-comment">//    a = field_initial_value + 10 val b = a * 3 //    b = 3 * field_initial_value + 30</span></span></code> </pre> <br><p>         — <code>true</code>  <code>false</code> .       .           .  Sebagai contoh </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(a &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-type"><span class="hljs-type">A</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-type"><span class="hljs-type">B</span></span> <span class="hljs-comment"><span class="hljs-comment">//   A ,  field_initial_value + 10 &gt; 0 //   B ,  field_initial_value + 10 &lt;= 0</span></span></code> </pre> <br><p>           ,  ,   ,     ,    .        ,       (, ,   ). </p><br><h4 id="testirovanie-ciklov-i-rekursivnyh-funkciy">      </h4><br><p>        .    ,     ,       .        ,       .         ,         . </p><br><p> ,      .       . , ,        .  ,       ,      ,        .        ,   ,   ,  ,   ,      ? </p><br><p>     Y- ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"  "</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">stackoverflow:What is a Y-combinator? (2- )</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">habr:  Y-  7  </a> ).      ,       . (   ,      ,  .)    .            ,      .        ,    ""    . Y-   "  "     (     ). </p><br><p>        ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a> ).   ,       .         ,     .       ,      . ,   ,       ,       <code>TestCase</code> '.  ,       ,     ( <code>throw</code>   <code>Nothing</code>  <code>bottom</code> ,    ).            . </p><br><p>        ,   .        .    ,  ,        .  ,       .        ,    ,     .          , ,    ,    ,      .      ,        .      ,    . </p><br><h3 id="smysl-testirovaniya-belogo-yaschika">     </h3><br><p>      ,  ,     ,      ,    100% .       ,     ,   .  Hm .   , ,   ,   ?         ,    ,     -  . </p><br><p>           : </p><br><ol><li>                . </li><li>       (      ). </li><li>       ,          . </li><li>      ,    . </li></ol><br><p>       ,   ,       . -,       ,     ,   ,       . -,    ,   ,     ( ,  ),         ,  ,   ""  .   /    ,         . </p><br><h3 id="zaklyuchenie">  Kesimpulan </h3><br><p>        "   "  "   ".  ,      ,     ,      ,     .         ,           . </p><br><p>      ,      ,  ,  ,  . -,          ,        ( ),      . -, -,      .      DSL,  ,    . -,          ,   . -,       ,        (   ,     ,   ).            . </p><br><p>  ,          ,      . ,      ,         -   . </p><br><h3 id="blagodarnosti">  Ucapan Terima Kasih </h3><br><p>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">@mneychev</a>        . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id422283/">https://habr.com/ru/post/id422283/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id422269/index.html">Buku "Perangkat internal Windows. Edisi ke-7</a></li>
<li><a href="../id422273/index.html">Tidak ada jalan tol di kota pintar. Apa itu RWIS dan bagaimana hal itu akan mengurangi biaya pekerjaan jalan</a></li>
<li><a href="../id422275/index.html">Seorang karyawan Google dapat mengendalikan sistem pembuka pintu di kantor perusahaan karena kerentanan perangkat lunak</a></li>
<li><a href="../id422277/index.html">Arsitektur dan pemrograman RCA Studio II</a></li>
<li><a href="../id422281/index.html">A7 Data Server: manajemen data online</a></li>
<li><a href="../id422285/index.html">Mengapa belanja online memiliki loyalitas cukup 1% dari pelanggan</a></li>
<li><a href="../id422291/index.html">Kotak hitam kecil (visualisasi semua uang dan pasar dunia)</a></li>
<li><a href="../id422293/index.html">Mendapatkan daftar alarm dari OSS melalui antarmuka AlarmIRP</a></li>
<li><a href="../id422297/index.html">Pengalaman pertama atau bagaimana mencoba menjadi legenda kode dan sihir</a></li>
<li><a href="../id422299/index.html">TsNIImash: SpaceX diduga mengimplementasikan perkembangan Soviet. Mengapa Topeng Ilon memiliki begitu banyak musuh</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>