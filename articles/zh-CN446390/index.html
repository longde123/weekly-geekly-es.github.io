<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙋🏾 👵 ⚕️ 回忆忘我炸弹 🍤 👆🏻 👩‍🚀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="您听说过memoization吗？ 顺便说一句，这是一件非常简单的事情-只是记住您从第一个函数调用中获得的结果，并使用它而不是第二次调用它-不要无故调用真实的东西，不要浪费时间。 


 跳过一些繁琐的操作是一种非常常见的优化技术。 每次您可能不做某事-不要做。 尝试使用缓存memcache ， f...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>回忆忘我炸弹</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/446390/"><p><img src="https://habrastorage.org/webt/ym/ok/d7/ymokd7njz99ry_9knpxx9iaz1ja.jpeg"></p><br><p>您听说过<code>memoization</code>吗？ 顺便说一句，这是一件非常简单的事情-只是记住您从第一个函数调用中获得的结果，并使用它而不是第二次调用它-不要无故调用真实的东西，不要浪费时间。 </p><br><p> 跳过一些繁琐的操作是一种非常常见的优化技术。 每次您可能不做某事-不要做。 尝试使用缓存<code>memcache</code> ， <code>file cache</code> ， <code>local cache</code> -任何缓存！ 后端系统的必备组件，过去和现在的任何后端系统的关键部分。 </p><a name="habracut"></a><br><p><img src="https://habrastorage.org/webt/j8/4x/u4/j84xu4vrhrsgqu6fc5qdbahwhig.jpeg"></p><br><h1 id="memoization-vscaching"> 记忆与缓存 </h1><br><blockquote> 记住就像缓存。 只是有些不同。 不缓存，我们称它为kashe。 </blockquote><p> 长话短说，但是记忆不是缓存，不是持久缓存。 它可能是在服务器端，但不能，并且不应是客户端的缓存。 更多有关可用资源，使用模式和使用原因的信息。 </p><br><h2 id="problem-cache-need-a-cachekey"> 问题-缓存需要一个“缓存键” </h2><br><p> 高速缓存使用<strong>字符串</strong>高速缓存<code>key</code>存储和获取数据。 构造一个唯一且可用的密钥已经是一个问题，但是随后您必须对数据进行序列化和反序列化，以再次存储在基于字符串的介质中……简而言之，高速缓存的速度可能不如您想象的那样快。 特别是分布式缓存。 </p><br><h2 id="memoization-does-not-need-any-cachekey"> 备注不需要任何缓存键 </h2><br><p> 同时-无需密钥即可记忆。  <em>通常*</em>它按原样使用参数，而不是尝试从中创建单个键，并且不像缓存通常那样使用某些全局可用的共享对象来存储结果。 </p><br><blockquote> 备注和缓存之间的区别在于<strong>API接口</strong> ！ </blockquote><p>  <em>通常*</em>并不表示总是。  <a href="">Lodash.memoize</a>默认情况下使用<code>JSON.stringify</code>将传递的参数转换为字符串缓存（还有其他方法吗？否！）。 只是因为他们将使用此键来访问内部对象，并保存一个缓存的值。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">快速存储</a> ，“最快的可能的存储库”，也可以做到这一点。 这两个命名库都不是备注库，而是缓存库。 </p><br><blockquote> 值得一提的是，您要记住，JSON.stringify的速度可能比函数慢10倍。 </blockquote><p> 显然-解决该问题的简单方法是不使用缓存键，也不使用该键访问某些内部缓存。 所以-记住最后一个被调用的参数。 像<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">回忆</a>或<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">重新选择</a>一样。 </p><br><blockquote>  Memoizerific可能是您要使用的唯一通用缓存库。 </blockquote><br><h1 id="the-cachesize"> 缓存大小 </h1><br><p> 所有库之间的第二个大区别是关于缓存大小和缓存结构。 </p><br><p> 您是否曾经想过-为什么<code>reselect</code>或<code>memoize-one</code>仅保留一个最后的结果？ 不要<em>“不要使用缓存键来存储一个以上的结果”</em> ，而是因为<strong>没有理由要存储多个结果而不只是最后一个结果</strong> 。 </p><br><p>  ...更多关于： </p><br><ul><li> 可用资源-单个缓存行非常资源友好 </li><li> 使用模式-记住“就地”的东西是一个很好的模式。  “就地”通常只需要一个，最后一个结果。 </li><li> 使用-模块化，隔离和内存安全的原因是很好的原因。 就缓存冲突而言，不与应用程序的其余部分共享缓存只会更安全。 </li></ul><br><h1 id="a-singleresult"> 一个结果？ </h1><br><p> 是的-唯一的结果。 用一个结果来记忆一些<strong>经典的事情</strong>是不可能的，例如记忆斐波那契数的产生（ <em>您可能在每篇关于记忆的文章中都可以找到例子</em> ）。 但是，通常情况下，您在做其他事情-前端需要谁做斐波那契？ 在后端？ 现实世界中的例子离抽象的<em>IT测验</em>还很远。 </p><br><p> 但是，关于单值备忘录类型仍然存在两个<strong>BIG</strong>问题。 </p><br><h2 id="problem-1-its-fragile"> 问题1-它“脆弱” </h2><br><p> 默认情况下-所有参数都应该匹配，完全相同。 如果一个参数不匹配-游戏结束。 即使这是来自记忆的想法-如今，这可能并不是您想要的。 我的意思是-您想尽可能多地，尽可能多地记住。 </p><br><blockquote> 甚至高速缓存未命中也是高速缓存擦除爆头。 </blockquote><p>  “今天”与“昨天”之间存在一些差异-不变的数据结构，例如在Redux中使用。 </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getSomeDataFromState = memoize(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state</span></span></span><span class="hljs-function"> =&gt;</span></span> compute(state.tasks));</code> </pre> <br><p> 看起来不错吗？ 看起来对不对？ 但是，当任务没有执行时，状态可能会改变，您只需要匹配任务即可。 </p><br><p>  <strong>结构选择器</strong>在这里与他们最强大的战士- <strong>重新选择</strong> -一起拯救您的一天。  Reselect不仅是记忆库，它的功能来自记忆<strong>级联</strong>或镜头（它们不是，而是将选择器视为光学镜头）。 </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// every time `state` changes, cached value would be rejected const getTasksFromState = createSelector(state =&gt; state.tasks); const getSomeDataFromState = createSelector( // `tasks` "without" `state` getTasksFromState, // &lt;---------- // and this operation would be memoized "more often" tasks =&gt; compute(state.tasks) );</span></span></code> </pre> <br><p> 结果，在数据不可变的情况下-您总是必须首先<strong>“聚焦”</strong>到您真正需要的数据上，然后-执行计算，否则缓存将被拒绝，而记忆化背后的所有想法将消失。 </p><br><p> 这实际上是一个大问题，特别是对于新手来说，但这是不可变的数据结构背后的想法，它具有显着的好处- <strong>如果不更改某些内容，则不会更改。</strong>  <strong>如果某项更改-可能已更改</strong> 。 这给了我们超快速的比较，但是有一些假阴性，就像第一个例子一样。 </p><br><blockquote> 这个想法是关于“关注”您所依赖的数据 </blockquote><p> 我应该有两个时刻-提到： </p><br><ul><li>  <code>lodash.memoize</code>和<code>fast-memoize</code> <code>lodash.memoize</code>您的数据转换为用作键的字符串。 这意味着它们是1）不快2）不安全3）可能产生误报-一些<strong>不同的数据</strong>可能具有<strong>相同的字符串表示形式</strong> 。 这可能会提高“缓存热速率”，但实际上是非常不好的事情。 </li><li> 有一种ES6代理方法，用于跟踪给定的所有使用过的变量，并仅检查重要的键。 尽管我个人想创建大量的数据选择器-您可能不喜欢或不了解该过程，但是可能想开箱即用地进行适当的备忘-然后使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">memoize-state</a> 。 </li></ul><br><h2 id="problem-2--its-one-cacheline"> 问题2-这是“一个缓存行” </h2><br><p> 无限的缓存大小是杀手er。 只要内存非常有限，任何不受控制的缓存都是致命的杀手。 所以-所有最好的库都是“ one-cache-line-long”。 这是一个功能和强大的设计决策。 我刚刚写下了它是多么正确，并且相信我-这是<strong>很正确的事情</strong> ，但这仍然是一个问题。 一个大问题。 </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> tasks = getTasks(state); <span class="hljs-comment"><span class="hljs-comment">// let's get some data from state1 (function was defined above) getDataFromTask(tasks[0]); // Yep! equal(getDataFromTask(tasks[0]), getDataFromTask(tasks[0])) // Ok! getDataFromTask(tasks[1]); // a different task? What the heck? // oh! That's another argument? How dare you!? // TLDR -&gt; task[0] in the cache got replaced by task[1] you cannot use getDataFromTask to get data from different tasks</span></span></code> </pre> <br><p> 一旦同一个选择器必须处理不同的源数据，就不止一个了-一切都坏了。 很容易遇到问题： </p><br><ul><li> 只要我们使用选择器从状态中获取任务-我们就可以使用相同的选择器从任务中获取某些东西。 强烈来自API本身。 但这是行不通的，因此您只能记住上一次呼叫，但必须使用多个数据源。 </li><li> 多个React组件存在相同的问题-它们都是相同的，并且都有些不同，它们获取不同的任务，彼此擦拭结果。 </li></ul><br><p> 有3种可能的解决方案： </p><br><ul><li> 如果是redux，请使用mapStateToProps工厂。 它将创建每个实例的备注。 <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mapStateToProps = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> selector = createSelector(...); <span class="hljs-comment"><span class="hljs-comment">// ^ you have to define per-instance selectors here // usually that's not possible :) return state =&gt; ({ data: selector(data), // a usual mapStateToProps }); }</span></span></code> </pre> </li><li> 第二个变体几乎相同（也用于redux）-它使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">re-reselect</a> 。 这是一个复杂的库，可以通过区分组件来节省时间。 它只是可以理解，新的调用是针对“另一个”组件的，它可以保留“上一个”组件的缓存。 </li></ul><br><p><img src="https://habrastorage.org/webt/rd/mz/gq/rdmzgqgrj_mjin5jjmsalnxmljm.png"></p><br><p> 该库将帮助您“保留”备忘录缓存，但不能删除它。 特别是因为它正在实现5种（五种！）不同的缓存策略以适合任何情况。 那是难闻的气味。 如果选择了错误的怎么办？ <br> 您已经记住的所有数据-迟早要忘记。 重点不是要记住上一次函数调用-重点是在正确的时间忘记它。 还不算太早，破坏记忆，也不会太晚。 </p><br><blockquote> 有这个主意吗？ 现在算了！ 第三变体在哪里？ </blockquote><br><h1 id="let-take-apause"> 稍等一下 </h1><br><p> 停下 放松一下 深呼吸。 并回答一个简单的问题-目标是什么？ 我们必须做什么才能达到目标？ 什么会节省一天？ </p><br><blockquote> 提示：f ***“缓存”位于何处！ </blockquote><p><img src="https://habrastorage.org/webt/7m/r1/iz/7mr1izrzb89femvq5h-suxxkfnm.jpeg"></p><br><p> 该“缓存”位于何处？ 是的-这是正确的问题。 感谢您的询问。 答案很简单-它位于一个闭包中。 在一个隐藏的位置*一个记忆功能。 例如-这是<code>memoize-one</code>代码： </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fn</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> lastArgs; <span class="hljs-comment"><span class="hljs-comment">// the last arguments let lastResult;// the last result &lt;--- THIS IS THE CACHE // the memoized function const memoizedCall = function(...newArgs) { if (isEqual(newArgs, lastArgs)) { return lastResult; } lastResult = resultFn.apply(this, newArgs); lastArgs = newArgs; return lastResult; }; return memoizedCall; }</span></span></code> </pre> <br><p> 您将获得一个<code>memoizedCall</code> ，它将在其本地闭包内保存附近的最后一个结果，除了memoizedCall之外，任何人都无法访问它。 一个安全的地方。  “这”是一个安全的地方。 </p><br><p>  <code>Reselect</code>具有相同的功能，并且是创建带有另一个缓存的“叉子”的唯一方法-创建新的备注关闭。 </p><br><p> 但是（另一个）主要问题-什么时候（缓存）会“消失”？ </p><br><blockquote>  TLDR：当函数实例被Garbage Collector吞噬时，函数将“消失”。 </blockquote><p> 实例？ 实例！ 那么-关于每个实例的备注是什么？ 在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">React文档中</a>有整篇文章 </p><br><p> 简而言之-如果您使用的是基于类的React组件，则可以执行以下操作： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> memoize <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"memoize-one"</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Example</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ filter = memoize( <span class="hljs-comment"><span class="hljs-comment">// &lt;-- bound to the instance (list, filterText) =&gt; list.filter(...); // ^ that is "per instance" memoization // we are creating "own" memoization function // with the "own" lastResult render() { // Calculate the latest filtered list. // If these arguments haven't changed since the last render, // `memoize-one` will reuse the last return value. const filteredList = this.filter(something, somehow); return &lt;ul&gt;{filteredList.map(item =&gt; ...}&lt;/ul&gt; } }</span></span></code> </pre> <br><p> 那么- <strong>“ lastResult”</strong>存储在哪里？ 在该类实例内部的备注<strong>过滤器</strong>的本地范围内。 而且，何时会“消失”？ </p><br><p> 这次它将与一个类实例“消失”。 一旦组件被卸载-它就消失了。 这是一个真实的“每个实例”，您可以使用<code>this.lastResult</code>来保存时间结果，并具有完全相同的“记忆”效果。 </p><br><h2 id="whats-about-reacthooks"> 什么是React.Hooks </h2><br><p> 我们越来越近了。  Redux钩子有一些可疑的命令，这些命令可能与记忆有关。 像<code>useMemo</code> ， <code>useCallback</code> ， <code>useRef</code> </p><br><p><img src="https://habrastorage.org/webt/wx/2k/kf/wx2kkfpti6kecbdj4zoohpslkqk.png"></p><br><blockquote> 但是问题是-这次它将在何处存储已存储的值？ </blockquote><p> 简而言之-它存储在“挂钩”中，该挂钩位于VDOM元素的特殊部分内，该部分称为与当前元素关联的光纤。 在并行数据结构中。 </p><br><p> 并非如此，短钩改变了程序的工作方式，将函数移到另一个函数中，而某些变量位于<em>父闭包内的隐藏点中</em> 。 此类功能称为可<em>暂停</em>或<em>可恢复</em>功能-协程。 在JavaScript中，它们通常称为<code>generators</code>或<code>async functions</code> 。 </p><br><p> 但这有点极端。 简而言之-useMemo会在其中存储备注值。  “ this”有点不同。 </p><br><blockquote> 如果我们想创建一个更好的记忆库，我们应该找到一个更好的“ this”。 </blockquote><p>  ing！ </p><br><h1 id="weakmaps"> 弱地图！ </h1><br><p> 是的 弱地图！ 要存储键值，键就是这个，只要WeakMap不接受除此以外的任何东西，即“对象”。 </p><br><p> 让我们创建一个简单的示例： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> createHiddenSpot = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fn</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> map = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">WeakMap</span></span>(); <span class="hljs-comment"><span class="hljs-comment">// a hidden "closure" const set = (key, value) =&gt; (map.set(key, value), value); return (key) =&gt; { return map.get(key) || set(key, fn(key)) } } const weakSelect = createHiddenSpot(selector); weakSelect(todos); // create a new entry weakSelect(todos); // return an existing entry weakSelect(todos[0]); // create a new entry weakSelect(todos[1]); // create a new entry weakSelect(todos[0]); // return an existing entry! weakSelect(todos[1]); // return an existing entry!! weakSelect(todos); // return an existing entry!!!</span></span></code> </pre> <br><p> 这很简单，而且很“正确”。 那么“什么时候会消失”？ </p><br><ul><li> 忘记了weakSelect，整个“地图”将消失 </li><li> 忘记待办事项[0]，他们的弱项将消失 </li><li> 忘记待办事项-记住的数据将消失！ </li></ul><br><blockquote> 很明显什么时候会“消失”-只有在应该的时候！ </blockquote><p> 神奇地-所有重新选择的问题都消失了。 积极记忆的问题-也可以解决。 </p><br><p> 这种方法会<strong>记住</strong>数据，直到需要<strong>FORGET</strong>为止。 它令人难以置信，但是要更好地记住某件事，您必须能够更好地忘记它。 </p><br><p> 唯一的持久方法-为这种情况创建一个更强大的API </p><br><h1 id="kashe-is-acache">  Kashe-是一个缓存 </h1><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">kashe</a>是基于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">WeakMap</a>的备忘录库，可以节省您的时间。 </p><br><p> 该库公开了4个函数 </p><br><ul><li>  <code>kashe</code>记忆。 </li><li>  <code>box</code> -用于前缀的备忘录，以<em>增加</em>备忘录的机会。 </li><li>  <code>inbox</code> -嵌套的前缀备忘录，以<em>减少</em>备忘录的更改 </li><li>  fork- <em>分叉</em> （很明显）的记忆。 </li></ul><br><h2 id="kashefn--memoizedfnargs">  kashe（fn）=&gt; memoizedFn（...参数） </h2><br><p> 它实际上是上一个示例中的createHiddenSpot。 它将使用第一个参数作为内部WeakMap的键。 </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> selector = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state, prop</span></span></span><span class="hljs-function">) =&gt;</span></span> ({<span class="hljs-attr"><span class="hljs-attr">result</span></span>: state[prop]}); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> memoized = kashe(selector); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> old = memoized(state, <span class="hljs-string"><span class="hljs-string">'x'</span></span>) memoized(state, <span class="hljs-string"><span class="hljs-string">'x'</span></span>) === old memoized(state, <span class="hljs-string"><span class="hljs-string">'y'</span></span>) === memoized(state, <span class="hljs-string"><span class="hljs-string">'y'</span></span>) <span class="hljs-comment"><span class="hljs-comment">// ^^ another argument // but old !== memoized(state, 'x') // 'y' wiped 'x' cache in `state`</span></span></code> </pre> <br><p> 第一个参数是键，如果您再次调用函数相同的键，但是参数不同-缓存将被替换，则它仍然是一个缓存行长的备注。 为了使它起作用，您必须为弱案例提供不同的键，就像我对weakSelect示例所做的那样，以提供不同的键来保存结果。 重新选择级联A仍然是问题。 <br> 并非所有功能都是Kashe可记忆的。 第一个参数<em>必须</em>是对象，数组或函数。 它应该可用作WeakMap的键。 </p><br><h2 id="boxfn--memoizedfn2boxargs">  box（fn）=&gt; memoizedFn2（box，... args） </h2><br><p> 这是相同的功能，只应用了两次。 一次为fn，一次为memoizedFn，向参数添加前导键。 它可以使任何功能kashe-memoizable。 </p><br><blockquote> 它非常具有说明性-嘿，功能！ 我将结果存储在此框中。 </blockquote><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// could not be "kashe" memoized const addTwo = (a,b) =&gt; ({ result: a+b }); const bAddTwo = boxed(addTwo); const cacheKey = {}; // any object bAddTwo(cacheKey, 1, 2) === bAddTwo(cacheKey, 1, 2) === { result: 3}</span></span></code> </pre> <br><p> 如果您将已记忆的功能装箱-您将增加记忆的机会，就像每个实例的记忆-您可以创建记忆级联。 </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> selectSomethingFromTodo = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state, prop</span></span></span><span class="hljs-function">) =&gt;</span></span> ... const selector = kashe(selectSomethingFromTodo); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> boxedSelector = kashe(selector); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ render () { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> result = boxedSelector(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, todos, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.todoId); <span class="hljs-comment"><span class="hljs-comment">// 1. try to find result in `this` // 2. try to find result in `todos` // 3. store in `todos` // 4. store in `this` // if multiple `this`(components) are reading from `todos` - // selector is not working (they are wiping each other) // but data stored in `this` - exists. ... } }</span></span></code> </pre> <br><h2 id="inboxfn--memoizedfn2boxargs"> 收件箱（fn）=&gt; memoizedFn2（box，... args） </h2><br><p> 这个与盒子相反，但是几乎一样，命令嵌套缓存将数据存储到提供的盒子中。 从一个角度看-它降低了记忆化的可能性（没有记忆式级联），但是从另一个角度-它消除了缓存冲突，并在进程之间由于某种原因不相互干扰时，可以帮助隔离进程。 </p><br><blockquote> 声明性很强-嘿！ 里面的每个人！ 这是一个要使用的盒子 </blockquote><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getAndSet = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">task, number</span></span></span><span class="hljs-function">) =&gt;</span></span> task.value + number; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> memoized = kashe(getAndSet); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> inboxed = inbox(getAndSet); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doubleBoxed = inbox(memoized); memoized(task, <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-comment"><span class="hljs-comment">// ok memoized(task, 2) // previous result wiped inboxed(key1, task, 1) // ok inboxed(key2, task, 2) // ok // inbox also override the cache for any underlaying kashe calls doubleBoxed(key1, task, 1) // ok doubleBoxed(key2, task, 2) // ok</span></span></code> </pre> <br><h2 id="forkkashe-memoized--kashe-memoized"> 叉子（kashe-memoized）=&gt; kashe-memoized </h2><br><p>  Fork是真正的fork-它具有任何kashe-memoized函数，并返回该函数，但具有另一个内部缓存项。 还记得redux mapStateToProps工厂方法吗？ </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mapStateToProps = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">// const selector = createSelector(...); // const selector = fork(realSelector); // just fork existing selector. Or box it, or don't do anything // kashe is more "stable" than reselect. return state =&gt; ({ data: selector(data), }); }</span></span></code> </pre> <br><h2 id="reselect"> 重新选择 </h2><br><p> 您还应该知道一件事-Kashe可以取代reselect。 从字面上看。 </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { createSelector } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'kashe/reselect'</span></span>;</code> </pre> <br><p> 它实际上是相同的重新选择，只是使用kashe作为备忘录功能创建的。 </p><br><h1 id="codesandbox"> 密码箱 </h1><br><p> 这是一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">小例子</a> 。 另外，您可能还要<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">仔细检查测试</a> -它们紧凑而合理。 <br> 如果您想了解有关缓存和记忆的更多信息，请查看<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">我</a>一年前<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">编写最快的记忆库</a>的方式。 </p><br><blockquote>  PS：值得一提的是，这种方法的较简单版本–“弱记忆” –在情绪js中使用了一段时间。 没有投诉。  nano-memoize也将WeakMaps用于单个参数情况。 </blockquote><p> 明白了吗？ 一种更“弱”的方法将帮助您更好地记住某些事情，并更好地忘记它。 </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://github.com/theKashey/kashe</a> </p><br><p> 是的，关于忘记某事，-您能在这里看看吗？ </p><br><p><img src="https://habrastorage.org/webt/60/d6/9y/60d69ysm9v5hy9dnm1siokafjhu.jpeg"></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN446390/">https://habr.com/ru/post/zh-CN446390/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN446372/index.html">热爱任务，热爱并在公共场合找到您的个人数据</a></li>
<li><a href="../zh-CN446378/index.html">单一Skype学校切换到冬季和夏季时间的问题</a></li>
<li><a href="../zh-CN446380/index.html">H2演进-嵌入式数据库中的窗口函数，CTE，JSON / XML</a></li>
<li><a href="../zh-CN446384/index.html">在Revit中开发大型项目的提示</a></li>
<li><a href="../zh-CN446388/index.html">石油和天然气行业以外围云系统为例</a></li>
<li><a href="../zh-CN446394/index.html">5.检查点入门R80.20。 盖亚和CLI</a></li>
<li><a href="../zh-CN446396/index.html">GPS周计数器重置</a></li>
<li><a href="../zh-CN446400/index.html">Dmitry Dumik，Chatfuel：关于Y组合器，技术创业，行为改变和意识</a></li>
<li><a href="../zh-CN446402/index.html">Angular中的多语言应用</a></li>
<li><a href="../zh-CN446404/index.html">PGP的现代替代品</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>