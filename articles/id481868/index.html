<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👐🏽 😎 🌎 Dagaz: Awal yang baru 👯 😴 🧘🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ia berlari ke selatan dan berputar ke utara, berputar, berputar untuk berlari bersama anginnya 
 Dan menurut sirkuitnya angin kembali; 
 Semua sungai ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Dagaz: Awal yang baru</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/481868/"><img align="left" src="https://habrastorage.org/webt/4i/sc/k4/4isck4toxbws20hsk3nrqghdkoy.png">  <b><i>Ia berlari ke selatan dan berputar ke utara, berputar, berputar untuk berlari bersama anginnya</i></b> <b><i><br></i></b>  <b><i>Dan menurut sirkuitnya angin kembali;</i></b> <b><i><br></i></b>  <b><i>Semua sungai mengalir ke laut - dan laut tidak meluap,</i></b> <b><i><br></i></b>  <b><i>Ke tempat di mana sungai mengalir, - Di sana mereka terus mengalir;</i></b> <b><i><br><br></i></b>  <b><i><a href="https://www.biblegateway.com/passage/%3Fsearch%3DEcclesiastes%2B1" rel="nofollow">Kitab gerejawi</a></i></b> <br><br>  Pada tahun 1998, aplikasi yang benar-benar unik, untuk masanya dikembangkan yang memungkinkan Anda mengurangi proses pengembangan permainan papan abstrak (atau teka-teki) menjadi bahasa deskripsi teks kecil, yang sedikit mengingatkan pada <a href="https://en.wikipedia.org/wiki/Lisp_(programming_language)" rel="nofollow">Lisp</a> .  Proyek ini disebut <a href="http://www.zillions-of-games.com/" rel="nofollow">Zillions of Games</a> .  Itu menciptakan kehebohan di antara penggemar game papan.  Saat ini, lebih dari 2.000 aplikasi telah dibuat menggunakan teknologi ini. <br><a name="habracut"></a><br>  Dengan cepat menjadi jelas bahwa ZoG memiliki banyak kelemahan.  Saya sudah <a href="https://habr.com/ru/post/221779/">menulis</a> tentang ini di Habr dan saya tidak akan mengulangi lagi.  Izinkan saya mengatakan bahwa para pengembang tidak memperhitungkan fitur-fitur dari sejumlah besar game yang ada dan beberapa opsi penting sudah dikodekan, sehingga perubahan mereka menjadi sangat bermasalah.  Greg Schmidt, pada 2007, mencoba memperbaiki situasi dengan merilis <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi%3Fdo%3Dshow%3Bid%3D1452" rel="nofollow">Axiom Development Kit</a> , tetapi integrasi yang erat dengan ZoG tidak memungkinkan menyelesaikan semua masalah. <br><br>  Project <a href="http://cambolbro.com/cv/publications/ciaig-browne-maire-19.pdf" rel="nofollow">Ludi</a> menunjukkan batas baru, menggunakan "mesin" permainan universal dan <a href="https://en.wikipedia.org/wiki/Genetic_algorithm" rel="nofollow">algoritma genetika</a> untuk mengotomatiskan proses pengembangan game papan baru.  Sayangnya, pendekatan ini pada awalnya dianggap sebagai penyederhanaan yang disengaja dari mekanisme permainan dan tingkat AI yang digunakan.  Diskusi tujuan proyek ini berada di luar ruang lingkup artikel ini, tetapi beberapa solusi teknisnya, tidak diragukan lagi, menjadi titik awal untuk pengembangan saya sendiri. <br><br>  Tujuan saya adalah pengembangan "mesin" yang lebih fleksibel dan ramah pengguna untuk pembuatan game papan abstrak.  Selama hampir satu tahun saya telah mempelajari kemungkinan ZoG dan Aksioma dan belajar banyak tentang keterbatasan mereka.  Saya pikir saya bisa menyelesaikan masalah mereka dengan menciptakan solusi yang lebih universal dan lintas platform.  Tentang kemajuan pekerjaan pada proyek ini saya akan melaporkan. <br><br><h2>  Keterbukaan dan modularitas </h2><br>  Mungkin kelemahan utama ZoG adalah penutupannya.  Produk ini dirakit “sekali dan selamanya” di bawah satu platform tunggal - Windows.  Kalau itu kode sumber terbuka, orang bisa mencoba untuk mem-portalnya di Linux, Android, iOS ... Masalah lain adalah monolitiknya. <br><br>  Di ZoG ada permulaan modularitas, memungkinkan untuk koneksi ke game DLL, termasuk implementasi kustom AI.  Aksioma berjalan sedikit lebih jauh, memungkinkan Anda untuk menjalankan aplikasi dalam mode autoplay, tanpa menggunakan kernel ZoG.  Sekalipun ada keterbatasan serius dari solusi ini (hanya mendukung aplikasi untuk dua pemain), contoh ini menunjukkan bagaimana modularitas akan membantu!  Kesempatan untuk mengatur permainan dengan dua bot (menggunakan pengaturan AI yang berbeda) dan untuk mengumpulkan statistik pada sejumlah besar permainan tidak dapat ditaksir terlalu tinggi.  Tetapi akan jauh lebih baik jika produk tersebut sepenuhnya modular! <br><br><ul><li>  Pindahkan modul pembangkit </li><li>  Pindahkan modul eksekusi </li><li>  Modul kontrol </li><li>  Modul AI </li><li>  Modul visualisasi </li></ul><br>  Semua pekerjaan yang menggambarkan permainan harus dilakukan oleh modul pemindahan generasi.  Ini adalah "jantung" proyek.  Pemindahan semua tugas yang tidak terhubung dengan fungsi ini ke modul lain akan membuatnya sesederhana mungkin.  Anda dapat meningkatkan modul ini, tanpa melihat masalah AI dan interaksi pengguna.  Anda dapat sepenuhnya mengubah format deskripsi game atau menambahkan dukungan untuk deskripsi dalam format ZoG, Axiom dan Ludi.  Modularitas adalah dasar dari fleksibilitas solusi! <br><br>  Modul eksekusi langkah adalah penjaga kondisi permainan.  Informasi tentang status permainan saat ini ditransfer ke semua modul lain sesuai permintaan.  Untuk alasan yang akan saya berikan di bawah ini, kemajuan eksekusi harus melewati modul generasi, yang tugasnya adalah pembentukan perintah dalam hal pelaksanaan modul.  Juga, tugas dari modul pembangkitan bergerak adalah konfigurasi utama ruang gim, berdasarkan deskripsi gim. <br><br>  Modul kontrol sebenarnya adalah aplikasi itu sendiri.  Itu meminta modul generasi bergerak untuk daftar langkah yang mungkin dan mengubah keadaan permainan, melewati langkah yang dipilih ke modul eksekusi langkah.  Modul kontrol dapat dihubungkan untuk memainkan satu atau lebih bot AI.  Sebanyak yang Anda butuhkan (dan mungkin berbeda)!  Jenis unit kontrol ditentukan oleh pembagian tugas.  Ini mungkin putar otomatis untuk mengumpulkan statistik game, server game (dapat mengontrol beberapa toko negara, memimpin sejumlah besar sesi permainan) atau aplikasi individual untuk bermain offline. <br><br>  Kemampuan untuk menghubungkan berbagai implementasi AI akan meningkatkan kualitas permainan.  Dapat dipahami bahwa modul untuk permainan catur dan Go harus menggunakan pendekatan yang berbeda.  Gim dengan informasi yang tidak lengkap dan gim yang menggunakan data acak juga membutuhkan pendekatan individual.  Implementasi universal AI akan sama buruknya memainkan semua game!  Koneksi modular AI akan memungkinkan untuk membandingkan "kekuatan" dari algoritma, termasuk mode permainan "satu sama lain." Karena arsitektur AI dipisahkan dari kondisi penyimpanan permainan, satu contoh bot permainan dapat mendukung jumlah yang tidak terbatas sesi game secara bersamaan. <br><br>  Visualisasi proses permainan juga dapat bervariasi.  Hal pertama yang terlintas dalam pikiran adalah implementasi 2D dan 3D.  Platform tempat aplikasi sedang dikembangkan, juga penting.  Yang kurang jelas adalah bahwa visualisasi mungkin menjadi bagian penting dari permainan!  Misalnya, dalam permainan <a href="https://glukkazan.github.io/elimination/surakarta.htm" rel="nofollow">Surakarta</a> , mengambil barang akan sama sekali tidak jelas karena tidak ada animasi gerakan yang tepat. <br><br><div style="text-align:center;"> <a href="https://glukkazan.github.io/elimination/surakarta.htm" rel="nofollow"><img src="https://habrastorage.org/files/9ad/1cd/c7c/9ad1cdc7c76041dc8776c5f4cb1a086a.jpg"></a> </div><br>  Secara umum, modularitas tampaknya merupakan ide yang bagus untuk proyek semacam itu, dan kode sumber terbuka akan memungkinkan semua orang yang ingin berpartisipasi dalam proyek tersebut.  Saat ini, saya tidak menetapkan tujuan komersial untuk diri saya, tetapi saya pikir, jika diinginkan, saya akan menemukan cara untuk menghasilkan uang tanpa menutup kode sumber. <br><br><h2>  Ruang permainan </h2><br>  Sebelum memulai pertunjukan, Anda perlu mengatur panggung.  Papan bukan hanya tempat di mana potongan tersusun.  Selain itu, arah pergerakan potongan dapat ditentukan (pada kenyataannya, koneksi antara posisi papan) area bermain (misalnya, area untuk konversi potongan) bidang terlarang, dll.  Berikut adalah bagaimana definisi papan catur terlihat dalam implementasi ZoG: <br><br><div class="spoiler">  <b class="spoiler_title">Menentukan papan dalam ZoG</b> <div class="spoiler_text"><pre><code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">define</span></span> Board-Definitions (<span class="hljs-name"><span class="hljs-name">image</span></span> <span class="hljs-string"><span class="hljs-string">"images\Chess\SHaag\Chess8x8.bmp"</span></span> <span class="hljs-string"><span class="hljs-string">"images\Chess\Chess8x8.bmp"</span></span>) (<span class="hljs-name"><span class="hljs-name">grid</span></span> (<span class="hljs-name"><span class="hljs-name">start-rectangle</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">53</span></span> <span class="hljs-number"><span class="hljs-number">53</span></span>) (<span class="hljs-name"><span class="hljs-name">dimensions</span></span> (<span class="hljs-string"><span class="hljs-string">"a/b/c/d/e/f/g/h"</span></span> (<span class="hljs-number"><span class="hljs-number">49</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>)) <span class="hljs-comment"><span class="hljs-comment">; files ("8/7/6/5/4/3/2/1" (0 49)) ; ranks ) (directions (n 0 -1) (e 1 0) (s 0 1) (w -1 0) (ne 1 -1) (nw -1 -1) (se 1 1) (sw -1 1) ) ) (symmetry Black (ns)(sn) (nw sw)(sw nw) (ne se)(se ne)) (zone (name promotion-zone) (players White) (positions a8 b8 c8 d8 e8 f8 g8 h8) ) (zone (name promotion-zone) (players Black) (positions a1 b1 c1 d1 e1 f1 g1 h1) ) (zone (name third-rank) (players White) (positions a3 b3 c3 d3 e3 f3 g3 h3) ) (zone (name third-rank) (players Black) (positions a6 b6 c6 d6 e6 f6 g6 h6) ) )</span></span></code> </pre> </div></div><br>  Anda mungkin memperhatikan bahwa di samping pengaturan gim, berikut adalah pengaturan yang terkait dengan visualisasi.  Saya sangat yakin bahwa pengaturan ini bukan di sini.  Dalam menerapkan modul visualisasi, beberapa pengaturan dapat digunakan dan pengaturan yang berbeda mungkin diperlukan.  Selain itu, game simulasi dapat bekerja tanpa modul visualisasi sama sekali (seperti pemutaran otomatis di Axiom).  Memang, karena Aksioma digunakan untuk memvisualisasikan ZoG, definisi tersebut tidak mengandung sesuatu yang berlebihan: <br><br><div class="spoiler">  <b class="spoiler_title">Mendefinisikan papan di Aksioma</b> <div class="spoiler_text"><pre> <code class="perl hljs">{board <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-string"><span class="hljs-string">{grid}</span></span> board} {directions -<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-string"><span class="hljs-string">{direction}</span></span> n <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-string"><span class="hljs-string">{direction}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">s</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-string"><span class="hljs-string">{direction}</span></span> e <span class="hljs-number"><span class="hljs-number">0</span></span> -<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-string"><span class="hljs-string">{direction}</span></span> w -<span class="hljs-number"><span class="hljs-number">1</span></span> -<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-string"><span class="hljs-string">{direction}</span></span> nw <span class="hljs-number"><span class="hljs-number">1</span></span> -<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-string"><span class="hljs-string">{direction}</span></span> sw -<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-string"><span class="hljs-string">{direction}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ne</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-string"><span class="hljs-string">{direction}</span></span> se directions} {symmetries Black <span class="hljs-string"><span class="hljs-string">{symmetry}</span></span> ns Black <span class="hljs-string"><span class="hljs-string">{symmetry}</span></span> nw sw Black <span class="hljs-string"><span class="hljs-string">{symmetry}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ne</span></span> se symmetries}</code> </pre></div></div><br>  Sayangnya, Aksioma juga tidak memiliki cara untuk menentukan zona game (lokasi zona game harus ditentukan secara manual dalam kode).  Ini bukan satu-satunya penyederhanaan aksioma.  Definisi papan dalam proyek ini tidak boleh mengandung lebih dari satu kisi dan kisi ini harus dua dimensi.  Papan, dengan demikian didefinisikan, adalah array satu dimensi, tetapi untuk kenyamanan programmer, sinonim didefinisikan untuk masing-masing ruang sebagai berikut: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/4d2/76d/a04/4d276da04e6542a385c3c30deeb6872f.PNG"></div><br>  Dibandingkan dengan skema definisi grid yang lebih fleksibel dalam ZoG, batasan ini cukup tidak nyaman (terutama mengingat fakta bahwa skema penamaan yang diberlakukan menggunakan bidang ini untuk tujuan visualisasi).  Untungnya, dimungkinkan untuk mendefinisikan dewan dengan bentuk yang sewenang-wenang.  Baik Aksioma dan ZoG memberikan kesempatan untuk mengidentifikasi elemen-bijaksana setiap posisi di papan bersama dengan kemampuan untuk menentukan hubungan antara pasangan posisi yang sewenang-wenang.  Dengan menggunakan pendekatan ini, kita dapat mendefinisikan papan topologi apa pun.  Satu-satunya kelemahan adalah verbositas ekstrim dan kompleksitas deskripsi. <br><br>  Selain lokasi potongan-potongan di papan tulis dan di cadangan, sistem harus memiliki kemampuan untuk menyimpan atribut untuk potongan-potongan individual dan untuk ruang-ruang di papan tulis.  Sebuah contoh yang baik tentang perlunya menggunakan atribut aturan " <a href="https://en.wikipedia.org/wiki/Castling" rel="nofollow">castling</a> " dalam <a href="https://en.wikipedia.org/wiki/Chess" rel="nofollow">catur</a> .  Ini adalah langkah yang sulit, yang termasuk gerakan simultan dari raja dan benteng, diizinkan, asalkan tidak satupun dari potongan-potongan ini telah bergerak sebelum melakukan langkah ini.  Atribut dapat digunakan untuk menyimpan tag Boolean yang menunjukkan apakah bagian tersebut pernah dipindahkan.  Atribut field juga dapat menemukan beberapa aplikasi menarik. <br><br>  Perlu dicatat bahwa atribut bukan hanya variabel tetapi bagian dari kondisi permainan.  Nilai atribut dapat diubah dengan eksekusi belokan (termasuk oleh modul AI) dan harus tersedia untuk semua belokan berikutnya, tetapi tidak untuk belokan yang dilakukan di cabang lain dari game.  Saat ini, ZoG mendukung penyimpanan atribut boolean.  Atribut aksioma penyimpanan tidak didukung, tetapi Anda dapat menambahkan deskripsi definisi variabel dan array ke definisi board.  Variabel-variabel ini dapat digunakan, seperti penghitung jumlah potongan yang ditangkap: <br><br><pre> <code class="perl hljs">{board <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">18</span></span> <span class="hljs-string"><span class="hljs-string">{grid}</span></span> <span class="hljs-string"><span class="hljs-string">{variable}</span></span> WhitePieces <span class="hljs-string"><span class="hljs-string">{variable}</span></span> BlackPieces board}</code> </pre> <br>  Namun batasan lain dari ZoG dan Aksioma adalah aturan bahwa setiap posisi dewan dapat berisi tidak lebih dari satu bagian.  Jika ada bagian yang menyelesaikan perpindahan ke posisi yang ditempati oleh bagian lain, bagian yang sebelumnya menempati posisi tersebut secara otomatis dianggap "dimakan".  Aturan ini berjalan dengan baik dengan prinsip "catur" mengambil barang dan berfungsi untuk menyederhanakan deskripsi game ini, tetapi mempersulit implementasi game seperti " <a href="http://www.iggamecenter.com/info/en/bashni.html" rel="nofollow">bashni checkers</a> " dan " <a href="http://www.iggamecenter.com/info/en/tavreli.html" rel="nofollow">tavreli</a> ". <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/455/804/146/45580414699f406281745176b1d91d9b.JPG"></div><br><br>  Dalam permainan ini, potongan dapat diatur dalam "kolom".  "Kolom" seperti itu dapat dipindahkan bersama-sama, sebagai satu kesatuan.  Setelah beberapa refleksi, saya memutuskan bahwa lebih baik tidak meninggalkan implementasi otomatis dari tangkapan "Catur", tetapi untuk meningkatkan mekanisme untuk memindahkan kelompok potongan.  Memang, untuk implementasi "pilar", Anda selalu dapat menambahkan ke dimensi lain (ini sangat mudah, selama modul visualisasi dipisahkan dari modul penghasil bergerak dan dari AI, maka Anda dapat menggunakan logika apa pun. untuk merender papan tiga dimensi ke dalam visualisasi dua dimensinya).  Argumen tambahan yang mendukung keputusan ini adalah bahwa gerakan “tumpukan tinggi” bukan satu-satunya jenis perjalanan kelompok.  Misalnya, dalam fragmen papan " <a href="https://s3-eu-west-1.amazonaws.com/mosigra.product.other/522/067/pentago.pdf" rel="nofollow">Pentago</a> " dapat diputar bersama-sama dengan potongan yang dipasang di atasnya. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/3f9/8db/7ba/3f98db7ba32042ec8dff2eb42878fa2e.jpg"></div><br>  Merangkum, saya dapat mengatakan bahwa, untuk kerangka permainan saya, saya memutuskan untuk mengambil semua yang terbaik yang telah dipikirkan di ZoG, Axiom, dan Ludi, dan menambahkan apa pun, yang menurut saya, tidak ada. <br><br><h2>  Pindahkan generasi </h2><br>  Move generation mirip dengan <a href="https://en.wikipedia.org/wiki/Nondeterministic_programming" rel="nofollow">pemrograman non-deterministik</a> .  Tugas generator gerakan menyediakan, atas permintaan, daftar semua kemungkinan perpindahan dari posisi saat ini.  Perpindahan mana dari daftar ini yang akan dipilih oleh pemain atau AI bukan fungsinya.  Mari kita lihat bagaimana generasi gerakan dilakukan dalam ZoG.  Sebagai contoh, kami mengambil langkah makro untuk bagian jangka panjang (ratu atau uskup).  Ini adalah bagaimana ia digunakan dalam menentukan gerakan untuk potongan-potongan ini: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">piece</span></span> (<span class="hljs-name"><span class="hljs-name">name</span></span> Bishop) (<span class="hljs-name"><span class="hljs-name">image</span></span> White <span class="hljs-string"><span class="hljs-string">"images\Chess\SHaag\wbishop.bmp"</span></span> <span class="hljs-string"><span class="hljs-string">"images\Chess\wbishop.bmp"</span></span> Black <span class="hljs-string"><span class="hljs-string">"images\Chess\SHaag\bbishop.bmp"</span></span> <span class="hljs-string"><span class="hljs-string">"images\Chess\bbishop.bmp"</span></span>) (<span class="hljs-name"><span class="hljs-name">moves</span></span> (<span class="hljs-name"><span class="hljs-name">slide</span></span> ne) (<span class="hljs-name"><span class="hljs-name">slide</span></span> nw) (<span class="hljs-name"><span class="hljs-name">slide</span></span> se) (<span class="hljs-name"><span class="hljs-name">slide</span></span> sw) ) )</code> </pre> <br>  Sebagai parameter, makro dilewatkan arah gerakan di papan tulis.  Jika Anda tidak mempertimbangkan kemungkinan untuk memasang potongan-potongan baru di papan tulis, pembuatan langkah terlihat sederhana.  Untuk masing-masing bagian di papan tulis, semua gerakan yang mungkin sesuai dengan aturan dihitung.  Kemudian keajaiban dimulai ... <br><br>  Setiap definisi dapat ditambahkan ke daftar sejumlah gerakan yang mungkin!  Menambahkan langkah ke daftar dilakukan dengan perintah add (pada saat yang sama memposisikan setiap bagian yang bergerak di papan).  Saya sudah <a href="https://habr.com/ru/post/221779/">menulis</a> tentang bagaimana solusi arsitektur ini sangat buruk.  Perintah untuk pembentukan langkah harus dipisahkan dari perintah yang memanipulasi potongan (seperti yang dilakukan dalam Aksioma).  Mari kita lihat cara kerja makro: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">define</span></span> slide ( $<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">while</span></span> empty? add $<span class="hljs-number"><span class="hljs-number">1</span></span> ) (<span class="hljs-name"><span class="hljs-name">verify</span></span> not-friend?) add ))</code> </pre> <br><br>  Pertama, perpindahan dilakukan oleh satu sel, dalam arah yang diberikan, kemudian dalam siklus ruang yang dicapai diperiksa untuk tidak adanya potongan-potongan di atasnya, bergerak terbentuk, dan pengaturan berlanjut ke sel lain dalam arah yang sama.  Jika Anda berhenti di sini, bidak dapat "meluncur" melalui sel-sel kosong, tetapi bagaimana Anda bisa mengambil bidak musuh? <br><br>  Sangat sederhana!  Setelah menjalankan perintah verifikasi, verifikasi bahwa bidang tersebut tidak ditempati oleh bagian yang ramah, kami membentuk perintah tambahan lain, menyelesaikan langkah.  Jika pada sel ini ditemukan bagian musuh, itu akan diambil secara otomatis (seperti pada satu ruang papan, pada satu waktu, Anda tidak dapat memiliki lebih dari satu bagian).  Jika bagian itu ramah, perhitungan langkah akan dibatalkan dengan perintah verifikasi (pelanggaran terhadap kondisi yang ditentukan dalam perintah ini segera mengakhiri perhitungan langkah saat ini). <br><br>  Z baik ZoG dan Aksioma, seseorang hanya dapat memindahkan kepingannya sendiri (atau lebih tepatnya, memindahkan kepingan lawan dimungkinkan, tetapi hanya jika ditentukan dalam mode perhitungan kepindahan salah satu kepingannya sendiri).  Saya menemukan ini sebagai batasan yang sangat tidak nyaman, karena ada banyak permainan di mana Anda dapat langsung memindahkan bagian lawan (dalam " <a href="https://glukkazan.github.io/checkers/stavropol-checkers.htm" rel="nofollow">Stavropol Checkers</a> ", misalnya).  Akan lebih konsisten untuk melakukan perhitungan langkah untuk semua bagian, terlepas dari afiliasinya.  Di makro yang menentukan langkah, seseorang hanya perlu menambahkan satu centang untuk memungkinkan hanya memindahkan bagiannya sendiri: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">define</span></span> slide ( (<span class="hljs-name"><span class="hljs-name">verify</span></span> friend?) $<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">while</span></span> empty? add $<span class="hljs-number"><span class="hljs-number">1</span></span> ) (<span class="hljs-name"><span class="hljs-name">verify</span></span> not-friend?) add ))</code> </pre> <br><br>  Penting adalah kemampuan untuk melakukan gerakan yang terdiri dari beberapa gerakan "parsial".  Dalam implementasi draft, kemampuan ini digunakan untuk melakukan tangkapan "rantai": <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">define</span></span> checker-jump ($<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">verify</span></span> enemy?) capture $<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">verify</span></span> empty?) (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">not-in-zone</span></span>? promotion-zone) (<span class="hljs-name"><span class="hljs-name">add-partial</span></span> jumptype) else (<span class="hljs-name"><span class="hljs-name">add-partial</span></span> King jumptype) ) ) )</code> </pre> <br><br>  Perintah move parsial dibentuk dengan add-partial (untuk perintah ini, serta untuk perintah add, ada variasi dari langkah tersebut, dengan "transformasi" potongan-potongan).  Langkah seperti itu selalu merupakan bagian dari langkah "komposit" yang lebih besar.  Sebagai aturan, untuk gerakan selanjutnya, "mode" diatur, yang harus diimplementasikan kelanjutan.  Jadi pada checker, tangkapan hanya dapat dilanjutkan dengan tangkapan berikut tetapi tidak dengan gerakan "lunak" (tidak menangkap). <br><br><div class="spoiler">  <b class="spoiler_title">Catatan</b> <div class="spoiler_text">  Di ZoG, implementasi gerakan parsial buruk.  Mencoba menjalankan perintah add-partial dalam satu siklus menyebabkan kesalahan.  Akibatnya, penangkapan yang dilakukan oleh raja pemeriksa dapat diwujudkan hanya dengan cara yang sangat canggung berikut: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">define</span></span> king-jump-1 ($<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">while</span></span> empty? $<span class="hljs-number"><span class="hljs-number">1</span></span> ) (<span class="hljs-name"><span class="hljs-name">verify</span></span> enemy?) capture $<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">verify</span></span> empty?) (<span class="hljs-name"><span class="hljs-name">add-partial</span></span> jumptype) ) ) (<span class="hljs-name"><span class="hljs-name">define</span></span> king-jump-2 ($<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">while</span></span> empty? $<span class="hljs-number"><span class="hljs-number">1</span></span> ) (<span class="hljs-name"><span class="hljs-name">verify</span></span> enemy?) capture $<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">verify</span></span> empty?) $<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">verify</span></span> empty?) (<span class="hljs-name"><span class="hljs-name">add-partial</span></span> jumptype) ) )</code> </pre> <br>  Dan seterusnya, sampai king-jump-7!  Izinkan saya mengingatkan Anda bahwa di sebagian besar varietas biji dengan raja “jarak jauh”, raja, setelah setiap penangkapan, dapat berhenti di ruang rantai kosong yang terus-menerus mengikuti potongan yang ditangkap.  Secara kebetulan, ada satu varian dari game ini di mana aturan penangkapan "rantai" diformulasikan secara berbeda.  Itulah yang saya sukai dari biji - setiap orang dapat menemukan varian sesuai dengan keinginan seseorang. <br></div></div><br>  Sistem deskripsi aturan seperti itu sangat fleksibel, tetapi kadang-kadang diperlukan logika yang lebih kompleks.  Sebagai contoh, jika sambungan, selama "parsial" kemajuan tidak boleh melewati kembali bidang yang sebelumnya dilalui, adalah logis untuk menggunakan bendera yang terkait dengan posisi di papan tulis.  Setelah mengunjungi ruang, kami menetapkan bendera, jadi selanjutnya tidak pergi ke ruang ini lagi: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">verify</span></span> (<span class="hljs-name"><span class="hljs-name">not-position-flag</span></span>? my-flag)) (<span class="hljs-name"><span class="hljs-name">set-position-flag</span></span> my-flag true)</code> </pre> <br>  Selain bendera "posisional", di ZoG Anda dapat menggunakan bendera global.  Kemampuan ini tidak harus disamakan dengan atribut potongan.  Tidak seperti yang terakhir, ini bukan bagian dari kondisi permainan.  Sayangnya, kedua atribut potongan dan bendera di ZoG hanya bisa boolean (dalam atribut aksioma bahkan tidak didukung).  Keterbatasan ini membuat sulit untuk melakukan operasi yang terkait dengan berbagai jenis penghitungan.  Misalnya, dalam teka-teki kecil <a href="http://zillions-of-games.com/cgi-bin/zilligames/submissions.cgi%3Fdo%3Dshow%3Bid%3D2233" rel="nofollow">ini</a> , saya harus menggunakan untuk “menghitung” keping, terjebak dalam “garpu”, sepasang bendera boolean (jumlah persis yang tidak saya butuhkan, asalkan kepingannya lebih dari satu). <br><br>  Hal lain yang harus diperbaiki adalah kurangnya “siklus hidup” yang jelas dalam pelaksanaan langkah tersebut.  Semua flag secara otomatis diatur ulang sebelum memulai langkah, tetapi akan lebih mudah untuk mengidentifikasi dengan jelas fase inisialisasi.  Menurut pendapat saya, dalam perhitungan langkah, harus ada fase berikut: <br><br><ol><li>  Inisialisasi variabel dan memeriksa prasyarat untuk langkah komposit </li><li>  Inisialisasi variabel dan memeriksa prasyarat untuk langkah parsial </li><li>  Generasi dari gerakan parsial </li><li>  Memeriksa kondisi akhir dari gerakan parsial </li><li>  Menghasilkan, menyelesaikan, dan memeriksa postconditions dari langkah komposit </li><li>  Memeriksa kondisi penghentian permainan </li></ol><br>  Kelompok langkah dari yang kedua ke yang keempat, dalam gerakan komposit penuh, dapat diulang berkali-kali.  Gagasan pra-dan pasca-kondisi, yang saya sebut invarian, saya ambil dari proyek Ludi.  Saya bercerita lebih banyak tentang penggunaan invarian. <br><br><h2>  Tentang pentingnya notasi </h2><br>  Generasi dari semua kemungkinan pergerakan dari posisi hanya setengah dari cerita.  Untuk mengontrol keadaan gim, diperlukan presentasi ringkas dari gerakan yang dihasilkan.  Dalam ZoG, untuk tujuan ini, notasi ZSG digunakan.  Berikut ini adalah catatan kemungkinan awal permainan catur dalam bentuk ini: <br><br><pre> <code class="perl hljs"><span class="hljs-number"><span class="hljs-number">1</span></span>. Pawn e2 - e4 <span class="hljs-number"><span class="hljs-number">1</span></span>. Pawn e7 - e5 <span class="hljs-number"><span class="hljs-number">2</span></span>. Knight g1 - f3 <span class="hljs-number"><span class="hljs-number">2</span></span>. Knight b8 - c6 <span class="hljs-number"><span class="hljs-number">3</span></span>. Bishop f1 - c4 <span class="hljs-number"><span class="hljs-number">3</span></span>. Knight g8 - f6 <span class="hljs-number"><span class="hljs-number">4</span></span>. King e1 - g1 Rook h1 - f1 @ f1 <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> @ g1 <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>. Pawn d7 - d5 <span class="hljs-number"><span class="hljs-number">5</span></span>. Pawn e4 <span class="hljs-keyword"><span class="hljs-keyword">x</span></span> d5 <span class="hljs-number"><span class="hljs-number">5</span></span>. Knight f6 <span class="hljs-keyword"><span class="hljs-keyword">x</span></span> d5</code> </pre> <br>  Skrip ini dekat dengan <a href="https://en.wikipedia.org/wiki/Chess_notation" rel="nofollow">notasi catur</a> biasa dan umumnya ramah pengguna.  Hanya langkah keempat putih yang dapat menyebabkan kebingungan.  Jadi di ZSG sepertinya seperti <a href="https://en.wikipedia.org/wiki/Castling" rel="nofollow">castling</a> .  Bagian dari deskripsi langkah sebelum karakter '@' cukup jelas;  itu adalah gerakan serentak benteng dan raja, tetapi apa yang terjadi selanjutnya?  Jadi, dalam ZSG, sepertinya diperlukan reset atribut dari potongan-potongan untuk mencegah kemungkinan castling berulang. <br><br><div class="spoiler">  <b class="spoiler_title">Catatan</b> <div class="spoiler_text">  ZoG menggunakan notasi ZSG-nya khususnya untuk menunjukkan jalannya permainan dalam bentuk yang dapat dimengerti oleh pemain.  Di sebelah kanan papan, sub-jendela "Daftar Bergerak" mungkin terbuka.  Daftar ini dapat digunakan untuk menavigasi melalui game yang direkam.  Daftar ini sangat tidak nyaman, karena tampilan cabang dari permainan alternatif tidak didukung.  Bagian dari belokan yang direkam terkait dengan perubahan atribut potongan, tidak ditampilkan kepada pengguna. <br></div></div><br>  Rekaman langkah dalam notasi ZSG harus berisi informasi lengkap yang cukup untuk mengubah keadaan game dengan benar.  Jika informasi tentang perubahan atribut hilang, dalam permainan sesuai dengan catatan seperti itu, suatu langkah bisa diulang secara tidak benar (misalnya, pemain akan memiliki kesempatan untuk mengeksekusi kembali castling).  Sayangnya, dalam ekstensi DLL (seperti Aksioma), informasi tambahan tidak dapat dikirim. <br><br>  Bekerja dengan ekstensi DLL, ZoG dipaksa untuk membuat manipulasi yang cukup cerdik ketika memposisikan ke langkah yang dipilih (misalnya, ketika Anda memutar mundur suatu langkah).  Dari [setiap] posisi sebelumnya [bekerja dari awal permainan], semua gerakan yang mungkin dihasilkan, dan kemudian, dalam daftar itu, seseorang harus mencari gerakan dengan representasi ZSG [yang sesuai].  Efek samping [masing-masing] yang dihasilkan diterapkan ke kondisi permainan [setiap berturut-turut], karena dimungkinkan untuk melakukan efek samping yang tidak tercermin dalam representasi ZSG gerakan tersebut. <br><br>  Situasi ini diperparah oleh fakta bahwa satu-satunya cara untuk mencapai keadaan permainan pada saat bergerak di masa lalu, adalah aplikasi yang konsisten dari semua gerakan dari awal permainan, ke keadaan awal papan.  Dalam <a href="https://habr.com/ru/post/234587/">kasus yang</a> sangat <a href="https://habr.com/ru/post/234587/">kompleks</a> , navigasi semacam ini tidak terjadi dengan cepat.  Kerugian lain dari notasi ZSG dapat diilustrasikan dengan merekam langkah berikut dalam permainan <a href="https://en.wikipedia.org/wiki/Go_(game)" rel="nofollow">Go</a> : <br><br><pre> <code class="perl hljs"><span class="hljs-number"><span class="hljs-number">1</span></span>. White Stone G19 <span class="hljs-keyword"><span class="hljs-keyword">x</span></span> A19 <span class="hljs-keyword"><span class="hljs-keyword">x</span></span> B19 <span class="hljs-keyword"><span class="hljs-keyword">x</span></span> C19 <span class="hljs-keyword"><span class="hljs-keyword">x</span></span> D19 <span class="hljs-keyword"><span class="hljs-keyword">x</span></span> E19 <span class="hljs-keyword"><span class="hljs-keyword">x</span></span> F19</code> </pre> <br>  Di sini, di posisi G19, sebuah batu putih ditempatkan yang menangkap sekelompok batu hitam.  Karena semua bagian yang terlibat dalam kinerja penempatan harus disebutkan dalam kinerja ZSG, catatan belokan mungkin tampak sangat panjang (dalam Go, satu tetes dapat menangkap hingga 360 batu).  Untuk apa ini dapat menyebabkan, saya menulis <a href="https://habr.com/ru/post/235483/">sebelumnya</a> .  Ukuran buffer yang dialokasikan untuk merekam gerakan ZoG, mungkin tidak cukup.  Selain itu, jika karena alasan tertentu urutan pemindahan batu berubah (dalam proses pengembangan permainan itu terjadi), upaya untuk menerapkan langkah, dari urutan tangkapan lama, akan gagal. <br><br>  Untungnya, ada cara sederhana untuk menangani semua masalah ini.  Mari kita lihat bagaimana mendefinisikan gerakan potongan di ZRF: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">piece</span></span> (<span class="hljs-name"><span class="hljs-name">name</span></span> Pawn) (<span class="hljs-name"><span class="hljs-name">image</span></span> White <span class="hljs-string"><span class="hljs-string">"images\Chess\SHaag\wpawn.bmp"</span></span> <span class="hljs-string"><span class="hljs-string">"images\Chess\wpawn.bmp"</span></span> Black <span class="hljs-string"><span class="hljs-string">"images\Chess\SHaag\bpawn.bmp"</span></span> <span class="hljs-string"><span class="hljs-string">"images\Chess\bpawn.bmp"</span></span>) (<span class="hljs-name"><span class="hljs-name">moves</span></span> (<span class="hljs-name"><span class="hljs-name">Pawn-capture</span></span> nw) (<span class="hljs-name"><span class="hljs-name">Pawn-capture</span></span> ne) (<span class="hljs-name"><span class="hljs-name">Pawn-move</span></span>) (<span class="hljs-name"><span class="hljs-name">En-Passant</span></span> e) (<span class="hljs-name"><span class="hljs-name">En-Passant</span></span> w) ) )</code> </pre> <br>  Nama gerakan, didefinisikan dalam makro ZoG, tidak dapat diakses sebagai generator gerakan.  Tapi apa yang mencegah kita menyerah pada makro dan membuat deskripsi gerakan dengan nama mereka?  Begini cara catatan mencari permainan catur: <br><br><pre> <code class="perl hljs"><span class="hljs-number"><span class="hljs-number">1</span></span>. e2 - e4 Pawn-move <span class="hljs-number"><span class="hljs-number">1</span></span>. e7 - e5 Pawn-move <span class="hljs-number"><span class="hljs-number">2</span></span>. g1 - f3 leap2 n nw <span class="hljs-number"><span class="hljs-number">2</span></span>. b8 - c6 leap2 n <span class="hljs-keyword"><span class="hljs-keyword">ne</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>. f1 - c4 slide nw <span class="hljs-number"><span class="hljs-number">3</span></span>. g8 - f6 leap2 n nw <span class="hljs-number"><span class="hljs-number">4</span></span>. e1 - g1 OO <span class="hljs-number"><span class="hljs-number">4</span></span>. d7 - d5 Pawn-move <span class="hljs-number"><span class="hljs-number">5</span></span>. e4 <span class="hljs-keyword"><span class="hljs-keyword">x</span></span> d5 Pawn-capture nw <span class="hljs-number"><span class="hljs-number">5</span></span>. f6 <span class="hljs-keyword"><span class="hljs-keyword">x</span></span> d5 leap2 w nw</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Catatan</b> <div class="spoiler_text">  Pembaca yang cerdik mungkin memperhatikan bahwa dalam gerakan untuk "hitam" saya menggunakan arahan yang tidak sesuai dengan arahan yang sebenarnya di papan catur.  Ini terhubung dengan fakta bahwa "simetri" didefinisikan untuk hitam: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">symmetry</span></span> Black (<span class="hljs-name"><span class="hljs-name">ns</span></span>)(<span class="hljs-name"><span class="hljs-name">sn</span></span>) (<span class="hljs-name"><span class="hljs-name">nw</span></span> sw)(<span class="hljs-name"><span class="hljs-name">sw</span></span> nw) (<span class="hljs-name"><span class="hljs-name">ne</span></span> se)(<span class="hljs-name"><span class="hljs-name">se</span></span> ne))</code> </pre> <br>  Jadi, berbicara kasar untuk apa yang putih itu "utara", karena hitam adalah "selatan", dan sebaliknya. <br></div></div><br>  Manfaat dari catatan semacam itu tidak jelas, tetapi memiliki satu keuntungan penting.  Semua gerakan dijelaskan dengan cara yang seragam dan deskripsi ini tidak mengandung tambahan apa pun (nama deskripsi gerakan, tentu saja, dapat dibuat lebih “deskriptif”).  Dalam deskripsi castling, seseorang berhasil menyingkirkan perubahan atribut dan deskripsi rook move (deskripsi ini tidak lagi tergantung pada detail implementasi dari move).  Kegunaan yang lebih jelas dari catatan semacam itu ada dalam kasus permainan Go: <br><br><pre> <code class="perl hljs"><span class="hljs-number"><span class="hljs-number">1</span></span>. G19 drop-to-empty White Stone</code> </pre> <br>  Dan itu dia!  Jika batu lawan diambil sesuai dengan aturan permainan, tidak perlu mendaftar semuanya dalam deskripsi langkah.  Cukup untuk menunjukkan ruang awal dan akhir perpindahan (mungkin dengan tanda untuk mengambil), nama langkah pelaksana dan garis parameter yang diteruskan ke sana.  Tentu saja, untuk melakukan pemindahan sesuai dengan deskripsi ini, untuk decoding, perlu mengakses modul pemindahan pemindahan, tetapi ZoG melakukannya! <br><br>  Kemungkinan lain, yang harus didukung, muncul dalam fungsi gerakan "parsial".  Berikut adalah contoh dari " <a href="https://glukkazan.github.io/checkers/russian-checkers.htm" rel="nofollow">catur Rusia</a> ": <br><br><pre> <code class="perl hljs"><span class="hljs-number"><span class="hljs-number">1</span></span>. Checker g3 - f4 <span class="hljs-number"><span class="hljs-number">1</span></span>. Checker f6 - g5 <span class="hljs-number"><span class="hljs-number">2</span></span>. Checker e3 - d4 <span class="hljs-number"><span class="hljs-number">2</span></span>. partial <span class="hljs-number"><span class="hljs-number">2</span></span> Checker g5 - e3 = XChecker on f4 <span class="hljs-number"><span class="hljs-number">2</span></span>. Checker e3 - c5 = XChecker on d4 <span class="hljs-keyword"><span class="hljs-keyword">x</span></span> d4 <span class="hljs-keyword"><span class="hljs-keyword">x</span></span> f4</code> </pre><br>  Di sini orang kulit hitam, pada langkah kedua mereka, ambil dua bagian pada d4 dan f4.  "Transformasi" awal dari karya-karya ini ke XChecker adalah fitur dari implementasi ini dan berfungsi untuk mencegah pengambilan kembali potongan-potongan "yang dikalahkan" pada langkah yang sama.  Ungkapan "parsial 2" menggambarkan awal dari kursus "komposit", yang terdiri dari dua gerakan "parsial".  Bentuk uraian ini tidak nyaman, karena pada saat generasi gerakan pertama, panjang urutan gerakan "parsial" mungkin tidak diketahui.  Begini cara uraian ini dalam format baru: <br><br><pre> <code class="perl hljs"><span class="hljs-number"><span class="hljs-number">1</span></span>. g3 - f4 checker-<span class="hljs-keyword"><span class="hljs-keyword">shift</span></span> nw <span class="hljs-number"><span class="hljs-number">1</span></span>. f6 - g5 checker-<span class="hljs-keyword"><span class="hljs-keyword">shift</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ne</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>. e3 - d4 checker-<span class="hljs-keyword"><span class="hljs-keyword">shift</span></span> nw <span class="hljs-number"><span class="hljs-number">2</span></span>. + g5 - e3 checker-jump nw <span class="hljs-number"><span class="hljs-number">2</span></span>. + e3 - c5 checker-jump sw <span class="hljs-number"><span class="hljs-number">2</span></span>. +</code> </pre><br>  Detail implementasi terkait dengan "transformasi" karya tidak relevan.  Penangkapan potongan juga tidak ditentukan, seperti pada catur, penangkapan terjadi sebagai "efek samping" dari gerakan potongan dan tidak sesuai dengan "prinsip catur." Kemajuan sebagian akan dikodekan dengan simbol "+" di awal. dari garis.  Satu-satunya "+" menunjukkan penyelesaian dari suatu "langkah komposit" (pada kenyataannya, ini adalah langkah "parsial" biasa, berisi langkah yang hilang, string kosong). <br><br>  Jadi, dengan menggunakan aturan yang disebutkan untuk implementasi gerakan, seseorang telah berhasil membuat notasi universal, sepenuhnya memenuhi persyaratan kami.  Tentu saja, itu tidak ada hubungannya dengan catur standar atau dengan notasi lainnya, tetapi kebetulan notasi konvensional untuk catur, catur dan permainan lainnya juga tidak ada hubungannya dengan satu sama lain.  Modul visualisasi selalu dapat mengubah catatan pindah ke bentuk yang lebih akrab diterima untuk game tertentu.  Konversi juga dapat menjadi beberapa bentuk universal, seperti <a href="https://en.wikipedia.org/wiki/Smart_Game_Format" rel="nofollow">SGF (Smart Game Format)</a> . <br><br><h2>  Siklus hidup game </h2><br>  Selain informasi tentang menempatkan potongan-potongan di papan tulis, urutan belokan adalah bagian penting dari status permainan, variabel dalam proses permainan.  Dalam kasus yang paling sederhana (dan paling umum), untuk menyimpan informasi ini satu bit sudah cukup, tetapi ZoG menyediakan beberapa peluang lagi untuk mengimplementasikan kasus yang lebih kompleks.  Di sini adalah bagaimana deskripsi urutan bergerak bisa mencari permainan <a href="http://www.iggamecenter.com/info/en/splut.html" rel="nofollow">Splut!</a>  : <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">players</span></span> South West North East) (<span class="hljs-name"><span class="hljs-name">turn-order</span></span> South West West repeat North North North East East East South South South West West West )</code> </pre> <br>  Dalam permainan ini, setiap pemain membuat tiga gerakan pada satu waktu, tetapi jika Anda memberi pemain pertama kesempatan untuk membuat tiga gerakan dari posisi awal, ia akan dapat menghancurkan salah satu potongan lawan, yang akan memberinya keuntungan yang signifikan.  Untuk alasan ini, pemain pertama harus membuat hanya satu gerakan (ini memberikan kesempatan untuk bersiap menyerang pemain lawan, tetapi tidak menyerangnya), yang kedua - dua gerakan (ini juga tidak cukup untuk menyerang pemain lawan), setelah dimana setiap pemain selalu membuat tiga gerakan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/f78/6b5/862/f786b5862708474184d805653c2fe9fc.jpg"></div><br>  Label repeat menunjukkan awal dari urutan gerakan berulang yang berulang.  Jika tidak muncul, seluruh deskripsi diulangi secara berulang.  ZoG tidak memungkinkan penggunaan label berulang lebih dari satu kali.  Fitur penting lainnya adalah spesifikasi urutan belokan.  Begini cara uraian urutan putaran permainan di mana setiap pemain melakukan dua putaran (langkah pertama - gerakan bergerak, gerakan kedua - menangkap potongan lawan) terlihat: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">players</span></span> White Black) (<span class="hljs-name"><span class="hljs-name">turn-order</span></span> (<span class="hljs-name"><span class="hljs-name">White</span></span> normal-move) (<span class="hljs-name"><span class="hljs-name">White</span></span> capture-move) (<span class="hljs-name"><span class="hljs-name">Black</span></span> normal-move) (<span class="hljs-name"><span class="hljs-name">Black</span></span> capture-move) )</code> </pre> <br>  Ada satu lagi kemampuan yang terkait dengan deskripsi memindahkan potongan orang lain, tetapi sangat tidak nyaman untuk digunakan.  Masalahnya adalah deskripsi seperti itu tidak memiliki alternatif.  Jika deskripsi menyatakan bahwa langkah itu harus dilakukan oleh bagian musuh, pemain harus melakukan langkah ini!  Dalam ZoG, tidak mungkin untuk menggambarkan pilihan untuk memindahkan miliknya sendiri atau milik orang lain.  Jika kemampuan seperti itu diperlukan dalam permainan (seperti dalam " <a href="https://glukkazan.github.io/checkers/stavropol-checkers.htm" rel="nofollow">Stavropol Checkers</a> "), perlu untuk membuat semua bagian netral (menciptakan untuk tujuan ini pemain yang tidak berpartisipasi dalam permainan) dan menentukan kesempatan bagi semua pemain untuk peluang untuk memindahkan bagian yang netral.  Saya telah mengatakan di atas bahwa jauh lebih mudah secara default untuk memungkinkan semua pemain kemampuan untuk memindahkan setiap bagian (milik mereka sendiri maupun milik lawan mereka) dengan menambahkan pemeriksaan yang diperlukan dalam algoritme pembangkit bergerak. <br><br>  Seperti yang Anda lihat, kisaran opsi yang disediakan oleh ZoG untuk deskripsi urutan belokan sangat terbatas.  Aksioma juga gagal menambahkan fitur baru, karena (biasanya) berjalan di atas ZoG.  Ludi, dalam hal ini, bahkan lebih miskin.  Untuk memaksimalkan penyatuan aturan permainan (diperlukan untuk kemungkinan menggunakan algoritma generik), dalam proyek ini, semua kemampuan deskriptif sengaja disederhanakan, yang telah menyebabkan penghapusan seluruh lapisan permainan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/52b/c1e/8a3/52bc1e8a3f374c8386884241a1571a18.jpg"></div><br>  " <a href="https://en.wikipedia.org/wiki/Bao_(game)" rel="nofollow">Bao Swahili</a> " adalah contoh yang baik dari sebuah game dengan siklus hidup yang kompleks. Dalam game ini, ada dua fase dengan aturan untuk eksekusi bergerak yang berbeda secara signifikan. Di awal permainan, bagian dari batu adalah "di tangan" "Dari masing-masing pemain. Sementara masih ada batu" di tangan ", batu dimasukkan ke dalam sumur, satu batu pada satu waktu. Ketika batu" di tangan "habis, fase kedua permainan dimulai, dengan distribusi dimasukkan Orang tidak dapat mengatakan bahwa permainan ini tidak dapat dijelaskan dalam ZRF (bahasa deskripsi ZoG), tetapi karena keterbatasan ZoG, implementasi ini akan sangat membingungkan (yang tentunya tidak terbaik untuk kualitas pekerjaan AI). Mari kita lihat bagaimana deskripsi game seperti itu akan terlihat di "dunia ideal": <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">players</span></span> South North) (<span class="hljs-name"><span class="hljs-name">turn-order</span></span> (<span class="hljs-name"><span class="hljs-name">turn-order</span></span> (<span class="hljs-name"><span class="hljs-name">South</span></span> pi-move) (<span class="hljs-name"><span class="hljs-name">North</span></span> pi-move) ) (<span class="hljs-name"><span class="hljs-name">label</span></span> phase-ii) (<span class="hljs-name"><span class="hljs-name">turn-order</span></span> (<span class="hljs-name"><span class="hljs-name">South</span></span> p-ii-move) (<span class="hljs-name"><span class="hljs-name">North</span></span> p-ii-move) ) )</code> </pre> <br>  Di sini, setiap daftar turn-order menentukan urutan gerakan yang berulang (membedakan dirinya dengan mode eksekusi bergerak).  Label kata kunci mendefinisikan label yang dapat dibuat transisi selama pembuatan langkah terbaru.  Anda mungkin memperhatikan bahwa di sini kita melanjutkan dari asumsi implisit bahwa transisi seperti itu selalu terjadi setelah perpindahan pemain kedua (jika tidak maka akan melanggar urutan gerakan).  Bagaimana cara melakukan transisi ke fase berikutnya pada waktu yang sewenang-wenang? <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">players</span></span> South North) (<span class="hljs-name"><span class="hljs-name">turn-order</span></span> (<span class="hljs-name"><span class="hljs-name">turn-order</span></span> (<span class="hljs-name"><span class="hljs-name">South</span></span> pi-move) (<span class="hljs-name"><span class="hljs-name">North</span></span> pi-move) ) (<span class="hljs-name"><span class="hljs-name">turn-order</span></span> (<span class="hljs-name"><span class="hljs-name">labels</span></span> - phase-ii) (<span class="hljs-name"><span class="hljs-name">South</span></span> p-ii-move) (<span class="hljs-name"><span class="hljs-name">labels</span></span> phase-ii -) (<span class="hljs-name"><span class="hljs-name">North</span></span> p-ii-move) ) )</code> </pre> <br>  Di sini, label dilakukan dalam badan loop dan terdiri dari dua nama.  Nama label dalam daftar label muncul dalam urutan transfer pemain dalam daftar pemain.  Nama yang digunakan untuk transisi ditentukan oleh pemain mana yang melakukan langkah terakhir.  Jika ini adalah Utara, itu akan beralih ke label pertama, jika tidak, ke yang kedua.  Jika salah satu nama dalam label tidak akan digunakan, posisi yang sesuai dapat diisi dengan tanda hubung. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/060/833/75d/06083375de8a4b97b7cffb138b3d5b9f.jpg"></div><br>  Aspek penting dalam pengelolaan gerakan bergantian, adalah kemampuan untuk melakukan putaran berulang.  Dalam gim <a href="https://en.wikipedia.org/wiki/Tables_(board_game)" rel="nofollow">keluarga Tables</a> , seperti <a href="https://en.wikipedia.org/wiki/Tables_(board_game)" rel="nofollow">Nard</a> , <a href="https://glukkazan.github.io/races/backgammon.htm" rel="nofollow">Backgammon</a> , atau <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi%3Fdo%3Dshow%3Bid%3D2262" rel="nofollow">Ur</a> , misalnya, kemampuan untuk melakukan belokan berulang adalah elemen penting dari taktik gim.  Di ZoG kita dapat menggunakan passing untuk meniru fitur ini, tetapi pendekatan ini secara signifikan menyulitkan deskripsi permainan (terutama dengan lebih banyak pemain).  Akan jauh lebih logis untuk menggunakan label untuk mengulangi belokan: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">players</span></span> South North) (<span class="hljs-name"><span class="hljs-name">turn-order</span></span> (<span class="hljs-name"><span class="hljs-name">label</span></span> repeat) South (<span class="hljs-name"><span class="hljs-name">label</span></span> repeat) North )</code> </pre> <br>  Permainan setelah melompat ke label repeat, pemain akan kembali memainkan gilirannya (label yang paling dekat dengan posisi saat ini dalam daftar putaran akan berlaku).  Saya suka pendekatan <a href="https://en.wikipedia.org/wiki/Perl" rel="nofollow">Perl</a> dalam definisi implisitnya.  Pembuatan struktur kontrol yang tersirat dapat menyederhanakan deskripsi game secara signifikan.  Sejauh gerakan berulang dapat digunakan dalam banyak permainan, label ulangi, mengantisipasi kemungkinan pengulangan setiap belokan dapat tersirat: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">players</span></span> South North) (<span class="hljs-name"><span class="hljs-name">turn-order</span></span> South North )</code> </pre> <br>  Selain itu, karena urutan belokan sepenuhnya konsisten dengan urutan tertulis dari pemain dalam susunan pemain, Anda dapat secara otomatis menghasilkan seluruh frase urutan belokan: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">players</span></span> South North)</code> </pre> <br>  Semakin mudah deskripsinya untuk menulis, semakin baik. <br><br><h2>  Invarian yang mudah pecah </h2><br>  Hal utama yang saya tidak suka di ZoG dapat diekspresikan dengan satu kata - skakmat.  Pada pandangan pertama, itu hanya suatu kondisi (sangat umum dalam permainan <a href="https://en.wikipedia.org/wiki/Checkmate" rel="nofollow">keluarga catur</a> ) yang menghubungkan akhir permainan dengan pembentukan situasi pasangan.  Sayangnya, pada pemeriksaan lebih dekat, kesederhanaan menunjukkan dirinya menipu.  Penggunaan kata kunci ini berarti tidak hanya kinerja, setelah setiap gerakan, dari cek untuk penyelesaian permainan, tetapi juga membebani pemain "perilaku" tertentu. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/OR74gUlfQNY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Dari <a href="https://en.wikipedia.org/wiki/Shogi" rel="nofollow">Shogi yang</a> biasa, permainan ini hanya berbeda dalam jumlah pemain.  Sayangnya, perbedaan ini cukup untuk membuat tugas menentukan skakmat (dan semua yang terkait dengan kata "ajaib") salah.  Memverifikasi sedang dalam pemeriksaan dilakukan hanya terkait dengan salah satu pemain.  Akibatnya, raja bisa datang untuk diserang, dan dimakan [oleh kombinasi giliran lawan bahkan ketika tidak ditinggalkan di "periksa"]!  Bahwa ini tidak optimal akan tercermin dalam karya AI. <br><br>  Jika masalah ini tampaknya tidak signifikan, perlu diingat koalisi biasanya dibentuk dalam permainan empat pemain "berpasangan dengan pasangan".  Dalam kasus pembentukan koalisi, kita harus mempertimbangkan bahwa potongan-potongan yang ramah kepada raja tidak mengancamnya!  Jadi, misalnya, dua Raja yang bersahabat mungkin tinggal di ruang tetangga papan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/b00/77d/949/b0077d949f2d472da9e12d64099d924d.jpg"></div><br>  Menjadi lebih rumit dari sebelumnya jika seorang pemain memiliki beberapa raja.  Dalam " <a href="http://history.chess.free.fr/tamerlane-full.htm" rel="nofollow">catur Tamerlane</a> ", pion kerajaan berubah menjadi pangeran (sebenarnya, raja kedua).  Jika ini terjadi, Anda hanya bisa menang dengan menangkap raja pertama (salah satu dari keduanya), dan mengawinkan yang kedua.  Dalam game ini, Anda bahkan bisa mendapatkan raja ketiga, menghabiskan dua kali lipat untuk transformasi "pion pion"!  Kemampuan ekspresif "skakmat" tidak cukup untuk menggambarkan situasi ini secara memadai. <br><br>  Kesulitan lain mungkin adalah proses memberi pasangan.  Jadi dalam catur Mongolia ( <a href="https://en.wikipedia.org/wiki/Shatar" rel="nofollow">Shatar</a> ), hasil percobaan pasangan tergantung pada urutan di mana potongan-potongan mengeksekusi "cek" berurutan.  Hasilnya bisa terbukti menang atau seri (seperti jodoh oleh pion), atau bahkan kalah (jodoh dilarang, tetapi Anda bisa memberi cek).  Dalam hal ini, yang kurang eksotis adalah Shogi Jepang.  Dalam game ini, dilarang memberi jodoh dengan pion yang jatuh, tetapi Anda bisa memberi cek dengan pion yang dijatuhkan dan memberikan jodoh dengan pion yang dipindahkan. <br><br><div class="spoiler">  <b class="spoiler_title">Catatan</b> <div class="spoiler_text">  Ada satu hal penting yang perlu disebutkan.  Dalam beberapa permainan, seperti Rhythmomagic, ada beberapa cara berbeda untuk mengakhiri permainan.  Cara paling jelas untuk menang, yang melibatkan penghancuran kepingan lawan, juga yang paling tidak disukai.  Untuk kemenangan yang lebih signifikan, seseorang harus mengatur bagiannya di wilayah musuh dalam pola tertentu. <br><br>  Seseorang harus membedakan antara jenis-jenis kemenangan (dan kekalahan dan seri) pada tingkat deskripsi permainan, karena jenis akhir permainan mungkin penting bagi pemain.  Selain itu, harus dimungkinkan untuk menetapkan prioritas numerik pada berbagai akhir pertandingan.  Setelah memenuhi beberapa persyaratan penyelesaian secara simultan, yang memiliki prioritas tertinggi harus diperhitungkan. <br></div></div><br>  Jelas, seseorang harus memisahkan logika verifikasi akhir pertandingan dari tes karena raja telah jatuh ke dalam pemeriksaan, yang merupakan <a href="https://en.wikipedia.org/wiki/Invariant_(mathematics)" rel="nofollow">aturan</a> yang tidak <a href="https://en.wikipedia.org/wiki/Invariant_(mathematics)" rel="nofollow">berubah</a> yang diperiksa setelah setiap belokan.  Pelanggaran aturan membuatnya tidak mungkin untuk melakukan langkah tersebut (langkah tersebut dihapus dari daftar langkah yang tersedia).  Jadi tes (disederhanakan) untuk seorang raja yang sedang diperiksa mungkin terlihat seperti ini untuk "catur Tamerlane": <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">verify</span></span> (<span class="hljs-name"><span class="hljs-name">or</span></span> (<span class="hljs-name"><span class="hljs-name">&gt;</span></span> (<span class="hljs-name"><span class="hljs-name">count</span></span> (<span class="hljs-name"><span class="hljs-name">pieces</span></span> my? (<span class="hljs-name"><span class="hljs-name">is-piece</span></span>? King))) <span class="hljs-number"><span class="hljs-number">1</span></span>) (<span class="hljs-name"><span class="hljs-name">=</span></span> (<span class="hljs-name"><span class="hljs-name">count</span></span> (<span class="hljs-name"><span class="hljs-name">pieces</span></span> my? (<span class="hljs-name"><span class="hljs-name">is-piece</span></span>? King) is-attacked?)) <span class="hljs-number"><span class="hljs-number">0</span></span>) ) )</code> </pre> <br>  Penting untuk dipahami bahwa tes ini harus dilakukan hanya untuk raja sendiri (saya menggunakan predikat saya ?, karena teman predikat ?, dengan dukungan untuk koalisi, akan puas tidak hanya untuk bagian sendiri, tetapi juga untuk semua pemain yang ramah).  Dapat diterima (dan diinginkan, [jika ada beberapa raja ramah]) adalah situasi di mana raja musuh jatuh di bawah kendali, setelah pindah, tetapi oleh raja sendiri.  Situasi ini seharusnya tidak mungkin [kecuali ada beberapa raja yang ramah]!  Setelah memberikan dukungan untuk memeriksa aturan seperti itu, memeriksa penyelesaian game dengan skakmat menjadi sepele.  Jika tidak ada gerakan yang mungkin dan raja [satu-satunya] berada dalam kendali, permainan berakhir [jika raja itu milik pemain bertahan terakhir dari koalisi bertahan kedua terakhir]: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">loss-condition</span></span> (<span class="hljs-name"><span class="hljs-name">and</span></span> (<span class="hljs-name"><span class="hljs-name">=</span></span> (<span class="hljs-name"><span class="hljs-name">count</span></span> moves) <span class="hljs-number"><span class="hljs-number">0</span></span>) (<span class="hljs-name"><span class="hljs-name">=</span></span> (<span class="hljs-name"><span class="hljs-name">count</span></span> (<span class="hljs-name"><span class="hljs-name">pieces</span></span> my? (<span class="hljs-name"><span class="hljs-name">is-piece</span></span>? King)) <span class="hljs-number"><span class="hljs-number">1</span></span>) (<span class="hljs-name"><span class="hljs-name">&gt;</span></span> (<span class="hljs-name"><span class="hljs-name">count</span></span> (<span class="hljs-name"><span class="hljs-name">pieces</span></span> my? (<span class="hljs-name"><span class="hljs-name">is-piece</span></span>? King) is-attacked?)) <span class="hljs-number"><span class="hljs-number">0</span></span>) ) )</code> </pre> <br>  Kemampuan untuk menentukan invarian akan berguna di gim lain, seperti di <a href="https://glukkazan.github.io/checkers/international-checkers.htm" rel="nofollow">gim</a> .  Kesulitan terbesar dalam implementasi permainan keluarga ini, terkait dengan penerapan "aturan mayoritas".  Di hampir semua draf gim, menangkap adalah wajib.  Juga, di sebagian besar permainan keluarga ini, ada penyelesaian karakteristik "tangkapan rantai" dalam satu putaran.  Pemeriksa, setelah ditangkap, terus mengambil potongan lainnya, jika mungkin.  Dalam sebagian besar permainan, pemain diharuskan untuk melakukan penangkapan berantai sampai akhir, tetapi ada pengecualian untuk aturan ini, misalnya, <a href="https://glukkazan.github.io/checkers-like/fanorona-normal.htm" rel="nofollow">Fanorona</a> . <br><br><div style="text-align:center;"> <a href="https://glukkazan.github.io/checkers-like/fanorona-normal.htm" rel="nofollow"><img src="https://habrastorage.org/files/a4a/f83/3d8/a4af833d85d445b5ba17aca59056b741.jpg"></a> </div><br>  Menggunakan mekanisme gerakan parsial, menerapkan "tangkapan rantai" cukup sederhana.  Kesulitan muncul ketika, selain itu, seseorang memaksakan suatu kondisi di mana, dari semua opsi yang mungkin, seseorang harus memilih rantai di mana jumlah maksimum potongan ditangkap.  Dalam ZoG, logika ini harus diimplementasikan dari awal di tingkat "hardcoding": <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">option</span></span> <span class="hljs-string"><span class="hljs-string">"maximal captures"</span></span> true)</code> </pre> <br>  Pengaturan ini cocok untuk " <a href="https://glukkazan.github.io/checkers/international-checkers.htm" rel="nofollow">catur internasional</a> ", tetapi dalam " <a href="https://glukkazan.github.io/checkers/italian-checkers.htm" rel="nofollow">catur Italia</a> " aturan mayoritas dirumuskan secara berbeda.  Dalam versi gim ini, jika ada beberapa opsi untuk jumlah tangkapan yang sama, Anda harus memilih opsi yang menangkap jumlah raja yang lebih banyak yang diubah (raja).  Pengembang ZoG telah menyediakan ini.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Anda memasukkan pengaturan berikut: </font></font><br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">option</span></span> <span class="hljs-string"><span class="hljs-string">"maximal captures"</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam pengaturan ini, seseorang tidak hanya menghitung jumlah potongan yang diambil, tetapi juga tipenya. </font><font style="vertical-align: inherit;">Sayangnya, tidak semuanya bisa diramalkan. </font><font style="vertical-align: inherit;">Inilah cara "aturan mayoritas" dirumuskan dalam "catur Prancis kuno":</font></font><br><br><blockquote> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika dengan serangkaian tangkapan dimungkinkan untuk menangkap jumlah biji yang sama dengan orang sederhana atau dengan raja, pemain harus menggunakan raja. </font><font style="vertical-align: inherit;">Namun, jika jumlah biji sama dalam kedua kasus, tetapi dalam satu ada raja musuh (atau ada lebih banyak), pemain harus memilih opsi ini, bahkan jika penangkapan kemudian dilakukan dengan menggunakan pemeriksa sederhana, dan tidak menggunakan raja.</font></font></i> </blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tentu saja, pada saat ini, hampir tidak ada yang memainkan versi checker ini, tetapi keberadaannya dengan jelas menunjukkan kekurangan implementasi “hardcoded”. </font><font style="vertical-align: inherit;">Menggunakan mekanisme invarian memungkinkan untuk semua opsi yang memungkinkan untuk "aturan mayoritas" secara universal. </font><font style="vertical-align: inherit;">Untuk " </font></font><a href="http://www.checkerschest.com/checkers-games/french-checkers.htm" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">catur Prancis lama</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> " implementasi akan sebagai berikut:</font></font><br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">verify</span></span> (<span class="hljs-name"><span class="hljs-name">&gt;=</span></span> capturing-count max-capturing-count) ) (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">&gt;</span></span> capturing-count max-capturing-count) (<span class="hljs-name"><span class="hljs-name">let</span></span> max-capturing-count capturing-count) (<span class="hljs-name"><span class="hljs-name">let</span></span> max-capturing-sum capturing-sum) (<span class="hljs-name"><span class="hljs-name">let</span></span> max-attacking-value attacking-value) ) (<span class="hljs-name"><span class="hljs-name">verify</span></span> (<span class="hljs-name"><span class="hljs-name">&gt;=</span></span> capturing-sum max-capturing-sum) ) (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">&gt;</span></span> capturing-sum max-capturing-sum) (<span class="hljs-name"><span class="hljs-name">let</span></span> max-capturing-sum capturing-sum) (<span class="hljs-name"><span class="hljs-name">let</span></span> max-attacking-value attacking-value) ) (<span class="hljs-name"><span class="hljs-name">verify</span></span> (<span class="hljs-name"><span class="hljs-name">&gt;=</span></span> attacking-value max-attacking-value) ) (<span class="hljs-name"><span class="hljs-name">let</span></span> max-attacking-value attacking-value)</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Di sini, kami mengasumsikan bahwa aturan untuk pembuatan tangkapan dengan benar mengisi variabel lokal [berikut]: </font></font><br><br><ul><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">capturing-count</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - total potongan yang ditangkap</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">capturing-sum</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - jumlah raja yang ditangkap</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">attacking-value</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - nilai penangkapan potongan</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terkait dengan masing-masing variabel ini adalah akumulator nilai, disimpan dalam variabel dengan awalan maks. Tiga cek dieksekusi secara seri. Pelanggaran terhadap salah satu kondisi verifikasi segera mengganggu pembuatan opsi belokan berikutnya (tangkapan tidak disimpan dalam daftar kemungkinan belokan). Karena pemeriksaan yang dilakukan terkait dengan nilai variabel, itu tidak cukup [untuk menguji hanya opsi penangkapan baru saat ini]. Setiap tes menghasilkan "aturan yang dapat ditekuk" yang terkait dengan tangkapan yang dihasilkan [yang dapat merevisi nilai maksimum terakumulasi]. Setelah setiap perubahan dalam akumulator apa pun, semua aturan terkait harus diperiksa lagi [untuk setiap opsi dalam daftar]. Jika ada kondisi yang dilanggar untuk opsi yang dibuat sebelumnya, opsi itu harus dihapus dari daftar opsi belok yang mungkin.</font></font><br><br><h2>  Kesimpulan </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini adalah terjemahan dari artikel saya tahun 2014 tahun. </font><font style="vertical-align: inherit;">Sejak itu, saya telah memikirkan kembali banyak hal dan </font></font><a href="https://glukkazan.github.io/" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">proyek Dagaz</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> telah menjadi kenyataan, tetapi saya tidak mengubah apa pun dalam teks. </font><font style="vertical-align: inherit;">Artikel ini diterjemahkan oleh teman saya </font></font><a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi%3Fsearchauthor%3D505" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Howard McCay</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan saya berterima kasih padanya untuk pekerjaan yang dilakukan.</font></font><br></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id481868/">https://habr.com/ru/post/id481868/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id481854/index.html">Menguji gagasan melalui prototipe dasbor</a></li>
<li><a href="../id481858/index.html">Ulang tahun di Kalender Google dengan usia</a></li>
<li><a href="../id481860/index.html">Apa yang harus dilakukan TI pada tahun 2020?</a></li>
<li><a href="../id481862/index.html">Sistem Pembelajaran Mesin Tertanam Nvidia Jetson</a></li>
<li><a href="../id481866/index.html">DBA: ketika VACUUM lewat - kami membersihkan tabel secara manual</a></li>
<li><a href="../id481874/index.html">Metrik - indikator kesehatan proyek</a></li>
<li><a href="../id481880/index.html">Fisika untuk penembak PvP seluler dan bagaimana kami berteman dengan ECS</a></li>
<li><a href="../id481882/index.html">4. Fortinet Memulai v6.0. Kebijakan firewall</a></li>
<li><a href="../id481884/index.html">Persimpangan jalan senior: ke mana harus pergi berikutnya?</a></li>
<li><a href="../id481886/index.html">Cara cepat membuat jurnal kehadiran</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>