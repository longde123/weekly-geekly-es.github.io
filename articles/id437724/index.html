<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äçüëß‚Äçüë¶ ‚òÇÔ∏è üë´ OpenSceneGraph: Animasi prosedural dari atribut geometri dan status üè≥Ô∏è üÜô ‚ôëÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pendahuluan 
 Berbicara tentang teknik pemrograman khusus untuk OSG , terakhir kali kami berbicara tentang mekanisme Callback dan implementasinya di m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>OpenSceneGraph: Animasi prosedural dari atribut geometri dan status</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437724/"><img src="https://habrastorage.org/webt/py/ks/3w/pyks3wlvjf_zfef-sqocutbnimk.jpeg" alt="gambar"><br><h1>  Pendahuluan </h1><br>  Berbicara tentang teknik pemrograman khusus untuk OSG <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">, terakhir kali</a> kami berbicara tentang mekanisme Callback dan implementasinya di mesin.  Sudah saatnya untuk melihat kemungkinan yang disediakan mekanisme ini untuk mengelola konten adegan tiga dimensi. <br><br>  Jika kita berbicara tentang animasi objek, OSG menyediakan pengembang dengan dua opsi untuk implementasinya: <br><br><ol><li>  Animasi prosedural diimplementasikan secara terprogram melalui transformasi objek dan atributnya </li><li>  Mengekspor animasi dari editor 3D dan mengelolanya dari kode aplikasi </li></ol><br>  Untuk memulai, pertimbangkan kemungkinan pertama, sebagai yang paling jelas.  Kami pasti akan membicarakan yang kedua nanti. <br><a name="habracut"></a><br><h1>  1. Animasi morphing prosedural </h1><br>  Saat melintasi grafik adegan, OSG mentransfer data ke pipa OpenGL, yang berjalan di utas terpisah.  Utas ini harus disinkronkan dengan utas pemrosesan lainnya di setiap bingkai.  Kegagalan untuk melakukannya dapat menyebabkan metode frame () selesai sebelum memproses data geometri.  Ini akan menyebabkan perilaku dan crash program tidak dapat diprediksi.  OSG menawarkan solusi untuk masalah ini dalam bentuk metode setDataVariance () dari kelas osg :: Object, yang merupakan basis untuk semua objek pemandangan.  Anda dapat mengatur tiga mode pemrosesan untuk objek <br><br><ol><li>  UNSPECIFIED (secara default) - OSG secara independen menentukan urutan pemrosesan objek. <br></li><li>  STATIC - objek tidak dapat diubah dan urutan pemrosesan tidak penting.  Mempercepat rendering secara signifikan. <br></li><li>  DINAMIK - objek harus diproses sebelum mulai rendering. <br></li></ol><br>  Pengaturan ini dapat diatur kapan saja dengan menelepon <br><br><pre><code class="cpp hljs">node-&gt;setDataVariance( osg::Object::DYNAMIC );</code> </pre> <br>  Praktik yang diterima secara umum adalah untuk memodifikasi geometri "on the fly", yaitu, mengubah koordinat simpul, normals warna, dan tekstur secara dinamis di setiap frame, memperoleh geometri yang bisa berubah.  Teknik ini disebut animasi morphing.  Dalam hal ini, urutan pemrosesan geometri sangat menentukan - semua perubahannya harus dihitung ulang sebelum menggambar dimulai.  Untuk menggambarkan trik ini, kita sedikit memodifikasi contoh kotak berwarna, memaksa salah satu simpulnya berputar di sekitar sumbu X. <br><br><div class="spoiler">  <b class="spoiler_title">Contoh animquad</b> <div class="spoiler_text">  <strong>main.h</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/Geometry&gt; #include &lt;osg/Geode&gt; #include &lt;osgViewer/Viewer&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ osg::Geometry *createQuad() { osg::ref_ptr&lt;osg::Vec3Array&gt; vertices = new osg::Vec3Array; vertices-&gt;push_back( osg::Vec3(0.0f, 0.0f, 0.0f) ); vertices-&gt;push_back( osg::Vec3(1.0f, 0.0f, 0.0f) ); vertices-&gt;push_back( osg::Vec3(1.0f, 0.0f, 1.0f) ); vertices-&gt;push_back( osg::Vec3(0.0f, 0.0f, 1.0f) ); osg::ref_ptr&lt;osg::Vec3Array&gt; normals = new osg::Vec3Array; normals-&gt;push_back( osg::Vec3(0.0f, -1.0f, 0.0f) ); osg::ref_ptr&lt;osg::Vec4Array&gt; colors = new osg::Vec4Array; colors-&gt;push_back( osg::Vec4(1.0f, 0.0f, 0.0f, 1.0f) ); colors-&gt;push_back( osg::Vec4(0.0f, 1.0f, 0.0f, 1.0f) ); colors-&gt;push_back( osg::Vec4(0.0f, 0.0f, 1.0f, 1.0f) ); colors-&gt;push_back( osg::Vec4(1.0f, 1.0f, 1.0f, 1.0f) ); osg::ref_ptr&lt;osg::Geometry&gt; quad = new osg::Geometry; quad-&gt;setVertexArray(vertices.get()); quad-&gt;setNormalArray(normals.get()); quad-&gt;setNormalBinding(osg::Geometry::BIND_OVERALL); quad-&gt;setColorArray(colors.get()); quad-&gt;setColorBinding(osg::Geometry::BIND_PER_VERTEX); quad-&gt;addPrimitiveSet(new osg::DrawArrays(GL_QUADS, 0, 4)); return quad.release(); } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ class DynamicQuadCallback : public osg::Drawable::UpdateCallback { public: virtual void update(osg::NodeVisitor *, osg::Drawable *drawable); }; //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ void DynamicQuadCallback::update(osg::NodeVisitor *, osg::Drawable *drawable) { osg::Geometry *quad = static_cast&lt;osg::Geometry *&gt;(drawable); if (!quad) return; osg::Vec3Array *vertices = static_cast&lt;osg::Vec3Array *&gt;(quad-&gt;getVertexArray()); if (!vertices) return; osg::Quat quat(osg::PI * 0.01, osg::X_AXIS); vertices-&gt;back() = quat * vertices-&gt;back(); quad-&gt;dirtyDisplayList(); quad-&gt;dirtyBound(); } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::Geometry *quad = createQuad(); quad-&gt;setDataVariance(osg::Object::DYNAMIC); quad-&gt;setUpdateCallback(new DynamicQuadCallback); osg::ref_ptr&lt;osg::Geode&gt; root = new osg::Geode; root-&gt;addDrawable(quad); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  Kami akan membuat kotak dalam fungsi terpisah <br><br><pre> <code class="cpp hljs">osg::<span class="hljs-function"><span class="hljs-function">Geometry *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createQuad</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ osg::ref_ptr&lt;osg::Vec3Array&gt; vertices = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Vec3Array; vertices-&gt;push_back( osg::Vec3(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>) ); vertices-&gt;push_back( osg::Vec3(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>) ); vertices-&gt;push_back( osg::Vec3(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>) ); vertices-&gt;push_back( osg::Vec3(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>) ); osg::ref_ptr&lt;osg::Vec3Array&gt; normals = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Vec3Array; normals-&gt;push_back( osg::Vec3(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">-1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>) ); osg::ref_ptr&lt;osg::Vec4Array&gt; colors = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Vec4Array; colors-&gt;push_back( osg::Vec4(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>) ); colors-&gt;push_back( osg::Vec4(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>) ); colors-&gt;push_back( osg::Vec4(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>) ); colors-&gt;push_back( osg::Vec4(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>) ); osg::ref_ptr&lt;osg::Geometry&gt; quad = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Geometry; quad-&gt;setVertexArray(vertices.get()); quad-&gt;setNormalArray(normals.get()); quad-&gt;setNormalBinding(osg::Geometry::BIND_OVERALL); quad-&gt;setColorArray(colors.get()); quad-&gt;setColorBinding(osg::Geometry::BIND_PER_VERTEX); quad-&gt;addPrimitiveSet(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::DrawArrays(GL_QUADS, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> quad.release(); }</code> </pre><br>  deskripsi yang, pada prinsipnya, tidak diperlukan, karena kami telah melakukan tindakan seperti itu berulang kali.  Untuk memodifikasi simpul dari persegi ini, kita menulis kelas DynamicQuadCallback, mewarisinya dari osg :: Drawable :: UpdateCallback <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DynamicQuadCallback</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> osg::Drawable::UpdateCallback { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(osg::NodeVisitor *, osg::Drawable *drawable)</span></span></span></span>; };</code> </pre><br>  mengganti metode pembaruan () di dalamnya <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> DynamicQuadCallback::update(osg::NodeVisitor *, osg::Drawable *drawable) { osg::Geometry *quad = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;osg::Geometry *&gt;(drawable); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!quad) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; osg::Vec3Array *vertices = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;osg::Vec3Array *&gt;(quad-&gt;getVertexArray()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!vertices) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; osg::<span class="hljs-function"><span class="hljs-function">Quat </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">quat</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(osg::PI * </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.01</span></span></span></span><span class="hljs-function"><span class="hljs-params">, osg::X_AXIS)</span></span></span></span>; vertices-&gt;back() = quat * vertices-&gt;back(); quad-&gt;dirtyDisplayList(); quad-&gt;dirtyBound(); }</code> </pre><br>  Di sini kita mendapatkan pointer ke objek geometri <br><br><pre> <code class="cpp hljs">osg::Geometry *quad = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;osg::Geometry *&gt;(drawable);</code> </pre><br>  kita membaca dari geometri daftar simpul (atau lebih tepatnya pointer ke sana) <br><br><pre> <code class="cpp hljs">osg::Vec3Array *vertices = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;osg::Vec3Array *&gt;(quad-&gt;getVertexArray());</code> </pre><br>  Untuk mendapatkan elemen terakhir (titik terakhir) dalam array, kelas osg :: Array menyediakan metode back ().  Untuk memutar simpul relatif terhadap sumbu X, kami memperkenalkan angka empat <br><br><pre> <code class="cpp hljs">osg::<span class="hljs-function"><span class="hljs-function">Quat </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">quat</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(osg::PI * </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.01</span></span></span></span><span class="hljs-function"><span class="hljs-params">, osg::X_AXIS)</span></span></span></span>;</code> </pre><br>  yaitu, kami menetapkan angka empat yang mengimplementasikan rotasi di sekitar sumbu X dengan sudut 0,01 * Pi.  Putar titik dengan mengalikan angka empat dengan vektor yang menentukan koordinat titik tersebut <br><br><pre> <code class="cpp hljs">vertices-&gt;back() = quat * vertices-&gt;back();</code> </pre><br>  Dua panggilan terakhir menceritakan daftar tampilan dan pararel dimensionalepiped untuk geometri yang dimodifikasi <br><br><pre> <code class="cpp hljs">quad-&gt;dirtyDisplayList(); quad-&gt;dirtyBound();</code> </pre><br>  Dalam tubuh fungsi utama (), kita membuat kotak, mengatur mode gambar dinamis untuknya, dan menambahkan panggilan balik memodifikasi geometri <br><br><pre> <code class="cpp hljs">osg::Geometry *quad = createQuad(); quad-&gt;setDataVariance(osg::Object::DYNAMIC); quad-&gt;setUpdateCallback(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DynamicQuadCallback);</code> </pre><br>  Saya akan meninggalkan sembarang membuat simpul root dan meluncurkan viewer, karena kami telah melakukan ini setidaknya dua puluh kali dengan cara yang berbeda.  Hasilnya, kami memiliki animasi morphing yang paling sederhana <br><br><img src="https://habrastorage.org/webt/rk/oy/rf/rkoyrfpjkx_kan0puqvyj1ocxps.gif"><br><br>  Sekarang cobalah untuk menghapus (mengomentari) panggilan setDataVariance ().  Mungkin kita tidak akan melihat kejahatan apa pun dalam kasus ini - secara default, OSG mencoba menentukan secara otomatis kapan akan memperbarui data geometri, mencoba menyinkronkan dengan rendering.  Kemudian cobalah mengubah mode dari DINAMIK ke STATIC dan akan terlihat bahwa gambar tidak membuat lancar, dengan tersentak terlihat, kesalahan dan peringatan seperti ini mengalir ke konsol <br><br><pre> <code class="plaintext hljs">Warning: detected OpenGL error 'invalid value' at after RenderBin::draw(..)</code> </pre><br>  Jika Anda tidak menjalankan metode dirtyDisplayList (), maka OpenGL akan mengabaikan semua perubahan pada geometri dan akan menggunakan daftar tampilan yang dibuat di awal untuk membuat kotak untuk rendering.  Hapus panggilan ini dan Anda akan melihat bahwa tidak ada animasi. <br><br>  Tanpa memanggil metode dirtyBound (), kotak pembatas tidak akan dihitung ulang dan OSG akan memangkas wajah yang tidak terlihat dengan salah. <br><br><h1>  2. Konsep interpolasi gerak </h1><br>  Misalkan kereta yang berangkat dari stasiun A ke stasiun B membutuhkan waktu 15 menit untuk bepergian.  Bagaimana kita bisa mensimulasikan situasi ini dengan mengubah posisi kereta di callback?  Cara termudah adalah dengan mengaitkan posisi stasiun A dengan waktu 0, dan stasiun B dengan 15 menit dan memindahkan kereta secara merata di antara waktu-waktu ini.  Pendekatan paling sederhana ini disebut interpolasi linier.  Dalam interpolasi linier, vektor yang menentukan posisi titik tengah dijelaskan oleh rumus <br><br><pre> <code class="plaintext hljs">p = (1 - t) * p0 + t * p1</code> </pre><br>  di mana p0 adalah titik awal;  p1 adalah titik akhir;  t adalah parameter yang bervariasi seragam dari 0 hingga 1. Namun, pergerakan kereta jauh lebih rumit: ia meninggalkan stasiun A, berakselerasi, kemudian bergerak dengan kecepatan konstan, dan kemudian melambat, berhenti di stasiun B. Proses semacam itu tidak lagi mampu menggambarkan interpolasi linier dan Itu terlihat tidak alami. <br><br>  OSG menyediakan pengembang dengan perpustakaan osgAnimation, yang berisi sejumlah algoritma interpolasi standar yang digunakan untuk dengan lancar menggerakkan pergerakan objek adegan.  Masing-masing fungsi ini biasanya memiliki dua argumen: nilai awal parameter (biasanya 0) dan nilai akhir parameter (biasanya 1).  Fungsi-fungsi ini dapat diterapkan pada awal gerakan (InMotion), ke akhir gerakan (OutMotion) atau ke awal dan akhir gerakan (InOutMotion) <br><br><table><thead><tr><th>  Jenis gerakan </th><th>  di kelas </th><th>  keluar kelas </th><th>  di / keluar kelas </th></tr></thead><tbody><tr><td>  Interpolasi linier </td><td>  LinearMotion </td><td>  - </td><td>  - </td></tr><tr><td>  Interpolasi kuadratik </td><td>  InQuadMotion </td><td>  OutQuadMotion </td><td>  InOutQuadMotion </td></tr><tr><td>  Interpolasi kubik </td><td>  InCubicMotion </td><td>  Promosi luar </td><td>  InOutCubicMotion </td></tr><tr><td>  Interpolasi 4-urutan </td><td>  InQuartMotion </td><td>  OutQuartMotion </td><td>  InOutQuartMotion </td></tr><tr><td>  Interpolasi Efek Bouncing </td><td>  InBounceMotion </td><td>  OutBounceMotion </td><td>  InOutBounceMotion </td></tr><tr><td>  Interpolasi rebound elastis </td><td>  InElasticMotion </td><td>  OutElasticMotion </td><td>  InOutElasticMotion </td></tr><tr><td>  Interpolasi sinusoidal </td><td>  InSineMotion </td><td>  Emosi luar biasa </td><td>  InOutSineMotion </td></tr><tr><td>  Interpolasi terbalik </td><td>  Inbackmotion </td><td>  Outbackmotion </td><td>  InOutBackMotion </td></tr><tr><td>  Interpolasi melingkar </td><td>  InCircMotion </td><td>  Peredaran </td><td>  InOutCircMotion </td></tr><tr><td>  Interpolasi eksponensial </td><td>  InExpoMotion </td><td>  Eksploitasi berlebihan </td><td>  InOutExpoMotion </td></tr></tbody></table><br>  Untuk membuat interpolasi linier dari pergerakan suatu objek, kita menulis kode seperti itu <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osgAnimation::LinearMotion&gt; motion = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osgAnimation::LinearMotion(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>);</code> </pre><br><h1>  3. Animasi node transformasi </h1><br>  Animasi lintasan adalah jenis animasi yang paling umum dalam aplikasi grafis.  Teknik ini dapat digunakan untuk menghidupkan gerakan mobil, penerbangan pesawat, atau gerakan kamera.  Lintasan sudah ditentukan sebelumnya, dengan semua posisi, rotasi, dan skala berubah pada titik-titik utama dalam waktu.  Ketika siklus simulasi dimulai, keadaan objek dihitung ulang di setiap frame, menggunakan interpolasi linier untuk posisi dan penskalaan dan interpolasi linear bola untuk angka empat rotasi.  Untuk melakukan ini, gunakan metode internal slerp () dari kelas osg :: Quat. <br><br>  OSG menyediakan kelas osg :: AnimationPath untuk menjelaskan jalur yang bervariasi waktu.  Metode sisipan kelas ini () digunakan untuk menambahkan titik kontrol yang sesuai dengan titik-titik tertentu dalam waktu ke lintasan.  Titik kontrol dijelaskan oleh kelas osg :: AnimationPath :: ControlPoint, konstruktor yang mengambil posisi sebagai parameter, dan, secara opsional, rotasi objek dan parameter penskalaan.  Sebagai contoh <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::AnimationPath&gt; path = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::AnimationPath; path-&gt;insert(t1, osg::AnimationPath::ControlPoint(pos1, rot1, scale1)); path-&gt;insert(t2, ...);</code> </pre><br>  Di sini t1, t2 adalah contoh waktu dalam detik;  rot1 adalah parameter rotasi pada waktu t1, dijelaskan oleh angka empat :: jumlah Quat. <br><br>  Dimungkinkan untuk mengontrol loop animasi melalui metode setLoopMode ().  Secara default, mode LOOP dihidupkan - animasi akan terus diulang.  Nilai lain yang mungkin: NO_LOOPING - mainkan animasi sekali dan SWING - putar gerakan ke arah maju dan mundur. <br><br>  Setelah semua inisialisasi selesai, kami lampirkan objek osg :: AnimationPath ke objek built-in osg :: AnimationPathCallback, yang berasal dari kelas osg :: NodeCallback. <br><br><h1>  4. Contoh animasi gerakan di sepanjang jalan </h1><br>  Sekarang kita akan membuat cessna kita bergerak dalam lingkaran dengan pusat di titik (0,0,0).  Posisi pesawat pada lintasan akan dihitung dengan menginterpolasi posisi dan orientasi antara bingkai kunci secara linear. <br><br><div class="spoiler">  <b class="spoiler_title">Contoh animcessna</b> <div class="spoiler_text">  <strong>main.h</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/AnimationPath&gt; #include &lt;osg/MatrixTransform&gt; #include &lt;osgDB/ReadFile&gt; #include &lt;osgViewer/Viewer&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ osg::AnimationPath *createAnimationPath(double radius, double time) { osg::ref_ptr&lt;osg::AnimationPath&gt; path = new osg::AnimationPath; path-&gt;setLoopMode(osg::AnimationPath::LOOP); unsigned int numSamples = 32; double delta_yaw = 2.0 * osg::PI / (static_cast&lt;double&gt;(numSamples) - 1.0); double delta_time = time / static_cast&lt;double&gt;(numSamples); for (unsigned int i = 0; i &lt; numSamples; ++i) { double yaw = delta_yaw * i; osg::Vec3d pos(radius * sin(yaw), radius * cos(yaw), 0.0); osg::Quat rot(-yaw, osg::Z_AXIS); path-&gt;insert(delta_time * i, osg::AnimationPath::ControlPoint(pos, rot)); } return path.release(); } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::ref_ptr&lt;osg::Node&gt; model = osgDB::readNodeFile("../data/cessna.osg.0,0,90.rot"); osg::ref_ptr&lt;osg::MatrixTransform&gt; root = new osg::MatrixTransform; root-&gt;addChild(model.get()); osg::ref_ptr&lt;osg::AnimationPathCallback&gt; apcb = new osg::AnimationPathCallback; apcb-&gt;setAnimationPath(createAnimationPath(50.0, 6.0)); root-&gt;setUpdateCallback(apcb.get()); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  Kami mulai dengan membuat lintasan pesawat, mengambil kode ini menjadi fungsi terpisah <br><br><pre> <code class="cpp hljs">osg::<span class="hljs-function"><span class="hljs-function">AnimationPath *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createAnimationPath</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> radius, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> time)</span></span></span><span class="hljs-function"> </span></span>{ osg::ref_ptr&lt;osg::AnimationPath&gt; path = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::AnimationPath; path-&gt;setLoopMode(osg::AnimationPath::LOOP); <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> numSamples = <span class="hljs-number"><span class="hljs-number">32</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> delta_yaw = <span class="hljs-number"><span class="hljs-number">2.0</span></span> * osg::PI / (<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;(numSamples) - <span class="hljs-number"><span class="hljs-number">1.0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> delta_time = time / <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;(numSamples); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; numSamples; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> yaw = delta_yaw * i; osg::<span class="hljs-function"><span class="hljs-function">Vec3d </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pos</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(radius * </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">sin</span></span></span></span><span class="hljs-function"><span class="hljs-params">(yaw), radius * </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">cos</span></span></span></span><span class="hljs-function"><span class="hljs-params">(yaw), </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; osg::<span class="hljs-function"><span class="hljs-function">Quat </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rot</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(-yaw, osg::Z_AXIS)</span></span></span></span>; path-&gt;insert(delta_time * i, osg::AnimationPath::ControlPoint(pos, rot)); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> path.release(); }</code> </pre><br>  Sebagai parameter, fungsi tersebut mengambil jari-jari lingkaran di mana pesawat bergerak dan waktu selama itu akan membuat satu revolusi.  Di dalam fungsinya, buat objek lintasan dan nyalakan mode perulangan animasi <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::AnimationPath&gt; path = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::AnimationPath; path-&gt;setLoopMode(osg::AnimationPath::LOOP);</code> </pre><br>  Kode berikut <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> numSamples = <span class="hljs-number"><span class="hljs-number">32</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> delta_yaw = <span class="hljs-number"><span class="hljs-number">2.0</span></span> * osg::PI / (<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;(numSamples) - <span class="hljs-number"><span class="hljs-number">1.0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> delta_time = time / <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;(numSamples);</code> </pre><br>  menghitung parameter perkiraan lintasan.  Kami membagi seluruh lintasan menjadi numContoh bagian lurus, dan menghitung perubahan sudut rotasi pesawat di sekitar sumbu vertikal (yaw) delta_yaw dan perubahan waktu delta_time ketika bergerak dari bagian ke bagian.  Sekarang buat titik kontrol yang diperlukan <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; numSamples; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> yaw = delta_yaw * i; osg::<span class="hljs-function"><span class="hljs-function">Vec3d </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pos</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(radius * </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">sin</span></span></span></span><span class="hljs-function"><span class="hljs-params">(yaw), radius * </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">cos</span></span></span></span><span class="hljs-function"><span class="hljs-params">(yaw), </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; osg::<span class="hljs-function"><span class="hljs-function">Quat </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rot</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(-yaw, osg::Z_AXIS)</span></span></span></span>; path-&gt;insert(delta_time * i, osg::AnimationPath::ControlPoint(pos, rot)); }</code> </pre><br>  Dalam siklus, semua bagian lintasan dari yang pertama ke yang terakhir diurutkan.  Setiap titik kontrol ditandai dengan sudut yaw <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">double</span></span> yaw = delta_yaw * i;</code> </pre><br>  posisi pusat massa pesawat di ruang angkasa <br><br><pre> <code class="cpp hljs">osg::<span class="hljs-function"><span class="hljs-function">Vec3d </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pos</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(radius * </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">sin</span></span></span></span><span class="hljs-function"><span class="hljs-params">(yaw), radius * </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">cos</span></span></span></span><span class="hljs-function"><span class="hljs-params">(yaw), </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>;</code> </pre><br>  Rotasi pesawat ke sudut yaw yang diinginkan (relatif terhadap sumbu vertikal) diatur oleh angka empat <br><br><pre> <code class="cpp hljs">osg::<span class="hljs-function"><span class="hljs-function">Quat </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rot</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(-yaw, osg::Z_AXIS)</span></span></span></span>;</code> </pre><br>  dan kemudian menambahkan parameter yang dihitung ke daftar titik kontrol jalan <br><br><pre> <code class="cpp hljs">path-&gt;insert(delta_time * i, osg::AnimationPath::ControlPoint(pos, rot));</code> </pre><br>  Dalam program utama, kami memperhatikan nuansa dalam menunjukkan nama file model pesawat saat boot <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Node&gt; model = osgDB::readNodeFile(<span class="hljs-string"><span class="hljs-string">"../data/cessna.osg.0,0,90.rot"</span></span>);</code> </pre><br>  - akhiran ".0,0,90.rot" telah ditambahkan ke nama file.  Mekanisme untuk memuat geometri dari file yang digunakan dalam OSG memungkinkan Anda menentukan posisi awal dan orientasi model setelah memuat.  Dalam hal ini, kami ingin model diputar 90 derajat di sekitar sumbu Z setelah pemuatan. <br><br>  Selanjutnya, simpul akar dibuat, yang merupakan simpul transformasi, dan objek model ditambahkan padanya sebagai simpul anak <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::MatrixTransform&gt; root = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::MatrixTransform; root-&gt;addChild(model.get());</code> </pre><br>  Sekarang buat callback animasi lintasan, tambahkan jalur yang dibuat oleh fungsi createAnimationPath () ke dalamnya <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::AnimationPathCallback&gt; apcb = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::AnimationPathCallback; apcb-&gt;setAnimationPath(createAnimationPath(<span class="hljs-number"><span class="hljs-number">50.0</span></span>, <span class="hljs-number"><span class="hljs-number">6.0</span></span>));</code> </pre><br>  Lampirkan panggilan balik ini ke node transformasi <br><br><pre> <code class="cpp hljs">root-&gt;setUpdateCallback(apcb.get());</code> </pre><br>  Penampil diinisialisasi dan diluncurkan seperti biasa. <br><br><pre> <code class="cpp hljs">osgViewer::Viewer viewer; viewer.setSceneData(root.get()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> viewer.run();</code> </pre><br>  Dapatkan animasi gerakan pesawat <br><br><img src="https://habrastorage.org/webt/ax/01/rl/ax01rlkfna5cfkvzqk3qfao_lmq.gif"><br><br>  Pikirkan Anda menemukan sesuatu yang aneh dalam contoh ini?  Sebelumnya, misalnya, dalam sebuah program saat merender ke suatu tekstur, Anda secara eksplisit mengubah matriks transformasi untuk mencapai perubahan posisi model dalam ruang.  Di sini kita hanya membuat simpul transformasi dan dalam kode tidak ada tugas matriks eksplisit di mana pun. <br><br>  Rahasianya adalah kelas khusus osg :: AnimationPathCallback melakukan pekerjaan ini.  Sesuai dengan posisi objek saat ini di jalan, ia menghitung matriks transformasi dan secara otomatis menerapkannya pada node transformasi yang dilampirkan, menyelamatkan pengembang dari banyak operasi rutin. <br><br>  Perlu dicatat bahwa melampirkan osg :: AnimationPathCallback ke jenis node lainnya tidak hanya tidak akan berpengaruh, tetapi juga dapat menyebabkan perilaku program yang tidak ditentukan.  Penting untuk diingat bahwa panggilan balik ini hanya memengaruhi node transformasi. <br><br><h1>  5. Animasi kontrol perangkat lunak </h1><br>  Kelas osg :: AnimationPathCallback menyediakan metode untuk mengontrol animasi selama eksekusi program. <br><br><ol><li>  reset () - reset animasi dan mainkan terlebih dahulu. <br></li><li>  setPause () - menjeda animasi.  Mengambil nilai boolean sebagai parameter <br></li><li>  setTimeOffset () - mengatur offset waktu sebelum dimulainya animasi. <br></li><li>  setTimeMultiplier () - mengatur faktor waktu untuk akselerasi / perlambatan animasi. <br></li></ol><br>  Misalnya, untuk menghapus animasi dari jeda dan mengatur ulang, kami mengeksekusi kode tersebut <br><br><pre> <code class="cpp hljs">apcb-&gt;setPause(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); apcb-&gt;reset();</code> </pre><br>  dan untuk memulai animasi dari detik keempat setelah memulai program dengan akselerasi ganda, kode seperti itu <br><br><pre> <code class="cpp hljs">apcb-&gt;setTimeOffset(<span class="hljs-number"><span class="hljs-number">4.0f</span></span>); apcb-&gt;setTimeMultiplier(<span class="hljs-number"><span class="hljs-number">2.0f</span></span>);</code> </pre><br><h1>  6. Urutan rendering primitif di OpenGL </h1><br>  OpenGL menyimpan data titik dan primitif dalam berbagai buffer, seperti buffer warna, buffer kedalaman, buffer stensil, dan sebagainya.  Selain itu, ia tidak menimpa simpul dan wajah segitiga yang sudah dikirim ke pipanya.  Ini berarti bahwa OpenGL membuat geometri baru, terlepas dari bagaimana geometri yang ada dibuat.  Ini berarti bahwa urutan primitif dikirim ke jalur render secara signifikan mempengaruhi hasil akhir yang kita lihat di layar. <br><br>  Berdasarkan data buffer kedalaman, OpenGL akan menggambar objek buram dengan benar, menyortir piksel berdasarkan jaraknya dari pengamat.  Namun, ketika menggunakan teknik pencampuran warna, misalnya, ketika mengimplementasikan objek transparan dan tembus cahaya, operasi khusus akan dilakukan untuk memperbarui buffer warna.  Pixel baru dan lama dari gambar dicampur, dengan mempertimbangkan nilai saluran alpha (komponen warna keempat).  Ini mengarah pada fakta bahwa urutan rendering dari tepi transparan dan buram mempengaruhi hasil akhir <br><br><img src="https://habrastorage.org/webt/tz/3w/o4/tz3wo4dfy14oscogqvrb1akmh5m.png"><br><br>  Dalam gambar, dalam situasi di sebelah kiri, pada objek buram pertama dan kemudian transparan dikirim ke pipa, yang menyebabkan pergeseran yang benar dalam buffer warna dan tampilan wajah yang benar.  Dalam situasi yang tepat, objek transparan pertama digambar, dan kemudian buram, yang menyebabkan tampilan yang salah. <br><br>  Metode setRenderingHint () dari kelas osg :: StateSet menunjukkan kepada OSG urutan render node dan objek geometri yang diperlukan, jika ini perlu dilakukan secara eksplisit.  Metode ini hanya menunjukkan apakah wajah transparan harus diperhitungkan atau tidak harus diperhitungkan saat rendering, dengan demikian memastikan bahwa jika ada wajah transparan dalam adegan, buram dan kemudian wajah transparan akan ditarik terlebih dahulu, dengan mempertimbangkan jarak dari pengamat.  Untuk memberi tahu mesin bahwa simpul ini buram, kami menggunakan kode ini <br><br><pre> <code class="cpp hljs">node-&gt;getOrCreateStateSet()-&gt;setRenderingHint(osg::StateSet::OPAQUE_BIN);</code> </pre><br>  atau mengandung tepi transparan <br><br><pre> <code class="cpp hljs">node-&gt;getOrCreateStateSet()-&gt;setRenderingHint(osg::StateSet::TRANSPARENT_BIN);</code> </pre><br><h1>  7. Contoh implementasi objek yang tembus cahaya </h1><br>  Mari kita coba mengilustrasikan semua pengantar teoretis di atas dengan contoh nyata implementasi objek yang tembus cahaya. <br><br><div class="spoiler">  <b class="spoiler_title">Contoh transparansi</b> <div class="spoiler_text">  <strong>main.h</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/BlendFunc&gt; #include &lt;osg/Texture2D&gt; #include &lt;osg/Geometry&gt; #include &lt;osgDB/ReadFile&gt; #include &lt;osgViewer/Viewer&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::ref_ptr</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg::Vec3Array&gt; vertices = new osg::Vec3Array; vertices-&gt;push_back( osg::Vec3(-0.5f, 0.0f, -0.5f) ); vertices-&gt;push_back( osg::Vec3( 0.5f, 0.0f, -0.5f) ); vertices-&gt;push_back( osg::Vec3( 0.5f, 0.0f, 0.5f) ); vertices-&gt;push_back( osg::Vec3(-0.5f, 0.0f, 0.5f) ); osg::ref_ptr&lt;osg::Vec3Array&gt; normals = new osg::Vec3Array; normals-&gt;push_back( osg::Vec3(0.0f, -1.0f, 0.0f) ); osg::ref_ptr&lt;osg::Vec2Array&gt; texcoords = new osg::Vec2Array; texcoords-&gt;push_back( osg::Vec2(0.0f, 0.0f) ); texcoords-&gt;push_back( osg::Vec2(0.0f, 1.0f) ); texcoords-&gt;push_back( osg::Vec2(1.0f, 1.0f) ); texcoords-&gt;push_back( osg::Vec2(1.0f, 0.0f) ); osg::ref_ptr&lt;osg::Vec4Array&gt; colors = new osg::Vec4Array; colors-&gt;push_back( osg::Vec4(1.0f, 1.0f, 1.0f, 0.5f) ); osg::ref_ptr&lt;osg::Geometry&gt; quad = new osg::Geometry; quad-&gt;setVertexArray(vertices.get()); quad-&gt;setNormalArray(normals.get()); quad-&gt;setNormalBinding(osg::Geometry::BIND_OVERALL); quad-&gt;setColorArray(colors.get()); quad-&gt;setColorBinding(osg::Geometry::BIND_OVERALL); quad-&gt;setTexCoordArray(0, texcoords.get()); quad-&gt;addPrimitiveSet(new osg::DrawArrays(GL_QUADS, 0, 4)); osg::ref_ptr&lt;osg::Geode&gt; geode = new osg::Geode; geode-&gt;addDrawable(quad.get()); osg::ref_ptr&lt;osg::Texture2D&gt; texture = new osg::Texture2D; osg::ref_ptr&lt;osg::Image&gt; image = osgDB::readImageFile("../data/Images/lz.rgb"); texture-&gt;setImage(image.get()); osg::ref_ptr&lt;osg::BlendFunc&gt; blendFunc = new osg::BlendFunc; blendFunc-&gt;setFunction(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); osg::StateSet *stateset = geode-&gt;getOrCreateStateSet(); stateset-&gt;setTextureAttributeAndModes(0, texture.get()); stateset-&gt;setAttributeAndModes(blendFunc); osg::ref_ptr&lt;osg::Group&gt; root = new osg::Group; root-&gt;addChild(geode.get()); root-&gt;addChild(osgDB::readNodeFile("../data/glider.osg")); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  Sebagian besar, kode yang ditampilkan di sini tidak mengandung sesuatu yang baru: dua objek geometrik dibuat - kotak bertekstur dan hang glider, model yang diambil dari file.  Namun, kami menerapkan warna transparan putih ke semua simpul persegi <br><br><pre> <code class="cpp hljs">colors-&gt;push_back( osg::Vec4(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) );</code> </pre><br>  - nilai kanal alfa adalah 0,5, yang bila dicampur dengan warna tekstur, akan memberikan efek objek yang tembus cahaya.  Selain itu, fungsi pencampuran warna harus diatur untuk pemrosesan transparansi. <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::BlendFunc&gt; blendFunc = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::BlendFunc; blendFunc-&gt;setFunction(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);</code> </pre><br>  meneruskannya ke mesin status OpenGL <br><br><pre> <code class="cpp hljs">stateset-&gt;setAttributeAndModes(blendFunc);</code> </pre><br>  Ketika menyusun dan menjalankan program ini, kami mendapatkan hasil berikut <br><br><img src="https://habrastorage.org/webt/_m/mz/kz/_mmzkzrmxvmfll-qi0xli6wq_5g.png"><br><br>  Hentikan itu!  Dan di mana transparansi?  Masalahnya adalah kita lupa memberi tahu mesin bahwa tepian transparan harus diproses, yang mudah diselesaikan dengan menelepon <br><br><pre> <code class="cpp hljs">stateset-&gt;setRenderingHint(osg::StateSet::TRANSPARENT_BIN);</code> </pre><br>  setelah itu kita mendapatkan hasil yang kita butuhkan - sayap peluncur layang bersinar melalui kotak bertekstur transparan <br><br><img src="https://habrastorage.org/webt/py/bl/ta/pybltaqa6xkligouodxgunwoyvs.png"><br><br>  Parameter dari fungsi pencampuran GL_SRC_ALPHA dan GL_ONE_MINUS_SRC_ALPHA berarti bahwa piksel layar yang dihasilkan saat menggambar wajah transparan akan memiliki komponen warna yang dihitung oleh rumus. <br><br><pre> <code class="plaintext hljs">R = srcR * srcA + dstR * (1 - srcA) G = srcG * srcA + dstG * (1 - srcA) B = srcB * srcA + dstB * (1 - srcA)</code> </pre><br>  di mana [srcR, srcG, srcB] adalah komponen warna dari tekstur kuadrat;<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[dstR, dstG, dstB] - komponen warna dari setiap piksel area di mana wajah yang transparan ditumpangkan, mengingat latar belakang dan tepi buram sayap glider sudah digambar di tempat ini. </font><font style="vertical-align: inherit;">Maksud saya srcA adalah komponen alfa dari warna kotak. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Metode seRenderingHint () dengan sempurna mengatur rendering primitif, tetapi menggunakannya tidak sangat efisien, karena menyortir objek transparan dengan kedalaman ketika rendering frame adalah operasi yang sangat intensif sumber daya. </font><font style="vertical-align: inherit;">Oleh karena itu, pengembang harus mengurus urutan menggambar wajah mereka sendiri, jika mungkin pada tahap awal persiapan adegan.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 8. Animasi atribut negara </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menggunakan animasi, Anda juga dapat mengontrol atribut negara. </font><font style="vertical-align: inherit;">Seluruh efek visual dapat dihasilkan dengan mengubah properti dari satu atau lebih atribut render. </font><font style="vertical-align: inherit;">Animasi semacam ini yang mengubah keadaan atribut render mudah diterapkan melalui mekanisme panggilan balik saat memperbarui adegan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kelas interpolasi standar juga dapat digunakan untuk menentukan fungsi mengubah parameter atribut. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami sudah memiliki pengalaman dalam membuat objek transparan. </font><font style="vertical-align: inherit;">Kita tahu bahwa jika komponen alfa warna adalah nol, kita mendapatkan objek yang sepenuhnya transparan, dengan nilai 1 - benar-benar buram. </font><font style="vertical-align: inherit;">Jelas bahwa dengan memvariasikan parameter ini dari 0 hingga 1 dalam waktu, efek dari penampilan bertahap atau hilangnya suatu objek dapat diperoleh. </font><font style="vertical-align: inherit;">Kami menggambarkan ini dengan contoh nyata.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Misalnya memudar</font></font></b> <div class="spoiler_text">  <strong>main.h</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/Geode&gt; #include &lt;osg/Geometry&gt; #include &lt;osg/BlendFunc&gt; #include &lt;osg/Material&gt; #include &lt;osgAnimation/EaseMotion&gt; #include &lt;osgDB/ReadFile&gt; #include &lt;osgViewer/Viewer&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ class AlphaFadingCallback : public osg::StateAttributeCallback { public: AlphaFadingCallback() { _motion = new osgAnimation::InOutCubicMotion(0.0f, 1.0f); } virtual void operator() (osg::StateAttribute* , osg::NodeVisitor*); protected: osg::ref_ptr&lt;osgAnimation::InOutCubicMotion&gt; _motion; }; //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ void AlphaFadingCallback::operator()(osg::StateAttribute *sa, osg::NodeVisitor *nv) { (void) nv; osg::Material *material = static_cast&lt;osg::Material *&gt;(sa); if (material) { _motion-&gt;update(0.0005f); float alpha = _motion-&gt;getValue(); material-&gt;setDiffuse(osg::Material::FRONT_AND_BACK, osg::Vec4(0.0f, 1.0f, 1.0f, alpha)); } } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::ref_ptr&lt;osg::Drawable&gt; quad = osg::createTexturedQuadGeometry( osg::Vec3(-0.5f, 0.0f, -0.5f), osg::Vec3(1.0f, 0.0f, 0.0f), osg::Vec3(0.0f, 0.0f, 1.0f)); osg::ref_ptr&lt;osg::Geode&gt; geode = new osg::Geode; geode-&gt;addDrawable(quad.get()); osg::ref_ptr&lt;osg::Material&gt; material = new osg::Material; material-&gt;setAmbient(osg::Material::FRONT_AND_BACK, osg::Vec4(0.0f, 0.0f, 0.0f, 1.0f)); material-&gt;setDiffuse(osg::Material::FRONT_AND_BACK, osg::Vec4(0.0f, 1.0f, 1.0f, 0.5f)); material-&gt;setUpdateCallback(new AlphaFadingCallback); geode-&gt;getOrCreateStateSet()-&gt;setAttributeAndModes(material.get()); geode-&gt;getOrCreateStateSet()-&gt;setAttributeAndModes(new osg::BlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)); geode-&gt;getOrCreateStateSet()-&gt;setRenderingHint(osg::StateSet::TRANSPARENT_BIN); osg::ref_ptr&lt;osg::Group&gt; root = new osg::Group; root-&gt;addChild(geode.get()); root-&gt;addChild(osgDB::readNodeFile("../data/glider.osg")); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kami mulai dengan membuat penangan panggilan balik untuk mengubah nilai saluran alpha dari waktu ke waktu </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AlphaFadingCallback</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> osg::StateAttributeCallback { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: AlphaFadingCallback() { _motion = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osgAnimation::InOutCubicMotion(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(osg::StateAttribute* , osg::NodeVisitor*)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: osg::ref_ptr&lt;osgAnimation::InOutCubicMotion&gt; _motion; };</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parameter _motion yang dilindungi akan menentukan fungsi dengan mana nilai alpha akan berubah seiring waktu. </font><font style="vertical-align: inherit;">Untuk contoh ini, kita memilih pendekatan spline kubik, mengaturnya segera, di konstruktor kelas</font></font><br><br><pre> <code class="cpp hljs">AlphaFadingCallback() { _motion = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osgAnimation::InOutCubicMotion(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ketergantungan ini dapat diilustrasikan oleh kurva seperti itu. </font></font><br><br><img src="https://habrastorage.org/webt/ej/gd/cr/ejgdcr97gkb0lru6evved46sk6q.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam konstruktor objek InOutCubicMotion, kita menentukan batas nilai yang diperkirakan dari 0 hingga 1. Selanjutnya, kita mendefinisikan kembali operator () untuk kelas ini dengan cara ini</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AlphaFadingCallback::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>()(osg::StateAttribute *sa, osg::NodeVisitor *nv) { (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) nv; osg::Material *material = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;osg::Material *&gt;(sa); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (material) { _motion-&gt;update(<span class="hljs-number"><span class="hljs-number">0.0005f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> alpha = _motion-&gt;getValue(); material-&gt;setDiffuse(osg::Material::FRONT_AND_BACK, osg::Vec4(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, alpha)); } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dapatkan pointer ke materi </font></font><br><br><pre> <code class="cpp hljs">osg::Material *material = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;osg::Material *&gt;(sa);</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nilai abstrak atribut datang ke callback, namun kami akan melampirkan handler ini ke materi, oleh karena itu adalah pointer ke material yang akan datang, oleh karena itu kami dapat dengan aman mengkonversi atribut state ke pointer ke material. </font><font style="vertical-align: inherit;">Selanjutnya, kita mengatur interval pembaruan dari fungsi yang diperkirakan - semakin besar, semakin cepat parameter akan berubah dalam rentang yang ditentukan</font></font><br><br><pre> <code class="cpp hljs">_motion-&gt;update(<span class="hljs-number"><span class="hljs-number">0.0005f</span></span>);</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kami membaca nilai fungsi aproksimasi </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> alpha = _motion-&gt;getValue();</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan memberikan materi nilai warna difus baru </font></font><br><br><pre> <code class="cpp hljs">material-&gt;setDiffuse(osg::Material::FRONT_AND_BACK, osg::Vec4(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, alpha));</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang mari kita membentuk adegan dalam fungsi utama (). </font><font style="vertical-align: inherit;">Saya pikir Anda lelah setiap kali membangun persegi pada simpul, jadi kami menyederhanakan tugas - kami menghasilkan poligon persegi dengan fungsi OSG standar</font></font><br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Drawable&gt; quad = osg::createTexturedQuadGeometry( osg::Vec3(<span class="hljs-number"><span class="hljs-number">-0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">-0.5f</span></span>), osg::Vec3(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>), osg::Vec3(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>));</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parameter pertama adalah titik dari mana sudut kiri bawah kotak akan dibangun, dua parameter lainnya menentukan koordinat diagonal. </font><font style="vertical-align: inherit;">Setelah menemukan kotak, kami membuat bahan untuk itu</font></font><br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Material&gt; material = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Material; material-&gt;setAmbient(osg::Material::FRONT_AND_BACK, osg::Vec4(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>)); material-&gt;setDiffuse(osg::Material::FRONT_AND_BACK, osg::Vec4(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>));</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami menunjukkan opsi warna material. </font><font style="vertical-align: inherit;">Warna ambient adalah parameter yang mencirikan warna material di area yang diarsir, tidak dapat diakses oleh sumber warna. </font><font style="vertical-align: inherit;">Warna difus adalah warna bahan itu sendiri, yang mencirikan kemampuan permukaan untuk meredakan warna yang jatuh di atasnya, yaitu apa yang biasa kita sebut warna dalam kehidupan sehari-hari. </font><font style="vertical-align: inherit;">Parameter FRONT_AND_BACK menunjukkan bahwa atribut warna ini ditetapkan untuk sisi depan dan belakang wajah geometri. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tetapkan materi untuk penangan yang dibuat sebelumnya.</font></font><br><br><pre> <code class="cpp hljs">material-&gt;setUpdateCallback(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AlphaFadingCallback);</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tetapkan materi yang dibuat ke kotak </font></font><br><br><pre> <code class="cpp hljs">geode-&gt;getOrCreateStateSet()-&gt;setAttributeAndModes(material.get());</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan mengatur atribut lainnya - fungsi pencampuran warna dan menunjukkan bahwa objek ini memiliki tepi transparan </font></font><br><br><pre> <code class="cpp hljs">geode-&gt;getOrCreateStateSet()-&gt;setAttributeAndModes(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::BlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)); geode-&gt;getOrCreateStateSet()-&gt;setRenderingHint(osg::StateSet::TRANSPARENT_BIN);</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kami menyelesaikan pembentukan adegan dan menjalankan pemirsa </font></font><br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Group&gt; root = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Group; root-&gt;addChild(geode.get()); root-&gt;addChild(osgDB::readNodeFile(<span class="hljs-string"><span class="hljs-string">"../data/glider.osg"</span></span>)); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> viewer.run();</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kami mendapatkan hasilnya dalam bentuk kotak yang muncul dengan mulus di tempat kejadian </font></font><br><br><img src="https://habrastorage.org/webt/s5/jv/1h/s5jv1h_ebaecadz6owo60nnrdvg.gif"><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Alih-alih kesimpulan: komentar kecil tentang dependensi </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tentunya contoh Anda tidak dikompilasi, memberikan kesalahan pada tahap pembuatan. </font><font style="vertical-align: inherit;">Ini bukan kebetulan - perhatikan baris di file header main.h</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osgAnimation/EaseMotion&gt;</span></span></span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Direktori header OSG dari mana file header diambil biasanya menunjuk ke perpustakaan yang berisi implementasi fungsi dan kelas yang dijelaskan dalam header. </font><font style="vertical-align: inherit;">Oleh karena itu, tampilan osgAnimation / direktori harus menyarankan bahwa perpustakaan dengan nama yang sama harus ditambahkan ke daftar tautan skrip build proyek, kira-kira seperti ini (dengan mempertimbangkan jalur ke perpustakaan dan versi build)</font></font><br><br><pre> <code class="cmake hljs">LIBS += -losgAnimation</code> </pre><br>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dilanjutkan ...</a></i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id437724/">https://habr.com/ru/post/id437724/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id437712/index.html">Stasiun Luar Angkasa Roskomnadzor</a></li>
<li><a href="../id437714/index.html">Kami menggambar ledakan kartun untuk 180 garis telanjang C ++</a></li>
<li><a href="../id437716/index.html">Tiga cara yang relatif jujur ‚Äã‚Äãuntuk membuat proyek Flutter</a></li>
<li><a href="../id437720/index.html">Perjuangan untuk solusi berkualitas di Erlang / Elixir</a></li>
<li><a href="../id437722/index.html">Konsekuensi Kosmik Shatdown Amerika</a></li>
<li><a href="../id437726/index.html">Serializing Kotlin dengan Kotlinx. Serialisasi</a></li>
<li><a href="../id437730/index.html">Bagaimana kami memecahkan masalah memori di PostgreSQL tanpa menambahkan byte</a></li>
<li><a href="../id437732/index.html">Tinjauan Umum tentang Printer DLP MakeX M-One Pro 70</a></li>
<li><a href="../id437734/index.html">Menyiapkan IPTV dari Rostelecom pada router MikroTik</a></li>
<li><a href="../id437736/index.html">Bagaimana kami mengotomatiskan peluncuran uji Selenium melalui Moon dan OpenShift</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>