<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💖 🕦 ⚔️ Recursos de chamadas de função em C ++ 👈🏻 🦅 👋🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Há pouco tempo, tive outra conversa com um colega sobre um assunto eterno: "por referência ou por valor". Como resultado, este artigo surgiu. Nele, qu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Recursos de chamadas de função em C ++</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/414443/"><p>  Há pouco tempo, tive outra conversa com um colega sobre um assunto eterno: "por referência ou por valor".  Como resultado, este artigo surgiu.  Nele, quero apresentar os resultados de minha pesquisa sobre este e outros tópicos relacionados.  A seguir serão considerados: </p><br><ul><li>  Registradores e sua finalidade ao chamar funções. </li><li>  Transferência e retorno de tipos e estruturas simples. </li><li>  Como a passagem por referência e por valor afeta a otimização do corpo da função pelo compilador. </li><li>  Como o espaço é usado em várias chamadas de função. </li><li>  O mecanismo de chamadas virtuais. </li><li>  Otimização de chamadas de cauda e recursão. </li><li>  Inicialização de estruturas, matrizes e vetores. </li></ul><br><p> Cuidado  O artigo contém uma grande quantidade de C ++ e código assembler ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Intel ASM</a> com comentários), além de muitas tabelas com classificações de desempenho.  Tudo o que foi escrito é relevante para o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><em>x86-64 System V ABI</em></a> , que é usado em todos os sistemas operacionais Unix modernos, por exemplo, Linux e macOS. </p><a name="habracut"></a><br><p> As informações foram obtidas da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Interface Binária do Aplicativo System V para o</a> documento <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">x86-64</a> .  As listagens de assembler foram obtidas para o <em>clang 5.0.0 x86-64</em> com os sinalizadores <code>-O3 -std=c++1z -march=sandybridge</code> (usando o site <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://godbolt.org</a> ).  As classificações de desempenho foram feitas para o <em>processador Intel® Xeon® E5-2660 2.20GHz</em> . </p><br><h2 id="soderzhanie">  Conteúdo </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Conteúdo</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Registros em x86-64</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Passando parâmetros</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Exemplos simples</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Passar por link</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Comparação de desempenho</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Ponteiros transparentes</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Reutilizar pilha</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Comparação de desempenho</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Digite opcional</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Funções virtuais</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Comparação de desempenho</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Chamadas de cauda</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Inicialização</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Um item</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Pequena matriz</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Large array</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Matriz dinâmica</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Comparação de desempenho</a> </li></ul></li></ul><br><h2 id="registry-v-x86-64">  Registros em x86-64 </h2><br><p>  Todos os dados são armazenados na RAM.  Para acelerar o trabalho, são usados ​​caches multiníveis.  Mas, para alterar os dados, de uma maneira ou de outra, são utilizados registros ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">discussão nos comentários</a> ).  Abaixo está uma descrição muito breve dos registros mais usados ​​na arquitetura x86-64. </p><br><ul><li>  16 registradores de uso geral: <code>rax, rbx, rcx, rdx, rbp, rsi, rdi, rsp</code> e também <code>r8-r15</code> .  O tamanho de cada um deles é de 64 bits (8 bytes).  Para acessar os 32 bits inferiores (4 bytes), o prefixo <code>e</code> vez de <code>r</code> ( <code>rax</code> → <code>eax</code> ).  Apenas operações inteiras não vetoriais são suportadas. </li><li>  <code>rip</code> (ponteiro da instrução) indica a instrução a ser executada a seguir.  Vários dados constantes na seção de memória com instruções podem ser lidos em um deslocamento relativo ao <code>rip</code> . </li><li>  <code>rsp</code> (ponteiro da pilha) aponta para o último item da pilha.  A pilha cresce em direção aos endereços mais baixos.  Colocar algo na pilha <strong>reduz</strong> o valor de <code>rsp</code> . </li><li>  16 SSE registra 128 bits de tamanho: <code>xmm0 - xmm15</code> .  Se o modo <code>AVX</code> for suportado, eles se referem aos 128 bits inferiores dos <code>ymm0 - ymm15</code> cada um com 256 bits.  Para operações vetoriais ou não inteiras, os dados devem primeiro ser carregados nesses registradores. </li></ul><br><h2 id="peredacha-parametrov">  Passando parâmetros </h2><br><p>  Esta seção fornece uma descrição um tanto resumida e simplificada do algoritmo para distribuir argumentos entre registros / pilha.  Para uma descrição completa, consulte a página 17 "System V ABI". </p><br><p>  Introduzimos várias classes de objetos: </p><br><ul><li>  <strong>INTEGER</strong> - Tipos integrais colocados em registros gerais.  Estes são <code>bool</code> , <code>char</code> , <code>int</code> e assim por diante. </li><li>  <strong>SSE</strong> são números de ponto flutuante que se ajustam a um registro vetorial.  Estes são <code>float</code> e <code>double</code> . </li><li>  <strong>MEMORY</strong> - objetos passados ​​pela pilha. </li></ul><br><p>  Para unificar a descrição, os tipos <code>__int128</code> e <code>complex</code> <code>__int128</code> representados como estruturas de dois campos: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> __</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">int128</span></span></span><span class="hljs-class"> {</span></span> int64 low, high; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">complexT</span></span></span><span class="hljs-class"> {</span></span> T real, imag; }; <span class="hljs-comment"><span class="hljs-comment">//  T - float,  double.</span></span></code> </pre> <br><p>  No início, cada argumento de função é classificado: </p><br><ol><li>  Se o tipo for maior que 128 bits ou tiver campos não alinhados, será <strong>MEMORY</strong> . </li><li>  Se houver um destruidor não trivial, construtor de cópias, métodos virtuais, classes base virtuais, ele será passado por um "link transparente".  O objeto é substituído por um ponteiro do tipo <strong>INTEGER</strong> . </li><li>  Agregados, e estas são estruturas e matrizes, são analisados ​​em partes de <strong>8 bytes</strong> . <br><ol><li>  Se houver um campo do tipo <strong>MEMORY</strong> na peça, a peça inteira será <strong>MEMORY</strong> . </li><li>  Se houver um campo do tipo <strong>INTEGER</strong> , a peça inteira será <strong>INTEGER</strong> . </li><li>  Caso contrário, toda a peça do <strong>SSE</strong> . </li></ol></li><li>  Se houver um pedaço do tipo <strong>MEMORY</strong> , o argumento inteiro será <strong>MEMORY</strong> . </li><li>  Os tipos <code>long double</code> e <code>complex long double</code> usam um conjunto especial de registros <code>x87 FPU</code> e são do tipo <strong>MEMORY</strong> . </li><li>  Os <code>__m256</code> , <code>__m128</code> e <code>__float128</code> são do tipo <strong>SSE</strong> . </li></ol><br><p>  Após a classificação, todos os pedaços de <strong>8 bytes</strong> (em um pedaço podem haver vários campos da estrutura ou elementos da matriz) são distribuídos nos registros: </p><br><ol><li>  <strong>MEMORY</strong> são passados ​​pela pilha. </li><li>  <strong>INTEGERs</strong> são transmitidos através do próximo registro gratuito <code>rdi, rsi, rdx, rcx, r8, r9</code> nessa ordem. </li><li>  <strong>As SSEs</strong> são transmitidas através do próximo registro gratuito <code>xmm0 - xmm7</code> . </li></ol><br><p>  Os argumentos são considerados da esquerda para a direita.  Os argumentos que não tinham registros suficientes são transmitidos pela pilha.  Se alguma parte do argumento não tiver um registrador, o argumento inteiro será passado pela pilha. </p><br><p>  Os valores de retorno são os seguintes: </p><br><ol><li>  <strong>Os</strong> tipos de <strong>MEMÓRIA</strong> são retornados através da pilha.  O local é fornecido pela função de chamada e o endereço de seu início é passado por <code>rdi</code> como se fosse o primeiro argumento para a função.  Ao retornar, esse endereço deve ser retornado via <code>rax</code> .  O primeiro argumento original será passado, respectivamente, como o segundo e assim por diante. </li><li>  <strong>O</strong> pedaço <strong>INTEGER</strong> é retornado através do próximo registro gratuito <code>rax, rdx</code> . </li><li>  <strong>O</strong> pedaço <strong>SSE</strong> é retornado através do próximo registro gratuito <code>xmm0, xmm1</code> .  Esses registradores são usados ​​para receber e retornar valores. </li></ol><br><p>  Uma tabela dinâmica com registradores e seu objetivo é muito útil ao ler o assembler: </p><br><table><thead><tr><th>  Registre-se </th><th>  Nomeação </th></tr></thead><tbody><tr><td> <code>rax</code> </td> <td>  Registro temporário, retorne o primeiro resultado (ret 1) <strong>INTEGER</strong> . </td></tr><tr><td> <code>rbx</code> </td> <td>  Pertence à função de chamada, não deve ser alterado no momento do retorno. </td></tr><tr><td> <code>rcx</code> </td> <td>  Passando o quarto (4) argumento <strong>INTEGER</strong> . </td></tr><tr><td> <code>rdx</code> </td> <td>  Passando o terceiro (3) argumento <strong>INTEGER</strong> , retornando o segundo (ret 2) resultado <strong>INTEGER</strong> . </td></tr><tr><td> <code>rsp</code> </td> <td>  Ponteiro para a pilha. </td></tr><tr><td> <code>rbp</code> </td> <td>  Pertence à função de chamada, não deve ser alterado no momento do retorno. </td></tr><tr><td> <code>rsi</code> </td> <td>  Passando o segundo (2) argumento <strong>INTEGER</strong> . </td></tr><tr><td> <code>rdi</code> </td> <td>  Passando o primeiro (1) argumento <strong>INTEGER</strong> . </td></tr><tr><td> <code>r8</code> </td> <td>  Passando o quinto (5) argumento <strong>INTEGER</strong> . </td></tr><tr><td> <code>r9</code> </td> <td>  Passando o sexto (6) argumento <strong>INTEGER</strong> . </td></tr><tr><td> <code>r10-r11</code> </td> <td>  Registros temporários. </td></tr><tr><td> <code>r12-r15</code> </td> <td>  Pertence à função de chamada, não deve ser alterado no momento do retorno. </td></tr><tr><td> <code>xmm0-xmm1</code> </td> <td>  Passe e retorne o primeiro e o segundo argumentos do <strong>SSE</strong> . </td></tr><tr><td> <code>xmm2-xmm7</code> </td> <td>  Passando do terceiro ao sexto argumento <strong>SSE</strong> . </td></tr><tr><td> <code>xmm8-xmm15</code> </td> <td>  Registros temporários. </td></tr></tbody></table><br><p>  Registros pertencentes à função de chamada não devem ser usados ​​ou seus valores devem ser armazenados em algum lugar, por exemplo, na pilha e, em seguida, restaurados. </p><br><h2 id="prostye-primery">  Exemplos simples </h2><br><p>  Salvo indicação explícita em contrário, todas as funções utilizadas foram marcadas como <code>NOINLINE</code> .  Fingimos que o corpo da função está localizado no arquivo cpp e o LTO está desativado.  Além disso, todos os resultados das funções são transferidos para uma função <code>NOINLINE</code> vazia para impedir que o otimizador exclua todo o código. </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NOINLINE __attribute__((noinline)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> INLINE static __attribute__((always_inline))</span></span></code> </pre> <br><p>  Considere algo simples. </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int64_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> d, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + b + c + d + x + y; } ... <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> result = foo(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>);</code> </pre> <br><p>  Os parâmetros são passados ​​assim: </p><br><table><thead><tr><th>  Primeiro nome </th><th>  Registre-se </th><th>  Primeiro nome </th><th>  Registre-se </th><th>  Resultado </th></tr></thead><tbody><tr><td>  <strong>a</strong> </td><td> <code>rdi</code> </td> <td>  <strong>d</strong> </td><td> <code>rcx</code> </td> <td> <code>xmm0</code> </td> </tr><tr><td>  <strong>b</strong> </td><td> <code>rsi</code> </td> <td>  <strong>x</strong> </td><td> <code>xmm0</code> </td> <td></td></tr><tr><td>  <strong>c</strong> </td><td> <code>rdx</code> </td> <td>  <strong>y</strong> </td><td> <code>xmm1</code> </td> <td></td></tr></tbody></table><br><p>  Considere o código gerado com mais detalhes. </p><br><pre> <code class="hljs pgsql">foo(signed <span class="hljs-type"><span class="hljs-type">char</span></span>, short, <span class="hljs-type"><span class="hljs-type">int</span></span>, long, <span class="hljs-type"><span class="hljs-type">float</span></span>, <span class="hljs-type"><span class="hljs-type">double</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> edi, esi #  a  b. <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> edi, edx #  c. movsxd rax, edi #    rax,    <span class="hljs-number"><span class="hljs-number">64</span></span>    . <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> rax, rcx #  d. vcvtsi2ss xmm2, xmm2, rax #    <span class="hljs-type"><span class="hljs-type">float</span></span>     xmm2. vaddss xmm0, xmm2, xmm0 #  x,  <span class="hljs-string"><span class="hljs-string">'s'</span></span>  vaddss    single <span class="hljs-type"><span class="hljs-type">precision</span></span>. vcvtss2sd xmm0, xmm0, xmm0 #    <span class="hljs-type"><span class="hljs-type">double</span></span>. vaddsd xmm0, xmm0, xmm1 #  y,  <span class="hljs-string"><span class="hljs-string">'d'</span></span>  vaddsd    <span class="hljs-type"><span class="hljs-type">double</span></span> <span class="hljs-type"><span class="hljs-type">precision</span></span>. ret #       ,    ,    ,   rsp   <span class="hljs-number"><span class="hljs-number">8.</span></span> .LCPI1_0: #    . .long <span class="hljs-number"><span class="hljs-number">1084227584</span></span> # <span class="hljs-type"><span class="hljs-type">float</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> .LCPI1_1: .quad <span class="hljs-number"><span class="hljs-number">4618441417868443648</span></span> # <span class="hljs-type"><span class="hljs-type">double</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span> main: # @main sub rsp, <span class="hljs-number"><span class="hljs-number">24</span></span> #     . vmovss xmm0, dword ptr [rip + .LCPI1_0] # xmm0 = mem[<span class="hljs-number"><span class="hljs-number">0</span></span>],zero,zero,zero vmovsd xmm1, qword ptr [rip + .LCPI1_1] # xmm1 = mem[<span class="hljs-number"><span class="hljs-number">0</span></span>],zero mov edi, <span class="hljs-number"><span class="hljs-number">1</span></span> mov esi, <span class="hljs-number"><span class="hljs-number">2</span></span> mov edx, <span class="hljs-number"><span class="hljs-number">3</span></span> mov ecx, <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> foo(signed <span class="hljs-type"><span class="hljs-type">char</span></span>, short, <span class="hljs-type"><span class="hljs-type">int</span></span>, long, <span class="hljs-type"><span class="hljs-type">float</span></span>, <span class="hljs-type"><span class="hljs-type">double</span></span>) # <span class="hljs-keyword"><span class="hljs-keyword">call</span></span>      ,    rsp  <span class="hljs-number"><span class="hljs-number">8</span></span>,      . vmovsd qword ptr [rsp + <span class="hljs-number"><span class="hljs-number">16</span></span>], xmm0 #     .</code> </pre> <br><p>  Se você passar parâmetros de tipos simples para uma função, precisará se esforçar para que eles não sejam transmitidos pelos registradores. </p><br><p>  Considere vários exemplos de agregados.  Matrizes podem ser consideradas estruturas com vários campos. </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">St</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> a, b; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(St s)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sa + sb; } ... St s{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> result = foo(s);</code> </pre> <br><table><thead><tr><th>  Primeiro nome </th><th>  Registre-se </th><th>  Primeiro nome </th><th>  Registre-se </th><th>  Resultado </th></tr></thead><tbody><tr><td>  <strong>sa</strong> </td><td> <code>xmm0</code> </td> <td>  <strong>sb</strong> </td><td> <code>xmm1</code> </td> <td> <code>xmm0</code> </td> </tr></tbody></table><br><p>  Parece que nada impede a <code>xmm</code> duas <code>double</code> em um registro <code>xmm</code> uma vez.  Mas, infelizmente, o algoritmo de distribuição opera apenas em blocos de oito bytes. </p><br><pre> <code class="hljs pgsql">foo(St): # @foo(St) vaddsd xmm0, xmm0, xmm1 #     ,       . ret .LCPI1_0: .quad <span class="hljs-number"><span class="hljs-number">4607182418800017408</span></span> # <span class="hljs-type"><span class="hljs-type">double</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> .LCPI1_1: .quad <span class="hljs-number"><span class="hljs-number">4611686018427387904</span></span> # <span class="hljs-type"><span class="hljs-type">double</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> main: # @main sub rsp, <span class="hljs-number"><span class="hljs-number">24</span></span> #   . vmovsd xmm0, qword ptr [rip + .LCPI1_0] # xmm0 = mem[<span class="hljs-number"><span class="hljs-number">0</span></span>],zero vmovsd xmm1, qword ptr [rip + .LCPI1_1] # xmm1 = mem[<span class="hljs-number"><span class="hljs-number">0</span></span>],zero <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> foo(St) vmovsd qword ptr [rsp + <span class="hljs-number"><span class="hljs-number">16</span></span>], xmm0 #  <span class="hljs-type"><span class="hljs-type">double</span></span>    .</code> </pre> <br><p>  Se você adicionar outro campo <code>double</code> , toda a estrutura será passada pela pilha, pois seu tamanho excederá 128 bytes. </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">St</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> a, b, c; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(St s)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sa + sb + sc; } ... St s{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> result = foo(s);</code> </pre> <br><pre> <code class="hljs pgsql">foo(St): # @foo(St) #   ,    <span class="hljs-number"><span class="hljs-number">8</span></span> ,     .        ,         rsp+<span class="hljs-number"><span class="hljs-number">8.</span></span> vmovsd xmm0, qword ptr [rsp + <span class="hljs-number"><span class="hljs-number">8</span></span>] # xmm0 = mem[<span class="hljs-number"><span class="hljs-number">0</span></span>],zero vaddsd xmm0, xmm0, qword ptr [rsp + <span class="hljs-number"><span class="hljs-number">16</span></span>] vaddsd xmm0, xmm0, qword ptr [rsp + <span class="hljs-number"><span class="hljs-number">24</span></span>] ret .L_ZZ4mainE1s: .quad <span class="hljs-number"><span class="hljs-number">4607182418800017408</span></span> # <span class="hljs-type"><span class="hljs-type">double</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> .quad <span class="hljs-number"><span class="hljs-number">4611686018427387904</span></span> # <span class="hljs-type"><span class="hljs-type">double</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> .quad <span class="hljs-number"><span class="hljs-number">4613937818241073152</span></span> # <span class="hljs-type"><span class="hljs-type">double</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> main: # @main sub rsp, <span class="hljs-number"><span class="hljs-number">40</span></span> #    <span class="hljs-number"><span class="hljs-number">40</span></span> . #       ,    .      ,   mov       . mov rax, qword ptr [rip + .L_ZZ4mainE1s+<span class="hljs-number"><span class="hljs-number">16</span></span>] #    <span class="hljs-string"><span class="hljs-string">'3'</span></span>. mov qword ptr [rsp + <span class="hljs-number"><span class="hljs-number">16</span></span>], rax #  <span class="hljs-string"><span class="hljs-string">'3'</span></span>  . vmovups xmm0, xmmword ptr [rip + .L_ZZ4mainE1s] #   xmm0  <span class="hljs-string"><span class="hljs-string">'1'</span></span>  <span class="hljs-string"><span class="hljs-string">'2'</span></span>. vmovups xmmword ptr [rsp], xmm0 #  <span class="hljs-string"><span class="hljs-string">'1'</span></span>  <span class="hljs-string"><span class="hljs-string">'2  .    : 1 = *rsp , 2 = *(rsp+8), 3 = *(rsp+16). call foo(St) vmovsd qword ptr [rsp + 32], xmm0 #     double  .</span></span></code> </pre> <br><p>  Vamos ver o que acontece se substituirmos <code>double</code> por <code>uint64_t</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">St</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> a, b; }; <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> foo(St s) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sa + sb; } ... St s{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> result = foo(s);</code> </pre> <br><table><thead><tr><th>  Primeiro nome </th><th>  Registre-se </th><th>  Primeiro nome </th><th>  Registre-se </th><th>  Resultado </th></tr></thead><tbody><tr><td>  <strong>sa</strong> </td><td> <code>rdi</code> </td> <td>  <strong>sb</strong> </td><td> <code>rsi</code> </td> <td> <code>rax</code> </td> </tr></tbody></table><br><pre> <code class="hljs kotlin">foo(St): # <span class="hljs-meta"><span class="hljs-meta">@foo(St)</span></span> lea rax, [rdi + rsi] ret main: # <span class="hljs-meta"><span class="hljs-meta">@main</span></span> sub rsp, <span class="hljs-number"><span class="hljs-number">24</span></span> mov edi, <span class="hljs-number"><span class="hljs-number">1</span></span> mov esi, <span class="hljs-number"><span class="hljs-number">2</span></span> call foo(St) mov qword ptr [rsp + <span class="hljs-number"><span class="hljs-number">16</span></span>], rax</code> </pre> <br><p>  O resultado é visivelmente mais compacto.  Mais informações sobre por que a instrução <code>lea</code> é usada em vez de <code>add</code> podem ser lidas, por exemplo, aqui: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://stackoverflow.com/a/6328441/1418863</a> </p><br><p>  Se você adicionar outro campo, como no exemplo <code>double</code> , a estrutura será passada pela pilha.  O código, a propósito, será quase idêntico, mesmo o carregamento na pilha será feito através de registros <code>xmm</code> . </p><br><p>  Considere algo mais interessante. </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">St</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> a, b, c, d; }; <span class="hljs-function"><span class="hljs-function">St </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(St s1, St s2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {s1.a + s2.a, s1.b + s2.b, s1.c + s2.c, s1.d + s2.d}; } ... St s1{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>}, s2{<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> result = foo(s1, s2);</code> </pre> <br><table><thead><tr><th>  Primeiro nome </th><th>  Registre-se </th><th>  Primeiro nome </th><th>  Registre-se </th><th>  Resultado </th></tr></thead><tbody><tr><td>  <strong>s1.a</strong> </td><td> <code>xmm0</code> </td> <td>  <strong>s1.b</strong> </td><td> <code>xmm0</code> </td> <td> <code>xmm0, xmm1</code> </td> </tr><tr><td>  <strong>s1.c</strong> </td><td> <code>xmm1</code> </td> <td>  <strong>s1.d</strong> </td><td> <code>xmm1</code> </td> <td></td></tr><tr><td>  <strong>s2.a</strong> </td><td> <code>xmm2</code> </td> <td>  <strong>s2.b</strong> </td><td> <code>xmm2</code> </td> <td></td></tr><tr><td>  <strong>s2.c</strong> </td><td> <code>xmm3</code> </td> <td>  <strong>s2.d</strong> </td><td> <code>xmm3</code> </td> <td></td></tr></tbody></table><br><p>  Dois campos <code>float</code> são inseridos em cada registrador <code>xmm</code> . </p><br><pre> <code class="hljs objectivec">foo(St, St): <span class="hljs-meta"><span class="hljs-meta"># @foo(St, St) #   vaddps    float . vaddps xmm0, xmm0, xmm2 vaddps xmm1, xmm1, xmm3 ret .LCPI1_0: .long 1065353216 # float 1 .long 1073741824 # float 2 .zero 4 .zero 4 #   LCPI1_1 - LCPI1_3. ... main: # @main sub rsp, 24 #  ,      . vmovapd xmm0, xmmword ptr [rip + .LCPI1_0] # xmm0 = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;1,2,u,u&gt;</span></span></span><span class="hljs-meta"> vmovapd xmm1, xmmword ptr [rip + .LCPI1_1] # xmm1 = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;3,4,u,u&gt;</span></span></span><span class="hljs-meta"> vmovaps xmm2, xmmword ptr [rip + .LCPI1_2] # xmm2 = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;5,6,u,u&gt;</span></span></span><span class="hljs-meta"> vmovaps xmm3, xmmword ptr [rip + .LCPI1_3] # xmm3 = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;7,8,u,u&gt;</span></span></span><span class="hljs-meta"> call foo(St, St) #        ,         . xmm   256 ,    128    a  b,   - c  d. vunpcklpd xmm0, xmm0, xmm1 # xmm0 = xmm0[0],xmm1[0] vmovupd xmmword ptr [rsp + 8], xmm0</span></span></code> </pre> <br><p>  Se a estrutura não tivesse 4, mas três campos, o código da função seria semelhante, exceto pela substituição da segunda instrução <code>vaddss</code> por <code>vaddss</code> , que adiciona apenas os primeiros 64 bits do registro. </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">St</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int32_t</span></span> a, b, c, d; }; <span class="hljs-function"><span class="hljs-function">St </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(St s1, St s2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {s1.a + s2.a, s1.b + s2.b, s1.c + s2.c, s1.d + s2.d}; } ... St s1{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>}, s2{<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> result = foo(s1, s2);</code> </pre> <br><table><thead><tr><th>  Primeiro nome </th><th>  Registre-se </th><th>  Primeiro nome </th><th>  Registre-se </th><th>  Resultado </th></tr></thead><tbody><tr><td>  <strong>s1.a</strong> </td><td> <code>rdi</code> </td> <td>  <strong>s1.b</strong> </td><td> <code>rdi</code> </td> <td> <code>rax, rdx</code> </td> </tr><tr><td>  <strong>s1.c</strong> </td><td> <code>rsi</code> </td> <td>  <strong>s1.d</strong> </td><td> <code>rsi</code> </td> <td></td></tr><tr><td>  <strong>s2.a</strong> </td><td> <code>rdx</code> </td> <td>  <strong>s2.b</strong> </td><td> <code>rdx</code> </td> <td></td></tr><tr><td>  <strong>s2.c</strong> </td><td> <code>rcx</code> </td> <td>  <strong>s2.d</strong> </td><td> <code>rcx</code> </td> <td></td></tr></tbody></table><br><pre> <code class="hljs pgsql">foo(St, St): # @foo(St, St) lea eax, [rdx + rdi] movabs r8, <span class="hljs-number"><span class="hljs-number">-4294967296</span></span> # <span class="hljs-number"><span class="hljs-number">0xFFFFFFFF00000000</span></span>  . <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> rdi, r8 <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> rdi, rdx <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> rdi, r8 <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> rax, rdi lea edx, [rcx + rsi] #  ,   <span class="hljs-keyword"><span class="hljs-keyword">add</span></span>. <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> rsi, r8 <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> rsi, rcx <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> rsi, r8 <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> rdx, rsi ret main: # @main sub rsp, <span class="hljs-number"><span class="hljs-number">24</span></span> movabs rdi, <span class="hljs-number"><span class="hljs-number">8589934593</span></span> #       . movabs rsi, <span class="hljs-number"><span class="hljs-number">17179869187</span></span> movabs rdx, <span class="hljs-number"><span class="hljs-number">25769803781</span></span> movabs rcx, <span class="hljs-number"><span class="hljs-number">34359738375</span></span> <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> foo(St, St) mov qword ptr [rsp + <span class="hljs-number"><span class="hljs-number">8</span></span>], rax #    . mov qword ptr [rsp + <span class="hljs-number"><span class="hljs-number">16</span></span>], rdx</code> </pre> <br><p>  Um pouco de mágica acontece dentro da função, mas o princípio é bastante claro.  Cada par de números de 32 bits é compactado em um registro de 64 bits.  Os reembolsos são feitos da mesma maneira. </p><br><p>  Vamos ver o que acontece se começarmos a misturar tipos de campo, mas para que, em blocos de 8 bytes, eles sejam da mesma classe. </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">St</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int32_t</span></span> a, b; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> c, d; }; <span class="hljs-function"><span class="hljs-function">St </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(St s1, St s2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {s1.a + s2.a, s1.b + s2.b, s1.c + s2.c, s1.d + s2.d}; } ... St s1{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>}, s2{<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> result = foo(s1, s2);</code> </pre> <br><table><thead><tr><th>  Primeiro nome </th><th>  Registre-se </th><th>  Primeiro nome </th><th>  Registre-se </th><th>  Resultado </th></tr></thead><tbody><tr><td>  <strong>s1.a</strong> </td><td> <code>rdi</code> </td> <td>  <strong>s1.b</strong> </td><td> <code>rdi</code> </td> <td> <code>rax, xmm0</code> </td> </tr><tr><td>  <strong>s1.c</strong> </td><td> <code>xmm0</code> </td> <td>  <strong>s1.d</strong> </td><td> <code>xmm0</code> </td> <td></td></tr><tr><td>  <strong>s2.a</strong> </td><td> <code>rsi</code> </td> <td>  <strong>s2.b</strong> </td><td> <code>rsi</code> </td> <td></td></tr><tr><td>  <strong>s2.c</strong> </td><td> <code>xmm1</code> </td> <td>  <strong>s2.d</strong> </td><td> <code>xmm1</code> </td> <td></td></tr></tbody></table><br><pre> <code class="hljs cpp">foo(St, St): # @foo(St, St) lea eax, [rsi + rdi] #     . movabs rcx, <span class="hljs-number"><span class="hljs-number">-4294967296</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> rdi, rcx add rdi, rsi <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> rdi, rcx <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> rax, rdi vaddps xmm0, xmm0, xmm1 #    . ret .LCPI1_0: .<span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-number"><span class="hljs-number">1077936128</span></span> <span class="hljs-meta"><span class="hljs-meta"># float 3 .long 1082130432 # float 4 .zero 4 .zero 4 ... main: # @main sub rsp, 24 vmovaps xmm0, xmmword ptr [rip + .LCPI1_0] # xmm0 = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;3,4,u,u&gt; vmovaps xmm1, xmmword ptr [rip + .LCPI1_1] # xmm1 = &lt;7,8,u,u&gt; movabs rdi, 8589934593 movabs rsi, 25769803781 call foo(St, St) mov qword ptr [rsp + 8], rax #    . vmovlps qword ptr [rsp + 16], xmm0</span></span></span></span></code> </pre> <br><p>  Mas isso não é interessante, pois os tipos de campos em cada bloco de 8 bytes são os mesmos.  Baralhe os campos. </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">St</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int32_t</span></span> a; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> b; <span class="hljs-keyword"><span class="hljs-keyword">int32_t</span></span> c; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> d; }; <span class="hljs-function"><span class="hljs-function">St </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(St s1, St s2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {s1.a + s2.a, s1.b + s2.b, s1.c + s2.c, s1.d + s2.d}; } ... St s1{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>}, s2{<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> result = foo(s1, s2);</code> </pre> <br><table><thead><tr><th>  Primeiro nome </th><th>  Registre-se </th><th>  Primeiro nome </th><th>  Registre-se </th><th>  Resultado </th></tr></thead><tbody><tr><td>  <strong>s1.a</strong> </td><td> <code>rdi</code> </td> <td>  <strong>s1.b</strong> </td><td> <code>rdi</code> </td> <td> <code>rax, rdx</code> </td> </tr><tr><td>  <strong>s1.c</strong> </td><td> <code>rsi</code> </td> <td>  <strong>s1.d</strong> </td><td> <code>rsi</code> </td> <td></td></tr><tr><td>  <strong>s2.a</strong> </td><td> <code>rdx</code> </td> <td>  <strong>s2.b</strong> </td><td> <code>rdx</code> </td> <td></td></tr><tr><td>  <strong>s2.c</strong> </td><td> <code>rcx</code> </td> <td>  <strong>s2.d</strong> </td><td> <code>rcx</code> </td> <td></td></tr></tbody></table><br><p>  Veja o parágrafo 3.2.  Como o pedaço de 8 bytes contém <code>float</code> e <code>int</code> , o pedaço inteiro será do tipo <strong>INTEGER</strong> e será passado nos registros gerais. </p><br><pre> <code class="hljs delphi">foo(St, St): # @foo(St, St) mov rax, rdx add edx, edi <span class="hljs-keyword"><span class="hljs-keyword">shr</span></span> rdi, <span class="hljs-number"><span class="hljs-number">32</span></span> vmovd xmm0, edi mov rdi, rcx add ecx, esi <span class="hljs-keyword"><span class="hljs-keyword">shr</span></span> rsi, <span class="hljs-number"><span class="hljs-number">32</span></span> vmovd xmm1, esi <span class="hljs-keyword"><span class="hljs-keyword">shr</span></span> rax, <span class="hljs-number"><span class="hljs-number">32</span></span> vmovd xmm2, eax vaddss xmm0, xmm0, xmm2 <span class="hljs-keyword"><span class="hljs-keyword">shr</span></span> rdi, <span class="hljs-number"><span class="hljs-number">32</span></span> vmovd xmm2, edi vaddss xmm1, xmm1, xmm2 vmovd eax, xmm0 <span class="hljs-keyword"><span class="hljs-keyword">shl</span></span> rax, <span class="hljs-number"><span class="hljs-number">32</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> rdx, rax vmovd eax, xmm1 <span class="hljs-keyword"><span class="hljs-keyword">shl</span></span> rax, <span class="hljs-number"><span class="hljs-number">32</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> rcx, rax mov rax, rdx mov rdx, rcx ret main: # @main sub rsp, <span class="hljs-number"><span class="hljs-number">24</span></span> movabs rdi, <span class="hljs-number"><span class="hljs-number">4611686018427387905</span></span> # <span class="hljs-number"><span class="hljs-number">0</span></span>x4000000000000001,   <span class="hljs-number"><span class="hljs-number">32</span></span>   int,   - float. movabs rsi, <span class="hljs-number"><span class="hljs-number">4647714815446351875</span></span> movabs rdx, <span class="hljs-number"><span class="hljs-number">4665729213955833861</span></span> movabs rcx, <span class="hljs-number"><span class="hljs-number">4683743612465315847</span></span> call foo(St, St) mov qword ptr [rsp + <span class="hljs-number"><span class="hljs-number">8</span></span>], rax #      <span class="hljs-number"><span class="hljs-number">64</span></span>  . mov qword ptr [rsp + <span class="hljs-number"><span class="hljs-number">16</span></span>], rdx</code> </pre> <br><p>  Aqui você pode ver 6 operações de turno para extrair campos <code>float</code> e enviá-los para o registro com o resultado.  Bem como a ausência de qualquer operação vetorial.  Em geral, é melhor não interferir com os tipos de campo em pedaços de 8 bytes da estrutura. </p><br><h2 id="peredacha-po-ssylke">  Passar por link </h2><br><p>  Passar parâmetros através de uma referência constante é semelhante a passar um ponteiro para um objeto.  Se o objeto não couber nos registradores, ele é passado e retornado pela pilha.  Vamos ver como isso acontece.  Para realismo, considere a estrutura para um ponto tridimensional. </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point3f</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x, y, z; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point3d</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> x, y, z; }; <span class="hljs-function"><span class="hljs-function">Point3f </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scale</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Point3f p)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {px * <span class="hljs-number"><span class="hljs-number">2</span></span>, py * <span class="hljs-number"><span class="hljs-number">2</span></span>, pz * <span class="hljs-number"><span class="hljs-number">2</span></span>}; } <span class="hljs-function"><span class="hljs-function">Point3f </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scaleR</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Point3f&amp; p)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {px * <span class="hljs-number"><span class="hljs-number">2</span></span>, py * <span class="hljs-number"><span class="hljs-number">2</span></span>, pz * <span class="hljs-number"><span class="hljs-number">2</span></span>}; } <span class="hljs-function"><span class="hljs-function">Point3d </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scale</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Point3d p)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {px * <span class="hljs-number"><span class="hljs-number">2</span></span>, py * <span class="hljs-number"><span class="hljs-number">2</span></span>, pz * <span class="hljs-number"><span class="hljs-number">2</span></span>}; } <span class="hljs-function"><span class="hljs-function">Point3d </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scaleR</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Point3d&amp; p)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {px * <span class="hljs-number"><span class="hljs-number">2</span></span>, py * <span class="hljs-number"><span class="hljs-number">2</span></span>, pz * <span class="hljs-number"><span class="hljs-number">2</span></span>}; }</code> </pre> <br><p>  Compare o código da função.  Principalmente novos registros <code>xmm</code> serão usados, portanto a lógica é compreensível. </p><br><pre> <code class="hljs kotlin">scale(Point3f): # <span class="hljs-meta"><span class="hljs-meta">@scale(Point3f)</span></span> #     , x, y   xmm0, z - xmm1,     . vaddps xmm0, xmm0, xmm0 vaddss xmm1, xmm1, xmm1 ret scaleR(Point3f <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp;): # <span class="hljs-meta"><span class="hljs-meta">@scaleR(Point3f const&amp;)</span></span> #       rdi,     .      xmm0, xmm1. vmovsd xmm0, qword ptr [rdi] # xmm0 = mem[<span class="hljs-number"><span class="hljs-number">0</span></span>],zero vaddps xmm0, xmm0, xmm0 vmovss xmm1, dword ptr [rdi + <span class="hljs-number"><span class="hljs-number">8</span></span>] # xmm1 = mem[<span class="hljs-number"><span class="hljs-number">0</span></span>],zero,zero,zero vaddss xmm1, xmm1, xmm1 ret scale(Point3d): # <span class="hljs-meta"><span class="hljs-meta">@scale(Point3d)</span></span> #   rdi  ,     .          [rsp+<span class="hljs-number"><span class="hljs-number">8</span></span>, rsp+<span class="hljs-number"><span class="hljs-number">32</span></span>).  [rsp, rsp+<span class="hljs-number"><span class="hljs-number">8</span></span>)     . vmovapd xmm0, xmmword ptr [rsp + <span class="hljs-number"><span class="hljs-number">8</span></span>] vaddpd xmm0, xmm0, xmm0 vmovupd xmmword ptr [rdi], xmm0 vmovsd xmm0, qword ptr [rsp + <span class="hljs-number"><span class="hljs-number">24</span></span>] # xmm0 = mem[<span class="hljs-number"><span class="hljs-number">0</span></span>],zero vaddsd xmm0, xmm0, xmm0 vmovsd qword ptr [rdi + <span class="hljs-number"><span class="hljs-number">16</span></span>], xmm0 mov rax, rdi #  ,    . ret scaleR(Point3d <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp;): # <span class="hljs-meta"><span class="hljs-meta">@scaleR(Point3d const&amp;)</span></span> #   ,      [rsp+<span class="hljs-number"><span class="hljs-number">8</span></span>, rsp+<span class="hljs-number"><span class="hljs-number">32</span></span>),   [rsi, rsi+<span class="hljs-number"><span class="hljs-number">24</span></span>). vmovupd xmm0, xmmword ptr [rsi] vaddpd xmm0, xmm0, xmm0 vmovupd xmmword ptr [rdi], xmm0 vmovsd xmm0, qword ptr [rsi + <span class="hljs-number"><span class="hljs-number">16</span></span>] # xmm0 = mem[<span class="hljs-number"><span class="hljs-number">0</span></span>],zero vaddsd xmm0, xmm0, xmm0 vmovsd qword ptr [rdi + <span class="hljs-number"><span class="hljs-number">16</span></span>], xmm0 mov rax, rdi ret</code> </pre> <br><p>  Agora vamos ver o local onde essas funções são chamadas. </p><br><pre> <code class="hljs vbscript"># scale(Point3f) main: # @main <span class="hljs-keyword"><span class="hljs-keyword">sub</span></span> rsp, <span class="hljs-number"><span class="hljs-number">24</span></span> #     . vmovaps xmm0, xmmword ptr [rip + .LCPI4_0] # xmm0 = &lt;<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,u,u&gt; vmovss xmm1, dword ptr [rip + .LCPI4_1] # xmm1 = &lt;<span class="hljs-number"><span class="hljs-number">3</span></span>,u,u,u&gt; <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> scale(Point3f) # scaleR(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Point3f&amp;) main: # @main <span class="hljs-keyword"><span class="hljs-keyword">sub</span></span> rsp, <span class="hljs-number"><span class="hljs-number">24</span></span> #         rdi,     . mov edi, .L_ZZ4mainE1p # &lt;<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,u&gt; <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> scaleR(Point3f <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp;) # scale(Point3d) main: # @main <span class="hljs-keyword"><span class="hljs-keyword">sub</span></span> rsp, <span class="hljs-number"><span class="hljs-number">64</span></span> #        . mov rax, qword ptr [rip + .L_ZZ4mainE1p+<span class="hljs-number"><span class="hljs-number">16</span></span>] mov qword ptr [rsp + <span class="hljs-number"><span class="hljs-number">16</span></span>], rax vmovups xmm0, xmmword ptr [rip + .L_ZZ4mainE1p] vmovups xmmword ptr [rsp], xmm0 lea rbx, [rsp + <span class="hljs-number"><span class="hljs-number">40</span></span>] mov rdi, rbx #     [rsp+<span class="hljs-number"><span class="hljs-number">40</span></span>, rsp+<span class="hljs-number"><span class="hljs-number">64</span></span>). <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> scale(Point3d) .L_ZZ4mainE1p: .quad <span class="hljs-number"><span class="hljs-number">4607182418800017408</span></span> # double <span class="hljs-number"><span class="hljs-number">1</span></span> .quad <span class="hljs-number"><span class="hljs-number">4611686018427387904</span></span> # double <span class="hljs-number"><span class="hljs-number">2</span></span> .quad <span class="hljs-number"><span class="hljs-number">4613937818241073152</span></span> # double <span class="hljs-number"><span class="hljs-number">3</span></span> # scaleR(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Point3d&amp;) main: # @main <span class="hljs-keyword"><span class="hljs-keyword">sub</span></span> rsp, <span class="hljs-number"><span class="hljs-number">64</span></span> #   . mov rax, qword ptr [rip + .L_ZZ4mainE1p+<span class="hljs-number"><span class="hljs-number">16</span></span>] mov qword ptr [rsp + <span class="hljs-number"><span class="hljs-number">32</span></span>], rax vmovups xmm0, xmmword ptr [rip + .L_ZZ4mainE1p] vmovaps xmmword ptr [rsp + <span class="hljs-number"><span class="hljs-number">16</span></span>], xmm0 lea rbx, [rsp + <span class="hljs-number"><span class="hljs-number">40</span></span>] lea rsi, [rsp + <span class="hljs-number"><span class="hljs-number">16</span></span>] #     [rsp+<span class="hljs-number"><span class="hljs-number">16</span></span>, rsp+<span class="hljs-number"><span class="hljs-number">40</span></span>). mov rdi, rbx #     [rsp+<span class="hljs-number"><span class="hljs-number">40</span></span>, rsp+<span class="hljs-number"><span class="hljs-number">64</span></span>). <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> scaleR(Point3d <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp;)</code> </pre> <br><p>  Vamos ver se temos muitos campos, mas a estrutura ainda se encaixa nos registros.  Aqui a diversão começa. </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">St</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> d[<span class="hljs-number"><span class="hljs-number">16</span></span>]; }; <span class="hljs-function"><span class="hljs-function">St </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(St s1, St s2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   s1  s2. St res; for(int i{}; i &lt; 16; ++i) res.d[i] = s1.d[i] + s2.d[i]; return res; }</span></span></code> </pre> <br><p>  Código para uma função que aceita argumentos por valor. </p><br><table><thead><tr><th>  Primeiro nome </th><th>  Registre-se </th><th>  Primeiro nome </th><th>  Registre-se </th><th>  Resultado </th></tr></thead><tbody><tr><td>  <strong>s1.d [1: 8]</strong> </td><td> <code>rdi</code> </td> <td>  <strong>s1.d [8:16]</strong> </td><td> <code>rsi</code> </td> <td> <code>rax, rdx</code> </td> </tr><tr><td>  <strong>s2.d [1: 8]</strong> </td><td> <code>rdx</code> </td> <td>  <strong>s2.d [8:16]</strong> </td><td> <code>rcx</code> </td> <td></td></tr></tbody></table><br><pre> <code class="hljs lua">foo(St, St): # @foo(St, St) mov qword ptr [rsp - <span class="hljs-number"><span class="hljs-number">16</span></span>], rdi mov qword ptr [rsp - <span class="hljs-number"><span class="hljs-number">8</span></span>], rsi mov qword ptr [rsp - <span class="hljs-number"><span class="hljs-number">32</span></span>], rdx mov qword ptr [rsp - <span class="hljs-number"><span class="hljs-number">24</span></span>], rcx mov eax, edx add al, dil mov <span class="hljs-built_in"><span class="hljs-built_in">byte</span></span> ptr [rsp - <span class="hljs-number"><span class="hljs-number">48</span></span>], al mov r8, rdi shr r8, <span class="hljs-number"><span class="hljs-number">8</span></span> mov rax, rdx shr rax, <span class="hljs-number"><span class="hljs-number">8</span></span> add al, r8b mov <span class="hljs-built_in"><span class="hljs-built_in">byte</span></span> ptr [rsp - <span class="hljs-number"><span class="hljs-number">47</span></span>], al mov r8, rdi shr r8, <span class="hljs-number"><span class="hljs-number">16</span></span> mov rax, rdx shr rax, <span class="hljs-number"><span class="hljs-number">16</span></span> add al, r8b mov <span class="hljs-built_in"><span class="hljs-built_in">byte</span></span> ptr [rsp - <span class="hljs-number"><span class="hljs-number">46</span></span>], al mov r8, rdi shr r8, <span class="hljs-number"><span class="hljs-number">24</span></span> mov rax, rdx shr rax, <span class="hljs-number"><span class="hljs-number">24</span></span> add al, r8b mov <span class="hljs-built_in"><span class="hljs-built_in">byte</span></span> ptr [rsp - <span class="hljs-number"><span class="hljs-number">45</span></span>], al mov r8, rdi shr r8, <span class="hljs-number"><span class="hljs-number">32</span></span> mov rax, rdx shr rax, <span class="hljs-number"><span class="hljs-number">32</span></span> add al, r8b mov <span class="hljs-built_in"><span class="hljs-built_in">byte</span></span> ptr [rsp - <span class="hljs-number"><span class="hljs-number">44</span></span>], al mov r8, rdi shr r8, <span class="hljs-number"><span class="hljs-number">40</span></span> mov rax, rdx shr rax, <span class="hljs-number"><span class="hljs-number">40</span></span> add al, r8b mov <span class="hljs-built_in"><span class="hljs-built_in">byte</span></span> ptr [rsp - <span class="hljs-number"><span class="hljs-number">43</span></span>], al mov r8, rdi shr r8, <span class="hljs-number"><span class="hljs-number">48</span></span> mov rax, rdx shr rax, <span class="hljs-number"><span class="hljs-number">48</span></span> add al, r8b mov <span class="hljs-built_in"><span class="hljs-built_in">byte</span></span> ptr [rsp - <span class="hljs-number"><span class="hljs-number">42</span></span>], al shr rdi, <span class="hljs-number"><span class="hljs-number">56</span></span> shr rdx, <span class="hljs-number"><span class="hljs-number">56</span></span> add dl, dil mov <span class="hljs-built_in"><span class="hljs-built_in">byte</span></span> ptr [rsp - <span class="hljs-number"><span class="hljs-number">41</span></span>], dl mov eax, ecx add al, sil mov <span class="hljs-built_in"><span class="hljs-built_in">byte</span></span> ptr [rsp - <span class="hljs-number"><span class="hljs-number">40</span></span>], al mov rax, rsi shr rax, <span class="hljs-number"><span class="hljs-number">8</span></span> mov rdx, rcx shr rdx, <span class="hljs-number"><span class="hljs-number">8</span></span> add dl, al mov <span class="hljs-built_in"><span class="hljs-built_in">byte</span></span> ptr [rsp - <span class="hljs-number"><span class="hljs-number">39</span></span>], dl shr rsi, <span class="hljs-number"><span class="hljs-number">16</span></span> shr rcx, <span class="hljs-number"><span class="hljs-number">16</span></span> add cl, sil mov <span class="hljs-built_in"><span class="hljs-built_in">byte</span></span> ptr [rsp - <span class="hljs-number"><span class="hljs-number">38</span></span>], cl mov al, <span class="hljs-built_in"><span class="hljs-built_in">byte</span></span> ptr [rsp - <span class="hljs-number"><span class="hljs-number">21</span></span>] mov cl, <span class="hljs-built_in"><span class="hljs-built_in">byte</span></span> ptr [rsp - <span class="hljs-number"><span class="hljs-number">20</span></span>] add al, <span class="hljs-built_in"><span class="hljs-built_in">byte</span></span> ptr [rsp - <span class="hljs-number"><span class="hljs-number">5</span></span>] mov <span class="hljs-built_in"><span class="hljs-built_in">byte</span></span> ptr [rsp - <span class="hljs-number"><span class="hljs-number">37</span></span>], al add cl, <span class="hljs-built_in"><span class="hljs-built_in">byte</span></span> ptr [rsp - <span class="hljs-number"><span class="hljs-number">4</span></span>] mov <span class="hljs-built_in"><span class="hljs-built_in">byte</span></span> ptr [rsp - <span class="hljs-number"><span class="hljs-number">36</span></span>], cl mov al, <span class="hljs-built_in"><span class="hljs-built_in">byte</span></span> ptr [rsp - <span class="hljs-number"><span class="hljs-number">19</span></span>] mov cl, <span class="hljs-built_in"><span class="hljs-built_in">byte</span></span> ptr [rsp - <span class="hljs-number"><span class="hljs-number">18</span></span>] add al, <span class="hljs-built_in"><span class="hljs-built_in">byte</span></span> ptr [rsp - <span class="hljs-number"><span class="hljs-number">3</span></span>] mov <span class="hljs-built_in"><span class="hljs-built_in">byte</span></span> ptr [rsp - <span class="hljs-number"><span class="hljs-number">35</span></span>], al add cl, <span class="hljs-built_in"><span class="hljs-built_in">byte</span></span> ptr [rsp - <span class="hljs-number"><span class="hljs-number">2</span></span>] mov <span class="hljs-built_in"><span class="hljs-built_in">byte</span></span> ptr [rsp - <span class="hljs-number"><span class="hljs-number">34</span></span>], cl mov al, <span class="hljs-built_in"><span class="hljs-built_in">byte</span></span> ptr [rsp - <span class="hljs-number"><span class="hljs-number">17</span></span>] add al, <span class="hljs-built_in"><span class="hljs-built_in">byte</span></span> ptr [rsp - <span class="hljs-number"><span class="hljs-number">1</span></span>] mov <span class="hljs-built_in"><span class="hljs-built_in">byte</span></span> ptr [rsp - <span class="hljs-number"><span class="hljs-number">33</span></span>], al mov rax, qword ptr [rsp - <span class="hljs-number"><span class="hljs-number">48</span></span>] mov rdx, qword ptr [rsp - <span class="hljs-number"><span class="hljs-number">40</span></span>] ret</code> </pre> <br><p>  Sim, aqui todos os argumentos são copiados para a pilha, após o que são extraídos e adicionados um byte de cada vez.  Como você pode ver, existem exatamente 16 instruções de <code>add</code> na função.  A propósito, o GCC, neste exemplo, produz um código muito mais compacto, mas ainda com a cópia na pilha.  Alguma coisa pode ser melhorada?  Passe a estrutura por referência. </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">St </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fooR</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> St&amp; s1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> St&amp; s2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*  . */</span></span> }</code> </pre> <br><table><thead><tr><th>  Primeiro nome </th><th>  Registre-se </th><th>  Primeiro nome </th><th>  Registre-se </th><th>  Resultado </th></tr></thead><tbody><tr><td>  <strong>s1</strong> </td><td> <code>rdi</code> </td> <td>  <strong>s2</strong> </td><td> <code>rsi</code> </td> <td> <code>rax, rdx</code> </td> </tr></tbody></table><br><pre> <code class="hljs vbscript">fooR(St <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp;, St <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp;): # @fooR(St <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp;, St <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp;) vmovdqu xmm0, xmmword ptr [rsi] vpaddb xmm0, xmm0, xmmword ptr [rdi] vmovdqa xmmword ptr [rsp - <span class="hljs-number"><span class="hljs-number">24</span></span>], xmm0 mov rax, qword ptr [rsp - <span class="hljs-number"><span class="hljs-number">24</span></span>] mov rdx, qword ptr [rsp - <span class="hljs-number"><span class="hljs-number">16</span></span>] ret</code> </pre> <br><p>  Ah sim!  Parece muito melhor.  Podemos carregar 16 elementos de byte único de uma vez no registrador <code>xmm</code> e chamar <code>vpaddb</code> que os <code>vpaddb</code> todos em uma operação.  Depois disso, o resultado é copiado para os registros de saída através da pilha.  Você pode pensar que pode se livrar dessa última operação substituindo o primeiro argumento por uma referência não constante. </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fooR1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(St &amp;s1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> St&amp; s2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i{}; i &lt; <span class="hljs-number"><span class="hljs-number">16</span></span>; ++i) s1.d[i] += s2.d[i]; }</code> </pre> <br><table><thead><tr><th>  Primeiro nome </th><th>  Registre-se </th><th>  Primeiro nome </th><th>  Registre-se </th><th>  Resultado </th></tr></thead><tbody><tr><td>  <strong>s1</strong> </td><td> <code>rdi</code> </td> <td>  <strong>s2</strong> </td><td> <code>rsi</code> </td> <td></td></tr></tbody></table><br><pre> <code class="hljs go">fooR1(St&amp;, St <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp;): # @fooR1(St&amp;, St <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp;) mov al, <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> ptr [rsi] add <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> ptr [rdi], al mov al, <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> ptr [rsi + <span class="hljs-number"><span class="hljs-number">1</span></span>] add <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> ptr [rdi + <span class="hljs-number"><span class="hljs-number">1</span></span>], al mov al, <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> ptr [rsi + <span class="hljs-number"><span class="hljs-number">2</span></span>] add <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> ptr [rdi + <span class="hljs-number"><span class="hljs-number">2</span></span>], al mov al, <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> ptr [rsi + <span class="hljs-number"><span class="hljs-number">3</span></span>] add <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> ptr [rdi + <span class="hljs-number"><span class="hljs-number">3</span></span>], al mov al, <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> ptr [rsi + <span class="hljs-number"><span class="hljs-number">4</span></span>] add <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> ptr [rdi + <span class="hljs-number"><span class="hljs-number">4</span></span>], al mov al, <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> ptr [rsi + <span class="hljs-number"><span class="hljs-number">5</span></span>] add <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> ptr [rdi + <span class="hljs-number"><span class="hljs-number">5</span></span>], al mov al, <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> ptr [rsi + <span class="hljs-number"><span class="hljs-number">6</span></span>] add <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> ptr [rdi + <span class="hljs-number"><span class="hljs-number">6</span></span>], al mov al, <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> ptr [rsi + <span class="hljs-number"><span class="hljs-number">7</span></span>] add <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> ptr [rdi + <span class="hljs-number"><span class="hljs-number">7</span></span>], al mov al, <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> ptr [rsi + <span class="hljs-number"><span class="hljs-number">8</span></span>] add <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> ptr [rdi + <span class="hljs-number"><span class="hljs-number">8</span></span>], al mov al, <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> ptr [rsi + <span class="hljs-number"><span class="hljs-number">9</span></span>] add <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> ptr [rdi + <span class="hljs-number"><span class="hljs-number">9</span></span>], al mov al, <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> ptr [rsi + <span class="hljs-number"><span class="hljs-number">10</span></span>] add <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> ptr [rdi + <span class="hljs-number"><span class="hljs-number">10</span></span>], al mov al, <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> ptr [rsi + <span class="hljs-number"><span class="hljs-number">11</span></span>] add <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> ptr [rdi + <span class="hljs-number"><span class="hljs-number">11</span></span>], al mov al, <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> ptr [rsi + <span class="hljs-number"><span class="hljs-number">12</span></span>] add <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> ptr [rdi + <span class="hljs-number"><span class="hljs-number">12</span></span>], al mov al, <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> ptr [rsi + <span class="hljs-number"><span class="hljs-number">13</span></span>] add <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> ptr [rdi + <span class="hljs-number"><span class="hljs-number">13</span></span>], al mov al, <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> ptr [rsi + <span class="hljs-number"><span class="hljs-number">14</span></span>] add <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> ptr [rdi + <span class="hljs-number"><span class="hljs-number">14</span></span>], al mov al, <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> ptr [rsi + <span class="hljs-number"><span class="hljs-number">15</span></span>] add <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> ptr [rdi + <span class="hljs-number"><span class="hljs-number">15</span></span>], al ret</code> </pre> <br><p>  Algo parece ter dado errado.  Isso aconteceu porque, por padrão, o compilador é muito cuidadoso e sugere que o programador pode estar fora de ordem e escrever algo como isto: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buff[<span class="hljs-number"><span class="hljs-number">17</span></span>]; fooR1(*<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;St*&gt;(buff+<span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> St*&gt;(buff));</code> </pre> <br><p>  Nesse caso, o <code>buff[i+1] += buff[i]</code> calculado a cada iteração, ou seja, o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">alias do ponteiro</a> está disponível.  ,   ,       ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">__restrict</a> . </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fooR2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(St &amp; __restrict s1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> St&amp; s2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*  . */</span></span> }</code> </pre> <br><p>     . </p><br><pre> <code class="hljs kotlin">fooR2(St&amp;, St <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp;): # <span class="hljs-meta"><span class="hljs-meta">@fooR2(St&amp;, St const&amp;)</span></span> vmovdqu xmm0, xmmword ptr [rdi] vpaddb xmm0, xmm0, xmmword ptr [rsi] vmovdqu xmmword ptr [rdi], xmm0 ret</code> </pre> <br><p>    <code>void fooR3(St &amp;__restrict s1, St s2)</code> ,      ,      <code>St foo(St, St)</code> . </p><br><p> ,      ,  <code>void foo(char* __restrict s1, const char* s2, int size)</code>        ,    <code>__restrict</code> . </p><br><h3 id="sravnenie-proizvoditelnosti">   </h3><br><p>     <code>b</code>  <code>a</code> ,  ,  <code>foo</code>    : </p><br><pre> <code class="cpp hljs">St a, b; st(a, b); <span class="hljs-comment"><span class="hljs-comment">// st(St&amp; a, St&amp; b) { a = b = {}; }   . a = foo(a, b); a = foo(a, b); a = foo(a, b); a = foo(a, b);</span></span></code> </pre> <br><table><thead><tr><th> Code </th><th> Cycles per iteration </th></tr></thead><tbody><tr><td> <code>St a, b; st(a, b);</code> </td> <td> 7.6 </td></tr><tr><td> 4 x <code>foo</code> no reuse </td><td> 121.9 </td></tr><tr><td> 4 x <code>foo</code> </td><td> 117.7 </td></tr><tr><td> 4 x <code>fooR</code> no reuse </td><td> 66.3 </td></tr><tr><td> 4 x <code>fooR</code> </td><td> 64.6 </td></tr><tr><td> 4 x <code>fooR1</code> </td><td> 84.5 </td></tr><tr><td> 4 x <code>fooR2</code> </td><td> 20.6 </td></tr><tr><td> 4 x <code>foo</code> inline </td><td> 51.9 </td></tr><tr><td> 4 x <code>fooR</code> inline </td><td> 30.5 </td></tr><tr><td> 4 x <code>fooR1</code> inline </td><td> 8.8 </td></tr><tr><td> 4 x <code>fooR2</code> inline </td><td> 8.8 </td></tr></tbody></table><br><p> 'no reuse'   ,        . <code>auto a2 = foo(a, b); auto a3 = foo(a2, b);</code>  . 'inline' ,     <strong>INLINE</strong> ,   <strong>NOINLINE</strong> . </p><br><p>     <code>fooR1 inline / fooR2 inline</code> ,       ,   ,   ,    , <code>foo inline / fooR inline</code> ,         . ,        ,             . </p><br><h2 id="prozrachnye-ukazateli">   </h2><br><p> ,  ,    . </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point3f</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x, y, z; ~Point3f() {} }; <span class="hljs-function"><span class="hljs-function">Point3f </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scale</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Point3f p)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {px * <span class="hljs-number"><span class="hljs-number">2</span></span>, py * <span class="hljs-number"><span class="hljs-number">2</span></span>, pz * <span class="hljs-number"><span class="hljs-number">2</span></span>}; }</code> </pre> <br><p>    <code>rdi</code>  ,     . ,  <code>rsi</code> ,      . </p><br><pre> <code class="hljs pgsql">scale(Point3f): # @scale(Point3f) vmovss xmm0, dword ptr [rsi] # xmm0 = mem[<span class="hljs-number"><span class="hljs-number">0</span></span>],zero,zero,zero vaddss xmm0, xmm0, xmm0 vmovss dword ptr [rdi], xmm0 vmovss xmm0, dword ptr [rsi + <span class="hljs-number"><span class="hljs-number">4</span></span>] # xmm0 = mem[<span class="hljs-number"><span class="hljs-number">0</span></span>],zero,zero,zero vaddss xmm0, xmm0, xmm0 vmovss dword ptr [rdi + <span class="hljs-number"><span class="hljs-number">4</span></span>], xmm0 vmovss xmm0, dword ptr [rsi + <span class="hljs-number"><span class="hljs-number">8</span></span>] # xmm0 = mem[<span class="hljs-number"><span class="hljs-number">0</span></span>],zero,zero,zero vaddss xmm0, xmm0, xmm0 vmovss dword ptr [rdi + <span class="hljs-number"><span class="hljs-number">8</span></span>], xmm0 mov rax, rdi ret</code> </pre> <br><p>  , ,  ( )        .       POD .      <code>Point3f scaleR(const Point3f&amp;)</code>   .    . </p><br><pre> <code class="cpp hljs">Point3f p{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> result = scale(p); sink(&amp;result);</code> </pre> <br><pre> <code class="hljs pgsql">main: # @main push rbx sub rsp, <span class="hljs-number"><span class="hljs-number">48</span></span> movabs rax, <span class="hljs-number"><span class="hljs-number">4611686019492741120</span></span> #    . mov qword ptr [rsp + <span class="hljs-number"><span class="hljs-number">16</span></span>], rax mov dword ptr [rsp + <span class="hljs-number"><span class="hljs-number">24</span></span>], <span class="hljs-number"><span class="hljs-number">1077936128</span></span> lea rbx, [rsp + <span class="hljs-number"><span class="hljs-number">32</span></span>] lea rsi, [rsp + <span class="hljs-number"><span class="hljs-number">16</span></span>] #    [rsp+<span class="hljs-number"><span class="hljs-number">16</span></span>, rsp+<span class="hljs-number"><span class="hljs-number">28</span></span>) mov rdi, rbx #    [rsp+<span class="hljs-number"><span class="hljs-number">32</span></span>, rsp+<span class="hljs-number"><span class="hljs-number">44</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> scale(Point3f) mov qword ptr [rsp + <span class="hljs-number"><span class="hljs-number">8</span></span>], rbx #  [rsp+<span class="hljs-number"><span class="hljs-number">8</span></span>, rsp+<span class="hljs-number"><span class="hljs-number">16</span></span>)    . lea rdi, [rsp + <span class="hljs-number"><span class="hljs-number">8</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> sink&lt;Point3f*&gt;(Point3f* const&amp;) xor eax, eax <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> rsp, <span class="hljs-number"><span class="hljs-number">48</span></span> pop rbx ret #  . mov rdi, rax <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> _Unwind_Resume</code> </pre> <br><p>    <strong>NOINLINE</strong> ,     . </p><br><pre> <code class="hljs pgsql">main: # @main push r14 push rbx sub rsp, <span class="hljs-number"><span class="hljs-number">56</span></span> movabs rax, <span class="hljs-number"><span class="hljs-number">4611686019492741120</span></span> #    [rsp, rsp+<span class="hljs-number"><span class="hljs-number">12</span></span>).   p. mov qword ptr [rsp], rax mov dword ptr [rsp + <span class="hljs-number"><span class="hljs-number">8</span></span>], <span class="hljs-number"><span class="hljs-number">1077936128</span></span> #    [rsp+<span class="hljs-number"><span class="hljs-number">24</span></span>, rsp+<span class="hljs-number"><span class="hljs-number">36</span></span>),    pTmp. mov eax, dword ptr [rsp + <span class="hljs-number"><span class="hljs-number">8</span></span>] mov dword ptr [rsp + <span class="hljs-number"><span class="hljs-number">32</span></span>], eax mov rax, qword ptr [rsp] mov qword ptr [rsp + <span class="hljs-number"><span class="hljs-number">24</span></span>], rax lea r14, [rsp + <span class="hljs-number"><span class="hljs-number">40</span></span>] lea rbx, [rsp + <span class="hljs-number"><span class="hljs-number">24</span></span>] mov rdi, r14 #    [rsp+<span class="hljs-number"><span class="hljs-number">40</span></span>, rsp+<span class="hljs-number"><span class="hljs-number">52</span></span>),  result. mov rsi, rbx #   -   pTmp. <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> scale(Point3f) mov rdi, rbx #    pTmp.    -  this. <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> Point3f::~Point3f() mov qword ptr [rsp + <span class="hljs-number"><span class="hljs-number">16</span></span>], r14 #  [rsp+<span class="hljs-number"><span class="hljs-number">16</span></span>, rsp+<span class="hljs-number"><span class="hljs-number">24</span></span>)     result.     sink. lea rdi, [rsp + <span class="hljs-number"><span class="hljs-number">16</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> sink&lt;Point3f*&gt;(Point3f* const&amp;) lea rdi, [rsp + <span class="hljs-number"><span class="hljs-number">40</span></span>] #    result. <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> Point3f::~Point3f() mov rdi, rsp #    p. <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> Point3f::~Point3f() xor eax, eax <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> rsp, <span class="hljs-number"><span class="hljs-number">56</span></span> pop rbx pop r14 ret #  .           . mov rbx, rax lea rdi, [rsp + <span class="hljs-number"><span class="hljs-number">40</span></span>] #    result. <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> Point3f::~Point3f() mov rdi, rsp #    p. <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> Point3f::~Point3f() mov rdi, rbx <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> _Unwind_Resume</code> </pre> <br><p>   <code>p</code>    ,            . </p><br><h2 id="pereispolzovanie-steka">   </h2><br><p> ,        .      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> </a> . </p><br><pre> <code class="hljs pgsql"># Point3f result = scale(scale(Point3f{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>})); sub rsp, <span class="hljs-number"><span class="hljs-number">24</span></span> vmovaps xmm0, xmmword ptr [rip + .LCPI4_0] # xmm0 = &lt;<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,u,u&gt; vmovss xmm1, dword ptr [rip + .LCPI4_1] # xmm1 = mem[<span class="hljs-number"><span class="hljs-number">0</span></span>],zero,zero,zero #    xmm0, xmm1    ,    ,       ! <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> scale(Point3f) <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> scale(Point3f) vmovlps qword ptr [rsp + <span class="hljs-number"><span class="hljs-number">8</span></span>], xmm0 vmovss dword ptr [rsp + <span class="hljs-number"><span class="hljs-number">16</span></span>], xmm1 # Point3f result = scaleR(scaleR(Point3f{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>})); sub rsp, <span class="hljs-number"><span class="hljs-number">56</span></span> #       [rsp+<span class="hljs-number"><span class="hljs-number">24</span></span>, rsp+<span class="hljs-number"><span class="hljs-number">36</span></span>). movabs rax, <span class="hljs-number"><span class="hljs-number">4611686019492741120</span></span> # <span class="hljs-number"><span class="hljs-number">0x400000003F800000</span></span> = [<span class="hljs-number"><span class="hljs-number">2.0</span></span>f, <span class="hljs-number"><span class="hljs-number">1.0</span></span>f] mov qword ptr [rsp + <span class="hljs-number"><span class="hljs-number">24</span></span>], rax mov dword ptr [rsp + <span class="hljs-number"><span class="hljs-number">32</span></span>], <span class="hljs-number"><span class="hljs-number">1077936128</span></span> # <span class="hljs-number"><span class="hljs-number">0x40400000</span></span> = <span class="hljs-number"><span class="hljs-number">3.0</span></span>f lea rdi, [rsp + <span class="hljs-number"><span class="hljs-number">24</span></span>] #      . <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> scaleR(Point3f const&amp;) #    [rsp+<span class="hljs-number"><span class="hljs-number">8</span></span>, rsp+<span class="hljs-number"><span class="hljs-number">20</span></span>). vmovlps qword ptr [rsp + <span class="hljs-number"><span class="hljs-number">8</span></span>], xmm0 vmovss dword ptr [rsp + <span class="hljs-number"><span class="hljs-number">16</span></span>], xmm1 lea rdi, [rsp + <span class="hljs-number"><span class="hljs-number">8</span></span>] #       . <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> scaleR(Point3f const&amp;) vmovlps qword ptr [rsp + <span class="hljs-number"><span class="hljs-number">40</span></span>], xmm0 vmovss dword ptr [rsp + <span class="hljs-number"><span class="hljs-number">48</span></span>], xmm1</code> </pre> <br><p> ,       ,   .      ,    . </p><br><pre> <code class="hljs pgsql"># Point3d result = scale(scale(Point3d{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>})); sub rsp, <span class="hljs-number"><span class="hljs-number">112</span></span> #    [rsp, rsp+<span class="hljs-number"><span class="hljs-number">24</span></span>). vmovaps xmm0, xmmword ptr [rip + .LCPI4_0] # xmm0 = [<span class="hljs-number"><span class="hljs-number">1.000000e+00</span></span>,<span class="hljs-number"><span class="hljs-number">2.000000e+00</span></span>] vmovaps xmmword ptr [rsp + <span class="hljs-number"><span class="hljs-number">32</span></span>], xmm0 movabs rax, <span class="hljs-number"><span class="hljs-number">4613937818241073152</span></span> # <span class="hljs-number"><span class="hljs-number">0x4008000000000000</span></span> = <span class="hljs-number"><span class="hljs-number">3.0</span></span> mov qword ptr [rsp + <span class="hljs-number"><span class="hljs-number">48</span></span>], rax mov rax, qword ptr [rsp + <span class="hljs-number"><span class="hljs-number">48</span></span>] mov qword ptr [rsp + <span class="hljs-number"><span class="hljs-number">16</span></span>], rax vmovaps xmm0, xmmword ptr [rsp + <span class="hljs-number"><span class="hljs-number">32</span></span>] vmovups xmmword ptr [rsp], xmm0 #    [rsp+<span class="hljs-number"><span class="hljs-number">64</span></span>, rsp+<span class="hljs-number"><span class="hljs-number">88</span></span>). lea rdi, [rsp + <span class="hljs-number"><span class="hljs-number">64</span></span>] #  rdi     . <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> scale(Point3d) #        [rsp, rsp+<span class="hljs-number"><span class="hljs-number">24</span></span>). mov rax, qword ptr [rsp + <span class="hljs-number"><span class="hljs-number">80</span></span>] #  z   z . mov qword ptr [rsp + <span class="hljs-number"><span class="hljs-number">16</span></span>], rax vmovups xmm0, xmmword ptr [rsp + <span class="hljs-number"><span class="hljs-number">64</span></span>] #  [x, y]   [x, y] . vmovups xmmword ptr [rsp], xmm0 #    [rsp+<span class="hljs-number"><span class="hljs-number">88</span></span>, rsp+<span class="hljs-number"><span class="hljs-number">112</span></span>). lea rbx, [rsp + <span class="hljs-number"><span class="hljs-number">88</span></span>] mov rdi, rbx <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> scale(Point3d) # Point3d result = scaleR(scaleR(Point3d{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>})); sub rsp, <span class="hljs-number"><span class="hljs-number">72</span></span> #    [rsp, rsp+<span class="hljs-number"><span class="hljs-number">24</span></span>),   . vmovaps xmm0, xmmword ptr [rip + .LCPI4_0] vmovaps xmmword ptr [rsp], xmm0 movabs rax, <span class="hljs-number"><span class="hljs-number">4613937818241073152</span></span> mov qword ptr [rsp + <span class="hljs-number"><span class="hljs-number">16</span></span>], rax lea r14, [rsp + <span class="hljs-number"><span class="hljs-number">24</span></span>] mov rsi, rsp #   -       [rsp, rsp+<span class="hljs-number"><span class="hljs-number">24</span></span>). mov rdi, r14 #   -      [rsp+<span class="hljs-number"><span class="hljs-number">24</span></span>, rsp+<span class="hljs-number"><span class="hljs-number">48</span></span>). <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> scaleR(Point3d const&amp;) lea rbx, [rsp + <span class="hljs-number"><span class="hljs-number">48</span></span>] mov rdi, rbx #      [rsp+<span class="hljs-number"><span class="hljs-number">48</span></span>, rsp+<span class="hljs-number"><span class="hljs-number">72</span></span>). mov rsi, r14 #       [rsp+<span class="hljs-number"><span class="hljs-number">24</span></span>, rsp+<span class="hljs-number"><span class="hljs-number">48</span></span>). <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> scaleR(Point3d const&amp;)</code> </pre> <br><p> ,    ,   ,   ,    .      –     .                  .       ,       ,      . </p><br><h3 id="sravnenie-proizvoditelnosti-1">   </h3><br><p> ,       .         ,      . ,         , <code>Point3f</code>    ,  <code>Point3d</code> –  . </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   data.cpp.  . Point3f pf() { return {1, 2, 3}; } Point3d pd() { return {1, 2, 3}; }</span></span></code> </pre> <br><table><thead><tr><th> Code </th><th> Cycles per iteration </th></tr></thead><tbody><tr><td> <code>auto r = pf();</code> </td> <td> 6.7 </td></tr><tr><td> <code>auto r = scale(pf());</code> </td> <td> 11.1 </td></tr><tr><td> <code>auto r = scaleR(pf());</code> </td> <td> 12.6 </td></tr><tr><td> <code>auto r = scale(scale(pf()));</code> </td> <td> 18.2 </td></tr><tr><td> <code>auto r = scaleR(scaleR(pf()));</code> </td> <td> 18.3 </td></tr><tr><td> <code>auto r = scale(scale(scale(pf())));</code> </td> <td> 16.8 </td></tr><tr><td> <code>auto r = scaleR(scaleR(scaleR(pf())));</code> </td> <td> 20.2 </td></tr><tr><td> <code>auto r = pd();</code> </td> <td>  7.3 </td></tr><tr><td> <code>auto r = scale(pd());</code> </td> <td> 11.7 </td></tr><tr><td> <code>auto r = scaleR(pd());</code> </td> <td> 11.0 </td></tr><tr><td> <code>auto r = scale(scale(pd()));</code> </td> <td> 16.9 </td></tr><tr><td> <code>auto r = scaleR(scaleR(pd()));</code> </td> <td> 14.1 </td></tr><tr><td> <code>auto r = scale(scale(scale(pd())));</code> </td> <td> 21.2 </td></tr><tr><td> <code>auto r = scaleR(scaleR(scaleR(pd())));</code> </td> <td> 17.2 </td></tr><tr><td>    <strong>INLINE</strong> </td><td> 8.1 — 8.9 </td></tr></tbody></table><br><p>   <code>Point3f</code>  <code>struct Point3i { int32_t x, y, z; };</code>  <code>Point3d</code>  <code>struct Point3ll { int64_t x, y, z; };</code> ,       . ,        , ,    64       int,      .   ,   <code>Point3f</code>  <code>struct Point2ll { int64_t x, y; };</code>  <code>Point3d</code>  <code>struct Point4ll { int64_t x, y, z, a; };</code> ,     -. </p><br><p>   : </p><br><ul><li>      .     . </li><li> ,    ,    . </li><li>      inline      ,    .     ,  ,  ,    .       . </li></ul><br><h2 id="tip-optional">  optional </h2><br><p>   <code>std::optional</code> ,   <code>boost::optional</code> ,     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> </a> ,     "x86-64 clang (experimental concepts)" ,  , MSVC  ,  </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x, y; }; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> OptPoint1 = optional&lt;Point&gt;;</code> </pre> <br><p>     </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OptPoint2</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x, y; <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> _; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> d; }; <span class="hljs-comment"><span class="hljs-comment">//   std::optional. };</span></span></code> </pre> <br><p>      , <code>OptPoint1</code>    ,  <code>OptPoint2</code> –  . </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">OptPoint1 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(OptPoint1 s)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Point{s-&gt;x + <span class="hljs-number"><span class="hljs-number">1</span></span>, s-&gt;y + <span class="hljs-number"><span class="hljs-number">1</span></span>}; } <span class="hljs-function"><span class="hljs-function">OptPoint2 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(OptPoint2 s)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {sx + <span class="hljs-number"><span class="hljs-number">1</span></span>, sy + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>}; } ... OptPoint1 s1{Point{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>}}; OptPoint2 s2{<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> result1 = foo(s1); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> result2 = foo(s2);</code> </pre> <br><pre> <code class="hljs pgsql">.LCPI0_0: .long <span class="hljs-number"><span class="hljs-number">1065353216</span></span> # <span class="hljs-type"><span class="hljs-type">float</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> foo(std::optional&lt;<span class="hljs-type"><span class="hljs-type">Point</span></span>&gt;): # @foo(std::optional&lt;<span class="hljs-type"><span class="hljs-type">Point</span></span>&gt;) vmovss xmm0, dword ptr [rip + .LCPI0_0] # xmm0 = mem[<span class="hljs-number"><span class="hljs-number">0</span></span>],zero,zero,zero #  rsi       . vaddss xmm1, xmm0, dword ptr [rsi] #  x  ,  <span class="hljs-number"><span class="hljs-number">1.</span></span> vaddss xmm0, xmm0, dword ptr [rsi + <span class="hljs-number"><span class="hljs-number">4</span></span>] #  y  ,  <span class="hljs-number"><span class="hljs-number">1.</span></span> vmovss dword ptr [rdi], xmm1 #  x  , rdi      ,     . vmovss dword ptr [rdi + <span class="hljs-number"><span class="hljs-number">4</span></span>], xmm0 #  y  . mov byte ptr [rdi + <span class="hljs-number"><span class="hljs-number">8</span></span>], <span class="hljs-number"><span class="hljs-number">1</span></span> #  optional::has_value(). mov rax, rdi #    . ret .LCPI1_0: .long <span class="hljs-number"><span class="hljs-number">1065353216</span></span> # <span class="hljs-type"><span class="hljs-type">float</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> .long <span class="hljs-number"><span class="hljs-number">1065353216</span></span> # <span class="hljs-type"><span class="hljs-type">float</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> .zero <span class="hljs-number"><span class="hljs-number">4</span></span> .zero <span class="hljs-number"><span class="hljs-number">4</span></span> foo(OptPoint2): # @foo(OptPoint2) vaddps xmm0, xmm0, xmmword ptr [rip + .LCPI1_0] #  [x, y] c [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>].  xmm0  . mov al, <span class="hljs-number"><span class="hljs-number">1</span></span> #  d, al -   <span class="hljs-number"><span class="hljs-number">8</span></span>   rax. ret .LCPI2_0: .long <span class="hljs-number"><span class="hljs-number">1077936128</span></span> # <span class="hljs-type"><span class="hljs-type">float</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> .long <span class="hljs-number"><span class="hljs-number">1082130432</span></span> # <span class="hljs-type"><span class="hljs-type">float</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> .zero <span class="hljs-number"><span class="hljs-number">4</span></span> .zero <span class="hljs-number"><span class="hljs-number">4</span></span> main: # @main push rbx sub rsp, <span class="hljs-number"><span class="hljs-number">64</span></span> movabs rax, <span class="hljs-number"><span class="hljs-number">4611686019492741120</span></span> # <span class="hljs-number"><span class="hljs-number">0x400000003F800000</span></span>  x  y. mov qword ptr [rsp + <span class="hljs-number"><span class="hljs-number">32</span></span>], rax #  x, y  . mov byte ptr [rsp + <span class="hljs-number"><span class="hljs-number">40</span></span>], <span class="hljs-number"><span class="hljs-number">1</span></span> #  optional::has_value(). lea rbx, [rsp + <span class="hljs-number"><span class="hljs-number">48</span></span>] lea rsi, [rsp + <span class="hljs-number"><span class="hljs-number">32</span></span>] #    . mov rdi, rbx #    . <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> foo(std::optional&lt;<span class="hljs-type"><span class="hljs-type">Point</span></span>&gt;) #     . vmovaps xmm0, xmmword ptr [rip + .LCPI2_0] # xmm0 = &lt;<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,u,u&gt; mov edi, <span class="hljs-number"><span class="hljs-number">1</span></span> #  <span class="hljs-type"><span class="hljs-type">bool</span></span> d. <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> foo(OptPoint2) vmovlps qword ptr [rsp + <span class="hljs-number"><span class="hljs-number">16</span></span>], xmm0 #    . mov byte ptr [rsp + <span class="hljs-number"><span class="hljs-number">24</span></span>], al #  al      rax.</code> </pre> <br><p> ,    <code>foo</code>  <code>inline</code> ,         . </p><br><pre> <code class="hljs go"> # OptPoint1 foo(OptPoint1)  OptPoint1 foo(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> OptPoint1&amp;) vmovss xmm0, dword ptr [rip + .LCPI0_0] # xmm0 = mem[<span class="hljs-number"><span class="hljs-number">0</span></span>],zero,zero,zero vaddss xmm1, xmm0, dword ptr [rsp + <span class="hljs-number"><span class="hljs-number">32</span></span>] vaddss xmm0, xmm0, dword ptr [rsp + <span class="hljs-number"><span class="hljs-number">36</span></span>] vmovss dword ptr [rsp + <span class="hljs-number"><span class="hljs-number">8</span></span>], xmm1 vmovss dword ptr [rsp + <span class="hljs-number"><span class="hljs-number">12</span></span>], xmm0 mov <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> ptr [rsp + <span class="hljs-number"><span class="hljs-number">16</span></span>], <span class="hljs-number"><span class="hljs-number">1</span></span> # OptPoint2 foo(OptPoint2)  OptPoint2 foo(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> OptPoint2&amp;) vmovsd xmm0, qword ptr [rsp + <span class="hljs-number"><span class="hljs-number">48</span></span>] # xmm0 = mem[<span class="hljs-number"><span class="hljs-number">0</span></span>],zero vaddps xmm0, xmm0, xmmword ptr [rip + .LCPI0_1] vmovlps qword ptr [rsp + <span class="hljs-number"><span class="hljs-number">8</span></span>], xmm0 mov <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> ptr [rsp + <span class="hljs-number"><span class="hljs-number">16</span></span>], <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br><p> ,      ,      ,     . </p><br><p> :    <code>inline</code> ,     <code>std::optional</code>  . </p><br><h2 id="virtualnye-funkcii">   </h2><br><p>  ,     ,    .     . ,    .    , -        , , , .         . </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Fn</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~Fn() <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Add</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> Fn { Add(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a) : a(a) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + x; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a; }; <span class="hljs-function"><span class="hljs-function">NOINLINE </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isFixedPoint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Fn&amp; fn, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fn.call(x) == x; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Add add{<span class="hljs-number"><span class="hljs-number">32</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> result = isFixedPoint(add, <span class="hljs-number"><span class="hljs-number">10</span></span>); }</code> </pre> <br><p>    -  . </p><br><pre> <code class="hljs vbscript">Add::<span class="hljs-keyword"><span class="hljs-keyword">call</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">int</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>: # @Add::<span class="hljs-keyword"><span class="hljs-keyword">call</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">int</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> #  rdi   this  ,   [rdi, rdi+<span class="hljs-number"><span class="hljs-number">8</span></span>)      ,       . add esi, dword ptr [rdi + <span class="hljs-number"><span class="hljs-number">8</span></span>] mov eax, esi #    rax, eax     <span class="hljs-number"><span class="hljs-number">32</span></span> . ret #      Add.       <span class="hljs-number"><span class="hljs-number">16</span></span>,   RTTI    . vtable <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Add: .quad <span class="hljs-number"><span class="hljs-number">0</span></span> .quad typeinfo <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Add #   RTTI.  <span class="hljs-number"><span class="hljs-number">-8.</span></span> .quad Fn::~Fn() # ,  <span class="hljs-number"><span class="hljs-number">0</span></span>    . .quad Add::~Add() .quad Add::<span class="hljs-keyword"><span class="hljs-keyword">call</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">int</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> # ,  <span class="hljs-number"><span class="hljs-number">16</span></span> . isFixedPoint(Fn <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp;, <span class="hljs-built_in"><span class="hljs-built_in">int</span></span>): # @isFixedPoint(Fn <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp;, <span class="hljs-built_in"><span class="hljs-built_in">int</span></span>) push rbx #         rbx,    ,    . mov ebx, esi #  <span class="hljs-number"><span class="hljs-number">32</span></span>   . mov rax, qword ptr [rdi] #  rdi    -   Fn,         this . <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> qword ptr [rax + <span class="hljs-number"><span class="hljs-number">16</span></span>] #  Add::<span class="hljs-keyword"><span class="hljs-keyword">call</span></span>. cmp eax, ebx #   <span class="hljs-keyword"><span class="hljs-keyword">call</span></span>    rax,    ebx,      . sete al #     <span class="hljs-number"><span class="hljs-number">8</span></span>   eax. pop rbx #   rbx. ret main: # @main <span class="hljs-keyword"><span class="hljs-keyword">sub</span></span> rsp, <span class="hljs-number"><span class="hljs-number">40</span></span> mov qword ptr [rsp + <span class="hljs-number"><span class="hljs-number">24</span></span>], vtable <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Add+<span class="hljs-number"><span class="hljs-number">16</span></span> #          Add,    <span class="hljs-number"><span class="hljs-number">16</span></span>  ,    , ,  .    RTTI    . mov dword ptr [rsp + <span class="hljs-number"><span class="hljs-number">32</span></span>], <span class="hljs-number"><span class="hljs-number">32</span></span> #  add.a   . lea rdi, [rsp + <span class="hljs-number"><span class="hljs-number">24</span></span>] #      . mov esi, <span class="hljs-number"><span class="hljs-number">10</span></span> #   . <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> isFixedPoint(Fn <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp;, <span class="hljs-built_in"><span class="hljs-built_in">int</span></span>) mov byte ptr [rsp + <span class="hljs-number"><span class="hljs-number">15</span></span>], al #    . ... mov rdi, rax #  . <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> _Unwind_Resume mov rdi, rax <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> _Unwind_Resume</code> </pre> <br><p>    <code>protected</code>   ,         ( 34-37).        <strong>NOINLINE</strong> ,               ( <code>false</code>   ).    <strong>NOINLINE</strong> ,        .       . </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Add</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> {</span></span> Add(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a) : a(a) {} <span class="hljs-function"><span class="hljs-function">NOINLINE </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + x; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-function">NOINLINE </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isFixedPoint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; fn, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fn.call(x) == x; }</code> </pre> <br><pre> <code class="hljs cpp">Add::call(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>: # @Add::call(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> add esi, dword ptr [rdi] #    , <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>   rdi  ,        ,      . mov eax, esi ret <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isFixedPoint&lt;Add&gt;(Add <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp;, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>): # @<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isFixedPoint&lt;Add&gt;(Add <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp;, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) push rbx mov ebx, esi # Add::call         ,   isFixedPoint. call Add::call(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> cmp eax, ebx sete al pop rbx ret main: # @main sub rsp, <span class="hljs-number"><span class="hljs-number">24</span></span> mov dword ptr [rsp + <span class="hljs-number"><span class="hljs-number">8</span></span>], <span class="hljs-number"><span class="hljs-number">32</span></span> #  add.a. lea rdi, [rsp + <span class="hljs-number"><span class="hljs-number">8</span></span>] #    ,  rdi    add.a. mov esi, <span class="hljs-number"><span class="hljs-number">10</span></span> call <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isFixedPoint&lt;Add&gt;(Add <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp;, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) mov byte ptr [rsp + <span class="hljs-number"><span class="hljs-number">7</span></span>], al ... ret</code> </pre> <br><p>  ,      <strong>NOINLINE</strong> . </p><br><h3 id="sravnenie-proizvoditelnosti-2">   </h3><br><p>           1000   <code>Add</code>   <code>isFixedPoint</code>    . </p><br><table><thead><tr><th> Code </th><th> Cycles per iteration </th></tr></thead><tbody><tr><td>  <code>call</code>  ,   <code>isFixedPoint</code>  <code>call</code> </td><td> 5267 </td></tr><tr><td>  <code>call</code>  , <code>NOINLINE isFixedPoint</code> </td><td> 10721 </td></tr><tr><td>  <code>call</code>  , <code>INLINE isFixedPoint</code> </td><td> 8291 </td></tr><tr><td>   <code>call</code> , <code>NOINLINE isFixedPoint</code> </td><td> 10571 </td></tr><tr><td>   , <code>NOINLINE call</code> ,  <code>NOINLINE isFixedPoint</code> </td><td> 10536 </td></tr><tr><td>   ,   <code>isFixedPoint</code>  <code>call</code> </td><td> 4505 </td></tr><tr><td>   , <code>INLINE call</code> ,  <code>INLINE isFixedPoint</code> </td><td> 4531 </td></tr></tbody></table><br><p>   : </p><br><ul><li>     . </li><li>        ,     . </li><li>  ,       ,  ,  inline.      . </li><li>  <code>inline</code>       .   <code>inline</code>    -    cpp     ,     <strong>NOINLINE</strong> . </li><li> <code>inline</code>      . </li></ul><br><h2 id="hvostovye-vyzovy">   </h2><br><p>        <code>call</code> ,   <code>jmp</code>    . </p><br><p>  .  clang    .  ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">   </a> : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exp_by_squaring</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> exp_by_squaring(<span class="hljs-number"><span class="hljs-number">1.0</span></span> / x, -n, y); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> y; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n == <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x * y; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> exp_by_squaring(x * x, n / <span class="hljs-number"><span class="hljs-number">2</span></span>, y); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> exp_by_squaring(x * x, (n - <span class="hljs-number"><span class="hljs-number">1</span></span>) / <span class="hljs-number"><span class="hljs-number">2</span></span>, x * y); }</code> </pre> <br><p>  Temos: </p><br><pre> <code class="hljs pgsql">.LCPI0_0: .quad <span class="hljs-number"><span class="hljs-number">4607182418800017408</span></span> # <span class="hljs-type"><span class="hljs-type">double</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> exp_by_squaring(<span class="hljs-type"><span class="hljs-type">double</span></span>, <span class="hljs-type"><span class="hljs-type">int</span></span>, <span class="hljs-type"><span class="hljs-type">double</span></span>): # @exp_by_squaring(<span class="hljs-type"><span class="hljs-type">double</span></span>, <span class="hljs-type"><span class="hljs-type">int</span></span>, <span class="hljs-type"><span class="hljs-type">double</span></span>) vmovsd xmm2, qword ptr [rip + .LCPI0_0] # xmm2 = mem[<span class="hljs-number"><span class="hljs-number">0</span></span>],zero vmovapd xmm3, xmm0 test edi, edi jns .LBB0_4 jmp .LBB0_3 .LBB0_9: # <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Loop</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">Header</span></span>=BB0_4 Depth=<span class="hljs-number"><span class="hljs-number">1</span></span> shr edi vmovapd xmm3, xmm0 test edi, edi jns .LBB0_4 .LBB0_3: # =&gt;This <span class="hljs-keyword"><span class="hljs-keyword">Inner</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Loop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Header</span></span>: Depth=<span class="hljs-number"><span class="hljs-number">1</span></span> vdivsd xmm3, xmm2, xmm3 neg edi test edi, edi js .LBB0_3 .LBB0_4: # =&gt;This <span class="hljs-keyword"><span class="hljs-keyword">Inner</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Loop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Header</span></span>: Depth=<span class="hljs-number"><span class="hljs-number">1</span></span> je .LBB0_7 cmp edi, <span class="hljs-number"><span class="hljs-number">1</span></span> je .LBB0_6 vmulsd xmm0, xmm3, xmm3 test dil, <span class="hljs-number"><span class="hljs-number">1</span></span> je .LBB0_9 lea eax, [rdi - <span class="hljs-number"><span class="hljs-number">1</span></span>] shr eax, <span class="hljs-number"><span class="hljs-number">31</span></span> lea edi, [rdi + rax] <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> edi, <span class="hljs-number"><span class="hljs-number">-1</span></span> sar edi vmulsd xmm1, xmm3, xmm1 vmovapd xmm3, xmm0 test edi, edi jns .LBB0_4 jmp .LBB0_3 .LBB0_6: vmulsd xmm1, xmm3, xmm1 .LBB0_7: vmovapd xmm0, xmm1 ret</code> </pre> <br><p>  ,     ,  .    ,   ,   .      ~10% . </p><br><p>            .             . </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int64_t</span></span> sum(<span class="hljs-keyword"><span class="hljs-keyword">int64_t</span></span> x, <span class="hljs-keyword"><span class="hljs-keyword">int64_t</span></span> y) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + y; } <span class="hljs-keyword"><span class="hljs-keyword">int64_t</span></span> add1(<span class="hljs-keyword"><span class="hljs-keyword">int64_t</span></span> x) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum(x, <span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">int64_t</span></span> add2(<span class="hljs-keyword"><span class="hljs-keyword">int64_t</span></span> x) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum(<span class="hljs-number"><span class="hljs-number">1</span></span>, x); } <span class="hljs-keyword"><span class="hljs-keyword">int64_t</span></span> add3(<span class="hljs-keyword"><span class="hljs-keyword">int64_t</span></span> x) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum(<span class="hljs-number"><span class="hljs-number">-1</span></span>, x) + <span class="hljs-number"><span class="hljs-number">2</span></span>; }</code> </pre> <br><pre> <code class="hljs vala">sum(<span class="hljs-keyword"><span class="hljs-keyword">long</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>): # @sum(<span class="hljs-keyword"><span class="hljs-keyword">long</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>) lea rax, [rdi + rsi] ret add1(<span class="hljs-keyword"><span class="hljs-keyword">long</span></span>): # @add1(<span class="hljs-keyword"><span class="hljs-keyword">long</span></span>) mov esi, <span class="hljs-number"><span class="hljs-number">1</span></span> #   . jmp sum(<span class="hljs-keyword"><span class="hljs-keyword">long</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>) # TAILCALL add2(<span class="hljs-keyword"><span class="hljs-keyword">long</span></span>): # @add2(<span class="hljs-keyword"><span class="hljs-keyword">long</span></span>) mov rax, rdi #   . mov edi, <span class="hljs-number"><span class="hljs-number">1</span></span> mov rsi, rax jmp sum(<span class="hljs-keyword"><span class="hljs-keyword">long</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>) # TAILCALL add3(<span class="hljs-keyword"><span class="hljs-keyword">long</span></span>): # @add3(<span class="hljs-keyword"><span class="hljs-keyword">long</span></span>) push rax #  rax   . mov rax, rdi #  ,    add2,  . mov rdi, <span class="hljs-number"><span class="hljs-number">-1</span></span> mov rsi, rax call sum(<span class="hljs-keyword"><span class="hljs-keyword">long</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>) add rax, <span class="hljs-number"><span class="hljs-number">2</span></span> #  <span class="hljs-number"><span class="hljs-number">2</span></span>    . pop rcx ret</code> </pre> <br><p>  ,           ,     <code>call</code> ,    <code>jmp</code> .   ,     ,     <code>sum</code> ,     ,  <code>add</code> . </p><br><p>       ,          10%. </p><br><p> : </p><br><ul><li>      ,            . </li><li>       . </li></ul><br><h2 id="inicializaciya">  </h2><br><p>           .    2D      : </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> x, y; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ZeroPoint</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> x{}, y{}; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NanPoint</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> x{quietNaN}, y{quietNaN}; };</code> </pre> <br><p>  <code>Point</code>  . <code>ZeroPoint</code>  .   IEEE 754-1985: </p><br><blockquote> The number zero is represented specially: sign = 0 for positive zero, 1 for negative zero; biased exponent = 0; fraction = 0; </blockquote><p>         <code>memset</code> . <code>NanPoint</code>   <code>numeric_limits&lt;double&gt;::quiet_NaN();</code> ,           . </p><br><h3 id="odin-element">   </h3><br><pre> <code class="cpp hljs">Point data;</code> </pre> <br><pre> <code class="hljs perl"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rsp</span></span></span><span class="hljs-function">, 24</span></span></code> </pre> <br><p>       - . </p><br><pre> <code class="cpp hljs">ZeroPoint data; Point data{};</code> </pre> <br><p>     . </p><br><pre> <code class="hljs powershell"> sub rsp, <span class="hljs-number"><span class="hljs-number">40</span></span> vxorps xmm0, xmm0, xmm0 vmovaps xmmword ptr [<span class="hljs-type"><span class="hljs-type">rsp</span></span> + <span class="hljs-number"><span class="hljs-number">16</span></span>], xmm0</code> </pre> <br><p>    .   <code>xmm0</code> .    <code>XOR</code>   <code>vxorps</code>    .       . </p><br><pre> <code class="cpp hljs">NanPoint data;</code> </pre> <br><pre> <code class="hljs powershell"> sub rsp, <span class="hljs-number"><span class="hljs-number">40</span></span> vmovaps xmm0, xmmword ptr [<span class="hljs-type"><span class="hljs-type">rip</span></span> + <span class="hljs-type"><span class="hljs-type">.LCPI0_0</span></span>] <span class="hljs-comment"><span class="hljs-comment"># xmm0 = [nan,nan] vmovaps xmmword ptr [rsp + 16], xmm0</span></span></code> </pre> <br><p>   ,          . </p><br><h3 id="nebolshoy-massiv">   </h3><br><p>       : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> smallSize = <span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> bigSize = <span class="hljs-number"><span class="hljs-number">321</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> smallUnknownSize; <span class="hljs-comment"><span class="hljs-comment">// Also 8 extern size_t bigUnknownSize; // Also 321</span></span></code> </pre> <br><p>     . </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt;Point, smallSize&gt; data;</code> </pre> <br><p>    –     . </p><br><pre> <code class="hljs perl"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rsp</span></span></span><span class="hljs-function">, 136</span></span></code> </pre> <br><p>       ,     . </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt;ZeroPoint, smallSize&gt; data; <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt;ZeroPoint, smallSize&gt; data{}; <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt;Point, smallSize&gt; data{};</code> </pre> <br><p>         . </p><br><pre> <code class="hljs powershell"> sub rsp, <span class="hljs-number"><span class="hljs-number">192</span></span> vxorps ymm0, ymm0, ymm0 vmovaps ymmword ptr [<span class="hljs-type"><span class="hljs-type">rsp</span></span> + <span class="hljs-number"><span class="hljs-number">128</span></span>], ymm0 vmovaps ymmword ptr [<span class="hljs-type"><span class="hljs-type">rsp</span></span> + <span class="hljs-number"><span class="hljs-number">96</span></span>], ymm0 vmovaps ymmword ptr [<span class="hljs-type"><span class="hljs-type">rsp</span></span> + <span class="hljs-number"><span class="hljs-number">64</span></span>], ymm0 vmovaps ymmword ptr [<span class="hljs-type"><span class="hljs-type">rsp</span></span> + <span class="hljs-number"><span class="hljs-number">32</span></span>], ymm0</code> </pre> <br><p>     256 ,  2 . </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt;NanPoint, smallSize&gt; data; <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt;NanPoint, smallSize&gt; data{};</code> </pre> <br><pre> <code class="hljs powershell"> sub rsp, <span class="hljs-number"><span class="hljs-number">136</span></span> vmovaps xmm0, xmmword ptr [<span class="hljs-type"><span class="hljs-type">rip</span></span> + <span class="hljs-type"><span class="hljs-type">.LCPI0_0</span></span>] <span class="hljs-comment"><span class="hljs-comment"># xmm0 = [nan,nan] vmovups xmmword ptr [rsp + 24], xmm0 vmovups xmmword ptr [rsp + 8], xmm0 vmovups xmmword ptr [rsp + 56], xmm0 vmovups xmmword ptr [rsp + 40], xmm0 vmovups xmmword ptr [rsp + 88], xmm0 vmovups xmmword ptr [rsp + 72], xmm0 vmovups xmmword ptr [rsp + 120], xmm0 vmovups xmmword ptr [rsp + 104], xmm0</span></span></code> </pre> <br><p>      . </p><br><h3 id="bolshoy-massiv">   </h3><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt;Point, bigSize&gt; data;</code> </pre> <br><pre> <code class="hljs perl"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rsp</span></span></span><span class="hljs-function">, 5144</span></span></code> </pre> <br><p>   . </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt;ZeroPoint, bigSize&gt; data; <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt;ZeroPoint, bigSize&gt; data{}; <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt;Point, bigSize&gt; data{};</code> </pre> <br><pre> <code class="hljs vbscript"> <span class="hljs-keyword"><span class="hljs-keyword">sub</span></span> rsp, <span class="hljs-number"><span class="hljs-number">5152</span></span> lea rbx, [rsp + <span class="hljs-number"><span class="hljs-number">16</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">xor</span></span> esi, esi mov edx, <span class="hljs-number"><span class="hljs-number">5136</span></span> mov rdi, rbx <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> memset #  memset(rsp+<span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">5136</span></span>).</code> </pre> <br><p>     ,  <code>memset</code> .   ,      ,    <code>rdi, esi, edx</code> .  <code>e</code>  <code>d</code>     32  64- . </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt;NanPoint, bigSize&gt; data;</code> </pre> <br><pre> <code class="hljs powershell"> sub rsp, <span class="hljs-number"><span class="hljs-number">5144</span></span> lea rax, [<span class="hljs-type"><span class="hljs-type">rsp</span></span> + <span class="hljs-number"><span class="hljs-number">8</span></span>] lea rcx, [<span class="hljs-type"><span class="hljs-type">rsp</span></span> + <span class="hljs-number"><span class="hljs-number">5144</span></span>] vmovaps xmm0, xmmword ptr [<span class="hljs-type"><span class="hljs-type">rip</span></span> + <span class="hljs-type"><span class="hljs-type">.LCPI0_0</span></span>] <span class="hljs-comment"><span class="hljs-comment"># xmm0 = [nan,nan] #  . .LBB0_1: # =&gt;This Inner Loop Header: Depth=1 vmovups xmmword ptr [rax], xmm0 vmovups xmmword ptr [rax + 16], xmm0 vmovups xmmword ptr [rax + 32], xmm0 add rax, 48 cmp rax, rcx jne .LBB0_1</span></span></code> </pre> <br><p>    .       ,    321   3  .   <code>rax, rcx</code>      . </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt;NanPoint, bigSize&gt; data{};</code> </pre> <br><pre> <code class="hljs pgsql"> sub rsp, <span class="hljs-number"><span class="hljs-number">5152</span></span> lea rbx, [rsp + <span class="hljs-number"><span class="hljs-number">16</span></span>] xor esi, esi mov edx, <span class="hljs-number"><span class="hljs-number">5136</span></span> mov rdi, rbx <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> memset #  memset(rsp+<span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">5136</span></span>). lea rax, [rsp + <span class="hljs-number"><span class="hljs-number">5152</span></span>] vmovaps xmm0, xmmword ptr [rip + .LCPI0_0] # xmm0 = [<span class="hljs-keyword"><span class="hljs-keyword">nan</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">nan</span></span>] #  . .LBB0_1: # =&gt;This <span class="hljs-keyword"><span class="hljs-keyword">Inner</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Loop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Header</span></span>: Depth=<span class="hljs-number"><span class="hljs-number">1</span></span> vmovups xmmword ptr [rbx], xmm0 vmovups xmmword ptr [rbx + <span class="hljs-number"><span class="hljs-number">16</span></span>], xmm0 vmovups xmmword ptr [rbx + <span class="hljs-number"><span class="hljs-number">32</span></span>], xmm0 <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> rbx, <span class="hljs-number"><span class="hljs-number">48</span></span> cmp rbx, rax jne .LBB0_1</code> </pre> <br><p>      .   ,    <code>memset</code> .  ,     ,       .        . </p><br><h3 id="dinamicheskiy-massiv">   </h3><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Point&gt; data(smallSize);</code> </pre> <br><pre> <code class="hljs css"> <span class="hljs-selector-tag"><span class="hljs-selector-tag">sub</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">rsp</span></span>, 40 <span class="hljs-selector-tag"><span class="hljs-selector-tag">vxorps</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">xmm0</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">xmm0</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">xmm0</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">vmovaps</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">xmmword</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ptr</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[rsp]</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">xmm0</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">mov</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">qword</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ptr</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[rsp + 16]</span></span>, 0 <span class="hljs-selector-tag"><span class="hljs-selector-tag">mov</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">edi</span></span>, 128 <span class="hljs-selector-tag"><span class="hljs-selector-tag">call</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">operator</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">new</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">unsigned</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">long</span></span>) #  <span class="hljs-selector-tag"><span class="hljs-selector-tag">new</span></span>(128). <span class="hljs-selector-tag"><span class="hljs-selector-tag">mov</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">qword</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ptr</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[rsp]</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">rax</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">mov</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">rcx</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">rax</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">sub</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">rcx</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">-128</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">mov</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">qword</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ptr</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[rsp + 16]</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">rcx</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">vxorps</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">xmm0</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">xmm0</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">xmm0</span></span> #     . <span class="hljs-selector-tag"><span class="hljs-selector-tag">vmovups</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">xmmword</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ptr</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[rax + 16]</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">xmm0</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">vmovups</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">xmmword</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ptr</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[rax]</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">xmm0</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">vmovups</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">xmmword</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ptr</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[rax + 32]</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">xmm0</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">vmovups</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">xmmword</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ptr</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[rax + 48]</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">xmm0</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">vmovups</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">xmmword</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ptr</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[rax + 64]</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">xmm0</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">vmovups</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">xmmword</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ptr</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[rax + 80]</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">xmm0</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">vmovups</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">xmmword</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ptr</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[rax + 96]</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">xmm0</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">vmovups</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">xmmword</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ptr</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[rax + 112]</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">xmm0</span></span></code> </pre> <br><p>  <code>new</code>    .  ,      <code>T{}</code> ,    ,   .   <code>ZeroPoint</code>  <code>NanPoint</code>  .   : </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Point&gt; data(bigSize);</code> </pre> <br><pre> <code class="hljs pgsql">main: # @main push rbx sub rsp, <span class="hljs-number"><span class="hljs-number">48</span></span> vxorps xmm0, xmm0, xmm0 vmovaps xmmword ptr [rsp], xmm0 mov qword ptr [rsp + <span class="hljs-number"><span class="hljs-number">16</span></span>], <span class="hljs-number"><span class="hljs-number">0</span></span> mov edi, <span class="hljs-number"><span class="hljs-number">5136</span></span> <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(unsigned long) #  <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(<span class="hljs-number"><span class="hljs-number">5136</span></span>). mov qword ptr [rsp], rax mov qword ptr [rsp + <span class="hljs-number"><span class="hljs-number">8</span></span>], rax mov rcx, rax <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> rcx, <span class="hljs-number"><span class="hljs-number">5136</span></span> mov qword ptr [rsp + <span class="hljs-number"><span class="hljs-number">16</span></span>], rcx vxorps xmm0, xmm0, xmm0 vmovaps xmmword ptr [rsp + <span class="hljs-number"><span class="hljs-number">32</span></span>], xmm0 xor edx, edx #    . .LBB0_2: # =&gt;This <span class="hljs-keyword"><span class="hljs-keyword">Inner</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Loop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Header</span></span>: Depth=<span class="hljs-number"><span class="hljs-number">1</span></span> vmovaps xmm0, xmmword ptr [rsp + <span class="hljs-number"><span class="hljs-number">32</span></span>] vmovups xmmword ptr [rax + rdx], xmm0 vmovaps xmm0, xmmword ptr [rsp + <span class="hljs-number"><span class="hljs-number">32</span></span>] vmovups xmmword ptr [rax + rdx + <span class="hljs-number"><span class="hljs-number">16</span></span>], xmm0 vmovaps xmm0, xmmword ptr [rsp + <span class="hljs-number"><span class="hljs-number">32</span></span>] vmovups xmmword ptr [rax + rdx + <span class="hljs-number"><span class="hljs-number">32</span></span>], xmm0 <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> rdx, <span class="hljs-number"><span class="hljs-number">48</span></span> cmp rdx, <span class="hljs-number"><span class="hljs-number">5136</span></span> jne .LBB0_2 mov qword ptr [rsp + <span class="hljs-number"><span class="hljs-number">8</span></span>], rcx mov rax, rsp</code> </pre> <br><p>      ,     .    <code>NanPoint</code>   . </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;NanPoint&gt; data(bigSize);</code> </pre> <br><pre> <code class="hljs pgsql">main: # @main push rbx sub rsp, <span class="hljs-number"><span class="hljs-number">32</span></span> vxorps xmm0, xmm0, xmm0 vmovaps xmmword ptr [rsp], xmm0 mov qword ptr [rsp + <span class="hljs-number"><span class="hljs-number">16</span></span>], <span class="hljs-number"><span class="hljs-number">0</span></span> mov edi, <span class="hljs-number"><span class="hljs-number">5136</span></span> <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(unsigned long) #  <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(<span class="hljs-number"><span class="hljs-number">5136</span></span>). mov qword ptr [rsp], rax mov qword ptr [rsp + <span class="hljs-number"><span class="hljs-number">8</span></span>], rax mov rcx, rax <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> rcx, <span class="hljs-number"><span class="hljs-number">5136</span></span> mov qword ptr [rsp + <span class="hljs-number"><span class="hljs-number">16</span></span>], rcx xor edx, edx vmovaps xmm0, xmmword ptr [rip + .LCPI0_0] # xmm0 = [<span class="hljs-keyword"><span class="hljs-keyword">nan</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">nan</span></span>] #    <span class="hljs-keyword"><span class="hljs-keyword">NAN</span></span>. .LBB0_2: # =&gt;This <span class="hljs-keyword"><span class="hljs-keyword">Inner</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Loop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Header</span></span>: Depth=<span class="hljs-number"><span class="hljs-number">1</span></span> vmovups xmmword ptr [rax + rdx], xmm0 vmovups xmmword ptr [rax + rdx + <span class="hljs-number"><span class="hljs-number">16</span></span>], xmm0 vmovups xmmword ptr [rax + rdx + <span class="hljs-number"><span class="hljs-number">32</span></span>], xmm0 <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> rdx, <span class="hljs-number"><span class="hljs-number">48</span></span> cmp rdx, <span class="hljs-number"><span class="hljs-number">5136</span></span> jne .LBB0_2 mov qword ptr [rsp + <span class="hljs-number"><span class="hljs-number">8</span></span>], rcx mov rax, rsp</code> </pre> <br><p> A    <code>ZeroPoint</code>   . </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;ZeroPoint&gt; data(bigSize);</code> </pre> <br><pre> <code class="hljs pgsql"> sub rsp, <span class="hljs-number"><span class="hljs-number">32</span></span> vxorps xmm0, xmm0, xmm0 vmovaps xmmword ptr [rsp], xmm0 mov qword ptr [rsp + <span class="hljs-number"><span class="hljs-number">16</span></span>], <span class="hljs-number"><span class="hljs-number">0</span></span> mov edi, <span class="hljs-number"><span class="hljs-number">5136</span></span> <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(unsigned long) #  <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(<span class="hljs-number"><span class="hljs-number">5136</span></span>). mov qword ptr [rsp], rax mov rbx, rax <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> rbx, <span class="hljs-number"><span class="hljs-number">5136</span></span> mov qword ptr [rsp + <span class="hljs-number"><span class="hljs-number">16</span></span>], rbx xor esi, esi mov edx, <span class="hljs-number"><span class="hljs-number">5136</span></span> mov rdi, rax <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> memset #  memset(&amp;data, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">5136</span></span>).</code> </pre> <br><p>      <code>memset</code> . ,     , <code>memset</code>     <code>Point</code> . ,  ,   <code>bigUnknownSize</code>     . </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;NanPoint&gt; data(bigUnknownSize);</code> </pre> <br><pre> <code class="hljs pgsql"> sub rsp, <span class="hljs-number"><span class="hljs-number">32</span></span> mov rbx, qword ptr [rip + bigUnknownSize] vxorps xmm0, xmm0, xmm0 vmovaps xmmword ptr [rsp], xmm0 mov qword ptr [rsp + <span class="hljs-number"><span class="hljs-number">16</span></span>], <span class="hljs-number"><span class="hljs-number">0</span></span> test rbx, rbx #  bigUnknownSize == <span class="hljs-number"><span class="hljs-number">0</span></span>,   <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>. je .LBB0_1 mov rax, rbx shr rax, <span class="hljs-number"><span class="hljs-number">60</span></span> jne .LBB0_3 mov rdi, rbx shl rdi, <span class="hljs-number"><span class="hljs-number">4</span></span> #   <span class="hljs-number"><span class="hljs-number">16</span></span>    <span class="hljs-number"><span class="hljs-number">4.</span></span> <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(unsigned long) #  <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(bigUnknownSize*<span class="hljs-number"><span class="hljs-number">16</span></span>). jmp .LBB0_6 .LBB0_1: xor eax, eax .LBB0_6: mov rcx, rbx shl rcx, <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> rcx, rax mov qword ptr [rsp], rax mov qword ptr [rsp + <span class="hljs-number"><span class="hljs-number">8</span></span>], rax mov qword ptr [rsp + <span class="hljs-number"><span class="hljs-number">16</span></span>], rcx test rbx, rbx #  bigUnknownSize == <span class="hljs-number"><span class="hljs-number">0</span></span>,   . je .LBB0_14 lea rdx, [rbx - <span class="hljs-number"><span class="hljs-number">1</span></span>] mov rsi, rbx <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> rsi, <span class="hljs-number"><span class="hljs-number">7</span></span> je .LBB0_10 neg rsi vmovaps xmm0, xmmword ptr [rip + .LCPI0_0] # xmm0 = [<span class="hljs-keyword"><span class="hljs-keyword">nan</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">nan</span></span>] #   <span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-number"><span class="hljs-number">-7</span></span> . .LBB0_9: # =&gt;This <span class="hljs-keyword"><span class="hljs-keyword">Inner</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Loop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Header</span></span>: Depth=<span class="hljs-number"><span class="hljs-number">1</span></span> vmovups xmmword ptr [rax], xmm0 <span class="hljs-type"><span class="hljs-type">dec</span></span> rbx <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> rax, <span class="hljs-number"><span class="hljs-number">16</span></span> inc rsi jne .LBB0_9 .LBB0_10: cmp rdx, <span class="hljs-number"><span class="hljs-number">7</span></span> jb .LBB0_13 vmovaps xmm0, xmmword ptr [rip + .LCPI0_0] # xmm0 = [<span class="hljs-keyword"><span class="hljs-keyword">nan</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">nan</span></span>] #      <span class="hljs-number"><span class="hljs-number">8.</span></span> .LBB0_12: # =&gt;This <span class="hljs-keyword"><span class="hljs-keyword">Inner</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Loop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Header</span></span>: Depth=<span class="hljs-number"><span class="hljs-number">1</span></span> vmovups xmmword ptr [rax], xmm0 vmovups xmmword ptr [rax + <span class="hljs-number"><span class="hljs-number">16</span></span>], xmm0 vmovups xmmword ptr [rax + <span class="hljs-number"><span class="hljs-number">32</span></span>], xmm0 vmovups xmmword ptr [rax + <span class="hljs-number"><span class="hljs-number">48</span></span>], xmm0 vmovups xmmword ptr [rax + <span class="hljs-number"><span class="hljs-number">64</span></span>], xmm0 vmovups xmmword ptr [rax + <span class="hljs-number"><span class="hljs-number">80</span></span>], xmm0 vmovups xmmword ptr [rax + <span class="hljs-number"><span class="hljs-number">96</span></span>], xmm0 vmovups xmmword ptr [rax + <span class="hljs-number"><span class="hljs-number">112</span></span>], xmm0 sub rax, <span class="hljs-number"><span class="hljs-number">-128</span></span> <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> rbx, <span class="hljs-number"><span class="hljs-number">-8</span></span> jne .LBB0_12 .LBB0_13: mov rax, rcx .LBB0_14: mov qword ptr [rsp + <span class="hljs-number"><span class="hljs-number">8</span></span>], rax mov rax, rsp</code> </pre> <br><p>    . , <code>LBB0_9</code>       ,        8.      8   . </p><br><p>     ,   <code>Point</code>   ,   <code>ZeroPoint</code>   <code>memset</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;ZeroPoint&gt; data(bigUnknownSize);</code> </pre> <br><pre> <code class="hljs cpp"> sub rsp, <span class="hljs-number"><span class="hljs-number">40</span></span> mov rbx, qword ptr [rip + bigUnknownSize] vxorps xmm0, xmm0, xmm0 vmovaps xmmword ptr [rsp], xmm0 mov qword ptr [rsp + <span class="hljs-number"><span class="hljs-number">16</span></span>], <span class="hljs-number"><span class="hljs-number">0</span></span> test rbx, rbx #  bigUnknownSize == <span class="hljs-number"><span class="hljs-number">0</span></span>,   <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>. je .LBB0_1 mov rax, rbx shr rax, <span class="hljs-number"><span class="hljs-number">60</span></span> jne .LBB0_3 mov rdi, rbx shl rdi, <span class="hljs-number"><span class="hljs-number">4</span></span> call <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>) #  <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>(bigUnknownSize*<span class="hljs-number"><span class="hljs-number">16</span></span>). jmp .LBB0_6 .LBB0_1: xor eax, eax .LBB0_6: mov rdx, rbx shl rdx, <span class="hljs-number"><span class="hljs-number">4</span></span> lea r14, [rax + rdx] mov qword ptr [rsp], rax mov qword ptr [rsp + <span class="hljs-number"><span class="hljs-number">8</span></span>], rax mov qword ptr [rsp + <span class="hljs-number"><span class="hljs-number">16</span></span>], r14 test rbx, rbx #  bigUnknownSize == <span class="hljs-number"><span class="hljs-number">0</span></span>,   <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>. je .LBB0_8 xor esi, esi mov rdi, rax call <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span> #  <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(&amp;data, <span class="hljs-number"><span class="hljs-number">0</span></span>, bigUnknownSize*<span class="hljs-number"><span class="hljs-number">16</span></span>). mov rax, r14 .LBB0_8: mov qword ptr [rsp + <span class="hljs-number"><span class="hljs-number">8</span></span>], rax mov rax, rsp</code> </pre> <br><p> ,  </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;NanPoint&gt; data; data.resize(bigUnknownSize);</code> </pre> <br><p>   250  ,          .  <code>operator new</code>    ,         . </p><br><h3 id="sravnenie-proizvoditelnosti-3">   </h3><br><p>       . </p><br><table><thead><tr><th> Code </th><th> Cycles per iteration </th></tr></thead><tbody><tr><td> <code>Point p;</code> </td> <td> 4.5 </td></tr><tr><td> <code>ZeroPoint p;</code> </td> <td> 5.2 </td></tr><tr><td> <code>NanPoint p;</code> </td> <td> 4.5 </td></tr><tr><td> <code>array&lt;Point, smallSize&gt; p;</code> </td> <td> 4.5 </td></tr><tr><td> <code>array&lt;ZeroPoint, smallSize&gt; p;</code> </td> <td> 6.7 </td></tr><tr><td> <code>array&lt;NanPoint, smallSize&gt; p;</code> </td> <td> 6.7 </td></tr><tr><td> <code>array&lt;Point, bigSize&gt; p;</code> </td> <td> 4.5 </td></tr><tr><td> <code>array&lt;ZeroPoint, bigSize&gt; p;</code> </td> <td> 296.0 </td></tr><tr><td> <code>array&lt;NanPoint, bigSize&gt; p;</code> </td> <td> 391.0 </td></tr><tr><td> <code>array&lt;Point, bigSize&gt; p{};</code> </td> <td> 292.0 </td></tr><tr><td> <code>array&lt;NanPoint, bigSize&gt; p{};</code> </td> <td> <strong>657.0</strong> </td></tr><tr><td> <code>vector&lt;Point&gt; p(smallSize);</code> </td> <td> 32.3 </td></tr><tr><td> <code>vector&lt;ZeroPoint&gt; p(smallSize);</code> </td> <td> 33.8 </td></tr><tr><td> <code>vector&lt;NanPoint&gt; p(smallSize);</code> </td> <td> 33.8 </td></tr><tr><td> <code>vector&lt;Point&gt; p(bigSize);</code> </td> <td> 323.0 </td></tr><tr><td> <code>vector&lt;ZeroPoint&gt; p(bigSize);</code> </td> <td> 308.0 </td></tr><tr><td> <code>vector&lt;NanPoint&gt; p(bigSize);</code> </td> <td> 281.0 </td></tr><tr><td> <code>vector&lt;ZeroPoint&gt; p(smallUnknownSize);</code> </td> <td> 44.1 </td></tr><tr><td> <code>vector&lt;NanPoint&gt; p(smallUnknownSize);</code> </td> <td> 37.6 </td></tr><tr><td> <code>vector&lt;Point&gt; p(bigUnknownSize);</code> </td> <td> 311.0 </td></tr><tr><td> <code>vector&lt;ZeroPoint&gt; p(bigUnknownSize);</code> </td> <td> 315.0 </td></tr><tr><td> <code>vector&lt;NanPoint&gt; p(bigUnknownSize);</code> </td> <td> 290.0 </td></tr><tr><td> <code>vector&lt;NanPoint&gt; p; p.resize(bigUnknownSize);</code> </td> <td> 315.0 </td></tr></tbody></table><br><p> : </p><br><ul><li>         . </li><li>       . </li><li>      <code>memset</code>   ,        . </li><li>          . </li><li>       ,  .          . </li><li>        .        . </li><li>      ,      .         . </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt414443/">https://habr.com/ru/post/pt414443/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt414429/index.html">Como aprender uma língua estrangeira sem professor. Parte 1. "Minha experiência"</a></li>
<li><a href="../pt414431/index.html">Mitap JavaJam. Debate Javista, rafting, experimentos e microsserviços</a></li>
<li><a href="../pt414433/index.html">Andamos pela cidade com sabedoria: como eu fiz o serviço para construir percursos pedestres interessantes</a></li>
<li><a href="../pt414437/index.html">O bloqueio de telegrama provocou um aumento no custo de startups domésticas</a></li>
<li><a href="../pt414441/index.html">Experimente 1440 migrações de banco de dados</a></li>
<li><a href="../pt414445/index.html">Melhorando o Zimbra com o Zextras Suite</a></li>
<li><a href="../pt414447/index.html">Tipos de todos os tempos</a></li>
<li><a href="../pt414449/index.html">Como fazer amigos de todos os operadores do estádio e não semeá-lo com centenas de antenas</a></li>
<li><a href="../pt414451/index.html">"Calendário do testador" para junho. O testador deve pegar o erro, ler Caner e organizar a mudança.</a></li>
<li><a href="../pt414453/index.html">Implementar o Path Finder para agentes de IA com o NavMesh</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>