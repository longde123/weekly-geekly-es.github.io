<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôÉ üçñ ü§ß A coisa mais interessante no PHP 8 üë®‚Äçüéì üòπ üòè</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O PHP 7.4 acabou de ser declarado est√°vel, e j√° submetemos ainda mais melhorias. E o melhor de tudo, o que o PHP est√° esperando pode dizer a Dmitry St...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>A coisa mais interessante no PHP 8</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/481092/">  O PHP 7.4 acabou de ser declarado est√°vel, e j√° submetemos ainda mais melhorias.  E o melhor de tudo, o que o PHP est√° esperando pode dizer a Dmitry Stogov - um dos principais desenvolvedores do PHP de c√≥digo aberto e, provavelmente, o colaborador ativo mais antigo. <br><br>  Todos os relat√≥rios de Dmitry s√£o apenas sobre as tecnologias e solu√ß√µes nas quais ele trabalha pessoalmente.  Nas melhores tradi√ß√µes da Ontiko, abaixo do corte, uma vers√£o em texto da <a href="https://youtu.be/7UOWus-5yxg">hist√≥ria</a> sobre o mais interessante, do ponto de vista das inova√ß√µes de Dmitry no PHP 8, que pode abrir novos casos de uso.  Primeiro de tudo, JIT e FFI - n√£o na chave das ‚Äúperspectivas incr√≠veis‚Äù, mas com detalhes e armadilhas da implementa√ß√£o. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/h9/o1/xd/h9o1xdb-wntc2xl0eipeb4bd7du.png" width="500"></div><br>  <i>Para refer√™ncia:</i> Dmitry Stogov se familiarizou com a programa√ß√£o em 1984, quando nem todos os leitores nasceram, e conseguiu dar uma contribui√ß√£o significativa ao desenvolvimento de ferramentas de desenvolvimento e ao PHP em particular (embora Dmitry melhore o desempenho do PHP n√£o especificamente para desenvolvedores russos, eles <a href="https://habr.com/ru/company/oleg-bunin/blog/477426/">expressaram</a> meus agradecimentos na forma do pr√™mio HighLoad ++).  Dmitry √© o autor do Turck MMCache para PHP (eAccelerator), mantenedor do Zend OPcache, l√≠der do projeto PHPNG, que formou a base do PHP 7, e l√≠der no desenvolvimento do JIT para PHP. <br><a name="habracut"></a><br><h2>  Desenvolvimento de desempenho PHP </h2><br>  Comecei a trabalhar no desempenho do PHP h√° 15 anos quando entrei no Zend.  Em seguida, lan√ßamos a vers√£o 5.0 - a primeira na qual a linguagem se tornou verdadeiramente orientada a objetos.  Desde ent√£o, conseguimos melhorar o desempenho em testes sint√©ticos em 40 vezes e em aplicativos reais em 6 vezes. <br><br><img src="https://habrastorage.org/webt/xp/gc/xe/xpgcxedjqqy7_ay7vzrocx2cl3y.jpeg"><br><br>  Durante esse per√≠odo, houve dois momentos inovadores: <br><br><ul><li>  Vers√£o 5.1, na qual conseguimos aumentar significativamente a velocidade da interpreta√ß√£o.  Implementamos um int√©rprete especializado, o que afetou principalmente os testes sint√©ticos. </li><li> Vers√£o 7.0, na qual todas as estruturas de dados principais foram processadas e, portanto, otimizaram o trabalho com mem√≥ria e cache do processador (leia mais sobre essas otimiza√ß√µes <a href="https://habr.com/ru/company/oleg-bunin/blog/444508/">aqui</a> ).  Isso levou a acelera√ß√£o mais que dupla, tanto em testes sint√©ticos quanto em aplica√ß√µes reais. </li></ul><br>  Todas as outras vers√µes aumentaram gradualmente a produtividade implementando muitas id√©ias menos eficazes.  Na vers√£o 7.1, por exemplo, muita aten√ß√£o foi dada √† otimiza√ß√£o do bytecode ( <a href="https://habr.com/ru/company/oleg-bunin/blog/445512/">um artigo</a> sobre essas solu√ß√µes). <br><br>  O diagrama mostra que, no final do desenvolvimento da 5¬™ vers√£o e no final do ciclo de desenvolvimento da 7¬™ vers√£o, vamos para um plat√¥ e desaceleramos.  Portanto, durante o √∫ltimo ano de trabalho na v7.4, apenas um aumento de 2% na produtividade foi alcan√ßado.  E isso n√£o √© ruim, porque novos recursos, como propriedades digitadas e tipos covariantes, apareceram que desaceleram o PHP (Nikita Popov <a href="https://youtu.be/teKnckg5x7I">falou</a> sobre esses novos produtos no PHP R√∫ssia). <br><br>  E agora todo mundo est√° se perguntando o que esperar da 8¬™ vers√£o, ele pode repetir o sucesso da v7? <br><br><h3>  Para JIT ou n√£o para JIT </h3><br>  As id√©ias para melhorar o int√©rprete ainda n√£o foram esgotadas, mas todas elas requerem um estudo muito substancial.  Muitos deles precisam ser rejeitados na fase de prova de conceito, porque o ganho que pode ser obtido √© incomensur√°vel com as complica√ß√µes ou restri√ß√µes t√©cnicas impostas. <br><br>  Mas ainda h√° esperan√ßa de uma nova tecnologia inovadora - √© claro, eu me lembro do JIT e da hist√≥ria de sucesso dos mecanismos JavaScript. <br><br>  De fato, o trabalho no JIT para PHP est√° em andamento desde 2012.  Havia 3 ou 4 implementa√ß√µes, trabalhamos com colegas da Intel, hackers JavaScript, mas de alguma forma n√£o foi poss√≠vel incluir o JIT no ramo principal.  No final, no PHP 8, inclu√≠mos o JIT no compilador e vimos acelera√ß√£o dupla, mas apenas em testes sint√©ticos, mas em aplicativos reais, pelo contr√°rio, desacelera√ß√£o. <br><br><img src="https://habrastorage.org/webt/no/ly/58/noly58x1blcmkwv80nd8n60yu3q.jpeg"><br><br>  Obviamente, n√£o √© por isso que estamos nos esfor√ßando. <br><br>  Qual √© o problema?  Talvez estejamos fazendo algo errado, talvez o WordPress seja t√£o ruim e nenhum JIT o ajude (sim, na verdade √©).  Talvez j√° tenhamos tornado o int√©rprete muito bom, mas em JavaScript √© pior.  Nos testes computacionais, isso √© verdade: <strong>o int√©rprete PHP √© um dos melhores</strong> . <br><br><img src="https://habrastorage.org/webt/fi/ya/lc/fiyalccpg18n2aieqgj7bmy-nho.jpeg"><br><br>  No teste de Mandelbrot, ele ultrapassa at√© gemas como LuaJIT, um int√©rprete escrito em linguagem assembly.  Neste teste, estamos apenas quatro vezes atr√°s do compilador GCC-5.3 otimizador.  Com o JIT, conseguimos melhores resultados no teste de Mandelbrot.  Na verdade, j√° fazemos isso, ou seja, somos capazes de gerar c√≥digo que compete com o compilador C. <br><br>  Por que, ent√£o, n√£o podemos acelerar aplicativos reais?  Para entender, vou lhe dizer como fazemos o JIT.  Vamos come√ßar com o b√°sico. <br><br><h3>  Como o PHP funciona </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/r3/u7/zz/r3u7zzdgmpo37fihs44l6jl29wq.jpeg" width="300"></div><br>  O servidor aceita a solicita√ß√£o, compila-a no bytecode, que por sua vez √© enviado √† m√°quina virtual para execu√ß√£o.  Ao executar o bytecode, a m√°quina virtual tamb√©m pode chamar outros arquivos PHP, que s√£o recompilados novamente no bytecode e executados novamente. <br><br>  Ap√≥s a conclus√£o da consulta, todas as informa√ß√µes relacionadas a ela, incluindo o c√≥digo de bytes, s√£o exclu√≠das da mem√≥ria.  Ou seja, cada script PHP deve ser compilado em cada solicita√ß√£o novamente.  Obviamente, √© simplesmente imposs√≠vel incorporar a compila√ß√£o JIT em um esquema desse tipo, porque o compilador deve ser muito r√°pido. <br><br>  Mas provavelmente ningu√©m usa PHP em sua forma simples, todo mundo usa com OPcache. <br><br><h3>  PHP + OPcache </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/w4/cg/wr/w4cgwrta9e7mdka4mzsylnfzbqa.jpeg" width="484"></div><br>  O principal objetivo do OPcache √© livrar-se da recompila√ß√£o de scripts em cada solicita√ß√£o.  Ele √© incorporado em um ponto especialmente projetado para ele, intercepta todas as solicita√ß√µes de compila√ß√£o e armazena em cache o bytecode compilado na mem√≥ria compartilhada. <br><br>  Ao mesmo tempo, n√£o apenas o tempo de compila√ß√£o √© salvo, mas tamb√©m a mem√≥ria, porque a mem√≥ria do bytecode anterior foi alocada no espa√ßo de endere√ßo de cada processo e agora existe em uma √∫nica c√≥pia. <br><br>  Voc√™ j√° pode incorporar o JIT neste circuito, o que faremos.  Mas primeiro, mostrarei como o int√©rprete funciona. <br><br><img src="https://habrastorage.org/webt/jt/d5/50/jtd550mfh4al9klurcdde6yfzce.jpeg"><br><br>  Um int√©rprete √© antes de tudo um loop que chama seu pr√≥prio manipulador para cada instru√ß√£o. <br><br>  Usamos dois registros: <br><br><ul><li>  execute_data - ponteiro para o quadro de ativa√ß√£o atual; </li><li>  opline - ponteiro para a instru√ß√£o virtual execut√°vel atual. </li></ul><br>  Usando a extens√£o gcc, esses dois tipos de registradores s√£o mapeados para registros reais de hardware e, devido a isso, eles funcionam muito rapidamente. <br><br>  No loop, simplesmente chamamos o manipulador para cada instru√ß√£o, ap√≥s o que, no final de cada manipulador, movemos o ponteiro para a pr√≥xima instru√ß√£o. <br><br>  √â importante observar que o endere√ßo do manipulador √© gravado diretamente no bytecode.  Pode haver v√°rios manipuladores diferentes para uma √∫nica instru√ß√£o.  Isso foi originalmente inventado para especializa√ß√£o, para que os manipuladores possam se especializar nos tipos de operandos.  A mesma tecnologia √© usada para o JIT, porque se voc√™ escrever o endere√ßo no novo c√≥digo gerado como manipulador, os manipuladores JIT ser√£o iniciados sem nenhuma altera√ß√£o no int√©rprete. <br><br>  No exemplo acima, o manipulador escrito para a instru√ß√£o de adi√ß√£o √© apresentado √† direita.  Ele pega operandos (aqui o primeiro e o segundo podem ser uma vari√°vel constante, tempor√°ria ou local), l√™ operandos, verifica tipos, produz l√≥gica direta - adi√ß√£o - e depois retorna ao loop, que transfere o controle para o pr√≥ximo manipulador. <br><br>  Fun√ß√µes especializadas s√£o geradas a partir desta descri√ß√£o.  Como havia tr√™s primeiros operandos poss√≠veis, tr√™s segundos poss√≠veis, obtemos 9 fun√ß√µes diferentes. <br><br><img src="https://habrastorage.org/webt/sx/ac/ud/sxacudlzwpaetj0jdqlj-n-udqm.jpeg"><br><br>  Nessas fun√ß√µes, em vez de m√©todos universais para obter operandos, s√£o utilizados m√©todos espec√≠ficos que n√£o fazem nenhuma verifica√ß√£o. <br><br><h3>  M√°quina Virtual H√≠brida </h3><br>  Outra complica√ß√£o que fizemos na vers√£o 7.2 √© a chamada m√°quina virtual h√≠brida. <br><br>  Se anteriormente sempre chamamos o manipulador usando uma chamada indireta diretamente no loop do interpretador, agora para cada manipulador inserimos adicionalmente um r√≥tulo no corpo do loop, para o qual saltamos para o salto indireto e onde chamamos o pr√≥prio manipulador, mas diretamente. <br><br><img src="https://habrastorage.org/webt/ym/ve/1r/ymve1rgaxks_48lgcgt_m2zf3xm.jpeg"><br><br>  Parecia que antes eles faziam uma liga√ß√£o indireta, agora duas: uma transi√ß√£o indireta e uma liga√ß√£o direta, e esse sistema deveria funcionar mais devagar.  Mas, na verdade, ele funciona mais r√°pido, porque ajudamos o processador a prever transi√ß√µes.  Anteriormente, havia um ponto a partir do qual a transi√ß√£o para lugares diferentes era realizada.  O processador costumava estar enganado, porque simplesmente n√£o conseguia se lembrar de que era necess√°rio pular primeiro uma instru√ß√£o e depois outra.  Agora, ap√≥s cada chamada direta, h√° uma transi√ß√£o indireta para o pr√≥ximo r√≥tulo.  Como resultado, quando o loop do PHP √© executado, as instru√ß√µes virtuais do PHP s√£o organizadas em seq√º√™ncias est√°veis, que s√£o executadas quase linearmente. <br><br>  A m√°quina virtual h√≠brida permitiu aumentar a produtividade em mais 5 a 10%. <br><br><h3>  PHP + OPcache + JIT </h3><br>  O JIT √© implementado como parte do OPcache. <br><br><img src="https://habrastorage.org/webt/ye/ad/ad/yeadadf8b-tvejykkpdgpf3pacq.jpeg"><br><br>  Depois que o bytecode √© compilado e otimizado, um compilador JIT √© lan√ßado para ele, que n√£o funciona mais com o c√≥digo-fonte.  No bytecode do PHP, o compilador JIT gera c√≥digo nativo, ap√≥s o qual o endere√ßo da primeira instru√ß√£o (de fato a fun√ß√£o) √© alterado no bytecode. <br><br>  Depois disso, o c√≥digo nativo j√° gerado come√ßa a ser chamado a partir do int√©rprete existente sem nenhuma altera√ß√£o.  Vou mostrar um exemplo simples. <br><br><img src="https://habrastorage.org/webt/y8/zs/jz/y8zsjz7rzbiuvct-l146whbcotw.jpeg"><br><br>  √Ä esquerda, uma certa fun√ß√£o √© escrita em PHP que conta a soma dos n√∫meros de 0 a 100. √Ä direita, o c√≥digo de c√≥digo gerado.  A primeira instru√ß√£o atribui 0 √† soma, a segunda faz o mesmo para i, depois um salto incondicional para o r√≥tulo.  Na etiqueta L1, a condi√ß√£o para sair do ciclo √© verificada: se estiver preenchida, saia, se n√£o, ent√£o v√° para o ciclo.  Em seguida, adicione √† soma i, escreva o resultado na quantidade, aumente i em 1. <br><br>  Diretamente daqui, geramos c√≥digo assembler, o que resulta muito bom. <br><br><img src="https://habrastorage.org/webt/_g/q2/8b/_gq28bxpchqg3bc5duu7tysvpsq.jpeg"><br><br>  A primeira instru√ß√£o <code>QM_ASSIGN</code> compilada em apenas duas instru√ß√µes da m√°quina (2-3 linhas).  O registro <code>%esi</code> cont√©m um ponteiro para o quadro de ativa√ß√£o atual.  No deslocamento 30, encontra-se uma quantidade vari√°vel.  A primeira instru√ß√£o grava o valor 0, a segunda grava 4 - este √© um identificador de um tipo inteiro ( <code>IS_LONG</code> ).  Para a vari√°vel <code>i</code> compilador percebeu que √© sempre longo e, para isso, n√£o h√° necessidade de armazenar o tipo.  Al√©m disso, ele pode ser armazenado em um registro de m√°quina.  Portanto, aqui simplesmente o XOR do registro √© a instru√ß√£o mais simples e barata para redefinir. <br><br>  Ent√£o, da mesma maneira, uma transi√ß√£o incondicional, verificamos se algum evento externo ocorreu, verificamos a condi√ß√£o do ciclo, entramos no ciclo.  O loop verifica se a soma √© inteira: se sim, leia o valor inteiro, adicione o valor i, verifique se ocorreu um estouro, escreva o resultado de volta na soma e adicione 1 a <code>%edx</code> . <br><br>  Pode-se ver que o c√≥digo est√° pr√≥ximo do ideal.  Seria poss√≠vel otimiz√°-lo ainda mais, eliminando a verifica√ß√£o da soma do tipo em cada itera√ß√£o do loop.  Mas isso j√° √© uma otimiza√ß√£o bastante complicada, ainda n√£o o fazemos.  <strong>Estamos desenvolvendo o JIT como uma tecnologia bastante simples</strong> , n√£o estamos tentando fazer o que o Java HotSpot est√° tentando fazer, V8 - temos menos energia. <br><br><h2>  O que h√° de errado com jit </h2><br>  Por que, com um c√≥digo t√£o bom de montador, n√£o podemos acelerar aplicativos reais? <br><br>  Na verdade, deveriam? <br><br><ul><li>  Se o gargalo n√£o estiver na CPU, o JIT n√£o ajudar√°. </li><li>  Muito c√≥digo √© gerado (incha√ßo do c√≥digo). </li><li>  A infer√™ncia de tipo est√°tico nem sempre funciona. </li><li>  C√≥digo honesto (para casos que nunca s√£o executados). </li><li>  Suporte para o estado consistente da m√°quina virtual (e de repente uma exce√ß√£o). </li><li>  As aulas acontecem apenas para uma solicita√ß√£o. </li></ul><br>  Se o aplicativo aguardar 80% do tempo por uma resposta do banco de dados, o JIT n√£o ajudar√°.  Se chamarmos fun√ß√µes externas que consomem muitos recursos, por exemplo, combinando com uma express√£o regular, o JIT tamb√©m chamar√° as mesmas fun√ß√µes da mesma maneira.  Al√©m disso, se um aplicativo cria grandes estruturas de dados - √°rvores, gr√°ficos e as l√™, em seguida, usando JIT, geramos c√≥digo que ler√° em menos instru√ß√µes, mas para carregar os dados em si, levar√° o mesmo tempo, mas voc√™ tamb√©m precisar√° carregar o c√≥digo. <br><br>  Como voc√™ j√° viu, o JIT pode at√© desacelerar um aplicativo real, porque gera muito c√≥digo e a leitura se torna um problema - ao ler grandes quantidades de c√≥digo, outros dados s√£o for√ßados a sair do cache, o que leva a uma desacelera√ß√£o. <br><br><h2>  Planos modestos para PHP 8 </h2><br>  Uma das melhorias que queremos obter no PHP 8 √© <strong>gerar menos c√≥digo</strong> .  Agora, como eu disse, geramos c√≥digo nativo para todo o script, que carregamos no est√°gio de carregamento.  Mas metade das fun√ß√µes certamente n√£o ser√° chamada.  Ent√£o fomos um pouco mais longe e introduzimos um gatilho que nos permite configurar quando queremos executar o JIT.  Pode ser executado: <br><br><ul><li>  para todas as fun√ß√µes; </li><li>  somente para fun√ß√µes quando elas s√£o chamadas pela primeira vez; </li><li>  voc√™ pode pendurar um contador em cada fun√ß√£o e compilar apenas as fun√ß√µes que s√£o realmente boas. </li></ul><br>  Esse esquema pode funcionar um pouco melhor, mas ainda n√£o √© o ideal, porque novamente em cada fun√ß√£o existem caminhos que s√£o executados e caminhos que nunca s√£o executados.  Como o PHP √© uma linguagem de programa√ß√£o din√¢mica, ou seja, cada vari√°vel pode ter tipos diferentes, verifica-se que todos os tipos que o analisador est√°tico prev√™ devem ser suportados.  E ele costuma fazer isso com cautela quando n√£o consegue provar que o outro tipo n√£o pode faz√™-lo. <br><br>  <strong>Nessas condi√ß√µes, vamos nos afastar da compila√ß√£o honesta e come√ßar a faz√™-lo especulativamente.</strong> <br><br><img src="https://habrastorage.org/webt/cf/fu/2z/cffu2zfla_l00cqpouzm-ldteoi.jpeg"><br><br>  No futuro, planejamos, durante algum tempo, durante o trabalho de aplica√ß√£o, analisar as fun√ß√µes mais "quentes", ver quais caminhos o programa percorre, quais tipos de vari√°veis ‚Äã‚Äãs√£o, talvez at√© lembrar as condi√ß√µes de contorno e gerar apenas o c√≥digo de fun√ß√£o ideal para o atual maneira de execu√ß√£o - somente para as se√ß√µes que s√£o realmente executadas. <br><br>  Para todo o resto, colocaremos stubs.  Mesmo assim, haver√° verifica√ß√µes e poss√≠veis sa√≠das nas quais o processo de desoptimiza√ß√£o ser√° iniciado, ou seja, restauraremos o estado da m√°quina virtual necess√°ria para a interpreta√ß√£o e o forneceremos ao int√©rprete para execu√ß√£o. <br><br>  Um esquema semelhante √© usado no HotSpot Java VM e no V8.  Mas adaptar a tecnologia ao PHP tem v√°rias dificuldades.  Primeiro de tudo, √© que compartilhamos bytecode e c√≥digo nativo compartilhado usados ‚Äã‚Äãem diferentes processos.  N√£o podemos alter√°-los diretamente na mem√≥ria compartilhada, precisamos primeiro copiar em algum lugar, mudar e depois confirmar novamente na mem√≥ria compartilhada. <br><br><h2>  Pr√©-carregamento.  O problema da liga√ß√£o de classe </h2><br>  De fato, muitas das id√©ias para aprimoramentos do PHP que h√° muito foram inclu√≠das no PHP 7 e at√© no PHP 5 s√£o provenientes de trabalhos relacionados ao JIT.  Hoje vou falar sobre outra tecnologia desse tipo - isso √© pr√©-carregamento.  Essa tecnologia j√° est√° inclu√≠da no PHP 7.4 e permite especificar um conjunto de arquivos, carreg√°-los na inicializa√ß√£o do servidor e tornar todas as fun√ß√µes desses arquivos permanentes. <br><br>  Um dos problemas que a tecnologia de pr√©-carregamento resolve √© o problema da associa√ß√£o de classes.  O fato √© que, quando simplesmente compilamos arquivos em PHP, cada arquivo √© compilado separadamente dos outros.  Isso √© feito porque cada um deles pode ser alterado separadamente.  Voc√™ n√£o pode associar uma classe de um script a uma classe de outro script, porque na pr√≥xima solicita√ß√£o, um deles pode ser alterado e algo vai dar errado.  Al√©m disso, em v√°rios arquivos, pode haver uma classe com o mesmo nome e, com uma solicita√ß√£o, um deles √© usado como pai e, com a outra, outra classe de outro arquivo √© usada (com o mesmo nome, mas completamente diferente).  Acontece que, ao gerar c√≥digo que ser√° executado em v√°rias solicita√ß√µes, voc√™ n√£o pode se referir a classes ou m√©todos, porque eles s√£o recriados toda vez (a vida √∫til do c√≥digo excede a vida √∫til da classe). <br><br>  O pr√©-carregamento permite vincular classes inicialmente e, consequentemente, gerar o c√≥digo da melhor maneira poss√≠vel.  No m√≠nimo, para estruturas que ser√£o carregadas usando pr√©-carregamento. <br><br>  Essa tecnologia ajuda n√£o apenas na associa√ß√£o de classes.  Algo semelhante √© implementado em Java como Compartilhamento de dados de classe.  L√°, essa tecnologia tem como objetivo principal acelerar o lan√ßamento de aplicativos e reduzir a quantidade total de mem√≥ria consumida.  As mesmas vantagens s√£o obtidas no PHP, porque agora a liga√ß√£o de classe n√£o √© feita em tempo de execu√ß√£o, mas apenas uma vez.  Al√©m disso, as classes associadas agora s√£o armazenadas n√£o no espa√ßo de endere√ßo de cada processo, mas na mem√≥ria compartilhada e, portanto, o consumo total de mem√≥ria diminui. <br><br>  O uso do pr√©-carregamento tamb√©m ajuda na otimiza√ß√£o global de todos os scripts PHP, remove completamente a sobrecarga do OPcache e permite gerar um c√≥digo JIT mais eficiente. <br><br>  Mas tamb√©m h√° desvantagens.  <strong>Os scripts carregados na inicializa√ß√£o n√£o podem ser substitu√≠dos sem reiniciar o PHP.</strong>  Se baixamos algo e o tornamos permanente, n√£o podemos mais descarreg√°-lo.  Portanto, a tecnologia pode ser usada com estruturas est√°veis, mas se voc√™ implantar o aplicativo v√°rias vezes ao dia, provavelmente n√£o funcionar√° para voc√™. <br><br>  A tecnologia foi concebida como transparente, ou seja, permitiu carregar aplicativos existentes (ou partes deles) sem altera√ß√µes.  Mas, ap√≥s a implementa√ß√£o, verificou-se que isso n√£o √© inteiramente verdade: <strong>nem todos os aplicativos funcionam como planejado se fossem carregados usando pr√©-carregamento</strong> .  Por exemplo, se um c√≥digo for chamado no aplicativo com base nos resultados da verifica√ß√£o de <code>function_exists</code> ou <code>class_exists</code> , e a fun√ß√£o se tornar constante, respectivamente, <code>function_exists</code> sempre retornar√° <code>true</code> , e o c√≥digo que foi chamado anteriormente foi pensado para n√£o ser chamado. <br><br>  Tecnicamente, o pr√©-carregamento √© ativado com a ajuda de apenas uma diretiva de configura√ß√£o opcache.preload, para a entrada da qual voc√™ fornece um arquivo de script - um arquivo PHP comum que ser√° iniciado no est√°gio de inicializa√ß√£o do aplicativo (n√£o apenas carregado, mas executado). <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_preload</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string $preload, string $pattern = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"/\.php$/"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (is_file($path) &amp;&amp; preg_match($pattern, $path)) { opcache_compile_file($path) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">die</span></span>(<span class="hljs-string"><span class="hljs-string">"Preloading failed"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (is_dir($path)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($dh = opendir($path)) { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (($file = readdir($dh)) !== <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($file !== <span class="hljs-string"><span class="hljs-string">"."</span></span> &amp;&amp; $file !== <span class="hljs-string"><span class="hljs-string">".."</span></span>) { _preload($path . <span class="hljs-string"><span class="hljs-string">"/"</span></span> . $file, $pattern); } } closedir($dh); } } } _preload(<span class="hljs-string"><span class="hljs-string">"/usr/local/lib/ZendFramework"</span></span>);</code> </pre> <br>  Este √© um dos cen√°rios poss√≠veis que l√™ recursivamente todos os arquivos em algum diret√≥rio (neste caso, ZendFramework).  Voc√™ pode implementar absolutamente qualquer script no PHP: leia com uma lista, adicione exce√ß√µes ou at√© cruze com o compositor para que ele possa remover arquivos necess√°rios para o pr√©-carregamento.  Tudo isso √© uma quest√£o de tecnologia, e mais interessante n√£o √© como enviar, mas o que enviar. <br><br><h3>  O que carregar no pr√©-carregamento </h3><br>  Eu tentei essa tecnologia no WordPress.  Se voc√™ acabou de enviar todos os arquivos * .php, o WordPress deixar√° de funcionar por causa do recurso mencionado anteriormente: ele possui uma verifica√ß√£o function_exists, que sempre se torna verdadeira.  Portanto, tive que modificar levemente o script do exemplo anterior (adicionar exce√ß√µes) e, sem altera√ß√µes no pr√≥prio WordPress, ele funcionou. <br><br><div class="scrollable-table"><table><tbody><tr><td></td><td>  Velocidade [req / seq] </td><td>  Mem√≥ria [MB] </td><td>  N√∫mero de scripts </td><td>  N√∫mero de fun√ß√µes </td><td>  N√∫mero de aulas </td></tr><tr><td>  Nada </td><td>  378 </td><td>  0 0 </td><td>  0 0 </td><td>  0 0 </td><td>  0 0 </td></tr><tr><td>  Todos (quase *) </td><td>  395 </td><td>  7,5 </td><td>  254 </td><td>  1770 </td><td>  148 </td></tr><tr><td>  Somente scripts usados </td><td>  396 </td><td>  4,5 </td><td>  84 </td><td>  1532 </td><td>  51 </td></tr></tbody></table></div><br>  Como resultado, <strong>devido ao pr√©-carregamento, obtivemos ~ 5% de acelera√ß√£o</strong> , o que j√° n√£o √© ruim. <br><br>  Eu baixei quase todos os arquivos, mas metade deles n√£o foram usados.  Voc√™ pode fazer ainda melhor - conduza o aplicativo, veja quais arquivos foram baixados.  Voc√™ pode fazer isso usando a fun√ß√£o <code>opcache_get_status()</code> , que retornar√° todos os arquivos em cache do OPcache e criar√° uma lista para eles para pr√©-carregamento.  Assim, voc√™ pode economizar 3 MB e obter um pouco mais de acelera√ß√£o.  O fato √© que quanto mais mem√≥ria √© necess√°ria, mais o cache do processador fica sujo e menos eficiente ele √©.  <strong>Quanto menos mem√≥ria for usada, maior a velocidade.</strong> <br><br><h2>  FFI - Interface de Fun√ß√£o Estrangeira </h2><br>  Outra tecnologia relacionada ao JIT que foi desenvolvida para PHP √© a FFI (Foreign Function Interface) ou, em russo, a capacidade de chamar fun√ß√µes escritas em outras linguagens de programa√ß√£o compiladas sem compila√ß√£o.  As implementa√ß√µes dessa tecnologia em Python impressionaram meu chefe (Zeev Surazki), e fiquei muito impressionado quando comecei a adapt√°-lo ao PHP. <br><br>  J√° houve v√°rias tentativas no PHP de criar uma extens√£o para o FFI, mas todos usaram sua pr√≥pria linguagem ou API para descrever as interfaces.  Eu espiei a id√©ia no LuaJIT, onde a linguagem C (um subconjunto) √© usada para descrever as interfaces, e o resultado √© um brinquedo muito legal.  Agora, quando preciso verificar como algo funciona em C, escrevo em PHP - isso acontece, diretamente na linha de comando. <br><br>  O FFI permite trabalhar com estruturas de dados definidas em C e pode ser integrado ao JIT para gerar c√≥digo mais eficiente.  Sua implementa√ß√£o baseada em libffi j√° est√° inclu√≠da no PHP 7.4. <br><br>  Mas: <br><br><ul><li>  Estas s√£o 1000 novas maneiras de dar um tiro no pr√≥prio p√©. </li><li>  Requer conhecimento de C e, √†s vezes, gerenciamento manual de mem√≥ria. </li><li>  N√£o suporta pr√©-processador C (#include, #define, ...) e C ++. </li><li>  O desempenho sem JIT √© bastante baixo. </li></ul><br>  Embora, talvez para alguns seja conveniente, porque o compilador n√£o √© necess√°rio.  Mesmo no Windows, isso funcionar√° sem o Visual-C do PHP. <br><br>  Vou mostrar como usar o FFI para implementar um aplicativo GUI real para Linux. <br><br>  N√£o se assuste com o c√≥digo C, eu mesmo escrevi uma GUI em C h√° 20 anos, mas encontrei esse exemplo na Internet. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;gtk/gtk.h&gt; static void activate(GtkApplication* app, gpointer user_data) { GtkWidget *window = gtk_application_window_new(app); gtk_window_set_title(GTK_WINDOW(window), "Hello from C"); gtk_window_set_default_size(GTK_WINDOW(window), 200, 200); gtk_widget_show_all(window); } int main() { int status; GtkApplication *app; app = gtk_application_new("org.gtk.example", G_APPLICATION_FLAGS_NONE); g_signal_connect(app, "activate", G_CALLBACK(activate), NULL); status = g_application_run(G_APPLICATION(app), 0, NULL); g_object_unref(app); return status; }</span></span></span></span></code> </pre> <br>  O programa cria o aplicativo, trava no evento de retorno de chamada de ativa√ß√£o, inicia o aplicativo.  No retorno de chamada, crie uma janela, atribua o tamanho do t√≠tulo e mostre-o. <br><br>  E agora, a mesma coisa reescrita no PHP: <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> $ffi = FFI::cdef(<span class="hljs-string"><span class="hljs-string">" ‚Ä¶ // #include &lt;gtk/gtk.h&gt; "</span></span>, <span class="hljs-string"><span class="hljs-string">"libgtk-3.so.0"</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">activate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($app, $user_data)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> $ffi; $window = $ffi-&gt;gtk_application_window_new($app); $ffi-&gt;gtk_window_set_title($window, <span class="hljs-string"><span class="hljs-string">"Hello from PHP"</span></span>); $ffi-&gt;gtk_window_set_default_size($window, <span class="hljs-number"><span class="hljs-number">200</span></span>, <span class="hljs-number"><span class="hljs-number">200</span></span>); $ffi-&gt;gtk_widget_show_all($window); } $app = $ffi-&gt;gtk_application_new(<span class="hljs-string"><span class="hljs-string">"org.gtk.example"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); $ffi-&gt;g_signal_connect_data($app, <span class="hljs-string"><span class="hljs-string">"activate"</span></span>, <span class="hljs-string"><span class="hljs-string">"activate"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); $ffi-&gt;g_application_run($app, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>); $ffi-&gt;g_object_unref($app);</code> </pre> <br>  Aqui, o objeto FFI √© criado primeiro.  Uma descri√ß√£o da interface √© enviada a ele como uma entrada - em ess√™ncia, um arquivo h - e a biblioteca que queremos baixar.  Depois disso, todas as fun√ß√µes descritas na interface tornam-se dispon√≠veis como m√©todos do objeto ffi, e todos os par√¢metros transferidos s√£o autom√°tica e absolutamente transparentemente convertidos na representa√ß√£o necess√°ria da m√°quina. <br><br>  Pode-se ver que tudo √© exatamente igual ao exemplo anterior.  A √∫nica diferen√ßa √© que, em C, enviamos um retorno de chamada como endere√ßo e, no PHP, a conex√£o ocorre pelo nome fornecido pela string. <br><br>  Agora vamos ver como √© a interface.  Na primeira parte, determinamos os tipos e fun√ß√µes em C e, na √∫ltima linha, carregamos a biblioteca compartilhada: <br><br><pre> <code class="cpp hljs">&lt;?php $ffi = FFI::cdef(<span class="hljs-string"><span class="hljs-string">" typedef struct _GtkApplication GtkApplication; typedef struct _GtkWidget GtkWidget; typedef void (*GCallback)(void*,void*); int g_application_run (GtkApplication *app, int argc, char **argv); unsigned long * g_signal_connect_data (void *ptr, const char *signal, GCallback handler, void *data, GCallback *destroy, int flags); void g_object_unref (void *ptr); GtkApplication * gtk_application_new (const char *app_id, int flags); GtkWidget * gtk_application_window_new (GtkApplication *app); void gtk_window_set_title (GtkWidget *win, const char *title); void gtk_window_set_default_size (GtkWidget *win, int width, int height); void gtk_widget_show_all (GtkWidget *win); "</span></span>, <span class="hljs-string"><span class="hljs-string">"libgtk-3.so.0"</span></span>); ...</code> </pre> <br>  Nesse caso, essas defini√ß√µes C s√£o copiadas dos arquivos h da biblioteca GTK, quase inalteradas. <br><br>  Para n√£o interferir com C e PHP no mesmo arquivo, voc√™ pode colocar o c√≥digo C inteiro em um arquivo separado, por exemplo, com o nome gtk-ffi.h e adicionar alguns define'ov especiais ao in√≠cio que especificam o nome da interface e a biblioteca para carregamento: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FFI_SCOPE </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"GTK"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FFI_LIB </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"libgtk-3.so.0"</span></span></span></span></code> </pre> <br>  Assim, selecionamos toda a descri√ß√£o da interface C em um arquivo.  Esse gtk-ffi.h √© quase real, mas infelizmente ainda n√£o implementamos um pr√©-processador C, o que significa que macros e inclus√µes n√£o funcionar√£o. <br><br>  Agora vamos carregar esta interface no PHP: <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GTK</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $ffi = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create_window</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($title)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (is_null(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi)) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi = FFI::load(<span class="hljs-keyword"><span class="hljs-keyword">__DIR__</span></span> . <span class="hljs-string"><span class="hljs-string">"/gtk_ffi.h"</span></span>); $app = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi-&gt;gtk_application_new(<span class="hljs-string"><span class="hljs-string">"org.gtk.example"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi-&gt;g_signal_connect_data($app, <span class="hljs-string"><span class="hljs-string">"activate"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($app, $data)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($title)</span></span></span><span class="hljs-function"> </span></span>{ $window = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi-&gt;gtk_application_window_new($app); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi-&gt;gtk_window_set_title($window, $title); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi-&gt;gtk_window_set_default_size($window, <span class="hljs-number"><span class="hljs-number">200</span></span>, <span class="hljs-number"><span class="hljs-number">200</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi-&gt;gtk_widget_show_all($window); }, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi-&gt;g_application_run($app, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi-&gt;g_object_unref($app); } }</code> </pre> <br>  Como a FFI √© uma tecnologia bastante perigosa, n√£o queremos entreg√°-la √†s m√£os de ningu√©m.  Vamos pelo menos ocultar o objeto FFI, ou seja, torn√°-lo privado dentro da classe.  E criaremos um objeto FFI n√£o usando <code>FFI::cdef</code> , mas usando <code>FFI::load</code> , que l√™ apenas nosso arquivo h do exemplo anterior. <br><br>  O restante do c√≥digo n√£o mudou muito, apenas como manipulador de eventos, come√ßamos a usar uma fun√ß√£o sem nome e passamos o t√≠tulo usando liga√ß√£o lexical.  Ou seja, usamos C e os pontos fortes do PHP, que n√£o est√£o dispon√≠veis em C. <br><br>  Uma biblioteca criada dessa maneira j√° pode ser usada em seu aplicativo.  Mas √© bom que funcione <strong>apenas na linha de comando</strong> e, se voc√™ o colocar dentro do servidor da Web, em cada solicita√ß√£o o arquivo gtk_ffi.h ser√° lido, uma biblioteca ser√° criada e carregada, com a liga√ß√£o conclu√≠da ... E todo esse trabalho repetitivo carregar√° o servidor. <br><br>  Para evitar isso e, de fato, permitir a grava√ß√£o de extens√µes PHP no pr√≥prio PHP, decidimos cruzar o FFI com o pr√©-carregamento. <br><br><h3>  FFI + pr√©-carregamento </h3><br>  O c√≥digo n√£o mudou muito, s√≥ agora damos os arquivos h para o pr√©-carregamento e executamos o <code>FFI::load</code> diretamente no momento do pr√©-carregamento, e n√£o quando criamos o objeto.  Ou seja, ao carregar a biblioteca, todas as an√°lises e liga√ß√µes s√£o feitas uma vez (quando o servidor √© iniciado) e, usando <code>FFI::scope("GTK")</code> , obtemos acesso √† interface pr√©-carregada pelo nome em nosso script. <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> FFI::load(<span class="hljs-keyword"><span class="hljs-keyword">__DIR__</span></span> . <span class="hljs-string"><span class="hljs-string">"/gtk_ffi.h"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GTK</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $ffi = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create_window</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($title)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (is_null(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi)) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi = FFI::scope(<span class="hljs-string"><span class="hljs-string">"GTK"</span></span>); $app = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi-&gt;gtk_application_new(<span class="hljs-string"><span class="hljs-string">"org.gtk.example"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi-&gt;g_signal_connect_data($app, <span class="hljs-string"><span class="hljs-string">"activate"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($app, $data)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($title)</span></span></span><span class="hljs-function"> </span></span>{ $window = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi-&gt;gtk_application_window_new($app); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi-&gt;gtk_window_set_title($window, $title); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi-&gt;gtk_window_set_default_size($window, <span class="hljs-number"><span class="hljs-number">200</span></span>, <span class="hljs-number"><span class="hljs-number">200</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi-&gt;gtk_widget_show_all($window); }, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi-&gt;g_application_run($app, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$ffi-&gt;g_object_unref($app); } }</code> </pre> <br>  Nesta modalidade, o FFI pode ser usado a partir de um servidor da web.  Obviamente, isso n√£o √© para a GUI, mas dessa forma voc√™ pode escrever, por exemplo, uma liga√ß√£o ao banco de dados. <br><br>  Uma extens√£o criada dessa maneira pode ser usada diretamente na linha de comando: <br><pre> <code class="xml hljs">$ php -d opcache.preload=gtk.php -r 'GTK::create_window(" !");'</code> </pre> <br>  Outra vantagem do cruzamento e pr√©-carregamento de FFI √© a capacidade de proibir o uso de FFI para todos os scripts no n√≠vel do usu√°rio.  Voc√™ pode especificar ffi.enable = preload, o que significa que confiamos nos arquivos pr√©-carregados, mas √© proibido chamar FFI a partir de scripts PHP regulares. <br><br><h3>  Trabalhando com estruturas de dados C </h3><br>  Outro recurso interessante do FFI √© que ele pode trabalhar com estruturas de dados nativas.  Voc√™ pode, a qualquer momento, criar na mem√≥ria qualquer estrutura de dados descrita em C. <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> $points = FFI::new(<span class="hljs-string"><span class="hljs-string">"struct {int x,y;} [100]"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ($x = <span class="hljs-number"><span class="hljs-number">0</span></span>; $x &lt; count($points); $x++) { $points[$x]-&gt;x = $x; $points[$x]-&gt;y = $x * $x; } var_dump($points[<span class="hljs-number"><span class="hljs-number">25</span></span>]-&gt;y); <span class="hljs-comment"><span class="hljs-comment">// 625 var_dump(FFI::sizeof($points)); // 800  foreach ($points as &amp;$p) { $p-&gt;x += 10; } var_dump($points[25]-&gt;x); // 35</span></span></code> </pre> <br>    100  (  FFI::new != new FFI),     integer.       ,    C.             PHP,     .     count, /        foreach  .      800 ,      PHP      PHP'   ,       10 . <br><br>   FFI: <br><br><ul><li> <a href="https://github.com/dstogov/php-tensorflow"> </a>  PHP. </li><li> <a href="https://github.com/ircmaxell/libgccffi"></a>  PHP. </li></ul><br> Python/CFFI    :  (Cario, JpegTran),  (ffmpeg),  (LibreOfficeKit),   (SDL)    (TensorFlow). <br><br> <strong> ,   FFI    .</strong> <br><br>   -   PHP.    ,      ,      callback'        ,      .         FFI.  ,   .    FFI c JIT, ,   LuaJIT,    .      ,    ,     . <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ($k=<span class="hljs-number"><span class="hljs-number">0</span></span>; $k&lt;<span class="hljs-number"><span class="hljs-number">1000</span></span>; $k++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ($i=$n<span class="hljs-number"><span class="hljs-number">-1</span></span>; $i&gt;=<span class="hljs-number"><span class="hljs-number">0</span></span>; $i--) { $Y[$i] += $X[$i]; } }</code> </pre> <br>      FFI   . <br><div class="scrollable-table"><table><tbody><tr><td></td><td> Native Arrays </td><td> FFI Arrays </td></tr><tr><td> PyPy </td><td> 0,010 </td><td> 0,081 </td></tr><tr><td> Python </td><td> 0,212 </td><td> 0,343 </td></tr><tr><td> LuaJIt -joff </td><td> 0,037 </td><td> 0,412 </td></tr><tr><td> LuaJit -jon </td><td> 0,003 </td><td> 0,002 </td></tr><tr><td>  Php </td><td> 0,040 </td><td> 0,093 </td></tr><tr><td> PHP + JIT </td><td> 0,016 </td><td> 0,087 </td></tr></tbody></table></div><br> <em>  : Zeev Surasky (Zend), Andi Gutmans (ex-Zend, Amazon), Xinchen Hui (ex-Weibo, ex-Zend, Lianjia), Nikita Popov (JetBrains), Anatol Belsky (Microsoft), Anthony Ferrara (ex-Google, Lingo Live), Joe Watkins, Mohammad Reza Haghighat (Intel)   Intel, Andy Wingo (JS hacker, Igalia), Mike Pall ( LuaJIT).</em> <br><br>        ,       ,    <a href="https://www.youtube.com/watch%3Fv%3D7UOWus-5yxg%26amp%3Bfeature%3Dyoutu.be%26amp%3Bt%3D1804"></a> . <br><br><blockquote> <a href="https://phprussia.ru/moscow/2020">PHP Russia 2020</a> !     <a href="http://eepurl.com/VYVaf"></a>  <a href="https://t.me/PHPRussiaConfChannel">telegram-</a> ,    2019     <a href="https://www.youtube.com/channel/UCxLQ9eT6YHnc6dMLRFzEc7Q">youtube-</a>  ,       , ‚Äî <a href="https://conf.ontico.ru/lectures/propose%3Fconference%3Dpc2020"> </a>  . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt481092/">https://habr.com/ru/post/pt481092/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt481074/index.html">Calculadora Python</a></li>
<li><a href="../pt481078/index.html">A participa√ß√£o falhou: levamos o AgentTesla √† √°gua limpa. Parte 3</a></li>
<li><a href="../pt481082/index.html">Mohnatiki captura o mercado para a ind√∫stria de jogos! Peregrine Labs anuncia colabora√ß√£o com a Epic Games</a></li>
<li><a href="../pt481084/index.html">Python, introdu√ß√£o ao banco de dados</a></li>
<li><a href="../pt481086/index.html">Vivaldi 2.10 - Agente secreto</a></li>
<li><a href="../pt481094/index.html">Sobre os fones de ouvido sem fio JBL com energia solar e o que h√° de errado com eles</a></li>
<li><a href="../pt481100/index.html">Angular 9, o que h√° de novo?</a></li>
<li><a href="../pt481102/index.html">Lan√ßamento do kit de ferramentas de interface do usu√°rio .NET entre plataformas AvaloniaUI 0.9</a></li>
<li><a href="../pt481104/index.html">Misturando OpenJDK e NodeJS: intera√ß√µes entre idiomas e arquitetura vertical</a></li>
<li><a href="../pt481106/index.html">Como LANIT filmou uma com√©dia DIY em seu escrit√≥rio</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>