<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏭 🔵 😧 Un peu sur les modèles de conception génératifs 🎅🏽 ✌🏽 🤙🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Le thème des modèles de conception est assez populaire. De nombreuses vidéos ont été tournées dessus et des articles ont été écrits. Combine tous ces ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Un peu sur les modèles de conception génératifs</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467817/"><p>  Le thème des modèles de conception est assez populaire.  De nombreuses vidéos ont été tournées dessus et des articles ont été écrits.  Combine tous ces matériaux avec un «anti-motif». Complexité accidentelle.  En conséquence, les exemples sont abstraits, la description prête à confusion, la manière de postuler n'est pas claire.  Et la tâche principale des modèles de conception - la simplification (du code et du travail en général) n'est pas réalisée.  Après tout, l'utilisation du modèle nécessite des efforts supplémentaires.  À peu près la même chose que les tests unitaires. </p><br><p>  Je vais essayer d'expliquer les modèles de conception en termes de comment les appliquer, où et pourquoi. </p><a name="habracut"></a><br><p>  Six générateurs peuvent être attribués à: </p><br><ul><li>  Prototype </li><li>  Usine abstraite, </li><li>  Méthode d'usine </li><li>  Constructeur </li><li>  Singleton </li><li>  Initialisation paresseuse. </li></ul><br><p>  Tous les autres modèles relatifs aux générateurs sont un cas particulier d'application et il est inutile de s'y attarder. </p><br><p>  La génération de modèles peut être divisée en trois groupes, sur la question à laquelle ils répondent.  Donc, trois questions: </p><br><ul><li>  O?? </li><li>  Comment? </li><li>  Quand? </li></ul><br><h2>  O?? </h2><br><p>  Trois modèles répondent à cette question: prototype, usine abstraite et méthode d'usine. </p><br><div class="spoiler">  <b class="spoiler_title">Un peu sur les termes</b> <div class="spoiler_text"><p>  Dans le cadre du concept de POO, il n'y a que trois endroits où il est théoriquement possible de générer une nouvelle instance. </p><br><ul><li>  Le produit est la classe qui est instanciée. </li><li>  Le client est la classe qui utilisera l'instance instanciée. </li><li>  Partenaire - toute troisième classe dans le domaine de la visibilité du Client. </li></ul><br></div></div><br><p>  En fait, ces modèles déterminent le lieu de génération.  De plus, ils sont connectés hiérarchiquement et ont une portée différente.  La connexion est indiquée sur la figure, les flèches déterminent le sens des appels. </p><br><img src="https://github.com/mtemp123/Design-Patterns/raw/master/img/Creational_patterns1.png" alt="La hiérarchie des modèles génératifs"><br><p>  Dans sa mise en œuvre, la «méthode Factory» peut déléguer la génération d'une instance à la «Factory» existante ou au «prototype».  Le «prototype», cependant, ne devrait dépendre de personne et tout faire tout seul.  Maintenant plus en détail. </p><br><h3>  "Prototype" </h3><br><p>  Ce modèle correspond à la place "Produit", en fait, est le constructeur de la classe.  Par conséquent, une instance d'une classe spécifique (précédemment connue) est toujours générée. <br>  Dans le cadre de ce modèle, le constructeur ne connaît que les paramètres qui lui sont directement transmis (le nombre de paramètres tend vers le nombre de champs de classe).  Bien sûr, il y a un accès complet à tous les champs et propriétés de la classe créée. </p><br><p>  Des méthodes correctement mises en œuvre du "Prototype" vous permettent de vous débarrasser des méthodes d'initialisation supplémentaires en public.  À son tour, l'interface externe de la classe devient plus facile et moins tentante d'utiliser la classe à d'autres fins. </p><br><p>  Ce que ce modèle nous donne: </p><br><ul><li>  Faible connectivité - la classe ne se connaît que, ne dépend pas de données externes; </li><li>  Extensibilité - les constructeurs peuvent être redéfinis ou ajoutés aux descendants; </li></ul><br><p>  Des inconvénients: </p><br><ul><li>  Pour les classes complexes, vous devrez peut-être passer de nombreux paramètres pour l'initialisation.  Bien qu'il existe une solution triviale. </li><li>  Une utilisation directe dans le client peut nuire à la lisibilité et bloquer pratiquement la possibilité de remplacer le type d'instance généré dans le descendant du client. </li></ul><br><p>  Le modèle le plus populaire.  Tout le monde l'utilise, mais peu savent ce qu'il utilise.  C'est bon jusqu'à ce que le premier modèle de travail soit obtenu, jusqu'à ce que les classes et leurs relations soient complètement définies.  Après cela, le traitement et l'augmentation de l'abstraction sont obligatoires. </p><br><h3>  "Usine abstraite" </h3><br><p>  Un partenaire de classe.  Il peut être spécialisé ou "combiner".  Peut être statique (pas d'instance).  Un exemple de «combinaison» peut être une classe de configuration.  Il peut également être caché derrière la façade. </p><br><p>  "Factory" voit généralement tous les paramètres globaux de l'application (ou d'un sous-système séparé).  La génération immédiate peut être déléguée au prototype.  Dans le même temps, le nombre de paramètres d'entrée dans la méthode Factory sera inférieur à celui d'un constructeur de prototype similaire.  L'usine ne décide pas qui créer en fonction des paramètres entrants. </p><br><p>  Ce modèle est très pratique et facile à mettre en œuvre, mais nécessite une conception préliminaire.  Si vous créez des usines pour tout, cela compliquera le code.  En fait, nous obtenons un analogue du prototype, mais nous sommes passés à une classe tierce. </p><br><p>  Des pros: </p><br><ul><li>  Bonne redéfinition des descendants </li><li>  Appel simplifié </li><li>  Sur la base de la Factory, il est facile d'implémenter une substitution (modèle State) </li></ul><br><p>  Mais il y a aussi des inconvénients: </p><br><br><ul><li>  Il nécessite une conception, en particulier pour les usines universelles (qui sont utilisées dans de nombreux projets).  En d'autres termes, il n'est pas facile d'obtenir immédiatement une bonne usine. </li><li>  Il est très facile de gâcher le code, il y a deux domaines principaux: <br><ul><li>  Glissant vers le prototype, mais dans une classe extérieure.  Les méthodes sont surchargées de paramètres; il existe de nombreuses méthodes elles-mêmes.  En conséquence, l'héritage est difficile, à la fois dans l'usine elle-même et dans le client. </li><li>  Usine avec méthode universelle.  Cette méthode renvoie n'importe quelle instance en fonction des paramètres transmis.  Le résultat, comme dans le premier cas. </li></ul><br></li></ul><br><p>  Très populaire.  Ce modèle est utilisé par ceux qui ont suivi le cours du GoF.  En règle générale, le code devient encore pire qu'avant d'appliquer les modèles. </p><br><p>  Cela a du sens lorsque des usines apparaissent lors de la première révision du code.  À ce stade, les combinaisons de paramètres pour les instances créées sont déjà connues et il ne sera pas difficile d'écrire des méthodes Factory généralisées.  En conséquence, les appels dans le client seront simplifiés. </p><br><p>  Dans certains cas, il est pratique de cacher les usines derrière la façade.  Par exemple, l'application possède une douzaine de ses usines et une douzaine de bibliothèques.  Pour eux, vous pouvez construire une façade.  Cela permettra de ne pas lier les bibliothèques à chaque module, et il est également facile de remplacer une usine par une autre. </p><br><h3>  Méthode d'usine </h3><br><p>  Le sommet de l'abstraction dans les modèles génératifs.  Lieu d'origine Client.  La classe dans laquelle chaque produit est placé dans la méthode d'usine a toutes les chances d'une longue durée de vie.  Si sans fanatisme, alors l'axe de développement supposé doit nécessairement être basé sur ce modèle. </p><br><p>  La méthode d'usine ne voit pas au-delà de sa classe.  Le nombre de paramètres transmis directement doit être minimal (dans la limite de zéro).  La méthode elle-même doit être construite en tenant compte de la possibilité de chevauchement dans le descendant. </p><br><p>  Une erreur courante est l'initialisation compliquée dans une méthode.  Par exemple, lors de la création d'une instance complexe (le modèle Builder), la création de toutes les parties du futur objet est placée dans une seule méthode.  En conséquence, une telle méthode est difficile à chevaucher chez le descendant. </p><br><p>  Des pros: </p><br><ul><li>  Il sera facile de faire correspondre la méthode du modèle de modèle </li><li>  Nous obtenons un code concis dans lequel la logique est clairement visible (elle n'a pas besoin d'être consultée parmi un tas de méthodes et de paramètres) </li></ul><br><p>  Il n'y a essentiellement aucun inconvénient. </p><br><p>  Ce modèle n'est presque jamais utilisé.  En règle générale, il ne peut être vu que dans les projets avec une élaboration préliminaire approfondie.  Idéal lorsque la méthode d'usine délègue la génération à l '"usine" ou au "prototype". </p><br><h3>  Petit exemple </h3><br><p>  Nous avons une classe pour se connecter à un fichier sur le disque dur.  Voici à quoi pourraient ressembler les méthodes génériques dans les modèles «Où?»: </p><br><h4>  Prototype: </h4><br><pre><code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(aFilename: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">; aLogLevel: TLogLevel)</span></span></span><span class="hljs-function">;</span></span></code> </pre> <br><p>  Tout ce que le concepteur doit savoir lui est transmis sous forme de paramètres. </p><br><h4>  Usine: </h4><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetLogger</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(aLogLevel: TLogLevel)</span></span></span><span class="hljs-function">:</span></span> ILogger;</code> </pre> <br><p>  L'usine sait dans quel fichier écrire, comme spécifié dans les paramètres de l'application. </p><br><h4>  Méthode d'usine: </h4><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewLogger</span></span></span><span class="hljs-function">:</span></span> ILogger;</code> </pre> <br><p>  Dans la classe Client, on sait avec quels détails se connecter. </p><br><p>  Dans cette conception, pour remplacer la classe de journalisation par un stub, il suffit de redéfinir NewLogger dans le descendant du client.  Ceci est utile lors des tests unitaires. </p><br><p>  Pour se connecter à la base de données, il suffit de remplacer la méthode GetLogger dans le descendant de Factory. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr467817/">https://habr.com/ru/post/fr467817/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr467803/index.html">Simulation élémentaire d'interaction physique personnalisée en python + matplotlib</a></li>
<li><a href="../fr467807/index.html">Acheter et vendre des crypto-monnaies en Russie: méthodes, légalisation, risques</a></li>
<li><a href="../fr467811/index.html">Architecture et programmation Fairchild Channel F</a></li>
<li><a href="../fr467813/index.html">Révision des changements dans le 17e ordre du FSTEC</a></li>
<li><a href="../fr467815/index.html">Les médias ont paniqué que "les adresses IP s'épuisent en Russie". Comment vraiment?</a></li>
<li><a href="../fr467821/index.html">Simplifiez et éliminez les besoins: entretien avec John Romero, créateur de Doom</a></li>
<li><a href="../fr467823/index.html">Analyse: MOO sur Kubernetes</a></li>
<li><a href="../fr467825/index.html">Algorithmes d'apprentissage automatique indispensables</a></li>
<li><a href="../fr467827/index.html">Comment nous avons fait notre petite unité à partir de zéro</a></li>
<li><a href="../fr467831/index.html">La voie épineuse de la programmation</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>