<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧙🏾 🤙🏾 🏓 Comment ne pas jeter dans Java 🤲 👨🏾‍🎨 🛵</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Il existe une idée fausse très répandue selon laquelle si vous n'aimez pas la récupération de place, vous devez écrire non pas en Java, mais en C / C ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment ne pas jeter dans Java</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436024/"><p>  Il existe une idée fausse très répandue selon laquelle si vous n'aimez pas la récupération de place, vous devez écrire non pas en Java, mais en C / C ++.  Depuis trois ans, j'écris du code Java à faible latence pour le trading de devises, et j'ai dû éviter de créer des objets inutiles à tous points de vue.  En conséquence, j'ai formulé quelques règles simples pour moi-même, comment réduire les allocations en Java, sinon à zéro, puis à un minimum raisonnable, sans recourir à la gestion manuelle de la mémoire.  Ce sera peut-être aussi utile à quelqu'un de la communauté. </p><a name="habracut"></a><br><h2>  Pourquoi éviter les ordures du tout </h2><br><p>  A propos de ce qu'est GC et comment les configurer, il a été dit et écrit beaucoup.  Mais en fin de compte, peu importe la façon dont vous configurez le GC, le code de cette litière ne fonctionnera pas de manière optimale.  Il y a toujours un compromis entre le débit et la latence.  Il devient impossible d'améliorer l'un sans aggraver l'autre.  En règle générale, les frais généraux du GC sont mesurés en étudiant les journaux - vous pouvez comprendre d'eux à quels moments il y a eu des pauses et combien de temps ils ont pris.  Cependant, les journaux GC ne contiennent pas toutes les informations sur cette surcharge.  L'objet créé par le thread est automatiquement placé dans le cache L1 du cœur de processeur sur lequel le thread s'exécute.  Cela conduit à l'éviction d'autres données potentiellement utiles.  Avec un grand nombre d'allocations, les données utiles peuvent également être extraites du cache L3.  La prochaine fois que le thread accédera à ces données, un cache manquant se produira, ce qui entraînera des retards dans l'exécution du programme.  De plus, comme le cache L3 est commun à tous les cœurs du même processeur, un flux de déchets poussera les données et autres threads / applications du cache L3, et ils rencontreront déjà des échecs de cache supplémentaires, même s'ils sont écrits en C nu et ne créez pas de déchets.  Aucun paramètre, aucun récupérateur de place (ni C4, ni ZGC) n'aidera à résoudre ce problème.  La seule façon d'améliorer la situation dans son ensemble est de ne pas créer inutilement des objets inutiles.  Java, contrairement à C ++, ne dispose pas d'un arsenal riche de mécanismes pour travailler avec la mémoire, mais il existe néanmoins un certain nombre de façons de minimiser les allocations.  Ils seront discutés. </p><br><div class="spoiler">  <b class="spoiler_title">Digression lyrique</b> <div class="spoiler_text"><p>  Bien sûr, vous n'avez pas besoin d'écrire tout le code sans déchets.  Le truc avec le langage Java, c'est que vous pouvez grandement vous simplifier la vie en supprimant uniquement les principales sources de déchets.  Vous ne pouvez pas non plus gérer la récupération de mémoire en toute sécurité lors de l'écriture d'algorithmes sans verrouillage.  Si un certain code n'est exécuté qu'une seule fois au démarrage de l'application, il peut en allouer autant que vous le souhaitez, et ce n'est pas grave.  Eh bien, bien sûr, le principal outil de travail pour se débarrasser des déchets en excès est le profileur d'allocation. </p></div></div><br><h2>  Utilisation de types primitifs </h2><br><p> La chose la plus simple qui peut être faite dans de nombreux cas est d'utiliser des types primitifs au lieu de types d'objets.  La machine virtuelle Java dispose d'un certain nombre d'optimisations pour minimiser la surcharge des types d'objet, comme la mise en cache de petites valeurs de types entiers et l'inclusion de classes simples.  Mais ces optimisations ne valent pas toujours la peine d'être utilisées, car elles peuvent ne pas fonctionner: une valeur entière peut ne pas être mise en cache et l'inlining peut ne pas se produire.  De plus, lorsque nous travaillons avec un entier conditionnel, nous sommes obligés de suivre le lien, ce qui conduit potentiellement à un échec de cache.  De plus, tous les objets ont des en-têtes qui occupent de l'espace supplémentaire dans le cache, évinçant ainsi d'autres données.  Prenons-le: un primitif int prend 4 octets.  L'objet <code>Integer</code> prend 16 octets + la taille du lien vers cet Integer est de 4 octets minimum (dans le cas de oops compressés).  Au total, il s'avère que <code>Integer</code> occupe cinq (!) Fois plus d'espace <code>int</code> .  Par conséquent, il est préférable d'utiliser vous-même les types primitifs.  Je vais donner quelques exemples. </p><br><h3>  Exemple 1. Calculs conventionnels </h3><br><p>  Disons que nous avons une fonction régulière qui compte juste quelque chose. </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">Integer </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Integer a, Integer b, Integer c)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (a + b) / c; }</code> </pre> <br><p>  Un tel code est susceptible de devenir en ligne (à la fois la méthode et les classes) et ne conduira pas à des allocations inutiles, mais vous ne pouvez pas en être sûr.  Même si cela se produit, il y aura un problème avec le fait qu'une <code>NullPointerException</code> pourrait voler d'ici.  D'une manière ou d'une autre, la JVM devra soit insérer <code>null</code> vérifications <code>null</code> sous le capot, soit comprendre d'une manière ou d'une autre du contexte que <code>null</code> ne peut pas être un argument.  Quoi qu'il en soit, il vaut mieux simplement écrire le même code sur les primitives. </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (a + b) / c; }</code> </pre> <br><h3>  Exemple 2. Lambdas </h3><br><p>  Parfois, des objets sont créés à notre insu.  Par exemple, si nous transmettons des types primitifs à l'endroit où les types d'objets sont attendus.  Cela se produit souvent lors de l'utilisation d'expressions lambda. <br>  Imaginez que nous ayons ce code: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Consumer&lt;Integer&gt; calculator)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = System.currentTimeMillis(); calculator.accept(x); }</code> </pre> <br><p>  Malgré le fait que la variable x soit une primitive, un objet de type Integer sera créé, qui sera transmis à la calculatrice.  Pour éviter cela, utilisez <code>IntConsumer</code> au lieu de <code>Consumer&lt;Integer&gt;</code> : </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IntConsumer calculator)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = System.currentTimeMillis(); calculator.accept(x); }</code> </pre> <br><p>  Un tel code ne conduira plus à la création d'un objet supplémentaire.  Java.util.function dispose d'un ensemble complet d'interfaces standard adaptées à l'utilisation de types primitifs: <code>DoubleSupplier</code> , <code>LongFunction</code> , etc.  Eh bien, si quelque chose manque, vous pouvez toujours ajouter l'interface souhaitée avec des primitives.  Par exemple, au lieu de <code>BiConsumer&lt;Integer, Double&gt;</code> vous pouvez utiliser une interface maison. </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IntDoubleConsumer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">accept</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y)</span></span></span></span>; }</code> </pre> <br><h3>  Exemple 3. Collections </h3><br><p>  L'utilisation d'un type primitif peut être difficile car une variable de ce type se trouve dans une collection.  Supposons que nous ayons une <code>List&lt;Integer&gt;</code> et que nous voulons savoir quels nombres s'y trouvent et calculer combien de fois chacun des nombres est répété.  Pour cela, nous utilisons <code>HashMap&lt;Integer, Integer&gt;</code> .  Le code ressemble à ceci: </p><br><pre> <code class="java hljs">List&lt;Integer&gt; numbers = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); <span class="hljs-comment"><span class="hljs-comment">// fill numbers somehow Map&lt;Integer, Integer&gt; counters = new HashMap&lt;&gt;(); for (Integer x : numbers) { counters.compute(x, (k, v) -&gt; v == null ? 1 : v + 1); }</span></span></code> </pre> <br><p>  Ce code est mauvais de plusieurs façons à la fois.  Premièrement, il utilise une structure de données intermédiaire, ce qui pourrait probablement se faire sans.  Eh bien, pour plus de simplicité, nous supposons que cette liste sera nécessaire plus tard, c'est-à-dire  vous ne pouvez pas le supprimer complètement.  Deuxièmement, l'objet <code>Integer</code> utilisé aux deux endroits au lieu de primitive <code>int</code> .  Troisièmement, il existe de nombreuses allocations dans la méthode de <code>compute</code> .  Quatrièmement, un itérateur est attribué.  Cette allocation est susceptible de devenir en ligne, mais néanmoins.  Comment transformer ce code en code sans ordures?  Vous avez juste besoin d'utiliser la collection sur les primitives d'une bibliothèque tierce.  Il existe un certain nombre de bibliothèques contenant de telles collections.  Le morceau de code suivant utilise la bibliothèque <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">agrona</a> . </p><br><pre> <code class="java hljs">IntArrayList numbers = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IntArrayList(); <span class="hljs-comment"><span class="hljs-comment">// fill numbers somehow Int2IntCounterMap counters = new Int2IntCounterMap(0); for (int i = 0; i &lt; numbers.size(); i++) { counters.incrementAndGet(numbers.getInt(i)); }</span></span></code> </pre> <br><p>  Les objets qui sont créés ici sont deux collections et deux <code>int[]</code> , qui sont situés à l'intérieur de ces collections.  Les deux collections peuvent être réutilisées en appelant la méthode <code>clear()</code> sur elles.  En utilisant des collections sur des primitives, nous n'avons pas compliqué notre code (et nous l'avons même simplifié en supprimant la méthode de calcul avec un lambda complexe à l'intérieur) et avons reçu les bonus supplémentaires suivants par rapport à l'utilisation de collections standard: </p><br><ol><li>  Absence presque totale d'allocations.  Si les collections sont réutilisées, il n'y aura aucune allocation du tout. </li><li>  <code>IntArrayList</code> mémoire importantes ( <code>IntArrayList</code> prend environ cinq fois moins d'espace que <code>ArrayList&lt;Integer&gt;</code> . Comme déjà mentionné, nous nous soucions de l'utilisation économique des caches de processeur, pas de RAM. </li><li>  Accès série à la mémoire.  Beaucoup de choses ont été écrites sur la raison pour laquelle cela est important, donc je ne m'arrêterai pas là.  Voici quelques articles: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Martin Thompson</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ulrich Drepper</a> . </li></ol><br><p>  Un autre petit commentaire sur les collections.  Il peut s'avérer que la collection contient des valeurs de différents types et qu'il n'est donc pas possible de la remplacer par une collection avec des primitives.  À mon avis, c'est un signe de mauvaise conception de la structure des données ou de l'algorithme dans son ensemble.  Dans ce cas, très probablement, l'allocation d'objets supplémentaires n'est pas le problème principal. </p><br><h2>  Objets mutables </h2><br><p>  Mais que faire si les primitives ne peuvent pas être supprimées?  Par exemple, dans le cas où la méthode dont nous avons besoin devrait renvoyer plusieurs valeurs.  La réponse est simple: utilisez des objets mutables. </p><br><div class="spoiler">  <b class="spoiler_title">Petite digression</b> <div class="spoiler_text"><p>  Certaines langues mettent l'accent sur l'utilisation d'objets immuables, par exemple en Scala.  L'argument principal en leur faveur est que l'écriture de code multithread est grandement simplifiée.  Cependant, il existe également des frais généraux associés à une allocation excessive des ordures.  Si nous voulons les éviter, nous ne devons pas créer d’objets immuables de courte durée. </p></div></div><br><p>  À quoi cela ressemble-t-il dans la pratique?  Supposons que nous devions calculer le quotient et le reste de la division.  Et pour cela, nous utilisons le code suivant. </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IntPair</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y; } <span class="hljs-function"><span class="hljs-function">IntPair </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">divide</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> divisor)</span></span></span><span class="hljs-function"> </span></span>{ IntPair result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IntPair(); result.x = value / divisor; result.y = value % divisor; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p>  Comment se débarrasser de l'allocation dans ce cas?  C'est vrai, passez <code>IntPair</code> comme argument et écrivez-y le résultat.  Dans ce cas, vous devez écrire un javadoc détaillé et, mieux encore, utiliser une sorte de convention pour les noms de variable, où le résultat est écrit.  Par exemple, ils peuvent commencer par le préfixe out.  Le code sans déchets dans ce cas ressemblera à ceci: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">divide</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> divisor, IntPair outResult)</span></span></span><span class="hljs-function"> </span></span>{ outResult.x = value / divisor; outResult.y = value % divisor; }</code> </pre> <br><p>  Je tiens à noter que la méthode de <code>divide</code> ne doit pas enregistrer un lien à associer n'importe où ni le transmettre à des méthodes qui peuvent le faire, sinon nous pourrions avoir de gros problèmes.  Comme nous pouvons le voir, les objets mutables sont plus difficiles à utiliser que les types primitifs, donc si vous pouvez utiliser des primitives, il vaut mieux le faire.  En fait, dans notre exemple, nous avons transféré le problème de l'allocation de l'intérieur de la méthode de division vers l'extérieur.  Dans tous les endroits où nous appelons cette méthode, nous aurons besoin d'un mannequin <code>IntPair</code> , que nous passerons à <code>divide</code> .  Assez souvent pour stocker ce mannequin dans le <code>final</code> champ de l'objet, d'où nous appelons la méthode de <code>divide</code> .  Permettez-moi de vous donner un exemple artificiel: supposons que notre programme ne traite que de la réception d'un flux de nombres sur le réseau, les divise et envoie le résultat à la même socket. </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SocketListener</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> IntPair pair = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IntPair(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> BufferedReader in; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> PrintWriter out; SocketListener(<span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Socket socket) <span class="hljs-keyword"><span class="hljs-keyword">throws</span></span> IOException { in = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BufferedReader(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InputStreamReader(socket.getInputStream())); out = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PrintWriter(socket.getOutputStream(), <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">listenSocket</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value = in.read(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> divisor = in.read(); divide(value, divisor, pair); out.print(pair.x); out.print(pair.y); } } }</code> </pre> <br><p>  Par souci de concision, je n'ai pas écrit de code «supplémentaire» pour la gestion des erreurs, la terminaison correcte du programme, etc.  L'idée principale de ce morceau de code est que l'objet <code>IntPair</code> nous <code>IntPair</code> est créé une fois et stocké dans le champ <code>final</code> . </p><br><h2>  Pools d'objets </h2><br><p>  Lorsque nous utilisons des objets mutables, nous devons d'abord prendre un objet vide de quelque part, puis y écrire les données dont nous avons besoin, l'utiliser quelque part, puis retourner l'objet «en place».  Dans l'exemple ci-dessus, l'objet était toujours «en place», c'est-à-dire  dans le <code>final</code> champ.  Malheureusement, ce n'est pas toujours possible de le faire de manière simple.  Par exemple, nous pouvons ne pas savoir à l'avance exactement combien d'objets nous avons besoin.  Dans ce cas, les pools d'objets viennent à notre aide.  Lorsque nous avons besoin d'un objet vide, nous l'obtenons à partir du pool d'objets, et lorsqu'il cesse d'être nécessaire, nous le renvoyons là.  S'il n'y a pas d'objet libre dans le pool, le pool crée un nouvel objet.  Il s'agit en fait d'une gestion manuelle de la mémoire avec toutes les conséquences qui en découlent.  Il est conseillé de ne pas recourir à cette méthode s'il est possible d'utiliser les méthodes précédentes.  Qu'est-ce qui pourrait mal tourner? </p><br><ul><li>  Nous pouvons oublier de renvoyer l'objet dans le pool, puis des ordures ("fuite de mémoire") seront créées.  Il s'agit d'un petit problème - les performances diminueront légèrement, mais le GC fonctionnera et le programme continuera de fonctionner. </li><li>  Nous pouvons renvoyer l'objet dans le pool, mais enregistrer le lien vers celui-ci quelque part.  Ensuite, quelqu'un d'autre récupérera l'objet du pool, et à ce stade de notre programme, il y aura déjà deux liens vers le même objet.  Il s'agit d'un problème classique d'utilisation après libération.  C'est difficile de faire ses débuts parce que  contrairement à C ++, le programme ne se bloquera pas et continuera <em>à</em> fonctionner de <em>manière incorrecte</em> . </li></ul><br><p>  Afin de réduire la probabilité de faire les erreurs ci-dessus, vous pouvez utiliser la construction standard try-with-resources.  Cela peut ressembler à ceci: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Storage</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dispose</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T object)</span></span></span></span>; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IntPair</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AutoCloseable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Storage&lt;IntPair&gt; STORAGE = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StorageImpl(IntPair::<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IntPair</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> IntPair </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> STORAGE.get(); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ STORAGE.dispose(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } }</code> </pre> <br><p>  La méthode de division pourrait ressembler à ceci: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">IntPair </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">divide</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> divisor)</span></span></span><span class="hljs-function"> </span></span>{ IntPair result = IntPair.create(); result.x = value / divisor; result.y = value % divisor; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p>  Et la méthode <code>listenSocket</code> comme ceci: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">listenSocket</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value = in.read(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> divisor = in.read(); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (IntPair pair = divide(value, divisor)) { out.print(pair.x); out.print(pair.y); } } }</code> </pre> <br><p>  Dans l'EDI, vous pouvez généralement configurer la mise en surbrillance de tous les cas lorsque des objets à fermeture <code>AutoCloseable</code> sont utilisés en dehors du bloc try-with-resources.  Mais ce n'est pas une option absolue, car  la mise en surbrillance dans l'IDE peut simplement être désactivée.  Par conséquent, il existe un autre moyen de garantir le retour de l'objet à l'inversion de contrôle de pool.  Je vais donner un exemple: </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IntPair</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AutoCloseable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Storage&lt;IntPair&gt; STORAGE = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StorageImpl(IntPair::<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IntPair</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Consumer&lt;IntPair&gt; consumer)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>(IntPair pair = STORAGE.get()) { consumer.accept(pair); } } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ STORAGE.dispose(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } }</code> </pre> <br><p>  Dans ce cas, nous ne pouvons fondamentalement pas accéder à l'objet de la classe <code>IntPair</code> extérieur.  Malheureusement, cette méthode ne fonctionne pas toujours.  Par exemple, cela ne fonctionnera pas si un thread obtient des objets du pool et les place dans une file d'attente, et qu'un autre thread les sort de la file d'attente et revient dans le pool. </p><br><p>  Évidemment, si nous ne stockons pas d'objets génériques dans le pool, mais certains objets de bibliothèque qui <code>AutoCloseable</code> pas <code>AutoCloseable</code> , alors l'option essayer avec des ressources ne fonctionnera pas non plus. </p><br><p>  Un problème supplémentaire ici est le multithreading.  L'implémentation du pool d'objets doit être très rapide, ce qui est assez difficile à réaliser.  Un pool lent peut faire plus de mal que de bien aux performances.  À son tour, l'allocation de nouveaux objets dans TLAB est très rapide, beaucoup plus rapide que malloc en C. L'écriture d'un pool d'objets rapide est un sujet distinct que je ne voudrais pas développer maintenant.  Je peux seulement dire que je n'ai vu aucune bonne implémentation «prête à l'emploi». </p><br><h2>  Au lieu d'une conclusion </h2><br><p>  En bref, la réutilisation d'objets avec des pools d'objets est une grave hémorroïde.  Heureusement, vous pouvez presque toujours vous en passer.  Mon expérience personnelle est que l'utilisation excessive des pools d'objets signale des problèmes avec l'architecture de l'application.  En règle générale, une instance de l'objet mis en cache dans le champ <code>final</code> nous suffit.  Mais même cela est exagéré s'il est possible d'utiliser des types primitifs. </p><br><h2>  Mise à jour: </h2><br><p>  Oui, je me suis souvenu d'une autre façon pour ceux qui n'ont pas peur des changements au niveau du bit: regrouper plusieurs petits types primitifs en un seul grand.  Supposons que nous devions retourner deux <code>int</code> .  Dans ce cas particulier, vous ne pouvez pas utiliser l'objet <code>IntPair</code> , mais renvoyer un <code>long</code> , les 4 premiers octets dans lesquels correspondra le premier <code>int</code> , et les 4 derniers octets au second.  Le code pourrait ressembler à ceci: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">combine</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> left, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> right)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)left &lt;&lt; Integer.SIZE) | (<span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)right &amp; <span class="hljs-number"><span class="hljs-number">0xFFFFFFFFL</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getLeft</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(value &gt;&gt;&gt; Integer.SIZE); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getRight</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)value; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">divide</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> divisor)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = value / divisor; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = value % divisor; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> combine(left, right); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">listenSocket</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value = in.read(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> divisor = in.read(); <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> xy = divide(value, divisor); out.print(getLeft(xy)); out.print(getRight(xy)); } }</code> </pre> <br><p>  De telles méthodes, bien sûr, doivent être testées à fond, car il est assez facile de les écrire.  Mais alors utilisez-le. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr436024/">https://habr.com/ru/post/fr436024/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr436012/index.html">Je suis un idiot inutile, donc je veux quitter mon travail: 10 questions à un développeur de logiciels, un épisode pilote</a></li>
<li><a href="../fr436014/index.html">Modèles mathématiques du chaos</a></li>
<li><a href="../fr436016/index.html">Asterisk Voice Recognition IVR - Rapide, facile et gratuit</a></li>
<li><a href="../fr436020/index.html">Magento 2: importation de produits à partir de sources externes</a></li>
<li><a href="../fr436022/index.html">Comment nous avons développé Librem 5 DevKit entièrement en logiciel libre</a></li>
<li><a href="../fr436026/index.html">Info Desk: «Internet Archive» - histoire, mission et projets subsidiaires</a></li>
<li><a href="../fr436028/index.html">Une introduction à Kubernetes pour les utilisateurs de VMware. Partie 1. Théorie</a></li>
<li><a href="../fr436032/index.html">Tutoriel React, partie 9: Propriétés des composants</a></li>
<li><a href="../fr436036/index.html">Les chercheurs en intelligence artificielle peuvent-ils lui confier un test de leurs travaux?</a></li>
<li><a href="../fr436038/index.html">Le bruit du silence: combien de gadgets fous sont nécessaires pour obtenir un environnement optimal pour le sommeil?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>