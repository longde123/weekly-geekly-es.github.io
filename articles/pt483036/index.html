<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßíüèª üë´ üßíüèø Problema de conclus√£o do n-Queens - algoritmo de solu√ß√£o linear üåï üí™üèª ‚õ∞Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ericgrig 



 Pref√°cio 
 Gostaria de come√ßar o pref√°cio com palavras de gratid√£o a dois maravilhosos programadores de Odessa: Andrei Kiper (Lohica) e ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Problema de conclus√£o do n-Queens - algoritmo de solu√ß√£o linear</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/483036/">  Ericgrig <br><p><br></p><h4>  Pref√°cio </h4><br>  Gostaria de come√ßar o pref√°cio com palavras de gratid√£o a dois maravilhosos programadores de Odessa: Andrei Kiper (Lohica) e Timur Giorgadze (Luxoft), para uma verifica√ß√£o independente dos meus resultados, na fase inicial do estudo. <br><br><ol><li>  O artigo "Algoritmo linear para a solu√ß√£o do problema de conclus√£o do n-Queens" foi publicado em <a href="https://arxiv.org/pdf/1912.05935.pdf">(arXiv.org)</a> no in√≠cio do primeiro dia de 2020.  Inicialmente, o artigo foi escrito em russo; portanto, a apresenta√ß√£o b√°sica √© apresentada aqui e a tradu√ß√£o. </li><li>  Essa tarefa e alguns outros conjuntos de NP-Complete (a tarefa de satisfazer as f√≥rmulas booleanas (3-SAT), a tarefa de encontrar a camarilha m√°xima ou uma camarilha de um determinado tamanho ...) em momentos diferentes estavam na minha √°rea de interesse.  Eu estava procurando uma solu√ß√£o algor√≠tmica baseada em v√°rios experimentos computacionais, mas n√£o houve sucesso concreto.  Era como uma pessoa tentando aprender a ficar em forma na barra horizontal de um bra√ßo.  N√£o h√° resultado, mas toda vez h√° uma esperan√ßa de que tudo d√™ certo em breve.  A √∫ltima vez que decidi que deveria ficar mais tempo na tarefa de Conclus√£o do n-Queens (como um dos membros da fam√≠lia) e tentar fazer alguma coisa.  Aqui √© apropriado relembrar a maravilhosa piada de Odessa: "Em um √¥nibus lotado que retorna aos sub√∫rbios em uma estrada esburacada √† noite, a voz de uma mulher √© ouvida - Cara, se voc√™ me deitou completamente, fa√ßa pelo menos alguma coisa". </li><li>  O estudo durou o suficiente - quase um ano e meio.  Por um lado, isso se deve ao fato de que outras tarefas foram consideradas no processo de pesquisa e, por outro, houve quest√µes dif√≠ceis ao longo do caminho, sem as quais n√£o poder√≠amos avan√ßar.  Vou listar alguns deles: <br><br><ul><li>  Existem n linhas na matriz de decis√£o, em que sequ√™ncia o √≠ndice de linha deve ser selecionado se o n√∫mero de possibilidades para essa escolha for n! </li><li>  quando uma linha √© criada, qual das posi√ß√µes livres restantes nessa linha deve ser selecionada, porque o n√∫mero de possibilidades para uma sele√ß√£o √© t√£o grande que pode ser considerado um "parente pr√≥ximo" do infinito (por exemplo, o n√∫mero de maneiras poss√≠veis de selecionar uma posi√ß√£o livre em todas as linhas para um tabuleiro de xadrez de tamanho 100 x 100 √© aproximadamente 10 <sup>124</sup> ) </li><li>  Juntos, esses dois indicadores formam um espa√ßo de estado (um espa√ßo de escolha).  Parece que existem grandes oportunidades, voc√™ pode escolher o que deseja.  Mas por tr√°s de cada escolha espec√≠fica a cada passo, h√° outro problema - a limita√ß√£o da escolha em todos os passos subsequentes.  Al√©m disso, isso √© especialmente sens√≠vel nos √∫ltimos est√°gios da solu√ß√£o do problema.  Podemos dizer que a matriz de decis√£o √© "vingativa".  Todos os ‚Äúerros inconscientes‚Äù que voc√™ comete ao fazer uma escolha nos est√°gios anteriores s√£o ‚Äúacumulados‚Äù e, no final da decis√£o, isso se manifesta no fato de que naquelas linhas em que voc√™ deve colocar a rainha, n√£o h√° posi√ß√µes vazias e o ramo de busca p√°ra. .  Aqui, como Zhvanetsky: "uma jogada errada e voc√™ est√° gr√°vida". </li><li>  Quando o ramo da busca por uma solu√ß√£o fica parado, temos a oportunidade de voltar a algumas das posi√ß√µes anteriores (Back Tracking), para que a partir dessa posi√ß√£o comecemos novamente a formar o ramo da busca por uma solu√ß√£o.  Essa √© uma "propriedade" natural de problemas n√£o determin√≠sticos.  A quest√£o √© qual dos n√≠veis anteriores deve ser retornado.  Esse √© o mesmo problema em aberto que a quest√£o de escolher o √≠ndice de linha ou escolher uma posi√ß√£o livre nessa linha. </li><li>  Finalmente, um problema relacionado √† velocidade do algoritmo deve ser observado.  Seria triste se n√£o houvesse objetivo de criar algoritmos de execu√ß√£o r√°pida.  No processo de modelagem, n√£o foi poss√≠vel desenvolver um algoritmo que funcionasse r√°pida e eficientemente em todas as √°reas da solu√ß√£o do problema.  Eu tive que desenvolver tr√™s algoritmos.  Eles transmitem os resultados um para o outro, como um bast√£o.  Um deles trabalha muito rapidamente, mas de forma grosseira, o outro - pelo contr√°rio, trabalha lenta mas eficientemente.  Cada um deles trabalha na ‚Äúzona de sua responsabilidade‚Äù. </li></ul></li><li>  Inicialmente, o objetivo do estudo era apenas encontrar pelo menos alguma solu√ß√£o.  Eu tinha muito que descobrir antes que a primeira solu√ß√£o fosse desenvolvida.  Demorou mais de quatro meses.  Foi poss√≠vel parar por a√≠, o objetivo foi alcan√ßado - bem, tudo bem.  Mas me pareceu que nem todas as possibilidades de uma solu√ß√£o algor√≠tmica para esse problema estavam esgotadas.  Naturalmente, havia um desejo de melhorar o algoritmo desenvolvido para que a complexidade do tempo fosse linear-O (n).  Quando uma solu√ß√£o linear foi encontrada, havia ‚Äúmais um desejo‚Äù - reduzir o n√∫mero de casos em que o procedimento Back Tracking (BT) foi aplicado ao formar um ramo da pesquisa da solu√ß√£o.  Era um desejo "insolente" de transferir a tarefa de n√£o determinista para condicionalmente determinado (na medida do poss√≠vel).  Demorou muito tempo, mas o objetivo foi alcan√ßado, por exemplo, no intervalo de valores do tamanho de um tabuleiro de xadrez n = (320, ..., 22500), o n√∫mero de casos em que o procedimento BT nunca foi usado √© superior a 50%.  Acontece que em 50% dos casos, quando o programa √© iniciado, o algoritmo "propositalmente" forma uma solu√ß√£o, nunca "trope√ßando".  (Lembrando o conto de fadas sobre o peixe dourado, parei com esses dois desejos ...) </li><li>  Comparando as publica√ß√µes com as quais me familiarizei durante a pesquisa, cheguei √† conclus√£o de que esse problema e outros problemas desse tipo n√£o podem ser resolvidos com base em uma abordagem matem√°tica rigorosa, ou seja, apenas com base em defini√ß√µes, afirma√ß√µes de lemas e provas de teoremas.  H√° uma "observa√ß√£o filos√≥fica" sobre isso no artigo.  Estou certo de que muitos problemas do NP-Complete podem ser resolvidos apenas com base na matem√°tica algor√≠tmica com o uso da modelagem computacional.  Essa conclus√£o n√£o significa limitar a matem√°tica, pelo contr√°rio, significa expandir as capacidades da matem√°tica atrav√©s do desenvolvimento de m√©todos matem√°ticos algor√≠tmicos.  Para cada fam√≠lia de problemas, voc√™ precisa usar sua pr√≥pria abordagem matem√°tica adequada.  (Por que instruir um aluno de p√≥s-gradua√ß√£o a resolver um problema da fam√≠lia NP-Complete sem aplicar matem√°tica algor√≠tmica e modelagem por computador, se se sabe que nada realmente resultar√° de tal empreendimento). </li><li>  Qualquer algoritmo (programa) possui uma propriedade simples - funciona ou n√£o!  Quero apelar para os membros da nossa Comunidade Habro que t√™m um computador com o Matlab instalado na zona de acessibilidade.  Quero pedir que voc√™ teste a opera√ß√£o do algoritmo considerado para resolver o <i>problema de conclus√£o</i> do <i>n-Queens</i> .  Isso levar√° apenas 5 a 10 minutos.  Para testar o algoritmo, voc√™ precisa seguir algumas etapas simples: <br><br><ul><li>  Gere uma composi√ß√£o aleat√≥ria a partir de <i>k</i> rainhas e verifique a corre√ß√£o dessa composi√ß√£o. </li><li>  Com base no algoritmo de decis√£o proposto, conclua esta composi√ß√£o para uma solu√ß√£o completa.  Ou o programa deve decidir que essa composi√ß√£o n√£o tem solu√ß√£o. </li><li>  Verifique a corre√ß√£o da solu√ß√£o obtida como resultado da configura√ß√£o. </li></ul><br><br>  Voc√™ n√£o precisa escrever nenhum c√≥digo para esse teste.  Al√©m do programa principal, preparei mais dois programas no idioma Matlab: <br><br>  1. <i>Generarion_k_Queens_Composition</i> - gera√ß√£o de uma composi√ß√£o aleat√≥ria de tamanho <i>k</i> para um tabuleiro de xadrez arbitr√°rio de tamanho <i>nxn</i> <br><br>  2. <i>Completion_k_Queens_Composition.m</i> - concluir uma composi√ß√£o arbitr√°ria at√© uma decis√£o completa ou decidir que essa composi√ß√£o n√£o tem solu√ß√£o ( <b>programa principal</b> ). <br><br>  3. <i>Validation_n_Queens_Solution.m</i> - verificando a corre√ß√£o da solu√ß√£o do <i>Problema n-Queens</i> ou a corre√ß√£o da composi√ß√£o de <i>k</i> rainhas. <br><br>  Eles trabalham muito r√°pido.  Por exemplo, para um tabuleiro de xadrez, cujo tamanho √© de <i>1000 x 1000</i> c√©lulas, o tempo total necess√°rio para gerar uma composi√ß√£o arbitr√°ria (0,0015 s.), Complete esta composi√ß√£o (0,0622 s.) E verifique a corre√ß√£o da solu√ß√£o obtida (0,0003 s.) n√£o excede 0,1 segundos.  (excluindo o tempo necess√°rio para fazer o download de dados ou salvar os resultados) <br><br>  Envie-me um email (ericgrig@gmail.com). Se voc√™ tiver a oportunidade de ajudar um amigo, enviarei imediatamente esses tr√™s programas.  Serei grato a todos os meus colegas que podem testar objetivamente o algoritmo e expressar sua opini√£o na discuss√£o. </li><li>  Eu preparei o c√≥digo fonte do programa, com coment√°rios detalhados, que, espero, ser√£o publicados em Habr√© em breve.  Penso que aqueles que est√£o interessados ‚Äã‚Äãem resolver problemas complexos da fam√≠lia <i>NP-Complete</i> encontrar√£o algo interessante para si. </li><li>  Gostaria de apelar novamente aos membros da Comunidade Habr, mas por um motivo diferente.  Aqui, em Marselha (Fran√ßa), a forma√ß√£o da equipe do <i>France Fold Group</i> est√° em andamento, cujo objetivo √© a pesquisa e o desenvolvimento de algoritmos para prever as propriedades f√≠sico-qu√≠micas de compostos de alto peso molecular.  Acho que n√£o vale a pena dizer que esta √© uma tarefa bastante dif√≠cil, com uma longa hist√≥ria, e que equipes s√©rias em diferentes pa√≠ses est√£o trabalhando nesse problema, incluindo a equipe <i>Khasabis</i> da <i>Deep Mind</i> (voc√™ pode ver o artigo em Habr√© <a href="https://habr.com/ru/post/431948/">(habr.com_Folding)</a> . O objetivo √© criar uma equipe forte que n√£o tenha medo de resolver problemas complexos. A forma de organiza√ß√£o do trabalho conjunto √© distribu√≠da. Cada membro da equipe vive em sua cidade e trabalha no projeto em seu tempo livre a partir de seu trabalho principal. Precisamos de programadores e pesquisadores (f√≠sicos, qu√≠micos, matem√°ticos, bi√≥logos) ) etc.  osto programadores ‚Äúimprudentes‚Äù (ao quadrado). Escreva-me se achar interessante, o acima √© o meu e-mail. Mais detalhadamente, posso dizer na carta de resposta. </li></ol><br>  O pref√°cio do artigo acabou sendo o mesmo do pr√≥prio artigo.  O formato de apresenta√ß√£o da fam√≠lia em Habr√© me permite expressar meus pensamentos com mais liberdade, mas, a julgar pelo tamanho, aproveitei-o com bastante liberdade.  Eu queria escrever brevemente, mas "acabou como sempre". <br><br>  PS: Pensei que os membros da Comunidade Habr estariam interessados ‚Äã‚Äãem saber quais dificuldades encontrei ao tentar publicar os resultados do estudo.  Quando o artigo foi preparado, eu o reformatei no formato .tex de acordo com os requisitos do Journal of Artificial Intelligence Research (JAIR) e o enviei para l√°.  Costumava haver publica√ß√µes sobre um t√≥pico semelhante.  Destaca-se o artigo <i>C. Gent, I.-P.</i>  <i>Jefferson e P. Nightingale (2017)</i> <a href="https://jair.org/index.php/jair/article/view/11079/26262">(Complexidade da conclus√£o de n-rainhas)</a> , na qual os autores provaram que o problema em quest√£o pertence ao conjunto NP-Complete e falaram sobre as dificuldades encontradas na tentativa de resolver esse problema.  Nas conclus√µes, os autores escrevem: ‚ÄúPara quem entende as regras do xadrez, o n-Queens Completion pode ser um dos problemas mais naturais de NP-Complete de todos‚Äù ( <i>Para quem entende as regras do xadrez, a tarefa n-Queens Completion pode se tornar uma das as tarefas NP-Complete mais naturais</i> ). <br><br>  Ap√≥s 10 dias, recebi uma recusa da JAIR, com a reda√ß√£o: "o artigo n√£o corresponde ao formato da revista", ou seja,  nem sequer levou o artigo em considera√ß√£o.  Eu n√£o esperava essa resposta.  Eu pensei que, se uma revista publica artigos nos quais os autores concluem que √© muito dif√≠cil resolver um determinado problema e n√£o fornece nenhuma solu√ß√£o concreta, o artigo que fornece um algoritmo de solu√ß√£o eficaz certamente ser√° aceito para considera√ß√£o.  No entanto, os editores tinham sua pr√≥pria opini√£o sobre esse assunto.  (Acredito que especialistas competentes trabalhem l√°, e provavelmente eles foram questionados pelo t√≠tulo do artigo "insolente" e tudo o que √© declarado l√°. Pensamos: "provavelmente h√° algum tipo de erro e gentilmente me mandou embora, referindo-se ao formato "). <br><br>  Eu tive que escolher outra publica√ß√£o cient√≠fica peri√≥dica revisada por pares sobre t√≥picos relevantes.  Aqui estou diante da dura realidade.  O fato √© que aproximadamente 80% de todas as revistas s√£o pagas: ou eu tenho que pagar uma quantia decente √† revista para que o artigo esteja dispon√≠vel gratuitamente a todos os leitores, ou eles precisam dar o artigo como presente "na proa", e eles cobrar√£o a todos que quer se familiarizar com este estudo.  E a primeira e a segunda op√ß√µes s√£o fundamentalmente inaceit√°veis ‚Äã‚Äãpara mim.  Eu me senti bem com esse m√©todo de raquete de editores quando tentei me familiarizar com algumas publica√ß√µes. <br><br>  A pr√≥xima revista, que professa o princ√≠pio do livre acesso √† informa√ß√£o, foi <i>o SMAI Journal of Computational Mathematics</i> .  Eles tamb√©m recusaram com a mesma reda√ß√£o, embora muito mais r√°pido - em dois dias. <br><br>  Em seguida, foi escolhida uma revista: <i>Matem√°tica Discreta e Ci√™ncia da Computa√ß√£o Te√≥rica</i> .  Aqui os requisitos s√£o simples, primeiro voc√™ precisa publicar o artigo em arXiv.org e somente depois registre o artigo para considera√ß√£o.  Ok, seguiremos as regras - enviei um artigo no <i>arXiv.org</i> .  Eles me escreveram que publicariam o artigo em 8 horas.  No entanto, isso n√£o aconteceu ap√≥s 8 horas, n√£o ap√≥s 8 dias.  O artigo foi ‚Äúmantido‚Äù pelos mentores e somente ap√≥s 9 dias foi publicado.  N√£o houve queixas na forma e na ess√™ncia do artigo.  Eu acho que, como no caso do JAIR, os mentores tinham d√∫vidas sobre a possibilidade de "fazer isso e escrever sobre isso".  Algum tempo depois, depois de corrigir erros t√©cnicos, o artigo foi atualizado e em sua forma final foi lan√ßado na noite de Ano Novo. <br><br>  Tenho que me debru√ßar sobre isso em detalhes para mostrar que, na fase de publica√ß√£o dos resultados da pesquisa, pode haver problemas que n√£o podem ser explicados logicamente. <br><br>  A seguir, √© apresentado um artigo cuja tradu√ß√£o para o ingl√™s foi publicada em <a href="https://arxiv.org/pdf/1912.05935.pdf">(arXiv.org)</a> . <br><br><h3>  1. Introdu√ß√£o </h3><br>  Entre as v√°rias op√ß√µes para a formula√ß√£o do <i>problema</i> <i>do n-Queens, a</i> tarefa de <i>Conclus√£o do n-Queens</i> em quest√£o tem uma posi√ß√£o especial devido √† sua complexidade.  Em seu trabalho <a href="https://jair.org/index.php/jair/article/view/11079/26262">(Gent em tudo (2017))</a> mostrou que o <i>problema de conclus√£o</i> do <i>n-Queens</i> pertence ao conjunto <i>NP-Complete</i> ( <i>mostrou que o n-Queens Completion √© NP-Complete e # P-Complete</i> ).  Sup√µe-se que a solu√ß√£o para esse problema possa abrir caminho para resolvermos outros problemas do conjunto de <i>NP-Complete</i> . <br><br>  O problema √© formulado da seguinte maneira.  H√° uma composi√ß√£o de <i>k</i> rainhas, que s√£o distribu√≠das consistentemente em um tabuleiro de xadrez de tamanho <i>nxn</i> .  √â necess√°rio provar que esta composi√ß√£o pode ser completada para uma solu√ß√£o completa e fornecer pelo menos uma solu√ß√£o, ou provar que tal solu√ß√£o n√£o existe.  Aqui, por consist√™ncia, entendemos uma composi√ß√£o de <i>k</i> rainhas para as quais tr√™s condi√ß√µes do problema s√£o atendidas: em cada linha, cada coluna e tamb√©m nas diagonais esquerda e direita que passam pela c√©lula onde a rainha est√° localizada, n√£o mais que uma rainha est√° localizada.  O problema nesta forma foi formulado pela primeira vez por <i>Nauk (1850)</i> . <br><br>  <b>1.1 Defini√ß√µes</b> <br><br>  A seguir, indicaremos o tamanho da lateral do tabuleiro de xadrez pelo s√≠mbolo <i>n</i> .  Uma solu√ß√£o ser√° chamada completa se todas as <i>n</i> rainhas forem consistentemente colocadas em um tabuleiro de xadrez.  Todas as outras solu√ß√µes, quando o n√∫mero <i>k de</i> rainhas corretamente colocadas for menor que <i>n</i> - chamaremos a composi√ß√£o.  Chamamos de positiva uma composi√ß√£o de <i>k</i> rainhas se puder ser conclu√≠da antes de uma solu√ß√£o completa.  Por conseguinte, uma composi√ß√£o que n√£o pode ser conclu√≠da at√© que uma solu√ß√£o completa seja chamada negativa.  Como an√°logo de um "tabuleiro de xadrez" de tamanho <i>nxn</i> , tamb√©m consideraremos uma "matriz de solu√ß√£o" de tamanho <i>nxn</i> .  Como exemplo, todos os algoritmos desenvolvidos para resolver o problema ser√£o apresentados na linguagem Matlab. <br><br>  O estudo foi realizado com base em simula√ß√£o computacional (simula√ß√£o computacional).  Para testar esta ou aquela hip√≥tese, realizamos experimentos computacionais em uma ampla faixa de valores <i>n</i> = (10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 200, 300, 500, 800, 1000, 3000, 5000, 10000, 30.000, 50.000, 80.000, 10 <sup>5</sup> , 3 * 10 <sup>5</sup> , 5 * 10 <sup>5</sup> , 10 <sup>6</sup> , 3 * 10 <sup>6</sup> , 5 * 10 <sup>6</sup> , 10 <sup>7</sup> , 3 * 10 <sup>7</sup> , 5 * 10 <sup>7</sup> , 8 * 10 <sup>7</sup> , 10 <sup>8</sup> ) e, dependendo do valor de <i>n</i> , foram geradas amostras suficientemente grandes para an√°lise.  Chamamos essa lista de " <i>lista b√°sica de n valores</i> " para a realiza√ß√£o de experimentos computacionais.  Todos os c√°lculos foram realizados em um computador comum.  No momento da montagem (no in√≠cio de 2013), a configura√ß√£o era bem-sucedida: <i>CPU - Intel Core i7-3820, 3,60 GH, RAM-32,0 GB, GPU- NVIDIA Ge Forse GTX 550 Ti, dispositivo de disco - ATA Intel SSD, SCSI, OS- Sistema operacional de 64 bits Windows 7 Professional</i> .  Chamamos esse kit simplesmente - <i>desktop-13</i> . <br><br><h3>  2. Prepara√ß√£o de dados </h3><br>  O algoritmo come√ßa lendo um arquivo que cont√©m uma matriz unidimensional de dados sobre a distribui√ß√£o de uma composi√ß√£o arbitr√°ria de <i>k</i> rainhas.  Sup√µe-se que os dados sejam preparados da seguinte maneira.  Seja uma matriz zerada <i>Q (i) = 0, i = (1, ..., n)</i> , em que os √≠ndices das c√©lulas dessa matriz correspondem aos √≠ndices de linha da matriz da solu√ß√£o.  Se em alguma linha arbitr√°ria <i>i da</i> matriz da solu√ß√£o houver uma rainha na posi√ß√£o <i>j</i> , a atribui√ß√£o <i>Q (i) = j</i> √© executada.  Assim, o tamanho da composi√ß√£o <i>k</i> ser√° igual ao n√∫mero de c√©lulas diferentes de zero da matriz <i>Q.</i>  (Por exemplo, <i>Q = (0, 0, 5, 0, 4, 0, 0, 3, 0, 0)</i> significa que estamos considerando uma composi√ß√£o de <i>k = 3</i> rainhas na matriz <i>n = 10</i> , onde as rainhas est√£o localizadas na 3¬™, 5¬™ e 8¬™ linhas, respectivamente nas posi√ß√µes 5, 4, 3). <br><br><h3>  3. Algoritmo para verificar a corre√ß√£o do problema da solu√ß√£o n-Queens </h3><br>  Para pesquisa, precisamos de um algoritmo que permita determinar a corre√ß√£o da solu√ß√£o do <i>problema n-Queens</i> em um curto espa√ßo de tempo.  Controlar o local das rainhas em cada linha e cada coluna √© simples.  A quest√£o √© sobre limites diagonais.  Poder√≠amos construir um algoritmo eficaz para tal contabilidade se pud√©ssemos mapear cada c√©lula da matriz da solu√ß√£o para uma determinada c√©lula de um certo vetor de controle que caracterizaria exclusivamente a influ√™ncia de restri√ß√µes diagonais na c√©lula em quest√£o.  Ent√£o, com base em se a c√©lula do vetor de controle est√° livre ou ocupada, pode-se julgar se a c√©lula correspondente da matriz de decis√£o est√° livre ou fechada.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tal id√©ia foi usada pela primeira vez por </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sosic &amp; Gu (1990)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para levar em conta e acumular o n√∫mero de situa√ß√µes de conflito entre diferentes posi√ß√µes das rainhas. Usamos uma id√©ia semelhante no algoritmo apresentado abaixo, mas apenas para levar em considera√ß√£o se a c√©lula da matriz da solu√ß√£o est√° livre ou ocupada. A Figura 1, como exemplo, mostra um tabuleiro </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> xadrez </font><i><font style="vertical-align: inherit;">8 x 8</font></i><font style="vertical-align: inherit;"> acima do qual uma sequ√™ncia de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">24</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> c√©lulas </font><font style="vertical-align: inherit;">est√° localizada acima </font><font style="vertical-align: inherit;">. </font></font><br><br><img src="https://habrastorage.org/webt/sx/0f/ws/sx0fwsydzdsy954rtlqpdwwigqg.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fig. 1. Um exemplo de demonstra√ß√£o da correspond√™ncia das proje√ß√µes diagonais das c√©lulas da matriz com as c√©lulas correspondentes das matrizes de controle </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 8) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Considere as 15 primeiras c√©lulas como elementos do vetor de controle </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. As proje√ß√µes de todas as diagonais esquerdas de qualquer c√©lula da matriz da solu√ß√£o caem em uma das c√©lulas do vetor de controle </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . De fato, todas essas proje√ß√µes est√£o localizadas dentro de dois segmentos de linha paralelos, um dos quais conecta a c√©lula da matriz </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(8.1)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √† primeira c√©lula do vetor </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e o segundo </font><font style="vertical-align: inherit;">conecta a </font><font style="vertical-align: inherit;">c√©lula </font><font style="vertical-align: inherit;">da matriz </font><font style="vertical-align: inherit;">(1.8) √† 15¬™ c√©lula do vetor de controle </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . N√≥s damos uma defini√ß√£o semelhante para as proje√ß√µes diagonais corretas. Para fazer isso, mova a origem da c√©lula 1 para a c√©lula 9 para a direita e considere uma sequ√™ncia de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">16</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> c√©lulas como elementos do vetor de controle </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(na figura, s√£o c√©lulas dos dias 9 a 24). As proje√ß√µes de todas as diagonais corretas de qualquer c√©lula da matriz da solu√ß√£o cair√£o em uma das c√©lulas desse vetor de controle, come√ßando da 2¬™ √† 16¬™ (na figura, de 10 24). Aqui, todas essas proje√ß√µes est√£o localizadas entre dois segmentos de linhas paralelas - o segmento que conecta a c√©lula (8,8) da matriz da solu√ß√£o com a c√©lula 16 do vetor </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (c√©lula 24 na figura) e o segmento que conecta a c√©lula (1,1) da matriz da solu√ß√£o com a c√©lula 2 do vetor de controle </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (c√©lula 10 na figura). As proje√ß√µes de todas as c√©lulas da matriz da solu√ß√£o localizadas na mesma diagonal esquerda caem na mesma c√©lula do vetor de controle esquerdo </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, respectivamente, as proje√ß√µes de todas as c√©lulas da matriz da solu√ß√£o localizadas na mesma diagonal direita caem na mesma c√©lula do vetor de controle </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> certo </font><font style="vertical-align: inherit;">. Assim, esses dois vetores de controle </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> permitem o controle total de todas as inibi√ß√µes diagonais para qualquer c√©lula da matriz de decis√£o. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√â importante notar que a id√©ia de usar proje√ß√µes diagonais em c√©lulas de vetores de controle para determinar se uma c√©lula de uma matriz de solu√ß√£o com coordenadas </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(i, j) est√°</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> livre ou ocupada </font><font style="vertical-align: inherit;">tamb√©m foi implementada posteriormente em </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Richards (1997)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ele fornece um dos algoritmos de pesquisa recursiva mais r√°pidos para todas as solu√ß√µes, com base em opera√ß√µes com uma m√°scara de bits. Uma diferen√ßa importante √© que o algoritmo indicado √© projetado para a pesquisa seq√ºencial de todas as solu√ß√µes, iniciando na primeira linha da solu√ß√£o da matriz para baixo ou na √∫ltima linha da matriz para cima. O algoritmo que propusemos √© baseado na condi√ß√£o de que a escolha do n√∫mero de cada linha para a localiza√ß√£o da rainha deve ser arbitr√°ria. Para o algoritmo em considera√ß√£o, isso √© de fundamental import√¢ncia. Observe que a figura 1 acima, constru√≠mos por analogia com o que √© publicado neste artigo. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um programa para verificar se uma determinada solu√ß√£o do </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">problema n-Queens</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est√° correta ou se uma determinada composi√ß√£o de </font><i><font style="vertical-align: inherit;">k</font></i><font style="vertical-align: inherit;"> √© verdadeira</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Queens √© o seguinte. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Para controlar inibi√ß√µes diagonais, crie duas matrizes </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D1 (1: n2)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D2 (1: n2)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , em que n2 = 2 * n e uma matriz </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B (1: n)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para controlar a ocupa√ß√£o das colunas da matriz da solu√ß√£o. Zere essas tr√™s matrizes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. Introduzimos o contador do n√∫mero de rainhas corretamente instaladas ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">totPos = 0</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Consistentemente, em um ciclo, a partir da primeira linha, consideramos todas as posi√ß√µes de rainhas fornecidas. Se </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Q (i)&gt; 0</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ent√£o, com base no √≠ndice da linha </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e no √≠ndice da posi√ß√£o da rainha nesta linha </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">j = Q (i),</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> formamos os √≠ndices correspondentes para as matrizes de controle </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D1 (r)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D2 (t)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r = n + j - i </font></font></i> <br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t = j + i</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 3. Se todas as condi√ß√µes ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D1 (r) = 0, D2 (t) = 0, B (j) = 0</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) </font><font style="vertical-align: inherit;">forem satisfeitas </font><font style="vertical-align: inherit;">, isso significa que a c√©lula </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">( i, j) √©</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> livre e n√£o cai na zona de proje√ß√£o de restri√ß√µes diagonais formadas por rainhas previamente estabelecidas. A posi√ß√£o da rainha nesta posi√ß√£o est√° correta. Se pelo menos uma dessas condi√ß√µes n√£o for cumprida, a escolha de tal posi√ß√£o ser√° err√¥nea, respectivamente, e a decis√£o ser√° err√¥nea. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. Se a solu√ß√£o estiver correta, aumente o contador do n√∫mero de rainhas instaladas corretamente ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">totPos = totPos + 1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) e feche as c√©lulas correspondentes das matrizes de controle: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(D1 (r) = 1, D2 (t) = 1, B (j) = 1)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Ent√£o fechamos todas as c√©lulas da coluna</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(j)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e as c√©lulas da matriz da solu√ß√£o que est√£o localizadas ao longo das diagonais esquerda e direita que se cruzam na c√©lula </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(i, j)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5. Repita o procedimento de verifica√ß√£o para todas as posi√ß√µes restantes. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Talvez este seja um dos algoritmos mais r√°pidos para avaliar a corre√ß√£o da solu√ß√£o para o </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">problema n-Queens</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">O tempo de verifica√ß√£o de um milh√£o de posi√ß√µes para a matriz de solu√ß√µes 10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> x 10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> na </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√°rea de trabalho 13</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √© de 0,175 segundos, o que corresponde aproximadamente ao tempo de pressionar a tecla "Enter". </font><font style="vertical-align: inherit;">Obviamente, esse algoritmo √© linear em rela√ß√£o √† contagem do tempo em rela√ß√£o a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 4. Descri√ß√£o do algoritmo para resolver o problema </font></font></h3><br>  <b>O general</b> .  <i>O problema de conclus√£o do n-Queens</i> √© um <i>problema</i> cl√°ssico n√£o determin√≠stico.  A principal dificuldade de sua solu√ß√£o est√° relacionada √† quest√£o de escolher o √≠ndice de linha e o √≠ndice de posi√ß√£o nessa linha, em condi√ß√µes em que o espa√ßo de estado √© enorme.  Ao procurar todas as solu√ß√µes poss√≠veis, esse problema n√£o surge.  Devemos considerar todas as ramifica√ß√µes de pesquisa v√°lidas no espa√ßo de estado, e a ordem em que elas s√£o consideradas n√£o importa.  No entanto, quando uma composi√ß√£o arbitr√°ria de <i>k</i> rainhas precisa ser conclu√≠da at√© uma solu√ß√£o completa, nesse caso, precisamos de um algoritmo para selecionar √≠ndices de linha e coluna que percebam adequadamente a composi√ß√£o existente e levam a uma solu√ß√£o mais rapidamente do que outros.  Neste projeto, decidimos a quest√£o da escolha com base na seguinte posi√ß√£o geral - <i>se n√£o pudermos formular condi√ß√µes que d√™em prefer√™ncia a qualquer linha ou posi√ß√£o nesta linha sobre outras, usaremos um algoritmo de sele√ß√£o aleat√≥ria baseado em n√∫meros aleat√≥rios distribu√≠dos uniformemente</i> .  Um m√©todo de sele√ß√£o aleat√≥ria semelhante para resolver problemas nos quais o espa√ßo de estados √© enorme √© bastante natural.  Uma das edi√ß√µes da s√©rie Proceedings of a <i>DIMACS Workshop (1999)</i> foi completamente dedicada ao uso da sele√ß√£o aleat√≥ria no desenvolvimento de algoritmos para resolver problemas complexos.  A implementa√ß√£o correta do algoritmo de sele√ß√£o aleat√≥ria pode ser uma solu√ß√£o bastante produtiva, embora essa seja uma condi√ß√£o necess√°ria, mas n√£o suficiente, para a conclus√£o da solu√ß√£o.  <i>Sosic e Gu (1990)</i> √© um dos primeiros estudos a usar um algoritmo de sele√ß√£o aleat√≥ria para resolver o problema <i>n-Queens</i> .  O algoritmo que eles examinaram √© baseado em uma id√©ia bastante simples e concisa.  Haja uma sequ√™ncia de n√∫meros de <i>1</i> a <i>n</i> , que s√£o reorganizados aleatoriamente.  Esse conjunto de n√∫meros tem uma propriedade importante.  Consiste no fato de que, independentemente de como esses n√∫meros sejam distribu√≠dos em diferentes linhas da matriz da solu√ß√£o, conforme as posi√ß√µes da rainha (um n√∫mero por linha), as duas primeiras regras sempre ser√£o cumpridas na declara√ß√£o do problema: cada linha e cada coluna n√£o ter√° mais de uma rainha.  No entanto, apenas uma parte das posi√ß√µes assim obtidas estar√° livre de restri√ß√µes diagonais.  A outra parte estar√° em um estado de "conflito" com rainhas estabelecidas anteriormente.  Para sair dessa situa√ß√£o, os autores usaram o m√©todo de comparar e trocar posi√ß√µes conflitantes, a fim de obter uma solu√ß√£o completa.  Em nosso algoritmo proposto, as situa√ß√µes de conflito s√£o imposs√≠veis, pois a cada passo da solu√ß√£o do problema, a rainha √© instalada na c√©lula da linha em quest√£o somente se a c√©lula estiver livre. <br><br>  <b>4.1 Selecionando um modelo para rastreamento posterior (BT)</b> <br><br>  No processo de encontrar uma solu√ß√£o para um problema, uma situa√ß√£o pode surgir quando uma cadeia seq√ºencial de solu√ß√µes leva a um beco sem sa√≠da.  Essa √© uma propriedade "gen√©tica" de problemas n√£o determin√≠sticos.  Nesse caso, voc√™ precisa voltar para uma das etapas anteriores, restaurar o estado da tarefa de acordo com este n√≠vel e iniciar novamente a busca de uma solu√ß√£o a partir dessa posi√ß√£o.  A quest√£o √© qual dos n√≠veis anteriores deve ser retornado e quantos devem ser (por n√≠vel, queremos dizer uma certa etapa na solu√ß√£o do problema com um determinado n√∫mero de rainhas corretamente instaladas).  Obviamente, escolher um n√≠vel de solu√ß√£o para voltar √© t√£o relevante quanto escolher um √≠ndice de linha ou um √≠ndice de posi√ß√£o nessa linha.  Portanto, independentemente da abordagem para resolver esse problema, √© necess√°rio primeiro determinar o n√∫mero de n√≠veis b√°sicos para retorno, bem como o mecanismo e as condi√ß√µes para retornar a um desses n√≠veis.  Em nosso algoritmo proposto, dividimos a matriz da solu√ß√£o em tr√™s n√≠veis b√°sicos.  Estes s√£o os pontos de retorno.  Se, como resultado da solu√ß√£o, ocorrer um conflito, dependendo dos par√¢metros da tarefa, retornaremos a um desses tr√™s n√≠veis b√°sicos.  O primeiro n√≠vel base ( <i>baseLevel1</i> ) corresponde ao estado em que a verifica√ß√£o de dados da composi√ß√£o em quest√£o √© conclu√≠da.  Este √© o come√ßo do programa.  Os valores dos dois n√≠veis base a seguir ( <i>baseLevel2</i> e <i>baseLevel3</i> ) dependem do tamanho da matriz <i>n</i> .  A depend√™ncia emp√≠rica desses valores b√°sicos sobre o tamanho da matriz da solu√ß√£o foi estabelecida com base em um grande n√∫mero de experimentos computacionais.  Para uma representa√ß√£o mais precisa dessa depend√™ncia, dividimos todo o intervalo considerado de 7 a 10 <sup>8</sup> em duas partes.  Seja <i>u = log (n)</i> , ent√£o se <i>n &lt;30 000</i> , ent√£o <br><br>  <i>baseLevel2 = n - redondo (12.749568 * u3 - 46.535838 * u2 + 120.011829 * u - 89.600272)</i> <br>  <i>baseLevel3 = n - redondo (9.717958 * u3 - 46.144187 * u2 + 101.296409 * u - 50.669273)</i> <br><br>  caso contr√°rio <br><br>  <i>baseLevel2 = n - round (-0,886344 * u3 + 56,136743 * u2 + 146,486415 * u + 227,967782)</i> <br>  <i>baseLevel3 = n - redondo (14.959815 * u3 - 253.661725 * u2 + 1584.713376 * u - 3060.691342)</i> <br><br>  <b>4.2 Estrutura do bloco</b> <br><br>  O algoritmo √© constru√≠do na forma de uma sequ√™ncia de <i>cinco blocos de eventos</i> , em que cada evento est√° associado √† execu√ß√£o de uma determinada parte da solu√ß√£o do problema.  Os algoritmos de processamento em cada bloco s√£o diferentes um do outro.  Apenas tr√™s dos cinco blocos servem para formar uma cadeia seq√ºencial de solu√ß√µes, e os dois blocos restantes s√£o preparat√≥rios.  A escolha do n√∫mero do bloco a partir do qual os c√°lculos come√ßam depende do valor de <i>n</i> e dos resultados da compara√ß√£o do tamanho da composi√ß√£o <i>k</i> com os valores de <i>baseLeve2</i> e <i>baseLevel3</i> .  Uma exce√ß√£o √© o intervalo de valores <i>n = (7, ..., 99)</i> , que pode ser chamado de ‚Äúzona turbulenta‚Äù devido √†s peculiaridades do comportamento do algoritmo nesta se√ß√£o.  Para os valores <i>n = (7, ..., 49)</i> , independentemente do tamanho da composi√ß√£o, ap√≥s inserir e monitorar os dados, os c√°lculos come√ßam no 4¬∫ bloco.  Para os valores <i>n = (50, ..., 99)</i> , dependendo do tamanho da composi√ß√£o, os c√°lculos come√ßam no segundo bloco ou no quarto.  Como mencionado acima, em cada etapa da solu√ß√£o do problema, apenas as posi√ß√µes na linha s√£o consideradas que n√£o se enquadram na zona de restri√ß√µes criadas pelas rainhas estabelecidas anteriormente.  S√£o essas posi√ß√µes que <i>s√£o chamadas de livres</i> . <br>  Vamos descrever brevemente quais c√°lculos s√£o realizados em cada um desses cinco blocos do programa. <br><br>  <b>4.3 In√≠cio do algoritmo</b> <br><br>  Os dados s√£o inseridos e a composi√ß√£o √© verificada quanto √† corre√ß√£o.  Em cada etapa de verifica√ß√£o, as c√©lulas das matrizes de controle s√£o alteradas.  O n√∫mero de rainhas instaladas corretamente √© contado.  Se n√£o houver erros na composi√ß√£o, a solu√ß√£o continuar√°; caso contr√°rio, uma mensagem de erro ser√° exibida.  Ap√≥s a conclus√£o da verifica√ß√£o, c√≥pias das matrizes principais s√£o criadas para reutiliza√ß√£o nesse n√≠vel.  Depois disso, o controle √© transferido para o <i>Bloco 1</i> . <br><br>  <b>4.4 Bloco 1</b> <br><br>  O in√≠cio da forma√ß√£o do ramo de pesquisa.  Consideramos <i>k</i> rainhas localizadas em um tabuleiro de xadrez como uma posi√ß√£o inicial.  √â necess√°rio continuar a concluir essa composi√ß√£o e colocar as rainhas em um tabuleiro de xadrez at√© que seu n√∫mero total seja igual a <i>baseLevel2</i> .  O algoritmo usado aqui √© chamado <i>randSet &amp; randSet</i> .  Isso se deve ao fato de que aqui estamos constantemente comparando duas listas aleat√≥rias de √≠ndices, em busca de pares livres das restri√ß√µes diagonais correspondentes.  Para fazer isso, as seguintes a√ß√µes s√£o executadas: <br><br>  a) duas listas s√£o formadas: uma lista de √≠ndices de linhas livres e uma lista de √≠ndices de colunas livres; <br><br>  b) reorganizar aleatoriamente n√∫meros em cada uma dessas listas; <br><br>  c) em um loop, cada par sucessivo de valores <i>(i, j)</i> , em que o √≠ndice <i>(i)</i> √© selecionado na lista de √≠ndices de linha livre e o √≠ndice <i>(j)</i> na lista de √≠ndices de coluna livre, √© considerado como uma poss√≠vel posi√ß√£o rainha e √© verificado se isso posi√ß√£o na √°rea de proje√ß√£o de exce√ß√µes diagonais. <br><br>  Se a regra das exce√ß√µes diagonais n√£o for violada, a posi√ß√£o ser√° considerada correta e a rainha ser√° colocada nessa posi√ß√£o.  Depois disso, o contador √© incrementado para o n√∫mero de rainhas corretamente instaladas e as c√©lulas correspondentes das matrizes de controle s√£o alteradas.  Se a posi√ß√£o <i>(i, j)</i> cai na zona de restri√ß√µes diagonais formadas pelas rainhas estabelecidas anteriormente, nada muda e a transi√ß√£o para a considera√ß√£o do pr√≥ximo par de valores ocorre. <br><br>  Quando o ciclo de compara√ß√£o de todos os pares da lista √© conclu√≠do, com base nos √≠ndices restantes que est√£o na zona de exclus√£o diagonal, uma lista de √≠ndices das linhas livres restantes e colunas livres √© formada novamente e esse procedimento √© repetido at√© o n√∫mero total de rainhas corretamente colocadas <i>(totPos )</i> n√£o ser√° igual ou exceder√° o valor limite de <i>baseLevel2</i> .  Quando essa condi√ß√£o √© atendida, o controle √© transferido para o <i>Bloco 2</i> .  Se, como resultado de uma busca por uma solu√ß√£o, surgisse uma situa√ß√£o, da lista inteira de √≠ndices das linhas e colunas livres restantes, nenhum dos pares seria adequado para a localiza√ß√£o da rainha; nesse caso, os valores originais das matrizes de controle ser√£o restaurados com base nas c√≥pias geradas anteriormente , e o controle √© transferido para o in√≠cio do <i>Bloco 1</i> para recontagem. <br><br>  <b>4.5 Bloco 2</b> <br><br>  Este bloco serve como um est√°gio preparat√≥rio para a transi√ß√£o para o <i>Bloco 3</i> .  Nesse n√≠vel, o n√∫mero de linhas livres restantes ( <i>freeRows</i> ) √© significativamente menor que <i>n</i> .  Isso permite transferir eventos da matriz original de tamanho <i>nxn</i> para uma matriz de tamanho menor <i>L (1: freeRows, 1: freeRows)</i> .  Al√©m disso, com base nas informa√ß√µes sobre as linhas livres restantes e as colunas livres na matriz original da solu√ß√£o, os zeros s√£o gravados nas c√©lulas correspondentes da matriz <i>L</i> , indicando que essas c√©lulas est√£o livres.  Com essa transi√ß√£o de <i>"proje√ß√£o"</i> , a correspond√™ncia dos √≠ndices de linha e coluna da nova matriz com os √≠ndices correspondentes da matriz original √© preservada.  √â importante observar que, embora, no processo de solu√ß√£o desse problema, todos os eventos ocorram na matriz inicial de tamanho <i>nxn</i> , e essa matriz seja a principal arena de a√ß√£o, na <i>realidade, essa matriz n√£o √© criada</i> e apenas controla matrizes de contabilidade para os √≠ndices de linha <i>A (1: n)</i> e colunas <i>B (1: n)</i> desta matriz. <br><br>  Juntamente com a matriz L, duas matrizes de trabalho <i>rAr (1: freeRows)</i> e <i>tAr (1: freeRows)</i> tamb√©m s√£o formadas neste bloco para salvar os √≠ndices correspondentes das matrizes de controle <i>D1</i> e <i>D2</i> .  Isso ocorre porque, quando instalamos a pr√≥xima rainha na c√©lula <i>(i, j) da</i> matriz inicial de tamanho <i>nxn</i> , devemos excluir as c√©lulas da matriz <i>L</i> que caem na zona de proje√ß√£o das exce√ß√µes diagonais da matriz "grande" original.  Como o controle de restri√ß√µes diagonais √© realizado apenas dentro da matriz original de tamanho <i>nxn</i> , a presen√ßa de matrizes de trabalho <i>rAr</i> e <i>tAr nos</i> permite manter a correspond√™ncia e converter as c√©lulas proibidas nos limites da matriz L. Isso simplifica bastante a contabiliza√ß√£o de posi√ß√µes exclu√≠das. <br>  Ap√≥s a conclus√£o do trabalho preparat√≥rio neste bloco, c√≥pias das matrizes principais s√£o criadas para reutiliza√ß√£o nesse n√≠vel e o controle √© transferido para o <i>Bloco 3</i> . <br><br>  <b>4.6 Bloco 3</b> <br><br>  Nesse bloco, a forma√ß√£o do ramo de pesquisa de solu√ß√µes continua com base nos dados preparados no bloco anterior.  O n√∫mero de linhas nas quais as rainhas est√£o configuradas corretamente √© igual ou superior a <i>baseLevel-2</i> .  Voc√™ precisa continuar escolhendo at√© que o n√∫mero de rainhas instaladas seja igual a <i>baseLevel-3</i> .  Aqui, usamos o algoritmo de pesquisa de solu√ß√µes <i>rand e rand</i> , ou seja,  para formar a posi√ß√£o de uma dama, em vez de uma lista de √≠ndices livres, apenas dois √≠ndices s√£o usados, um valor aleat√≥rio de √≠ndice de uma linha livre e um valor aleat√≥rio de √≠ndice de uma posi√ß√£o livre nessa linha.  Este procedimento √© repetido ciclicamente at√© o n√∫mero total de rainhas colocadas ser igual ao valor de <i>baseLevel-3</i> .  Assim que essa condi√ß√£o for atendida, o controle √© transferido para o <i>Bloco-4</i> .  Se, como resultado dos c√°lculos, o ramo de pesquisa for um beco sem sa√≠da, esta se√ß√£o da forma√ß√£o do ramo de pesquisa ser√° fechada e retornar√° ao in√≠cio do <i>Bloco-3</i> , de onde os c√°lculos ser√£o repetidos novamente.  Para isso, os valores iniciais de todas as matrizes de controle s√£o restaurados. <br><br>  <b>4.7 Bloco 4</b> <br><br>  Neste bloco, os dados s√£o preparados para a transfer√™ncia do controle para o <i>Bloco 5</i> .  Para esta etapa, ap√≥s concluir o procedimento no <i>Bloco 3</i> , o n√∫mero de linhas livres ( <i>nRow</i> ) tornou-se ainda menor.  Portanto, tamb√©m √© ben√©fico converter eventos de uma matriz maior em uma matriz menor.  Essa abordagem nos d√° a oportunidade de determinar rapidamente as caracter√≠sticas necess√°rias para as linhas restantes necess√°rias nesta etapa.  De particular import√¢ncia √© o fato de que, com base nessa matriz, √© poss√≠vel prever as perspectivas do ramo de pesquisa para muitos passos adiante sem ter que concluir os c√°lculos.  A condi√ß√£o √© bastante simples.  Se, entre as linhas livres restantes, houver uma linha na qual n√£o h√° posi√ß√£o livre, o ramo de pesquisa em considera√ß√£o ser√° fechado e o controle ser√° transferido para um dos blocos de n√≠vel inferior.  As a√ß√µes preparat√≥rias realizadas aqui s√£o muito semelhantes ao que foi feito no <i>Bloco 2</i> .  Com base nos √≠ndices originais de linhas livres e colunas livres, √© formada uma nova matriz bidimensional, cujos valores zero correspondem a posi√ß√µes livres na matriz da solu√ß√£o original.  Al√©m disso, um array especial <i>E (1: nRow, 1: nRow)</i> √© criado neste bloco, com base no qual voc√™ pode determinar o n√∫mero de posi√ß√µes livres nas linhas livres restantes que ser√£o fechadas se voc√™ selecionar a posi√ß√£o <i>(i, j)</i> para definir a rainha em matriz de origem.  Antes de transferir o controle para o <i>Bloco 5</i> , s√£o executadas as seguintes a√ß√µes: <br><br>  a) a quantidade de vagas em todas as linhas restantes √© determinada, <br><br>  b) uma matriz da quantidade de posi√ß√µes livres, para as linhas em quest√£o, √© classificada em ordem crescente, <br><br>  c) se todas as linhas livres restantes tiverem posi√ß√µes livres (ou seja, o valor m√≠nimo nesta lista classificada √© diferente de 0), o controle √© transferido para o Bloco-5. <br><br>  Se, em qualquer uma das linhas restantes, n√£o houver posi√ß√£o livre, as matrizes necess√°rias ser√£o restauradas com base nas c√≥pias armazenadas e, dependendo dos par√¢metros da tarefa, o controle ser√° transferido para um dos n√≠veis b√°sicos. <br><br>  d) c√≥pias de backup de todas as matrizes de controle para este 4¬∫ n√≠vel s√£o formadas. <br><br>  <b>4.8 Bloco 5</b> <br><br>  Essa etapa √© final e, aqui, a forma√ß√£o do ramo de busca √© realizada de forma mais "equilibrada" e "racional".  Esta √© a "√∫ltima milha", resta apenas um pequeno n√∫mero de linhas livres.  Mas, ao mesmo tempo, esta √© a parte mais dif√≠cil.  Todos os erros que poderiam ter sido cometidos nos est√°gios anteriores da forma√ß√£o do ramo da busca por uma solu√ß√£o, no agregado, aparecem aqui - na forma da falta de uma posi√ß√£o vazia na linha. <br><br>  O algoritmo desse bloco √© executado com base em dois loops aninhados, dentro dos quais o terceiro loop √© executado.  Uma caracter√≠stica do terceiro ciclo √© que ele pode ser repetido, sem alterar os par√¢metros de dois ciclos externos.  Isso acontece se o ramo de pesquisa gerado estiver em um impasse.  O n√∫mero de tais repeti√ß√µes n√£o excede o valor limite de <i>repeatBound</i> , cujo valor √≥timo foi estabelecido com base em experimentos computacionais. <br><br>  O √≠ndice do loop externo est√° associado a uma escolha seq√ºencial de √≠ndices de linha que permaneceram livres ap√≥s os c√°lculos no terceiro n√≠vel de base.  Isso √© feito com base em uma lista de linhas classificada anteriormente pela quantidade de posi√ß√µes livres na linha.  A sele√ß√£o come√ßa com uma linha, com um n√∫mero m√≠nimo de posi√ß√µes livres e, em etapas subsequentes, em ordem crescente.  Dentro deste ciclo, um segundo ciclo √© formado, cujo √≠ndice itera sobre os √≠ndices de todas as posi√ß√µes livres na linha em quest√£o.  O objetivo do primeiro ciclo √© apenas selecionar o √≠ndice de uma das linhas livres nesse n√≠vel.  Consequentemente, o objetivo do segundo ciclo √© apenas selecionar uma posi√ß√£o livre dentro da linha considerada.  Essas a√ß√µes ocorrem apenas no terceiro n√≠vel b√°sico.  Ap√≥s essa escolha, o n√∫mero de rainhas instaladas √© incrementado e as c√©lulas correspondentes de todas as matrizes de controle s√£o alteradas.  Al√©m disso, o controle √© transferido dentro de um ciclo aninhado (terceiro), cuja zona de atividade j√° √© todas as demais linhas livres.  Dentro deste ciclo, a escolha do √≠ndice de linha e a escolha de uma posi√ß√£o livre nessa linha s√£o realizadas com base nas seguintes regras: <br><br>  a) <b>Selecione uma linha livre</b> .  Todas as linhas livres restantes s√£o consideradas e o n√∫mero de posi√ß√µes livres √© determinado em cada linha.  A linha √© selecionada para a qual o n√∫mero de posi√ß√µes livres √© m√≠nimo.  Isso minimiza os riscos associados √† possibilidade de excluir as √∫ltimas posi√ß√µes vagas em algumas das linhas restantes em que o estado √© m√≠nimo e cr√≠tico em termos do n√∫mero de posi√ß√µes vagas ( <b>regra de risco m√≠nimo</b> ).  A prop√≥sito, √© com essa regra que o √≠ndice do primeiro ciclo neste quinto bloco come√ßa com uma sele√ß√£o seq√ºencial de linhas com um valor m√≠nimo do n√∫mero de posi√ß√µes livres em uma linha.  Se, em algum momento, as duas linhas tiverem o mesmo n√∫mero m√≠nimo de posi√ß√µes livres, o √≠ndice de uma das duas posi√ß√µes listadas primeiro na lista classificada ser√° selecionado aleatoriamente.  Se o n√∫mero de linhas com o mesmo n√∫mero m√≠nimo de posi√ß√µes livres for maior que duas, o √≠ndice de uma das tr√™s posi√ß√µes listadas primeiro na lista classificada ser√° selecionado aleatoriamente. <br><br>  b) <b>Sele√ß√£o de uma posi√ß√£o livre consecutiva</b> .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Na lista de todas as posi√ß√µes vagas na linha em quest√£o, √© selecionada uma que cause danos m√≠nimos √†s posi√ß√µes vagas em todas as linhas restantes. Isso √© feito com base na matriz E. formada anteriormente. Por "dano m√≠nimo", entendemos a escolha dessa posi√ß√£o em uma determinada linha que exclui a menor quantidade de posi√ß√µes livres em todas as linhas restantes ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">regra de dano m√≠nimo)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) Se duas ou mais posi√ß√µes livres consecutivas tiverem os mesmos valores m√≠nimos, de acordo com o crit√©rio de dano, o √≠ndice de uma das duas posi√ß√µes listadas primeiro na lista √© selecionado aleatoriamente. Escolher uma posi√ß√£o que exclua o n√∫mero m√≠nimo de posi√ß√µes livres nas linhas restantes minimiza o "dano" associado √† posi√ß√£o da rainha nesta posi√ß√£o. O uso dessas duas regras permite um uso mais racional dos recursos em cada etapa da forma√ß√£o de um ramo de pesquisa. Isso reduz bastante os riscos e aumenta a probabilidade de escolher uma composi√ß√£o arbitr√°ria para uma solu√ß√£o completa se a composi√ß√£o em quest√£o tiver uma solu√ß√£o. Se em alguma etapa da solu√ß√£o ocorrer que em uma das linhas restantes para considera√ß√£o n√£o houver vagas, esse ramo de pesquisa ser√° fechado. Nesse caso,com base em backups, todas as matrizes de controle s√£o restauradas e, se o n√∫mero de repeti√ß√µes n√£o exceder o valor limite</font></font><i>repeatBound</i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, sem alterar os √≠ndices do primeiro e do segundo ciclos externos, o trabalho do terceiro ciclo aninhado √© repetido novamente. Isso se deve ao fato de que, nos casos em que os valores m√≠nimos dos crit√©rios relevantes coincidiram, fizemos uma sele√ß√£o aleat√≥ria. A reformula√ß√£o do ramo de pesquisa nas mesmas condi√ß√µes do n√≠vel b√°sico permite um uso mais eficiente dos "recursos iniciais" fornecidos nesse n√≠vel. O n√∫mero de partidas repetidas do terceiro ciclo aninhado √© limitado e, se o valor limite for excedido, a opera√ß√£o desse ciclo ser√° interrompida. Depois disso, os valores das matrizes de controle s√£o restaurados e o controle √© transferido para o ciclo do terceiro n√≠vel de base para ir para o pr√≥ximo valor de √≠ndice. Este procedimento √© repetido ciclicamente at√© que uma solu√ß√£o completa seja obtida, ou acontece queque usamos todas as linhas livres e todas as posi√ß√µes livres nessas linhas neste n√≠vel b√°sico. Nesse caso, dependendo do n√∫mero total de c√°lculos repetidos em v√°rios n√≠veis de base e levando em considera√ß√£o o tamanho da matriz de decis√£o e o tamanho da composi√ß√£o, retorna-se a um dos n√≠veis mais baixos para c√°lculos repetidos ou se decide que a composi√ß√£o em quest√£o n√£o pode ser equipado para completar a solu√ß√£o. No programa, para limitar o tempo total da fatura, √© aceito que o procedimentoou se for julgado que a composi√ß√£o em quest√£o n√£o pode ser conclu√≠da at√© uma decis√£o completa. No programa, para limitar o tempo total da fatura, √© aceito que o procedimentoou se for julgado que a composi√ß√£o em quest√£o n√£o pode ser conclu√≠da at√© uma decis√£o completa. No programa, para limitar o tempo total da fatura, √© aceito que o procedimento</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O Back Tracking</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , independentemente de qual dos n√≠veis anteriores o retorno √© feito, pode ser executado n√£o mais que </font><font style="vertical-align: inherit;">tempos de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SimSound</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Esse valor limite √© selecionado com base em experimentos computacionais para v√°rios valores de n.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 5. An√°lise da efetividade dos algoritmos de sele√ß√£o </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A efici√™ncia do </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">algoritmo randSet e randSet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Para analisar as capacidades desse algoritmo, foi realizado um experimento computacional, que consistiu em </font><font style="vertical-align: inherit;">colocar rainhas na matriz da solu√ß√£o com </font><font style="vertical-align: inherit;">base no modelo </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSet e randSet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , desde que exista essa possibilidade. Assim que o ramo de pesquisa alcan√ßou um beco sem sa√≠da, ou uma solu√ß√£o completa foi obtida, o tamanho da composi√ß√£o, o tempo da solu√ß√£o foram fixados e o teste foi repetido novamente. Experimentos computacionais foram realizados para toda a lista b√°sica de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> valores </font><font style="vertical-align: inherit;">. O n√∫mero de testes repetidos para os valores </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n = (30, 40, ..., 90, 100, 200, 300, 500, 800, 1000)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> foi igual a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">um milh√£o</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , para os demais valores, o n√∫mero de testes, com aumento de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, diminuiu gradualmente de 100000 para 100. Uma an√°lise dos resultados de experimentos computacionais permite tirar as seguintes conclus√µes: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a) Como resultado de apenas o primeiro ciclo do </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">procedimento randSet &amp; randSet,</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> em m√©dia cerca de 60% de todas as rainhas s√£o colocadas corretamente. Para </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 100, o n√∫mero de rainhas colocadas corretamente √© 60,05%. Com um aumento no valor de n, esse valor diminui gradualmente e para n = 10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> equivale a 59,97%. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b) O histograma da distribui√ß√£o dos valores de comprimento das composi√ß√µes obtidas tem a mesma forma, independentemente do tamanho da matriz de decis√£o </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Al√©m disso, todos eles t√™m uma caracter√≠stica - o lado esquerdo da distribui√ß√£o (para o valor modal) difere do lado direito. Na Figura 2, como exemplo, o histograma correspondente para a </font></font><br><br><img src="https://habrastorage.org/webt/fu/h3/xy/fuh3xyqsx5ro7zx8ru7b66fliy8.jpeg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fig. 2. Um histograma da distribui√ß√£o de solu√ß√µes de v√°rios comprimentos para o modelo randSet e randSet ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 100, tamanho da amostra = 10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 100. Parece que o histograma √© coletado da distribui√ß√£o de frequ√™ncia de dois eventos diferentes, uma vez que a frequ√™ncia de ocorr√™ncia de eventos nas partes esquerda e direita da distribui√ß√£o √© diferente. Para descrever essa distribui√ß√£o, √© mais prov√°vel usar duas fun√ß√µes da densidade da distribui√ß√£o normal, uma das quais cobre o intervalo para o valor modal, a outra - o intervalo ap√≥s o valor modal.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c) O valor m√©dio do n√∫mero de rainhas ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qMean</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) que pode ser definido na matriz de decis√£o com base nesse algoritmo aumenta com </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Como pode ser visto na Figura 3, onde √© apresentado um gr√°fico da depend√™ncia da raz√£o </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qMean / n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> no tamanho da matriz </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , essa propor√ß√£o aumenta com o aumento do tamanho da matriz.</font></font> Por exemplo <br><img src="https://habrastorage.org/webt/wi/5b/kr/wi5bkrcaftlplvllyxfmek0lycg.jpeg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fig. 3. A depend√™ncia da raz√£o </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qMean / n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> no valor de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para v√°rios tamanhos da matriz da solu√ß√£o. O modelo √© </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSet e randSet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qMean</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √© o valor m√©dio do comprimento da solu√ß√£o. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se, para uma matriz </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">100x100</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , o </font><font style="vertical-align: inherit;">algoritmo de sele√ß√£o de posi√ß√£o </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSet &amp; randSet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> permite que "sem parar" coloque rainhas em m√©dia 89 linhas; em uma matriz </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000x1000</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , o n√∫mero dessas linhas aumenta em m√©dia para 967. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d) Com base no </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">algoritmo randSet &amp; randSet,</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> voc√™ pode obter o valor completo Como solu√ß√£o, no entanto, a "produtividade" dessa abordagem √© extremamente baixa. Como pode ser visto na Figura 4, para</font></font><br><br><img src="https://habrastorage.org/webt/7w/gt/jg/7wgtjgp2ria3lxqff4ouw9zqzpw.jpeg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fig. 4. A diminui√ß√£o da probabilidade de obter uma solu√ß√£o completa no </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">modelo randSet e randSet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> com um aumento em </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">valores de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 7, a probabilidade de obter uma solu√ß√£o completa √© </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,057</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Al√©m disso, com um aumento em </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n, a</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> probabilidade de obter uma solu√ß√£o completa diminui rapidamente, aproximando-se assintoticamente de zero. A partir do valor </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 48, a probabilidade de obter uma solu√ß√£o completa √© da ordem de 10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-6</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Ap√≥s o valor limite </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 70, para os valores subsequentes de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n,</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nenhuma solu√ß√£o completa foi obtida (com o n√∫mero de testes igual a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">um milh√£o</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e) Modelo</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Os</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> formul√°rios </font><i><font style="vertical-align: inherit;">randSet e randSet</font></i><font style="vertical-align: inherit;"> pesquisam ramos a uma velocidade muito alta. Para </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 1000, o tempo m√©dio para obter a composi√ß√£o √© de 0,0015 segundos. O comprimento m√©dio das composi√ß√µes √© 967. Portanto, para </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6, o</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tempo m√©dio √© de 2.6754 segundos, com um comprimento m√©dio de composi√ß√µes de 999793. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f) Exceto por um pequeno intervalo </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> &lt;= 70, quando o modelo </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSet &amp; randSet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> em casos muito raros pode levar a solu√ß√£o completa, em todos os outros casos, o ramo de decis√£o termina com a forma√ß√£o de uma composi√ß√£o negativa, que n√£o pode ser conclu√≠da at√© uma solu√ß√£o completa. Portanto, o </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">algoritmo randSet e randSet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ele tem uma vantagem importante - a alta velocidade de forma√ß√£o do ramo de pesquisa e uma desvantagem significativa √© que, se o tamanho da composi√ß√£o exceder um determinado valor limite, esse algoritmo leva √† forma√ß√£o de composi√ß√µes que n√£o podem ser conclu√≠das at√© uma solu√ß√£o completa. Para superar essa desvantagem, paramos a forma√ß√£o do ramo de pesquisa quando o limite </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">baseLevel-2 √© atingido</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A efici√™ncia do algoritmo </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rand &amp; rand</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Para determinar as capacidades do algoritmo </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rand &amp; rand</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , foi realizada uma simula√ß√£o de computador bastante detalhada para uma lista b√°sica de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> valores </font><font style="vertical-align: inherit;">. Tal como no </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">modelo randSet e randSet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, o n√∫mero de retestes na maioria dos casos foi igual a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">um milh√£o</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Para outros valores, o n√∫mero de testes diminuiu gradualmente de 100.000 para 100. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ambos os algoritmos s√£o baseados no princ√≠pio da sele√ß√£o aleat√≥ria. Portanto, √© de esperar que as conclus√µes aqui tiradas sejam basicamente id√™nticas √†s conclus√µes formuladas para o </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">modelo randSet e randSet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . No entanto, existe uma diferen√ßa fundamental entre eles e consiste no seguinte: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a) o modelo </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rand &amp; rand</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> n√£o funciona t√£o "duro" quanto o </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">modelo randSet &amp; randSet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Se falarmos sobre algum "√≠ndice de uso racional das oportunidades oferecidas", o modelo </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rand &amp; rand</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a cada passo usa os recursos de maneira mais racional. Isso leva ao fato de que, por exemplo, em </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 30, a probabilidade de obter uma solu√ß√£o completa de 0,00170 nesse modelo √© 15 vezes maior que o valor semelhante de 0,00011 para o </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">modelo randSet e randSet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Al√©m disso, aqui, at√© o valor limite </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 370, permanece a probabilidade de obter pelo menos uma solu√ß√£o completa durante um milh√£o de testes. Ap√≥s esse valor limite, para valores subsequentes de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> com o n√∫mero de testes igual a um milh√£o, </font><font style="vertical-align: inherit;">nenhuma solu√ß√£o completa foi obtida </font><font style="vertical-align: inherit;">com base no modelo </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rand &amp; rand</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b) esse algoritmo √© muito mais lento que o </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">algoritmo randSet &amp; randSet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Se por</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 1000 para gerar uma composi√ß√£o de tamanho 967, o tempo m√©dio para obter uma composi√ß√£o ser√° de 0,0497 segundos, 33 a mais do que o valor correspondente de 0,0015 para o </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">modelo randSet &amp; randSet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A raz√£o para as diferen√ßas entre dois m√©todos essencialmente semelhantes de sele√ß√£o aleat√≥ria se deve ao fato de que, no </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">modelo randSet e randSet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , para acelerar os c√°lculos, a sele√ß√£o aleat√≥ria da lista restante n√£o √© realizada em cada etapa. Em vez disso, um par de √≠ndices √© selecionado sequencialmente em duas listas, cujos elementos foram reorganizados aleatoriamente. Essa sele√ß√£o n√£o √© aleat√≥ria em toda a extens√£o; no entanto, ela se ajusta bem √† l√≥gica do problema e permite que voc√™ conte rapidamente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para demonstrar visualmente a opera√ß√£o do algoritmo </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rand &amp; rand</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, foi realizada a seguinte experi√™ncia: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a) Para um tabuleiro de xadrez de tamanho </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">100x100</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ap√≥s cada etapa da localiza√ß√£o da rainha em qualquer linha, foi determinado o n√∫mero de posi√ß√µes livres em cada uma das linhas livres restantes. Assim, ap√≥s cada etapa da solu√ß√£o do problema, recebemos uma lista de linhas livres e uma lista correspondente do n√∫mero de posi√ß√µes livres nessas linhas. Isso possibilitou a constru√ß√£o de um gr√°fico no qual os √≠ndices das colunas da matriz em quest√£o s√£o plotados ao longo do eixo das abcissas e o n√∫mero de posi√ß√µes livres restantes ao longo do eixo das ordenadas. Para compara√ß√£o, os c√°lculos tamb√©m foram realizados para o modelo de sele√ß√£o seq√ºencial de posi√ß√µes. Por sele√ß√£o sequencial entende-se o seguinte. A primeira linha √© considerada, na qual a primeira posi√ß√£o livre na lista √© selecionada. Ent√£o, a segunda linha √© considerada, na qual a primeira posi√ß√£o livre na lista, etc. tamb√©m √© selecionada. Nas figuras 5 e 6</font></font><br><br><img src="https://habrastorage.org/webt/y1/b5/vc/y1b5vcf2es-tsqteleekwvp5dly.jpeg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fig. 5. Reduzir o n√∫mero de posi√ß√µes livres nas linhas livres restantes ap√≥s a coloca√ß√£o das rainhas. Sele√ß√£o seq√ºencial regular de posi√ß√µes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Os resultados que correspondem aos modelos em considera√ß√£o s√£o apresentados. Para maior clareza, o gr√°fico mostra os resultados somente ap√≥s as etapas (10, 40, 60). Para o modelo de sele√ß√£o sequencial de posi√ß√µes, o √∫ltimo √© o gr√°fico ap√≥s a 62¬™ etapa, pois o ramo de pesquisa termina devido √† falta de uma posi√ß√£o livre na 63¬™ linha. Por outro lado, no modelo </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rand &amp; rand</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , o √∫ltimo gr√°fico √© apresentado ap√≥s o 70¬∫ passo da coloca√ß√£o da rainha, embora aqui, o n√∫mero m√©dio de rainhas corretamente posicionadas atinja 89, o que √© 26 passos a mais do que no modelo seq√ºencial. Uma vis√£o estranha dos gr√°ficos no modelo </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rand &amp; rand</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">devido ao fato de o √≠ndice de linha ser selecionado aleatoriamente entre as linhas livres restantes e, portanto, eles est√£o espalhados aleatoriamente por toda a matriz da solu√ß√£o. Uma compara√ß√£o dessas duas figuras mostra que no modelo seq√ºencial de sele√ß√£o de posi√ß√£o, a faixa de variabilidade do n√∫mero de posi√ß√µes livres √© maior do que no modelo </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rand &amp; rand</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Isso se deve ao fato de que, com a sele√ß√£o regular, restri√ß√µes diagonais excluem de maneira n√£o uniforme as posi√ß√µes livres nas linhas restantes, o que leva ao fato de que em algumas linhas a taxa de redu√ß√£o no n√∫mero de posi√ß√µes vagas √© maior do que em outras linhas. </font></font><br><br><img src="https://habrastorage.org/webt/9y/mn/m6/9ymnm6wo_jsazg8_u474pjngke8.jpeg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fig. 6. Reduzir o n√∫mero de posi√ß√µes livres nas linhas livres restantes ap√≥s a coloca√ß√£o das rainhas. O modelo de posicionamento √© </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rand &amp; rand</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por outro lado, com a sele√ß√£o aleat√≥ria do √≠ndice de linha livre e do √≠ndice de coluna livre, as posi√ß√µes da rainha s√£o distribu√≠das igualmente sobre a "√°rea" da matriz de decis√£o, o que reduz a taxa "m√©dia" de redu√ß√£o no n√∫mero de posi√ß√µes livres nas linhas restantes. Assim, levando em considera√ß√£o os recursos do algoritmo </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rand &amp; rand</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , n√≥s o usamos no programa para continuar a forma√ß√£o do ramo de pesquisa de solu√ß√µes at√© que o n√≠vel </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">baseLevel-3</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> seja </font><i><font style="vertical-align: inherit;">atingido</font></i><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deve-se notar que, mesmo que os algoritmos de sele√ß√£o ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSet e randSet, rand e rand</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) n√£o fossem t√£o eficientes, ainda ter√≠amos que usar outro m√©todo de sele√ß√£o aleat√≥ria ao desenvolver o algoritmo. Isto √© devido √† pr√≥pria declara√ß√£o do problema.</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Problema de conclus√£o do n-Queens</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Se imaginarmos que existe um certo algoritmo ideal que resolve o problema, na entrada, esse algoritmo sempre receber√° um determinado conjunto aleat√≥rio de √≠ndices de linha e coluna. Cada vez ser√° um novo conjunto aleat√≥rio de √≠ndices de linhas e colunas, com uma enorme variedade de possibilidades. Para poder ‚Äúabsorver‚Äù o algoritmo de uma variedade de composi√ß√µes aleat√≥rias, o pr√≥prio algoritmo deve ser constru√≠do com base na sele√ß√£o aleat√≥ria. A correspond√™ncia deve ser </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">como uma chave da fechadura</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Se construirmos o algoritmo com base neste princ√≠pio, qualquer composi√ß√£o consistente de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rainhas ser√£o consideradas como a posi√ß√£o inicial (inicial) no ciclo de tomada de decis√£o. </font><font style="vertical-align: inherit;">Al√©m disso, o objetivo ser√° apenas continuar a forma√ß√£o do ramo da busca de uma solu√ß√£o at√© que uma solu√ß√£o seja encontrada para uma determinada composi√ß√£o ou seja provado que essa solu√ß√£o n√£o existe.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 6. Um exemplo de uso da regra de risco m√≠nimo (n = 100) </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No est√°gio inicial de localiza√ß√£o de uma solu√ß√£o, quando o n√∫mero de posi√ß√µes livres nas linhas n√£o √© cr√≠tico, a escolha do √≠ndice da linha livre ou o √≠ndice da posi√ß√£o nessa linha n√£o √© fatal. No entanto, no √∫ltimo est√°gio, quando o n√∫mero de posi√ß√µes livres em algumas linhas √© 1 ou 2, nesse caso, voc√™ deve escolher um algoritmo de sele√ß√£o diferente. Nesse n√≠vel, os algoritmos de sele√ß√£o aleat√≥ria </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSet &amp; randSet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rand &amp; rand</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> n√£o funcionar√£o mais. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A raz√£o pela qual os algoritmos de sele√ß√£o aleat√≥ria n√£o funcionar√£o pode ser explicada pelo seguinte exemplo simples. Vamos, em algum momento da solu√ß√£o do problema, para um valor arbitr√°rio de n, nas linhas restantes </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , i </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ..., i </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k</font></font></sub></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o n√∫mero de posi√ß√µes vagas (indicado entre par√™nteses) √©: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (1), i </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (2), i </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (4), i </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (5), i </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (3), i </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (4)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> etc. Se selecionarmos aleatoriamente qualquer linha, mas n√£o a linha i </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , na qual existe apenas uma posi√ß√£o livre, isso pode levar a uma situa√ß√£o de risco quando proibi√ß√µes diagonais relacionadas √† posi√ß√£o da rainha na linha selecionada podem levar ao fechamento da √∫nica posi√ß√£o livre na linha </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , o que levar√° a solu√ß√£o a uma parada. De todas as linhas </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , i </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ..., i </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k</font></font></sub></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o mais vulner√°vel e sens√≠vel √† escolha do √≠ndice de linha √© a linha </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Nessas situa√ß√µes, voc√™ deve primeiro selecionar a linha cujo status √© o mais cr√≠tico e criar um risco para resolver o problema. Portanto, na √∫ltima etapa da solu√ß√£o do problema, em cada etapa √© necess√°rio escolher a posi√ß√£o da linha com base em um algoritmo simples de risco m√≠nimo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para maior clareza, consideremos, por exemplo, uma matriz </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">100 x 100</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , o √∫ltimo est√°gio na forma√ß√£o de uma solu√ß√£o real, ap√≥s o 88¬∫ passo. At√© a conclus√£o da tarefa, restavam 12 linhas livres, para cada uma das quais o n√∫mero de posi√ß√µes livres foi encontrado (as linhas s√£o classificadas em ordem crescente do n√∫mero de posi√ß√µes livres):</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Etapa 89 - 25 (1), 12 (2), 22 (2), 82 (2), 88 (2), 7 (3), 64 (3), 3 (4), 76 (4), 91 (4), 4 (5), 96 (5)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - indica o √≠ndice de uma linha livre e, entre par√™nteses, o n√∫mero de posi√ß√µes livres nessa linha. De acordo com a regra de risco m√≠nimo, na 89¬™ etapa da solu√ß√£o do problema, a linha 25 √© selecionada e a posi√ß√£o livre que est√° nela. Como resultado da recontagem, temos 11 linhas livres restantes: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Etapa-90 - 7 (2), 12 (2), 22 (2), 82 (2), 88 (2), 3 (3), 64 (3), 76 (3), 4 (4), 91 (4), 96 (4).</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como voc√™ pode ver, o n√∫mero de posi√ß√µes livres nas cinco primeiras linhas √© igual e igual a 2. Portanto, o √≠ndice de uma das tr√™s primeiras linhas √© selecionado aleatoriamente. </font><font style="vertical-align: inherit;">Nesse caso, a 12¬™ linha foi selecionada e a posi√ß√£o dos dois restantes nessa linha, o que leva a danos m√≠nimos. </font><font style="vertical-align: inherit;">Assim, na 91¬™ etapa da forma√ß√£o da solu√ß√£o, temos 10 linhas livres: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Etapa-91 - 22 (1), 3 (2), 7 (2), 82 (2), 88 (2), 64 (3) 76 (3), 91 (3), 4 (4), 96 (4)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Nesta etapa, a linha 22 √© selecionada e aquela posi√ß√£o livre que est√° nela. </font><font style="vertical-align: inherit;">Continuando de maneira semelhante, foi formada a seguinte sequ√™ncia de decis√µes (Tabela 1). </font><font style="vertical-align: inherit;">Os √≠ndices das linhas selecionadas s√£o mostrados em negrito.</font></font><br><div class="scrollable-table"><table><caption> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tabela 1. Demonstra√ß√£o do uso da regra de risco m√≠nimo ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 100).</font></font></b> <br></caption><tbody><tr><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Etapa </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> linha </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> linha </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> linha </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> linha </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> linha </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> linha </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> linha </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> linha </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> linha </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> linha </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> linha </font></font></th></tr><tr><td>  89 </td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">25 (1)</font></font></b> </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 12 (2) </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 22 (2) </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 82 (2) </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 7 (3) </font></font></td><td> 64(3) </td><td> 3(4) </td><td> 76(4) </td><td> 91(4) </td><td> 4(5) </td><td> 96(5) </td></tr><tr><td>  90 </td><td> 7(2) </td><td> <b>12(2)</b> </td><td> 22(2) </td><td> 82(2) </td><td> 3(3) </td><td> 64(3) </td><td> 76(3) </td><td> 4(4) </td><td> 91(4) </td><td> 96(4) </td><td></td></tr><tr><td>  91 </td><td> <b>22(1)</b> </td><td> 3(2) </td><td> 7(2) </td><td> 82(2) </td><td> 64(3) </td><td> 76(3) </td><td> 91(3) </td><td> 4(4) </td><td> 96(4) </td><td></td><td></td></tr><tr><td>  92 </td><td> <b>88(1)</b> </td><td> 3(2) </td><td> 7(2) </td><td> 82(2) </td><td> 91(2) </td><td> 64(3) </td><td> 76(3) </td><td> 4(4) </td><td> 96(4) </td><td></td><td></td></tr><tr><td>  93 </td><td> <b>3(1)</b> </td><td> 7(2) </td><td> 76(2) </td><td> 82(2) </td><td> 91(2) </td><td> 4(3) </td><td> 64(3) </td><td> 96(4) </td><td></td><td></td><td></td></tr><tr><td>  94 </td><td> <b>76(1)</b> </td><td> 4(2) </td><td> 7(2) </td><td> 82(2) </td><td> 91(2) </td><td> 64(3) </td><td> 96(4) </td><td></td><td></td><td></td><td></td></tr><tr><td>  95 </td><td> <b>91(1)</b> </td><td> 7(2) </td><td> 82(2) </td><td> 64(3) </td><td> 96(3) </td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td> 96 </td><td> <b>4(1)</b> </td><td> 82(1) </td><td> 7(2) </td><td> 64(3) </td><td> 96(3) </td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  97 </td><td> <b>7(1)</b> </td><td> 82(1) </td><td> 64(2) </td><td> 96(3) </td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td> 98 </td><td> <b>82(1)</b> </td><td> 64(2) </td><td> 96(2) </td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td> 99 </td><td> 64(1) </td><td> <b>96(1)</b> </td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  100 </td><td> <b>64(1)</b> </td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Neste exemplo em particular, em 11 dos 12 casos, houve uma situa√ß√£o em que na lista de linhas livres restantes havia pelo menos uma linha na qual apenas uma posi√ß√£o livre permaneceu. Se n√£o us√°ssemos a regra de risco m√≠nimo, n√£o conseguir√≠amos chegar ao fim. Como um ‚Äúmovimento errado‚Äù na escolha de um √≠ndice de uma linha livre, provavelmente levaria √† destrui√ß√£o da √∫nica posi√ß√£o livre que estava em uma das linhas livres restantes. √â por isso que, ao usar apenas o </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">algoritmo randSet x randSet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ou </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rand x rand</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para obter uma solu√ß√£o completa, nos √∫ltimos est√°gios, a solu√ß√£o chega a um beco sem sa√≠da.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deve-se notar que o algoritmo de risco m√≠nimo tem um significado cotidiano simples e √© frequentemente usado na tomada de decis√µes. </font><font style="vertical-align: inherit;">Por exemplo, o m√©dico trabalha primeiro no paciente cuja condi√ß√£o √© mais cr√≠tica para a vida, da mesma forma, o fazendeiro, durante uma seca severa, tentando salvar a colheita, primeiro regou as √°reas que est√£o na condi√ß√£o mais cr√≠tica ...</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 7. An√°lise da efici√™ncia do algoritmo </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para avaliar a efici√™ncia do algoritmo para v√°rios valores de n, foi realizado um experimento computacional bastante longo (em termos de tempo total). Inicialmente, um algoritmo bastante r√°pido foi desenvolvido para gerar matrizes de solu√ß√µes nQueens Problem para um valor arbitr√°rio de n. Em seguida, com base nesse programa, grandes amostras de solu√ß√µes foram formadas para uma lista b√°sica de n valores. Os tamanhos das amostras obtidas das solu√ß√µes nQueens Problem para v√°rios valores de n, respectivamente, foram iguais: (10) - 1000, (20, 30, ..., 90, 100, 200, 300, 500, 800, 1000, 3000, 5000, 10,000) - -10000, (30000, 50000, 80000) - 5000, (105, 3 * 105) - 3000, (5 * 105, 8 * 105, 106) - 1000, (3 * 106) - 300, ( 5 * 106) - 200, (10 * 106) - 100, (30 * 106) - 50, (50 * 106) - 30, (80 * 106, 100 * 106) - 20. Aqui, entre par√™nteses, √© indicada uma lista de n valores e um tra√ßo duplo indica o tamanho da amostra das solu√ß√µes obtidas.Depois disso, composi√ß√µes aleat√≥rias de tamanho arbitr√°rio foram formadas com base em cada amostra de solu√ß√µes. Por exemplo, para cada uma das 10.000 solu√ß√µes para n = 1000, foram formadas 100 composi√ß√µes aleat√≥rias de tamanho arbitr√°rio. O resultado foi uma amostra de um milh√£o de m√∫sicas. Como qualquer composi√ß√£o de tamanho arbitr√°rio, formada com base em uma solu√ß√£o existente, pode ser conclu√≠da pelo menos uma vez at√© uma solu√ß√£o completa, a tarefa era concluir cada composi√ß√£o da amostra gerada para uma solu√ß√£o completa com base no algoritmo da solu√ß√£o n-Queens Completion Problem . Como no algoritmo considerado em cada etapa √© verificada a coloca√ß√£o correta da rainha no tabuleiro, aqui, em princ√≠pio, elas n√£o podem sercom base em cada amostra de solu√ß√µes, foram formadas composi√ß√µes aleat√≥rias de tamanho arbitr√°rio. Por exemplo, para cada uma das 10.000 solu√ß√µes para n = 1000, foram formadas 100 composi√ß√µes aleat√≥rias de tamanho arbitr√°rio. O resultado foi uma amostra de um milh√£o de m√∫sicas. Como qualquer composi√ß√£o de tamanho arbitr√°rio, formada com base em uma solu√ß√£o existente, pode ser conclu√≠da pelo menos uma vez at√© uma solu√ß√£o completa, a tarefa era concluir cada composi√ß√£o da amostra gerada para uma solu√ß√£o completa com base no algoritmo da solu√ß√£o n-Queens Completion Problem . Como no algoritmo considerado em cada etapa √© verificada a coloca√ß√£o correta da rainha no tabuleiro, aqui, em princ√≠pio, elas n√£o podem sercomposi√ß√µes aleat√≥rias de tamanho arbitr√°rio foram formadas com base em cada amostra de solu√ß√µes. Por exemplo, para cada uma das 10.000 solu√ß√µes para n = 1000, foram formadas 100 composi√ß√µes aleat√≥rias de tamanho arbitr√°rio. O resultado foi uma amostra de um milh√£o de m√∫sicas. Como qualquer composi√ß√£o de tamanho arbitr√°rio, formada com base em uma solu√ß√£o existente, pode ser conclu√≠da pelo menos uma vez at√© uma solu√ß√£o completa, a tarefa era concluir cada composi√ß√£o da amostra gerada para uma solu√ß√£o completa com base no algoritmo da solu√ß√£o n-Queens Completion Problem . Como no algoritmo considerado em cada etapa √© verificada a coloca√ß√£o correta da rainha no tabuleiro de xadrez, aqui, em princ√≠pio, elas n√£o podem serForam formadas 100 composi√ß√µes aleat√≥rias de tamanho arbitr√°rio. O resultado foi uma amostra de um milh√£o de m√∫sicas. Como qualquer composi√ß√£o de tamanho arbitr√°rio, formada com base em uma solu√ß√£o existente, pode ser conclu√≠da pelo menos uma vez at√© uma solu√ß√£o completa, a tarefa era concluir cada composi√ß√£o da amostra gerada para uma solu√ß√£o completa com base no algoritmo da solu√ß√£o n-Queens Completion Problem . Como no algoritmo considerado em cada etapa √© verificada a correta coloca√ß√£o da rainha no tabuleiro de xadrez, aqui, em princ√≠pio, elas n√£o podem serForam formadas 100 composi√ß√µes aleat√≥rias de tamanho arbitr√°rio. O resultado foi uma amostra de um milh√£o de m√∫sicas. Como qualquer composi√ß√£o de tamanho arbitr√°rio, formada com base em uma solu√ß√£o existente, pode ser conclu√≠da pelo menos uma vez at√© uma solu√ß√£o completa, a tarefa era concluir cada composi√ß√£o da amostra gerada para uma solu√ß√£o completa com base no algoritmo da solu√ß√£o n-Queens Completion Problem . Como no algoritmo considerado em cada etapa √© verificada a correta coloca√ß√£o da rainha no tabuleiro de xadrez, aqui, em princ√≠pio, elas n√£o podem sera tarefa era concluir cada composi√ß√£o da amostra gerada, com base no algoritmo da solu√ß√£o n-Queens Completion Problem, para uma solu√ß√£o completa. Como no algoritmo considerado em cada etapa √© verificada a coloca√ß√£o correta da rainha no tabuleiro, aqui, em princ√≠pio, elas n√£o podem sera tarefa era concluir cada composi√ß√£o da amostra gerada para uma solu√ß√£o completa, com base no algoritmo da solu√ß√£o n-Queens Completion Problem. Como no algoritmo considerado em cada etapa √© verificada a correta coloca√ß√£o da rainha no tabuleiro de xadrez, aqui, em princ√≠pio, elas n√£o podem ser</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Decis√µes de </font><i><font style="vertical-align: inherit;">falso positivo</font></i><font style="vertical-align: inherit;"> (ou seja, decis√µes incorretas que consideramos erradas). No entanto, pode haver </font><font style="vertical-align: inherit;">solu√ß√µes de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">falsos negativos</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - no caso de qualquer composi√ß√£o formada com base na solu√ß√£o existente n√£o ser conclu√≠da pelo programa at√© que a solu√ß√£o seja conclu√≠da (embora saibamos que todas as composi√ß√µes t√™m uma solu√ß√£o). Realizando um experimento computacional em uma gama t√£o ampla de n valores, estabelecemos os seguintes objetivos: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a) determinar a complexidade de tempo do algoritmo, </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b) determinar a probabilidade de solu√ß√µes de falso-negativos para v√°rios valores de n, </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c) determinar a frequ√™ncia com que o procedimento de Back Tracking √© usado para valores diferentes de n. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Os resultados desse experimento computacional s√£o apresentados na tabela 2.</font></font><br><div class="scrollable-table"><table><caption> <b> 2.         n.</b> <br> <i>n</i> ‚Äì   ; <i>m</i> ‚Äì   ; t <sub>mean</sub> , t <sub>min</sub> , t <sub>max</sub> ‚Äì ,     ; t90 <sub>mean</sub> ‚Äì   ,    10%    ; FalseNeg( FalseNegative) ‚Äì  ,      ; <i>t <sub>row</sub> = t <sub>mean</sub> *10 <sup>6</sup> / n</i> ,   10 <sup>6</sup>   ,            <i>nxn</i> . <br></caption><tbody><tr><th> n </th><th>  m </th><th> t <sub>mean</sub> </th><th> t90 <sub>mean</sub> </th><th> t <sub>min</sub> </th><th> t <sub>max</sub> </th><th> FalseNeg </th><th> t <sub>row</sub> </th></tr><tr><td>  10 </td><td> 5000 </td><td> <b>0.001010</b> </td><td> 0.000532 </td><td> 0.000168 </td><td> 0.080673 </td><td>  2 </td><td> 1.0102 </td></tr><tr><td>  20 </td><td> 10 <sup>5</sup> </td><td> <b>0.003589</b> </td><td> 0.001809 </td><td> 0.000197 </td><td> 0.363096 </td><td>  5 </td><td> 1.7945 </td></tr><tr><td>  30 </td><td> 10 <sup>5</sup> </td><td> <b>0.008025</b> </td><td> 0.003793 </td><td> 0.000244 </td><td> 0.495716 </td><td>  10 </td><td> 2.6752 </td></tr><tr><td>  40. </td><td> 10 <sup>5</sup> </td><td> <b>0.014323</b> </td><td> 0.009127 </td><td> 0.000252 </td><td> 0.965817 </td><td> 7 </td><td> 3.5807 </td></tr><tr><td>  50. </td><td> 10 <sup>5</sup> </td><td> <b>0.005357</b> </td><td> 0.003589 </td><td> 0.000313 </td><td> 0.441711 </td><td>  9 </td><td> 10.7146 </td></tr><tr><td>  60 </td><td> 10 <sup>5</sup> </td><td> <b>0.005991</b> </td><td> 0.004103 </td><td> 0.000340 </td><td> 0.013738 </td><td>  10 </td><td> 9.9852 </td></tr><tr><td>  70 </td><td> 10 <sup>5</sup> </td><td> <b>0.006533</b> </td><td> 0.004566 </td><td> 0.000368 </td><td> 0.583897 </td><td>  8 </td><td> 9.3328 </td></tr><tr><td>  80 </td><td> 10 <sup>5</sup> </td><td> <b>0.006975</b> </td><td> 0.004987 </td><td> 0.000394 </td><td> 0.635676 </td><td> 7 </td><td> 8.7187 </td></tr><tr><td>  90 </td><td> 10 <sup>5</sup> </td><td> <b>0.006912</b> </td><td> 0.004763 </td><td> 0.000393 </td><td> 1.012710 </td><td>  4 </td><td> 7.6840 </td></tr><tr><td>  100 </td><td> 10 <sup>5</sup> </td><td> <b>0.007264</b> </td><td> 0.005107 </td><td> 0.000419 </td><td> 0.692387 </td><td>  4 </td><td> 7.2641 </td></tr><tr><td>  300 </td><td> 10 <sup>5</sup> </td><td> <b>0.013518</b> </td><td> 0.009496 </td><td> 0.000986 </td><td> 3.349766 </td><td>  3 </td><td> 4.5060 </td></tr><tr><td> 500 </td><td> 10 <sup>5</sup> </td><td> <b>0.028194</b> </td><td> 0.014554 </td><td> 0.001541 </td><td> 4.558749 </td><td>  2 </td><td> 5.6388 </td></tr><tr><td> 800 </td><td> 10 <sup>5</sup> </td><td> <b>0.049385</b> </td><td> 0.022735 </td><td> 0.002367 </td><td> 6.192782 </td><td>  1 </td><td> 6.1731 </td></tr><tr><td>  1000 </td><td> <b>10 <sup>6</sup></b> </td><td> <b>0.062157</b> </td><td> 0.027727 </td><td> 0.002943 </td><td> 8.015123 </td><td>  0 0 </td><td> 6.2156 </td></tr><tr><td> 3000 </td><td> 10 <sup>5</sup> </td><td> <b>0.177290</b> </td><td> 0.088507 </td><td> 0.008537 </td><td> 16.713140 </td><td>  0 0 </td><td> 5.9097 </td></tr><tr><td> 5000 </td><td> 10 <sup>5</sup> </td><td> <b>0.159239</b> </td><td> 0.136047 </td><td> 0.014224 </td><td> 42.181080 </td><td>  0 0 </td><td> 3.1849 </td></tr><tr><td> 10 <sup>4</sup> </td><td> 10 <sup>5</sup> </td><td> <b>0.321003</b> </td><td> 0.270927 </td><td> 0.028594 </td><td> 79.321174 </td><td>  0 0 </td><td> 3.2100 </td></tr><tr><td> 3*10 <sup>4</sup> </td><td> 10 <sup>4</sup> </td><td> <b>0.968795</b> </td><td> 0.651618 </td><td> 0.084936 </td><td> 139.28827 </td><td>  0 0 </td><td> 3.2293 </td></tr><tr><td> 5*10 <sup>4</sup> </td><td> 5000 </td><td> <b>1.147196</b> </td><td> 0.864045 </td><td> 0.143005 </td><td> 154.38225 </td><td>  0 0 </td><td> 2.2944 </td></tr><tr><td> 8*10 <sup>4</sup> </td><td> 4000 </td><td> <b>2.112079</b> </td><td> 1.215612 </td><td> 0.229532 </td><td> 204.27321 </td><td>  0 0 </td><td> 2.6401 </td></tr><tr><td> 10 <sup>5</sup> </td><td>  2000 </td><td> <b>2.253118</b> </td><td> 1.433197 </td><td> 0.290566 </td><td> 224.34623 </td><td>  0 0 </td><td> 2.2531 </td></tr><tr><td> 3*10 <sup>5</sup> </td><td>  2000 </td><td> <b>4.330649</b> </td><td> 3.181905 </td><td> 0.990932 </td><td> 340.29584 </td><td>  0 0 </td><td> 1.4435 </td></tr><tr><td> 5*10 <sup>5</sup> </td><td>  2000 </td><td> <b>5.985339</b> </td><td> 4.532205 </td><td> 1.488209 </td><td> 382.20016 </td><td>  0 0 </td><td> 1.1971 </td></tr><tr><td> 8*10 <sup>5</sup> </td><td>  2000 </td><td> <b>8.297512</b> </td><td> 6.554302 </td><td> 2.902425 </td><td> 75.87513 </td><td>  0 0 </td><td> 1.0372 </td></tr><tr><td> 10 <sup>6</sup> </td><td>  1000 </td><td> <b>11.376632</b> </td><td> 7.932194 </td><td> 2.954968 </td><td> 510.6265 </td><td>  0 0 </td><td> 1.1377 </td></tr><tr><td> 3*10 <sup>6</sup> </td><td>  400 </td><td> <b>23.138609</b> </td><td> 18.521503 </td><td> 10.433580 </td><td> 122.7597 </td><td>  0 0 </td><td> 0.7713 </td></tr><tr><td> 5*10 <sup>6</sup> </td><td>  300 </td><td> <b>33.103386</b> </td><td> 28.057816 </td><td> 14.937556 </td><td> 155.0890 </td><td>  0 0 </td><td> 0.6621 </td></tr><tr><td> 10*10 <sup>6</sup> </td><td>  200 </td><td> <b>61.444001</b> </td><td> 52.269241 </td><td> 31.624475 </td><td> 228.3087 </td><td>  0 0 </td><td> 0.6144 </td></tr><tr><td> 30*10 <sup>6</sup> </td><td>  50. </td><td> <b>149.71717</b> </td><td> 136.66441 </td><td> 84.556686 </td><td> 352.0534 </td><td>  0 0 </td><td> 0.4991 </td></tr><tr><td> 50*10 <sup>6</sup> </td><td>  40. </td><td> <b>253.86220</b> </td><td> 228.93732 </td><td> 105.37934 </td><td> 558.4629 </td><td>  0 0 </td><td> 0.5077 </td></tr><tr><td> 80*10 <sup>6</sup> </td><td>  30 </td><td> <b>372.29294</b> </td><td> 341.56397 </td><td> 250.80182 </td><td> 728.4806 </td><td>  0 0 </td><td> 0.4654 </td></tr><tr><td> 100*10 <sup>6</sup> </td><td>  20 </td><td> <b>508.43573</b> </td><td> 474.04890 </td><td> 354.80864 </td><td> 831.3753 </td><td>  0 0 </td><td> 0.5084 </td></tr></tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A conclus√£o geral que pode ser tirada com base nos resultados obtidos √© a seguinte: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a) O algoritmo funciona com rapidez suficiente. Por exemplo, o tempo m√©dio de compila√ß√£o de uma composi√ß√£o arbitr√°ria para um tabuleiro de xadrez de tamanho </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000 x 1000</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , obtido com base em </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">um milh√£o de</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> experi√™ncias de computa√ß√£o, √© de 0,062157 segundos. Isso significa que, se a composi√ß√£o tiver uma solu√ß√£o, ela ser√° encontrada imediatamente ap√≥s pressionar a tecla </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Enter"</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . O tempo m√©dio de compila√ß√£o de uma composi√ß√£o arbitr√°ria, para todos os valores de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , na faixa de 7 a 30.000, n√£o excede um segundo.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b) Em cada amostra, existem aproximadamente 10% das composi√ß√µes, que requerem muito mais tempo para serem conclu√≠das. Tais composi√ß√µes formam uma longa cauda direita no histograma de distribui√ß√£o. Se excluirmos esses 10% das composi√ß√µes e realizarmos c√°lculos para os 90% restantes das solu√ß√µes, o tempo de c√°lculo ( </font><i><sub><font style="vertical-align: inherit;">m√©dia</font></sub></i></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> t90</font></font><sub><font style="vertical-align: inherit;"></font></sub></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) ser√° muito menor. Por exemplo, para um tabuleiro de xadrez </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000 x 1000</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , o tempo m√©dio de contagem ser√° de 0,027727 segundos, 2,24 vezes menor que o tempo m√©dio obtido em toda a amostra. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c) Para valores </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n‚â§800</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , na amostra de composi√ß√µes havia aquelas que n√£o podiam ser conclu√≠das at√© uma solu√ß√£o completa. Isso √© </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">falso negativo</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">decis√µes. Dentro dos limites especificados no programa, permitindo que o procedimento de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Back Tracking</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> seja executado </font><font style="vertical-align: inherit;">at√© 1000 vezes, o algoritmo falhou ao concluir essas composi√ß√µes. Eles foram erroneamente classificados como composi√ß√µes negativas, ou seja, aqueles que n√£o t√™m uma solu√ß√£o. O n√∫mero dessas </font><font style="vertical-align: inherit;">solu√ß√µes de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">falso negativo</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √© insignificante e sua participa√ß√£o na amostra √© menor que 0,0001. Al√©m disso, √† medida que </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> aumenta </font><font style="vertical-align: inherit;">, a propor√ß√£o de </font><font style="vertical-align: inherit;">solu√ß√µes </font><font style="vertical-align: inherit;">de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">falso negativo</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> diminui. Para todos os valores de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> &gt; 800, nesta s√©rie de experimentos computacionais, n√£o houve um √∫nico caso de </font><font style="vertical-align: inherit;">solu√ß√µes </font><font style="vertical-align: inherit;">de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">falso negativo</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . No entanto, √© √≥bvio que, se o tamanho da amostra aumentar muitas vezes, a possibilidade do aparecimento de </font><i><font style="vertical-align: inherit;">Falso Negativo</font></i><font style="vertical-align: inherit;"> n√£o </font><i><font style="vertical-align: inherit;">√©</font></i><font style="vertical-align: inherit;"> exclu√≠da.</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">solu√ß√µes, embora a probabilidade de tal evento seja um n√∫mero muito pequeno. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A complexidade do tempo do algoritmo</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . A Figura 7 mostra um gr√°fico de altera√ß√µes no tempo m√©dio de separa√ß√£o de composi√ß√µes aleat√≥rias para v√°rios valores de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><img src="https://habrastorage.org/webt/fe/lj/zy/feljzywqkqijg-0pftjholzx3es.jpeg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fig. 7. A depend√™ncia do tempo m√©dio de colheita ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) de composi√ß√µes aleat√≥rias sobre o tamanho ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) da matriz de decis√£o. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O logaritmo decimal do valor de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n √©</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> plotado no eixo das abcissas </font><font style="vertical-align: inherit;">, e o logaritmo, aumentado em 1000 vezes, do tempo m√©dio de contagem, √© plotado no eixo das ordenadas. Para maior clareza, a figura tamb√©m mostra a linha pontilhada da diagonal do quadrante. Pode-se observar que o tempo de separa√ß√£o aumenta linearmente com o aumento de n. Em toda a faixa de n de 50 a 10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">os valores experimentais do tempo de contagem formam uma linha reta, que com uma correla√ß√£o razoavelmente alta ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R = 0,9998</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) √© descrita pelo </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">log da</font></font></i> <font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> equa√ß√£o de regress√£o linear </font><i><font style="vertical-align: inherit;">(1000 * t) = - 0,628927 + 0,781568 * log (n)</font></i></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Um pequeno desvio da tend√™ncia geral √© t√≠pico apenas para os valores </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n = ( 10, ... 49)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , devido ao fato de que apenas o quinto bloco de c√°lculos √© usado nessa faixa para resolver o problema, cujo algoritmo difere significativamente da opera√ß√£o dos algoritmos do primeiro e terceiro blocos. Na depend√™ncia resultante, o coeficiente linear ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,781568</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) √© menor que a unidade, o que leva ao fato de que, com o aumento do valor de n, a linha de regress√£o e a diagonal do quadrante divergem. Para explicar claramente o motivo dessa discrep√¢ncia em vez do tempo inicial, consideramos o tempo m√©dio necess√°rio para a localiza√ß√£o de uma rainha em uma linha, ou seja, divida o tempo m√©dio de contagem por </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Chamamos esse indicador de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tempo reduzido</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Obviamente, se o tempo reduzido n√£o mudar com o aumento de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , essa solu√ß√£o ser√° linear ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O (n)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Como pode ser visto na Figura 8, onde uma representa√ß√£o gr√°fica do logaritmo do tempo dada, </font></font><br><br><img src="https://habrastorage.org/webt/rm/zo/i5/rmzoi5vzkips2kreyaltswbzivm.jpeg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fig. 8 Depend√™ncia de tempo m√©dio ( </font><i><sub><font style="vertical-align: inherit;">linha</font></sub></i></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> t</font></font><sub><font style="vertical-align: inherit;"></font></sub></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), necess√°rio para que a rainha esteja localizada em uma linha arbitr√°ria, a partir do tamanho ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) da matriz da solu√ß√£o. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tRow</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), aumentado em 10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> vezes, a partir do logaritmo do tamanho da matriz da solu√ß√£o, na faixa de n de 50 a 10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , o tempo reduzido diminui com o aumento de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Se o tempo reduzido para </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n = 50</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for 10,7146 * 10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-6</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> segundos, o tempo correspondente para n = 10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8 ser√°</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> reduzido em 21 vezes e ser√° 0,5084 * 10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-6</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">segundos. Esse comportamento do algoritmo, √† primeira vista, parece err√¥neo, pois n√£o h√° raz√µes objetivas pelas quais o algoritmo o considerar√° mais lento para valores pequenos de n do que para valores grandes. No entanto, n√£o h√° erro, e essa √© uma propriedade objetiva desse algoritmo. Isso se deve ao fato de que esse algoritmo √© uma composi√ß√£o de tr√™s algoritmos que operam em velocidades diferentes. Al√©m disso, o n√∫mero de linhas processadas por cada um desses algoritmos muda com o aumento do valor de n. √â por esse motivo que o tempo de contagem est√° aumentando no intervalo inicial de valores n = (10, 20, 30, 40), uma vez que todos os c√°lculos nessa pequena √°rea s√£o realizados apenas com base no quinto bloco de procedimentos, que funciona de maneira muito eficiente, mas n√£o t√£o r√°pida quanto. primeiro bloco de procedimentos. Assim, dado que o tempo de contagem necess√°rio para posicionar a rainha em uma linha,diminui com o aumento do tamanho do tabuleiro de xadrez, a complexidade do tempo desse algoritmo pode ser chamada de decrescente - linear.</font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O n√∫mero de vezes que o </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Back Tracking (BT) foi usado</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Em todos os casos de um experimento computacional, rastreamos o n√∫mero de casos usando o procedimento BT na resolu√ß√£o de cada problema. Foi feito um somat√≥rio cumulativo de todos os casos de uso de BT, independentemente do n√≠vel de base retornado no processo de busca de uma solu√ß√£o. Isso nos deu a oportunidade de determinar, para cada amostra, a propor√ß√£o daquelas decis√µes nas quais o procedimento BT nunca foi usado. A Figura 9 mostra a </font></font><br><br><img src="https://habrastorage.org/webt/_l/5t/h5/_l5th5fsxg_u7aw_dei4o3b5h2w.jpeg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fig. 9. A propor√ß√£o de decis√µes na amostra em que o procedimento de Back Tracking nunca foi usado em um </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gr√°fico que mostra como a propor√ß√£o de casos da solu√ß√£o muda sem usar o procedimento BT ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zero Back Tracking</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) com aumento de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Pode-se observar que no intervalo de valores </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n = (7, ..., 100000)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , o n√∫mero de solu√ß√µes nas quais o procedimento BT nunca foi usado excede 35%. Al√©m disso, no intervalo de valores </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n = (320, ..., 22500)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , o n√∫mero de tais casos excede 50%. Os resultados mais efetivos foram obtidos para um tabuleiro de xadrez de tamanho </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5000 x 5000</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , onde, em uma amostra de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10.000</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> composi√ß√µes, em </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">61,92% dos</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> casos </font><font style="vertical-align: inherit;">foi </font><font style="vertical-align: inherit;">realizada a </font><font style="vertical-align: inherit;">solu√ß√£o </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Äúdetermin√≠stica‚Äù</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> do </font><font style="vertical-align: inherit;">problema </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n√£o determin√≠stico</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , porque Procedimento BT a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">61,92%</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">casos nunca foram usados. Nas demais solu√ß√µes, em 21,87% dos casos, o procedimento BT foi utilizado 1 vez, em 9,07% dos casos - 2 vezes e em 3,77% dos casos - 3 vezes. Juntos, isso representa 96,63% dos casos. O fato de que, ap√≥s o valor </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n = 5000</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , o n√∫mero de casos de solu√ß√£o do problema de configura√ß√£o sem o uso do procedimento BT est√° diminuindo gradualmente, est√° associado ao modelo selecionado para selecionar os valores de limite de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">baseLevel2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">baseLevel3</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Voc√™ pode alterar esses par√¢metros e obter um aumento no n√∫mero de solu√ß√µes sem usar o procedimento BT. No entanto, isso levar√° a um aumento no tempo de c√°lculo, uma vez que a participa√ß√£o do quinto bloco na opera√ß√£o do algoritmo aumentar√°. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O histograma da distribui√ß√£o da separa√ß√£o do tempo</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Na Figura 10, para um valor de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n = 1000</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√© apresentado um histograma da distribui√ß√£o do tempo de separa√ß√£o para um milh√£o de solu√ß√µes. A vis√£o n√£o muito comum do histograma de distribui√ß√£o (que provavelmente se assemelha √† silhueta noturna de edif√≠cios altos) n√£o est√° associada a um erro na sele√ß√£o da dura√ß√£o ou do n√∫mero de intervalos. Essa √© uma propriedade natural desse algoritmo. Para entender, </font></font><br><br><img src="https://habrastorage.org/webt/cm/ii/z9/cmiiz94kbp7hxfss1aqzkejd09o.jpeg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fig. 10. Um histograma do tempo de compila√ß√£o de composi√ß√µes de tamanhos arbitr√°rios. ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n = 1000</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ; </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tamanho da amostra = 1.000.000</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por que o histograma tem esse formato, considere a distribui√ß√£o do tempo de separa√ß√£o para composi√ß√µes que tenham o mesmo tamanho. Para isso, como exemplo, a partir da amostra inicial, selecionaremos todas as composi√ß√µes cujo tamanho √© 800. Havia 998 dessas composi√ß√µes em uma amostra de um milh√£o. A Figura 11 mostra um histograma da distribui√ß√£o do tempo de contagem para esta amostra. Pode-se ver pela figura que a distribui√ß√£o consiste em seis histogramas separados, com tamanhos decrescentes. </font></font><br><br><img src="https://habrastorage.org/webt/ku/70/xa/ku70xadamrocfeimg3zpvyvurgu.jpeg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fig. 11. Um histograma do tempo de compila√ß√£o de composi√ß√µes do mesmo tamanho (k = 800). ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n = 1000</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ; </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tamanho da amostra = 998</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A raz√£o pela qual o tempo de compila√ß√£o de 998 composi√ß√µes, em cada uma das quais 800 rainhas s√£o distribu√≠das aleatoriamente, √© "agrupado" em 6 grupos, porque o procedimento </font><i><font style="vertical-align: inherit;">Back Tracking</font></i><font style="vertical-align: inherit;"> √© usado</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. O primeiro histograma da figura, com o tamanho m√°ximo da amostra, s√£o aquelas que selecionam solu√ß√µes em que o procedimento BT nunca foi usado. Este √© um grupo das solu√ß√µes mais r√°pidas. O segundo histograma, que √© significativamente menor em tamanho que o primeiro, s√£o aquelas solu√ß√µes em que o procedimento BT foi usado apenas uma vez. Portanto, o tempo de decis√£o nesse grupo √© um pouco mais longo que no primeiro. Por conseguinte, no terceiro grupo, o procedimento BT foi utilizado duas vezes, no quarto - tr√™s vezes, etc., ou seja, As decis√µes nas quais o procedimento BT foi utilizado repetidamente foram realizadas por um per√≠odo maior. Tais solu√ß√µes formam a cauda direita longa da distribui√ß√£o desejada. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solu√ß√µes de falso negativo</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Se dividirmos todas as composi√ß√µes poss√≠veis para um valor arbitr√°rio de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">positivo e negativo, entre as composi√ß√µes positivas, existem aquelas que esse algoritmo pode classificar como negativo. Isso se deve ao fato de que, dentro dos limites estabelecidos pelos par√¢metros de pesquisa, o algoritmo n√£o consegue encontrar o caminho certo para concluir essas composi√ß√µes. Como mostram os resultados experimentais (Tabela 2), o n√∫mero de casos n√£o excede 0,0001 do tamanho da amostra e o valor desse erro diminui com o aumento de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Al√©m disso, para todos os valores de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n&gt; 800,</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> n√£o houve um √∫nico caso de </font><font style="vertical-align: inherit;">solu√ß√£o </font><font style="vertical-align: inherit;">de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">falso negativo</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Mesmo aumentar o tamanho da amostra para um milh√£o para </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n = 1000</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> n√£o resultou em </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">falso negativo</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">decis√µes. </font><font style="vertical-align: inherit;">O resultado nos permite formular a seguinte regra para resolver o problema: ‚ÄúQualquer composi√ß√£o aleat√≥ria de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> rainhas que √© distribu√≠da consistentemente em um tabuleiro de xadrez arbitr√°rio de tamanho </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nxn</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pode ser conclu√≠da at√© que uma solu√ß√£o completa seja feita, ou ser√° decidido que essa composi√ß√£o √© negativa e n√£o pode para ser completado. </font><font style="vertical-align: inherit;">A probabilidade de tomar tal decis√£o n√£o excede </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,0001</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">√Ä medida que o tamanho de um tabuleiro de xadrez aumenta, a probabilidade de tomar decis√µes erradas diminui. </font><font style="vertical-align: inherit;">A complexidade do tempo do algoritmo √© linear. ‚Äù</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 8. Conclus√µes </font></font></h3><br>  1. √â apresentado um algoritmo que permite, em tempo linear, resolver o problema do conjunto completo at√© uma solu√ß√£o completa de uma composi√ß√£o aleat√≥ria de <i>k</i> rainhas, distribu√≠da consistentemente em um tabuleiro de xadrez de tamanho arbitr√°rio <i>nxn</i> .  Al√©m disso, para qualquer composi√ß√£o de <i>k</i> rainhas ( <i>1‚â§ k &lt;n</i> ), √© fornecida uma solu√ß√£o, se houver, ou √© tomada uma decis√£o de que essa composi√ß√£o n√£o pode ser conclu√≠da.  A probabilidade de um erro ao tomar essa decis√£o n√£o excede 0,0001 e esse valor diminui com o aumento do tamanho de um tabuleiro de xadrez. <br><br>  2. A opera√ß√£o deste algoritmo √© baseada no uso de duas regras importantes: <br><br>  a) Na fase final de solu√ß√£o do problema, dentre todas as linhas livres restantes, √© selecionada uma para a qual o n√∫mero de posi√ß√µes livres √© m√≠nimo ( <i>regra de risco m√≠nimo</i> ).  Isso minimiza os riscos associados √† possibilidade de excluir as √∫ltimas posi√ß√µes vagas em algumas das linhas restantes. <br><br>  b) De todas as posi√ß√µes vagas na linha em quest√£o, essa posi√ß√£o √© selecionada que causa dano m√≠nimo √†s posi√ß√µes livres nas linhas livres restantes ( <i>regra de dano m√≠nimo</i> ).  Por " <i>dano m√≠nimo</i> " entende-se a sele√ß√£o dessa posi√ß√£o em uma linha que exclui a menor quantidade de posi√ß√µes livres em todas as linhas livres restantes. <br><br>  3. Foi estabelecido que, como resultado da opera√ß√£o desse algoritmo, o tempo m√©dio necess√°rio para a rainha ser colocada em uma linha diminui com um aumento no valor de n.  O tempo m√©dio necess√°rio para colocar a rainha em uma linha no caso em que n √© 10 <sup>8</sup> √© 21 vezes menor que o tempo correspondente para o caso n = 50. <br><br>  4. Verificou-se que, no intervalo de valores <i>n = (7, ..., 100000), o</i> n√∫mero de solu√ß√µes nas quais o procedimento de rastreamento de retorno nunca foi usado excede 35%.  Al√©m disso, no intervalo de valores <i>n = (320, ..., 22500)</i> , o n√∫mero de casos excede 50%, o que indica a alta efici√™ncia desse algoritmo. <br><br>  5. Um modelo para organizar o procedimento de <i>Back Tracking</i> √© proposto, com base na divis√£o da sequ√™ncia de etapas da decis√£o em n√≠veis b√°sicos.  <i>Um n√≠vel significa uma determinada etapa de decis√£o com um determinado n√∫mero de rainhas corretamente colocadas</i> .  As f√≥rmulas de regress√£o s√£o fornecidas para o c√°lculo dos valores do segundo e terceiro n√≠veis b√°sicos, dependendo de <i>n</i> . <br><br>  6. Os resultados de uma an√°lise comparativa de dois m√©todos de sele√ß√£o aleat√≥ria, denominados <i>randSet e randSet</i> e <i>rand &amp; rand</i> , s√£o <i>apresentados</i> .  O <i>algoritmo randSet e randSet</i> foi considerado r√°pido, mas rude.  Portanto, seu uso √© limitado ao atingir o segundo n√≠vel b√°sico.  Depois disso, o algoritmo <i>rand &amp; rand</i> √© usado, o que n√£o √© t√£o r√°pido, mas coloca rainhas de forma mais eficiente no tabuleiro de xadrez. <br><br>  7. Um algoritmo eficaz para verificar a corre√ß√£o da solu√ß√£o do <i>problema n-Queens</i> √© fornecido.  Este programa tamb√©m foi projetado para verificar a corre√ß√£o de uma composi√ß√£o aleat√≥ria de tamanho arbitr√°rio.  O programa funciona r√°pido o suficiente.  Por exemplo, o tempo necess√°rio para validar uma solu√ß√£o que consiste em 5 milh√µes de posi√ß√µes √© de 0,85 segundos. <br><br><h3>  9. Coment√°rios </h3><br>  1. Conforme indicado no in√≠cio do artigo, foram realizados estudos na faixa de <i>n</i> valores, de 7 a 100 milh√µes.  No entanto, o programa foi testado em uma faixa mais ampla de <i>n</i> valores, at√© um bilh√£o.  √â verdade que, no √∫ltimo caso, o programa teve que ser ligeiramente adaptado, dado o grande tamanho das matrizes.  Portanto, se o tamanho da RAM permitir, √© poss√≠vel realizar c√°lculos para grandes valores de n. <br><br>  2. Os valores dos indicadores da linha de base, bem como os valores limites do n√∫mero de repeti√ß√µes em v√°rios n√≠veis, foram otimizados para resolver o problema em toda a faixa de pesquisa.  Eles podem ser alterados dentro de um intervalo menor e reduzir o tempo de contagem.  √â importante n√£o aumentar a participa√ß√£o das solu√ß√µes de <i>falso negativo</i> . <br><br>  3. Neste artigo, usei o tempo de pressionamento da tecla <i>Enter</i> como uma medida de tempo para avaliar a rapidez com que o algoritmo funciona.  Se o resultado aparecer imediatamente ap√≥s pressionar a tecla, no n√≠vel da percep√ß√£o do usu√°rio, parece que o programa funciona "muito" rapidamente.  N√£o importa a rapidez com que o algoritmo funcione, o resultado n√£o aparecer√° na tela at√© que a chave seja conclu√≠da.  Portanto, pareceu-me que essa medida condicional do tempo pode servir como um n√≠vel limite para n√£o comparar estritamente a velocidade de v√°rios algoritmos. <br><br>  4. Filos√≥fico ... Durante o estudo, foi considerado um grande n√∫mero de publica√ß√µes relacionadas √† solu√ß√£o de problemas n√£o determin√≠sticos.  Na maioria dos casos, essas eram tarefas nas quais era necess√°rio fazer uma escolha em um grande espa√ßo de estados, sob as condi√ß√µes de determinadas restri√ß√µes.  Comparando-os, foi interessante saber at√© que ponto podemos avan√ßar na solu√ß√£o de tais problemas usando a abordagem matem√°tica padr√£o.  Tive a impress√£o de que √© imposs√≠vel resolver esses problemas apenas com base em defini√ß√µes, afirma√ß√µes de lemas e provas de teoremas.  Parece-me que, para resolver esses problemas, √© necess√°rio usar os m√©todos da matem√°tica algor√≠tmica usando simula√ß√£o por computador.  Para demonstrar a validade dessa conclus√£o, como exemplo simples, preparei para o tabuleiro de xadrez, cujo tamanho √© 10 <sup>9</sup> x 10 <sup>9,</sup> duas composi√ß√µes do mesmo tamanho, consistindo em 999.999.482 rainhas.  Eles s√£o preparados conforme descrito no in√≠cio do artigo e apresentados em dois arquivos no formato .mat.  Eles podem ser baixados neste link <a href="https://drive.google.com/drive/folders/1p5VJO4fAEs8vNp_EonFIitd1o6EJqzQt%3Fusp%3Dsharing">(dois arquivos de teste)</a> .  Os arquivos s√£o bastante "pesados", o tamanho de cada um deles √© de cerca de 3,97 Gb.  Em 999 997 976 linhas (em 99,99998% dos casos), as posi√ß√µes das rainhas em ambas as composi√ß√µes coincidem, e somente em 1506 linhas arbitr√°rias as posi√ß√µes das rainhas diferem. <br><br>  Para concluir os dados de composi√ß√£o para uma solu√ß√£o completa, √© necess√°rio colocar corretamente as rainhas nas 518 linhas livres restantes.  O n√∫mero de maneiras poss√≠veis de organizar 518 rainhas nas linhas livres restantes (levando em considera√ß√£o apenas o n√∫mero de maneiras de selecionar uma posi√ß√£o livre na linha selecionada) √© de aproximadamente 10 <sup>1466</sup> .  A diferen√ßa entre essas duas composi√ß√µes consiste apenas no fato de que uma delas √© positiva e pode ser completada at√© uma solu√ß√£o completa, e a outra composi√ß√£o √© negativa - ela n√£o pode ser completada at√© uma solu√ß√£o completa.  Pergunta: ‚Äú√â poss√≠vel, com base em uma abordagem matem√°tica rigorosa (isto √©, sem realizar opera√ß√µes computacionais algor√≠tmicas), determinar qual dessas duas composi√ß√µes √© positiva?‚Äù Se isso √© imposs√≠vel de resolver, podemos assumir que a proposi√ß√£o feita √© comprovada por contradi√ß√£o. <br><br>  Quero observar que, independentemente da abordagem estritamente matem√°tica deste problema, √© necess√°rio determinar o status de 518 * 10 <sup>9</sup> c√©lulas nas demais linhas livres.  Para fazer isso, √© necess√°rio considerar cada posi√ß√£o de rainhas estabelecidas anteriormente, e existem quase um bilh√£o delas, a fim de estabelecer as restri√ß√µes que cada rainha estabelecida imp√µe a posi√ß√µes livres nas 518 linhas restantes.  N√£o encontrei um "ponto de apoio" que me permitisse fazer esse trabalho apenas com base em uma abordagem estritamente matem√°tica, sem c√°lculos algor√≠tmicos. <br><br>  Dei aqui um exemplo m√≠nimo que consiste em apenas duas composi√ß√µes.  Se necess√°rio, o n√∫mero de tais composi√ß√µes pode ser aumentado. <br><br>  Deve-se notar que, com base no algoritmo linear proposto, ligeiramente adaptado para trabalhar com grandes composi√ß√µes, cujas tarefas podem ser conclu√≠das antes que uma solu√ß√£o completa seja executada na <i>√°rea de trabalho-13</i> , em cerca de 4,5 minutos (excluindo o tempo de carregamento dados de entrada). <br><br><h3>  10. Adi√ß√£o </h3><br>  A a√ß√£o de professores que recomendam tarefas capazes para os alunos desenvolverem e pesquisarem √© digna de respeito.  Isso requer um esfor√ßo consider√°vel, mas, superando dificuldades, o pesquisador observa outras tarefas complexas de maneira diferente.  Eu pensei que seria √∫til expandir as op√ß√µes para definir o problema do n-Queens para tais prop√≥sitos.  Se voc√™ observar a mesma tarefa de perspectivas diferentes, poder√° ver coisas diferentes.  Abaixo est√£o alguns deles. <br><br>  1. Considere o problema de organizar <i>n</i> rainhas em um <b>tabuleiro retangular de xadrez de</b> tamanho <i>nxm</i> .  Denote <i>k = m - n</i> .  Seja obtida alguma solu√ß√£o e em cada uma das <i>n</i> linhas uma rainha deve ser localizada.  Exclu√≠mos as posi√ß√µes em que as rainhas est√£o localizadas de uma an√°lise mais aprofundada.  Agora em cada linha existe a posi√ß√£o livre <i>m-1</i> .  Nas demais posi√ß√µes livres, encontramos novamente uma solu√ß√£o.  Como antes, exclu√≠mos de uma an√°lise mais aprofundada as posi√ß√µes em que as rainhas da segunda solu√ß√£o est√£o localizadas.  Agora em cada linha existem <i>m-2</i> posi√ß√µes livres.  Obviamente, a primeira e a segunda solu√ß√µes n√£o se cruzam em suas posi√ß√µes em nenhuma linha - elas s√£o ortogonais.  √â necess√°rio determinar o n√∫mero m√°ximo de solu√ß√µes mutuamente ortogonais para v√°rios valores de <i>k</i> .  Se <i>n</i> solu√ß√µes mutuamente ortogonais forem encontradas para o valor <i>k = 0</i> , o Royal Latin Square ser√° constru√≠do. <br><br>  <b>Observa√ß√£o</b> .  <i>Grigoryan E. (2018)</i> mostrou que, para qualquer solu√ß√£o do <i>Problema n-Queens</i> , existe uma solu√ß√£o complementar que n√£o se cruza com ela.  Isso significa que, para um valor arbitr√°rio de <i>n</i> , o conjunto de todas as solu√ß√µes do <i>problema n-Queens</i> √© dividido em dois subconjuntos de <b>tamanho igual</b> .  Qualquer solu√ß√£o do segundo subconjunto √© uma solu√ß√£o complementar √† solu√ß√£o correspondente do primeiro subconjunto.  A regra √© bastante simples, se <i>Q1 (i) √©</i> uma solu√ß√£o do primeiro conjunto, a solu√ß√£o complementar correspondente <i>Q2 (i)</i> do segundo subconjunto √© determinada pela f√≥rmula <i>Q2 (i) = n + 1 - Q1 (i), onde i = (1, ... , n)</i>  √â essa regra que explica o fato de que o n√∫mero de todas as solu√ß√µes do <i>problema n-Queens</i> , para um valor arbitr√°rio de <i>n</i> , √© sempre um n√∫mero par.  (Esta regra nos permite reduzir pela metade o tempo para calcular todas as solu√ß√µes completas para um tamanho arbitr√°rio <i>n do</i> tabuleiro <i>de</i> xadrez. Se denotarmos por <i>2 * k o</i> n√∫mero total de todas as solu√ß√µes, o valor <i>k</i> ser√° igual ao √≠ndice na lista seq√ºencial de todas as solu√ß√µes quando <i>Q (k) + Q ( k + 1) = n + 1</i> ). <br><br>  2. Na formula√ß√£o inicial do <i>problema do</i> problema <i>n-Qeens</i> , depois que a rainha √© colocada na posi√ß√£o <i>(i, j)</i> , s√£o executadas as seguintes a√ß√µes: <br><br>  a) excluir todas as c√©lulas da linha <i>ie</i> coluna <i>j</i> <br><br>  b) todas as c√©lulas localizadas na linha das diagonais esquerda e direita que passam pela c√©lula <i>(i, j)</i> s√£o exclu√≠das. <br><br>  Mudamos a condi√ß√£o b) na declara√ß√£o do problema.  Em vez de eliminar c√©lulas, usaremos a troca de c√©lulas.  Se a c√©lula localizada na linha das diagonais esquerda ou direita estiver livre, n√≥s a fecharemos; se a c√©lula estiver fechada, ent√£o a abriremos.  Isso facilita a localiza√ß√£o de uma solu√ß√£o.  No entanto, em vez da matriz quadrada <i>nxn</i> , consideramos uma matriz retangular de tamanho <i>nx (n - k)</i> .  √â necess√°rio, para um dado valor de <i>n</i> , encontrar o valor m√°ximo de <i>k</i> no qual pelo menos tr√™s solu√ß√µes ortogonais possam ser obtidas.  Como o valor de <i>k</i> mudar√° com o aumento do valor de <i>n</i> ? <br><br>  3. Altere algumas condi√ß√µes na formula√ß√£o inicial do <i>problema do</i> problema <i>n-Queens</i> .  Quando a rainha √© colocada na posi√ß√£o <i>(i, j)</i> em um tabuleiro de xadrez de tamanho <i>nxn</i> : <br><br>  a) excluir todas as c√©lulas da linha <i>i</i> , <br><br>  b) se o √≠ndice <i>j for</i> um n√∫mero par, ent√£o: <br><br>  b1) excluir c√©lulas em linhas pares da coluna j, <br><br>  b2) exclu√≠mos c√©lulas em linhas pares que se cruzam com as diagonais esquerda e direita passando pela c√©lula <i>(i, j)</i> , <br><br>  c) Se o √≠ndice <i>j for</i> um n√∫mero √≠mpar, os pontos b1) e b2) ser√£o satisfeitos para c√©lulas localizadas em linhas √≠mpares. <br><br>  3.1 Sabe-se <i>(Sloane-2016)</i> que a lista de valores de todas as solu√ß√µes do <i>problema nQueens</i> , para <i>n = (8, 9, 10, 11, 12, 13, 14, 15, 16)</i> , respectivamente, √© <i>(92, 352, 724, 2680, 14200, 73712, 365596, 2279184, 14772512)</i> .  Como o n√∫mero de todas as solu√ß√µes mudar√° se, na declara√ß√£o do problema, a condi√ß√£o padr√£o para exce√ß√µes diagonais for alterada para o par√°grafo b) ou o par√°grafo c)? <br><br>  3.2 √â sabido por Grigoryan (2018) que, se determinarmos a frequ√™ncia de participa√ß√£o de diferentes c√©lulas da matriz da solu√ß√£o na forma√ß√£o de uma lista de todas as solu√ß√µes, podemos descobrir que h√° rela√ß√µes harmoniosas entre todas as c√©lulas na forma de simetrias verticais e horizontais das frequ√™ncias correspondentes.  Isso significa que, se assumirmos que <i>k &lt;n / 2</i> , a frequ√™ncia das c√©lulas da <i>k-√©sima</i> linha ser√° id√™ntica √†s frequ√™ncias das c√©lulas da linha <i>n-k + 1</i> .  Da mesma forma, a frequ√™ncia das c√©lulas da <i>k-√©sima</i> coluna ser√° id√™ntica √†s frequ√™ncias das c√©lulas da coluna <i>n-k + 1</i> .  Pergunta: ‚ÄúComo essas rela√ß√µes harmoniosas mudar√£o no contexto da tarefa?‚Äù <br><br>  4. Todas as c√©lulas de um tabuleiro de xadrez s√£o divididas em duas classes por sua cor.  Acredita-se que uma cor seja branca e a outra preta.  Considere dois tabuleiros de xadrez e coloque um deles no outro para que as bordas coincidam completamente.  Como resultado, obtemos um "sandu√≠che" de dois tabuleiros de xadrez, nos quais o arranjo das c√©lulas brancas e pretas coincide.  A tarefa √© encontrar solu√ß√µes simultaneamente em duas placas, observando as seguintes condi√ß√µes: <br><br>  a) Se em uma das placas a rainha estiver localizada em uma c√©lula preta com √≠ndices <i>(i, j)</i> , ent√£o: <br><br>  - em ambas as placas, todas as c√©lulas pretas encontradas na linha <i>ie</i> coluna <i>j</i> s√£o exclu√≠das <br><br>  - em ambas as placas, todas as c√©lulas pretas localizadas ao longo das diagonais esquerda e direita que passam pela c√©lula <i>(i, j)</i> s√£o exclu√≠das. <br><br>  b) Se em uma das placas a rainha estiver localizada em uma c√©lula branca com √≠ndices <i>(i, j)</i> , todas as a√ß√µes do par√°grafo a) ser√£o realizadas apenas para c√©lulas brancas. <br><br>  5. Imagine que em uma matriz de solu√ß√£o do tamanho <i>nxn</i> , as linhas podem deslizar uma em rela√ß√£o √† outra √† direita ou √† esquerda, com uma etapa de <i>k</i> c√©lulas.  Al√©m disso, se a linha anterior foi deslocada, por exemplo, para a esquerda, a pr√≥xima linha deve ser deslocada para a direita, ou seja,  cada linha seguinte √© deslocada na dire√ß√£o oposta √† linha anterior.  Como resultado dessa constru√ß√£o, obtemos uma matriz retangular de tamanho <i>nx (n + k)</i> , onde em cada linha k c√©lulas do in√≠cio da linha ou do final ser√£o exclu√≠das da considera√ß√£o.  A tarefa √© encontrar o valor m√°ximo de <i>k</i> para um valor arbitr√°rio de <i>n</i> para o qual existe pelo menos uma solu√ß√£o <i>n-Problema do Queens</i> . <br>  Considere uma variante do problema em que o deslocamento de uma linha em rela√ß√£o a outra √© um n√∫mero aleat√≥rio que varia de <i>k1</i> a <i>k2</i> . <br><br>  6. A <b>formula√ß√£o <i>unidimensional do problema nQueens</i></b> .  Deixe <i>n</i> segmentos de comprimento arbitr√°rio, numerados de <i>1 a n</i> , dispostos no semi-eixo.  Divida cada segmento em <i>n</i> c√©lulas de tamanho arbitr√°rio e, em cada segmento, numere c√©lulas de <i>1 a n</i> .  Chamamos essas c√©lulas de abertas.  √â necess√°rio fechar uma c√©lula em cada segmento, levando em considera√ß√£o as seguintes restri√ß√µes: <br><br>  a) Podemos escolher uma c√©lula aberta com o n√∫mero <i>j</i> do <i>i-</i> √©simo segmento, se: <br><br>  D1 (r) = 0; <br><br>  D2 (t) = 0; <br><br>  onde <i>r = n + j - i, t = j + i, D1 e D2</i> s√£o matrizes de controle unidimensional que consistem em <i>2n</i> c√©lulas que foram zeradas anteriormente. <br><br>  b) Ap√≥s essa sele√ß√£o, o segmento <i>ie</i> c√©lulas com o n√∫mero <i>j</i> ser√£o fechadas em todos os demais segmentos livres.  Tamb√©m √© necess√°rio fechar as c√©lulas correspondentes nas matrizes de controle: <br><br>  D1 (r) = 1; <br><br>  D2 (t) = 1; <br><br>  Nessa configura√ß√£o, a tarefa √© completamente id√™ntica √† original.  De interesse √© a formula√ß√£o desse problema com outras condi√ß√µes de restri√ß√£o.  Por exemplo, se em vez de f√≥rmulas: <br>  <i>r = n + j - i, t = j + i ,,</i> <br>  ser√£o consideradas outras rela√ß√µes que conectam funcionalmente os √≠ndices <i>r</i> e <i>t</i> aos √≠ndices <i>(i, j) da</i> matriz de decis√£o. <br><br>  7. <b>A reda√ß√£o da tarefa com base em uma urna com bolas</b> (id√™ntica √† reda√ß√£o anterior).  Que haja <i>n</i> urnas numeradas de <i>1 a n</i> , e em cada urna h√° <i>n</i> bolas, tamb√©m numeradas de <i>1 a n</i> .  √â necess√°rio selecionar uma bola de cada urna, levando em considera√ß√£o as seguintes restri√ß√µes: <br><br>  a) Podemos escolher uma bola com o n√∫mero <i>j</i> da <i>i¬™</i> urna se: <br><br>  <i>D1 (r) = 0</i> , <br><br>  <i>D2 (t) = 0</i> , <br><br>  onde <i>r = n + j - i, t = j + i, D1 e D2</i> s√£o matrizes de controle unidimensional que consistem em <i>2n</i> c√©lulas que foram zeradas anteriormente. <br><br>  b) Ap√≥s essa escolha, as urnas de vota√ß√£o <i>ie as</i> bolas com n√∫mero <i>j</i> ser√£o fechadas em todas as urnas restantes restantes.  Tamb√©m √© necess√°rio fechar as c√©lulas correspondentes nas matrizes de controle: <br><br>  <i>D1 (r) = 1</i> <br><br>  <i>D2 (t) = 1</i> . <br><br>  Nessa configura√ß√£o, a tarefa √© completamente id√™ntica √† original.  Como no caso anterior, a declara√ß√£o deste problema com outras condi√ß√µes que conectam funcionalmente os √≠ndices <i>r</i> e <i>t</i> com os √≠ndices <i>(i, j) da</i> matriz de decis√£o √© de interesse. <br><br>  8. <b>o jogo</b>  Considere um tabuleiro de xadrez de tamanho <i>nxn</i> .  Vamos devolver a cor √†s rainhas, deixar algumas rainhas de cor branca, outras pretas.  Tamb√©m devolvemos a cor branca e preta alternada √†s c√©lulas do tabuleiro de xadrez, com base no fato de que a c√©lula com o √≠ndice <i>(1, n)</i> deve ser branca.  Todas as c√©lulas no in√≠cio do jogo s√£o consideradas livres.  Rainhas brancas fazem o primeiro movimento.  O jogador coloca a rainha em uma c√©lula livre arbitr√°ria com √≠ndices <i>(i, j)</i> .  Que seja uma c√©lula branca.  Como resultado dessa escolha, feche: <br><br>  a) todas as c√©lulas brancas da linha <i>i</i> , <br><br>  b) todas as c√©lulas brancas da coluna <i>j</i> , <br><br>  c) todas as c√©lulas brancas que se encontram nas diagonais esquerda e direita que passam atrav√©s da c√©lula <i>(i, j)</i> . <br><br>  Se a c√©lula <i>(i, j)</i> for preta, todos os itens <i>(a, b, c)</i> ser√£o satisfeitos e, portanto, todas as c√©lulas em preto ser√£o fechadas.  Em seguida, as pretas executam o movimento, colocando a rainha em qualquer uma das c√©lulas livres restantes.  Depois disso, de maneira semelhante, as c√©lulas se fecham, como descrito acima.  O tempo para pensar sobre a pr√≥xima jogada √© fixo e √© selecionado por acordo das partes.  Se durante o tempo especificado, um dos jogadores n√£o concluir sua jogada, o jogo ser√° transferido para o outro.  O jogo termina se ambos os jogadores, um ap√≥s o outro, falharem em completar o turno no tempo especificado.  Quem pode colocar mais rainhas no tabuleiro vence. <br><br>  9. Sobre a estabilidade da sele√ß√£o aleat√≥ria.  Considere o <i>modelo randSet e randSet</i> .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como resultado da compara√ß√£o de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pares aleat√≥rios de √≠ndices de linha e coluna, no primeiro est√°gio do ciclo, √© poss√≠vel estabelecer rainhas em m√©dia em </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k * n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> linhas. O valor de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pode ser considerado um valor constante igual a 0,6. Seu valor varia de 0,605701 em </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n = 10</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e 0,599777 em n = 10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e, com o aumento de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , a varia√ß√£o desse valor diminui. Qual √© o motivo dessa "const√¢ncia"? Por que, com uma sele√ß√£o aleat√≥ria do √≠ndice de linha e o √≠ndice de posi√ß√£o da rainha nesta linha, com base em duas listas de n√∫meros obtidos com base em uma permuta√ß√£o aleat√≥ria de n√∫meros de 1 a n, √© poss√≠vel colocar consistentemente as rainhas (em m√©dia) em 60% das linhas? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10. Deixe o tamanho do tabuleiro de xadrez igual</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nxn</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Com base nos procedimentos </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randSet e randSet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font><i><font style="vertical-align: inherit;">colocamos as</font></i><font style="vertical-align: inherit;"> rainhas no tabuleiro de xadrez at√© que o ramo de pesquisa atinja o beco sem sa√≠da. Indique o comprimento da composi√ß√£o assim obtida por </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Se, para um determinado valor de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n,</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> repetir esse procedimento v√°rias vezes e construir um histograma da distribui√ß√£o dos valores de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , verifica-se que a altera√ß√£o na frequ√™ncia de ocorr√™ncia de eventos no valor do modo de distribui√ß√£o difere da altera√ß√£o na frequ√™ncia de ocorr√™ncia de eventos ap√≥s esse valor. Se, com base no valor modal, o histograma for dividido em duas partes, a parte esquerda n√£o coincidir√° com a parte direita. Esse padr√£o √© caracter√≠stico para qualquer valor de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Por que, ap√≥s a transi√ß√£o do comprimento da composi√ß√£o pelo valor modal, a frequ√™ncia de ocorr√™ncia de eventos assume uma forma diferente? </font><font style="vertical-align: inherit;">Por um evento, queremos dizer receber uma composi√ß√£o de um determinado tamanho, antes de atingir um estado de impasse.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Literatura </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Nauck, F. (1850). </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Briefwechsel mit allen fur alle</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Illustrierte Zeitung, 15, 182. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. </font></font><a href="https://jair.org/index.php/jair/article/view/11079/26262"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gent, IP, Jefferson, C. &amp; Nightingale, P. (2017). </font></font></a> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Complexidade da conclus√£o de n-Queens</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Journal of Artificial Intelligence Research., 59, 815-848. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. Sosic, R., &amp; Gu, J. (1990). </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um algoritmo de tempo polinomial para o problema n-rainhas</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Boletim SIGART, 1 (3), 7‚Äì11. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. </font></font><a href="https://www.cl.cam.ac.uk/~mr10/backtrk.pdf"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Richards, M. (1997). </font></font></a> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Algoritmos de retrocesso no MCPL usando padr√µes de bits e recurs√£o</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tech. rep., Laborat√≥rio de Inform√°tica, Universidade de Cambridge. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M√©todos de Randomiza√ß√£o no Design de Algoritmos</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, Anais de um Workshop DIMACS, Princeton, Nova Jersey, EUA, 12-14 de dezembro de 1997. S√©rie DIMACS em Matem√°tica Discreta e Ci√™ncia da Computa√ß√£o Te√≥rica 43, DIMACS / AMS 1999, ISBN 978-0-8218-0916-7 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6. </font></font><a href="http://ejournal11.com/journals_n/1537458681.pdf"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grigoryan E. (2018). </font></font></a> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Investiga√ß√£o das regularidades na forma√ß√£o de solu√ß√µes n-Queens Problem</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Modelagem de Intelig√™ncia Artificial, 5 (1), 3-21 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7. </font></font><a href="http://oeis.org/A000170,%25202016"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sloane N.-JA (2016). </font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A enciclop√©dia on-line de seq√º√™ncias inteiras.</font></font><br><br><br></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt483036/">https://habr.com/ru/post/pt483036/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt483018/index.html">Mask-R CNN do iniciante ao profissional</a></li>
<li><a href="../pt483024/index.html">‚ÄúO que as empresas fizeram com sua privacidade?‚Äù, Arthur Khachuyan (Tazeros Global)</a></li>
<li><a href="../pt483026/index.html">Java / Spring: Como gerar completamente uma API RUD CRUD usando Speedment</a></li>
<li><a href="../pt483030/index.html">API que faz voc√™ chorar</a></li>
<li><a href="../pt483032/index.html">Mudando da CEI para a Rep√∫blica Tcheca, experi√™ncia pr√≥pria (parte 2)</a></li>
<li><a href="../pt483038/index.html">Reiniciando o mundo do jogo com compet√™ncia</a></li>
<li><a href="../pt483040/index.html">Chave de fenda m√°gica para montagem no Extremo Oriente Excel 97</a></li>
<li><a href="../pt483042/index.html">9 dicas de desempenho do Vue</a></li>
<li><a href="../pt483048/index.html">Divers√£o no terminal: 10 piadas cl√°ssicas do console</a></li>
<li><a href="../pt483050/index.html">As 5 principais empresas de desenvolvimento do ReactJS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>