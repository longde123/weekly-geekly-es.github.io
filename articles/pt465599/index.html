<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕜 👃🏼 ⏸️ IPFS sem dor (mas isso não é preciso) 👱🏿 ⏺️ ⚖️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Apesar do fato de que em Habré já não havia um artigo sobre o IPFS . 

 Esclareço imediatamente que não sou especialista neste campo, mas demonstrei i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>IPFS sem dor (mas isso não é preciso)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/465599/"><img src="https://habrastorage.org/webt/wi/od/vh/wiodvhs9bp_gm6uff-4kp8ly0ni.jpeg"><br><br>  Apesar do fato de que em Habré já <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">não</a> havia <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">um artigo sobre o IPFS</a> . <br><br>  Esclareço imediatamente que não sou especialista neste campo, mas demonstrei interesse nessa tecnologia mais de uma vez, mas tentar brincar com ela geralmente causava alguma dor.  Hoje fiz novamente os experimentos e obtive alguns resultados que gostaria de compartilhar.  Em resumo, o processo de instalação do IPFS e alguns chips será descrito (tudo foi feito no ubuntu, em outras plataformas que eu não tentei). <br><a name="habracut"></a><br>  <i>Se você perdeu o que é IPFS, ele está escrito com alguns detalhes aqui: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">habr.com/en/post/314768</a></i> <br><br><h2>  Instalação </h2><br>  <i>Para a pureza do experimento, proponho a instalação imediata em algum servidor externo, pois consideraremos algumas armadilhas ao trabalhar no modo local e remoto.</i>  <i>Então, se desejado, não será demolido por muito tempo, não há muitos.</i> <br><br><h3>  Pronto </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Documentação oficial</a> <br>  Veja a versão atual em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">golang.org/dl</a> <br><br>  <i>Nota: é melhor instalar o IPFS em nome do usuário, que deve usar os mais frequentes.</i>  <i>O fato é que abaixo consideraremos a opção de montagem via <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">FUSE</a> e existem sutilezas por lá.</i> <br><br><pre><code class="plaintext hljs">cd ~ curl -O https://dl.google.com/go/go1.12.9.linux-amd64.tar.gz tar xvf go1.12.9.linux-amd64.tar.gz sudo chown -R root:root ./go sudo mv go /usr/local rm go1.12.9.linux-amd64.tar.gz</code> </pre> <br>  Então você precisa atualizar o ambiente (mais detalhes aqui: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">golang.org/doc/code.html#GOPATH</a> ). <br><br><pre> <code class="plaintext hljs">echo 'export GOPATH=$HOME/work' &gt;&gt; ~/.bashrc echo 'export PATH=$PATH:/usr/local/go/bin:$GOPATH/bin' &gt;&gt; ~/.bashrc source ~/.bashrc</code> </pre><br>  Verifique se o go está instalado <br><br><pre> <code class="plaintext hljs">go version</code> </pre> <br><h3>  Instalar IPFS </h3><br>  Eu gostei da maneira de instalar via <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ipfs-update mais</a> . <br><br>  Instale-o com o comando <br><br><pre> <code class="plaintext hljs">go get -v -u github.com/ipfs/ipfs-update</code> </pre><br>  Depois disso, você pode executar os seguintes comandos: <br><br>  <b>versões do ipfs-update</b> - para ver todas as versões disponíveis para download. <br>  <b>ipfs-update version</b> - para ver a versão atual instalada (até que tenhamos o IPFS instalado, não haverá nenhum). <br>  <b>ipfs-update install latest</b> - instale a versão mais recente do IPFS.  Em vez da mais recente, respectivamente, você pode especificar qualquer versão desejada da lista de disponíveis. <br><br>  Instale o ipfs <br><br><pre> <code class="plaintext hljs">ipfs-update install latest</code> </pre><br>  Verifique <br><br><pre> <code class="plaintext hljs">ipfs --version</code> </pre> <br>  Diretamente com a instalação em termos gerais, tudo. <br><br><h2>  Lançamento do IPFS </h2><br><h3>  Inicialização </h3><br>  Primeiro você precisa executar a inicialização. <br><br><pre> <code class="plaintext hljs">ipfs init</code> </pre> <br>  Em resposta, você obterá algo como isto: <br><br><pre> <code class="plaintext hljs"> ipfs init initializing IPFS node at /home/USERNAME/.ipfs generating 2048-bit RSA keypair...done peer identity: QmeCWX1DD7HnXXXXXXXXXXXXXXXXXXXXXXXXxxx to get started, enter: ipfs cat /ipfs/QmS4ustL54uo8FzR9455qaxZwuMiUhyvMcX9Ba8nUH4uVv/readme</code> </pre><br>  Você pode executar o comando proposto <br><br><pre> <code class="plaintext hljs">ipfs cat /ipfs/QmS4ustL54uo8FzR9455qaxZwuMiUhyvMcX9Ba8nUH4uVv/readme</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Resultado</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">Hello and Welcome to IPFS! ██╗██████╗ ███████╗███████╗ ██║██╔══██╗██╔════╝██╔════╝ ██║██████╔╝█████╗ ███████╗ ██║██╔═══╝ ██╔══╝ ╚════██║ ██║██║ ██║ ███████║ ╚═╝╚═╝ ╚═╝ ╚══════╝ If you're seeing this, you have successfully installed IPFS and are now interfacing with the ipfs merkledag! ------------------------------------------------------- | Warning: | | This is alpha software. Use at your own discretion! | | Much is missing or lacking polish. There are bugs. | | Not yet secure. Read the security notes for more. | ------------------------------------------------------- Check out some of the other files in this directory: ./about ./help ./quick-start &lt;-- usage examples ./readme &lt;-- this file ./security-notes</code> </pre><br></div></div><br>  Aqui, na minha opinião, o interessante já está começando.  Na fase de instalação, os caras já estão começando a usar suas próprias tecnologias.  O hash proposto QmS4ustL54uo8FzR9455qaxZwuMiUhyvMcX9Ba8nUH4uVv - não gerado especificamente para você, mas costurado no release.  Ou seja, antes do lançamento, eles prepararam um texto de boas-vindas, o colocaram no IPFS e adicionaram o endereço ao instalador.  Na minha opinião, isso é muito legal.  E esse arquivo (mais precisamente, a pasta inteira) agora pode ser exibido não apenas localmente, mas também no gateway oficial <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ipfs.io/ipfs/QmS4ustL54uo8FzR9455qaxZwuMiUhyvMcX9Ba8nUH4uVv</a> .  Ao mesmo tempo, você pode ter certeza de que o conteúdo da pasta não mudou de forma alguma, porque, se tivesse sido alterado, o hash também teria sido alterado. <br><br>  <i>A propósito, nesse caso, o IPFS tem algumas semelhanças com o servidor de controle de versão.</i>  <i>Se você fizer alterações nos arquivos de origem da pasta e despejar a pasta novamente no IPFS, ele receberá um novo endereço.</i>  <i>Ao mesmo tempo, a pasta antiga não irá a lugar nenhum e estará disponível no endereço anterior.</i> <br><br><h3>  Lançamento direto </h3><br><pre> <code class="plaintext hljs">ipfs daemon</code> </pre> <br>  Eles devem receber uma resposta como esta: <br><br><pre> <code class="plaintext hljs">ipfs daemon Initializing daemon... go-ipfs version: 0.4.22- Repo version: 7 System version: amd64/linux Golang version: go1.12.7 Swarm listening on /ip4/xxxx/tcp/4001 Swarm listening on /ip4/127.0.0.1/tcp/4001 Swarm listening on /ip6/::1/tcp/4001 Swarm listening on /p2p-circuit Swarm announcing /ip4/127.0.0.1/tcp/4001 Swarm announcing /ip6/::1/tcp/4001 API server listening on /ip4/127.0.0.1/tcp/5001 WebUI: http://127.0.0.1:5001/webui Gateway (readonly) server listening on /ip4/127.0.0.1/tcp/8080 Daemon is ready</code> </pre><br><h4>  Abrimos a porta para a Internet </h4><br>  Preste atenção a estas duas linhas: <br><br><pre> <code class="plaintext hljs">WebUI: http://127.0.0.1:5001/webui Gateway (readonly) server listening on /ip4/127.0.0.1/tcp/8080</code> </pre><br>  Agora, se você instalou o IPFS localmente, acessará as interfaces IPFS nos endereços locais e tudo estará disponível para você (por exemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">localhost</a> : 5001 / webui /).  Porém, quando instalados em um servidor externo, por padrão, os gateways são fechados para a Internet.  Existem dois gateways: <br><br><ol><li>  Admin webui ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">github</a> ) na porta 5001. </li><li>  API externa na porta 8080 (somente leitura). </li></ol><br>  Até o momento, é possível abrir as duas portas para experimentos (5001 e 8080), mas é claro que, no servidor de batalha, a porta 5001 deve ser fechada com um firewall.  Existem 4001 portas, é necessário para que outros pares possam encontrá-lo.  Deve ser deixado aberto para solicitações externas. <br><br>  Abra ~ / .ipfs / config para editar e encontre as seguintes linhas: <br><br><pre> <code class="plaintext hljs">"Addresses": { "Swarm": [ "/ip4/0.0.0.0/tcp/4001", "/ip6/::/tcp/4001" ], "Announce": [], "NoAnnounce": [], "API": "/ip4/127.0.0.1/tcp/5001", "Gateway": "/ip4/127.0.0.1/tcp/8080" }</code> </pre> <br>  Altere 127.0.0.1 para o ip do seu servidor, salve o arquivo e reinicie o ipfs (interrompa o comando Ctrl + C e execute novamente). <br><br>  Deve obter <br><br><pre> <code class="plaintext hljs">... WebUI: http://ip__:5001/webui Gateway (readonly) server listening on /ip4/ip__/tcp/8080</code> </pre><br>  Agora interfaces externas devem estar disponíveis. <br><br>  Confira <br><br><pre> <code class="plaintext hljs">http://__ip_:8080/ipfs/QmS4ustL54uo8FzR9455qaxZwuMiUhyvMcX9Ba8nUH4uVv/readme</code> </pre> <br>  O arquivo leia-me acima deve abrir. <br><br><pre> <code class="plaintext hljs">http://__ip_:5001/webui/</code> </pre> <br>  A interface da web deve abrir. <br><br>  <i>Se o webui funcionar para você, as configurações do IPFS poderão ser alteradas diretamente, incluindo estatísticas de exibição, mas abaixo considerarei as opções de configuração diretamente através do arquivo de configuração, o que geralmente não é crítico.</i>  <i>É melhor lembrar exatamente onde está a configuração e o que fazer com ela. Se o focinho da web não funcionar, será mais difícil.</i> <br><br><h3>  Configure uma interface da web para trabalhar com seu servidor </h3><br>  Aqui está a primeira armadilha, que foi gasta cerca de três horas. <br><br>  Se você instalou o IPFS em um servidor externo, mas não instalou ou iniciou o IPFS localmente, ao acessar / webui na interface da web, você verá um erro de conexão: <br><br><img src="https://habrastorage.org/webt/bp/l7/jj/bpl7jjxzunvmtl9ffvvkiwphmue.png"><br><br>  O fato é que o webui, na minha opinião, funciona de maneira muito ambígua.  Primeiro, ele tenta se conectar à API do servidor em que a interface está aberta (é claro, com base no endereço no navegador).  e se não funcionar lá, ele tentará se conectar ao gateway local.  E se você tiver o IPFS em execução localmente, seu webui funcionará bem, apenas você trabalhará com o IPFS local, não externo, embora tenha aberto o webui em um servidor externo.  Em seguida, faça o upload dos arquivos, mas, por algum motivo, você não os verá assim em um servidor externo ... <br><br>  E se não estiver sendo executado localmente, obteremos um erro de conexão.  No nosso caso, o erro provavelmente ocorre devido ao CORS, que também é indicado pelo webui, propondo adicionar uma configuração. <br><br><pre> <code class="plaintext hljs">ipfs config --json API.HTTPHeaders.Access-Control-Allow-Origin '["http://ip_ :5001", "http://127.0.0.1:5001", "https://webui.ipfs.io"]' ipfs config --json API.HTTPHeaders.Access-Control-Allow-Methods '["PUT", "GET", "POST"]'</code> </pre> <br>  Acabei de registrar um curinga <br><br><pre> <code class="plaintext hljs">ipfs config --json API.HTTPHeaders.Access-Control-Allow-Origin '["*"]'</code> </pre> <br>  Cabeçalhos adicionados podem ser encontrados no mesmo ~ / .ipfs / config.  No meu caso é <br><br><pre> <code class="plaintext hljs"> "API": { "HTTPHeaders": { "Access-Control-Allow-Origin": [ "*" ] } },</code> </pre><br>  Reiniciamos o ipfs e vemos que o webui foi conectado com êxito (pelo menos deveria se você abriu os gateways para solicitações externas, conforme descrito acima). <br><br>  Agora você pode fazer upload diretamente de pastas e arquivos através da interface da Web, bem como criar suas próprias pastas. <br><br><h3>  Monte o sistema de arquivos FUSE </h3><br>  Este é um truque bastante interessante. <br><br>  Podemos adicionar arquivos (e também pastas) não apenas através da interface da web, mas também diretamente no terminal, por exemplo <br><br><pre> <code class="plaintext hljs">ipfs add test -r added QmfYuz2gegRZNkDUDVLNa5DXzKmxxxxxxxxxx test/test.txt added QmbnzgRVAP4fL814h5mQttyqk1aURxxxxxxxxxxxx test</code> </pre><br>  O último hash é o hash da pasta raiz. <br><br>  Usando esse hash, podemos abrir a pasta em qualquer nó ipfs (que pode encontrar nosso nó e obter o conteúdo), podemos na interface da web na porta 5001 ou 8080 ou localmente através de ipfs. <br><br><pre> <code class="plaintext hljs">ipfs ls QmbnzgRVAP4fL814h5mQttyqk1aUxxxxxxxxxxxxx QmfYuz2gegRZNkDUDVLNa5DXzKmKVxxxxxxxxxxxxxx 10 test.txt</code> </pre><br>  Mas você ainda pode abri-lo como uma pasta normal. <br><br>  Vamos criar duas pastas na raiz e conceder direitos a nosso usuário. <br><br><pre> <code class="plaintext hljs">sudo mkdir /ipfs /ipns sudo chown USERNAME /ipfs /ipns</code> </pre><br>  e reinicie o ipfs com o sinalizador --mount <br><br><pre> <code class="plaintext hljs">ipfs daemon --mount</code> </pre> <br>  <i>Você pode criar pastas em outros lugares e especificar o caminho para elas através do daemon ipfs --mount --mount-ipfs / ipfs_path --mount-ipns / ipns_path</i> <br><br>  Agora a leitura desta pasta é um tanto incomum. <br><br><pre> <code class="plaintext hljs">ls -la /ipfs ls: reading directory '/ipfs': Operation not permitted total 0</code> </pre><br>  Ou seja, não há acesso direto à raiz desta pasta.  Mas então você pode obter o conteúdo, conhecendo o hash. <br><br><pre> <code class="plaintext hljs">ls -la /ipfs/QmbnzgRVAP4fL814h5mQttyqxxxxxxxxxxxxxxxxx total 0 -r--r--r-- 1 root root 10 Aug 31 07:03 test.txt</code> </pre><br><pre> <code class="plaintext hljs">cat /ipfs/QmbnzgRVAP4fL814h5mQttyqxxxxxxxxxxxxxxxxx/test.txt test test</code> </pre><br>  Além disso, até o preenchimento automático dentro da pasta funciona ao especificar um caminho. <br><br>  Como eu disse acima, existem sutilezas com essa montagem: por padrão, as pastas do FUSE montadas são acessíveis apenas ao usuário atual (mesmo o root não pode ler essa pasta, sem mencionar outros usuários no sistema).  Se você deseja tornar essas pastas acessíveis a outros usuários, na configuração, você precisa alterar “FuseAllowOther”: false para “FuseAllowOther”: true.  Mas isso não é tudo.  Se você executar o IPFS como root, tudo estará bem.  E se, em nome de um usuário comum (embora sudo), você receba um erro <br><br><pre> <code class="plaintext hljs">mount helper error: fusermount: option allow_other only allowed if 'user_allow_other' is set in /etc/fuse.conf</code> </pre> <br>  Nesse caso, você precisa corrigir o /etc/fuse.conf descomentando a linha #user_allow_other. <br><br>  Depois disso, reiniciaremos o ipfs. <br><br><h4>  Problemas conhecidos do FUSE </h4><br>  Mais de uma vez, o problema foi percebido que após reiniciar o ipfs com a montagem (ou talvez em outros casos), os pontos de montagem / ipfs e / ipns ficam indisponíveis.  Não há acesso a eles, mas ls -la / ipfs mostra ????  na lista de direitos. <br><br>  Encontrou uma solução: <br><br><pre> <code class="plaintext hljs">fusermount -z -u /ipfs fusermount -z -u /ipns</code> </pre> <br>  Então reinicie o ipfs. <br><br><h3>  Adicionar serviço </h3><br>  Obviamente, o lançamento no terminal é adequado apenas para testes primários.  No modo de combate, o daemon deve iniciar automaticamente quando o sistema iniciar. <br><br>  Em nome do sudo, crie o arquivo /etc/systemd/system/ipfs.service e escreva para ele: <br><br><pre> <code class="plaintext hljs">[Unit] Description=IPFS Daemon After=syslog.target network.target remote-fs.target nss-lookup.target [Service] Type=simple ExecStart=/home/USERNAME/work/bin/ipfs daemon --mount User=USERNAME Restart=always [Install] WantedBy=multi-user.target</code> </pre><br>  USERNAME, é claro, deve ser substituído pelo seu usuário (e talvez o caminho completo para o programa ipfs seja diferente para você (você deve especificar o caminho completo)). <br><br>  Ativamos o serviço. <br><br><pre> <code class="plaintext hljs">sudo systemctl enable ipfs.service</code> </pre> <br>  Iniciamos o serviço. <br><br><pre> <code class="plaintext hljs">sudo service ipfs start</code> </pre> <br>  Verifique o status do serviço. <br><br><pre> <code class="plaintext hljs">sudo service ipfs status</code> </pre> <br>  Para a pureza do experimento, será possível reiniciar o servidor no futuro para verificar se o ipfs é iniciado com êxito automaticamente. <br><br><h3>  Adicione as festas que conhecemos </h3><br>  Considere a situação em que temos nós IPFS instalados em um servidor externo e localmente.  Em um servidor externo, adicionamos algum tipo de arquivo e tentamos obtê-lo através do IPFS localmente pelo CID.  O que vai acontecer?  Obviamente, o servidor local provavelmente não sabe nada sobre o servidor externo e simplesmente tentará encontrar o arquivo pelo CID "pedindo" a todos os pares de IPFS disponíveis (com os quais ele já conseguiu "conhecer").  Esses, por sua vez, perguntarão aos outros.  E assim, até que o arquivo seja encontrado.  Na verdade, o mesmo acontece quando tentamos obter o arquivo através do gateway oficial <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ipfs.io.</a>  Se você tiver sorte, o arquivo será encontrado em alguns segundos.  E, se não, não será encontrado em alguns minutos, o que afeta muito o conforto do trabalho.  Mas sabemos onde esse arquivo aparecerá pela primeira vez.  Então, por que não informamos imediatamente ao servidor local "Olhe lá primeiro"?  Aparentemente, isso pode ser feito. <br><br>  1. Vá para o servidor remoto e procure por ~ / .ipfs / config na configuração <br><br><pre> <code class="plaintext hljs">"Identity": { "PeerID": "QmeCWX1DD7HnPSuMHZSh6tFuxxxxxxxxxxxxxxxx",</code> </pre><br>  2. Executamos o status de ipfs do serviço sudo e procuramos entradas do Swarm, por exemplo: <br><br><pre> <code class="plaintext hljs">Swarm announcing /ip4/ip__/tcp/4001</code> </pre> <br>  3. A partir disso, adicionamos o endereço geral no formato "/ ip4 / ip_seu_servidor / tcp / 4001 / ipfs / $ PeerID". <br><br>  4. Para confiabilidade, através do nosso webui local, tentaremos adicionar esse endereço aos pares. <br><br><img src="https://habrastorage.org/webt/g5/y2/oh/g5y2ohfylmp2be51tzh0iohq1y8.png"><br><br>  5. Se estiver tudo bem, abra a configuração local ~ / .ipfs / config, encontre "Bootstrap" nela: [... <br>  e adicione o endereço recebido primeiro à matriz. <br><br>  Reinicie o IPFS. <br><br>  Agora adicione o arquivo ao servidor externo e tente solicitá-lo no local.  Deve voar rápido. <br><br>  Mas essa funcionalidade ainda é instável.  Pelo que entendi, mesmo se especificarmos o endereço de ponto no Bootstrap, no decorrer do trabalho, o ipfs altera a lista de conexões ativas com os pares.  De qualquer forma, uma discussão sobre isso e seus desejos sobre a possibilidade de indicar pares constantes está sendo realizada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> e parece <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">que deve</a> adicionar alguma funcionalidade a ipfs@5.0+ <br><br>  Uma lista dos pares atuais pode ser visualizada no webui e no terminal. <br><br><pre> <code class="plaintext hljs">ipfs swarm peers</code> </pre> <br>  Lá e lá, você pode adicionar seu banquete manualmente. <br><br><pre> <code class="plaintext hljs">ipfs swarm connect "/ip4/ip__/tcp/4001/ipfs/$PeerID"</code> </pre> <br>  Até que você melhore essa funcionalidade, você pode escrever uma ferramenta para verificar se há uma conexão com o par desejado e, se não, adicionar uma conexão. <br><br><h2>  Raciocínio </h2><br>  Entre aqueles que já conhecem o IPFS, há argumentos a favor e contra o IPFS.  Em princípio, o dia antes da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">discussão</a> de ontem me levou a cavar o IPFS novamente.  E com relação à discussão mencionada acima: não posso dizer que sou totalmente contra alguns dos argumentos acima expressos (discordo apenas do fato de que um programa e meio programadores usam IPFS).  Em geral, os dois têm a sua maneira (especialmente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">comentários sobre cheques</a> fazem você pensar).  Mas se você deixar de lado a avaliação moral e legal, quem fará uma avaliação técnica dessa tecnologia?  Pessoalmente, tenho algum tipo de sentimento interior de que "isso é necessário, com certeza, tem certas perspectivas".  Mas por que exatamente, não há uma redação clara?  Como se você olhar para as ferramentas centralizadas existentes, em muitos aspectos elas estão muito à frente (estabilidade, velocidade, capacidade de gerenciamento, etc.).  No entanto, tenho um pensamento que parece fazer sentido e que dificilmente pode ser implementado sem esses sistemas descentralizados.  É claro que realmente mudo de idéia, mas a formularia da seguinte maneira: o princípio de disseminar informações na Internet precisa ser alterado. <br><br>  Eu vou explicar  Se você pensa assim, agora nossas informações são disseminadas com o princípio "Espero que a pessoa para quem eu as transferi as proteja e não sejam perdidas ou recebidas por aqueles a quem não foram destinadas".  Por exemplo, é fácil considerar vários serviços de correio, armazenamento em nuvem etc.  E o que temos no final?  No Habré Hub, a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Segurança da informação está</a> na primeira linha e quase todos os dias recebemos notícias sobre outro vazamento global.  Em princípio, tudo o mais interessante está listado no artigo &lt;irony&gt; wonderful &lt;/ irony&gt; O <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">verão está quase no fim.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Quase nenhum dado vazou</a> .  Ou seja, os principais gigantes da Internet estão se tornando maiores, estão acumulando cada vez mais informações, e esses vazamentos são uma espécie de explosões atômicas informacionais.  Isso nunca aconteceu, e aqui novamente.  Ao mesmo tempo, embora muitos entendam que existem riscos, eles continuarão a confiar em seus dados com empresas de terceiros.  Em primeiro lugar, não há muita alternativa; em segundo lugar, eles prometem corrigir todos os buracos e isso nunca mais acontecerá. <br><br>  Que opção eu vejo?  Parece-me que os dados devem ser inicialmente distribuídos abertamente.  Mas abertura neste caso não significa que tudo deve ser fácil de ler.  Estou falando da abertura de armazenamento e distribuição, mas não da abertura total na leitura.  Presumo que as informações devem ser distribuídas com chaves públicas.  Afinal, o princípio das chaves públicas / privadas já é antigo, quase como a Internet.  Se a informação não é confidencial e foi projetada para uma ampla variedade, ela é apresentada imediatamente com a chave pública (mas ainda na forma criptografada, qualquer pessoa pode descriptografá-la com a chave existente).  E, se não, é apresentada sem uma chave pública, e a própria chave é transmitida àquele que deve ter acesso a essas informações.  Ao mesmo tempo, quem precisa lê-lo deve ter apenas uma chave e, onde obter essas informações, não deve pairar realmente - ele apenas as extrai da rede (esse é o novo princípio de distribuição para o conteúdo e não para o endereço). <br><br>  Assim, para um ataque em massa, os invasores precisarão obter um grande número de chaves privadas, e é improvável que eles possam fazer isso em um só lugar.  Essa tarefa, a meu ver, é mais difícil do que invadir um serviço específico. <br><br>  E aqui outro problema se fecha: confirmação de autoria.  Agora, na Internet, você pode encontrar muitas citações escritas por nossos amigos.  Mas onde está a garantia de que eles os escreveram?  Agora, se cada uma dessas gravações fosse acompanhada por uma assinatura digital, seria muito mais simples.  E não importa onde estejam essas informações, o principal é a assinatura, que, obviamente, é difícil de falsificar. <br><br>  E aqui está o que é interessante aqui: o IPFS já possui ferramentas de criptografia (afinal, ele é construído sobre a tecnologia blockchain).  A chave privada é especificada imediatamente na configuração. <br><br><pre> <code class="plaintext hljs"> "Identity": { "PeerID": "QmeCWX1DD7HnPSuMHZSh6tFuMxxxxxxxxxxxxxx", "PrivKey": "CAASqAkwggSkAgEAAoIBAQClZedVmj8JkPvT92sGrNIQmofVF3ne8xSWZIGqkm+t9IHNN+/NDI51jA0MRzpBviM3o/c/Nuz30wo95vWToNyWzJlyAISXnUHxnVhvpeJAbaeggQRcFxO9ujO9DH61aqgN1m+JoEplHjtc4KS5 pUEDqamve+xAJO8BWt/LgeRKA70JN4hlsRSghRqNFFwjeuBkT1kB6tZsG3YmvAXJ0o2uye+y+7LMS7jKpwJNJBiFAa/Kuyu3W6PrdOe7SqrXfjOLHQ0uX1oYfcqFIKQsBNj/Fb+GJMiciJUZaAjgHoaZrrf2b/Eii3z0i+QIVG7OypXT3Z9JUS60 KKLfjtJ0nVLjAgMBAAECggEAZqSR5sbdffNSxN2TtsXDa3hq+WwjPp/908M10QQleH/3mcKv98FmGz65zjfZyHjV5C7GPp24e6elgHr3RhGbM55vT5dQscJu7SGng0of2bnzQCEw8nGD18dZWmYJsE4rUsMT3wXxhUU4s8/Zijgq27oLyxKNr9T7 2gxqPCI06VTfMiCL1wBBUP1wHdFmD/YLJwOjV/sVzbsl9HxqzgzlDtfMn/bJodcURFI1sf1e6WO+MyTc3.................</code> + / NDI51jA0MRzpBviM3o / c / Nuz30wo95vWToNyWzJlyAISXnUHxnVhvpeJAbaeggQRcFxO9ujO9DH61aqgN1m + JoEplHjtc4KS5 <code class="plaintext hljs"> "Identity": { "PeerID": "QmeCWX1DD7HnPSuMHZSh6tFuMxxxxxxxxxxxxxx", "PrivKey": "CAASqAkwggSkAgEAAoIBAQClZedVmj8JkPvT92sGrNIQmofVF3ne8xSWZIGqkm+t9IHNN+/NDI51jA0MRzpBviM3o/c/Nuz30wo95vWToNyWzJlyAISXnUHxnVhvpeJAbaeggQRcFxO9ujO9DH61aqgN1m+JoEplHjtc4KS5 pUEDqamve+xAJO8BWt/LgeRKA70JN4hlsRSghRqNFFwjeuBkT1kB6tZsG3YmvAXJ0o2uye+y+7LMS7jKpwJNJBiFAa/Kuyu3W6PrdOe7SqrXfjOLHQ0uX1oYfcqFIKQsBNj/Fb+GJMiciJUZaAjgHoaZrrf2b/Eii3z0i+QIVG7OypXT3Z9JUS60 KKLfjtJ0nVLjAgMBAAECggEAZqSR5sbdffNSxN2TtsXDa3hq+WwjPp/908M10QQleH/3mcKv98FmGz65zjfZyHjV5C7GPp24e6elgHr3RhGbM55vT5dQscJu7SGng0of2bnzQCEw8nGD18dZWmYJsE4rUsMT3wXxhUU4s8/Zijgq27oLyxKNr9T7 2gxqPCI06VTfMiCL1wBBUP1wHdFmD/YLJwOjV/sVzbsl9HxqzgzlDtfMn/bJodcURFI1sf1e6WO+MyTc3.................</code> 7LMS7jKpwJNJBiFAa / Kuyu3W6PrdOe7SqrXfjOLHQ0uX1oYfcqFIKQsBNj / Fb + GJMiciJUZaAjgHoaZrrf2b / Eii3z0i + QIVG7OypXT3Z9JUS60 <code class="plaintext hljs"> "Identity": { "PeerID": "QmeCWX1DD7HnPSuMHZSh6tFuMxxxxxxxxxxxxxx", "PrivKey": "CAASqAkwggSkAgEAAoIBAQClZedVmj8JkPvT92sGrNIQmofVF3ne8xSWZIGqkm+t9IHNN+/NDI51jA0MRzpBviM3o/c/Nuz30wo95vWToNyWzJlyAISXnUHxnVhvpeJAbaeggQRcFxO9ujO9DH61aqgN1m+JoEplHjtc4KS5 pUEDqamve+xAJO8BWt/LgeRKA70JN4hlsRSghRqNFFwjeuBkT1kB6tZsG3YmvAXJ0o2uye+y+7LMS7jKpwJNJBiFAa/Kuyu3W6PrdOe7SqrXfjOLHQ0uX1oYfcqFIKQsBNj/Fb+GJMiciJUZaAjgHoaZrrf2b/Eii3z0i+QIVG7OypXT3Z9JUS60 KKLfjtJ0nVLjAgMBAAECggEAZqSR5sbdffNSxN2TtsXDa3hq+WwjPp/908M10QQleH/3mcKv98FmGz65zjfZyHjV5C7GPp24e6elgHr3RhGbM55vT5dQscJu7SGng0of2bnzQCEw8nGD18dZWmYJsE4rUsMT3wXxhUU4s8/Zijgq27oLyxKNr9T7 2gxqPCI06VTfMiCL1wBBUP1wHdFmD/YLJwOjV/sVzbsl9HxqzgzlDtfMn/bJodcURFI1sf1e6WO+MyTc3.................</code> Zijgq27oLyxKNr9T7 <code class="plaintext hljs"> "Identity": { "PeerID": "QmeCWX1DD7HnPSuMHZSh6tFuMxxxxxxxxxxxxxx", "PrivKey": "CAASqAkwggSkAgEAAoIBAQClZedVmj8JkPvT92sGrNIQmofVF3ne8xSWZIGqkm+t9IHNN+/NDI51jA0MRzpBviM3o/c/Nuz30wo95vWToNyWzJlyAISXnUHxnVhvpeJAbaeggQRcFxO9ujO9DH61aqgN1m+JoEplHjtc4KS5 pUEDqamve+xAJO8BWt/LgeRKA70JN4hlsRSghRqNFFwjeuBkT1kB6tZsG3YmvAXJ0o2uye+y+7LMS7jKpwJNJBiFAa/Kuyu3W6PrdOe7SqrXfjOLHQ0uX1oYfcqFIKQsBNj/Fb+GJMiciJUZaAjgHoaZrrf2b/Eii3z0i+QIVG7OypXT3Z9JUS60 KKLfjtJ0nVLjAgMBAAECggEAZqSR5sbdffNSxN2TtsXDa3hq+WwjPp/908M10QQleH/3mcKv98FmGz65zjfZyHjV5C7GPp24e6elgHr3RhGbM55vT5dQscJu7SGng0of2bnzQCEw8nGD18dZWmYJsE4rUsMT3wXxhUU4s8/Zijgq27oLyxKNr9T7 2gxqPCI06VTfMiCL1wBBUP1wHdFmD/YLJwOjV/sVzbsl9HxqzgzlDtfMn/bJodcURFI1sf1e6WO+MyTc3.................</code> </pre> <br>  Não sou especialista em segurança e não sei exatamente como usá-lo corretamente, mas parece-me que essas chaves são usadas no nível de troca entre nós IPFS.  E também <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">js-ipfs</a> e projetos de exemplo como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">orbit-db</a> , nos quais o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">orbit.chat</a> funciona.  Ou seja, teoricamente, cada dispositivo (móvel e não apenas) pode ser facilmente equipado com suas próprias máquinas de criptografia e descriptografia.  Nesse caso, resta apenas a todos cuidar de manter suas chaves privadas e todos serão responsáveis ​​por sua própria segurança, e não serão reféns de outro fator humano em algum gigante da Internet super popular. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt465599/">https://habr.com/ru/post/pt465599/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt465587/index.html">Análise: qual é o mercado de balcão e quais transações são feitas lá</a></li>
<li><a href="../pt465589/index.html">Guia de Iniciação Rápida ao Piloto e ao PoC</a></li>
<li><a href="../pt465591/index.html">Conferência do PHP Central Europe cancelada devido ao fato de não haver mulheres entre os oradores</a></li>
<li><a href="../pt465595/index.html">5G chega até nós?</a></li>
<li><a href="../pt465597/index.html">Aprendendo STM8S Slow Start. Parte 0</a></li>
<li><a href="../pt465601/index.html">Por que você precisa do DevOps e que são especialistas em DevOps</a></li>
<li><a href="../pt465603/index.html">Cursos vs estágio. Como ensinamos midbells na SimbirSoft</a></li>
<li><a href="../pt465605/index.html">O livro “Aprendizado por reforço profundo em Python. Ginásio OpenAI e TensorFlow para profissionais »</a></li>
<li><a href="../pt465607/index.html">Entendendo Lean e Agile no desenvolvimento de software</a></li>
<li><a href="../pt465609/index.html">Por que o 1C-Bitrix de 1 de dezembro de 2019 pode se transformar em uma abóbora</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>