<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕝 👩🏼‍💼 🎢 Erfahrung in der Entwicklung des Refund Tool-Dienstes mit einer asynchronen API auf Kafka 🚴🏾 👩🏽‍🎤 🚏</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Was kann ein großes Unternehmen wie Lamoda mit einem optimierten Prozess und Dutzenden miteinander verbundener Dienste dazu bringen, den Ansatz erhebl...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Erfahrung in der Entwicklung des Refund Tool-Dienstes mit einer asynchronen API auf Kafka</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/445424/"> Was kann ein großes Unternehmen wie Lamoda mit einem optimierten Prozess und Dutzenden miteinander verbundener Dienste dazu bringen, den Ansatz erheblich zu ändern?  Die Motivation kann völlig anders sein: von der Gesetzgebung bis zum Wunsch aller Programmierer, zu experimentieren. <br><br>  Dies bedeutet jedoch keineswegs, dass man nicht mit zusätzlichen Vorteilen rechnen kann.  Was genau gewonnen werden kann, wenn Sie die ereignisgesteuerte API auf Kafka implementieren, wird Sergey Zaika ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Fewald</a> ) sagen.  Auch über ausgestopfte Beulen und interessante Entdeckungen wird es sicherlich geben - ein Experiment kann nicht ohne sie auskommen. <br><br><img src="https://habrastorage.org/webt/kq/o2/ye/kqo2yemmmu-wiqi9vtpcrbolroq.png"><br><br>  <em>Haftungsausschluss: Dieser Artikel basiert auf den Materialien des Mitaps, den Sergey im November 2018 auf HighLoad ++ gehalten hat.</em>  <em>Lamodas Live-Erfahrung mit Kafka zog die Zuhörer nicht weniger an als andere Zeitplanberichte.</em>  <em>Es scheint uns, dass dies ein großartiges Beispiel dafür ist, dass es immer möglich und notwendig ist, Gleichgesinnte zu finden, und die Organisatoren von HighLoad ++ werden weiterhin versuchen, eine Atmosphäre zu schaffen, die dies fördert.</em> <br><a name="habracut"></a><br><h2>  Über den Prozess </h2><br>  Lamoda ist eine große E-Commerce-Plattform, die über ein eigenes Contact Center, einen Lieferservice (und viele verbundene Unternehmen), ein Fotostudio, ein riesiges Lager und alles verfügt, was mit ihrer Software funktioniert.  Es gibt Dutzende von Zahlungsmethoden, B2B-Partner, die einen Teil oder alle dieser Dienste nutzen können und die neuesten Informationen zu ihren Produkten erhalten möchten.  Darüber hinaus ist Lamoda neben der Russischen Föderation in drei Ländern tätig, und dort ist alles etwas anders.  Insgesamt gibt es wahrscheinlich mehr als hundert Möglichkeiten, eine neue Bestellung zu konfigurieren, die auf ihre eigene Weise verarbeitet werden muss.  All dies funktioniert mit Hilfe von Dutzenden von Diensten, die manchmal auf nicht offensichtliche Weise kommunizieren.  Es gibt auch ein zentrales System, dessen Hauptverantwortung der Status von Bestellungen ist.  Wir nennen sie BOB, ich arbeite mit ihr. <br><br><h2>  Refund Tool mit ereignisgesteuerter API </h2><br>  Das Wort ereignisgesteuert ist ziemlich abgedroschen, ein wenig weiter werden wir genauer definieren, was damit gemeint ist.  Ich beginne mit dem Kontext, in dem wir beschlossen haben, den ereignisgesteuerten Kafka-API-Ansatz auszuprobieren. <br><br><img src="https://habrastorage.org/webt/8y/0i/kp/8y0ikp8ebxzglwhw1s-dhrubivw.png"><br><br>  In jedem Geschäft gibt es zusätzlich zu Bestellungen, für die Kunden bezahlen, Zeiten, in denen das Geschäft Geld zurückgeben muss, weil das Produkt nicht zum Kunden passt.  Dieser relativ kurze Prozess: Wir klären die Informationen, wenn ein solcher Bedarf besteht, und überweisen das Geld. <br><br>  Die Rückgabe war jedoch aufgrund von Gesetzesänderungen kompliziert, und wir mussten einen separaten Mikroservice dafür implementieren. <br><br><img src="https://habrastorage.org/webt/nn/_x/xr/nn_xxr2xlqfpn-kmgc5y4rzj9a8.png"><br><br>  Unsere Motivation: <br><br><ol><li>  <strong>Gesetz FZ-54</strong> - Kurz gesagt, das Gesetz schreibt vor, dass Sie dem Finanzamt in wenigen Minuten jede Geldtransaktion, sei es eine Rückgabe oder eine Quittung, in einem relativ kurzen SLA melden müssen.  Wir als E-Commerce führen einige Operationen durch.  Technisch bedeutet dies eine neue Verantwortung (und damit einen neuen Service) und Verbesserungen in allen beteiligten Systemen. </li><li>  <strong>BOB-Split</strong> - das unternehmensinterne Projekt, um BOB von einer Vielzahl von nicht zum Kerngeschäft gehörenden Aufgaben zu befreien und die Gesamtkomplexität zu verringern. </li></ol><br><img src="https://habrastorage.org/webt/u7/k8/7x/u7k87xo4jzxcjmoeanxdzhy_yag.png"><br><br>  Dieses Diagramm zeigt die wichtigsten Lamoda-Systeme.  Jetzt ähneln die meisten eher einer <strong>Konstellation von 5-10 Mikrodiensten um einen abnehmenden Monolithen</strong> .  Sie wachsen langsam, aber wir versuchen, sie kleiner zu machen, weil es beängstigend ist, das in der Mitte hervorgehobene Fragment einzusetzen - es darf nicht fallen.  Alle Börsen (Pfeile) sind wir gezwungen zu reservieren und darauf zu setzen, dass einer von ihnen möglicherweise nicht verfügbar ist. <br><br>  Es gibt auch ziemlich viele Börsen in BOB: Zahlung, Lieferung, Benachrichtigungssysteme usw. <br><br>  Technisch gesehen ist BOB: <br><br><ul><li>  ~ 150.000 Codezeilen + ~ 100.000 Testzeilen; </li><li>  php7.2 + Zend 1 &amp; Symfony Components 3; </li><li>  &gt; 100 API &amp; ~ 50 ausgehende Integrationen; </li><li>  4 Länder mit eigener Geschäftslogik. </li></ul><br>  Die Bereitstellung von BOB ist teuer und schmerzhaft. Die Menge an Code und die damit verbundenen Aufgaben sind so, dass niemand sie in den Kopf bekommen kann.  Im Allgemeinen gibt es viele Gründe, dies zu vereinfachen. <br><br><h2>  Rückgabeprozess </h2><br>  Zunächst sind zwei Systeme in den Prozess involviert: BOB und Payment.  Nun erscheinen zwei weitere: <br><br><ul><li>  Fiscalization Service, der sich um Probleme bei der Fiskalisierung und der Kommunikation mit externen Diensten kümmert. </li><li>  Rückerstattungstool, in das neue Börsen einfach herausgenommen werden, um das BOB nicht aufzublasen. </li></ul><br>  Jetzt sieht der Prozess so aus: <br><br><img src="https://habrastorage.org/webt/pe/e6/0q/pee60qj1tdefewqgdaw22bww-ag.png"><br><br><ol><li>  BOB erhält eine Rückerstattungsanfrage. </li><li>  BOB spricht über dieses Rückerstattungstool. </li><li>  Das Rückerstattungstool sagt Zahlung: "Holen Sie sich das Geld zurück." </li><li>  Die Zahlung gibt das Geld zurück. </li><li>  Das Refund Tool und BOB synchronisieren die Status miteinander, da beide sie vorerst benötigen.  Wir sind noch nicht bereit, vollständig auf das Rückerstattungstool umzusteigen, da BOB über eine Benutzeroberfläche, Berichte für die Buchhaltung und im Allgemeinen viele Daten verfügt, die Sie nicht einfach übertragen können.  Wir müssen auf zwei Stühlen sitzen. </li><li>  Der Fiskalisierungsantrag geht. </li></ol><br>  Als Ergebnis haben wir auf Kafka eine Art Eventbus gebaut - einen Eventbus, mit dem alles begann.  Hurra, jetzt haben wir einen einzigen Fehlerpunkt (Sarkasmus). <br><br><img src="https://habrastorage.org/webt/8k/zg/qc/8kzgqcfju7ybv8imzajjjykpz10.png"><br><br>  Die Vor- und Nachteile liegen auf der Hand.  Wir haben einen Bus gebaut, daher hängen jetzt alle Dienste davon ab.  Dies vereinfacht das Design, führt jedoch einen einzelnen Fehlerpunkt in das System ein.  Kafka wird fallen, der Prozess wird steigen. <br><br><h2>  Was ist eine ereignisgesteuerte API? </h2><br>  Eine gute Antwort auf diese Frage findet sich in dem Bericht von Martin Fowler (GOTO 2017) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Die vielen Bedeutungen ereignisgesteuerter Architektur"</a> . <br><br>  Kurz gesagt, was wir getan haben: <br><br><ol><li>  Alle asynchronen Austausche wurden über den <strong>Ereignisspeicher abgeschlossen</strong> .  Anstatt jeden interessierten Verbraucher über das Netzwerk über die Statusänderung zu informieren, schreiben wir ein Statusänderungsereignis in das zentrale Repository, und Verbraucher, die an dem Thema interessiert sind, lesen alles, was von dort aus angezeigt wird. </li><li>  Ein Ereignis in diesem Fall ist eine Benachrichtigung ( <strong>Benachrichtigungen</strong> ), dass sich irgendwo etwas geändert hat.  Beispielsweise hat sich der Bestellstatus geändert.  Ein Verbraucher, der an Daten interessiert ist, die mit der Statusänderung einhergehen, und die nicht in der Benachrichtigung enthalten sind, kann seinen Status selbst herausfinden. </li><li>  Die maximale Option ist eine vollständige Ereignisbeschaffung, Statusübertragung, bei der das Ereignis alle für die Verarbeitung erforderlichen Informationen enthält: von wo und zu welchem ​​Status haben Sie gewechselt, wie genau haben sich die Daten geändert usw. Die einzige Frage ist, ob es sich lohnt und wie viele Informationen Sie sich leisten können, um sie zu speichern. </li></ol><br>  Im Rahmen des Starts des Refund-Tools haben wir die dritte Option verwendet.  Dies vereinfachte die Verarbeitung von Ereignissen, da keine detaillierten Informationen eingeholt werden mussten, und schloss das Szenario aus, in dem jedes neue Ereignis eine Flut von Klärungsanfragen von Verbrauchern erzeugt. <br><br>  Der Refund Tool Service ist <strong>nicht geladen</strong> , daher ist Kafka dort eher ein Pen-Test als eine Notwendigkeit.  Ich glaube nicht, dass das Unternehmen glücklich wäre, wenn der Rückerstattungsservice zu einem Hochlastprojekt würde. <br><br><h4>  Asynchroner Austausch wie besehen </h4><br>  Für den asynchronen Austausch verwendet die PHP-Abteilung normalerweise RabbitMQ.  Wir haben die Daten für die Anfrage gesammelt, in die Warteschlange gestellt, und der Verbraucher desselben Dienstes hat sie gelesen und gesendet (oder nicht gesendet).  Für die API selbst verwendet Lamoda aktiv Swagger.  Wir entwerfen die API, beschreiben sie in Swagger, generieren Client- und Servercode.  Wir verwenden auch einen leicht fortgeschrittenen JSON RPC 2.0. <br><br>  Hier und da werden esb-Busse verwendet, jemand lebt von activeMQ, aber im Allgemeinen ist <strong>RabbitMQ der Standard</strong> . <br><br><h4>  Async Austausch zu sein </h4><br>  Beim Entwerfen eines Austauschs über den Ereignisbus wird eine Analogie verfolgt.  In ähnlicher Weise beschreiben wir den zukünftigen Datenaustausch durch Ereignisstrukturbeschreibungen.  Das Yaml-Format, die Codegenerierung musste von uns selbst durchgeführt werden, der Generator erstellt das DTO gemäß der Spezifikation und bringt Clients und Servern bei, wie man mit ihnen arbeitet.  Die Generation geht in zwei Sprachen - <strong>Golang und PHP</strong> .  Dies hält die Bibliotheken konsistent.  Der Generator ist in Golang geschrieben, für den er den Namen Gogi erhielt. <br><br>  Event-Sourcing bei Kafka ist eine typische Sache.  Es gibt eine Lösung aus der Hauptunternehmensversion von Kafka Confluent, es gibt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nakadi</a> , eine Lösung aus unseren "Brüdern" im Bereich der Zalando-Domain.  Unsere <strong>Motivation, mit Vanilla Kafka zu beginnen,</strong> besteht darin, die Lösung frei zu lassen, bis wir schließlich entscheiden, ob wir sie überall verwenden möchten, und auch Raum für Manöver und Verbesserungen zu lassen: Wir möchten Unterstützung für unseren <strong>JSON RPC 2.0</strong> , Generatoren für zwei Sprachen, und sehen, was noch alles. <br><br>  Es ist ironisch, dass wir selbst in einem so glücklichen Fall, wenn es ein ähnliches Geschäft wie Zalando gibt, das eine ähnliche Entscheidung getroffen hat, es nicht effektiv nutzen können. <br><br>  Architektonisch ist das Muster beim Start wie folgt: Lesen Sie direkt von Kafka, aber schreiben Sie nur über den Ereignisbus.  In Kafka gibt es viel zu lesen: Broker, Balancer und es ist mehr oder weniger bereit für horizontale Skalierung, ich wollte es behalten.  Die Aufzeichnung wollten wir durch einen Gateway alias Events-Bus wickeln, und deshalb. <br><br><h3>  Veranstaltungsbus </h3><br>  Oder ein Eventbus.  Dies ist nur ein zustandsloses http-Gateway, das mehrere wichtige Rollen übernimmt: <br><br><ul><li>  <strong>Validierung der Produktion</strong> - Wir überprüfen, ob die Ereignisse unserer Spezifikation entsprechen. </li><li>  <strong>Ein Event-Master-System</strong> , dh es ist das wichtigste und einzige System im Unternehmen, das die Frage beantwortet, welche Events mit welchen Strukturen als gültig angesehen werden.  Die Validierung umfasst lediglich Datentypen und Aufzählungen für eine strikte Spezifikation des Inhalts. </li><li>  <strong>Die</strong> Hash- <strong>Funktion</strong> für das Sharding - die Nachrichtenstruktur von Kafka ist der Schlüsselwert, und hier wird sie durch den Hash vom Schlüssel berechnet, wo er abgelegt werden soll. </li></ul><br><h3>  Warum </h3><br>  Wir arbeiten in einem großen Unternehmen mit einem optimierten Prozess.  Warum etwas ändern?  <strong>Dies ist ein Experiment</strong> , und wir erwarten mehrere Vorteile. <br><br><h4>  1: n + 1 Austausch (eins zu viele) </h4><br>  Mit Kafka ist es sehr einfach, neue Verbraucher mit der API zu verbinden. <br><br>  Angenommen, Sie haben ein Verzeichnis, das in mehreren Systemen gleichzeitig (und in einigen neuen) auf dem neuesten Stand gehalten werden muss.  Zuvor haben wir ein Bundle erfunden, das eine Set-API implementiert hat, und Verbraucheradressen wurden an das Mastersystem gemeldet.  Jetzt sendet das Mastersystem Aktualisierungen zum Thema und zu allen, die am Lesen interessiert sind.  Ein neues System ist erschienen - sie haben es zu diesem Thema unterschrieben.  Ja, auch bündeln, aber einfacher. <br><br>  Im Fall des Rückerstattungs-Tools, bei dem es sich um ein Stück BOB handelt, ist es für uns praktisch, sie über Kafka synchron zu halten.  Die Zahlung besagt, dass sie das Geld zurückgegeben haben: BOB, RT hat davon erfahren, ihren Status geändert, Fiscalization Service hat davon erfahren und einen Scheck ausgeknockt. <br><br><img src="https://habrastorage.org/webt/x1/rs/gx/x1rsgx9mbceqzstdmcsg_hapnbs.png"><br><br>  Wir haben vor, einen einzigen Benachrichtigungsservice einzurichten, der den Kunden über die Neuigkeiten zu seiner Bestellung / Rücksendung informiert.  Jetzt ist diese Verantwortung auf die Systeme verteilt.  Es reicht aus, wenn wir dem Benachrichtigungsdienst beibringen, relevante Informationen von Kafka abzufangen und darauf zu reagieren (und diese Benachrichtigungen in anderen Systemen zu deaktivieren).  Es ist kein neuer direkter Austausch erforderlich. <br><br><h4>  Datengesteuert </h4><br>  Informationen zwischen Systemen werden transparent - egal wie blutig Ihr Unternehmen ist und wie geschwollen Ihr Rückstand ist.  Lamoda verfügt über eine Data Analytics-Abteilung, die Daten zu Systemen sammelt und in eine wiederverwendbare Form bringt, sowohl für Unternehmen als auch für intelligente Systeme.  Mit Kafka können Sie ihnen schnell viele Daten geben und diesen Informationsfluss auf dem neuesten Stand halten. <br><br><h4>  Replikationsprotokoll </h4><br>  Nachrichten verschwinden nach dem Lesen nicht wie in RabbitMQ.  Wenn das Ereignis genügend Informationen für die Verarbeitung enthält, haben wir einen Verlauf der letzten Änderungen am Objekt und, falls gewünscht, die Möglichkeit, diese Änderungen anzuwenden. <br><br>  Die Speicherdauer des Replikationsprotokolls hängt von der Intensität des Schreibens in dieses Thema ab. Mit Kafka können Sie die Speicherzeit und das Datenvolumen flexibel begrenzen.  Bei intensiven Themen ist es wichtig, dass alle Verbraucher Zeit haben, Informationen zu lesen, bevor sie verschwinden, auch bei kurzfristiger Inoperabilität.  Normalerweise werden Daten für Tageseinheiten gespeichert, was für den Support völlig ausreicht. <br><br><img src="https://habrastorage.org/webt/xz/6-/59/xz6-59a1z7vrszrmoowvswxauqc.png"><br><br>  Dann eine kleine Nacherzählung der Dokumentation für diejenigen, die mit Kafka nicht vertraut sind (das Bild stammt auch aus der Dokumentation) <br><br>  In AMQP gibt es Warteschlangen: Wir schreiben Nachrichten für den Verbraucher in die Warteschlange.  In der Regel wird eine Warteschlange von einem System mit derselben Geschäftslogik verarbeitet.  Wenn Sie mehrere Systeme benachrichtigen müssen, können Sie der Anwendung das Schreiben in mehrere Warteschlangen beibringen oder den Austausch mit dem Fanout-Mechanismus konfigurieren, der sie selbst klont. <br><br>  Kafka hat eine ähnliche <em>Themenabstraktion,</em> in der Sie Nachrichten schreiben, die jedoch nach dem Lesen nicht verschwinden.  Wenn Sie eine Verbindung zu Kafka herstellen, erhalten Sie standardmäßig alle Nachrichten, und gleichzeitig besteht die Möglichkeit, den Ort zu speichern, an dem Sie aufgehört haben.  Das heißt, Sie lesen nacheinander, Sie können die Nachricht nicht als gelesen markieren, sondern die ID speichern, von der aus Sie dann weiterlesen.  Die ID, bei der Sie anhalten, heißt Offset, und der Mechanismus ist Commit-Offset. <br><br>  Dementsprechend kann eine andere Logik implementiert werden.  Zum Beispiel haben wir BOB in 4 Fällen für verschiedene Länder - Lamoda ist in Russland, Kasachstan, der Ukraine, Weißrussland.  Da sie separat bereitgestellt werden, haben sie ein wenig ihre eigenen Konfigurationen und ihre eigene Geschäftslogik.  In der Nachricht geben wir an, auf welches Land es sich bezieht.  Jeder BOB-Verbraucher in jedem Land liest mit einer anderen Gruppen-ID. Wenn die Nachricht nicht auf ihn zutrifft, überspringen Sie sie, d. H.  Sofort Offset +1 festschreiben.  Wenn dasselbe Thema von unserem Zahlungsservice gelesen wird, erfolgt dies mit einer separaten Gruppe, und daher überschneiden sich die Offsets nicht. <br><br>  <b>Veranstaltungsvoraussetzungen:</b> <br><br><ul><li>  <strong>Vollständigkeit der Daten.</strong>  Ich wünschte, es wären genügend Daten in der Veranstaltung vorhanden, damit sie verarbeitet werden könnten. </li></ul><br><ul><li>  <strong>Integrität</strong>  Wir delegieren den Events-Bus, um zu überprüfen, ob das Event konsistent ist und es verarbeiten kann. </li><li>  <strong>Ordnung ist wichtig.</strong>  Im Falle einer Rückkehr sind wir gezwungen, mit der Geschichte zu arbeiten.  Bei Benachrichtigungen ist die Bestellung nicht wichtig. Wenn es sich um homogene Benachrichtigungen handelt, ist die E-Mail dieselbe, unabhängig davon, welche Bestellung zuerst eingegangen ist.  Im Falle einer Rücksendung gibt es einen klaren Prozess. Wenn Sie die Bestellung ändern, gibt es Ausnahmen, die Rückerstattung wird nicht erstellt oder verarbeitet - wir werden in einem anderen Status enden. </li><li>  <strong>Kohärenz.</strong>  Wir haben ein Repository und jetzt erstellen wir anstelle der API Ereignisse.  Wir brauchen eine Möglichkeit, Informationen über neue Ereignisse und Änderungen an bestehenden Ereignissen schnell und kostengünstig an unsere Dienste zu übertragen.  Dies wird mithilfe einer gemeinsamen Spezifikation in einem separaten Git-Repository und Codegeneratoren erreicht.  Daher werden Clients und Server in verschiedenen Diensten mit uns koordiniert. </li></ul><br><h2>  Kafka in Lamoda </h2><br>  Wir haben drei Kafka-Installationen: <br><br><ol><li>  Protokolle </li><li>  F &amp; E; </li><li>  Veranstaltungsbus. </li></ol><br>  Heute sprechen wir nur über den letzten Punkt.  Im Events-Bus haben wir keine sehr großen Installationen - 3 Broker (Server) und insgesamt 27 Themen.  Ein Thema ist in der Regel ein Prozess.  Aber dies ist ein heikler Moment, und jetzt werden wir darauf eingehen. <br><br><img src="https://habrastorage.org/webt/1v/5s/nj/1v5snjoqmrg2sb1grok5snkzowu.png"><br><br>  Oben ist das RPS-Diagramm.  Der Rückerstattungsprozess ist mit einer türkisfarbenen Linie markiert (ja, die auf der X-Achse liegende), und Pink ist der Prozess zur Inhaltsaktualisierung. <br><br>  Lamodas Katalog enthält Millionen von Produkten, wobei die Daten ständig aktualisiert werden.  Einige Kollektionen sind aus der Mode gekommen, stattdessen erscheinen neue, neue Modelle erscheinen ständig im Katalog.  Wir versuchen vorherzusagen, was für unsere Kunden morgen interessant sein wird, also kaufen wir ständig neue Dinge, fotografieren sie und aktualisieren das Fenster. <br><br>  Pink Peaks sind ein Produktupdate, dh Änderungen an Produkten.  Es ist zu sehen, dass die Jungs Fotos gemacht haben, Fotos gemacht haben und dann wieder!  - ein Ereignispaket heruntergeladen. <br><br><h2>  Anwendungsfälle von Lamoda Events </h2><br>  Wir verwenden die konstruierte Architektur für solche Operationen: <br><br><ul><li>  <strong>Verfolgung von Rückgabestatus</strong> : Handlungsaufforderung und Verfolgung von Status aller beteiligten Systeme.  Zahlung, Status, Fiskalisierung, Benachrichtigungen.  Hier haben wir den Ansatz ausprobiert, die Tools erstellt, alle Fehler gesammelt, die Dokumentation geschrieben und den Kollegen erklärt, wie sie verwendet werden sollen. </li><li>  <strong>Aktualisieren von Produktkarten:</strong> Konfiguration, Metadaten, Eigenschaften.  Ein System liest (was angezeigt wird) und mehrere schreiben. </li><li>  <strong>E-Mail, Push und SMS</strong> : Die Bestellung wird abgeholt, die Bestellung ist eingetroffen, die Rücksendung wurde angenommen usw., viele von ihnen. </li><li>  <strong>Lagerbestand, Lageraktualisierung</strong> - eine quantitative Aktualisierung der Artikel, nur Zahlen: Eingang im Lager, Rückgabe.  Es ist erforderlich, dass alle Systeme im Zusammenhang mit der Warenreservierung mit den relevantesten Daten arbeiten.  Jetzt ist das Abfluss-Upgrade-System ziemlich kompliziert, Kafka wird es vereinfachen. </li><li>  <strong>Datenanalyse</strong> (F &amp; E-Abteilung), ML-Tools, Analytik, Statistik.  Wir möchten, dass die Informationen transparent sind - dafür ist Kafka gut geeignet. </li></ul><br>  Der interessantere Teil handelt von ausgestopften Zapfen und interessanten Entdeckungen, die über sechs Monate stattfanden. <br><br><h2>  Designprobleme </h2><br>  Angenommen, wir möchten etwas Neues machen - zum Beispiel den gesamten Lieferprozess an Kafka übertragen.  Ein Teil des Prozesses wird jetzt in der Auftragsabwicklung in BOB implementiert.  Hinter der Übergabe der Bestellung an den Lieferservice, der Übergabe an ein Zwischenlager usw. steht ein Statusmodell.  Es gibt einen ganzen Monolithen, sogar zwei, sowie eine Reihe von Bereitstellungs-APIs.  Sie wissen viel mehr über Lieferung. <br><br>  Dies scheinen ähnliche Bereiche zu sein, aber für die Auftragsabwicklung im BOB und für das Liefersystem sind die Status unterschiedlich.  Beispielsweise senden einige Kurierdienste keine Zwischenstatus, sondern nur endgültige: "geliefert" oder "verloren".  Andere hingegen berichten ausführlich über den Warenverkehr.  Jeder hat seine eigenen Validierungsregeln: Für jemanden ist E-Mail gültig, daher wird sie verarbeitet.  Für andere ist es nicht gültig, aber die Bestellung wird weiterhin bearbeitet, da ein Telefon für die Kommunikation vorhanden ist und jemand sagt, dass eine solche Bestellung überhaupt nicht bearbeitet wird. <br><br><h3>  Datenstrom </h3><br>  Bei Kafka stellt sich die Frage nach der Organisation des Datenflusses.  Diese Aufgabe ist mit der Wahl der Strategie für mehrere Punkte verbunden, wir werden sie alle durchgehen. <br><br><h4>  In einem Thema oder in einem anderen? </h4><br>  Wir haben eine Veranstaltungsspezifikation.  In BOB schreiben wir, dass eine solche Bestellung geliefert werden muss, und geben an: die Bestellnummer, ihre Zusammensetzung, einige SKUs und Barcodes usw.  Wenn die Waren im Lager ankommen, kann die Lieferung Status, Zeitstempel und alles, was benötigt wird, erhalten.  Aber weiter wollen wir Updates zu diesen Daten in BOB erhalten.  Wir stehen vor dem umgekehrten Prozess, Daten aus der Lieferung zu erhalten.  Ist das das gleiche Ereignis?  Oder ist es ein separater Austausch, der ein separates Thema verdient? <br><br>  Höchstwahrscheinlich werden sie sich sehr ähnlich sein, und die Versuchung, ein Thema zu erstellen, ist nicht unangemessen, da ein separates Thema separate Verbraucher, separate Konfigurationen und eine separate Generation all dessen sind.  Aber keine Tatsache. <br><br><h4>  Neues Feld oder neues Ereignis? </h4><br>  Wenn Sie jedoch dieselben Ereignisse verwenden, tritt ein anderes Problem auf.  Beispielsweise können nicht alle Liefersysteme ein DTO generieren, das BOBs generieren kann.  Wir senden ihnen eine ID, aber sie speichern sie nicht, weil sie sie nicht benötigen. Aus Sicht des Starts des Event-Bus-Prozesses ist dieses Feld erforderlich. <br><br>  Wenn wir eine Regel für den Ereignisbus einführen, dass dieses Feld erforderlich ist, müssen wir zusätzliche Validierungsregeln im BOB oder im Startereignishandler festlegen.  Die Validierung schleicht sich in den Service ein - dies ist nicht sehr praktisch. <br><br>    —    .  ,   -   , ,  ,   ,      .       —   .   —    ,    .        JSON      . <br><br>   refunds        .     -,   refund update,     type, ,     update .      «»   ,  ,        type. <br><br><h4>   </h4><br>     Kafka   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Avro</a> ,          Confluent.        .        replication log,    «».  ,    ,     : ,    .    ,     ,   ,    . <br><br><h4>    partitions </h4><br>   Kafka   partitions.          ,  ,  ,     . <br><br>       Kafka  .     partition,        .       . , ,    ,      .  , ,  ,    Kafka   partition,  Kafka       —  ,  . <br><br>  Kafka  ?      (    JSON)   key.      -,   ,   partition  . <br><br>     refunds  ,     partition,   ,           . - ,            partition. <br><br><h4> Events vs commands </h4><br>    ,    . Event —   :  ,  - -  (something_happened), , item    refund.    - ,   «item »  refund  ,  « refund»  -  . <br><br>  ,    ,        —    ,   -  .     something_happened (item_canceled, refund_refunded),  something_should_be_done. , item   . <br><br>   ,  ,    .   ,        .   ,      do_something.     ,    - ;   ,   ;    ,   -,   -  .   ,    do_something,    ,   . <br><br><img src="https://habrastorage.org/webt/gy/xo/vm/gyxovmgvxv3wbwkv_k7mzluobls.png"><br><br>     RabbitMQ,    ,   http,    response —  ,    .     Kafka,  ,     Kafka,   ,   ,    . <br><br>             ,    - ,  -       .    ,  , -   . ,     «item_ready_to_refund»,  ,  refund ,   ,    «money_refunded».    ,   . <br><br><h3>  Nuancen </h3><br>    :      ,    -  ,  ,     .   <strong>  </strong> ,  offset ,   . <br><br>    ,   ,     .    ,        events-bus,        ,         PostgreSQL,        MySQL  UNSIGNED INT,      PostgreSQL   INT.     ,  Id  . Symfony   . , ,  ,     ,     offset,       ,     .        ,  Symfony     ,          offset. <br><br> -    —  ,  Kafka    ,    .       .  . <br><br>  Kafka    tooling   offset.    ,     —      ,     , redeployments.   Kafka  tooling   offset,   . <br><br>   — <strong>replication log vs rdkafka.so</strong> —     .   PHP,   PHP,  ,  ,   Kafka   rdkafka.so,    - .  ,    ,  ,        - .  ,   . <br><br>      partitions,     <strong>consumers &gt;= topic partitions</strong> .       ,   .        ,      partitions.  ,      partition,    20  ,    ,     . ,     ,    partitions. <br><br><h2>  Überwachung </h2><br> ,  ,   ,   ,      . <br><br> , ,       , , ,       ,        .   Kafka    ,       . ,         . <br><br><img src="https://habrastorage.org/webt/il/on/va/ilonvaqqf3tkfcv9reuyezxpgoq.png"><br><br>  ,  ,    ,   events-bus ,     . ,     Refund Tool  ,   BOB  -  ( ). <br><br><img src="https://habrastorage.org/webt/i4/9b/jf/i49bjfsr_lrypwz0_1qfkhhmcjq.png"><br><br>    consumer-group lag.  ,    .       ,     0,      . Kafka    ,     . <br><br>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Burrow</a> ,       Kafka.    API  consumer-group  ,     .    Failed   warning,    ,         —    ,  .   ,   . <br><br><img src="https://habrastorage.org/webt/4j/ht/go/4jhtgoqjn_0kdgvagxkg3flceng.png"><br><br>     API.   bob-live-fifa, partition refund.update.v1,  , lag 0 —   offset -. <br><br><img src="https://habrastorage.org/webt/mh/gn/aq/mhgnaq2qcxamaejf1fkdkkkqnwu.png"><br><br>  <strong>updated_at SLA (stuck)</strong>   . ,    ,     .   Cron,  ,    5       refund (       ),  -    ,      .    Cron,    ,     0,   . <br><br> <b> ,   , </b> : <br><br><ul><li>    ; </li><li>    ; </li><li>     . </li></ul><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es scheint, dass der Artikel ein sehr spezifisches Thema hat - die asynchrone API auf Kafka, aber im Zusammenhang damit möchte ich sofort viele Dinge empfehlen. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstens sollte das nächste </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HighLoad ++</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> erst im November erwartet werden, in St. Petersburg wird es seine Version geben, und im Juni werden wir über hohe Lasten in Nowosibirsk sprechen. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zweitens ist der Autor des Berichts, Sergey Zaika, Mitglied des Programmausschusses unserer neuen KnowledgeConf- </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wissensmanagementkonferenz</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Die Konferenz ist eintägig und findet am 26. April statt. Das Programm ist jedoch sehr ereignisreich. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und im Mai wird es </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PHP Russia</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RIT ++ geben</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (inklusive DevOpsConf) - Sie können immer noch Ihr eigenes Thema vorschlagen, über Ihre Erfahrungen berichten und sich über Ihre verstopften Unebenheiten beschweren.</font></font></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de445424/">https://habr.com/ru/post/de445424/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de445414/index.html">Wie sowjetische Wissenschaftsbücher zu einem Artefakt unter Physikern und Ingenieuren in Indien wurden</a></li>
<li><a href="../de445416/index.html">Warum Schallplatten das digitale Zeitalter überleben</a></li>
<li><a href="../de445418/index.html">Homo Sapiens? Nicht mehr</a></li>
<li><a href="../de445420/index.html">Es gibt 17 Milliarden Computer in der Hirnrinde</a></li>
<li><a href="../de445422/index.html">Welche Programmiersprachen sind am wenigsten sicher?</a></li>
<li><a href="../de445426/index.html">Optimierung für die PostgreSQL-Serving-Rails-Anwendung</a></li>
<li><a href="../de445428/index.html">Hochwertiges WLAN - die Basis moderner Gastfreundschaft und der Motor des Geschäfts</a></li>
<li><a href="../de445432/index.html">Unity Package Manager</a></li>
<li><a href="../de445434/index.html">Bester schlechtester Job der Welt: Auf der Suche nach einem Habraautor</a></li>
<li><a href="../de445436/index.html">Umschulung in DevOps - worauf Sie sich vorbereiten müssen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>