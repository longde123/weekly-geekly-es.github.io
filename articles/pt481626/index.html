<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üïê ü•ñ ‚ñ∂Ô∏è Cole√ß√µes de exibi√ß√£o complexas no iOS: problemas e solu√ß√µes no exemplo do feed VKontakte üôÜ ‚òïÔ∏è üßôüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Oi Meu nome √© Sasha, sou desenvolvedor iOS da equipe que cria o feed do VKontakte. Agora, mostrarei como otimizamos a exibi√ß√£o da interface e contorna...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cole√ß√µes de exibi√ß√£o complexas no iOS: problemas e solu√ß√µes no exemplo do feed VKontakte</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/vk/blog/481626/"><p>  Oi  Meu nome √© Sasha, sou desenvolvedor iOS da equipe que cria o feed do VKontakte.  Agora, mostrarei como otimizamos a exibi√ß√£o da interface e contornamos os problemas associados a isso. <br>  Eu acho que voc√™ pode imaginar o que √© fita VK.  Esta √© uma tela na qual voc√™ pode ver uma variedade de conte√∫do: textos, imagens est√°ticas, gifs animados, elementos incorporados (v√≠deo e m√∫sica).  Tudo isso deve ser exibido sem problemas, da√≠ as altas demandas no desempenho das solu√ß√µes. </p><br><p>  Agora vamos ver quais abordagens padr√£o para trabalhar com mapeamentos existem e quais limita√ß√µes ou vantagens devem ser levadas em considera√ß√£o. </p><br><p>  Se voc√™ gosta de ouvir mais do que ler, a grava√ß√£o em v√≠deo do relat√≥rio est√° <a href="https://vk.com/video-147415323_456239051">aqui</a> . </p><br><p><img src="https://habrastorage.org/webt/6u/np/1d/6unp1dycdkq5wxkhtv-6ixrmv-q.png"></p><a name="habracut"></a><br><h1 id="soderzhanie">  Conte√∫do </h1><br><ol><li> Descri√ß√£o e c√°lculo do layout <br>  1.1  Layout autom√°tico <br>  1.2  C√°lculo de <code>frame</code> manual </li><li>  C√°lculo do tamanho do texto <br>  2.1  M√©todos padr√£o para calcular o tamanho de <code>UILabel</code> / <code>UITextView</code> / <code>UITextField</code> <br>  2.2  M√©todos <code>NSAttributedString</code> / <code>NSString</code> <br>  2.3  Textkit <br>  2.4  Coretext </li><li>  Como o feed do VKontakte funciona? </li><li>  Como obter melhor desempenho <br>  4.1 Por que problemas de desempenho <br>  4.2 <code>CATransaction.commit</code> <br>  4.3  Pipeline de renderiza√ß√£o <br>  4.4  Os lugares mais vulner√°veis ‚Äã‚Äãao desempenho </li><li>  Ferramentas de medi√ß√£o <br>  5.1  Rastreio do sistema de metal <br>  5.2  Corrigimos rebaixamentos de desempenho no c√≥digo enquanto o aplicativo est√° sendo executado </li></ol><br><ul><li>  Como pesquisar problemas.  Recomenda√ß√µes </li><li>  Conclus√£o </li><li>  Fontes de informa√ß√£o </li></ul><br><h1 id="1-opisanie-i-vychislenie-layout">  <strong>1. Descri√ß√£o e c√°lculo do layout</strong> </h1><br><p>  Primeiro, vamos relembrar como criar uma estrutura de interface visual ( <em>layout</em> ) usando ferramentas regulares.  Para economizar espa√ßo, ficaremos sem listagens - simplesmente listarei as solu√ß√µes e explicarei seus recursos. </p><br><h2 id="11-auto-layout">  <strong>1.1</strong>  <strong>Layout autom√°tico</strong> </h2><br><p>  Talvez a maneira mais popular de criar uma interface no iOS seja usar o sistema de layout <a href="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/index.html">Auto Layout</a> da Apple.  √â <a href="https://habr.com/ru/company/oleg-bunin/blog/437584/">baseado no</a> algoritmo <a href="https://constraints.cs.washington.edu/cassowary/">Cassowary</a> , indissociavelmente ligado ao conceito de <em>restri√ß√µes.</em> </p><br><p>  <em>Por enquanto, lembre-se de que a interface implementada usando o Layout autom√°tico se baseia em restri√ß√µes.</em> </p><br><p>  <strong>Caracter√≠sticas da abordagem:</strong> </p><br><ul><li>  O sistema de restri√ß√£o √© transformado em <a href="https://ru.wikipedia.org/wiki/%25D0%259B%25D0%25B8%25D0%25BD%25D0%25B5%25D0%25B9%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5">um problema de programa√ß√£o linear</a> . </li><li>  <a href="https://constraints.cs.washington.edu/solvers/cassowary-tochi.pdf">Cassowary resolve o</a> problema de otimiza√ß√£o resultante usando o <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25B8%25D0%25BC%25D0%25BF%25D0%25BB%25D0%25B5%25D0%25BA%25D1%2581-%25D0%25BC%25D0%25B5%25D1%2582%25D0%25BE%25D0%25B4">m√©todo simplex</a> .  Este m√©todo possui complexidade assint√≥tica exponencial.  O que isso significa?  √Ä medida que o n√∫mero de restri√ß√µes no layout aumenta, na pior das hip√≥teses, os c√°lculos podem diminuir exponencialmente. </li><li>  Os valores de <a href="https://developer.apple.com/documentation/uikit/uiview/1622621-frame"><code>frame</code></a> resultantes para o <a href="https://developer.apple.com/documentation/uikit/uiview"><code>UIView</code></a> s√£o a solu√ß√£o para o problema de otimiza√ß√£o correspondente. </li></ul><br><p>  <strong>Benef√≠cios do uso do Layout Autom√°tico:</strong> </p><br><ul><li>  <a href="https://developer.apple.com/videos/play/wwdc2018/220">Em mapeamentos simples, √© poss√≠vel complexidade computacional linear</a> . </li><li>  Ele se d√° bem com todos os elementos padr√£o, pois √© a tecnologia "nativa" da Apple. </li><li>  <code>UIView</code> funciona com o <code>UIView</code> . </li><li>  Dispon√≠vel no Interface Builder, que permite descrever o layout em um Storyboard ou XIB. </li><li>  Garante uma solu√ß√£o atualizada, mesmo durante a transi√ß√£o.  Isso significa que o valor do <code>frame</code> de cada <code>UIView</code> sempre (!) Uma solu√ß√£o para a tarefa de layout real. </li></ul><br><p>  Os recursos do sistema s√£o suficientes para a maioria dos monitores.  Mas n√£o √© adequado para criar fitas com uma quantidade enorme de conte√∫do heterog√™neo.  Porque </p><br><p>  <strong>√â importante lembrar que o Layout autom√°tico:</strong> </p><br><ul><li>  <em>Funciona apenas no segmento principal</em> .  Suponha que os engenheiros da Apple tenham escolhido o Mainstream como o ponto de sincroniza√ß√£o da solu√ß√£o Auto Layout e os valores de quadro de todos os <code>UIView</code> .  Sem isso, voc√™ teria que calcular o Layout autom√°tico em um segmento separado e sincronizar constantemente os valores com o segmento Principal. </li><li>  <em>Ele pode trabalhar lentamente em representa√ß√µes complexas</em> , pois √© baseado em um algoritmo de for√ßa bruta cuja complexidade, no pior caso, √© exponencial. </li><li>  <em>Dispon√≠vel</em> <em>com iOS 6.0</em> .  Agora, isso dificilmente √© um problema, mas vale a pena considerar. </li></ul><br><p>  <em>Conclus√£o: usando o Layout autom√°tico, √© conveniente criar exibi√ß√µes sem ou com cole√ß√µes, mas sem rela√ß√µes complexas entre elementos.</em> </p><br><h2 id="12-raschyot-frame-vruchnuyu">  <strong>1.2</strong>  <strong>C√°lculo de <code>frame</code> manual</strong> </h2><br><p>  A ess√™ncia da abordagem: calculamos todos os valores de <code>frame</code> .  Por exemplo, implementamos os m√©todos <a href="https://developer.apple.com/documentation/uikit/uiview/1622482-layoutsubviews%3Flanguage%3Dobjc%2560"><code>layoutSubviews</code></a> , <a href="https://developer.apple.com/documentation/uikit/uiview/1622625-sizethatfits"><code>sizeThatFits</code></a> .  Ou seja, em <code>layoutSubviews</code> mesmos organizamos todos os elementos filho, em <code>sizeThatFits</code> calculamos o tamanho correspondente ao local desejado dos elementos e conte√∫do filho. </p><br><p>  O que isso d√°?  Podemos transferir c√°lculos complexos para o fluxo de segundo plano, e c√°lculos relativamente simples podem ser realizados no fluxo principal. </p><br><p>  Qual √© o problema?  Voc√™ deve implementar os c√°lculos voc√™ mesmo, √© f√°cil cometer um erro.  Voc√™ tamb√©m precisa garantir que a posi√ß√£o dos filhos e os resultados retornados em <code>sizeThatFits</code> . </p><br><p>  <strong>A auto-avalia√ß√£o √© justificada se:</strong> </p><br><ul><li>  Descobrimos ou prevemos que encontraremos limita√ß√µes de desempenho do Layout Autom√°tico. </li><li>  o aplicativo possui uma cole√ß√£o complexa e h√° uma boa chance de o elemento desenvolvido cair em uma de suas c√©lulas; </li><li>  queremos calcular o tamanho do elemento no segmento Background; </li><li>  exibimos elementos n√£o padronizados na tela, cujo tamanho deve ser constantemente recontado, dependendo do conte√∫do ou do ambiente. <br><img src="https://habrastorage.org/webt/tg/-l/nl/tg-lnlwfkzfzkqir1xdd2dun6la.png"></li></ul><br><p>  <strong>Um exemplo</strong>  Desenhe dicas de ferramentas que s√£o dimensionadas automaticamente para se ajustarem ao conte√∫do.  A parte mais interessante desta tarefa √© como calcular o tamanho visual do texto em cada dica de ferramenta. </p><br><hr><br><h1 id="2-vychislenie-razmera-teksta">  <strong>2. C√°lculo do tamanho do texto</strong> </h1><br><p>  Esse problema pode ser resolvido de pelo menos quatro maneiras, cada uma das quais se baseia em seu pr√≥prio conjunto de m√©todos.  E cada um tem suas pr√≥prias caracter√≠sticas e limita√ß√µes. </p><br><h2 id="21-standartnye-metody-vychisleniya-razmera-uilabeluitextviewuitextfield">  <strong>2.1</strong>  <strong>M√©todos padr√£o para calcular o tamanho de <code>UILabel</code> / <code>UITextView</code> / <code>UITextField</code></strong> </h2><br><p>  Os <a href="https://developer.apple.com/documentation/uikit/uiview/1622625-sizethatfits"><code>sizeThatFits</code></a> (usados ‚Äã‚Äãpor padr√£o em <a href="https://developer.apple.com/documentation/uikit/uiview/1622630-sizetofit"><code>sizeToFit</code></a> ) e <a href="https://developer.apple.com/documentation/uikit/uiview/1622600-intrinsiccontentsize"><code>intrinsicContentSize</code></a> (usado no Layout autom√°tico) retornam o tamanho preferido do conte√∫do da exibi√ß√£o.  Por exemplo, com a ajuda deles, podemos descobrir quanto espa√ßo o texto escrito em <code>UILabel</code> . </p><br><p>  A desvantagem √© que ambos os m√©todos funcionam apenas no segmento Principal - eles n√£o podem ser chamados a partir do plano de fundo. </p><br><p>  <strong>Quando os m√©todos padr√£o s√£o √∫teis?</strong> </p><br><ul><li>  Se j√° usamos <code>sizeToFit</code> ou Auto Layout. </li><li>  Quando h√° elementos padr√£o no visor, e queremos obter o tamanho deles no c√≥digo. </li><li>  Para qualquer exibi√ß√£o sem cole√ß√µes complexas. </li></ul><br><h2 id="22-metody-nsattributedstringnsstring">  <strong>2.2</strong>  <strong>M√©todos NSAttributedString / NSString</strong> </h2><br><p>  Observe os <a href="https://developer.apple.com/documentation/foundation/nsstring/1531844-sizewithattributes%3Flanguage%3Dobjc"><code>sizeWithAttributes</code></a> <a href="https://developer.apple.com/documentation/foundation/nsstring/1524729-boundingrect"><code>boundingRect</code></a> e <a href="https://developer.apple.com/documentation/foundation/nsstring/1531844-sizewithattributes%3Flanguage%3Dobjc"><code>sizeWithAttributes</code></a> .  Eu n√£o aconselho us√°-los para ler o tamanho do conte√∫do de <code>UILabel</code> / <code>UITextView</code> / <code>UITextField</code> .  N√£o encontrei nas informa√ß√µes da documenta√ß√£o que os m√©todos <code>NSString</code> e os m√©todos de layout dos elementos <code>UIView</code> sejam baseados no mesmo c√≥digo (mesmas classes).  Esses dois grupos de classes pertencem a estruturas diferentes: Foundation e UIKit, respectivamente.  Talvez voc√™ j√° tenha que ajustar o resultado boundingRect ao tamanho <code>UILabel</code> ?  Ou voc√™ se deparou com o fato de que os <a href="https://stackoverflow.com/questions/15965525/how-to-get-nsstring-size-when-nsstring-includes-emojis"><code> NSString</code> n√£o levam em considera√ß√£o o tamanho dos emoticons</a> ?  Estes s√£o os problemas que voc√™ pode obter. </p><br><p>  Tamb√©m vou lhe dizer quais classes s√£o respons√°veis ‚Äã‚Äãpelo desenho de texto em <code>UILabel</code> / <code>UITextView</code> / <code>UITextField</code> , mas, por enquanto, <code>UITextField</code> retornar aos m√©todos. </p><br><p>  <strong>Usar boundingRect e sizeWithAttributes vale a pena se:</strong> </p><br><ul><li>  <a href="https://developer.apple.com/documentation/foundation/nsstring/1529855-drawinrect"><code>drawInRect</code></a> elementos de interface n√£o padr√£o usando <a href="https://developer.apple.com/documentation/foundation/nsstring/1529855-drawinrect"><code>drawInRect</code></a> , <a href="https://developer.apple.com/documentation/foundation/nsstring/1533109-drawatpoint"><code>drawAtPoint</code></a> ou outros m√©todos da <code>NSAttributedString</code> <code>NSString</code> / <code>NSAttributedString</code> . </li><li>  Queremos considerar o tamanho dos elementos no fluxo de segundo plano.  Novamente, isso √© apenas ao usar os m√©todos de renderiza√ß√£o apropriados. </li><li>  Desenhe em um <a href="https://developer.apple.com/documentation/coregraphics/cgcontextref%3Flanguage%3Dobjc">contexto</a> arbitr√°rio, por exemplo, exiba uma linha na parte superior da imagem. </li></ul><br><h2 id="23-textkit">  <strong>2.3</strong>  <strong>Textkit</strong> </h2><br><p>  Essa ferramenta consiste nas classes padr√£o <a href="https://developer.apple.com/documentation/uikit/nslayoutmanager"><code>NLayoutManager</code></a> , <a href="https://developer.apple.com/documentation/uikit/nstextstorage"><code>NSTextStorage</code></a> e <a href="https://developer.apple.com/documentation/uikit/nstextcontainer"><code>NSTextContainer</code></a> .  O layout <code>UILabel</code> / <code>UITextView</code> / <code>UITextField</code> tamb√©m <code>UITextField</code> <a href="https://developer.apple.com/library/archive/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/CustomTextProcessing/CustomTextProcessing.html">baseado</a> neles. </p><br><p>  O TextKit √© muito conveniente quando voc√™ precisa descrever em detalhes a localiza√ß√£o do texto e <a href="https://developer.apple.com/documentation/uikit/nstextcontainer/1444569-exclusionpaths">indicar em quais formas ele fluir√°</a> : </p><br><p><img src="https://habrastorage.org/webt/g8/m1/hi/g8m1hixof_ic7gpugctcvug9gsk.png"></p><br><p>  Usando o TextKit, voc√™ pode calcular o tamanho dos elementos da interface na fila de segundo plano, bem como o <a href="https://developer.apple.com/documentation/uikit/nslayoutmanager/1403160-enumeratelinefragments"><code>  frame</code> linhas / caracteres</a> .  Al√©m disso, a estrutura permite <a href="https://developer.apple.com/documentation/uikit/nslayoutmanager/1403158-drawglyphs">desenhar glifos</a> e alterar completamente a apar√™ncia do texto no layout existente.  Tudo isso funciona no iOS 7.0 e superior. </p><br><p>  <strong>O TextKit √© √∫til quando voc√™ precisa:</strong> </p><br><ul><li>  exibir texto com layout complexo; </li><li>  desenhar texto em imagens; </li><li>  calcular os tamanhos de substrings individuais; </li><li>  conte o n√∫mero de linhas; </li><li>  use os resultados dos c√°lculos em um <code>UITextView</code> . </li></ul><br><p>  Eu enfatizo novamente.  Se voc√™ precisar calcular o tamanho do <code>UITextView</code> , primeiro configuramos as inst√¢ncias das <code>NSLayoutManager</code> , <code>NSTextStorage</code> e <code>NSTextContainer</code> e <a href="https://developer.apple.com/documentation/uikit/uitextview/1618602-layoutmanager">passamos essas inst√¢ncias para o</a> <code>UITextView</code> <a href="https://developer.apple.com/documentation/uikit/uitextview/1618602-layoutmanager">correspondente</a> , onde ser√£o respons√°veis ‚Äã‚Äãpelo layout.  Somente assim garantimos total coincid√™ncia de todos os valores. </p><br><p>  N√£o use o TextKit com <code>UILabel</code> e <code>UITextField</code> !  Para eles (diferente do <code>UITextView</code> ), voc√™ n√£o pode configurar o <code>NSLayoutManager</code> , <code>NSTextStorage</code> e <code>NSTextContainer</code> . </p><br><h2 id="24-coretext">  <strong>2.4</strong>  <strong>Coretext</strong> </h2><br><p>  Esta √© a ferramenta de texto de n√≠vel mais baixo no iOS.  D√° o controle m√°ximo sobre a renderiza√ß√£o de fontes, caracteres, linhas, recuos.  E ele, como o TextKit, permite calcular par√¢metros tipogr√°ficos do texto, como linha de base e tamanho do quadro de linhas individuais. </p><br><p>  Como voc√™ sabe, quanto mais liberdade, maior a responsabilidade.  E, para obter bons resultados usando o CoreText, voc√™ precisa poder usar seus m√©todos. </p><br><p>  O CoreText fornece seguran√ßa de thread para opera√ß√µes na maioria dos objetos.  Isso significa que podemos chamar seus m√©todos a partir de diferentes threads.  Para compara√ß√£o, ao usar o TextKit, voc√™ mesmo deve pensar na sequ√™ncia de chamadas de m√©todo. </p><br><p>  O CoreText deve ser usado se: </p><br><ul><li>  √â necess√°ria uma API de baixo n√≠vel extremamente simples para acesso direto aos par√¢metros de texto.  Devo dizer imediatamente que, para a grande maioria das tarefas, os recursos do TextKit s√£o suficientes. </li><li>  H√° muito trabalho a fazer com linhas individuais ( <a href="https://developer.apple.com/documentation/coretext/ctline-61l"><code>CTLine</code></a> ) e caracteres / elementos. </li><li>  O suporte √© importante no iOS 6.0. </li></ul><br><p>  Para o feed do VKontakte, usamos o CoreText.  Porque  No momento em que implementamos as fun√ß√µes b√°sicas de trabalhar com texto, o TextKit ainda n√£o estava l√°. </p><br><hr><br><h1 id="3-kak-rabotaet-lenta-vkontakte">  <strong>3. Como o feed do VKontakte funciona?</strong> </h1><br><p>  Brevemente sobre como recebemos dados do servidor, layout de formul√°rio e displays. </p><br><p><img src="https://habrastorage.org/webt/7g/kx/pt/7gkxptt4lpgjhjzbtyl3prm4vxy.png"></p><br><p>  Primeiro, considere as tarefas executadas na fila de segundo plano.  Recebemos dados do servidor, processamos e descrevemos declarativamente a exibi√ß√£o subsequente.  Nesse est√°gio, ainda n√£o temos inst√¢ncias do <code>UIView</code> , apenas definimos as regras e a estrutura da interface futura com nossa ferramenta declarativa, um pouco semelhante ao <a href="https://developer.apple.com/xcode/swiftui/">SwiftUI</a> .  Para calcular o layout, calculamos o <code>frame</code> inteiro levando em considera√ß√£o as restri√ß√µes atuais, por exemplo, a largura da tela.  Atualizamos o <code>dataSource</code> atual ( <code>dataSourceUpdate</code> ).  Aqui, na fila de plano de fundo, preparamos as imagens: executar descompacta√ß√£o (consulte a se√ß√£o de desempenho para obter mais detalhes), desenhar sombras, arredondamentos e outros efeitos. </p><br><p>  Agora v√° para a fila principal.  <code>dataSourceUpdate</code> recebido no <code>UITableView</code> , reutilizamos e processamos os eventos da interface, preenchemos as c√©lulas. </p><br><p>  Para descrever nosso sistema de layout, seria necess√°rio um artigo separado, mas aqui vou listar suas principais caracter√≠sticas: </p><br><ul><li>  Uma API declarativa √© um conjunto de regras nas quais uma interface √© constru√≠da. </li><li>  Componentes b√°sicos formam uma √°rvore ( <code>nodes</code> ). </li><li>  C√°lculos simples em componentes b√°sicos.  Por exemplo, nas listas, calculamos apenas o deslocamento da <code>origin</code> , levando em considera√ß√£o a largura / altura de todos os filhos. </li><li>  Os elementos b√°sicos n√£o criam "cont√™ineres" desnecess√°rios do <code>UIView</code> na hierarquia.  Por exemplo, o componente da lista n√£o forma um <code>UIView</code> adicional e n√£o adiciona filhos a ele.  Em vez disso, calculamos o deslocamento da <code>origin</code> dos filhos em rela√ß√£o ao elemento pai (para a lista). </li><li>  Gerenciamento de texto de baixo n√≠vel com CoreText. </li></ul><br><p>  Mas mesmo com essa abordagem, a exibi√ß√£o da fita pode n√£o ser tranquila devido a problemas de desempenho.  Porque </p><br><p>  Cada c√©lula possui uma hierarquia complexa de <code>nodes</code> .  E embora os elementos b√°sicos n√£o criem cont√™ineres desnecess√°rios, muitas <code>UIView</code> ainda <code>UIView</code> exibidas na faixa de op√ß√µes.  E ao preencher a hierarquia com ‚Äún√≥s‚Äù (ver liga√ß√£o) na fila principal, h√° trabalho extra que √© dif√≠cil de evitar. </p><br><p>  Tentamos transferir o maior n√∫mero poss√≠vel de tarefas para a fila de segundo plano e agora continuamos a faz√™-lo.  Al√©m disso, existem opera√ß√µes intensivas em CPU e GPU que devem ser levadas em considera√ß√£o e contornadas. </p><br><hr><br><h1 id="4-kak-dobitsya-luchshey-proizvoditelnosti">  <strong>4. Como alcan√ßar um melhor desempenho</strong> </h1><br><p>  A resposta mais simples √© descarregar o thread principal, CPU e GPU.  Para fazer isso, voc√™ precisa entender profundamente o trabalho dos aplicativos iOS.  E, acima de tudo, identifique as fontes dos problemas. </p><br><h2 id="41-pochemu-voznikayut-problemy-s-proizvoditelnostyu">  <strong>4.1 Por que problemas de desempenho</strong> </h2><br><p>  <strong>Anima√ß√£o principal, <code>RunLoop</code> e Scroll</strong> <br>  Vamos lembrar como a interface √© constru√≠da no iOS.  No n√≠vel superior, h√° o <a href="https://developer.apple.com/documentation/uikit">UIKit</a> , respons√°vel por interagir com o usu√°rio: manipulando gestos, despertando o aplicativo do modo de suspens√£o e coisas semelhantes.  Para renderizar a interface, uma ferramenta de n√≠vel inferior √© respons√°vel - <a href="https://developer.apple.com/documentation/quartzcore">Core Animation</a> (como no macOS).  Esta √© uma estrutura com seu pr√≥prio <a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CoreAnimation_guide/CoreAnimationBasics/CoreAnimationBasics.html">sistema de descri√ß√£o de interface</a> .  Considere os conceitos b√°sicos de constru√ß√£o de uma interface. </p><br><p>  Para o Core Animation, toda a interface √© <a href="https://developer.apple.com/documentation/quartzcore/calayer"><code>CALayer</code></a> camadas do <a href="https://developer.apple.com/documentation/quartzcore/calayer"><code>CALayer</code></a> .  Eles formam uma √Årvore de Renderiza√ß√£o, gerenciada atrav√©s de transa√ß√µes de transa√ß√£o <a href="https://developer.apple.com/documentation/quartzcore/catransaction"><code>CATransaction</code></a> . </p><br><p>  Uma transa√ß√£o √© um grupo de altera√ß√µes, mais precisamente, informa√ß√µes sobre a necessidade de atualizar algo na interface exibida.  Qualquer altera√ß√£o no <code>frame</code> ou em outros par√¢metros da camada cai na transa√ß√£o atual.  Se ainda n√£o estiver, o pr√≥prio sistema cria uma <a href="https://developer.apple.com/documentation/quartzcore/catransaction%3Flanguage%3Dobjc"><em>transa√ß√£o impl√≠cita</em></a> . </p><br><p>  V√°rias transa√ß√µes formam uma pilha.  Novas atualiza√ß√µes caem na transa√ß√£o principal da pilha. </p><br><p>  <em>Agora sabemos que, para atualizar a tela, precisamos formar transa√ß√µes com novos par√¢metros para a √°rvore de camadas.</em> </p><br><p><img src="https://habrastorage.org/webt/84/2n/q5/842nq5jznw5i30ybdmqjrngqhiw.png"></p><br><p>  <strong>Quando e como criar transa√ß√µes?</strong>  Em nosso aplicativo, os threads t√™m uma <a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html">entidade</a> chamada <a href="https://developer.apple.com/documentation/foundation/runloop"><code>RunLoop</code></a> .  Em termos simples, esse √© um loop infinito, a cada itera√ß√£o na qual a <a href="https://ru.wikipedia.org/wiki/%25D0%25A6%25D0%25B8%25D0%25BA%25D0%25BB_%25D1%2581%25D0%25BE%25D0%25B1%25D1%258B%25D1%2582%25D0%25B8%25D0%25B9">fila de eventos</a> atual √© processada. </p><br><p>  No thread Principal, o <code>RunLoop</code> necess√°rio para processar eventos de v√°rias fontes, como uma interface (gestos), timers ou, por exemplo, manipuladores para receber dados do <a href="https://developer.apple.com/documentation/foundation/nsstream"><code>NSStream</code></a> e <a href="https://developer.apple.com/documentation/foundation/nsport"><code>NSPort</code></a> . </p><br><p><img src="https://habrastorage.org/webt/rd/f_/_m/rdf__mlll7k8wkiz6ijg8cnhhba.png"></p><br><p>  Como o Core Animation e o <code>RunLoop</code> ?  Descobrimos acima que, ao alterar as propriedades de uma camada na √Årvore de Renderiza√ß√£o, o sistema cria transa√ß√µes impl√≠citas, se necess√°rio (portanto, n√£o precisamos chamar <a href="https://developer.apple.com/documentation/quartzcore/catransaction/1448282-begin"><code>CATransaction.begin</code></a> para redesenhar algo).  Al√©m disso, a cada itera√ß√£o do <code>RunLoop</code> sistema fecha automaticamente as transa√ß√µes abertas e aplica as altera√ß√µes feitas ( <a href="https://developer.apple.com/documentation/quartzcore/catransaction/1448255-commit"><code>CATransaction.commit</code></a> ). </p><br><p>  <strong>Preste aten√ß√£o!</strong>  O n√∫mero de itera√ß√µes <code>RunLoop</code> n√£o depende da taxa de atualiza√ß√£o da tela.  O ciclo n√£o √© sincronizado com a tela e funciona como " <code>while()</code> sem fim <code>while()</code> ". </p><br><p>  Agora vamos ver o que acontece nas itera√ß√µes do <code>RunLoop</code> no thread Principal durante a rolagem: </p><br><pre> <code class="plaintext hljs"> ... if (dispatchBlocks.count &gt; 0) { //   MainQueue doBlocks() } ... if (hasPanEvent) { handlePan() // UIScrollView change content offset -&gt; change bounds } ... if (hasCATransaction) { CATransaction.commit() } ...</code> </pre> <br><p>  Primeiro, os blocos adicionados √† fila Principal por meio de <a href="https://developer.apple.com/documentation/dispatch/1453057-dispatch_async"><code>dispatch_async</code></a> / <a href="https://developer.apple.com/documentation/dispatch/1452870-dispatch_sync"><code>dispatch_sync</code></a> s√£o executados.  E at√© que sejam conclu√≠dos, o programa n√£o continua com as seguintes tarefas. </p><br><p>  Em seguida, o UIKit come√ßa a processar o <a href="https://developer.apple.com/documentation/uikit/uipangesturerecognizer">gesto</a> de <a href="https://developer.apple.com/documentation/uikit/uipangesturerecognizer">pan</a> do usu√°rio.  Como parte do processamento desse gesto, o <a href="https://developer.apple.com/documentation/uikit/uiscrollview/1619404-contentoffset"><code>UIScrollView.contentOffset</code></a> muda e, como resultado, o <a href="https://developer.apple.com/documentation/uikit/uiview/1622580-bounds"><code>UIScrollView.bounds</code></a> .  Alterar os <code>bounds</code> <a href="https://developer.apple.com/documentation/uikit/uiscrollview"><code>UIScrollView</code></a> (respectivamente e de seus descendentes <a href="https://developer.apple.com/documentation/uikit/uitableview"><code>UITableView</code></a> , <a href="https://developer.apple.com/documentation/uikit/uicollectionview"><code>UICollectionView</code></a> ) atualiza a parte vis√≠vel do conte√∫do ( <code>viewport</code> ). </p><br><p>  No final da itera√ß√£o <code>RunLoop</code> , se tivermos transa√ß√µes abertas, a <code>commit</code> ou <code>RunLoop</code> ocorrer√° automaticamente. </p><br><p>  Para verificar como isso funciona, coloque pontos de interrup√ß√£o nos locais apropriados. <br>  Aqui est√° a apar√™ncia do processamento de gestos: </p><br><p><img src="https://habrastorage.org/webt/9c/kw/08/9ckw08wo9cay2nhxqm7qikm1n4w.png"></p><br><p>  E aqui est√° o <code>CATransaction.commit</code> ap√≥s o <code>handlePan</code> : </p><br><p><img src="https://habrastorage.org/webt/0k/h0/xc/0kh0xcaq1yx04htvepmilc_przq.png"></p><br><p>  Durante a desacelera√ß√£o da rolagem, o <code>UIScrollView</code> cria um timer <a href="https://developer.apple.com/documentation/quartzcore/cadisplaylink"><code>CADisplayLink</code></a> para sincronizar o n√∫mero de altera√ß√µes no <code>contentOffset</code> por segundo com a taxa de atualiza√ß√£o da tela. </p><br><p><img src="https://habrastorage.org/webt/42/gz/5x/42gz5xmatumqfi9jpcl3z1gabic.png"></p><br><p>  Percebemos que o <code>CATransaction.commit</code> n√£o ocorre no final da itera√ß√£o <code>RunLoop</code> , mas diretamente no processamento do timer do <code>CADisplayLink</code> .  Mas isso n√£o importa: </p><br><p><img src="https://habrastorage.org/webt/oq/si/f0/oqsif0ek7f1-w4f4lguvp_eun20.png"></p><br><h2 id="42-catransactioncommit">  <strong>4.2</strong> <strong><code>CATransaction.commit</code></strong> </h2><br><p>  De fato, todas as opera√ß√µes dentro do <code>CATransaction.commit</code> s√£o executadas nas camadas do <code>CALayer</code> .  <a href="https://developer.apple.com/documentation/quartzcore/calayer/1410935-layoutsublayers%3Flanguage%3Dobjc"><code>layoutSublayers</code></a> t√™m seus pr√≥prios m√©todos para atualizar o layout ( <a href="https://developer.apple.com/documentation/quartzcore/calayer/1410935-layoutsublayers%3Flanguage%3Dobjc"><code>layoutSublayers</code></a> ) e a imagem ( <a href="https://developer.apple.com/documentation/quartzcore/calayerdelegate/2097262-draw"><code>drawLayer</code></a> ).  A implementa√ß√£o padr√£o desses m√©todos resulta em chamadas de m√©todo <a href="https://developer.apple.com/documentation/quartzcore/calayer/1410984-delegate">delegadas</a> .  Ao adicionar uma nova inst√¢ncia do <code>UIView</code> √† hierarquia do <code>UIView</code> , adicionamos implicitamente a camada correspondente √† hierarquia da camada de Anima√ß√£o principal.  Nesse caso, o <code>UIView</code> por padr√£o um delegado de sua camada.  Como voc√™ pode ver na pilha de chamadas, o <code>UIView</code> como parte da implementa√ß√£o dos m√©todos delegados do <code>CALayer</code> , executa seus m√©todos, que ser√£o discutidos: </p><br><p><img src="https://habrastorage.org/webt/oq/si/f0/oqsif0ek7f1-w4f4lguvp_eun20.png"></p><br><p>  Como geralmente trabalhamos com a hierarquia do <code>UIView</code> , a descri√ß√£o continuar√° com exemplos do <code>UIView</code> . </p><br><p>  Durante o <code>CATransaction.commit</code> , o layout de todo o <code>UIView</code> marcado com <a href="https://developer.apple.com/documentation/uikit/uiview/1622601-setneedslayout"><code>setNeedsLayout</code></a> .  Observe que mais uma vez n√≥s mesmos n√£o chamamos <a href="https://developer.apple.com/documentation/uikit/uiview/1622482-layoutsubviews"><code>layoutSubviews</code></a> ou <a href="https://developer.apple.com/documentation/uikit/uiview/1622507-layoutifneeded"><code>layoutIfNeeded</code></a> devido √† sua execu√ß√£o adiada garantida no sistema dentro do <code>CATransaction.commit</code> .  Mesmo que em uma transa√ß√£o (entre chamadas para <code>CATransaction.begin</code> e <code>CATransaction.commit</code> ) voc√™ altere o <code>frame</code> v√°rias vezes e chame <code>setNeedsLayout</code> , cada altera√ß√£o n√£o ser√° aplicada instantaneamente.  As altera√ß√µes finais s√≥ ter√£o efeito depois de chamar <code>CATransaction.commit</code> .  M√©todos relevantes do <code>CALayer</code> : <a href="https://developer.apple.com/documentation/quartzcore/calayer/1410946-setneedslayout%3Flanguage%3Dobjc"><code>setNeedsLayout</code></a> , <a href="https://developer.apple.com/documentation/quartzcore/calayer/1410873-layoutifneeded%3Flanguage%3Dobjc"><code>layoutIfNeeded</code></a> e <a href="https://developer.apple.com/documentation/quartzcore/calayer/1410935-layoutsublayers%3Flanguage%3Dobjc"><code>layoutSublayers</code></a> . </p><br><p>  Um grupo semelhante para desenho √© formado pelos m√©todos <a href="https://developer.apple.com/documentation/uikit/uiview/1622437-setneedsdisplay"><code>setNeedsDisplay</code></a> e <a href="https://developer.apple.com/documentation/uikit/uiview/1622437-setneedsdisplay"><code>setNeedsDisplay</code></a> .  Para <code>CALayer</code> s√£o <a href="https://developer.apple.com/documentation/quartzcore/calayer/1410855-setneedsdisplay"><code>setNeedsDisplay</code></a> , <a href="https://developer.apple.com/documentation/quartzcore/calayer/1410813-displayifneeded"><code>displayIfNeeded</code></a> e <a href="https://developer.apple.com/documentation/quartzcore/calayerdelegate/2097262-draw"><code>drawLayer</code></a> .  <code>CATransaction.commit</code> chama os m√©todos de renderiza√ß√£o em todos os elementos marcados com <code>setNeedsDisplay</code> .  Esta etapa √†s vezes √© chamada de desenho fora da tela. </p><br><p>  <strong>Um exemplo</strong>  Para especificidade e conveni√™ncia, <code>UITableView</code> o <code>UITableView</code> : </p><br><pre> <code class="plaintext hljs"> ... // Layout UITableView.layoutSubviews() //  ,   .. ... // Offscreen drawing UITableView.drawRect() //    ...</code> </pre> <br><p>  O UIKit reutiliza as <code>UICollectionView</code> <code>UITableView</code> / <code>UICollectionView</code> no <code>layoutSubviews</code> : chama o <code>willDisplayCell</code> delegado <code>willDisplayCell</code> e assim por diante.  Durante o <code>CATransaction.commit</code> , ocorre o desenho fora da tela: os m√©todos <a href="https://developer.apple.com/documentation/quartzcore/calayer/1410757-drawincontext%3Flanguage%3Dobjc"><code>drawInContext</code></a> de todas as camadas ou o <a href="https://developer.apple.com/documentation/uikit/uiview/1622529-drawrect"><code>drawRect</code></a> todos os <code>UIView</code> , marcados como <a href="https://developer.apple.com/documentation/uikit/uiview/1622437-setneedsdisplay"><code>setNeedsDisplay</code></a> , s√£o <a href="https://developer.apple.com/documentation/uikit/uiview/1622437-setneedsdisplay"><code>setNeedsDisplay</code></a> .  Percebo que quando desenhamos algo no <code>drawRect</code> , isso acontece no encadeamento principal e precisamos urgentemente alterar a exibi√ß√£o das camadas para um novo quadro.  √â claro que essa solu√ß√£o pode ser muito ineficiente. </p><br><p>  O que acontece a seguir no <code>CATransaction.commit</code> ?  A √°rvore de renderiza√ß√£o √© enviada ao servidor de renderiza√ß√£o. </p><br><h2 id="43-rendering-pipeline">  <strong>4.3</strong>  <strong>Pipeline de renderiza√ß√£o</strong> </h2><br><p>  Lembre-se de todo o processo de forma√ß√£o de um quadro de interface no iOS (pipeline de renderiza√ß√£o [WWDC 2014 Session 419. Gr√°ficos e anima√ß√µes avan√ßados para aplicativos iOS)): </p><br><p><img src="https://habrastorage.org/webt/wh/ac/dj/whacdjlwdz9p3yxk4q2lonad4ag.png"></p><br><p>  N√£o apenas o processo de nosso aplicativo √© respons√°vel pela forma√ß√£o do quadro - o Core Animation tamb√©m trabalha em um processo de sistema separado chamado Render Server. </p><br><p>  <strong>Como o quadro √© formado.</strong>  N√≥s (ou o sistema para n√≥s) criamos uma nova transa√ß√£o ( <code>CATransaction</code> ) no aplicativo com uma descri√ß√£o das altera√ß√µes na interface, ‚Äúconfirmamos‚Äù e transferimos para o Render Server.  Tudo, no lado da aplica√ß√£o, o trabalho est√° feito.  Em seguida, o servidor de renderiza√ß√£o decodifica a transa√ß√£o (√°rvore de renderiza√ß√£o), chama os comandos necess√°rios no chip de v√≠deo, desenha um novo quadro e o exibe na tela. </p><br><p>  Curiosamente, ao criar o quadro, um certo "multithreading" √© usado.  Se a taxa de atualiza√ß√£o da tela for de 60 quadros por segundo, um novo quadro ser√° formado no total, n√£o em 1/60, mas em 1/30 de segundo.  Isso ocorre porque enquanto o aplicativo est√° preparando um novo quadro, o Render Server ainda est√° processando o anterior: </p><br><p><img src="https://habrastorage.org/webt/vz/cp/oa/vzcpoae_zvhzw0zkhll1_tjuwwy.png"></p><br><p>  Grosso modo, o tempo total da forma√ß√£o do quadro antes de ser exibido na tela consiste em 1/60 segundo em nosso processo para a forma√ß√£o da transa√ß√£o e 1/60 segundo no processo do Render Server durante o processamento da transa√ß√£o. </p><br><p>  Eu gostaria de fazer a seguinte observa√ß√£o.  <strong>Podemos paralelizar o desenho de camadas</strong> e <a href="https://developer.apple.com/documentation/uikit/1623912-uigraphicsbeginimagecontextwitho">renderizar o</a> conte√∫do da <code>CGImage</code> <code>UIImage</code> / <code>CGImage</code> no fluxo Background.  Depois disso, no encadeamento principal, voc√™ precisa atribuir a imagem criada √† propriedade <a href="https://developer.apple.com/documentation/quartzcore/calayer/1410773-contents"><code>CALayer.contents</code></a> .  Em termos de desempenho, essa √© uma abordagem muito boa.  S√£o os desenvolvedores que o usam <a href="https://texturegroup.org/">Texture</a> .  Mas como podemos alterar o <code>CALayer.contents</code> apenas no processo de gerar uma transa√ß√£o no processo do nosso aplicativo, temos apenas 1/60 de segundo a 60 quadros para criar e substituir uma nova imagem, em vez de 1/30 de segundo (levando em conta otimiza√ß√µes e paraleliza√ß√£o do pipeline de renderiza√ß√£o com o Render Server ) </p><br><p>  Al√©m disso, o servidor de renderiza√ß√£o ainda pode lidar com mesclagem (veja abaixo) e cache de camada de curto prazo [iOS Core Animation: Advanced Techniques. Nick Lockwood].        1/60      <code>CALayer.contents</code> ,         .     . </p><br><p> <em>:    ,     .</em> </p><br><h2 id="44-samye-uyazvimye-po-proizvoditelnosti-mesta"> <strong>4.4.     </strong> </h2><br><p> <strong>Main-thread</strong> </p><br><p><img src="https://habrastorage.org/webt/yt/c7/2n/ytc72nywgvqohz44yx_lsr9jhti.png"></p><br><p> <strong><em> 1.     ( <code>CATransaction.commit</code> )</em></strong> -   <code>UIView.layoutSubviews</code>     <code>UIView</code> (,  <code>CALayer</code> ).   ,         <code>layoutSubviews</code> / <code>cellForRow</code> / <code>willDisplayCell</code> . </p><br><p> <strong><em> 2.    <a href="https://developer.apple.com/documentation/quartzcore/calayer/1410757-drawincontext%3Flanguage%3Dobjc"><code>drawInContext</code></a> / <a href="https://developer.apple.com/documentation/uikit/uiview/1622529-drawrect"><code>drawRect</code></a> .</em></strong>  -  Main-      ( <code>CATransaction.commit</code> ) ‚Äî  .                 ,    . </p><br><p> <strong><em> 3.     </em></strong> .          .        <code>CATransaction.commit</code> ,        ,  <a href="https://developer.apple.com/documentation/uikit/uiimage/1624092-draw"></a>    . </p><br><p> <strong><em> 4.   .</em></strong>                <code>UIImage</code> / <code>CGImage</code> . </p><br><p> <strong><em> 5.  </em></strong> .     Main-thread   ,     scroll.           -  ,       UI. </p><br><p> <strong><em> 6.    Main-.</em></strong>    , <code>RunLoop</code>  Main-   ,     ,   Main-.         . </p><br><p> <strong>GPU</strong> </p><br><p><img src="https://habrastorage.org/webt/xx/gl/cq/xxglcqd-3yjgmjsuxkppjbzbc38.png"></p><br><p> <strong><em>Blending</em></strong> .        GPU       (  Render Server       GPU,         ).   ,      ,      Background-. </p><br><p> <strong><em> </em></strong> . ,    <a href="https://developer.apple.com/documentation/uikit/uiblureffect"><code>UIBlurEffect</code></a> , <a href="https://developer.apple.com/documentation/uikit/uivibrancyeffect"><code>UIVibrancyEffect</code></a>    ,  ,    (Render Pass).      ,       ,    . </p><br><p> <strong>Offscreen rendering (Render Server)</strong> </p><br><p><img src="https://habrastorage.org/webt/zm/ru/b4/zmrub4eko8bdeelh2lbivcem8bi.png"></p><br><p> Render Server        .        , ,     : </p><br><ul><li> <a href="https://developer.apple.com/documentation/quartzcore/calayer/1410818-cornerradius"><code>cornerRadius</code></a> ‚Äî  Render Server      ,         ; </li><li> <a href="https://developer.apple.com/documentation/quartzcore/calayer/1410819-shadowradius"><code>shadowRadius</code></a> ‚Äî   Render Server    ,   ; </li><li> <a href="https://developer.apple.com/documentation/quartzcore/calayer/1410861-mask"><code>mask</code></a> ‚Äî        . </li></ul><br><p>    <code>CALayer</code> ,       ,    Offscreen rendering.    ,     <a href="https://developer.apple.com/documentation/uikit/uivisualeffect"><code>UIVisualEffect</code></a> (   ,     Render Server  CPU,   GPU). </p><br><p>  ,       . </p><br><hr><br><h1 id="5-instrumenty-izmereniy"> <strong>5.  </strong> </h1><br><p>    ,    ,    Time Profiler.   <a href="https://developer.apple.com/documentation/metal/using_metal_system_trace_in_instruments_to_profile_your_app">Metal System Trace</a> ‚Äî         Time Profiler    . </p><br><h2 id="51-metal-system-trace"> <strong>5.1. Metal System Trace</strong> </h2><br><p>  ,          ( ).   ,    : ,    . </p><br><p>  ,   Metal System Trace  ,           .     ,       Render Server.       ,      Main-,   ‚Äî ,     . </p><br><p><img src="https://habrastorage.org/webt/gy/pv/ay/gypvay-wwr1f0ldbjazina-ewtg.png"></p><br><p>      - ,   : </p><br><p><img src="https://habrastorage.org/webt/0r/af/6e/0raf6e-cvoukj_6jzt1o6frzjom.png"></p><br><p>  Metal System Trace   .     64- ,     iPhone 5s.  ,    <em></em>    .   , -   ,  ,          UI. </p><br><h2 id="52-fiksiruem-prosadki-proizvoditelnosti-v-kode-vo-vremya-raboty-prilozheniya"> <strong>5.2.         </strong> </h2><br><p>         . ,   - -  .         ,    <a href="https://developer.apple.com/documentation/quartzcore/cadisplaylink"><code>CADisplayLink</code></a> . </p><br><p>   <code>CADisplayLink</code>   <a href="https://developer.apple.com/documentation/quartzcore/cadisplaylink/1621257-timestamp"><code>timestamp</code></a> ‚Äî     (    Render Server).         <code>CADisplayLink.timestamp</code>     <code>timestamp</code> .   ,          (, 1/60 )  : </p><br><pre> <code class="plaintext hljs"> //  CADisplayLink. link = [CADisplayLink displayLinkWithTarget:target selector:selector] [link addToRunLoop:[NSRunLoop mainRunLoop] forMode:UITrackingRunLoopMode] //    CADisplayLink : diff = prevTimestamp - link.timestamp if (diff &gt; 1/fps) { //  freeze } prevTimestamp = link.timestamp</code> </pre> <br><p> <code>CADisplayLink</code>   <a href="https://developer.apple.com/documentation/uikit/uitrackingrunloopmode%3Flanguage%3Dobjc"><code>UITrackingRunLoopMode</code></a> ,       . </p><br><p>     Rendering Pipeline: <br><img src="https://habrastorage.org/webt/yv/ca/t3/yvcat3yxparod3whs19qzwwjzhw.png"></p><br><p>      UI-,         .    ¬´¬ª     <code>freezeFrameTimeRate</code> : </p><br><pre> <code class="plaintext hljs">scrollTime //    Scroll freezeFrameTime //    ,  "",       freezeFrameTimeRate = freezeFrameTime / scrollTime</code> </pre> <br><p>  ,            -    <code>UIView</code> .   ,      ¬´¬ª: </p><br><p><img src="https://habrastorage.org/webt/ws/l7/tr/wsl7trcro6gr-t7ax-paqn_rxls.png"></p><br><p>  ,          ,    ¬´ <code>UIView</code> ¬ª         .  Porque   ,   . , ,      ,     : <code>CADisplayLink</code> ,       Render Server    <code>link.timetamp</code> ,    Render Server     ,      .   60     UI-,         Render Server.   Render Server      ,     . </p><br><p>  ,     ,   ,  Render Server    .    <a href="https://developer.apple.com/documentation/metal/mtlcommandbuffer/1442997-addcompletedhandler%3Flanguage%3Dobjc">Metal</a> ,        Render Server. ,  ,       iOS,   Render Server            . </p><br><h2 id="kak-issledovat-problemy-rekomendacii"> <strong>  . </strong> </h2><br><p>   ,   ,      .             ,        . </p><br><p> :   ‚Äî   !          ‚Äî        . </p><br><hr><br><h1 id="zaklyuchenie">  <strong>Conclus√£o</strong> </h1><br><p>   ‚Äî               .    ,     ,      . </p><br><hr><br><h1 id="istochniki-informacii"> <strong> </strong> </h1><br><p>  ,        ‚Äî        .        ,   . </p><br><p>  ,        : </p><br><ol><li> <a href="https://developer.apple.com/documentation"> Apple</a> . </li><li> <a href="https://habr.com/ru/company/oleg-bunin/blog/437584/">    Auto Layout</a> . </li><li> <a href="https://constraints.cs.washington.edu/solvers/cassowary-tochi.pdf">The Cassowary Linear Arithmetic Constraint Solving Algorithm</a> . </li><li> iOS Core Animation: Advanced Techniques. Nick Lockwood. </li><li> WWDC 2014 Session 419. Advanced Graphics and Animations for iOS Apps. </li></ol><br><p><img src="https://habrastorage.org/webt/ij/vj/ex/ijvjexv2ppdy6bdkepcwbqk7wy8.png"></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt481626/">https://habr.com/ru/post/pt481626/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt481612/index.html">Nossa pequena contribui√ß√£o para a luta da Avalonia UI por menos plataformas</a></li>
<li><a href="../pt481616/index.html">Domo geod√©sico. Sobre o dispositivo e minha experi√™ncia em c√°lculos</a></li>
<li><a href="../pt481618/index.html">MVP no Unity ou como simplificar a vida</a></li>
<li><a href="../pt481620/index.html">Juniper SRX e Cisco ASA: pr√≥xima s√©rie</a></li>
<li><a href="../pt481624/index.html">Escrevendo um aplicativo no Flutter em conjunto com o Redux</a></li>
<li><a href="../pt481628/index.html">Regras para escrever etapas preliminares em casos de teste</a></li>
<li><a href="../pt481630/index.html">Melhores ferramentas e recursos √∫teis para tornar uma startup mais inteligente em 2019</a></li>
<li><a href="../pt481632/index.html">Fornecedores de nuvem: quem √© o melhor do mercado?</a></li>
<li><a href="../pt481634/index.html">Food Design Digest, novembro de 2019</a></li>
<li><a href="../pt481638/index.html">Por que modelos 3D de produ√ß√£o complexa s√£o √∫teis</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>