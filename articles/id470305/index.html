<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👷🏻 🗻 😣 Mempersiapkan Sertifikasi Spring Profesional. Wadah, IOC, Kacang 👩🏻‍💻 ♓️ ⚓️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Selamat siang, Habr. 


 Hari ini saya memutuskan untuk menyajikan kepada Anda terjemahan dari serangkaian artikel dalam persiapan untuk Sertifikasi P...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mempersiapkan Sertifikasi Spring Profesional. Wadah, IOC, Kacang</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/470305/"><p>  Selamat siang, Habr. </p><br><p>  Hari ini saya memutuskan untuk menyajikan kepada Anda terjemahan dari <a href="">serangkaian artikel</a> dalam persiapan untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sertifikasi Profesional Spring</a> . </p><br><p>  Terjemahan ini hanya artikel pertama, jika ditujukan kepada audiens, saya akan terus menerbitkan terjemahan. </p><br><div class="spoiler">  <b class="spoiler_title">Mengapa saya melakukan ini, karena sudah ada banyak bahan khusus?</b> <div class="spoiler_text"><ol><li>  Seringkali informasi di dalamnya tidak terstruktur, tidak dikumpulkan, atau tidak relevan <br></li><li>  Pengembang muda mungkin tidak tahu bahasa Inggris.  Siklus ini dapat digunakan tidak hanya untuk sertifikasi, tetapi juga untuk pelatihan diri / pengulangan materi. <br></li><li>  Bahan-bahan ini dapat digunakan dalam persiapan untuk wawancara, seperti  mereka diatur dalam bentuk pertanyaan dan jawaban. <br></li><li> Keuntungan penting, dan paling penting, QA ini dibuat dari pertanyaan dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Panduan Studi</a> Penting resmi. <br></li></ol><br><ul><li>  Saya sengaja melewatkan beberapa pertanyaan yang menurut saya berlebihan atau yang tidak ada dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">panduan</a> . </li></ul></div></div><br><div class="spoiler">  <b class="spoiler_title">Daftar isi</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ketergantungan injeksi, wadah, IOC, kacang</a> </li><li>  AOP (pemrograman berorientasi aspek) </li><li>  JDBC, Transaksi, JPA, Data Musim Semi </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Boot musim semi</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Musim semi mvc</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Keamanan musim semi</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SISA</a> </li><li>  Pengujian </li></ol></div></div><br><img src="https://habrastorage.org/webt/r4/jl/yi/r4jlyi8dwzp-e9xvywevoicmwsg.jpeg"><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Saya akan menulis daftar sumber dari mana penulis mengambil materi</b> <div class="spoiler_text"><ul><li>  Pola desain pegas 5 <br></li><li>  Spring in Action edisi ke-4 <br></li><li>  Keamanan Musim Semi - Edisi Ketiga <br></li><li>  Sertifikasi Core Spring 5 secara Detail oleh Ivan Krizsan <br></li><li>  Dokumentasi Pegas dan API Spring API <br></li></ul></div></div><br><p>  Jadi, mari kita mulai. </p><br><div class="spoiler">  <b class="spoiler_title">Apa itu injeksi ketergantungan (DI) dan apa manfaatnya?</b> <div class="spoiler_text"><p>  Ketergantungan injeksi adalah pola khusus yang mengurangi komunikasi antara komponen Pegas.  Jadi, ketika menerapkan DI, kode Anda menjadi lebih bersih, lebih sederhana, menjadi lebih mudah dipahami dan diuji. <br>  Menurut pola DI, membuat objek untuk dependensi ditransfer ke pabrik atau diberikan kepada pihak ketiga.  Ini artinya kita bisa fokus menggunakan benda-benda ini daripada membuatnya. </p><br><div class="spoiler">  <b class="spoiler_title">Manfaat DI</b> <div class="spoiler_text"><ul><li>  Mengurangi komunikasi antar bagian aplikasi <br></li><li>  Peningkatan pengujian <br></li><li>  Arsitektur Aplikasi yang Disempurnakan <br></li><li>  Mengurangi kode boilerplate <br></li><li>  Membakukan pengembangan aplikasi <br></li></ul></div></div></div></div><br><div class="spoiler">  <b class="spoiler_title">Mengapa antarmuka direkomendasikan untuk membuat kacang Spring?</b> <div class="spoiler_text"><ul><li>  Peningkatan pengujian.  Dalam pengujian, kacang dapat diganti dengan objek khusus (tiruan atau rintisan) yang mengimplementasikan antarmuka kacang. <br></li><li>  Memungkinkan Anda menggunakan mekanisme proxy dinamis dari JDK (misalnya, saat membuat repositori melalui Spring Data) <br></li><li>  Memungkinkan Anda menyembunyikan implementasinya <br></li></ul></div></div><br><div class="spoiler">  <b class="spoiler_title">Apa itu konteks aplikasi?</b> <div class="spoiler_text"><p> Dalam Spring Framework, antarmuka <code>org.springframework.factory.BeanFactory</code> menyediakan pabrik <code>org.springframework.factory.BeanFactory</code> , yang pada saat yang sama merupakan wadah aplikasi IoC.  Manajemen bean didasarkan pada konfigurasi (java atau xml). </p><br><p>  Antarmuka <code>org.springframework.context.ApplicationContext</code> adalah pembungkus atas pabrik kacang yang menyediakan beberapa fitur tambahan, seperti AOP, transaksi, keamanan, i18n, dll. </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Apa itu wadah dan apa siklus hidupnya?</b> <div class="spoiler_text"><p>  Dasar dari Kerangka Pegas adalah sebuah wadah, dan objek kami "hidup" dalam wadah ini. <br>  Wadah biasanya menciptakan banyak objek berdasarkan konfigurasi mereka dan mengelola siklus hidup mereka dari membuat objek hingga kehancuran. </p><br><p>  Wadah adalah objek yang mengimplementasikan antarmuka <b>ApplicationContext</b> . </p><br><div class="spoiler">  <b class="spoiler_title">Siklus hidup kontainer</b> <div class="spoiler_text"><ol><li>  Wadah dibuat saat aplikasi dimulai. <br></li><li>  Wadah membaca data konfigurasi <br></li><li>  Deskripsi tempat sampah dibuat dari data konfigurasi <br></li><li>  BeanFactoryPostProcessors menangani deskripsi bean <br></li><li>  Wadah tersebut membuat kacang menggunakan deskripsi mereka <br></li><li>  Kacang diinisialisasi - nilai properti dan dependensi tertanam dalam kacang <br></li><li>  BeanPostProcessor memulai metode panggilan balik <br></li><li>  Aplikasi aktif dan berjalan <br></li><li>  Penutupan aplikasi diinisialisasi <br></li><li>  Wadah ditutup <br></li><li>  Metode panggilan balik disebut <br></li></ol></div></div></div></div><br><div class="spoiler">  <b class="spoiler_title">Bagaimana cara membuat instance ApplicationContext?</b> <div class="spoiler_text"><p>  Spring menyediakan beberapa variasi konteks. </p><br><p>  Ada beberapa implementasi dasar antarmuka ApplicationContext: </p><br><ul><li>  FileSystemXmlApplicationContext <br></li><li>  ClassPathXmlApplicationContext <br></li><li>  AnnotationConfigApplicationContext <br></li><li>  XmlWebApplicationContext <br></li><li>  AnnotationConfigWebApplicationContext <br></li></ul><br><p>  Contoh membuat konteks: </p><br><pre> <code class="java hljs">ApplicationContext ctx = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileSystemXmlApplicationContext(                                     <span class="hljs-string"><span class="hljs-string">"c:/bean_properties.xml"</span></span>); ApplicationContext ctx = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AnnotationConfigApplicationContext(                            <span class="hljs-string"><span class="hljs-string">"com.springdemoapp.JavaConfig.class"</span></span>);</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Bisakah Anda menggambarkan siklus hidup kacang dalam wadah?</b> <div class="spoiler_text"><ol><li>  Memuat deskripsi nampan, membuat grafik dependensi (antara kacang) </li><li>  Membuat dan <code>BeanFactoryPostProcessors</code> </li><li>  Buat Kacang </li><li>  Spring menyuntikkan nilai dan dependensi ke dalam properti kacang </li><li>  Jika kacang mengimplementasikan metode <code>setBeanName()</code> dari antarmuka NameBeanAware, maka kacang ID diteruskan ke metode </li><li>  Jika kacang mengimplementasikan BeanFactoryAware, maka Spring membuat referensi ke pabrik kacang melalui <code>setBeanFactory()</code> dari antarmuka ini. </li><li>  Jika kacang mengimplementasikan antarmuka ApplicationContextAware, maka Spring membuat referensi ke ApplicationContext melalui <code>setApplicationContext()</code> . </li><li>  <code>BeanPostProcessor</code> adalah antarmuka khusus (tentangnya di bawah ini), dan Spring memungkinkan tempat sampah untuk mengimplementasikan antarmuka ini.  Dengan menerapkan metode <code>postProcessBeforeInitialization()</code> , Anda dapat mengubah instance bean sebelum menginisialisasi (bean) (menyetel properti, dll.) </li><li>  Jika metode panggilan balik didefinisikan, maka Spring memanggil mereka.  Sebagai contoh, ini adalah metode yang dianotasikan oleh <code>@PostConstruct</code> atau metode <code>initMethod</code> dari anotasi <code>@Bean</code> . </li><li>  Kacang sekarang siap digunakan.  Itu dapat diperoleh dengan menggunakan metode <code>ApplicationContext#getBean()</code> . </li><li>  Setelah konteks ditutup ( <code>close()</code> metode dari ApplicationContext), kacang hancur. </li><li>  Jika kacang memiliki metode yang dijelaskan oleh <code>@PreDestroy</code> , maka metode ini akan dipanggil sebelum kehancuran.  Jika kacang mengimplementasikan DisposibleBean, maka Spring akan memanggil metode <code>destroy()</code> untuk menghapus sumber daya atau mematikan proses dalam aplikasi.  Jika metode <code>@Bean</code> didefinisikan dalam <code>destroyMethod</code> , maka itu juga disebut. <br><img src="https://habrastorage.org/webt/kx/at/5e/kxat5ery0dcq_sujzijmiqyutda.png"></li></ol></div></div><br><div class="spoiler">  <b class="spoiler_title">Bagaimana cara mendapatkan ApplicationContext dalam tes integrasi?</b> <div class="spoiler_text"><p>  Jika Anda menggunakan JUnit 5, maka Anda harus menentukan 2 anotasi: </p><br><ul><li>  @ExtendWith (TestClass.class) - digunakan untuk menunjukkan kelas uji <br></li><li>  @ContextConfoguration (classes = JavaConfig.class) - memuat konfigurasi java / xml untuk membuat konteks dalam pengujian <br></li></ul><br><p>  Anda dapat menggunakan anotasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>@SpringJUnitConfig</code></a> , yang menggabungkan kedua anotasi ini. <br>  Anda dapat menggunakan anotasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>@SpringJUnitWebConfig</code></a> untuk menguji lapisan web. </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Bagaimana cara mematikan konteks dalam suatu aplikasi?</b> <div class="spoiler_text"><p>  Jika ini bukan aplikasi web, maka ada 2 cara: </p><br><ul><li>  Daftarkan shutdown-hook menggunakan pemanggilan metode <code>registerShutdownHook()</code> , itu juga diimplementasikan dalam kelas AbstractApplicationContext.  Ini adalah metode yang disukai. </li><li>  Anda dapat memanggil metode <code>close()</code> dari kelas AbstractApplicationContext. </li></ul><br><p>  Dalam aplikasi Spring Boot: </p><br><ul><li>  Spring Boot akan mendaftarkan hook shutdown untuk Anda sendiri. </li></ul></div></div><br><div class="spoiler">  <b class="spoiler_title">Apa itu konfigurasi Java?</b>  <b class="spoiler_title">Bagaimana ini diterapkan?</b> <div class="spoiler_text"><p>  Untuk membuat kelas dengan konfigurasi berdasarkan kode Java, Anda perlu memberikan anotasi dengan <br>  <code>@Configuration</code> . <br>  Kelas ini akan berisi metode pabrik untuk membuat kacang dalam wadah. <br>  Metode-metode ini harus dijelaskan dengan penjelasan <code>@Bean</code> . </p><br><p>  Contoh: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Configuration</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DSConfig</span></span></span><span class="hljs-class"> </span></span>{  <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span>  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> DataSource </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dataSource</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{      <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> DataSourceBuilder          .create()          .username(<span class="hljs-string"><span class="hljs-string">""</span></span>)          .password(<span class="hljs-string"><span class="hljs-string">""</span></span>)          .url(<span class="hljs-string"><span class="hljs-string">""</span></span>)          .driverClassName(<span class="hljs-string"><span class="hljs-string">""</span></span>)          .build();  } }</code> </pre> <br><p>  Kelas ini akan menempatkan instance kelas DataSource dalam wadah.  Nantinya dapat digunakan saat mengakses database. </p></div></div><br><div class="spoiler">  <b class="spoiler_title">DI menggunakan anotasi, pemindaian kelas</b> <div class="spoiler_text"><p>  Pemindaian komponen - Pegas secara otomatis mendeteksi kacang yang ada di wadah.  Ini adalah tempat sampah dengan anotasi-stereotip. </p><br><p>  Namun, pemindaian komponen tidak diaktifkan secara default. <br>  Untuk mengaktifkan pemindaian, anotasi kelas @ Konfigurasi dengan anotasi <code>@ComponentScanning</code> .  Spring akan secara otomatis memindai paket yang berisi kelas ini dan semua sub-paketnya. <br>  Anda dapat menentukan paket lain untuk pemindaian, dan bahkan kelas: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// 2  @Configuration(basePackages = {"soundsystem", "video"})</span></span></code> </pre> <br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//  @Configuration(basePackageClasses = "MyClass.class")</span></span></code> </pre> <br><p>  Autowiring - Pegas akan secara otomatis menyuntikkan dependensi saat memindai atau menempatkan nampan di dalam wadah. <br>  Ketergantungan injeksi menggunakan anotasi <code>@Autowire</code> . </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Apa itu stereotip (anotasi-stereotip)?</b> <div class="spoiler_text"><p>  Stereotip adalah penjelasan yang menunjukkan fungsi khusus. <br>  Semua stereotip termasuk anotasi <code>@Component</code> . </p><br><div class="scrollable-table"><table><tbody><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">Komponen</a> </td><td>  Anotasi root yang menandai kelas sebagai kandidat untuk implementasi otomatis </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">Pengendali</a> </td><td>  Menunjukkan bahwa kelas adalah pengontrol untuk mengirim data ke depan. <br></td></tr><tr><td>  @RestController </td><td>  Menunjukkan bahwa kelas adalah pengontrol untuk REST. <br>  Berisi anotasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">Controller</a> dan @ResponseBody </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">Layanan</a> </td><td>  Menunjukkan bahwa kelas adalah layanan untuk mengeksekusi logika bisnis. </td></tr><tr><td>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">Repositori</a> </td><td>  Menunjukkan bahwa kelas adalah repositori untuk bekerja dengan database. </td></tr><tr><td>  @ Konfigurasi </td><td>  Menunjukkan bahwa kelas berisi konfigurasi Java (metode @ Bean) </td></tr></tbody></table></div></div></div><br><div class="spoiler">  <b class="spoiler_title">Apa cakupan bin?</b>  <b class="spoiler_title">Apa visibilitas default mereka?</b> <div class="spoiler_text"><p>  Lingkup - ruang lingkup.  Ada 2 cakupan default. </p><br><div class="scrollable-table"><table><tbody><tr><td>  Singleton <br></td><td>  Lingkup default.  Hanya ada 1 contoh kacang dalam wadah <br></td></tr><tr><td>  Prototipe <br></td><td>  Sejumlah instance bin dapat berada di wadah <br></td></tr></tbody></table></div><br><p>  Dan 4 cakupan dalam aplikasi web. </p><br><div class="scrollable-table"><table><tbody><tr><td>  Minta <br></td><td>  Cakupan - 1 permintaan HTTP.  Kacang baru dibuat untuk setiap permintaan. <br></td></tr><tr><td>  Sesi <br></td><td>  Lingkup - 1 sesi.  Kacang baru dibuat untuk setiap sesi. <br></td></tr><tr><td>  Aplikasi <br></td><td>  Lingkup - Siklus Hidup ServletContext <br></td></tr><tr><td>  Soket web <br></td><td>  Lingkup - Siklus Hidup WebSocket <br></td></tr></tbody></table></div><br><p>  Lingkup ditunjukkan menggunakan penjelasan <code>@Bean</code> pada metode <code>@Bean</code> . </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Bagaimana berbagai cakupan dan multithreading terkait?</b> <div class="spoiler_text"><p>  Prototipe Lingkup tidak aman karena thread  itu tidak menjamin bahwa instance yang sama akan dipanggil hanya dalam 1 utas. </p><br><p>  Singleton Scope, di sisi lain, aman dari benang. </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Bagaimana kacang dibuat: secara instan atau malas?</b>  <b class="spoiler_title">Bagaimana cara mengubah perilaku ini?</b> <div class="spoiler_text"><p>  Kacang singleton biasanya dibuat segera setelah pemindaian. <br>  Kacang prototipe biasanya dibuat hanya atas permintaan. </p><br><p>  Anda dapat menggunakan anotasi <code>@Lazy</code> untuk mengindikasikan cara menginisialisasi. <br>  Itu ditempatkan pada metode @ Bean, pada kelas @ konfigurasi, atau pada kelas @ komponen. <br>  Bergantung pada parameter (benar atau salah) yang diterima oleh anotasi, inisialisasi akan menjadi malas atau akan segera terjadi.  Secara default (mis., Tanpa menentukan parameter), true digunakan. </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Apa yang terjadi jika sebuah bin dengan satu ruang lingkup tertanam dalam sebuah bin dengan ruang lingkup lain?</b> <div class="spoiler_text"><p>  Kacang singleton dapat ditanam di kacang lainnya. </p><br><p>  Hanya <em><code>prototype</code></em> atau <em><code>singleton</code></em> dapat tertanam dalam <em><code>singleton</code></em> . <br>  Jika Anda menerapkan prototipe, maka prototipe unik akan dibuat untuk setiap singleton. </p><br><p>  Prototipe dapat menjadi ketergantungan bagi kacang apa pun. <br>  Anda hanya dapat mengimplementasikan singleton atau prototipe. </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Apa itu BeanFactoryPostProcessor dan kapan itu digunakan?</b> <div class="spoiler_text"><ul><li>  <code>BeanFactoryPostProcessor</code> berfungsi pada deskripsi bin atau metadata konfigurasi sebelum bin dibuat. </li><li>  Spring menyediakan beberapa implementasi <code>BeanFactoryPostProcessor</code> berguna, misalnya, membaca file properti dan mendapatkan properti <code>BeanFactoryPostProcessor</code> dari mereka. </li><li>  Anda dapat menulis implementasi BFPP Anda sendiri. </li></ul></div></div><br><div class="spoiler">  <b class="spoiler_title">Mengapa Anda memerlukan metode @ Bean statis?</b> <div class="spoiler_text"><p>  Untuk menggunakan BFPP khusus.  Anda dapat mengganti mekanisme untuk mendapatkan data dari metafile. </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> PropertySourcesPlaceholderConfigurer </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pspc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{    <span class="hljs-comment"><span class="hljs-comment">//,    pspc }</span></span></code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Jelaskan properti anotasi @Bean</b> <div class="spoiler_text"><ul><li>  <code>destroyMethod</code> - menunjuk ke metode panggilan balik.  Metode ini di tempat sampah. </li><li>  <code>initMethod</code> - menunjuk ke metode panggilan balik.  Metode ini di tempat sampah. </li><li>  <code>name</code> - nama kacang.  Secara default, nama kacang adalah nama metode. </li><li>  <code>value</code> - alias untuk nama () </li></ul></div></div><br><div class="spoiler">  <b class="spoiler_title">Apa itu BeanPostProcessor dan apa bedanya dengan BeanFactoryPostProcessor?</b> <div class="spoiler_text"><p>  Spring menggunakan beberapa BeanPostProcessors. <br>  Misalnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>CommonAnnotationPostProcessor</code></a> atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>AutowiredAnnotationBeanPostProcessor</code></a> . <br>  BPP bekerja dengan instance kacang, mis.  wadah membuat tempat sampah, dan kemudian BPP dimulai. </p><br><img src="https://habrastorage.org/webt/7u/-v/bt/7u-vbtqvcgkoscws4xca3e90yrw.png"></div></div><br><div class="spoiler">  <b class="spoiler_title">Apa itu metode panggilan balik dan bagaimana menggunakannya?</b> <div class="spoiler_text"><p>  Ada 3 opsi untuk membuat metode tersebut: </p><br><ul><li>  <code>@PreDestroy</code> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penjelasan</a> <code>@PostConstruct</code> </li><li>  <code>destroyMethod</code> dan <code>destroyMethod</code> dalam penjelasan <code>destroyMethod</code> mengarah ke metode di kelas bean </li><li>  <code>InitializingBean#afterPropertiesSet()</code> dan <code>DisposableBean#destroy()</code> .  Untuk mengganti metode ini, Anda perlu mengimplementasikan antarmuka yang sesuai. </li></ul><br><img src="https://habrastorage.org/webt/y6/yz/yx/y6yzyxkd94o9omsqbjimep2fowg.png"></div></div><br><div class="spoiler">  <b class="spoiler_title">Bagaimana saya bisa menggunakan anotasi @ Autowire dan apa perbedaannya?</b> <div class="spoiler_text"><p>  Berikut ini adalah jenis DI yang dapat digunakan dalam aplikasi Anda: </p><br><ul><li>  Konstruktor DI </li><li>  Setter di </li><li>  Bidang di </li></ul><br><p>  DI melalui konstruktor dianggap sebagai cara terbaik, karena  baginya tidak perlu menggunakan refleksi, dan juga dia tidak memiliki kelemahan DI melalui setter. <br>  DI melalui bidang tidak dianjurkan, karena  Untuk ini, refleksi digunakan yang mengurangi produktivitas. <br>  DI melalui konstruktor dapat menyebabkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dependensi melingkar</a> .  Untuk menghindari hal ini, Anda dapat menggunakan inisialisasi malas bean atau DI melalui setter. </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Jelaskan perilaku anotasi @Autowired</b> <div class="spoiler_text"><ol><li>  Wadah menentukan jenis objek yang akan ditanam. </li><li>  Wadah mencari kacang dalam konteks (alias wadah) yang cocok dengan jenis yang diinginkan </li><li>  Jika ada beberapa kandidat, dan salah satunya ditandai sebagai <code>@Primary</code> , maka itu akan diterapkan </li><li>  Jika penjelasan <code>@Autowire</code> + <code>Qualifier</code> digunakan, wadah akan menggunakan informasi dari <code>@Qualifier</code> untuk mengetahui komponen mana yang akan digunakan </li><li>  Jika tidak, wadah akan berusaha menyuntikkan komponen berdasarkan nama atau ID-nya. </li><li>  Jika tidak ada metode yang berhasil, pengecualian akan dilemparkan </li></ol><br><p>  Wadah menangani DI menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">AutowiredAnnotationBeanPostProcessor</a> .  Dalam hal ini, anotasi tidak dapat digunakan di BeanFactoryPP atau BeanPP. </p><br><p>  Jika objek yang disuntikkan adalah array, koleksi, atau peta dengan generik, maka Spring akan menanamkan semua kacang yang berjenis dalam array ini (atau struktur data lain).  Dalam kasus peta, kuncinya adalah nama bean. </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// ,   DI @Authowired(required = true/false)</span></span></code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Bagaimana cara membuat DI di bidang pribadi?</b> <div class="spoiler_text"><p>  Anda dapat menggunakan berbagai jenis implementasi: </p><br><ul><li>  Konstruktor </li><li>  Setter </li><li>  Injeksi lapangan </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">Nilai</a> </li></ul></div></div><br><div class="spoiler">  <b class="spoiler_title">Bagaimana cara menggunakan @Qualifier melengkapi @Autowired?</b> <div class="spoiler_text"><p>  Spring menyediakan anotasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">Kualifikasi</a> untuk mengatasi masalah ambiguitas DI. </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-meta"><span class="hljs-meta">@Qualifier</span></span>(<span class="hljs-string"><span class="hljs-string">"SomeClass1"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> SomeClass </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getField</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{...} <span class="hljs-comment"><span class="hljs-comment">//… @Autowire @Qualifier("SomeField1") public SomeClass someField;</span></span></code> </pre> <br><p>  Jika wadah memiliki beberapa nampan dari jenis yang sama (SomeClass), maka wadah akan menerapkan persis tempat itu, di atas metode @ Bean yang ada kualifikasi yang sesuai.  Anda juga tidak bisa menempatkan kualifikasi pada suatu metode, tetapi menggunakan nama bean sebagai parameter kualifikasi. <br>  Nama kacang dapat ditentukan melalui parameter anotasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">Bean</a> , dan secara default, ini adalah nama metode pabrik. </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Apa objek proxy dan jenis objek proxy apa yang dapat dibuat Spring?</b> <div class="spoiler_text"><p>  Proxy adalah objek khusus yang memiliki metode publik yang sama dengan kacang, tetapi yang memiliki fungsi tambahan. <br>  Dua jenis proksi: </p><br><ul><li>  JDK-proxy - proxy dinamis.  API dibangun ke dalam JDK.  Perlu antarmuka </li><li>  Proxy CGLib - tidak dibangun ke dalam JDK.  Digunakan saat antarmuka objek tidak tersedia. </li></ul><br><p>  Pro dari objek proxy: </p><br><ul><li>  Izinkan untuk menambahkan ekstra.  logika - manajemen transaksi, keamanan, pencatatan </li><li>  Memisahkan beberapa kode (logging, dll.) Dari logika utama </li></ul></div></div><br><div class="spoiler">  <b class="spoiler_title">Bagaimana kacang tunggal diterapkan?</b> <div class="spoiler_text"><p>  Jika tidak ada instance kacang dalam wadah, metode @ Bean disebut.  Jika ada contoh kacang, maka kacang yang sudah dibuat dikembalikan. </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Apa itu profil?</b>  <b class="spoiler_title">Apa alasan mereka menggunakannya?</b> <div class="spoiler_text"><p>  Saat menggunakan konfigurasi Java, Anda dapat menggunakan anotasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>@Profile</code></a> . <br>  Ini memungkinkan Anda untuk menggunakan pengaturan yang berbeda untuk Spring, tergantung pada profil yang ditentukan. <br>  Itu dapat ditempatkan pada kelas-kelas @Configuration dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">Component</a> , juga pada metode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">Bean</a> . </p><br><pre> <code class="java hljs">Profile(<span class="hljs-string"><span class="hljs-string">"!test"</span></span>) <span class="hljs-comment"><span class="hljs-comment">//   ,  </span></span></code> </pre> <br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Bean</span></span>(<span class="hljs-string"><span class="hljs-string">"dataSource"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@Profile</span></span>(<span class="hljs-string"><span class="hljs-string">"production"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> DataSource </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">jndiDataSource</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{...} <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span>(<span class="hljs-string"><span class="hljs-string">"dataSource"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@Profile</span></span>(<span class="hljs-string"><span class="hljs-string">"development"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> DataSource </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">standaloneDataSource</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{...}</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Bagaimana cara menanamkan nilai sederhana dalam properti di Spring?</b> <div class="spoiler_text"><p>  Anda dapat menggunakan anotasi <code>@Value</code> untuk <code>@Value</code> . <br>  Nilai tersebut dapat diperoleh dari file properti, dari sampah, dll. </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Value</span></span>(<span class="hljs-string"><span class="hljs-string">"$some.key"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> String stringWithDefaultValue;</code> </pre> <br><p>  String akan disematkan dalam variabel ini, misalnya, dari properti atau dari tampilan. </p></div></div><br><blockquote>  Seperti biasa, silakan kirim koreksi atau kesalahan yang ditemukan di PM. </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id470305/">https://habr.com/ru/post/id470305/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id470289/index.html">Bahasa pemrograman impian saya</a></li>
<li><a href="../id470295/index.html">Enkripsi SQlite DB sederhana</a></li>
<li><a href="../id470299/index.html">Manajemen Koneksi SignalR yang Efisien</a></li>
<li><a href="../id470301/index.html">Pohon Kata Kunci: analisis grafik untuk ekstraksi semantik</a></li>
<li><a href="../id470303/index.html">Instal server tftp pada CentOS 8 atau RedHat 8</a></li>
<li><a href="../id470309/index.html">Xamarin.Forms Shell</a></li>
<li><a href="../id470311/index.html">Mainan Kayu, Bagian Tujuh - 1993</a></li>
<li><a href="../id470313/index.html">Mainan Kayu, Bagian Delapan - 1994</a></li>
<li><a href="../id470317/index.html">C ++ lembar contekan singkatan dan banyak lagi. Bagian 2: "dan tidak hanya"</a></li>
<li><a href="../id470321/index.html">Mainan Kayu, Bagian Sembilan - 1995</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>