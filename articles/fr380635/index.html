<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✅ 🧑🏽 📵 Exploiter des bitcoins sur IBM 1401, un vétéran de 55 ans 🏹 📳 ⚔️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Inspiré par la publication de l'utilisateur mark_ablov« En utilisant du bitcoin avec du papier et un stylo », nous avons décidé que les lecteurs de hi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Exploiter des bitcoins sur IBM 1401, un vétéran de 55 ans</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/380635/"><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inspiré par la publication de l'utilisateur </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mark_ablov</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">« </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En utilisant du bitcoin avec du papier et un stylo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> », nous avons décidé que les lecteurs de hiktime seraient intéressés par les autres idées folles que l'auteur du message original, Ken Shirriff, avait réussi à réaliser.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Le mainframe IBM des années 60 du siècle dernier peut-il être utilisé pour </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">extraire des</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bitcoins? J'ai décidé de vérifier cette idée apparemment folle. J'ai injecté l'algorithme de hachage Bitcoin dans du code assembleur pour IBM 1401 et l'ai testé en pratique en l'exécutant sur un modèle réalisable de cet ancien ordinateur central. </font></font><br>
<br>
<img src="https://habrastorage.org/files/a33/6cd/657/a336cd6572dd402b8af57646e03fa39e.jpg"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La carte avec laquelle les hachages SHA-256 ont été calculés sur le mainframe IBM 1401. Une impression est visible derrière la carte, montrant l'entrée de l'algorithme et le hachage résultant</font></font></i><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il s'est avéré qu'en utilisant cet ordinateur, vous pouvez extraire, mais ce processus prendra tellement de temps que même toute la durée de vie de l'Univers peut ne pas être suffisante pour réussir l'extraction d'un bloc. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alors que le matériel moderne vous permet de calculer des milliards de hachages par seconde, l'ordinateur 1401 consacre 80 secondes chacun à calculer un seul hachage. </font><font style="vertical-align: inherit;">Les progrès des performances informatiques au cours des dernières décennies sont évidents, ce qui est clairement décrit par la loi de Gordon Moore. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les cartes perforées qui ont participé à l'expérience, ainsi que l'impression SHA-256 avec une imprimante linéaire sont illustrées sur la photo ci-dessus (la première carte perforée ne sert qu'à la beauté - il n'a pas été facile de percer ce modèle). </font><font style="vertical-align: inherit;">Notez que la deuxième ligne se termine par un groupe de zéros; </font><font style="vertical-align: inherit;">cela signifie un hachage réussi.</font></font><br>
 <habracut></habracut><br>
<h2><font color="170ec7"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Principe de minage de Bitcoin</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Récemment, la monnaie électronique Bitcoin (Bitcoin), que les internautes peuvent transférer entre eux, a été très populaire. Pour comprendre l'essence du travail de cette crypto-monnaie, le système Bitcoin peut être présenté sous la forme d'une sorte de journal comptable, qui stocke des enregistrements sur le propriétaire des pièces numériques (bitcoins) et le nombre de pièces dont il dispose. Les membres Bitcoin peuvent se transférer des pièces numériques entre eux. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il convient de noter que le système Bitcoin est décentralisé: il ne dispose pas d'un seul serveur de régulation qui surveillerait l'avancement des transactions. Au lieu de cela, les enregistrements sont envoyés sur un réseau distribué à partir de milliers d'ordinateurs sur Internet.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La difficulté est qu'un tel système distribué doit en quelque sorte garantir que tous les utilisateurs sont d'accord sur les enregistrements. Autrement dit, les utilisateurs consciencieux doivent confirmer la validité de la transaction, l'approuver, malgré la présence possible de fraudeurs et de réseaux lents. La solution à ce problème a été la soi-disant «exploitation minière». Environ toutes les 10 minutes pendant le processus d'extraction, un bloc de transactions sortantes est confirmé, par conséquent, il est considéré comme officiellement confirmé.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le processus d'extraction, basé sur une cryptographie fiable, est extrêmement compliqué, donc personne ne peut contrôler les transactions qui sont extraites. En particulier, l'idée clé du système Bitcoin est que le résultat du travail est difficile et difficile, mais facile à vérifier. Il s'agit de la technologie dite de «preuve de travail». </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le processus d'extraction de blocs nécessite un énorme coût de calcul. Cependant, une fois le blocage confirmé, les utilisateurs d'égal à égal peuvent facilement vérifier sa validité. La complexité de l'exploitation minière empêche l'utilisation frauduleuse de Bitcoin, et la facilité de vérifier la validité du bloc permet aux utilisateurs d'avoir confiance en la validité des transactions.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un effet secondaire de l'exploitation minière est l'ajout de nouveaux bitcoins au système. Actuellement, tous ceux qui confirment le bloc reçoivent 25 bitcoins générés pour cela (maintenant le coût de ce nombre de pièces virtuelles en termes monétaires traditionnels est d'environ 6 mille dollars américains). Cet encouragement encourage les mineurs à travailler dur et à dépenser leurs ressources pour l'exploitation minière. Étant donné la possibilité de recevoir 6 000 dollars toutes les 10 minutes, l'exploitation minière semble être une véritable «mine d'or», encourageant les utilisateurs à dépenser des sommes importantes en matériel pour l'exploitation minière.</font></font><br>
<br>
<img src="https://habrastorage.org/files/fb4/5d2/b88/fb45d2b8850d4f18ad691aacfc300506.jpg"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'imprimante en ligne et l'ordinateur central IBM 1401 sont présentés au Computer History Museum. Cet ordinateur exécutait mon programme. La console est située en haut à gauche. Les panneaux rectangulaires foncés de l'ordinateur sont les «portes» des racks inclinables, offrant un accès pour l'entretien.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Le processus d'extraction est extrêmement compliqué, mais le résultat est très facile à vérifier. Le minage de Bitcoin utilise la cryptographie avec une fonction de hachage appelée double SHA-256. Le hachage prend un bloc de données à l'entrée et le réduit à une valeur de hachage inférieure (dans ce cas, 256 bits).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'algorithme de hachage cryptographique ne vous permettra pas d'obtenir la valeur de hachage souhaitée sans avoir à trier la masse de données à l'entrée. Cependant, après avoir trouvé une entrée qui donne la valeur souhaitée, tout le monde peut facilement vérifier le hachage. Par conséquent, le hachage cryptographique est un bon moyen d'implémenter des bitcoins de «preuve de travail».</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Plus en détail, afin de restreindre un bloc, vous devez d'abord collecter de nouvelles transactions dans un bloc. Ensuite, vous devez hacher le bloc pour obtenir (essentiellement au hasard) la valeur de hachage du bloc. Si la valeur de hachage commence par 16 zéros, le bloc est considéré comme confirmé avec succès et envoyé au réseau Bitcoin. La plupart du temps, le hachage échoue, vous modifiez donc légèrement le bloc et réessayez encore et encore, après plus d'un milliard d'opérations de calcul. Toutes les 10 minutes environ, quelqu'un réussit à confirmer le blocage et le processus recommence. Cela rappelle une loterie à laquelle les mineurs participent, faisant une tentative après une tentative, jusqu'à ce que quelqu'un devienne un «gagnant». La complexité du processus de hachage est difficile à visualiser: il est plus facile de trouver un grain de sable dans tout le sable de la Terre que de trouver une valeur de hachage valide.Pour rechercher de telles valeurs de hachage, les mineurs utilisent des centres de données équipés de matériel spécial pour l'extraction.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je simplifie délibérément bon nombre des explications de cet article. </font><font style="vertical-align: inherit;">Si vous souhaitez en savoir plus sur le système Bitcoin et l'exploitation minière, je vous conseille d'étudier mes articles La </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">difficile expérience de l'extraction de bitcoins</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et les </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dures leçons de l'extraction de bitcoin</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h2><font color="170ec7"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Algorithme de hachage Bitcoin SHA-256</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maintenant, je vais regarder la fonction de hachage utilisée par Bitcoin, qui est basée sur une fonction de hachage cryptographique standard appelée SHA-256. Le système Bitcoin utilise un «double SHA-256». Cela signifie que la fonction SHA-256 est exécutée deux fois. L'algorithme SHA-256 est si simple que vous pouvez l'exécuter littéralement en utilisant uniquement un </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">crayon et du papier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , et l'algorithme vous permet de mélanger les données de manière imprévisible. L'algorithme accepte des blocs de 64 octets en entrée, traite les données cryptographiquement et produit 256 bits (32 octets) de données cryptées. L'algorithme utilise un tour, qui est répété 64 fois. L'illustration ci-dessous montre un tour de l'algorithme, qui prend huit blocs de 4 octets, A à H, effectue plusieurs opérations et produit de nouvelles valeurs pour A à N.</font></font><br>
<br>
<img src="https://habrastorage.org/files/bcf/3bd/18f/bcf3bd18f62848598a024da9361f49cb.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Round SHA-256, utilisant </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wikipedia</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> comme exemple </font><font style="vertical-align: inherit;">, par kockmeyer, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CC BY-SA 3.0</font></font></a></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Les blocs bleu foncé mélangent les bits de manière non linéaire, ce qui est difficile pour l'analyse cryptographique. (Si vous parvenez à trouver un moyen mathématiquement plus rapide d'obtenir des hachages réussis, vous pouvez contrôler l'extraction des bitcoins). La cellule "select" Ch sélectionne les bits de F ou G, en fonction de la valeur de l'entrée E. Les cellules Σ "sum" font tourner les bits A (ou E) générant trois versions décalées cycliques, puis les additionnent ensemble modulo 2.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La cellule majoritaire Ma vérifie les bits à chaque position de A, B et C et sélectionne 0 ou 1, selon la valeur qui est majoritaire. </font><font style="vertical-align: inherit;">Les globules rouges effectuent des ajouts 32 bits, générant de nouvelles valeurs pour A et E. L'entrée Wt est basée sur une entrée légèrement traitée. </font><font style="vertical-align: inherit;">(C'est là que le bloc d'entrée est introduit dans l'algorithme.) L'entrée Kt est une constante définie pour chaque tour. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selon l'illustration ci-dessus, seuls A et E sont modifiés par tour. Les valeurs restantes sont ignorées telles quelles. </font><font style="vertical-align: inherit;">L'ancienne valeur de A devient la nouvelle valeur de B, l'ancienne valeur de B devient la nouvelle valeur de C, etc. </font><font style="vertical-align: inherit;">Bien que chaque tour de SHA-256 modifie légèrement les données, après 64 tours, les données d'entrée sont complètement mélangées, donnant une valeur de hachage imprévisible.</font></font><br>
<br>
<h2><font color="170ec7"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ibm 1401</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'ai décidé d'exécuter cet algorithme sur le mainframe IBM 1401. Cet ordinateur est apparu en 1959 et au milieu des années 60 est devenu l'ordinateur le plus vendu - à cette époque, plus de 10 000 machines étaient activement utilisées. L'ordinateur 1401 n'était pas un ordinateur très puissant, même pour 1960. Cependant, il était abordable pour les moyennes entreprises qui auparavant ne pouvaient pas se permettre d'avoir un ordinateur, car il pouvait être loué pour peu d'argent - 2 500 $ par mois. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'IBM 1401 n'utilisait pas de puces de silicium. De plus, dans cet ordinateur, il n'y avait pas de puces du tout. Ses transistors étaient construits sur des semi-conducteurs, des cristaux de germanium, qui étaient utilisés avant le silicium. Des transistors, ainsi que d'autres composants, ont été installés sur des cartes de la taille de cartes à jouer appelées </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cartes SMS</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. L'ordinateur comportait des milliers de ces cartes, qui ont été installées sous la forme de racks appelés «portes». L'IBM 1401 possède vingt «portes» de ce type qui ont été proposées pour la maintenance informatique. Dans l'illustration ci-dessus, une porte ouverte est visible, donnant accès aux micropuces et aux câbles. </font></font><br>
<br>
<img src="https://habrastorage.org/files/233/edb/2cc/233edb2cc53448849fd26f814e12c8c6.jpg"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'illustration montre un rack ouvert (appelé «porte») de l'unité centrale IBM 1401. La photo montre des cartes SMS connectées au circuit. Ce rack contient des lecteurs de bande</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le principe de fonctionnement d'un tel ordinateur était très différent des PC modernes. Cet ordinateur n'utilisait pas des octets 8 bits, mais des caractères 6 bits basés sur un nombre décimal codé binaire (BCD). Étant donné que cet ordinateur était une machine à calculer pour résoudre les problèmes économiques, il utilisait l'arithmétique décimale plutôt que binaire, et chaque caractère dans la mémoire avait une valeur numérique de 0 à 9. La mémoire de l'ordinateur sur des noyaux magnétiques contenait 4000 caractères. Un module d'extension mémoire de la taille d'un lave-vaisselle a augmenté la capacité mémoire de 12 000 caractères. La saisie des données dans l'ordinateur a été effectuée à l'aide de cartes perforées. Le lecteur de cartes lit les données et les programmes des cartes. Les données de sortie ont été imprimées par une imprimante à grande vitesse ou perforées sur des cartes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Musée d'histoire de l' </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">ordinateur</font></a><font style="vertical-align: inherit;"> Musée d'histoire de l' </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ordinateur</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">à Mountain View, il dispose de deux ordinateurs centraux IBM 1401. Sur l'un d'eux, j'ai exécuté le code de hachage SHA-256. </font><font style="vertical-align: inherit;">Je parle plus d'IBM 1401 dans mon article </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fractals sur IBM 1401</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
.</font></font><br>
<h2><font color="170ec7"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exécution de SHA-256 sur un IBM 1401</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'ordinateur IBM 1401 est certainement la pire de toutes les machines qui pourraient être choisies pour exécuter l'algorithme de hachage SHA-256. </font><font style="vertical-align: inherit;">Pour fonctionner efficacement, cet algorithme nécessite des machines capables d'effectuer des opérations binaires sur des mots 32 bits. </font><font style="vertical-align: inherit;">Malheureusement, IBM 1401 ne prend en charge ni les mots ni les octets 32 bits. </font><font style="vertical-align: inherit;">Cet ordinateur fonctionne avec des caractères 6 bits et n'autorise pas les opérations sur les bits. </font><font style="vertical-align: inherit;">De plus, au lieu de binaire, l'arithmétique décimale a été utilisée. </font><font style="vertical-align: inherit;">Par conséquent, l'algorithme sur l'ordinateur 1401 sera lent et incommode pour l'utilisateur.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'ai fini par utiliser un caractère par bit. La valeur 32 bits a été stockée sous forme de 32 caractères, soit «0» ou «1». Mon code devait effectuer des opérations au niveau du bit, des multiplications et des ajouts caractère par caractère, vérifier chaque caractère et décider quoi en faire. Comme vous vous en doutez, l'exécution du code a pris beaucoup de temps.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ensuite, je présente le code assembleur que j'ai écrit. </font><font style="vertical-align: inherit;">En général, le principe du code est décrit dans les commentaires. </font><font style="vertical-align: inherit;">À la fin du code, il y a une table de constantes nécessaires pour l'algorithme SHA-256 sous forme hexadécimale. </font><font style="vertical-align: inherit;">Étant donné que l'ordinateur 1401 ne prend pas en charge le format hexadécimal, j'ai dû écrire mes propres routines pour convertir les formats hexadécimal et binaire. </font><font style="vertical-align: inherit;">Dans cet article, je n'expliquerai pas le code assembleur pour IBM 1401, je souligne seulement qu'il est très différent de ce que les ordinateurs modernes utilisent. </font><font style="vertical-align: inherit;">Ce code n'appelle pas de sous-programmes et ne renvoie pas de résultats. </font><font style="vertical-align: inherit;">En raison de l'absence de registres à usage général, les opérations sont effectuées en mémoire. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Recherchez le code sous le spoiler:</font></font><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Texte masqué</font></font></b><div class="spoiler_text"><pre><code class="dos hljs">job  bitcoin<font></font>
     * SHA-<span class="hljs-number">256</span> hash<font></font>
     * Ken Shirriff  http://righto.com<font></font>
               ctl  <span class="hljs-number">6641</span><font></font>
<font></font>
               org  <span class="hljs-number">087</span>
     X1        dcw  @<span class="hljs-number">000</span>@<font></font>
               org  <span class="hljs-number">092</span>
     X2        dcw  @<span class="hljs-number">000</span>@<font></font>
               org  <span class="hljs-number">097</span>
     X3        dcw  @<span class="hljs-number">000</span>@<font></font>
     <font></font>
               org  <span class="hljs-number">333</span>
     <span class="hljs-built_in">start</span>     cs   <span class="hljs-number">299</span><font></font>
               r<font></font>
               sw   <span class="hljs-number">001</span>
               lca  <span class="hljs-number">064</span>, input0<font></font>
               mcw  <span class="hljs-number">064</span>, <span class="hljs-number">264</span><font></font>
               w<font></font>
     * Initialize word marks on storage<font></font>
               mcw  +s0, x3<font></font>
<font></font>
     wmloop    sw   <span class="hljs-number">0</span>&amp;x3  <font></font>
               ma   @<span class="hljs-number">032</span>@, x3<font></font>
               c    +h7+<span class="hljs-number">32</span>, x3<font></font>
               bu   wmloop<font></font>
     <font></font>
               mcw  +input-<span class="hljs-number">127</span>, x3      * Put input into warr[<span class="hljs-number">0</span>] to warr[<span class="hljs-number">15</span>]<font></font>
               mcw  +warr, x1<font></font>
               mcw  @<span class="hljs-number">128</span>@, tobinc<font></font>
               b    tobin<font></font>
     <font></font>
     * Compute message schedule array w[<span class="hljs-number">0</span>..<span class="hljs-number">63</span>]<font></font>
  <font></font>
               mcw  @<span class="hljs-number">16</span>@, i<font></font>
     * i is word index <span class="hljs-number">16</span>-<span class="hljs-number">63</span>   
     * x1 is <span class="hljs-built_in">start</span> of warr[i-<span class="hljs-number">16</span>], i.e. bit <span class="hljs-number">0</span> (bit <span class="hljs-number">0</span> on left, bit <span class="hljs-number">31</span> on right)   <font></font>
               mcw  +warr, x1<font></font>
     wloop     c    @<span class="hljs-number">64</span>@, i<font></font>
               be   wloopd<font></font>
     <font></font>
     * Compute s0<font></font>
               mcw  +s0, x2<font></font>
               za   +<span class="hljs-number">0</span>, <span class="hljs-number">31</span>&amp;x2               * Zero s0<font></font>
     * Add w[i-<span class="hljs-number">15</span>] rightrotate <span class="hljs-number">7</span>
               sw   <span class="hljs-number">7</span>&amp;x2               * Wordmark <span class="hljs-built_in">at</span> bit <span class="hljs-number">7</span> (from left) of s0<font></font>
               a    <span class="hljs-number">56</span>&amp;x1, <span class="hljs-number">31</span>&amp;x2       * Right shifted: <span class="hljs-number">32</span>+<span class="hljs-number">31</span>-<span class="hljs-number">7</span> = bit <span class="hljs-number">24</span> of w[i-<span class="hljs-number">15</span>], <span class="hljs-number">31</span> = end of s0<font></font>
               a    <span class="hljs-number">63</span>&amp;x1, <span class="hljs-number">6</span>&amp;x2        * Wrapped: <span class="hljs-number">32</span>+<span class="hljs-number">31</span> = end of w[i-<span class="hljs-number">15</span>], <span class="hljs-number">7</span>-<span class="hljs-number">1</span> = bit <span class="hljs-number">6</span> of s0   <font></font>
               cw   <span class="hljs-number">7</span>&amp;x2               * Clear wordmark<font></font>
     * Add w[i-<span class="hljs-number">15</span>] rightrotate <span class="hljs-number">18</span>
               sw   <span class="hljs-number">18</span>&amp;x2              * Wordmark <span class="hljs-built_in">at</span> bit <span class="hljs-number">18</span> (from left) of s0<font></font>
               a    <span class="hljs-number">45</span>&amp;x1, <span class="hljs-number">31</span>&amp;x2       * Right shifted: <span class="hljs-number">32</span>+<span class="hljs-number">31</span>-<span class="hljs-number">18</span> = bit <span class="hljs-number">13</span> of w[i-<span class="hljs-number">15</span>], <span class="hljs-number">31</span> = end of s0<font></font>
               a    <span class="hljs-number">63</span>&amp;x1, <span class="hljs-number">17</span>&amp;x2       * Wrapped: <span class="hljs-number">32</span>+<span class="hljs-number">31</span> = end of w[i-<span class="hljs-number">15</span>], <span class="hljs-number">18</span>-<span class="hljs-number">1</span> = bit <span class="hljs-number">17</span> of s0   <font></font>
               cw   <span class="hljs-number">18</span>&amp;x2              * Clear wordmark<font></font>
     * Add w[i-<span class="hljs-number">15</span>] rightshift <span class="hljs-number">3</span>
               sw   <span class="hljs-number">3</span>&amp;x2               * Wordmark <span class="hljs-built_in">at</span> bit <span class="hljs-number">3</span> (from left) of s0<font></font>
               a    <span class="hljs-number">60</span>&amp;x1, <span class="hljs-number">31</span>&amp;x2       * Right shifted: <span class="hljs-number">32</span>+<span class="hljs-number">31</span>-<span class="hljs-number">3</span> = bit <span class="hljs-number">28</span> of w[i-<span class="hljs-number">15</span>], <span class="hljs-number">31</span> = end of s0<font></font>
               cw   <span class="hljs-number">3</span>&amp;x2               * Clear wordmark<font></font>
     * <span class="hljs-built_in">Convert</span> sum to xor<font></font>
               mcw  x1, x1tmp<font></font>
               mcw  +s0+<span class="hljs-number">31</span>, x1         * x1 = right end of s0<font></font>
               mcw  @<span class="hljs-number">032</span>@, x2          * Process <span class="hljs-number">32</span> bits<font></font>
               b    xor<font></font>
               sw   s0                 * <span class="hljs-built_in">Restore</span> wordmark cleared by xor<font></font>
     <font></font>
               mcw  x1tmp, x1<font></font>
     <font></font>
     * Compute s1         <font></font>
               mcw  +s1, x2<font></font>
               za   +<span class="hljs-number">0</span>, <span class="hljs-number">31</span>&amp;x2               * Zero s1<font></font>
     * Add w[i-<span class="hljs-number">2</span>] rightrotate <span class="hljs-number">17</span>
               sw   <span class="hljs-number">17</span>&amp;x2              * Wordmark <span class="hljs-built_in">at</span> bit <span class="hljs-number">17</span> (from left) of s1<font></font>
               a    <span class="hljs-number">462</span>&amp;x1, <span class="hljs-number">31</span>&amp;x2      * Right shifted: <span class="hljs-number">14</span>*<span class="hljs-number">32</span>+<span class="hljs-number">31</span>-<span class="hljs-number">17</span> = bit <span class="hljs-number">14</span> of w[i-<span class="hljs-number">2</span>], <span class="hljs-number">31</span> = end of s1<font></font>
               a    <span class="hljs-number">479</span>&amp;x1, <span class="hljs-number">16</span>&amp;x2      * Wrapped: <span class="hljs-number">14</span>*<span class="hljs-number">32</span>+<span class="hljs-number">31</span> = end of w[i-<span class="hljs-number">2</span>], <span class="hljs-number">17</span>-<span class="hljs-number">1</span> = bit <span class="hljs-number">16</span> of s1   <font></font>
               cw   <span class="hljs-number">17</span>&amp;x2              * Clear wordmark<font></font>
     * Add w[i-<span class="hljs-number">2</span>] rightrotate <span class="hljs-number">19</span>
               sw   <span class="hljs-number">19</span>&amp;x2              * Wordmark <span class="hljs-built_in">at</span> bit <span class="hljs-number">19</span> (from left) of s1<font></font>
               a    <span class="hljs-number">460</span>&amp;x1, <span class="hljs-number">31</span>&amp;x2      * Right shifted: <span class="hljs-number">14</span>*<span class="hljs-number">32</span>+<span class="hljs-number">31</span>-<span class="hljs-number">19</span> = bit <span class="hljs-number">12</span> of w[i-<span class="hljs-number">2</span>], <span class="hljs-number">31</span> = end of s1<font></font>
               a    <span class="hljs-number">479</span>&amp;x1, <span class="hljs-number">18</span>&amp;x2      * Wrapped: <span class="hljs-number">14</span>*<span class="hljs-number">32</span>+<span class="hljs-number">31</span> = end of w[i-<span class="hljs-number">2</span>], <span class="hljs-number">19</span>-<span class="hljs-number">1</span> = bit <span class="hljs-number">18</span> of s1  <font></font>
               cw   <span class="hljs-number">19</span>&amp;x2              * Clear wordmark<font></font>
     * Add w[i-<span class="hljs-number">2</span>] rightshift <span class="hljs-number">10</span>
               sw   <span class="hljs-number">10</span>&amp;x2              * Wordmark <span class="hljs-built_in">at</span> bit <span class="hljs-number">10</span> (from left) of s1<font></font>
               a    <span class="hljs-number">469</span>&amp;x1, <span class="hljs-number">31</span>&amp;x2      * Right shifted: <span class="hljs-number">14</span>*<span class="hljs-number">32</span>+<span class="hljs-number">31</span>-<span class="hljs-number">10</span> = bit <span class="hljs-number">21</span> of w[i-<span class="hljs-number">2</span>], <span class="hljs-number">31</span> = end of s1<font></font>
               cw   <span class="hljs-number">10</span>&amp;x2              * Clear wordmark<font></font>
     * <span class="hljs-built_in">Convert</span> sum to xor<font></font>
               mcw  +s1+<span class="hljs-number">31</span>, x1         * x1 = right end of s1<font></font>
               mcw  @<span class="hljs-number">032</span>@, x2          * Process <span class="hljs-number">32</span> bits<font></font>
               b    xor<font></font>
               sw   s1                 * <span class="hljs-built_in">Restore</span> wordmark cleared by xor<font></font>
     <font></font>
     * Compute w[i] := w[i-<span class="hljs-number">16</span>] + s0 + w[i-<span class="hljs-number">7</span>] + s1<font></font>
               mcw  x1tmp, x1<font></font>
               a    s1+<span class="hljs-number">31</span>, s0+<span class="hljs-number">31</span>       * Add s1 to s0<font></font>
               a    <span class="hljs-number">31</span>&amp;x1, s0+<span class="hljs-number">31</span>       * Add w[i-<span class="hljs-number">16</span>] to s0<font></font>
               a    <span class="hljs-number">319</span>&amp;x1, s0+<span class="hljs-number">31</span>      * Add <span class="hljs-number">9</span>*<span class="hljs-number">32</span>+<span class="hljs-number">31</span> = w[i-<span class="hljs-number">7</span>] to s0<font></font>
     * <span class="hljs-built_in">Convert</span> bit sum to <span class="hljs-number">32</span>-bit sum<font></font>
               mcw  +s0+<span class="hljs-number">31</span>, x1         * x1 = right end of s0<font></font>
               mcw  @<span class="hljs-number">032</span>@, x2          * Process <span class="hljs-number">32</span> bits<font></font>
               b    sum<font></font>
               sw   s0                 * <span class="hljs-built_in">Restore</span> wordmark cleared by sum<font></font>
     <font></font>
<font></font>
     <font></font>
               mcw  x1tmp, x1<font></font>
               mcw  s0+<span class="hljs-number">31</span>, <span class="hljs-number">543</span>&amp;x1      * <span class="hljs-built_in">Move</span> s0 to w[i]<font></font>
       <font></font>
              <font></font>
               ma   @<span class="hljs-number">032</span>@, x1<font></font>
               a    +<span class="hljs-number">1</span>, i<font></font>
               mz   @<span class="hljs-number">0</span>@, i<font></font>
               b    wloop<font></font>
     <font></font>
     x1tmp     dcw  #<span class="hljs-number">5</span><font></font>
     <font></font>
<font></font>
     * Initialize: <span class="hljs-built_in">Copy</span> hex h0init-h7init into binary h0-h7<font></font>
     wloopd    mcw  +h0init-<span class="hljs-number">7</span>, x3<font></font>
               mcw  +h0, x1<font></font>
               mcw  @<span class="hljs-number">064</span>@, tobinc       * <span class="hljs-number">8</span>*<span class="hljs-number">8</span> hex digits<font></font>
               b    tobin<font></font>
     <font></font>
     <font></font>
     * Initialize a-h from h0-h7<font></font>
               mcw  @<span class="hljs-number">000</span>@, x1<font></font>
     ilp       mcw  h0+<span class="hljs-number">31</span>&amp;x1, a+<span class="hljs-number">31</span>&amp;x1<font></font>
               ma   @<span class="hljs-number">032</span>@, x1<font></font>
               c    x1, @<span class="hljs-number">256</span>@<font></font>
               bu   ilp<font></font>
     <font></font>
               mcw  @<span class="hljs-number">000</span>@, bitidx      * bitidx = i*<span class="hljs-number">32</span> = bit index<font></font>
               mcw  @<span class="hljs-number">000</span>@, kidx        * kidx = i*<span class="hljs-number">8</span> = key index<font></font>
                <font></font>
<font></font>
     * Compute s1 from e        <font></font>
     mainlp    mcw  +e, x1<font></font>
               mcw  +s1, x2<font></font>
               za   +<span class="hljs-number">0</span>, <span class="hljs-number">31</span>&amp;x2               * Zero s1<font></font>
     * Add e rightrotate <span class="hljs-number">6</span>
               sw   <span class="hljs-number">6</span>&amp;x2               * Wordmark <span class="hljs-built_in">at</span> bit <span class="hljs-number">6</span> (from left) of s1<font></font>
               a    <span class="hljs-number">25</span>&amp;x1, <span class="hljs-number">31</span>&amp;x2       * Right shifted: <span class="hljs-number">31</span>-<span class="hljs-number">6</span> = bit <span class="hljs-number">25</span> of e, <span class="hljs-number">31</span> = end of s1<font></font>
               a    <span class="hljs-number">31</span>&amp;x1, <span class="hljs-number">5</span>&amp;x2        * Wrapped: <span class="hljs-number">31</span> = end of e, <span class="hljs-number">6</span>-<span class="hljs-number">1</span> = bit <span class="hljs-number">5</span> of s1   <font></font>
               cw   <span class="hljs-number">6</span>&amp;x2               * Clear wordmark<font></font>
     * Add e rightrotate <span class="hljs-number">11</span>
               sw   <span class="hljs-number">11</span>&amp;x2              * Wordmark <span class="hljs-built_in">at</span> bit <span class="hljs-number">11</span> (from left) of s1<font></font>
               a    <span class="hljs-number">20</span>&amp;x1, <span class="hljs-number">31</span>&amp;x2       * Right shifted: <span class="hljs-number">31</span>-<span class="hljs-number">11</span> = bit <span class="hljs-number">20</span> of e, <span class="hljs-number">31</span> = end of s1<font></font>
               a    <span class="hljs-number">31</span>&amp;x1, <span class="hljs-number">10</span>&amp;x2       * Wrapped: <span class="hljs-number">31</span> = end of e, <span class="hljs-number">11</span>-<span class="hljs-number">1</span> = bit <span class="hljs-number">10</span> of s1   <font></font>
               cw   <span class="hljs-number">11</span>&amp;x2              * Clear wordmark<font></font>
     * Add e rightrotate <span class="hljs-number">25</span>
               sw   <span class="hljs-number">25</span>&amp;x2              * Wordmark <span class="hljs-built_in">at</span> bit <span class="hljs-number">25</span> (from left) of s1<font></font>
               a    <span class="hljs-number">6</span>&amp;x1, <span class="hljs-number">31</span>&amp;x2        * Right shifted: <span class="hljs-number">31</span>-<span class="hljs-number">25</span> = bit <span class="hljs-number">6</span> of e, <span class="hljs-number">31</span> = end of s1<font></font>
               a    <span class="hljs-number">31</span>&amp;x1, <span class="hljs-number">24</span>&amp;x2       * Wrapped: <span class="hljs-number">31</span> = end of e, <span class="hljs-number">25</span>-<span class="hljs-number">1</span> = bit <span class="hljs-number">24</span> of s1   <font></font>
               cw   <span class="hljs-number">25</span>&amp;x2              * Clear wordmark<font></font>
     * <span class="hljs-built_in">Convert</span> sum to xor<font></font>
               mcw  +s1+<span class="hljs-number">31</span>, x1         * x1 = right end of s1<font></font>
               mcw  @<span class="hljs-number">032</span>@, x2          * Process <span class="hljs-number">32</span> bits<font></font>
               b    xor<font></font>
               sw   s1                 * <span class="hljs-built_in">Restore</span> wordmark cleared by xor<font></font>
<font></font>
     * Compute ch: choose function<font></font>
               mcw  @<span class="hljs-number">000</span>@, x1          * x1 is index from <span class="hljs-number">0</span> to <span class="hljs-number">31</span>
     chl       c    e&amp;x1, @<span class="hljs-number">0</span>@<font></font>
               be   chzero<font></font>
               mn   f&amp;x1, ch&amp;x1        * <span class="hljs-keyword">for</span> <span class="hljs-number">1</span>, select f bit<font></font>
               b    chincr<font></font>
     chzero    mn   g&amp;x1, ch&amp;x1        * <span class="hljs-keyword">for</span> <span class="hljs-number">0</span>, select g bit<font></font>
     chincr    a    +<span class="hljs-number">1</span>, x1<font></font>
               mz   @<span class="hljs-number">0</span>@, x1<font></font>
               c    @<span class="hljs-number">032</span>@, x1<font></font>
               bu   chl<font></font>
<font></font>
     * Compute temp1: k[i] + h + S1 + ch + w[i]<font></font>
               cs   <span class="hljs-number">299</span>
               mcw  +k-<span class="hljs-number">7</span>, x3            * <span class="hljs-built_in">Convert</span> k[i] to binary <span class="hljs-keyword">in</span> temp1<font></font>
               ma   kidx, x3<font></font>
               mcw  +temp1, x1<font></font>
               mcw  @<span class="hljs-number">008</span>@, tobinc       * <span class="hljs-number">8</span> hex digits<font></font>
               b    tobin<font></font>
               mcw  @<span class="hljs-number">237</span>@, x3<font></font>
               mcw  +temp1, x1<font></font>
               mcw  @<span class="hljs-number">008</span>@, tobinc<font></font>
               b    tohex<font></font>
               a    h+<span class="hljs-number">31</span>, temp1+<span class="hljs-number">31</span>     * +h<font></font>
               a    s1+<span class="hljs-number">31</span>, temp1+<span class="hljs-number">31</span>    * +s1<font></font>
               a    ch+<span class="hljs-number">31</span>, temp1+<span class="hljs-number">31</span>    * +ch<font></font>
               mcw  bitidx, x1<font></font>
               a    warr+<span class="hljs-number">31</span>&amp;x1, temp1+<span class="hljs-number">31</span>         * + w[i]<font></font>
     * <span class="hljs-built_in">Convert</span> bit sum to <span class="hljs-number">32</span>-bit sum<font></font>
               mcw  +temp1+<span class="hljs-number">31</span>, x1      * x1 = right end of temp1<font></font>
               b    sum<font></font>
  <font></font>
<font></font>
     * Compute s0 from a<font></font>
               mcw  +a, x1<font></font>
               mcw  +s0, x2<font></font>
               za   +<span class="hljs-number">0</span>, <span class="hljs-number">31</span>&amp;x2               * Zero s0<font></font>
     * Add a rightrotate <span class="hljs-number">2</span>
               sw   <span class="hljs-number">2</span>&amp;x2               * Wordmark <span class="hljs-built_in">at</span> bit <span class="hljs-number">2</span> (from left) of s0<font></font>
               a    <span class="hljs-number">29</span>&amp;x1, <span class="hljs-number">31</span>&amp;x2       * Right shifted: <span class="hljs-number">31</span>-<span class="hljs-number">2</span> = bit <span class="hljs-number">29</span> of a, <span class="hljs-number">31</span> = end of s0<font></font>
               a    <span class="hljs-number">31</span>&amp;x1, <span class="hljs-number">1</span>&amp;x2        * Wrapped: <span class="hljs-number">31</span> = end of a, <span class="hljs-number">2</span>-<span class="hljs-number">1</span> = bit <span class="hljs-number">1</span> of s0   <font></font>
               cw   <span class="hljs-number">2</span>&amp;x2               * Clear wordmark<font></font>
     * Add a rightrotate <span class="hljs-number">13</span>
               sw   <span class="hljs-number">13</span>&amp;x2              * Wordmark <span class="hljs-built_in">at</span> bit <span class="hljs-number">13</span> (from left) of s0<font></font>
               a    <span class="hljs-number">18</span>&amp;x1, <span class="hljs-number">31</span>&amp;x2       * Right shifted: <span class="hljs-number">31</span>-<span class="hljs-number">13</span> = bit <span class="hljs-number">18</span> of a, <span class="hljs-number">31</span> = end of s0<font></font>
               a    <span class="hljs-number">31</span>&amp;x1, <span class="hljs-number">12</span>&amp;x2       * Wrapped: <span class="hljs-number">31</span> = end of a, <span class="hljs-number">13</span>-<span class="hljs-number">1</span> = bit <span class="hljs-number">12</span> of s0   <font></font>
               cw   <span class="hljs-number">13</span>&amp;x2              * Clear wordmark<font></font>
     * Add a rightrotate <span class="hljs-number">22</span>
               sw   <span class="hljs-number">22</span>&amp;x2              * Wordmark <span class="hljs-built_in">at</span> bit <span class="hljs-number">22</span> (from left) of s0<font></font>
               a    <span class="hljs-number">9</span>&amp;x1, <span class="hljs-number">31</span>&amp;x2        * Right shifted: <span class="hljs-number">31</span>-<span class="hljs-number">22</span> = bit <span class="hljs-number">9</span> of a, <span class="hljs-number">31</span> = end of s0<font></font>
               a    <span class="hljs-number">31</span>&amp;x1, <span class="hljs-number">21</span>&amp;x2       * Wrapped: <span class="hljs-number">31</span> = end of a, <span class="hljs-number">22</span>-<span class="hljs-number">1</span> = bit <span class="hljs-number">21</span> of s0   <font></font>
               cw   <span class="hljs-number">22</span>&amp;x2              * Clear wordmark<font></font>
     * <span class="hljs-built_in">Convert</span> sum to xor<font></font>
               mcw  +s0+<span class="hljs-number">31</span>, x1         * x1 = right end of s0<font></font>
               mcw  @<span class="hljs-number">032</span>@, x2          * Process <span class="hljs-number">32</span> bits<font></font>
               b    xor<font></font>
               sw   s0                 * <span class="hljs-built_in">Restore</span> wordmark cleared by xor<font></font>
<font></font>
     * Compute maj(a, b, c): majority function<font></font>
               za   +<span class="hljs-number">0</span>, maj+<span class="hljs-number">31</span>
               a    a+<span class="hljs-number">31</span>, maj+<span class="hljs-number">31</span>
               a    b+<span class="hljs-number">31</span>, maj+<span class="hljs-number">31</span>
               a    c+<span class="hljs-number">31</span>, maj+<span class="hljs-number">31</span>
               mz   @<span class="hljs-number">0</span>@, maj+<span class="hljs-number">31</span>
               mcw  @<span class="hljs-number">000</span>@, x1          * x1 is index from <span class="hljs-number">0</span> to <span class="hljs-number">31</span>
     mjl       c    maj&amp;x1, @<span class="hljs-number">2</span>@<font></font>
               bh   mjzero<font></font>
               mn   @<span class="hljs-number">1</span>@, maj&amp;x1       * majority of the <span class="hljs-number">3</span> bits is <span class="hljs-number">1</span><font></font>
               b    mjincr<font></font>
     mjzero    mn   @<span class="hljs-number">0</span>@, maj&amp;x1       * majority of the <span class="hljs-number">3</span> bits is <span class="hljs-number">0</span>
     mjincr    a    +<span class="hljs-number">1</span>, x1<font></font>
               mz   @<span class="hljs-number">0</span>@, x1<font></font>
               c    @<span class="hljs-number">032</span>@, x1<font></font>
               bu   mjl<font></font>
<font></font>
     * Compute temp2: S0 + maj<font></font>
               za   +<span class="hljs-number">0</span>, temp2+<span class="hljs-number">31</span>
               a    s0+<span class="hljs-number">31</span>, temp2+<span class="hljs-number">31</span>
               a    maj+<span class="hljs-number">31</span>, temp2+<span class="hljs-number">31</span>
     * <span class="hljs-built_in">Convert</span> bit sum to <span class="hljs-number">32</span>-bit sum<font></font>
               mcw  +temp2+<span class="hljs-number">31</span>, x1      * x1 = right end of temp1<font></font>
               b    sum<font></font>
     <font></font>
               mcw  g+<span class="hljs-number">31</span>, h+<span class="hljs-number">31</span>         * h := g<font></font>
               mcw  f+<span class="hljs-number">31</span>, g+<span class="hljs-number">31</span>         * g := f<font></font>
               mcw  e+<span class="hljs-number">31</span>, f+<span class="hljs-number">31</span>         * f := e<font></font>
               za   +<span class="hljs-number">0</span>, e+<span class="hljs-number">31</span>           * e := d + temp1<font></font>
               a    d+<span class="hljs-number">31</span>, e+<span class="hljs-number">31</span>
               a    temp1+<span class="hljs-number">31</span>, e+<span class="hljs-number">31</span>
               mcw  +e+<span class="hljs-number">31</span>, x1          * <span class="hljs-built_in">Convert</span> sum to <span class="hljs-number">32</span>-bit sum<font></font>
               b    sum<font></font>
               mcw  c+<span class="hljs-number">31</span>, d+<span class="hljs-number">31</span>         * d := c<font></font>
               mcw  b+<span class="hljs-number">31</span>, c+<span class="hljs-number">31</span>         * c := b<font></font>
               mcw  a+<span class="hljs-number">31</span>, b+<span class="hljs-number">31</span>         * b := a<font></font>
               za   +<span class="hljs-number">0</span>, a+<span class="hljs-number">31</span>           * a := temp1 + temp2<font></font>
               a    temp1+<span class="hljs-number">31</span>, a+<span class="hljs-number">31</span>
               a    temp2+<span class="hljs-number">31</span>, a+<span class="hljs-number">31</span>
               mcw  +a+<span class="hljs-number">31</span>, x1          * <span class="hljs-built_in">Convert</span> sum to <span class="hljs-number">32</span>-bit sum<font></font>
               b    sum<font></font>
<font></font>
               a    @<span class="hljs-number">8</span>@, kidx          * Increment kidx by <span class="hljs-number">8</span> chars<font></font>
               mz   @<span class="hljs-number">0</span>@, kidx<font></font>
               ma   @<span class="hljs-number">032</span>@, bitidx      * Increment bitidx by <span class="hljs-number">32</span> bits<font></font>
               c    @!<span class="hljs-number">48</span>@, bitidx      * Compare to <span class="hljs-number">2048</span><font></font>
               bu   mainlp<font></font>
<font></font>
     * Add a-h to h0-h7<font></font>
               cs   <span class="hljs-number">299</span>
               mcw  @<span class="hljs-number">00000</span>@, x1tmp  <font></font>
     add1      mcw  x1tmp, x1<font></font>
               a    a+<span class="hljs-number">31</span>&amp;x1, h0+<span class="hljs-number">31</span>&amp;x1<font></font>
               ma   +h0+<span class="hljs-number">31</span>, x1          * <span class="hljs-built_in">Convert</span> sum to <span class="hljs-number">32</span>-bit sum<font></font>
               b    sum     <font></font>
               ma   @<span class="hljs-number">032</span>@, x1tmp<font></font>
               c    @<span class="hljs-number">00256</span>@, x1tmp<font></font>
               bu   add1<font></font>
               mcw  @<span class="hljs-number">201</span>@, x3<font></font>
               mcw  +h0, x1<font></font>
               mcw  @<span class="hljs-number">064</span>@, tobinc<font></font>
               b    tohex<font></font>
               w<font></font>
               mcw  <span class="hljs-number">280</span>, <span class="hljs-number">180</span><font></font>
               p<font></font>
               p<font></font>
<font></font>
     finis     h<font></font>
               b    finis<font></font>
<font></font>
      <font></font>
     * Converts sum of bits to xor<font></font>
     * X1 is right end of word<font></font>
     * X2 is bit count    <font></font>
     * Note: clears word marks<font></font>
     xor       sbr  xorx&amp;<span class="hljs-number">3</span>
     xorl      c    @<span class="hljs-number">000</span>@, x2<font></font>
               be   xorx<font></font>
     xorfix    mz   @<span class="hljs-number">0</span>@, <span class="hljs-number">0</span>&amp;x1          * Clear zone<font></font>
               c    <span class="hljs-number">0</span>&amp;x1, @<span class="hljs-number">2</span>@<font></font>
               bh   xorok<font></font>
               sw   <span class="hljs-number">0</span>&amp;x1               * Subtract <span class="hljs-number">2</span> and loop<font></font>
               s    +<span class="hljs-number">2</span>, <span class="hljs-number">0</span>&amp;x1<font></font>
               cw   <span class="hljs-number">0</span>&amp;x1<font></font>
               b    xorfix<font></font>
     xorok     ma   @I9I@, x1         * x1 -= <span class="hljs-number">1</span>
               s    +<span class="hljs-number">1</span>, x2             * x2 -= <span class="hljs-number">1</span>
               mz   @<span class="hljs-number">0</span>@, x2<font></font>
               b    xorl               * loop<font></font>
     <font></font>
     xorx      b    @<span class="hljs-number">000</span>@<font></font>
     <font></font>
     * Converts sum of bits to sum (i.e. propagate carries <span class="hljs-keyword">if</span> digit &gt; <span class="hljs-number">1</span>)<font></font>
     * X1 is right end of word<font></font>
     * Ends <span class="hljs-built_in">at</span> word mark<font></font>
     sum       sbr  sumx&amp;<span class="hljs-number">3</span>
     suml      mz   @<span class="hljs-number">0</span>@, <span class="hljs-number">0</span>&amp;x1          * Clear zone<font></font>
               c    <span class="hljs-number">0</span>&amp;x1, @<span class="hljs-number">2</span>@          * <span class="hljs-keyword">If</span> digit is &lt;<span class="hljs-number">2</span>, then ok<font></font>
               bh   sumok<font></font>
               s    +<span class="hljs-number">2</span>, <span class="hljs-number">0</span>&amp;x1           * Subtract <span class="hljs-number">2</span> from digit<font></font>
               bwz  suml, <span class="hljs-number">0</span>&amp;x1, <span class="hljs-number">1</span>      * Skip carry <span class="hljs-keyword">if</span> <span class="hljs-built_in">at</span> wordmark<font></font>
               a    @<span class="hljs-number">1</span>@, <span class="hljs-number">15999</span>&amp;x1      * Add <span class="hljs-number">1</span> to previous position<font></font>
               b    suml               * Loop<font></font>
     sumok     bwz  sumx,<span class="hljs-number">0</span>&amp;x1,<span class="hljs-number">1</span>        * Quit <span class="hljs-keyword">if</span> <span class="hljs-built_in">at</span> wordmark<font></font>
               ma   @I9I@, x1          * x1 -= <span class="hljs-number">1</span><font></font>
               b    suml               * loop<font></font>
     sumx      b    @<span class="hljs-number">000</span>@              * return<font></font>
     <font></font>
     * Converts binary to string of hex digits<font></font>
     * X1 points to <span class="hljs-built_in">start</span> (left) of binary<font></font>
     * X3 points to <span class="hljs-built_in">start</span> (left) of hex buffer<font></font>
     * X1, X2, X3 destroyed<font></font>
     * tobinc holds count (# of hex digits)<font></font>
     tohex     sbr  tohexx&amp;<span class="hljs-number">3</span>
     tohexl    c    @<span class="hljs-number">000</span>@, tobinc      * check counter<font></font>
               be   tohexx<font></font>
               s    @<span class="hljs-number">1</span>@, tobinc        * decrement counter<font></font>
               mz   @<span class="hljs-number">0</span>@, tobinc<font></font>
               b    tohex4<font></font>
               mcw  hexchr, <span class="hljs-number">0</span>&amp;x3<font></font>
               ma   @<span class="hljs-number">004</span>@, X1<font></font>
               ma   @<span class="hljs-number">001</span>@, X3<font></font>
               b    tohexl             * loop<font></font>
     tohexx    b    @<span class="hljs-number">000</span>@ <font></font>
     <font></font>
<font></font>
     <font></font>
     * X1 points to <span class="hljs-number">4</span> bits<font></font>
     * <span class="hljs-built_in">Convert</span> to hex char and write into hexchr<font></font>
     * X2 destroyed<font></font>
<font></font>
     tohex4    sbr  tohx4x&amp;<span class="hljs-number">3</span>
               mcw  @<span class="hljs-number">000</span>@, x2<font></font>
               c    <span class="hljs-number">3</span>&amp;X1, @<span class="hljs-number">1</span>@<font></font>
               bu   tohx1<font></font>
               a    +<span class="hljs-number">1</span>, x2<font></font>
     tohx1     c    <span class="hljs-number">2</span>&amp;X1, @<span class="hljs-number">1</span>@<font></font>
               bu   tohx2<font></font>
               a    +<span class="hljs-number">2</span>, x2<font></font>
     tohx2     c    <span class="hljs-number">1</span>&amp;x1, @<span class="hljs-number">1</span>@<font></font>
               bu   tohx4<font></font>
               a    +<span class="hljs-number">4</span>, x2<font></font>
     tohx4     c    <span class="hljs-number">0</span>&amp;x1, @<span class="hljs-number">1</span>@<font></font>
               bu   tohx8<font></font>
               a    +<span class="hljs-number">8</span>, x2<font></font>
     tohx8     mz   @<span class="hljs-number">0</span>@, x2<font></font>
               mcw  hextab-<span class="hljs-number">15</span>&amp;x2, hexchr<font></font>
     tohx4x    b    @<span class="hljs-number">000</span>@<font></font>
     <font></font>
     * Converts string of hex digits to binary<font></font>
     * X3 points to <span class="hljs-built_in">start</span> (left) of hex digits<font></font>
     * X1 points to <span class="hljs-built_in">start</span> (left) of binary digits<font></font>
     * tobinc holds count (# of hex digits)<font></font>
     * X1, X3 destroyed<font></font>
     tobin     sbr  tobinx&amp;<span class="hljs-number">3</span>
     tobinl    c    @<span class="hljs-number">000</span>@, tobinc      * check counter<font></font>
               be   tobinx<font></font>
               s    @<span class="hljs-number">1</span>@, tobinc        * decrement counter<font></font>
               mz   @<span class="hljs-number">0</span>@, tobinc<font></font>
               mcw  <span class="hljs-number">0</span>&amp;X3, hexchr<font></font>
               b    tobin4             * <span class="hljs-built_in">convert</span> <span class="hljs-number">1</span> char<font></font>
               ma   @<span class="hljs-number">004</span>@, X1<font></font>
               ma   @<span class="hljs-number">001</span>@, X3<font></font>
               b    tobinl             * loop<font></font>
     tobinx    b    @<span class="hljs-number">000</span>@<font></font>
               <font></font>
     <font></font>
     tobinc    dcw  @<span class="hljs-number">000</span>@<font></font>
     * <span class="hljs-built_in">Convert</span> hex digit to binary<font></font>
     * Digit <span class="hljs-keyword">in</span> hexchr (destroyed)<font></font>
     * Bits written to x1, ..., x1+<span class="hljs-number">3</span>
     tobin4    sbr  tobn4x&amp;<span class="hljs-number">3</span>
               mcw  @<span class="hljs-number">0000</span>@, <span class="hljs-number">3</span>+x1   * <span class="hljs-built_in">Start</span> with zero bits<font></font>
               bwz  norm,hexchr,<span class="hljs-number">2</span>  * Branch <span class="hljs-keyword">if</span> no zone<font></font>
              <font></font>
               mcw  @<span class="hljs-number">1</span>@, <span class="hljs-number">0</span>&amp;X1<font></font>
               a    @<span class="hljs-number">1</span>@, hexchr    * <span class="hljs-built_in">Convert</span> letter to value: A (<span class="hljs-number">1</span>) -&gt; <span class="hljs-number">2</span>, F (<span class="hljs-number">6</span>) -&gt; <span class="hljs-number">7</span>
               mz   @<span class="hljs-number">0</span>@, hexchr<font></font>
               b    tob4<font></font>
     norm      c    @<span class="hljs-number">8</span>@, hexchr<font></font>
               bl   tob4<font></font>
               mcw  @<span class="hljs-number">1</span>@, <span class="hljs-number">0</span>&amp;X1<font></font>
               s    @<span class="hljs-number">8</span>@, hexchr<font></font>
               mz   @<span class="hljs-number">0</span>@, hexchr<font></font>
     tob4      c    @<span class="hljs-number">4</span>@, hexchr<font></font>
               bl   tob2<font></font>
               mcw  @<span class="hljs-number">1</span>@, <span class="hljs-number">1</span>&amp;X1<font></font>
               s    @<span class="hljs-number">4</span>@, hexchr<font></font>
               mz   @<span class="hljs-number">0</span>@, hexchr<font></font>
     tob2      c    @<span class="hljs-number">2</span>@, hexchr<font></font>
               bl   tob1<font></font>
               mcw  @<span class="hljs-number">1</span>@, <span class="hljs-number">2</span>&amp;X1<font></font>
               s    @<span class="hljs-number">2</span>@, hexchr<font></font>
               mz   @<span class="hljs-number">0</span>@, hexchr<font></font>
     tob1      c    @<span class="hljs-number">1</span>@, hexchr<font></font>
               bl   tobn4x<font></font>
               mcw  @<span class="hljs-number">1</span>@, <span class="hljs-number">3</span>&amp;X1<font></font>
     tobn4x    b    @<span class="hljs-number">000</span>@          <font></font>
<font></font>
<font></font>
     <font></font>
     * Message schedule array is <span class="hljs-number">64</span> entries of <span class="hljs-number">32</span> bits = <span class="hljs-number">2048</span> bits.<font></font>
               org  <span class="hljs-number">3000</span>
     warr      <span class="hljs-keyword">equ</span>  <span class="hljs-number">3000</span><font></font>
     <font></font>
     s0        <span class="hljs-keyword">equ</span>  warr+<span class="hljs-number">2047</span>                *<span class="hljs-number">32</span> bits<font></font>
     s1        <span class="hljs-keyword">equ</span>  s0+<span class="hljs-number">32</span> 
     ch        <span class="hljs-keyword">equ</span>  s1+<span class="hljs-number">32</span>              *<span class="hljs-number">32</span> bits<font></font>
<font></font>
     temp1     <span class="hljs-keyword">equ</span>  ch+<span class="hljs-number">32</span>               *<span class="hljs-number">32</span> bits<font></font>
     <font></font>
     temp2     <span class="hljs-keyword">equ</span>  temp1+<span class="hljs-number">32</span>                *<span class="hljs-number">32</span> bits<font></font>
     <font></font>
     maj       <span class="hljs-keyword">equ</span>  temp2+<span class="hljs-number">32</span>                *<span class="hljs-number">32</span> bits<font></font>
     <font></font>
     a         <span class="hljs-keyword">equ</span>  maj+<span class="hljs-number">32</span>
     b         <span class="hljs-keyword">equ</span>  a+<span class="hljs-number">32</span>
     c         <span class="hljs-keyword">equ</span>  b+<span class="hljs-number">32</span>
     d         <span class="hljs-keyword">equ</span>  c+<span class="hljs-number">32</span>
     e         <span class="hljs-keyword">equ</span>  d+<span class="hljs-number">32</span>
     f         <span class="hljs-keyword">equ</span>  e+<span class="hljs-number">32</span>
     g         <span class="hljs-keyword">equ</span>  f+<span class="hljs-number">32</span>
     h         <span class="hljs-keyword">equ</span>  g+<span class="hljs-number">32</span>
     h0        <span class="hljs-keyword">equ</span>  h+<span class="hljs-number">32</span>
     h1        <span class="hljs-keyword">equ</span>  h0+<span class="hljs-number">32</span>
     h2        <span class="hljs-keyword">equ</span>  h1+<span class="hljs-number">32</span>
     h3        <span class="hljs-keyword">equ</span>  h2+<span class="hljs-number">32</span>
     h4        <span class="hljs-keyword">equ</span>  h3+<span class="hljs-number">32</span>
     h5        <span class="hljs-keyword">equ</span>  h4+<span class="hljs-number">32</span>
     h6        <span class="hljs-keyword">equ</span>  h5+<span class="hljs-number">32</span>
     h7        <span class="hljs-keyword">equ</span>  h6+<span class="hljs-number">32</span>
               org  h7+<span class="hljs-number">32</span><font></font>
 <font></font>
     hexchr    dcw  @<span class="hljs-number">0</span>@<font></font>
     hextab    dcw  @<span class="hljs-number">0123456789</span>abcdef@    <font></font>
     i         dcw  @<span class="hljs-number">00</span>@               * Loop counter <span class="hljs-keyword">for</span> w computation<font></font>
     bitidx    dcw  #<span class="hljs-number">3</span>
     kidx      dcw  #<span class="hljs-number">3</span>         <font></font>
     <font></font>
     * <span class="hljs-number">64</span> round constants <span class="hljs-keyword">for</span> SHA-<span class="hljs-number">256</span>
     k         dcw  @<span class="hljs-number">428</span>a2f98@<font></font>
               dcw  @<span class="hljs-number">71374491</span>@<font></font>
               dcw  @b5c0fbcf@<font></font>
               dcw  @e9b5dba5@<font></font>
               dcw  @<span class="hljs-number">3956</span>c25b@<font></font>
               dcw  @<span class="hljs-number">59</span>f111f1@<font></font>
               dcw  @<span class="hljs-number">923</span>f82a4@<font></font>
               dcw  @ab1c5ed5@<font></font>
               dcw  @d807aa98@<font></font>
               dcw  @<span class="hljs-number">12835</span>b01@<font></font>
               dcw  @<span class="hljs-number">243185</span>be@<font></font>
               dcw  @<span class="hljs-number">550</span>c7dc3@<font></font>
               dcw  @<span class="hljs-number">72</span>be5d74@<font></font>
               dcw  @<span class="hljs-number">80</span>deb1fe@<font></font>
               dcw  @<span class="hljs-number">9</span>bdc06a7@<font></font>
               dcw  @c19bf174@<font></font>
               dcw  @e49b69c1@<font></font>
               dcw  @efbe4786@<font></font>
               dcw  @<span class="hljs-number">0</span>fc19dc6@<font></font>
               dcw  @<span class="hljs-number">240</span>ca1cc@<font></font>
               dcw  @<span class="hljs-number">2</span>de92c6f@<font></font>
               dcw  @<span class="hljs-number">4</span>a7484aa@<font></font>
               dcw  @<span class="hljs-number">5</span>cb0a9dc@<font></font>
               dcw  @<span class="hljs-number">76</span>f988da@<font></font>
               dcw  @<span class="hljs-number">983</span>e5152@<font></font>
               dcw  @a831c66d@<font></font>
               dcw  @b00327c8@<font></font>
               dcw  @bf597fc7@<font></font>
               dcw  @c6e00bf3@<font></font>
               dcw  @d5a79147@<font></font>
               dcw  @<span class="hljs-number">06</span>ca6351@<font></font>
               dcw  @<span class="hljs-number">14292967</span>@<font></font>
               dcw  @<span class="hljs-number">27</span>b70a85@<font></font>
               dcw  @<span class="hljs-number">2</span>e1b2138@<font></font>
               dcw  @<span class="hljs-number">4</span>d2c6dfc@<font></font>
               dcw  @<span class="hljs-number">53380</span>d13@<font></font>
               dcw  @<span class="hljs-number">650</span>a7354@<font></font>
               dcw  @<span class="hljs-number">766</span>a0abb@<font></font>
               dcw  @<span class="hljs-number">81</span>c2c92e@<font></font>
               dcw  @<span class="hljs-number">92722</span>c85@<font></font>
               dcw  @a2bfe8a1@<font></font>
               dcw  @a81a664b@<font></font>
               dcw  @c24b8b70@<font></font>
               dcw  @c76c51a3@<font></font>
               dcw  @d192e819@<font></font>
               dcw  @d6990624@<font></font>
               dcw  @f40e3585@<font></font>
               dcw  @<span class="hljs-number">106</span>aa070@<font></font>
               dcw  @<span class="hljs-number">19</span>a4c116@<font></font>
               dcw  @<span class="hljs-number">1</span>e376c08@<font></font>
               dcw  @<span class="hljs-number">2748774</span>c@<font></font>
               dcw  @<span class="hljs-number">34</span>b0bcb5@<font></font>
               dcw  @<span class="hljs-number">391</span>c0cb3@<font></font>
               dcw  @<span class="hljs-number">4</span>ed8aa4a@<font></font>
               dcw  @<span class="hljs-number">5</span>b9cca4f@<font></font>
               dcw  @<span class="hljs-number">682</span>e6ff3@<font></font>
               dcw  @<span class="hljs-number">748</span>f82ee@<font></font>
               dcw  @<span class="hljs-number">78</span>a5636f@<font></font>
               dcw  @<span class="hljs-number">84</span>c87814@<font></font>
               dcw  @<span class="hljs-number">8</span>cc70208@<font></font>
               dcw  @<span class="hljs-number">90</span>befffa@<font></font>
               dcw  @a4506ceb@<font></font>
               dcw  @bef9a3f7@<font></font>
               dcw  @c67178f2@<font></font>
     * <span class="hljs-number">8</span> initial hash values <span class="hljs-keyword">for</span> SHA-<span class="hljs-number">256</span>
     h0init    dcw  @<span class="hljs-number">6</span>a09e667@<font></font>
     h1init    dcw  @bb67ae85@<font></font>
     h2init    dcw  @<span class="hljs-number">3</span>c6ef372@<font></font>
     h3init    dcw  @a54ff53a@<font></font>
     h4init    dcw  @<span class="hljs-number">510</span>e527f@<font></font>
     h5init    dcw  @<span class="hljs-number">9</span>b05688c@<font></font>
     h6init    dcw  @<span class="hljs-number">1</span>f83d9ab@<font></font>
     h7init    dcw  @<span class="hljs-number">5</span>be0cd19@<font></font>
<font></font>
<font></font>
     input0    <span class="hljs-keyword">equ</span>  h7init+<span class="hljs-number">64</span>
               org  h7init+<span class="hljs-number">65</span><font></font>
<font></font>
               dc   @<span class="hljs-number">80000000000000000000000000000000</span>@<font></font>
     input     dc   @<span class="hljs-number">00000000000000000000000000000100</span>@      * <span class="hljs-number">512</span> bits with the mostly-zero padding<font></font>
<font></font>
               end  <span class="hljs-built_in">start</span>
</code></pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le programme exécutable a été appliqué à 85 cartes perforées (vous les avez déjà vues au début de l'article). </font><font style="vertical-align: inherit;">J'ai également fait une carte perforée avec un algorithme de hachage. </font><font style="vertical-align: inherit;">Afin d'exécuter le programme, j'ai dû charger la carte perforée dans le lecteur de carte et cliquer sur le bouton "Charger". </font><font style="vertical-align: inherit;">Le lecteur de cartes a traité 800 cartes par minute. </font><font style="vertical-align: inherit;">Ainsi, il n'a fallu que quelques secondes pour télécharger le programme. </font><font style="vertical-align: inherit;">Pendant l'exécution du programme, la console d'ordinateur (voir l'illustration ci-dessous) a clignoté fébrilement pendant 40 secondes. </font><font style="vertical-align: inherit;">Enfin, l'imprimante a imprimé pour moi le hachage final (vous avez également vu l'impression au début de l'article), et les résultats ont été appliqués à une nouvelle carte perforée. </font><font style="vertical-align: inherit;">Étant donné que l'exploitation minière Bitcoin utilise le double hachage SHA-256, le processus de hachage minier a pris deux fois plus de temps (80 secondes).</font></font><br>
<br>
<img src="https://habrastorage.org/files/203/4f4/35f/2034f435fe9e484c904b2e80287aebbe.gif"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Travail acharné de la console IBM 1401 lors du calcul du hachage SHA-256</font></font></i><br>
<br>
<h2><font color="170ec7"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comparaison des performances</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'ordinateur IBM 1401 peut calculer le double hachage SHA-256 en 80 secondes. </font><font style="vertical-align: inherit;">Pour effectuer cette tâche, l'ordinateur consomme environ 3 000 watts, à peu près la même chose qu'une cuisinière électrique ou une sécheuse. </font><font style="vertical-align: inherit;">À un moment donné, le système de base IBM 1401 a coûté 125 600 $. </font><font style="vertical-align: inherit;">Dans la réalité de 2015, cela représente environ un million de dollars américains. </font><font style="vertical-align: inherit;">Dans le même temps, vous pouvez maintenant acheter un </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lecteur flash USB pour l'exploitation minière</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour 50 $, qui dispose d'un circuit intégré spécialisé (mineur ASIC USB). </font><font style="vertical-align: inherit;">Ce mineur USB effectue 3,6 milliards de hachages par seconde, tout en consommant environ 4 watts.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ces indicateurs de performance importants sont dus à plusieurs facteurs: une forte augmentation des performances informatiques au cours des 50 dernières années selon la loi de Moore, une perte de performances associée à l'utilisation de l'arithmétique décimale dans les ordinateurs pour résoudre des problèmes commerciaux, qui était occupé à calculer un code de hachage binaire, ainsi qu'un gain de vitesse avec côtés du matériel d'extraction de bitcoin traditionnel.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Résumer. Pour exploiter le bloc, compte tenu des exigences actuelles de ce processus, l'ordinateur IBM 1401 aura besoin d'environ 5 x 10 ^ 14 ans (ce qui représente 40 000 fois l'âge actuel de l'Univers). Le coût de l'électricité consommée sera d'environ 10 ^ 18 dollars américains. En conséquence, vous recevrez 25 bitcoins, dont la valeur monétaire sera d'environ 6 000 dollars américains. Ainsi, l'extraction de bitcoins sur le mainframe IBM 1401 ne peut pas être considérée comme une entreprise rentable. Les photographies ci-dessous comparent les puces informatiques des années 60 du siècle dernier et les options modernes, démontrant clairement les progrès technologiques.</font></font><br>
<br>
<img src="https://habrastorage.org/files/0a5/4f3/3b4/0a54f33b4ab44c6ba6c0e4f6abe021fe.jpg"><img src="https://habrastorage.org/files/8fe/8d3/b6f/8fe8d3b6f6074f669239c244fb8f2ac8.jpg"><br>
<i>: SMS ,   IBM 1401.        .       . :  Bitfury ASIC      2-3   .  : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">zeptobars</a> (CC BY 3.0)</i><br>
<br>
<h2><font color="170ec7">   </font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous pouvez décider que les bitcoins sont incompatibles avec la technologie des années 60 du siècle dernier en raison du manque de capacité à transmettre des données sur le réseau. Quelqu'un devra-t-il envoyer des cartes perforées avec une chaîne de blocs à d'autres ordinateurs? La communication entre les ordinateurs via le réseau est apparue il y a longtemps. Dès 1941, IBM a pris en charge le soi-disant </font><font style="vertical-align: inherit;">processus de traitement des données </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">télémétriques</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (à distance). Dans les années 60, IBM 1401 pouvait être connecté à un périphérique de transmission de données </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">IBM 1009</font></a><font style="vertical-align: inherit;"> ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IBM 1009 Data Transmission Unit</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) - un modem de la taille d'un lave-vaisselle, qui permettait aux ordinateurs d'échanger des données entre eux sur une ligne téléphonique jusqu'à 300 caractères par seconde. </font><font style="vertical-align: inherit;">Autrement dit, la construction d'un réseau Bitcoin basé sur les technologies des années 60 du siècle dernier est tout à fait possible. </font><font style="vertical-align: inherit;">Malheureusement, je n'ai pas pu obtenir d'équipement pour le télétraitement des données et tester cette théorie. </font></font><br>
<br>
<img src="https://habrastorage.org/files/a47/6f1/3af/a476f13afad344cf9876fb8ffb151b14.jpg"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le dispositif de transfert de données IBM 1009. Un modem de la taille d'un lave-vaisselle est apparu en 1960. </font><font style="vertical-align: inherit;">Avec lui, il était possible de transmettre jusqu'à 300 caractères par seconde sur une ligne téléphonique. </font><font style="vertical-align: inherit;">Source de la photo: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Introduction aux systèmes de traitement de données IBM)</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></i><br>
<br>
<h2><font color="170ec7"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">résultats</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'utilisation de SHA-256 dans le langage d'assemblage de l'ancien ordinateur central est devenue une expérience difficile mais intéressante. Je m'attendais à de meilleures performances (même par rapport à mon </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">set Mandelbrot en 12 minutes</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). L'arithmétique décimale d'un ordinateur commercial n'est pas la meilleure option pour un algorithme binaire comme SHA-256. Cependant, l'algorithme d'exploration de Bitcoin peut être exécuté même sur un ordinateur sans circuits intégrés. Par conséquent, si soudainement un certain effondrement temporaire me porte à 1960, je peux construire un réseau Bitcoin. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le Mountain View Museum of Computer History montre les IBM 1401 en cours d'exécution les mercredis et samedis. Si vous vous trouvez à proximité, vous devriez certainement y jeter un œil en consultant les </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">horaires</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">travail. </font><font style="vertical-align: inherit;">Et si vous parlez au personnel du musée qui fait la démonstration d'IBM 1401 de moi, ils peuvent même lancer mon </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">programme Pi</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je tiens à remercier le Computer History Museum et les membres de l'équipe de récupération informatique 1401: Robert Garner, Ed Thelen, Van Snyder et surtout Stan Paddock. </font><font style="vertical-align: inherit;">Le </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">site Web de l'</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> équipe </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">ibm-1401.info contient de</font></a><font style="vertical-align: inherit;"> nombreuses informations intéressantes sur l'ordinateur 1401 et comment le restaurer.</font></font><br>
<br>
<h2><font color="170ec7"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Explication</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il est à noter que je n'ai pas écrasé le vrai bloc sur IBM 1401 - le Museum of Computer History ne l'aimerait pas. </font><font style="vertical-align: inherit;">Comme je l’ai dit, avec un IBM 1401 en état de marche, vous ne pourrez pas gagner de l’argent grâce à l’exploitation minière. </font><font style="vertical-align: inherit;">Cependant, j'ai réussi à implémenter et exécuter l'algorithme SHA-256 sur une machine IBM 1401, prouvant ainsi que l'exploitation minière est théoriquement possible. </font><font style="vertical-align: inherit;">Et je vais révéler le secret de la recherche d'un hachage valide - je viens d'utiliser le </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bloc</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> déjà </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">miné</font></a><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous espérons que vous avez apprécié notre traduction</font></font></i><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><img src="https://habrastorage.org/files/1dd/367/7aa/1dd3677aafe64a1e888d52478bfea613.png"></a></div>
      
    </div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr380635/">https://habr.com/ru/post/fr380635/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr380625/index.html">Airbus entre dans la course des lanceurs réutilisables</a></li>
<li><a href="../fr380627/index.html">ICESat-2 déterminera la masse de la couverture de glace de la Terre</a></li>
<li><a href="../fr380629/index.html">Le chirurgien qui prévoit d'effectuer une greffe de tête réalisée avec un patient possible</a></li>
<li><a href="../fr380631/index.html">В Amazon раздумывают над тем, чтобы доставлять товары могли люди, которым «по пути»</a></li>
<li><a href="../fr380633/index.html">Les scientifiques ont fait briller le graphène</a></li>
<li><a href="../fr380637/index.html">La sonde Philae est entrée en mode opérationnel et transmet des données à la Terre (mise à jour)</a></li>
<li><a href="../fr380639/index.html">Stanford et une autre innovation</a></li>
<li><a href="../fr380641/index.html">Test de cartes SD et microSD de 32 gigaoctets</a></li>
<li><a href="../fr380643/index.html">Un microscope portable au service d'un geek</a></li>
<li><a href="../fr380645/index.html">Notes sur la rencontre avec l'Opéra</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>