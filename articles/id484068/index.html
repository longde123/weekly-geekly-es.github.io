<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👺 🏻 🤰🏽 gRPC sebagai protokol komunikasi antar-layanan. Laporan Yandex 🧝🏽 🌷 👨🏽‍🔧</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="gRPC adalah kerangka kerja open source untuk panggilan prosedur jarak jauh. Di Yandex.Market, gRPC digunakan sebagai alternatif yang lebih nyaman untu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>gRPC sebagai protokol komunikasi antar-layanan. Laporan Yandex</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/484068/"> gRPC adalah kerangka kerja open source untuk panggilan prosedur jarak jauh.  Di Yandex.Market, gRPC digunakan sebagai alternatif yang lebih nyaman untuk REST.  Sergey Fedoseenkov, yang menjalankan layanan pengembangan alat untuk mitra Pasar, berbagi pengalamannya menggunakan gRPC sebagai protokol untuk membangun integrasi antara layanan Java dan C ++.  Dari laporan tersebut Anda akan belajar cara menghindari masalah umum jika Anda mulai menggunakan gRPC setelah REST, cara mengembalikan kesalahan, menerapkan penelusuran, permintaan debug, dan menguji panggilan klien.  <a href="https://habr.com/ru/company/yandex/blog/484068">Pada akhirnya</a> ada catatan tidak resmi dari laporan tersebut. <br><br>  - Pertama, saya ingin memperkenalkan Anda beberapa fakta tentang Yandex.Market, mereka akan berguna sebagai bagian dari laporan.  Fakta pertama: kami menulis layanan dalam berbagai bahasa.  Ini membebankan persyaratan pelanggan untuk layanan. <br><a name="habracut"></a><br>  Dan jika kita memiliki layanan di Jawa, alangkah baiknya jika klien untuk itu, misalnya, juga plus atau sedikit. <br><br><img src="https://habrastorage.org/webt/fk/km/ek/fkkmekzj1zv6uobtlxcypvjb5bq.jpeg"><br><br>  Semua layanan yang kami miliki adalah independen, tidak ada rilis besar yang direncanakan dari seluruh Pasar.  Layanan Microsoft akan dirilis secara independen, dan kompatibilitas ke belakang penting bagi kami di sini, sehingga protokol mendukungnya. <br><br>  Fakta ketiga: kami memiliki integrasi sinkron dan asinkron.  Dalam laporan itu, saya terutama akan berbicara tentang sinkron. <br><br>  Apa yang kami gunakan?  Sekarang, tentu saja, dasar dari integrasi kami adalah layanan REST atau seperti REST yang menukar XML / JSON melalui HTTP 1.1.  Ada juga XML-RPC - kami terutama menggunakannya ketika mengintegrasikan dengan kode Python, yaitu, Python memiliki server XML-RPC bawaan.  Cukup nyaman untuk menggunakannya di sana, dan kami mendukungnya. <br><br>  Kami pernah memiliki CORBA.  Untungnya, kami meninggalkannya.  Sekarang kebanyakan REST dan XML / JSON melalui HTTP. <br><br><img src="https://habrastorage.org/webt/mw/we/q6/mwweq653dwqkzn9afcvtqt3temm.jpeg"><br><br>  Integrasi sinkron memiliki masalah dengan protokol yang ada.  Kami menghadapi masalah seperti itu dan mencoba memperlakukannya dengan gRPC.  Apa masalah ini?  Seperti yang saya katakan, saya ingin memiliki pelanggan dalam berbagai bahasa.  Dianjurkan agar mereka tidak harus ditulis sendiri.  Dan, secara umum, akan keren jika klien bisa sinkron dan asinkron - tergantung pada tujuan pengguna layanan. <br><br>  Saya juga ingin protokol yang kami gunakan untuk mendukung kompatibilitas dengan baik: ini sangat penting dengan rilis independen paralel.  Semua rilis kami kompatibel ke belakang, kami tidak memecah umpan balik.  Jika Anda memecahkannya, ini adalah bug, dan Anda hanya perlu memperbaikinya sesegera mungkin. <br><br>  Pendekatan koheren untuk penanganan kesalahan juga diperlukan: semua orang yang membuat layanan REST tahu bahwa Anda tidak bisa hanya menggunakan status HTTP.  Mereka biasanya tidak mengizinkan deskripsi rinci masalah, Anda harus memasukkan beberapa status mereka, detail mereka.  Dalam layanan REST, setiap orang memperkenalkan implementasi kesalahan ini sendiri, setiap kali Anda harus bekerja secara berbeda dengan ini.  Ini tidak selalu nyaman. <br><br>  Saya juga ingin memiliki manajemen batas waktu di sisi klien.  Sekali lagi, mereka yang bekerja dengan HTTP memahami bahwa jika kita menetapkan batas waktu di sisi klien dan berakhir, klien akan berhenti menunggu permintaan selesai, tetapi server tidak akan tahu apa-apa tentang hal itu dan akan terus menjalankannya.  Apalagi di tengah ada berbagai proxy yang mengatur timeout global.  Dan klien mungkin tidak tahu apa-apa tentang mereka dan mengkonfigurasinya tidak selalu sepele. <br><br>  Dan akhirnya, masalah dokumentasi.  Tidak selalu jelas di mana mendapatkan dokumentasi untuk sumber daya REST atau untuk beberapa metode, parameter apa yang mereka terima, badan mana yang dapat ditransfer, dan bagaimana mengkomunikasikan dokumentasi ini dengan konsumen layanan.  Jelas bahwa ada kesombongan, tetapi dengan itu juga, tidak semuanya sepele. <br><br><h3>  gRPC  Teori </h3><br>  Saya ingin berbicara tentang bagian teoretis dari gRPC - apa itu, apa idenya.  Dan kemudian kita akan melanjutkan untuk berlatih. <br><br><img src="https://habrastorage.org/webt/4t/ly/cn/4tlycnzym8eeecxp8_-j2fwedwe.jpeg"><br><br>  Secara umum, gRPC adalah spesifikasi abstrak.  Ini menjelaskan RPC abstrak (panggilan prosedur jarak jauh), yaitu panggilan prosedur jarak jauh yang memiliki properti tertentu.  Sekarang kita akan daftar mereka.  Properti pertama adalah dukungan untuk panggilan tunggal dan streaming.  Artinya, semua layanan yang mengimplementasikan spesifikasi ini mendukung kedua opsi.  Item berikutnya adalah ketersediaan metadata, yaitu, sehingga bersama dengan payload Anda bisa melewati beberapa jenis metadata - syaratnya, header.  Dan - dukungan untuk membatalkan permintaan dan batas waktu di luar kotak. <br><br>  Ini juga mengasumsikan bahwa deskripsi pesan dan layanan itu sendiri dilakukan melalui Bahasa Definisi Antarmuka atau IDL tertentu.  Spesifikasi ini juga menjelaskan protokol kawat melalui HTTP / 2, yaitu, gRPC mengasumsikan bahwa protokol itu hanya berfungsi melalui HTTP / 2. <br><br><img src="https://habrastorage.org/webt/e0/s9/5n/e0s95ncgptmoczazqnei0yns3b4.jpeg"><br><br>  Ada implementasi gRPC khas yang digunakan dalam kebanyakan kasus.  Kami juga menggunakannya, dan sekarang kami akan melihatnya.  Format proto digunakan sebagai IDL.  Plugin gRPC untuk compiler proto memungkinkan Anda untuk mendapatkan sumber layanan yang dihasilkan dari deskripsi proto.  Dan ada pustaka runtime dalam berbagai bahasa - Java, C ++, Python.  Secara umum, hampir semua bahasa populer didukung, pustaka runtime ada untuk mereka.  Dan ketika pesan dipertukarkan di antara layanan, pesan proto digunakan, pesan bergaya sesuai dengan skema protobuf. <br><br><img src="https://habrastorage.org/webt/wy/zp/bh/wyzpbhu3uhozqntsux32nyvpejw.jpeg"><br><br>  Saya ingin terjun sedikit ke beberapa fitur tertentu.  Inilah mereka.  Pengetikan yang kuat, yaitu, pesan proto, adalah pesan yang diketik dengan kuat.  Mereka yang pernah bekerja dengan protobuf tahu bahwa di sana Anda dapat menggambarkan bidang dalam pesan Anda dengan tipe.  Ada jenis primitif dan string, byte array.  Mereka bisa skalar, bisa vektor.  Dan, pada kenyataannya, pesan dapat, sebagai suatu bidang, mengandung pesan lain, yang cukup nyaman, secara umum, model apa pun dapat direpresentasikan. <br><br><img src="https://habrastorage.org/webt/29/oz/e6/29oze6gv_s9vazqemxztvqyrrbs.jpeg"><br><br>  Tentang kompatibilitas ke belakang.  Saya ingin mencatat bahwa proto IDL adalah format di mana kompatibilitas mundur diletakkan di luar kotak, yaitu, itu disusun dengan jaminan kompatibilitas mundur, dan Google merilis versi proto3, yang, dibandingkan dengan proto2, yang meningkatkan kompatibilitas mundur lebih jauh lagi.  Di sana, ditambah, ada segala macam spesifikasi, bagaimana dan apa yang dapat diubah sehingga kompatibilitas mundur dipertahankan dalam beberapa kasus non-sepele. <br><br>  Ada kemungkinan nilai default, Anda dapat menambahkan bidang baru dan konsumen tidak perlu mengubah apa pun, pada kenyataannya.  Semua bidang dalam proto3 bersifat opsional dan, misalnya, dapat dihapus, dan mengakses bidang jarak jauh tidak menyebabkan kesalahan pada klien. <br><br><img src="https://habrastorage.org/webt/dl/ws/kh/dlwskhpcodspqbqkwe-q1ihxaas.jpeg"><br><br>  Fitur gRPC lain adalah bahwa klien dan server dihasilkan menggunakan kompilator proto dan plugin gRPC berdasarkan pada deskripsi proto.  Ada kemungkinan pada saat kode sedang ditulis untuk memilih klien mana yang akan digunakan.  Yaitu, pilih klien asinkron atau sinkron, tergantung pada jenis kode apa yang Anda tulis.  Sebagai contoh, klien asinkron sangat cocok untuk kode reaktif.  Dan kesempatan ini untuk bahasa apa pun.  Yaitu, setelah Anda menulis proto-deskripsi, setelah itu Anda dapat menghasilkan klien untuk bahasa apa pun, dan Anda tidak perlu mengembangkannya secara terpisah.  Anda dapat mendistribusikan antarmuka untuk layanan Anda hanya sebagai proto-deskripsi.  Konsumen mana pun dapat menghasilkan klien untuk dirinya sendiri. <br><br><img src="https://habrastorage.org/webt/ny/at/qr/nyatqr7l4jcnnxrzwudubg0u_wc.jpeg"><br><br>  Tentang pembatalan permintaan dan tenggat waktu, saya ingin mencatat bahwa permintaan dapat dibatalkan di server dan di klien.  Jika kami memahami semuanya, kami tidak perlu memenuhi permintaan lebih lanjut, maka kami dapat membatalkannya.  Dimungkinkan untuk mengatur batas waktu berdasarkan permintaan.  Di gRPC, sebagian besar pustaka runtime menggunakan tenggat waktu sebagai konsep batas waktu.  Tetapi sebenarnya itu sama.  Artinya, ini adalah waktu ketika permintaan harus selesai. <br><br>  Dan hal yang paling menarik adalah server dapat mencari tahu tentang pembatalan permintaan dan tentang berakhirnya batas waktu dan berhenti mengeksekusi permintaan di sisinya.  Ini sangat keren, menurut saya tidak ada banyak tempat lain. <br><br>  Tentang dokumentasi, saya ingin mencatat bahwa karena format proto digunakan dalam IDL untuk gRPC, ini adalah kode biasa.  Di sana Anda dapat menulis komentar, termasuk yang sangat rinci.  Dan Anda perlu memahami bahwa untuk berintegrasi dengan layanan Anda, pengguna Anda perlu memiliki format proto ini di rumah mereka, dan itu akan sampai pada mereka bersama dengan komentar, mereka tidak akan berbohong di tempat lain.  Sangat nyaman.  Dan Anda dapat memperluas uraian ini, yaitu, fitur yang sangat nyaman sehingga dokumentasi berada di sebelah kode, sangat mirip dengan yang terletak di sebelah metode dalam bentuk javadoc atau komentar lainnya. <br><br><h3>  gRPC panggilan unary.  Berlatih </h3><br>  Mari kita lanjutkan, lihat sedikit latihan.  Dan contoh paling dasar menggunakan gRPC adalah apa yang disebut panggilan unary, atau panggilan tunggal.  Ini adalah skema klasik - kami mengirim permintaan ke server dan mendapatkan satu respons dari server.  Sepertinya ini berfungsi di HTTP. <br><br><img src="https://habrastorage.org/webt/dd/lh/kd/ddlhkdqueihh4_s65obi4t9qxns.jpeg"><br><br>  Pertimbangkan contoh layanan gema yang kami lakukan.  Server akan ditulis dalam plus, klien di Jawa.  Sirkuit balancing klasik digunakan di sini.  Yaitu, klien mengatasi penyeimbang, dan kemudian penyeimbang sudah memilih backend spesifik untuk memproses permintaan. <br><br>  Saya ingin memperhatikan - karena gRPC bekerja melalui HTTP / 2, satu koneksi TCP digunakan.  Dan selanjutnya, berbagai aliran melewatinya.  Di sini Anda dapat melihat bahwa koneksi antara klien dan penyeimbang didirikan sekali dan tetap bertahan, dan kemudian penyeimbang menyeimbangkan beban pada backend yang berbeda untuk setiap panggilan.  Jika Anda melihat, itu terjadi seperti ini dan seperti itu jika pesan didistribusikan. <br><br><img src="https://habrastorage.org/webt/yc/tn/fe/yctnfe9-06tb1-en3lvbxlmqbsu.jpeg"><br><br>  Berikut adalah contoh kode untuk file proto kami.  Anda dapat melihat bahwa kami pertama-tama mendeskripsikan pesan, yaitu, kami memiliki EchoRequest dan EchoResponse.  Hanya ada satu bidang string yang menyimpan pesan. <br><br>  Langkah kedua kami jelaskan prosedur kami.  Prosedur input menerima EchoRequest, mengembalikan EchoResponse sebagai hasilnya, semuanya sangat sepele.  Ini adalah deskripsi layanan dan pesan gRPC yang akan dikejar. <br><br><br><img src="https://habrastorage.org/webt/yo/ti/mi/yotimiyugzrzit8vy2xdfn-yely.jpeg"><br><br>  Mari kita lihat bagaimana ini terjadi dalam kasus plus, misalnya.  Itu dirakit dalam tiga tahap.  Pada tahap pertama, tugas kami adalah menghasilkan sumber pesan.  Di sini kami melakukan ini dengan tim ini.  Kami memanggil proto compiler, meneruskan proto-file ke input, menunjukkan tempat untuk meletakkan file output. <br><br>  Tim kedua.  Kami juga menghasilkan layanan dengan cara yang sama.  Satu-satunya perbedaan dengan perintah sebelumnya adalah bahwa kita melewati plugin, dan berdasarkan deskripsi, yang dalam format proto, itu menghasilkan layanan. <br><br>  Langkah ketiga - kami mengumpulkan semua ini dalam satu binar sehingga server kami dapat diluncurkan. <br><br>  Bendera tambahan diteruskan ke tautan, itu disebut grpc ++ _ reflection.  Saya ingin mencatat - server gRPC memiliki fitur seperti itu, refleksi server.  Ini memungkinkan Anda menjelajahi jenis layanan, panggilan RPC, dan pesan yang dimiliki layanan ini.  Secara default, ini dimatikan, dan Anda dapat mengakses layanan hanya jika Anda memiliki format proto.  Tetapi, misalnya, untuk debugging, ini sangat nyaman, tanpa format proto yang ada, cukup nyalakan server dengan fitur refleksi dan segera terima informasi. <br><br><br><img src="https://habrastorage.org/webt/yl/h-/fw/ylh-fw1j3sykaipf5_4c3zvvhgi.jpeg"><br><br>  Sekarang mari kita lihat implementasinya.  Implementasinya juga minimalis.  Artinya, tugas utama kami adalah mengimplementasikan layanan-echo yang dihasilkan.  Ini memiliki satu metode getEcho.  Itu hanya menghasilkan pesan dan mengirimkannya kembali.  Status OK - status sukses. <br><br>  Selanjutnya, kita buat ServerBuilder, daftarkan layanan kami di dalamnya, yang kami bangun sedikit lebih tinggi. <br><br><br><img src="https://habrastorage.org/webt/u8/6l/yz/u86lyzlselt_gi1khgl7l5umzw8.jpeg"><br><br>  Sekarang kita baru mulai dan menunggu permintaan masuk. <br><br><br><img src="https://habrastorage.org/webt/bd/v9/bl/bdv9blqsyc3gbw-atarolnny0ha.jpeg"><br><br><br>  Sekarang mari kita lihat klien di Jawa.  Kami mengumpulkan gradle.  Tugas kita adalah menghubungkan plugin protobuf terlebih dahulu. <br><br>  Ada satu set dependensi dasar yang perlu kami seret untuk layanan kami, mereka diperlukan pada tahap kompilasi. <br><br>  Saya juga ingin mencatat bahwa ada perpustakaan runtime.  Untuk Java, ia menggunakan netty sebagai server dan klien, mendukung HTTP / 2, cukup nyaman dan berkinerja tinggi. <br><br>  Selanjutnya kita mengkonfigurasi proto compiler.  Compiler itu sendiri tidak perlu diinstal secara lokal untuk Java, itu bisa diambil dari artefak. <br><br>  Hal yang sama dengan plugin.  Secara lokal untuk Jawa, tidak perlu.  Anda dapat menyeret artefak.  Dan penting untuk mengonfigurasinya sehingga untuk semua pengocokan juga disebut, sehingga stubs dihasilkan. <br><br><br><img src="https://habrastorage.org/webt/iu/n7/v6/iun7v66-lubn0f1qrwb1napvw6s.jpeg"><br><br><br>  Mari kita beralih ke kode Java.  Di sini kita adalah orang pertama yang membuat rintisan layanan kami.  Itu adalah tugas kami bagi Jawa untuk menyediakan Saluran.  Ada ChannelBuilder di perpustakaan runtime yang dengannya kita dapat membangun saluran ini.  Di sini kita secara manual mengaktifkan teks biasa untuk kesederhanaan, tetapi HTTP2 dan gRPC mengenkripsi semuanya secara default dan menggunakan TLS. <br><br>  Kami memiliki rintisan klien kami, klien sinkron dihasilkan di sini.  Dengan cara yang sama, Anda dapat menghasilkan klien asinkron, ada opsi lain. <br><br>  Selanjutnya, kami membuat permintaan protobuff kami, yaitu, kami membuat pesan protobuff. <br><br><br><img src="https://habrastorage.org/webt/kn/qo/1u/knqo1uengqboh-vagqyfyipqvrs.jpeg"><br><br><br>  Itu saja, kirimkan, pada klien kami, kami memanggil getEcho dan mencetak hasilnya.  Semuanya sederhana.  Seperti yang Anda lihat, diperlukan sedikit kode, dan integrasi dibuat. <br><br><h3>  streaming gRPC.  Berlatih </h3><br>  Sekarang mari kita lihat hal yang lebih maju, ini streaming.  Saya akan memberi tahu Anda cara kerjanya, dan nanti saya akan memberi tahu Anda cara menggunakannya. <br><br><img src="https://habrastorage.org/webt/ly/pu/15/lypu157vtebmx4q8sw11d70gemo.jpeg"><br><br>  Streaming client-server terlihat hampir sama secara arsitektur.  Artinya, kami memiliki koneksi yang terus-menerus antara klien dan penyeimbang.  Kemudian perbedaan dimulai.  Inti dari streaming adalah bahwa klien dilampirkan ke beberapa backend akhir, dan koneksi disimpan melalui.  Begitulah, terus seperti ini.  Dan begitulah.  Di sini saya ingin mencatat secara terpisah bahwa penggunaan penyeimbang tidak tipikal untuk streaming, yaitu, Anda perlu memahami bahwa permintaan streaming bisa berumur panjang.  Artinya, Anda dapat membukanya dan bertukar pesan untuk waktu yang lama.  Dan pesan-pesan ini akan melalui penyeimbang, tetapi, pada kenyataannya, selalu menuju ke backend yang sama.  Dan tidak jelas mengapa itu dibutuhkan sama sekali. <br><br>  Praktik yang umum adalah ketika layanan, misalnya, murni mengalir, atau terutama streaming, maka penemuan layanan digunakan.  GRPC memiliki titik ekstensi tempat penemuan layanan dapat disematkan. <br><br><img src="https://habrastorage.org/webt/dm/5f/lq/dm5flqilbfrmpdwlz-xi-0dn9nw.jpeg"><br><br>  Apa yang kita butuhkan untuk mengimplementasikan layanan streaming?  Kami memiliki format proto yang sama.  Kami menambahkan RPC lain, dan di sini Anda dapat melihat bahwa kami telah menambahkan dua kata kunci sebelum permintaan dan sebelum tanggapan.  Karenanya, kami mendeklarasikan stream EchoRequest dan EchoResponse. <br><br><br><img src="https://habrastorage.org/webt/y7/ji/8i/y7ji8idykqbfsumuuj91t1fwwde.jpeg"><br><br>  Semakin menarik dimulai.  Kompilasi kami tidak berubah dengan cara apa pun agar layanan streaming dapat dilakukan.  Tugas kami selanjutnya adalah mengganti metode baru kami di layanan Echo kami, yang akan berfungsi dengan stream.  Dalam hal server, ini semua agak lebih mudah.  Artinya, kita dapat terus membaca dari aliran dan dapat menjawab sesuatu.  Kami dapat merespons secara tidak sinkron.  Artinya, mereka independen, streaming untuk menulis dan streaming untuk membaca, dan di sini semuanya sederhana untuk skenario sederhana. <br><br><img src="https://habrastorage.org/webt/vv/ih/as/vvihasd7g8s9s8jfxte2lgdkae0.jpeg"><br><br>  Ini bacaannya sekarang, ini rekamannya. <br><br><br><img src="https://habrastorage.org/webt/v_/rb/l_/v_rbl_m4pyxndxrkveev_ibze2q.jpeg"><br><br>  Pada klien Java, banyak hal yang sedikit lebih rumit.  Di sana Anda tidak dapat menggunakan API sinkron apa pun, yaitu, itu hanya tidak berfungsi dengan stream.  Dan di sana API asinkron digunakan.  Artinya, tugas kita adalah mengimplementasikan templat Observer.  Ada antarmuka StreamObserver di sana.  Ini berisi tiga metode: onNext, onCompleted, dan onError.  Di sini, untuk kesederhanaan, saya hanya menerapkan onNext.  Itu berkedut hanya ketika jawabannya datang kepada kami dari server. <br><br><br><img src="https://habrastorage.org/webt/o5/ma/2r/o5ma2rsuawum-empf1enylvayos.jpeg"><br><br>  Di sini saya hanya memasukkan antrian untuk olahpesan di antara utas. <br><br><img src="https://habrastorage.org/webt/wt/pu/zd/wtpuzdzh5dlmkgdxqpkieddlegg.jpeg"><br><br>  Apa bedanya?  Alih-alih memblokir Stub, kami hanya membuat newStub.  Ini adalah implementasi asinkron yang dapat bekerja sama dengan Observer.  Bahkan, Anda dapat melakukan panggilan unary pada Observer, hanya saja tidak begitu nyaman.  Kami, setidaknya, menggunakannya secara tidak aktif. <br><br>  Selanjutnya kita membangun Pengamat kita. <br><br>  Dan kami melakukan panggilan RPC kami.  Kami meneruskan ResponseObserver ke input, dan pada outputnya mengeluarkan RequestObserver kepada kami.  Selanjutnya, kita dapat melakukan panggilan di RequestObserver, sehingga mengirimkan pesan ke server.  Dan ResponseObserver kami akan bergerak dan memproses pesan. <br><br>  Berikut ini sebuah contoh.  Kami baru saja menelepon.  Hubungi onNext, kirimkan Permintaan di sana. <br><br>  Lebih jauh dari antrian, kami menunggu server untuk merespons dan mencetak. <br><br><br><img src="https://habrastorage.org/webt/bg/ta/hq/bgtahqaqbyqbzp72lhix4tzsmii.jpeg"><br><br><br>  Saya ingin menarik perhatian pada kenyataan bahwa tugas kami di sini, sebagai orang yang bertanggung jawab atas implementasi streaming, adalah menangani dengan benar penutupan dari RequestObserver ini.  Artinya, jika terjadi kesalahan, kita harus memanggil metode onError di atasnya, dan dalam kasus penyelesaian yang berhasil, ketika kita percaya bahwa aliran dapat ditutup, kita harus memanggil metode onCompleted. <br><br><img src="https://habrastorage.org/webt/js/4a/ze/js4aze1vr9sb4t9clbpq0obdywy.jpeg"><br><br>  Kami melanjutkan.  Apa saja aplikasi streaming?  Ini adalah hal yang lebih maju, bukan fakta bahwa itu langsung bermanfaat bagi semua orang, tetapi kadang-kadang digunakan.  Artinya, yang pertama mengunduh dan mengunggah sejumlah besar data.  Server atau klien dapat menghasilkan data dalam beberapa bagian.  Bagian-bagian ini mungkin sudah entah bagaimana dikelompokkan pada klien atau di server.  Artinya, Anda sudah bisa melakukan optimasi tambahan di sini. <br><br>  Juga, skema streaming sangat cocok untuk server push.  Anda perlu memahami bahwa saya menganggap opsi paling ekstrem ketika kami memiliki streaming dua arah.  Dan mungkin mengalir dalam satu arah.  Misalnya, dari klien ke server atau dari server ke klien.  Dalam hal server ke klien, kami dapat terhubung ke beberapa server, dan itu akan mengirimkan pushies kepada kami, dan untuk ini kami tidak perlu melakukan polling secara teratur. <br><br>  Keuntungan streaming berikutnya adalah mengikat ke satu mesin.  Seperti yang saya katakan, satu koneksi ujung ke ujung akan dibuat untuk semua pesan di dalam aliran, dan koneksi ini akan diikat ke satu mesin, dan itu pasti tidak akan beralih di mana pun.  Oleh karena itu, adalah mungkin, pertama, untuk menyederhanakan sesuatu, semacam sinkronisasi interserver, dan plus, Anda dapat melakukan hal-hal transaksional. <br><br>  Dan streaming dua arah, hanya contoh yang saya tunjukkan, adalah kemampuan untuk membangun beberapa protokol saya sendiri.  Hal yang cukup menarik.  Kami memiliki antrian internal di Yandex yang hanya menggunakan streaming dua arah.  Dan jika tiba-tiba seseorang memiliki tugas seperti itu, maka peluang yang cukup bagus untuk menggunakannya. <br><br>    ,     .            .            . ,     -   ,      ,      .      .  gRPC    . <br><br><h3>   </h3><br>  ,      gRPC. <br><br><img src="https://habrastorage.org/webt/wl/un/lo/wlunloh9hz1t6cklr4zaqzketmm.jpeg"><br><br>     ,   .   -  .   gRPC    . , ,  ,   , ,   .   ,    runtime- .  ,   .      ,   OK,       runtime- . <br><br> ,  Java      .                    .  google.rpc.Status  3 :  ,   .     ,   .        ,    .  —  ,      ,    . <br><br>      error details,   ,   .   : ,   , , stack traces,      .   ,    . <br><br>    —   ,  HTTP   ,     ?       .     BadRequest   .   ,     ,      error details,   . <br><br>   .   , , BadRequest  -  (   ),     - error detail.       , ,      ,   - .    ,    . <br><br><img src="https://habrastorage.org/webt/dk/dn/zl/dkdnzlcnav_kpnc7e29mv7j5hqa.jpeg"><br><br>       .  .   ,    , ,     .   - -   ,  - - ,     ,  .       .  , , Zipkin.   ,  HTTP    ,  —  metadata.         . <br><br>       ,   .       ,        - ,    ,    ,     . <br><br>     runtime-,           - ,   .  Java  ClientInterceptor  ServerInterceptor.  ,    ,   . ,   ,  ,       ,    ,   - . ,  - API - .    ,  ,  , ,   - .  ,     gRPC,      ,  - .       ,  ,   - , ,  ,  . <br><br><img src="https://habrastorage.org/webt/fy/8u/iz/fy8uiztm6gwxntcvzc8m0qdcply.jpeg"><br><br>   -   .     -.   Java  .       ,       ,    -  .   -  ,     . <br><br><img src="https://habrastorage.org/webt/sb/zx/th/sbzxthmnnf_fh8iyxl9ghv02s4y.jpeg"><br><br>  .   gRPC —  . HTTP/2  .   -   ,   ?    : , .    .   ,    gRPC   grpc_cli,  curl.   ,      . , -,  .    ,    gRPC    ,       . <br><br>    ,  evans.   ,    CLI:   ,     ,  ,  .  ,   .  - , ,  ,   , ,  . <br><br>  -  UI — ,   Postman, —  BloomRPC.     Postman .  Postman, , ,    .   , BloomRPC ,   . <br><br>  -  ,   .  , ,     grpc_cli.          .   ,   .  ,   ,  .       ,       .  , - -  .    — . <br><br><img src="https://habrastorage.org/webt/7y/oe/w3/7yoew3fwgydkvdgiaxm1acueyki.jpeg"><br><br> ,     ,    gRPC.       . -    , -  ,  .  Swagger. ,    HTTP/1    .     OpenAPI   ,        .       . ,        HTTP/2,  Swagger —   . <br><br> WSDL —  ,  .   .       Swagger,     ,   .    .   -. <br><br>  ,  , ,       ,  JAX-RS,   Java  .    . <br><br>     Twirp.   ?     Go,     .     . ,  ,   Go ,   gRPC  Twirp.   ?  ,  gRPC —   ,   , ,  IDL .     proto-  ,        gRPC-.      protoc,       ,       . <br><br>  Twirp     .   proto-      ,    HTTP/1.1    ,   JSON.    ,  Twirp      Go.       ,    ,   Java      Jetty.    ,    . <br><br><img src="https://habrastorage.org/webt/fn/p3/bi/fnp3bihwdt68ttten4_mpx7qal4.jpeg"><br><br>     ? gRPC —    REST   .    ,     ,   , ,  HTTP/2 balancer.   service discovery,    . gRPC ,   .    . <br><br>      gRPC —  ,  .   CLI,   UI. ,        . <br><br>    ,      gRPC.  inter-process-. , sidecar pattern.  ,          .      ,    . ,   -.    -     ,              ,     -.              .      ,  , ,    ,     - . <br><br> ,       .  gRPC    .   ,  .    ,   unary-.         ,      . <br><br>   : <br> — <a href="https://grpc.io/">C  gRPC</a> —   , .  ,    , ,      . <br> — <a href="https://github.com/grpc-ecosystem/awesome-grpc">Awesome gRPC</a> —   GitHub      .      ,    ,   , .  .    —  ,  . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anda dapat menemukan banyak sumber daya lain di Internet, pada beberapa slide. </font><font style="vertical-align: inherit;">Tapi saya paling suka ini. </font><font style="vertical-align: inherit;">Kode yang sedikit dimodifikasi dari presentasi ada di </font></font><a href="https://github.com/homer-j/grpc-examples"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font> Terima kasih <br><br><a name="video1"></a><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pencatatan Laporan Informal</font></font></b> <div class="spoiler_text"><iframe width="560" height="315" src="https://www.youtube.com/embed/AciUs4Yq7oU" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id484068/">https://habr.com/ru/post/id484068/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id484052/index.html">Tugas untuk basis lunar</a></li>
<li><a href="../id484056/index.html">Apakah proyek Anda benar-benar membutuhkan tes?</a></li>
<li><a href="../id484062/index.html">Belajar Bahasa Inggris oleh MEMASICS</a></li>
<li><a href="../id484064/index.html">Bagaimana Cara Menyiapkan Game untuk Pelokalan? 10 Aturan Dasar</a></li>
<li><a href="../id484066/index.html">Uang vs Tim. Bukan aspek yang paling jelas dari hubungan pengusaha, pendiri dan investor</a></li>
<li><a href="../id484070/index.html">Bagaimana kami menulis sistem antifraud di empat tangan dan tiga kepala</a></li>
<li><a href="../id484072/index.html">5. Fortinet Memulai v6.0. NAT</a></li>
<li><a href="../id484076/index.html">Tempat menyimpan cryptocurrency: perpajakan cryptocurrency di berbagai negara</a></li>
<li><a href="../id484084/index.html">1C-Bitrix dan upaya untuk memperkenalkannya</a></li>
<li><a href="../id484088/index.html">Kata sandi hit parade (analisis ~ 5 miliar kata sandi dari kebocoran)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>