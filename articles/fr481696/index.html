<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌴 ↪️ 👨🏾‍🏫 règle: contrôle dynamique de Go 🛌🏽 👩‍👩‍👦‍👦 ♻️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans cet article, je parlerai de la nouvelle bibliothèque (et utilitaire) d'analyse statique go-ruleguard qui adapte gogrep pour une utilisation à l'i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>règle: contrôle dynamique de Go</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/481696/"><p><img src="https://habrastorage.org/webt/b5/p-/sq/b5p-sqgr-9b1e5mimtxaftmryau.png"></p><br><p> Dans cet article, je parlerai de la nouvelle bibliothèque (et utilitaire) d'analyse statique <a href="https://github.com/quasilyte/go-ruleguard"><code>go-ruleguard</code></a> qui adapte <a href="https://github.com/mvdan/gogrep"><code>gogrep</code></a> pour une utilisation à l'intérieur des linters. </p><br><p>  Particularité: vous décrivez les règles de l'analyse statique sur un DSL spécial Go-like, qui au début de <code>ruleguard</code> se transforme en un ensemble de diagnostics.  C'est peut-être l'un des outils les plus faciles à configurer pour implémenter des inspections personnalisées pour Go. </p><br><p>  En bonus, nous parlerons de <a href="https://godoc.org/golang.org/x/tools/go/analysis"><code>go/analysis</code></a> et de ses <a href="https://github.com/go-lintpack/lintpack">prédécesseurs</a> . </p><a name="habracut"></a><br><h1 id="rasshiryaemost-staticheskogo-analiza">  Extensibilité de l'analyse statique </h1><br><p>  Il existe de <a href="https://github.com/golangci/awesome-go-linters">nombreux</a> linters pour Go, dont certains peuvent être étendus.  Habituellement, pour étendre le linter, vous devez écrire du code Go à l'aide de l'API linter spéciale. </p><br><p>  Il existe deux méthodes principales: les <a href="https://golang.org/pkg/plugin/">plugins Go</a> et monolith.  Le monolithe implique que tous les chèques (y compris les vôtres personnels) sont disponibles au stade de la compilation. </p><br><p>  <a href="https://github.com/mgechev/revive"><code>revive</code></a> nécessite que de nouveaux contrôles soient inclus dans son noyau pour l'expansion.  <a href="https://github.com/go-critic/go-critic"><code>go-critic</code></a> en plus de cela peut plug-ins, ce qui vous permet de collecter des extensions quel que soit le code principal.  Ces deux approches impliquent que vous implémentez les manipulations <a href="https://golang.org/pkg/go/ast/"><code>go/ast</code></a> et <a href="https://golang.org/pkg/go/types/"><code>go/types</code></a> sur Go à l'aide de l'API linter.  Même les vérifications simples nécessitent <a href="">beaucoup de code</a> . </p><br><p>  <a href="https://godoc.org/golang.org/x/tools/go/analysis"><code>go/analysis</code></a> vise à simplifier l'image par le fait que le "framework" du linter devient presque identique, mais il ne résout pas le problème de la complexité de la mise en œuvre technique des diagnostics eux-mêmes. </p><br><div class="spoiler">  <b class="spoiler_title">Digression sur `loader` et` go / packages`</b> <div class="spoiler_text"><hr><br><p>  Lorsque vous écrivez un analyseur pour Go, votre objectif final est d'interagir avec l'AST et les types, mais avant de pouvoir le faire, le code source doit être «chargé» correctement.  Pour simplifier, le concept de chargement inclut l' <a href="https://golang.org/pkg/go/parser/">analyse</a> , la vérification de type et l' <a href="https://golang.org/pkg/go/importer/">importation de dépendances</a> . </p><br><p>  La première étape de la simplification de ce pipeline a été le package <a href="https://godoc.org/golang.org/x/tools/go/loader"><code>go/loader</code></a> , qui vous permettra de "télécharger" tout ce dont vous avez besoin en quelques appels.  Tout allait presque bien, puis il est devenu obsolète au profit de <a href="https://godoc.org/golang.org/x/tools/go/packages"><code>go/packages</code></a> .  <code>go/packages</code> a une API légèrement améliorée et, en théorie, fonctionne bien avec les modules. </p><br><p>  Maintenant, pour écrire des analyseurs, il est préférable de ne pas utiliser directement ce qui précède, car <a href="https://godoc.org/golang.org/x/tools/go/analysis"><code>go/analysis</code></a> donné à <code>go/packages</code> quelque chose qu'aucune solution précédente n'avait - une structure pour votre programme.  Nous pouvons maintenant utiliser le paradigme dicté <code>go/analysis</code> et réutiliser les analyseurs plus efficacement.  Ce paradigme a des points controversés, par exemple, <code>go/analysis</code> bien adapté pour l'analyse au niveau d'un package et de ses dépendances, mais faire une analyse globale sur celui-ci sans astuces d'ingénierie astucieuses ne sera pas facile. </p><br><p>  <code>go/analysis</code> simplifie également les <a href="https://godoc.org/golang.org/x/tools/go/analysis/analysistest">tests de l'analyseur</a> . </p><br><hr></div></div><br><h1 id="chto-zhe-takoe-ruleguard">  Qu'est-ce que la règle? </h1><br><p><img src="https://habrastorage.org/webt/zp/ym/rj/zpymrjjb8zkqa_c069ccd-yf3xg.png"></p><br><p>  <a href="https://github.com/quasilyte/go-ruleguard"><code>go-ruleguard</code></a> est un utilitaire d'analyse statique qui, par défaut, n'inclut pas une seule vérification. </p><br><p>  Les règles <code>ruleguard</code> chargées au début, à partir d'un fichier spécial <code>gorules</code> qui décrit de manière déclarative les modèles de code auxquels les avertissements doivent être émis.  Ce fichier peut être édité librement par les utilisateurs de <code>ruleguard</code> . </p><br><p>  Il n'est pas nécessaire de <code>gorules</code> programme de contrôle pour connecter de nouveaux chèques, de sorte que les règles des <code>gorules</code> peuvent être appelées <a href="https://habr.com/ru/company/vk/blog/473718/">dynamiques</a> . </p><br><p>  Le programme de contrôle des <code>ruleguard</code> ressemble à ceci: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"github.com/quasilyte/go-ruleguard/analyzer"</span></span> <span class="hljs-string"><span class="hljs-string">"golang.org/x/tools/go/analysis/singlechecker"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { singlechecker.Main(analyzer.Analyzer) }</code> </pre> <br><p>  Dans le même temps, l' <code>analyzer</code> implémenté via le package <a href="https://godoc.org/github.com/quasilyte/go-ruleguard/ruleguard"><code>ruleguard</code></a> , que vous devez utiliser si vous souhaitez l'utiliser comme bibliothèque. </p><br><h1 id="ruleguard-vs-revive">  règleguard VS revive </h1><br><p>  Prenons un exemple simple mais réel: supposons que nous voulons éviter les <a href="https://golang.org/pkg/runtime/"><code>runtime.GC()</code></a> dans nos programmes.  Dans Revive, il existe déjà un diagnostic distinct pour cela, il est appelé <code>"call-to-gc"</code> . </p><br><div class="spoiler">  <b class="spoiler_title">Implémentation de Call-to-gc (70 lignes en elfique)</b> <div class="spoiler_text"><hr><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> rule <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"go/ast"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/mgechev/revive/lint"</span></span> ) <span class="hljs-comment"><span class="hljs-comment">// CallToGCRule lints calls to the garbage collector. type CallToGCRule struct{} // Apply applies the rule to given file. func (r *CallToGCRule) Apply(file *lint.File, _ lint.Arguments) []lint.Failure { var failures []lint.Failure onFailure := func(failure lint.Failure) { failures = append(failures, failure) } var gcTriggeringFunctions = map[string]map[string]bool{ "runtime": map[string]bool{"GC": true}, } w := lintCallToGC{onFailure, gcTriggeringFunctions} ast.Walk(w, file.AST) return failures } // Name returns the rule name. func (r *CallToGCRule) Name() string { return "call-to-gc" } type lintCallToGC struct { onFailure func(lint.Failure) gcTriggeringFunctions map[string]map[string]bool } func (w lintCallToGC) Visit(node ast.Node) ast.Visitor { ce, ok := node.(*ast.CallExpr) if !ok { return w // nothing to do, the node is not a call } fc, ok := ce.Fun.(*ast.SelectorExpr) if !ok { return nil // nothing to do, the call is not of the form pkg.func(...) } id, ok := fc.X.(*ast.Ident) if !ok { return nil // in case X is not an id (it should be!) } fn := fc.Sel.Name pkg := id.Name if !w.gcTriggeringFunctions[pkg][fn] { return nil // it isn't a call to a GC triggering function } w.onFailure(lint.Failure{ Confidence: 1, Node: node, Category: "bad practice", Failure: "explicit call to the garbage collector", }) return w }</span></span></code> </pre> <br><hr></div></div><br><p>  Comparez maintenant avec la façon dont cela se fait dans <a href="https://github.com/quasilyte/go-ruleguard"><code>go-ruleguard</code></a> : </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> gorules <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/quasilyte/go-ruleguard/dsl/fluent"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">callToGC</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(m fluent.Matcher)</span></span></span></span> { m.Match(<span class="hljs-string"><span class="hljs-string">`runtime.GC()`</span></span>).Report(<span class="hljs-string"><span class="hljs-string">`explicit call to the garbage collector`</span></span>) }</code> </pre> <br><p>  Rien de plus, juste ce qui compte vraiment - <code>runtime.GC</code> et le message qui doit être émis en cas de déclenchement de la règle. </p><br><p>  Vous pouvez vous demander: c'est tout?  J'ai spécifiquement commencé avec un exemple aussi simple pour montrer combien de code pourrait être nécessaire pour un diagnostic très trivial dans le cas de l'approche traditionnelle.  Je promets qu'il y aura des exemples plus excitants. </p><br><h1 id="quick-start">  Démarrage rapide </h1><br><p>  <code>go-critic</code> a un diagnostic <a href="https://go-critic.github.io/overview"><code>rangeExprCopy</code></a> qui trouve des copies de tableau potentiellement inattendues dans le code. </p><br><p>  Ce code est itéré sur une <strong>copie du</strong> tableau: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> xs [<span class="hljs-number"><span class="hljs-number">2048</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, x := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> xs { <span class="hljs-comment"><span class="hljs-comment">// Copies 2048 bytes // Loop body. }</span></span></code> </pre> <br><p>  La solution à ce problème consiste à ajouter un caractère: </p><br><pre> <code class="diff hljs"> var xs [2048]byte - for _, x := range xs { // Copies 2048 bytes + for _, x := range &amp;xs { // No copy // Loop body. }</code> </pre> <br><p>  Très probablement, vous n'avez pas besoin de cette copie et les performances de la version corrigée sont toujours meilleures.  Vous pouvez attendre que le compilateur Go s'améliore, ou vous pouvez détecter de tels endroits dans le code et les corriger aujourd'hui en utilisant le même <code>go-critic</code> . </p><br><p>  Ce diagnostic peut être implémenté dans le langage <code>rules.go</code> (fichier <code>rules.go</code> ): </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> gorules <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/quasilyte/go-ruleguard/dsl/fluent"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> _</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(m fluent.Matcher)</span></span></span></span> { m.Match(<span class="hljs-string"><span class="hljs-string">`for $_, $_ := range $x { $*_ }`</span></span>, <span class="hljs-string"><span class="hljs-string">`for $_, $_ = range $x { $*_ }`</span></span>). Where(m[<span class="hljs-string"><span class="hljs-string">"x"</span></span>].Addressable &amp;&amp; m[<span class="hljs-string"><span class="hljs-string">"x"</span></span>].Type.Size &gt;= <span class="hljs-number"><span class="hljs-number">128</span></span>). Report(<span class="hljs-string"><span class="hljs-string">`$x copy can be avoided with &amp;$x`</span></span>). At(m[<span class="hljs-string"><span class="hljs-string">"x"</span></span>]). Suggest(<span class="hljs-string"><span class="hljs-string">`&amp;$x`</span></span>) }</code> </pre> <br><p>  La règle recherche toutes les boucles <code>for-range</code> où les deux variables itérables sont utilisées (c'est le cas qui conduit à la copie).  L'expression itérable <code>$x</code> doit être <a href="https://golang.org/ref/spec"><code>addressable</code></a> et doit être supérieure au seuil sélectionné en octets. </p><br><p>  <a href="https://godoc.org/github.com/quasilyte/go-ruleguard/dsl/fluent"><code>Report()</code></a> définit le message à <code>quickfix</code> à l'utilisateur, et <a href="https://godoc.org/github.com/quasilyte/go-ruleguard/dsl/fluent"><code>Suggest()</code></a> décrit un modèle de <code>quickfix</code> qui peut être utilisé dans votre éditeur via <a href="https://github.com/golang/tools/tree/master/gopls">gopls</a> (LSP), ainsi qu'interactivement si <code>ruleguard</code> appelé avec l'argument <code>-fix</code> (nous y reviendrons).  <a href="https://godoc.org/github.com/quasilyte/go-ruleguard/dsl/fluent"><code>At()</code></a> attache l'avertissement <strong>et le</strong> <code>quickfix</code> à une partie spécifique du modèle.  Nous en avons besoin pour remplacer <code>$x</code> par <code>&amp;$x</code> , plutôt que de réécrire la boucle entière. </p><br><p>  <code>Report()</code> et <code>Suggest()</code> acceptent une chaîne dans laquelle les expressions capturées par le modèle à partir de <code>Match()</code> peuvent être interpolées.  La variable prédéfinie <code>$$</code> signifie «tout fragment capturé» (comme <code>$0</code> dans les expressions régulières). </p><br><p>  Créez le fichier <code>rangecopy.go</code> : </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> example <span class="hljs-comment"><span class="hljs-comment">// sizeof(builtins[...]) = 240 on x86-64 var builtins = [...]string{ "append", "cap", "close", "complex", "copy", "delete", "imag", "len", "make", "new", "panic", "print", "println", "real", "recover", } func builtinID(name string) int { for i, s := range builtins { if s == name { return i } } return -1 }</span></span></code> </pre> <br><p>  Maintenant, nous pouvons exécuter le <code>ruleguard</code> : </p><br><pre> <code class="bash hljs">$ ruleguard -rules rules.go -fix rangecopy.go rangecopy.go:12:20: builtins copy can be avoided with &amp;builtins</code> </pre> <br><p>  Si après cela, nous regardons <code>rangecopy.go</code> , nous verrons une version fixe, car <code>ruleguard</code> été appelé avec le paramètre <code>-fix</code> . </p><br><p>  Les règles les plus simples peuvent être déboguées sans créer de fichier <code>gorules</code> : </p><br><pre> <code class="plaintext hljs">$ ruleguard -c 1 -e 'm.Match(`return -1`)' rangecopy.go rangecopy.go:17:2: return -1 16 } 17 return -1 18 }</code> </pre> <br><p>  Grâce à l'utilisation de <a href="https://godoc.org/golang.org/x/tools/go/analysis/singlechecker"><code>go/analysis/singlechecker</code></a> , nous avons l'option <code>-c</code> , qui nous permet d'afficher les lignes de contexte spécifiées avec l'avertissement lui-même.  Contrôler ce paramètre est un peu contre-intuitif: la valeur par défaut est <code>-c=-1</code> , ce qui signifie "pas de contexte", et <code>-c=0</code> affichera une ligne de contexte (celle indiquée par les diagnostics). </p><br><p>  Voici quelques <code>gorules</code> plus intéressantes: </p><br><ul><li>  <a href="">Modèles de type</a> qui vous permettent de spécifier les types attendus.  Par exemple, l'expression <code>map[$t]$t</code> décrit toutes les maps dont le type de valeur correspond au type de clé et <code>*[$len]$elem</code> capture tous les pointeurs vers les tableaux. </li><li>  Dans une même fonction, il peut y avoir plusieurs règles, <br>  et les fonctions elles-mêmes devraient être appelées <a href="">groupes de règles</a> . </li><li>  Les règles du groupe sont appliquées les unes après les autres, dans l'ordre dans lequel elles sont définies.  La première règle déclenchée annule la comparaison avec les autres règles.  Ceci est important non pas tant pour l'optimisation que pour la spécialisation des règles pour des cas spécifiques.  Un exemple où cela est utile est la règle de réécriture de <code>$x=$x+$y</code> en <code>$x+=$y</code> , pour le cas avec <code>$y=1</code> vous voulez offrir <code>$x++</code> , pas <code>$x+=1</code> . </li></ul><br><p>  Plus d'informations sur la DSL utilisée peuvent être trouvées dans <a href=""><code>docs/gorules.md</code></a> . </p><br><h1 id="eschyo-bolshe-primerov">  Plus d'exemples </h1><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> gorules <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/quasilyte/go-ruleguard/dsl/fluent"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exampleGroup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(m fluent.Matcher)</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">//     json.Decoder. // . http://golang.org/issue/36225 m.Match(`json.NewDecoder($_).Decode($_)`). Report(`this json.Decoder usage is erroneous`) //   unconvert,    . m.Match(`time.Duration($x) * time.Second`). Where(m["x"].Const). Suggest(`$x * time.Second`) //   fmt.Sprint()    String(), //   $x  . m.Match(`fmt.Sprint($x)`). Where(m["x"].Type.Implements(`fmt.Stringer`)). Suggest(`$x.String()`) //   . m.Match(`!($x != $y)`).Suggest(`$x == $y`) m.Match(`!($x == $y)`).Suggest(`$x != $y`) }</span></span></code> </pre> <br><p>  S'il n'y a pas d'appel <a href="https://godoc.org/github.com/quasilyte/go-ruleguard/dsl/fluent"><code>Report()</code></a> pour la règle, la sortie de message de <a href="https://godoc.org/github.com/quasilyte/go-ruleguard/dsl/fluent"><code>Suggest()</code></a> sera utilisée.  Cela permet dans certains cas d'éviter les doublons. </p><br><p>  Les filtres de type et les sous-expressions peuvent vérifier diverses propriétés.  Par exemple, les propriétés <code>Pure</code> et <code>Const</code> sont utiles: </p><br><ul><li>  <a href="https://godoc.org/github.com/quasilyte/go-ruleguard/dsl/fluent"><code>Var.Pure</code></a> signifie que l'expression n'a aucun effet secondaire. </li><li>  <a href="https://godoc.org/github.com/quasilyte/go-ruleguard/dsl/fluent"><code>Var.Const</code></a> signifie que l'expression peut être utilisée dans un contexte constant (par exemple, la dimension d'un tableau). </li></ul><br><p>  Pour les noms <code>package-qualified</code> dans les conditions <a href="https://godoc.org/github.com/quasilyte/go-ruleguard/dsl/fluent"><code>Where()</code></a> , vous devez utiliser la méthode <a href="https://godoc.org/github.com/quasilyte/go-ruleguard/dsl/fluent"><code>Import()</code></a> .  Pour plus de commodité, tous les packages standard ont été importés pour vous, donc dans l'exemple ci-dessus, nous n'avons pas besoin d'effectuer des importations supplémentaires. </p><br><h1 id="goanalysis-quickfix-actions">  <code>go/analysis</code> actions quickfix </h1><br><p>  Le support de <code>quickfix</code> par <code>go/analysis</code> pour nous. </p><br><p>  Dans le modèle <code>go/analysis</code> , l'analyseur génère des <a href="https://godoc.org/golang.org/x/tools/go/analysis">diagnostics</a> et des <a href="https://godoc.org/golang.org/x/tools/go/analysis">faits</a> .  Les diagnostics sont envoyés aux utilisateurs et les faits sont destinés à être utilisés par d'autres analyseurs. </p><br><p>  Les diagnostics peuvent avoir un ensemble de <a href="https://godoc.org/golang.org/x/tools/go/analysis">correctifs suggérés</a> , chacun décrivant comment modifier les codes source dans la plage spécifiée afin de résoudre le problème détecté par les diagnostics. </p><br><p>  La description officielle est disponible dans <a href=""><code>go/analysis/doc/suggested_fixes.md</code></a> . </p><br><h1 id="zaklyuchenie">  Conclusion </h1><br><p><img src="https://habrastorage.org/webt/m3/bs/zw/m3bszwzp2nwkxrnxdnenypatyjk.png"></p><br><p>  Essayez <code>ruleguard</code> sur vos projets, et si vous trouvez un bug ou si vous souhaitez demander une nouvelle fonctionnalité, <a href="https://github.com/quasilyte/go-ruleguard/issues/new">ouvrez le problème</a> . </p><br><p>  Si vous trouvez toujours difficile de trouver une application de <code>ruleguard</code> , voici quelques exemples: </p><br><ul><li>  Implémentez vos propres diagnostics pour Go. </li><li>  <code>-fix</code> niveau ou refactoriser automatiquement le code avec <code>-fix</code> . </li><li>  Collection de statistiques de code avec traitement <a href=""><code>-json</code></a> du résultat de l' <a href=""><code>-json</code></a> . </li></ul><br><p>  Plans de développement de <code>ruleguard</code> dans un avenir proche: </p><br><ul><li>  <code>ruleguard</code> <a href="https://github.com/go-critic/go-critic"><code>go-critic</code></a> <code>ruleguard</code> à <a href="https://github.com/go-critic/go-critic"><code>go-critic</code></a> comme un moyen de l'étendre. </li><li>  Essayez les idées de l' <a href="https://github.com/quasilyte/talks/tree/master/2019-7-Oct-moscow">analyse de similitude du code Applied Go</a> . </li><li>  Ajoutez de nouvelles fonctionnalités à DSL.  <a href="https://github.com/quasilyte/go-ruleguard/issues/28">les sous-correspondances</a> peuvent être un ajout utile. </li></ul><br><h1 id="poleznye-ssylki-i-resursy">  Liens et ressources utiles </h1><br><ul><li>  Exemple de fichier de règles recommandé: <a href=""><code>rules.go</code></a> </li><li> <a href="https://godoc.org/github.com/quasilyte/go-ruleguard/dsl/fluent"><code> dsl/fluent</code></a> </li> <li> <a href="https://godoc.org/github.com/quasilyte/go-ruleguard/ruleguard"><code> ruleguard</code></a> </li> <li>  <a href="https://github.com/mvdan/gogrep"><code>mvdan/gogrep</code></a> AST utilisé: <a href="https://github.com/mvdan/gogrep"><code>mvdan/gogrep</code></a> </li><li>  <a href="https://habr.com/ru/company/vk/blog/473718/">Contrôles dynamiques dans NoVerify</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr481696/">https://habr.com/ru/post/fr481696/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr481680/index.html">Ecrire TodoMVC sur dap. 2e partie</a></li>
<li><a href="../fr481684/index.html">Un ordinateur portable de Powerbank?</a></li>
<li><a href="../fr481688/index.html">Pourquoi apprendre Java et comment le faire efficacement. Rapport Yandex</a></li>
<li><a href="../fr481692/index.html">Utilisation de Intel Processor Trace pour tracer le code du mode de gestion du système</a></li>
<li><a href="../fr481694/index.html">Ma façon de partitionner dans PostgreSQL</a></li>
<li><a href="../fr481698/index.html">WebRTC en streaming dans et autour de la réalité virtuelle</a></li>
<li><a href="../fr481700/index.html">Une tante</a></li>
<li><a href="../fr481702/index.html">Du grille-pain au drone. Comment Internet des objets est-il né et pourquoi ne s'est-il déclenché que 30 ans plus tard</a></li>
<li><a href="../fr481704/index.html">C'est la norme - 2: comment les cartes normales sont cuites</a></li>
<li><a href="../fr481706/index.html">Des ordinateurs quantiques perdus dans la course et leurs erreurs fatales</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>