<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚤 📟 🐃 Lección para la noche: escribir resaltado de sintaxis 🕺🏿 📺 🐲</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recientemente me interesé en cómo se organiza el resaltado del código desde adentro. Al principio parecía que todo era muy complicado allí: un árbol d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Lección para la noche: escribir resaltado de sintaxis</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/482884/"> Recientemente me interesé en cómo se organiza el resaltado del código desde adentro.  Al principio parecía que todo era muy complicado allí: un árbol de sintaxis, recursión, y eso era todo.  Sin embargo, después de una inspección más cercana, resultó que no hay nada difícil aquí.  Todo el trabajo se puede hacer en un ciclo con miradas de un lado a otro, además, las expresiones regulares casi nunca se usan en el script resultante. <br><br>  Página de demostración: <a href="https://astynk.github.io/highlight.html">resaltador de código Javascript</a> <br><a name="habracut"></a><br><h2>  Idea principal </h2><br>  Declaramos la variable de <i>estado</i> , que almacenará información sobre en qué parte del código estamos.  Si, por ejemplo, el <i>estado</i> es igual a uno, esto significa que estamos dentro de una cadena con comillas simples.  El script esperará la cita de cierre e ignorará todo lo demás.  Lo mismo con resaltar comentarios, expresiones regulares y otros elementos, cada uno tiene su propio valor de <i>estado</i> .  Por lo tanto, diferentes caracteres de apertura y cierre no entrarán en conflicto;  en otras palabras, un código como este: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a = <span class="hljs-string"><span class="hljs-string">'"\'"'</span></span>;</code> </pre> <br>  se resaltará correctamente, es decir, tales casos causaron la mayoría de las dificultades. <br><br><h2>  Empezando </h2><br>  Determinamos los posibles valores de la variable de estado, así como el color en el que se pintará esta o aquella parte del código, así como una lista de palabras clave de Javascript (que también se resaltará): <br><br><div class="spoiler">  <b class="spoiler_title">estados const = {...</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> states = { <span class="hljs-attr"><span class="hljs-attr">NONE</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">SINGLE_QUOTE</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-comment"><span class="hljs-comment">// 'string' DOUBLE_QUOTE : 2, // "string" ML_QUOTE : 3, // `string` REGEX_LITERAL : 4, // /regex/ SL_COMMENT : 5, // // single line comment ML_COMMENT : 6, // /* multiline comment */ NUMBER_LITERAL : 7, // 123 KEYWORD : 8 // function, var etc. }; const colors = { NONE : '#000', SINGLE_QUOTE : '#aaa', // 'string' DOUBLE_QUOTE : '#aaa', // "string" ML_QUOTE : '#aaa', // `string` REGEX_LITERAL : '#707', // /regex/ SL_COMMENT : '#0a0', // // single line comment ML_COMMENT : '#0a0', // /* multiline comment */ NUMBER_LITERAL : '#a00', // 123 KEYWORD : '#00a', // function, var etc. OPERATOR : '#07f' // null, true etc. }; const keywords = 'async|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|of|package|private|protected|public|return|set|static|super|switch|throw|try|typeof|var|void|while|with|yield|catch|finally'.split('|');</span></span></code> </pre><br></div></div><br>  A continuación, creamos una función que tomará una línea con el código y devolverá el HTML terminado con el código resaltado.  Para resaltar, los caracteres se envolverán en SPAN con el color especificado en la variable de <i>colores</i> . <br><br>  La función tendrá solo un ciclo, que analiza cada carácter y agrega SPAN de apertura / cierre cuando sea necesario. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">highlight</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">code</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> output = <span class="hljs-string"><span class="hljs-string">''</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> state = states.NONE; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; code.length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> char = code[i], prev = code[i<span class="hljs-number"><span class="hljs-number">-1</span></span>], next = code[i+<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-comment"><span class="hljs-comment">//     } return output; }</span></span></code> </pre> <br>  Primero, resalte los comentarios: una línea y varias líneas.  Si el carácter actual y el siguiente es una barra diagonal y no están dentro de la línea (el <i>estado</i> es 0, es decir, <i>estados</i> . <i>NINGUNO</i> ), entonces este es el comienzo del comentario.  Cambiar <i>estado</i> y abrir SPAN con el color deseado: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == states.NONE &amp;&amp; char == <span class="hljs-string"><span class="hljs-string">'/'</span></span> &amp;&amp; next == <span class="hljs-string"><span class="hljs-string">'/'</span></span>) { state = states.SL_COMMENT; output += <span class="hljs-string"><span class="hljs-string">'&lt;span style="color: '</span></span> + colors.SL_COMMENT + <span class="hljs-string"><span class="hljs-string">'"&gt;'</span></span> + char; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br>  <i>continuar es</i> necesario para que las siguientes comprobaciones no funcionen y no se produzca un conflicto. <br><br>  A continuación, esperamos el final de la línea: si el carácter actual es un salto de línea y en <i>estado un</i> comentario de <i>una</i> sola línea, cierre el SPAN y cambie el <i>estado</i> a cero: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == states.SL_COMMENT &amp;&amp; char == <span class="hljs-string"><span class="hljs-string">'\n'</span></span>) { state = states.NONE; output += char + <span class="hljs-string"><span class="hljs-string">'&lt;/span&gt;'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br>  Del mismo modo, estamos buscando comentarios de varias líneas, el algoritmo es exactamente el mismo, solo los caracteres que está buscando son diferentes: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == states.NONE &amp;&amp; char == <span class="hljs-string"><span class="hljs-string">'/'</span></span> &amp;&amp; next == <span class="hljs-string"><span class="hljs-string">'*'</span></span>) { state = states.ML_COMMENT; output += <span class="hljs-string"><span class="hljs-string">'&lt;span style="color: '</span></span> + colors.ML_COMMENT + <span class="hljs-string"><span class="hljs-string">'"&gt;'</span></span> + char; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == states.ML_COMMENT &amp;&amp; char == <span class="hljs-string"><span class="hljs-string">'/'</span></span> &amp;&amp; prev == <span class="hljs-string"><span class="hljs-string">'*'</span></span>) { state = states.NONE; output += char + <span class="hljs-string"><span class="hljs-string">'&lt;/span&gt;'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br>  El resaltado de las cadenas se produce de manera similar, solo debe tenerse en cuenta que la comilla de cierre se puede escapar con una barra diagonal inversa y, por lo tanto, ya no es una barra diagonal. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == states.NONE &amp;&amp; char == <span class="hljs-string"><span class="hljs-string">'\''</span></span>) { state = states.SINGLE_QUOTE; output += <span class="hljs-string"><span class="hljs-string">'&lt;span style="color: '</span></span> + colors.SINGLE_QUOTE + <span class="hljs-string"><span class="hljs-string">'"&gt;'</span></span> + char; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == states.SINGLE_QUOTE &amp;&amp; char == <span class="hljs-string"><span class="hljs-string">'\''</span></span> &amp;&amp; prev != <span class="hljs-string"><span class="hljs-string">'\\'</span></span>) { state = states.NONE; output += char + <span class="hljs-string"><span class="hljs-string">'&lt;/span&gt;'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br>  El código es similar a lo que ya estaba arriba, solo que ahora no registramos el final de la línea si hubo una barra invertida antes de la cotización. <br><br>  La definición de cadenas entre comillas dobles ocurre exactamente de la misma manera, y tiene poco sentido analizarlas en detalle.  Para completar la imagen, los colocaré debajo del spoiler. <br><br><div class="spoiler">  <b class="spoiler_title">if (state == states.NONE &amp;&amp; char == '' '') {...</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == states.NONE &amp;&amp; char == <span class="hljs-string"><span class="hljs-string">'"'</span></span>) { state = states.DOUBLE_QUOTE; output += <span class="hljs-string"><span class="hljs-string">'&lt;span style="color: '</span></span> + colors.DOUBLE_QUOTE + <span class="hljs-string"><span class="hljs-string">'"&gt;'</span></span> + char; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == states.DOUBLE_QUOTE &amp;&amp; char == <span class="hljs-string"><span class="hljs-string">'"'</span></span> &amp;&amp; prev != <span class="hljs-string"><span class="hljs-string">'\\'</span></span>) { state = states.NONE; output += char + <span class="hljs-string"><span class="hljs-string">'&lt;/span&gt;'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == states.NONE &amp;&amp; char == <span class="hljs-string"><span class="hljs-string">'`'</span></span>) { state = states.ML_QUOTE; output += <span class="hljs-string"><span class="hljs-string">'&lt;span style="color: '</span></span> + colors.ML_QUOTE + <span class="hljs-string"><span class="hljs-string">'"&gt;'</span></span> + char; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == states.ML_QUOTE &amp;&amp; char == <span class="hljs-string"><span class="hljs-string">'`'</span></span> &amp;&amp; prev != <span class="hljs-string"><span class="hljs-string">'\\'</span></span>) { state = states.NONE; output += char + <span class="hljs-string"><span class="hljs-string">'&lt;/span&gt;'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br></div></div><br>  Los literales Regexp, que se confunden fácilmente con el signo de división, merecen una consideración aparte.  Volveremos a este problema al final del artículo, pero por ahora estamos haciendo lo mismo con expresiones regulares que con cadenas. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == states.NONE &amp;&amp; char == <span class="hljs-string"><span class="hljs-string">'/'</span></span>) { state = states.REGEX_LITERAL; output += <span class="hljs-string"><span class="hljs-string">'&lt;span style="color: '</span></span> + colors.REGEX_LITERAL + <span class="hljs-string"><span class="hljs-string">'"&gt;'</span></span> + char; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == states.REGEX_LITERAL &amp;&amp; char == <span class="hljs-string"><span class="hljs-string">'/'</span></span> &amp;&amp; prev != <span class="hljs-string"><span class="hljs-string">'\\'</span></span>) { state = states.NONE; output += char + <span class="hljs-string"><span class="hljs-string">'&lt;/span&gt;'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br>  Esto finaliza casos simples cuando el principio y el final de un literal se pueden determinar con 1-2 caracteres.  Comencemos por resaltar números: como saben, siempre comienzan con un número, pero pueden tener letras en la composición ( <i>0xFF</i> , <i>123n</i> ). <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == states.NONE &amp;&amp; <span class="hljs-regexp"><span class="hljs-regexp">/[0-9]/</span></span>.test(char) &amp;&amp; !<span class="hljs-regexp"><span class="hljs-regexp">/[0-9a-z$_]/i</span></span>.test(prev)) { state = states.NUMBER_LITERAL; output += <span class="hljs-string"><span class="hljs-string">'&lt;span style="color: '</span></span> + colors.NUMBER_LITERAL + <span class="hljs-string"><span class="hljs-string">'"&gt;'</span></span> + char; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == states.NUMBER_LITERAL &amp;&amp; !<span class="hljs-regexp"><span class="hljs-regexp">/[0-9a-fnx]/i</span></span>.test(char)) { state = states.NONE; output += <span class="hljs-string"><span class="hljs-string">'&lt;/span&gt;'</span></span> }</code> </pre> <br>  Aquí estamos buscando el comienzo de un número: el carácter anterior no debe ser un número o letra, de lo contrario, se resaltarán los números en los nombres de las variables.  Tan pronto como el carácter actual no sea un número o una letra que pueda estar contenida en el literal de un número, cierre el SPAN y establezca el <i>estado en</i> cero. <br><br>  Todos los tipos posibles de literales están resaltados, la búsqueda de palabras clave permanece.  Para hacer esto, necesita un bucle anidado que mire hacia adelante y determine si el carácter actual es el comienzo de la palabra clave. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == states.NONE &amp;&amp; !<span class="hljs-regexp"><span class="hljs-regexp">/[a-z0-9$_]/i</span></span>.test(prev)) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> word = <span class="hljs-string"><span class="hljs-string">''</span></span>, j = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (code[i + j] &amp;&amp; <span class="hljs-regexp"><span class="hljs-regexp">/[az]/i</span></span>.test(code[i + j])) { word += code[i + j]; j++; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (keywords.includes(word)) { state = states.KEYWORD; output += <span class="hljs-string"><span class="hljs-string">'&lt;span style="color: '</span></span> + colors.KEYWORD + <span class="hljs-string"><span class="hljs-string">'"&gt;'</span></span>; } }</code> </pre> <br>  Aquí miramos, el carácter anterior no puede estar en el nombre de la variable; de ​​lo contrario, <i>deje</i> que la palabra clave se resalte en la <i>salida de</i> la palabra.  Luego, el bucle anidado recopila la palabra más larga posible hasta que se encuentre un carácter no alfabético.  Si la palabra recibida está en la matriz de <i>palabras clave</i> , abra el SPAN y comience a resaltar la palabra.  Tan pronto como se encuentre un carácter no alfabético, esto significa el final de la palabra; en consecuencia, cierre el SPAN: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == states.KEYWORD &amp;&amp; !<span class="hljs-regexp"><span class="hljs-regexp">/[az]/i</span></span>.test(char)) { state = states.NONE; output += <span class="hljs-string"><span class="hljs-string">'&lt;/span&gt;'</span></span>; }</code> </pre> <br>  Lo más simple sigue siendo: el resaltado de operadores, aquí simplemente puede comparar con el conjunto de caracteres que pueden aparecer en los operadores: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == states.NONE &amp;&amp; <span class="hljs-string"><span class="hljs-string">'+-/*=&amp;|%!&lt;&gt;?:'</span></span>.indexOf(char) != <span class="hljs-number"><span class="hljs-number">-1</span></span>) { output += <span class="hljs-string"><span class="hljs-string">'&lt;span style="color: '</span></span> + colors.OPERATOR + <span class="hljs-string"><span class="hljs-string">'"&gt;'</span></span> + char + <span class="hljs-string"><span class="hljs-string">'&lt;/span&gt;'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br>  Al final del ciclo, si no se activa ninguna de las condiciones que <i>continúan la</i> causa <i>continua</i> , simplemente agregamos el carácter actual a la variable resultante.  Cuando se produce el comienzo o el final de un literal o palabra clave, abrimos / cerramos el SPAN con color;  en todos los demás casos, por ejemplo, cuando la línea ya está abierta, solo lanzamos un carácter a la vez.  También vale la pena proteger los soportes de ángulo de apertura, de lo contrario pueden romper el diseño. <br><br><pre> <code class="javascript hljs">output += char.replace(<span class="hljs-string"><span class="hljs-string">'&lt;'</span></span>, <span class="hljs-string"><span class="hljs-string">'&amp;'</span></span> + <span class="hljs-string"><span class="hljs-string">'lt;'</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  +      &lt;</span></span></code> </pre> <br><h2>  Corrección de errores </h2><br>  Todo parecía de alguna manera demasiado simple, y no en vano: con pruebas más exhaustivas, había casos en los que la luz de fondo no funcionaba correctamente. <br><br>  La división se reconoce como regexp, para distinguir una de la otra, será necesario cambiar la forma en que se determina regexp.  Declaramos que la variable <i>esRegex = true</i> , después de lo cual trataremos de "probar" que esto no es regexp, sino un signo de división.  No puede haber palabras clave o corchetes de apertura antes de la operación de división; por lo tanto, creamos un bucle anidado y vemos a qué se enfrenta la barra diagonal. <br><br><div class="spoiler">  <b class="spoiler_title">Como era antes</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == states.NONE &amp;&amp; char == <span class="hljs-string"><span class="hljs-string">'/'</span></span>) { state = states.REGEX_LITERAL; output += <span class="hljs-string"><span class="hljs-string">'&lt;span style="color: '</span></span> + colors.REGEX_LITERAL + <span class="hljs-string"><span class="hljs-string">'"&gt;'</span></span> + char; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br></div></div><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == states.NONE &amp;&amp; char == <span class="hljs-string"><span class="hljs-string">'/'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> word = <span class="hljs-string"><span class="hljs-string">''</span></span>, j = <span class="hljs-number"><span class="hljs-number">0</span></span>, isRegex = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (i + j &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { j--; <span class="hljs-comment"><span class="hljs-comment">//        if ('+/-*=|&amp;&lt;&gt;%,({[?:;'.indexOf(code[i+j]) != -1) break; //   ;   -   if (!/[0-9a-z$_]/i.test(code[i+j]) &amp;&amp; word.length &gt; 0) break; //  ,     if (/[0-9a-z$_]/i.test(code[i+j])) word = code[i+j] + word; //   - ,     if (')]}'.indexOf(code[i+j]) != -1) { isRegex = false; break; } } //      -    //  : return /test/g - , plainWord /test/g -  if (word.length &gt; 0 &amp;&amp; !keywords.includes(word)) isRegex = false; if (isRegex) { state = states.REGEX_LITERAL; output += '&lt;span style="color: ' + colors.REGEX_LITERAL + '"&gt;' + char; continue; } }</span></span></code> </pre> <br>  Aunque este enfoque resuelve el problema, todavía no está exento de defectos.  Puede ajustarlo para que este algoritmo también se resalte incorrectamente, por ejemplo: <i>if (a) / regex /</i> or so: <i>1 / / regex / / 2</i> .  ¿Por qué una persona que divide los números en expresiones regulares necesita resaltar el código? Esta es otra pregunta;  El diseño es sintácticamente correcto, aunque no ocurre en la vida real. <br><br>  Hay problemas con la coloración regexp en muchas obras, por ejemplo en <a href="https://prismjs.com/test.html">prism.js</a> .  Aparentemente, para resaltar correctamente las expresiones regulares, debe comprender completamente la sintaxis, como lo hacen los navegadores. <br><br>  El segundo error con el que tuve que lidiar estaba relacionado con las barras invertidas.  No se reconoció una comilla de cierre en una cadena de la forma <i>'test \\'</i> debido a la presencia de una barra invertida frente a ella.  Volver a la condición que atrapa el final de la línea: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == states.SINGLE_QUOTE &amp;&amp; char == <span class="hljs-string"><span class="hljs-string">'\''</span></span> &amp;&amp; prev != <span class="hljs-string"><span class="hljs-string">'\\'</span></span>)</code> </pre> <br>  La última parte de la condición debe cambiarse: si la barra invertida se escapa (es decir, hay otra barra invertida antes), entonces registre el final de la línea. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> closingCharNotEscaped = prev != <span class="hljs-string"><span class="hljs-string">'\\'</span></span> || prev == <span class="hljs-string"><span class="hljs-string">'\\'</span></span> &amp;&amp; code[i<span class="hljs-number"><span class="hljs-number">-2</span></span>] == <span class="hljs-string"><span class="hljs-string">'\\'</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ... if (state == states.SINGLE_QUOTE &amp;&amp; char == '\'' &amp;&amp; closingCharNotEscaped)</span></span></code> </pre> <br>  Se deben hacer los mismos reemplazos en la búsqueda de cadenas con comillas dobles e inversas, así como en la búsqueda de expresiones regulares. <br><br>  Eso es todo, puede probar el resaltado mediante el enlace al comienzo del artículo. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/482884/">https://habr.com/ru/post/482884/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../482872/index.html">Polígonos otro mundo</a></li>
<li><a href="../482874/index.html">La muerte de Koshchei en la lista de recomendaciones (¿puedes hacer que YouTube sea cómodo y seguro?)</a></li>
<li><a href="../482876/index.html">Cálculo del costo de producción de electricidad solar para las necesidades propias de un hogar en el centro de Europa</a></li>
<li><a href="../482878/index.html">Cómo busqué la definición de "producto"</a></li>
<li><a href="../482882/index.html">Motor como freno electromagnético</a></li>
<li><a href="../482886/index.html">Análisis de habra: ¿es importante la duración de la publicación?</a></li>
<li><a href="../482888/index.html">Lanzar un servidor VPN detrás del proveedor NAT</a></li>
<li><a href="../482892/index.html">Let vs const: ¿qué usar?</a></li>
<li><a href="../482894/index.html">Generación de procedimientos adaptativos utilizando el algoritmo WaveFunctionCollapse y la distribución de probabilidad a priori</a></li>
<li><a href="../482896/index.html">OSCP - Mi experiencia</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>