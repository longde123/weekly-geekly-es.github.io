<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üö§ üìü üêÉ Lecci√≥n para la noche: escribir resaltado de sintaxis üï∫üèø üì∫ üê≤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recientemente me interes√© en c√≥mo se organiza el resaltado del c√≥digo desde adentro. Al principio parec√≠a que todo era muy complicado all√≠: un √°rbol d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Lecci√≥n para la noche: escribir resaltado de sintaxis</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/482884/"> Recientemente me interes√© en c√≥mo se organiza el resaltado del c√≥digo desde adentro.  Al principio parec√≠a que todo era muy complicado all√≠: un √°rbol de sintaxis, recursi√≥n, y eso era todo.  Sin embargo, despu√©s de una inspecci√≥n m√°s cercana, result√≥ que no hay nada dif√≠cil aqu√≠.  Todo el trabajo se puede hacer en un ciclo con miradas de un lado a otro, adem√°s, las expresiones regulares casi nunca se usan en el script resultante. <br><br>  P√°gina de demostraci√≥n: <a href="https://astynk.github.io/highlight.html">resaltador de c√≥digo Javascript</a> <br><a name="habracut"></a><br><h2>  Idea principal </h2><br>  Declaramos la variable de <i>estado</i> , que almacenar√° informaci√≥n sobre en qu√© parte del c√≥digo estamos.  Si, por ejemplo, el <i>estado</i> es igual a uno, esto significa que estamos dentro de una cadena con comillas simples.  El script esperar√° la cita de cierre e ignorar√° todo lo dem√°s.  Lo mismo con resaltar comentarios, expresiones regulares y otros elementos, cada uno tiene su propio valor de <i>estado</i> .  Por lo tanto, diferentes caracteres de apertura y cierre no entrar√°n en conflicto;  en otras palabras, un c√≥digo como este: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a = <span class="hljs-string"><span class="hljs-string">'"\'"'</span></span>;</code> </pre> <br>  se resaltar√° correctamente, es decir, tales casos causaron la mayor√≠a de las dificultades. <br><br><h2>  Empezando </h2><br>  Determinamos los posibles valores de la variable de estado, as√≠ como el color en el que se pintar√° esta o aquella parte del c√≥digo, as√≠ como una lista de palabras clave de Javascript (que tambi√©n se resaltar√°): <br><br><div class="spoiler">  <b class="spoiler_title">estados const = {...</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> states = { <span class="hljs-attr"><span class="hljs-attr">NONE</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">SINGLE_QUOTE</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-comment"><span class="hljs-comment">// 'string' DOUBLE_QUOTE : 2, // "string" ML_QUOTE : 3, // `string` REGEX_LITERAL : 4, // /regex/ SL_COMMENT : 5, // // single line comment ML_COMMENT : 6, // /* multiline comment */ NUMBER_LITERAL : 7, // 123 KEYWORD : 8 // function, var etc. }; const colors = { NONE : '#000', SINGLE_QUOTE : '#aaa', // 'string' DOUBLE_QUOTE : '#aaa', // "string" ML_QUOTE : '#aaa', // `string` REGEX_LITERAL : '#707', // /regex/ SL_COMMENT : '#0a0', // // single line comment ML_COMMENT : '#0a0', // /* multiline comment */ NUMBER_LITERAL : '#a00', // 123 KEYWORD : '#00a', // function, var etc. OPERATOR : '#07f' // null, true etc. }; const keywords = 'async|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|of|package|private|protected|public|return|set|static|super|switch|throw|try|typeof|var|void|while|with|yield|catch|finally'.split('|');</span></span></code> </pre><br></div></div><br>  A continuaci√≥n, creamos una funci√≥n que tomar√° una l√≠nea con el c√≥digo y devolver√° el HTML terminado con el c√≥digo resaltado.  Para resaltar, los caracteres se envolver√°n en SPAN con el color especificado en la variable de <i>colores</i> . <br><br>  La funci√≥n tendr√° solo un ciclo, que analiza cada car√°cter y agrega SPAN de apertura / cierre cuando sea necesario. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">highlight</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">code</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> output = <span class="hljs-string"><span class="hljs-string">''</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> state = states.NONE; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; code.length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> char = code[i], prev = code[i<span class="hljs-number"><span class="hljs-number">-1</span></span>], next = code[i+<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-comment"><span class="hljs-comment">//     } return output; }</span></span></code> </pre> <br>  Primero, resalte los comentarios: una l√≠nea y varias l√≠neas.  Si el car√°cter actual y el siguiente es una barra diagonal y no est√°n dentro de la l√≠nea (el <i>estado</i> es 0, es decir, <i>estados</i> . <i>NINGUNO</i> ), entonces este es el comienzo del comentario.  Cambiar <i>estado</i> y abrir SPAN con el color deseado: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == states.NONE &amp;&amp; char == <span class="hljs-string"><span class="hljs-string">'/'</span></span> &amp;&amp; next == <span class="hljs-string"><span class="hljs-string">'/'</span></span>) { state = states.SL_COMMENT; output += <span class="hljs-string"><span class="hljs-string">'&lt;span style="color: '</span></span> + colors.SL_COMMENT + <span class="hljs-string"><span class="hljs-string">'"&gt;'</span></span> + char; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br>  <i>continuar es</i> necesario para que las siguientes comprobaciones no funcionen y no se produzca un conflicto. <br><br>  A continuaci√≥n, esperamos el final de la l√≠nea: si el car√°cter actual es un salto de l√≠nea y en <i>estado un</i> comentario de <i>una</i> sola l√≠nea, cierre el SPAN y cambie el <i>estado</i> a cero: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == states.SL_COMMENT &amp;&amp; char == <span class="hljs-string"><span class="hljs-string">'\n'</span></span>) { state = states.NONE; output += char + <span class="hljs-string"><span class="hljs-string">'&lt;/span&gt;'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br>  Del mismo modo, estamos buscando comentarios de varias l√≠neas, el algoritmo es exactamente el mismo, solo los caracteres que est√° buscando son diferentes: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == states.NONE &amp;&amp; char == <span class="hljs-string"><span class="hljs-string">'/'</span></span> &amp;&amp; next == <span class="hljs-string"><span class="hljs-string">'*'</span></span>) { state = states.ML_COMMENT; output += <span class="hljs-string"><span class="hljs-string">'&lt;span style="color: '</span></span> + colors.ML_COMMENT + <span class="hljs-string"><span class="hljs-string">'"&gt;'</span></span> + char; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == states.ML_COMMENT &amp;&amp; char == <span class="hljs-string"><span class="hljs-string">'/'</span></span> &amp;&amp; prev == <span class="hljs-string"><span class="hljs-string">'*'</span></span>) { state = states.NONE; output += char + <span class="hljs-string"><span class="hljs-string">'&lt;/span&gt;'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br>  El resaltado de las cadenas se produce de manera similar, solo debe tenerse en cuenta que la comilla de cierre se puede escapar con una barra diagonal inversa y, por lo tanto, ya no es una barra diagonal. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == states.NONE &amp;&amp; char == <span class="hljs-string"><span class="hljs-string">'\''</span></span>) { state = states.SINGLE_QUOTE; output += <span class="hljs-string"><span class="hljs-string">'&lt;span style="color: '</span></span> + colors.SINGLE_QUOTE + <span class="hljs-string"><span class="hljs-string">'"&gt;'</span></span> + char; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == states.SINGLE_QUOTE &amp;&amp; char == <span class="hljs-string"><span class="hljs-string">'\''</span></span> &amp;&amp; prev != <span class="hljs-string"><span class="hljs-string">'\\'</span></span>) { state = states.NONE; output += char + <span class="hljs-string"><span class="hljs-string">'&lt;/span&gt;'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br>  El c√≥digo es similar a lo que ya estaba arriba, solo que ahora no registramos el final de la l√≠nea si hubo una barra invertida antes de la cotizaci√≥n. <br><br>  La definici√≥n de cadenas entre comillas dobles ocurre exactamente de la misma manera, y tiene poco sentido analizarlas en detalle.  Para completar la imagen, los colocar√© debajo del spoiler. <br><br><div class="spoiler">  <b class="spoiler_title">if (state == states.NONE &amp;&amp; char == '' '') {...</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == states.NONE &amp;&amp; char == <span class="hljs-string"><span class="hljs-string">'"'</span></span>) { state = states.DOUBLE_QUOTE; output += <span class="hljs-string"><span class="hljs-string">'&lt;span style="color: '</span></span> + colors.DOUBLE_QUOTE + <span class="hljs-string"><span class="hljs-string">'"&gt;'</span></span> + char; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == states.DOUBLE_QUOTE &amp;&amp; char == <span class="hljs-string"><span class="hljs-string">'"'</span></span> &amp;&amp; prev != <span class="hljs-string"><span class="hljs-string">'\\'</span></span>) { state = states.NONE; output += char + <span class="hljs-string"><span class="hljs-string">'&lt;/span&gt;'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == states.NONE &amp;&amp; char == <span class="hljs-string"><span class="hljs-string">'`'</span></span>) { state = states.ML_QUOTE; output += <span class="hljs-string"><span class="hljs-string">'&lt;span style="color: '</span></span> + colors.ML_QUOTE + <span class="hljs-string"><span class="hljs-string">'"&gt;'</span></span> + char; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == states.ML_QUOTE &amp;&amp; char == <span class="hljs-string"><span class="hljs-string">'`'</span></span> &amp;&amp; prev != <span class="hljs-string"><span class="hljs-string">'\\'</span></span>) { state = states.NONE; output += char + <span class="hljs-string"><span class="hljs-string">'&lt;/span&gt;'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br></div></div><br>  Los literales Regexp, que se confunden f√°cilmente con el signo de divisi√≥n, merecen una consideraci√≥n aparte.  Volveremos a este problema al final del art√≠culo, pero por ahora estamos haciendo lo mismo con expresiones regulares que con cadenas. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == states.NONE &amp;&amp; char == <span class="hljs-string"><span class="hljs-string">'/'</span></span>) { state = states.REGEX_LITERAL; output += <span class="hljs-string"><span class="hljs-string">'&lt;span style="color: '</span></span> + colors.REGEX_LITERAL + <span class="hljs-string"><span class="hljs-string">'"&gt;'</span></span> + char; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == states.REGEX_LITERAL &amp;&amp; char == <span class="hljs-string"><span class="hljs-string">'/'</span></span> &amp;&amp; prev != <span class="hljs-string"><span class="hljs-string">'\\'</span></span>) { state = states.NONE; output += char + <span class="hljs-string"><span class="hljs-string">'&lt;/span&gt;'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br>  Esto finaliza casos simples cuando el principio y el final de un literal se pueden determinar con 1-2 caracteres.  Comencemos por resaltar n√∫meros: como saben, siempre comienzan con un n√∫mero, pero pueden tener letras en la composici√≥n ( <i>0xFF</i> , <i>123n</i> ). <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == states.NONE &amp;&amp; <span class="hljs-regexp"><span class="hljs-regexp">/[0-9]/</span></span>.test(char) &amp;&amp; !<span class="hljs-regexp"><span class="hljs-regexp">/[0-9a-z$_]/i</span></span>.test(prev)) { state = states.NUMBER_LITERAL; output += <span class="hljs-string"><span class="hljs-string">'&lt;span style="color: '</span></span> + colors.NUMBER_LITERAL + <span class="hljs-string"><span class="hljs-string">'"&gt;'</span></span> + char; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == states.NUMBER_LITERAL &amp;&amp; !<span class="hljs-regexp"><span class="hljs-regexp">/[0-9a-fnx]/i</span></span>.test(char)) { state = states.NONE; output += <span class="hljs-string"><span class="hljs-string">'&lt;/span&gt;'</span></span> }</code> </pre> <br>  Aqu√≠ estamos buscando el comienzo de un n√∫mero: el car√°cter anterior no debe ser un n√∫mero o letra, de lo contrario, se resaltar√°n los n√∫meros en los nombres de las variables.  Tan pronto como el car√°cter actual no sea un n√∫mero o una letra que pueda estar contenida en el literal de un n√∫mero, cierre el SPAN y establezca el <i>estado en</i> cero. <br><br>  Todos los tipos posibles de literales est√°n resaltados, la b√∫squeda de palabras clave permanece.  Para hacer esto, necesita un bucle anidado que mire hacia adelante y determine si el car√°cter actual es el comienzo de la palabra clave. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == states.NONE &amp;&amp; !<span class="hljs-regexp"><span class="hljs-regexp">/[a-z0-9$_]/i</span></span>.test(prev)) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> word = <span class="hljs-string"><span class="hljs-string">''</span></span>, j = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (code[i + j] &amp;&amp; <span class="hljs-regexp"><span class="hljs-regexp">/[az]/i</span></span>.test(code[i + j])) { word += code[i + j]; j++; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (keywords.includes(word)) { state = states.KEYWORD; output += <span class="hljs-string"><span class="hljs-string">'&lt;span style="color: '</span></span> + colors.KEYWORD + <span class="hljs-string"><span class="hljs-string">'"&gt;'</span></span>; } }</code> </pre> <br>  Aqu√≠ miramos, el car√°cter anterior no puede estar en el nombre de la variable; de ‚Äã‚Äãlo contrario, <i>deje</i> que la palabra clave se resalte en la <i>salida de</i> la palabra.  Luego, el bucle anidado recopila la palabra m√°s larga posible hasta que se encuentre un car√°cter no alfab√©tico.  Si la palabra recibida est√° en la matriz de <i>palabras clave</i> , abra el SPAN y comience a resaltar la palabra.  Tan pronto como se encuentre un car√°cter no alfab√©tico, esto significa el final de la palabra; en consecuencia, cierre el SPAN: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == states.KEYWORD &amp;&amp; !<span class="hljs-regexp"><span class="hljs-regexp">/[az]/i</span></span>.test(char)) { state = states.NONE; output += <span class="hljs-string"><span class="hljs-string">'&lt;/span&gt;'</span></span>; }</code> </pre> <br>  Lo m√°s simple sigue siendo: el resaltado de operadores, aqu√≠ simplemente puede comparar con el conjunto de caracteres que pueden aparecer en los operadores: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == states.NONE &amp;&amp; <span class="hljs-string"><span class="hljs-string">'+-/*=&amp;|%!&lt;&gt;?:'</span></span>.indexOf(char) != <span class="hljs-number"><span class="hljs-number">-1</span></span>) { output += <span class="hljs-string"><span class="hljs-string">'&lt;span style="color: '</span></span> + colors.OPERATOR + <span class="hljs-string"><span class="hljs-string">'"&gt;'</span></span> + char + <span class="hljs-string"><span class="hljs-string">'&lt;/span&gt;'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br>  Al final del ciclo, si no se activa ninguna de las condiciones que <i>contin√∫an la</i> causa <i>continua</i> , simplemente agregamos el car√°cter actual a la variable resultante.  Cuando se produce el comienzo o el final de un literal o palabra clave, abrimos / cerramos el SPAN con color;  en todos los dem√°s casos, por ejemplo, cuando la l√≠nea ya est√° abierta, solo lanzamos un car√°cter a la vez.  Tambi√©n vale la pena proteger los soportes de √°ngulo de apertura, de lo contrario pueden romper el dise√±o. <br><br><pre> <code class="javascript hljs">output += char.replace(<span class="hljs-string"><span class="hljs-string">'&lt;'</span></span>, <span class="hljs-string"><span class="hljs-string">'&amp;'</span></span> + <span class="hljs-string"><span class="hljs-string">'lt;'</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  +      &lt;</span></span></code> </pre> <br><h2>  Correcci√≥n de errores </h2><br>  Todo parec√≠a de alguna manera demasiado simple, y no en vano: con pruebas m√°s exhaustivas, hab√≠a casos en los que la luz de fondo no funcionaba correctamente. <br><br>  La divisi√≥n se reconoce como regexp, para distinguir una de la otra, ser√° necesario cambiar la forma en que se determina regexp.  Declaramos que la variable <i>esRegex = true</i> , despu√©s de lo cual trataremos de "probar" que esto no es regexp, sino un signo de divisi√≥n.  No puede haber palabras clave o corchetes de apertura antes de la operaci√≥n de divisi√≥n; por lo tanto, creamos un bucle anidado y vemos a qu√© se enfrenta la barra diagonal. <br><br><div class="spoiler">  <b class="spoiler_title">Como era antes</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == states.NONE &amp;&amp; char == <span class="hljs-string"><span class="hljs-string">'/'</span></span>) { state = states.REGEX_LITERAL; output += <span class="hljs-string"><span class="hljs-string">'&lt;span style="color: '</span></span> + colors.REGEX_LITERAL + <span class="hljs-string"><span class="hljs-string">'"&gt;'</span></span> + char; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br></div></div><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == states.NONE &amp;&amp; char == <span class="hljs-string"><span class="hljs-string">'/'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> word = <span class="hljs-string"><span class="hljs-string">''</span></span>, j = <span class="hljs-number"><span class="hljs-number">0</span></span>, isRegex = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (i + j &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { j--; <span class="hljs-comment"><span class="hljs-comment">//        if ('+/-*=|&amp;&lt;&gt;%,({[?:;'.indexOf(code[i+j]) != -1) break; //   ;   -   if (!/[0-9a-z$_]/i.test(code[i+j]) &amp;&amp; word.length &gt; 0) break; //  ,     if (/[0-9a-z$_]/i.test(code[i+j])) word = code[i+j] + word; //   - ,     if (')]}'.indexOf(code[i+j]) != -1) { isRegex = false; break; } } //      -    //  : return /test/g - , plainWord /test/g -  if (word.length &gt; 0 &amp;&amp; !keywords.includes(word)) isRegex = false; if (isRegex) { state = states.REGEX_LITERAL; output += '&lt;span style="color: ' + colors.REGEX_LITERAL + '"&gt;' + char; continue; } }</span></span></code> </pre> <br>  Aunque este enfoque resuelve el problema, todav√≠a no est√° exento de defectos.  Puede ajustarlo para que este algoritmo tambi√©n se resalte incorrectamente, por ejemplo: <i>if (a) / regex /</i> or so: <i>1 / / regex / / 2</i> .  ¬øPor qu√© una persona que divide los n√∫meros en expresiones regulares necesita resaltar el c√≥digo? Esta es otra pregunta;  El dise√±o es sint√°cticamente correcto, aunque no ocurre en la vida real. <br><br>  Hay problemas con la coloraci√≥n regexp en muchas obras, por ejemplo en <a href="https://prismjs.com/test.html">prism.js</a> .  Aparentemente, para resaltar correctamente las expresiones regulares, debe comprender completamente la sintaxis, como lo hacen los navegadores. <br><br>  El segundo error con el que tuve que lidiar estaba relacionado con las barras invertidas.  No se reconoci√≥ una comilla de cierre en una cadena de la forma <i>'test \\'</i> debido a la presencia de una barra invertida frente a ella.  Volver a la condici√≥n que atrapa el final de la l√≠nea: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == states.SINGLE_QUOTE &amp;&amp; char == <span class="hljs-string"><span class="hljs-string">'\''</span></span> &amp;&amp; prev != <span class="hljs-string"><span class="hljs-string">'\\'</span></span>)</code> </pre> <br>  La √∫ltima parte de la condici√≥n debe cambiarse: si la barra invertida se escapa (es decir, hay otra barra invertida antes), entonces registre el final de la l√≠nea. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> closingCharNotEscaped = prev != <span class="hljs-string"><span class="hljs-string">'\\'</span></span> || prev == <span class="hljs-string"><span class="hljs-string">'\\'</span></span> &amp;&amp; code[i<span class="hljs-number"><span class="hljs-number">-2</span></span>] == <span class="hljs-string"><span class="hljs-string">'\\'</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ... if (state == states.SINGLE_QUOTE &amp;&amp; char == '\'' &amp;&amp; closingCharNotEscaped)</span></span></code> </pre> <br>  Se deben hacer los mismos reemplazos en la b√∫squeda de cadenas con comillas dobles e inversas, as√≠ como en la b√∫squeda de expresiones regulares. <br><br>  Eso es todo, puede probar el resaltado mediante el enlace al comienzo del art√≠culo. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/482884/">https://habr.com/ru/post/482884/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../482872/index.html">Pol√≠gonos otro mundo</a></li>
<li><a href="../482874/index.html">La muerte de Koshchei en la lista de recomendaciones (¬øpuedes hacer que YouTube sea c√≥modo y seguro?)</a></li>
<li><a href="../482876/index.html">C√°lculo del costo de producci√≥n de electricidad solar para las necesidades propias de un hogar en el centro de Europa</a></li>
<li><a href="../482878/index.html">C√≥mo busqu√© la definici√≥n de "producto"</a></li>
<li><a href="../482882/index.html">Motor como freno electromagn√©tico</a></li>
<li><a href="../482886/index.html">An√°lisis de habra: ¬øes importante la duraci√≥n de la publicaci√≥n?</a></li>
<li><a href="../482888/index.html">Lanzar un servidor VPN detr√°s del proveedor NAT</a></li>
<li><a href="../482892/index.html">Let vs const: ¬øqu√© usar?</a></li>
<li><a href="../482894/index.html">Generaci√≥n de procedimientos adaptativos utilizando el algoritmo WaveFunctionCollapse y la distribuci√≥n de probabilidad a priori</a></li>
<li><a href="../482896/index.html">OSCP - Mi experiencia</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>