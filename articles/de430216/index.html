<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘ƒğŸ¼ ğŸ§ğŸ» ğŸ§šğŸ½ So wie ich es verstehe, esse ich viele SÃ¼ÃŸigkeiten oder die Klassifizierung von Waren durch Einchecken in der Anwendung ğŸ˜§ ğŸ‘³ ğŸ‘©ğŸ¼â€âš•ï¸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Herausforderung 
 In diesem Artikel mÃ¶chten wir darÃ¼ber sprechen, wie wir eine LÃ¶sung zum Klassifizieren von Produktnamen aus Belegen in der Anwendung...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>So wie ich es verstehe, esse ich viele SÃ¼ÃŸigkeiten oder die Klassifizierung von Waren durch Einchecken in der Anwendung</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430216/"><h2>  Herausforderung </h2><br>  In diesem Artikel mÃ¶chten wir darÃ¼ber sprechen, wie wir eine LÃ¶sung zum Klassifizieren von Produktnamen aus Belegen in der Anwendung zum Erfassen von Ausgaben fÃ¼r Schecks und den Einkaufsassistenten erstellt haben.  Wir wollten den Benutzern die MÃ¶glichkeit geben, Statistiken Ã¼ber EinkÃ¤ufe anzuzeigen, die automatisch auf der Grundlage gescannter Belege gesammelt werden, und zwar alle vom Benutzer gekauften Waren nach Kategorien zu verteilen.  Weil es bereits das letzte Jahrhundert ist, den Benutzer zu zwingen, Produkte unabhÃ¤ngig zu gruppieren.  Es gibt verschiedene AnsÃ¤tze zur LÃ¶sung dieses Problems: Sie kÃ¶nnen versuchen, Clustering-Algorithmen mit verschiedenen Arten der Vektordarstellung von WÃ¶rtern oder klassischen Klassifizierungsalgorithmen anzuwenden.  Wir haben nichts Neues erfunden und mÃ¶chten in diesem Artikel nur einen kleinen Leitfaden Ã¼ber eine mÃ¶gliche LÃ¶sung des Problems, Beispiele dafÃ¼r, wie dies nicht funktioniert, eine Analyse, warum andere Methoden nicht funktionierten und auf welche Probleme Sie dabei stoÃŸen kÃ¶nnten, verÃ¶ffentlichen. <br><a name="habracut"></a><br><h2>  Clustering </h2><br>  Eines der Probleme war, dass die Namen der Waren, die wir aus Schecks erhalten, selbst fÃ¼r eine Person nicht immer leicht zu entziffern sind.  Es ist unwahrscheinlich, dass Sie wissen, welche Art von Produkt mit dem Namen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">â€UTRUSTA krnshtâ€œ</a> in einem der russischen GeschÃ¤fte gekauft wurde?  Echte Kenner des schwedischen Designs werden uns sicherlich sofort antworten: Halterung fÃ¼r den Ofen von Utrust, aber solche Spezialisten im Hauptquartier zu halten, ist ziemlich teuer.  AuÃŸerdem hatten wir keine fertige, beschriftete Probe, die fÃ¼r unsere Daten geeignet war und an der wir das Modell trainieren konnten.  Daher werden wir zunÃ¤chst darÃ¼ber sprechen, wie wir mangels Daten fÃ¼r das Training Clustering-Algorithmen angewendet haben und warum es uns nicht gefallen hat. <br><br>  Solche Algorithmen basieren auf der Messung von AbstÃ¤nden zwischen Objekten, was deren Vektordarstellung oder die Verwendung einer Metrik zur Messung der Ã„hnlichkeit von WÃ¶rtern erfordert (z. B. Levenshtein-Abstand).  In diesem Schritt liegt die Schwierigkeit in der aussagekrÃ¤ftigen Vektordarstellung der Namen.  Es ist problematisch, Eigenschaften aus den Namen zu extrahieren, die das Produkt und seine Beziehung zu anderen Produkten vollstÃ¤ndig und umfassend beschreiben. <br><br>  Die einfachste Option ist die Verwendung von Tf-Idf, aber in diesem Fall ist die Dimension des Vektorraums ziemlich groÃŸ und der Raum selbst ist spÃ¤rlich.  DarÃ¼ber hinaus extrahiert dieser Ansatz keine zusÃ¤tzlichen Informationen aus den Namen.  So kann es in einem Cluster viele Produkte aus verschiedenen Kategorien geben, die durch ein gemeinsames Wort vereint sind, wie zum Beispiel â€Kartoffelâ€œ oder â€Salatâ€œ: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pb/uh/bd/pbuhbdnf0bwmwvy0ywqwapil018.png"></div><br>  Wir kÃ¶nnen auch nicht steuern, welche Cluster zusammengestellt werden.  Das einzige, was angezeigt werden kann, ist die Anzahl der Cluster (wenn Algorithmen verwendet werden, die auf Nichtdichtespitzen im Raum basieren).  Wenn Sie jedoch eine zu kleine Menge angeben, wird ein groÃŸer Cluster gebildet, der alle Namen enthÃ¤lt, die nicht in andere Cluster passen kÃ¶nnten.  Wenn Sie einen ausreichend groÃŸen angeben, mÃ¼ssen wir nach dem Funktionieren des Algorithmus Hunderte von Clustern durchsuchen und diese manuell in semantische Kategorien kombinieren. <br><br>  Die folgenden Tabellen enthalten Informationen zu Clustern, die die Algorithmen KMeans und Tf-Idf zur Vektordarstellung verwenden.  Aus diesen Tabellen geht hervor, dass die AbstÃ¤nde zwischen den Zentren der Cluster geringer sind als der durchschnittliche Abstand zwischen den Objekten und den Zentren der Cluster, zu denen sie gehÃ¶ren.  Solche Daten kÃ¶nnen durch die Tatsache erklÃ¤rt werden, dass es im Raum der Vektoren keine offensichtlichen Dichtespitzen gibt und sich die Zentren der Cluster um den Kreis befinden, wo sich die meisten Objekte auÃŸerhalb dieses Kreises befinden.  ZusÃ¤tzlich wird ein Cluster gebildet, der die meisten Vektoren enthÃ¤lt.  Am wahrscheinlichsten werden in diesem Cluster Namen verwendet, die WÃ¶rter enthalten, die unter allen Produkten aus verschiedenen Kategorien hÃ¤ufiger als andere vorkommen. <br><br><table><caption>  Tabelle 1. AbstÃ¤nde zwischen Clustern. </caption><tbody><tr><th>  Cluster </th><th>  C1 </th><th>  C2 </th><th>  C3 </th><th>  C4 </th><th>  C5 </th><th>  C6 </th><th>  C7 </th><th>  C8 </th><th>  C9 </th></tr><tr><th>  C1 </th><td>  0.0 </td><td>  0,502 </td><td>  0,354 </td><td>  0,475 </td><td>  0,481 </td><td>  0,527 </td><td>  0,498 </td><td>  0,501 </td><td>  0,524 </td></tr><tr><th>  C2 </th><td>  0,502 </td><td>  0.0 </td><td>  0,614 </td><td>  0,685 </td><td>  0,696 </td><td>  0,728 </td><td>  0,706 </td><td>  0,709 </td><td>  0,725 </td></tr><tr><th>  C3 </th><td>  0,354 </td><td>  0,614 </td><td>  0.0 </td><td>  0,590 </td><td>  0,597 </td><td>  0,635 </td><td>  0,610 </td><td>  0,613 </td><td>  0,632 </td></tr><tr><th>  C4 </th><td>  0,475 </td><td>  0,685 </td><td>  0,590 </td><td>  0.0 </td><td>  0,673 </td><td>  0,709 </td><td>  0,683 </td><td>  0,687 </td><td>  0,699 </td></tr><tr><th>  C5 </th><td>  0,481 </td><td>  0,696 </td><td>  0,597 </td><td>  0,673 </td><td>  0.0 </td><td>  0,715 </td><td>  0,692 </td><td>  0,694 </td><td>  0,711 </td></tr><tr><th>  C6 </th><td>  0,527 </td><td>  0,727 </td><td>  0,635 </td><td>  0,709 </td><td>  0,715 </td><td>  0.0 </td><td>  0,726 </td><td>  0,728 </td><td>  0,741 </td></tr><tr><th>  C7 </th><td>  0,498 </td><td>  0,706 </td><td>  0,610 </td><td>  0,683 </td><td>  0,692 </td><td>  0,725 </td><td>  0.0 </td><td>  0,707 </td><td>  0,714 </td></tr><tr><th>  C8 </th><td>  0,501 </td><td>  0,709 </td><td>  0,612 </td><td>  0,687 </td><td>  0,694 </td><td>  0,728 </td><td>  0,707 </td><td>  0.0 </td><td>  0,725 </td></tr><tr><th>  C9 </th><td>  0,524 </td><td>  0,725 </td><td>  0,632 </td><td>  0,699 </td><td>  0,711 </td><td>  0,741 </td><td>  0,714 </td><td>  0,725 </td><td>  0.0 </td></tr></tbody></table><br><table><caption>  Tabelle 2. Kurzinformationen zu Clustern </caption><tbody><tr><th>  Cluster </th><th>  Anzahl der Objekte </th><th>  Durchschnittliche Entfernung </th><th>  Mindestabstand </th><th>  Maximale Entfernung </th></tr><tr><th>  C1 </th><td>  62530 </td><td>  0,999 </td><td>  0,041 </td><td>  1.001 </td></tr><tr><th>  C2 </th><td>  2159 </td><td>  0,864 </td><td>  0,527 </td><td>  0,964 </td></tr><tr><th>  C3 </th><td>  1099 </td><td>  0,934 </td><td>  0,756 </td><td>  0,993 </td></tr><tr><th>  C4 </th><td>  1292 </td><td>  0,879 </td><td>  0,733 </td><td>  0,980 </td></tr><tr><th>  C5 </th><td>  746 </td><td>  0,875 </td><td>  0,731 </td><td>  0,965 </td></tr><tr><th>  C6 </th><td>  2451 </td><td>  0,847 </td><td>  0,719 </td><td>  0,994 </td></tr><tr><th>  C7 </th><td>  1133 </td><td>  0,866 </td><td>  0,724 </td><td>  0,986 </td></tr><tr><th>  C8 </th><td>  876 </td><td>  0,863 </td><td>  0,704 </td><td>  0,999 </td></tr><tr><th>  C9 </th><td>  1879 </td><td>  0,849 </td><td>  0,526 </td><td>  0,981 </td></tr></tbody></table><br><br>  Aber an einigen Stellen erweisen sich die Cluster als recht anstÃ¤ndig, wie zum Beispiel im Bild unten - dort sind fast alle Produkte Katzenfutter. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/oh/uy/5p/ohuy5p_bgiignp9ah_gokvvbzs4.png"></div><br><br>  Doc2Vec ist ein weiterer Algorithmus, mit dem Sie Texte in Vektorform darstellen kÃ¶nnen.  Bei Verwendung dieses Ansatzes wird jeder Name durch einen Vektor mit einer kleineren Dimension als bei Verwendung von Tf-Idf beschrieben.  In dem resultierenden Vektorraum sind Ã¤hnliche Texte nahe beieinander und verschiedene weit entfernt. <br><br>  Dieser Ansatz kann das Problem der groÃŸen Dimension und des entladenen Raums lÃ¶sen, das durch das Tf-Idf-Verfahren erhalten wird.  FÃ¼r diesen Algorithmus haben wir die einfachste Option der Tokenisierung verwendet: Wir haben den Namen in separate WÃ¶rter aufgeteilt und ihre ursprÃ¼nglichen Formen angenommen.  Er wurde auf folgende Weise auf Daten geschult: <br><br><pre><code class="python hljs">max_epochs = <span class="hljs-number"><span class="hljs-number">100</span></span> vec_size = <span class="hljs-number"><span class="hljs-number">20</span></span> alpha = <span class="hljs-number"><span class="hljs-number">0.025</span></span> model = doc2vec.Doc2Vec(vector_size=vec_size, alpha=alpha, min_alpha=<span class="hljs-number"><span class="hljs-number">0.00025</span></span>, min_count=<span class="hljs-number"><span class="hljs-number">1</span></span>, dm =<span class="hljs-number"><span class="hljs-number">1</span></span>) model.build_vocab(train_corpus) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> epoch <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(max_epochs): print(<span class="hljs-string"><span class="hljs-string">'iteration {0}'</span></span>.format(epoch)) model.train(train_corpus, total_examples=model.corpus_count, epochs=model.iter) <span class="hljs-comment"><span class="hljs-comment"># decrease the learning rate model.alpha -= 0.0002 # fix the learning rate, no decay model.min_alpha = model.epochs</span></span></code> </pre> <br>  Bei diesem Ansatz haben wir jedoch Vektoren erhalten, die keine Informationen Ã¼ber den Namen enthalten. Mit demselben Erfolg kÃ¶nnen Sie zufÃ¤llige Werte verwenden.  Hier ist ein Beispiel fÃ¼r die Funktionsweise des Algorithmus: Das Bild zeigt Produkte, die nach Ansicht des Algorithmus dem â€Borodino-Brot der Form n pn 0,45 kâ€œ Ã¤hnlich sind. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qd/m9/lp/qdm9lplwaidbilivtpb3jjskopo.png"></div><br>  Vielleicht liegt das Problem in der LÃ¤nge und dem Kontext der Namen: Der Pass im Namen "__ club. Banana 200ml" kann entweder Joghurt, Saft oder eine groÃŸe Dose Sahne sein.  Mit einem anderen Ansatz zur Namens-Tokenisierung kÃ¶nnen Sie ein besseres Ergebnis erzielen.  Wir hatten keine Erfahrung mit dieser Methode, und als die ersten Versuche fehlgeschlagen waren, fanden wir bereits einige markierte SÃ¤tze mit Produktnamen. Daher beschlossen wir, diese Methode fÃ¼r eine Weile zu verlassen und auf Klassifizierungsalgorithmen umzusteigen. <br><br><h2>  Klassifizierung </h2><br><h3>  Datenvorverarbeitung </h3><br>  Die Namen von Waren aus Schecks kommen uns nicht immer klar vor: Latein und Kyrillisch werden in Worten gemischt.  Zum Beispiel kann der Buchstabe "a" durch "a" lateinisch ersetzt werden, und dies erhÃ¶ht die Anzahl der eindeutigen Namen - zum Beispiel werden die WÃ¶rter "Milch" und "Milch" als unterschiedlich angesehen.  Die Namen enthalten auch viele andere Tippfehler und AbkÃ¼rzungen. <br><br>  Wir haben unsere Datenbank untersucht und typische Fehler in den Namen gefunden.  Zu diesem Zeitpunkt haben wir auf regulÃ¤re AusdrÃ¼cke verzichtet, mit deren Hilfe wir die Namen bereinigt und zu einer bestimmten allgemeinen Sichtweise gebracht haben.  Mit diesem Ansatz wird das Ergebnis um ca. 7% gesteigert.  Zusammen mit einer einfachen SGD-Klassifikatoroption basierend auf der Huber-Verlustfunktion mit verdrillten Parametern haben wir eine Genauigkeit von 81% fÃ¼r F1 erhalten (durchschnittliche Genauigkeit fÃ¼r alle Produktkategorien). <br><br><pre> <code class="python hljs">sgd_model = SGDClassifier() parameters_sgd = { <span class="hljs-string"><span class="hljs-string">'max_iter'</span></span>:[<span class="hljs-number"><span class="hljs-number">100</span></span>], <span class="hljs-string"><span class="hljs-string">'loss'</span></span>:[<span class="hljs-string"><span class="hljs-string">'modified_huber'</span></span>], <span class="hljs-string"><span class="hljs-string">'class_weight'</span></span>:[<span class="hljs-string"><span class="hljs-string">'balanced'</span></span>], <span class="hljs-string"><span class="hljs-string">'penalty'</span></span>:[<span class="hljs-string"><span class="hljs-string">'l2'</span></span>], <span class="hljs-string"><span class="hljs-string">'alpha'</span></span>:[<span class="hljs-number"><span class="hljs-number">0.0001</span></span>] } sgd_cv = GridSearchCV(sgd_model, parameters_sgd,n_jobs=<span class="hljs-number"><span class="hljs-number">-1</span></span>) sgd_cv.fit(tf_idf_data, prod_cat) sgd_cv.best_score_, sgd_cv.best_params_</code> </pre> <br>  Vergessen Sie auch nicht, dass einige Kategorien von Menschen hÃ¤ufiger einkaufen als andere: Zum Beispiel sind â€Tee und SÃ¼ÃŸigkeitenâ€œ und â€GemÃ¼se und Obstâ€œ viel beliebter als â€Dienstleistungenâ€œ und â€Kosmetikâ€œ.  Bei einer solchen Datenverteilung ist es besser, Algorithmen zu verwenden, mit denen Sie Gewichte (Wichtigkeitsgrad) fÃ¼r jede Klasse festlegen kÃ¶nnen.  Das Gewicht der Klasse kann umgekehrt mit dem Wert bestimmt werden, der dem VerhÃ¤ltnis der Anzahl der Produkte in der Klasse zur Gesamtzahl der Produkte entspricht.  Sie mÃ¼ssen jedoch nicht darÃ¼ber nachdenken, da bei der Implementierung dieser Algorithmen das Gewicht von Kategorien automatisch ermittelt werden kann. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ty/o9/pk/tyo9pkfhw-ibby5jopobc5okotc.png"></div><br><h2>  Neue Daten fÃ¼r das Training erhalten </h2><br>  Unsere Anwendung erforderte geringfÃ¼gig andere Kategorien als die im Wettbewerb verwendeten, und die Namen der Produkte aus unserer Datenbank unterschieden sich erheblich von den im Wettbewerb prÃ¤sentierten.  Daher mussten wir die Waren von unseren Belegen markieren.  Wir haben versucht, dies alleine zu tun, aber wir haben festgestellt, dass es sehr lange dauern wird, selbst wenn wir unser gesamtes Team verbinden.  Deshalb haben wir uns fÃ¼r <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Yandexs â€Tolokaâ€œ entschieden</a> . <br><br>  Dort haben wir diese Zuordnungsform verwendet: <br><br><ul><li>  In jeder Zelle haben wir ein Produkt vorgestellt, dessen Kategorie definiert werden muss </li><li>  seine hypothetische Kategorie, die von einem unserer VorgÃ¤ngermodelle definiert wurde </li><li>  Antwortfeld (wenn die vorgeschlagene Kategorie falsch war) </li></ul><br>  Wir haben detaillierte Anweisungen mit Beispielen erstellt, in denen die Merkmale der einzelnen Kategorien erlÃ¤utert wurden, und auch Methoden zur QualitÃ¤tskontrolle verwendet: ein Set mit Standardantworten, die zusammen mit den Ã¼blichen Aufgaben angezeigt wurden (wir haben die Standardantworten selbst implementiert und mehrere hundert Produkte markiert).  Entsprechend den Ergebnissen der Antworten auf diese Aufgaben wurden Benutzer, die die Daten falsch markiert hatten, herausgesucht.  FÃ¼r das gesamte Projekt haben wir jedoch nur drei der Ã¼ber 600 Benutzer gesperrt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fx/ib/xt/fxibxt-v5h7vouodjoffwtl6egy.png"></div><br>  Mit den neuen Daten haben wir ein Modell erhalten, das besser zu unseren Daten passt, und die Genauigkeit hat sich etwas mehr erhÃ¶ht (um ~ 11%) und hat bereits 92% erreicht. <br><br><h2>  Endmodell </h2><br>  Wir haben den Klassifizierungsprozess mit einer Kombination von Daten aus mehreren DatensÃ¤tzen mit Kaggle begonnen - 74%. Danach haben wir die Vorverarbeitung verbessert - 81%, einen neuen Datensatz gesammelt - 92% und schlieÃŸlich den Klassifizierungsprozess verbessert: ZunÃ¤chst erhalten wir mithilfe der logistischen Regression vorlÃ¤ufige Wahrscheinlichkeiten fÃ¼r die ZugehÃ¶rigkeit von Waren SGD gab Kategorien, die auf Produktnamen basierten, eine grÃ¶ÃŸere Genauigkeit, hatte jedoch immer noch groÃŸe Werte fÃ¼r die Verlustfunktionen, was die Ergebnisse des endgÃ¼ltigen Klassifikators stark beeinflusste.  DarÃ¼ber hinaus kombinieren wir die erhaltenen Daten mit anderen Daten zum Produkt (Preis des Produkts, des GeschÃ¤fts, in dem es gekauft wurde, Statistiken Ã¼ber das GeschÃ¤ft, Scheck und andere Metainformationen), und XGBoost wird auf all dieses Datenvolumen geschult, was eine Genauigkeit von 98% ergab (ErhÃ¶hung) weitere 6%).  Wie sich herausstellte, leistete die QualitÃ¤t der Trainingsstichprobe den grÃ¶ÃŸten Beitrag. <br><br><h2>  Wird auf dem Server ausgefÃ¼hrt </h2><br>  Um die Bereitstellung zu beschleunigen, haben wir einen einfachen Server auf Flask to Docker eingerichtet.  Es gab eine Methode, mit der Waren vom Server empfangen wurden, die kategorisiert und Waren mit Kategorien bereits zurÃ¼ckgegeben werden mussten.  So konnten wir uns problemlos in das bestehende System integrieren, dessen Zentrum Tomcat war, und wir mussten keine Ã„nderungen an der Architektur vornehmen - wir haben nur einen weiteren Block hinzugefÃ¼gt. <br><br><h2>  Erscheinungsdatum </h2><br>  Vor einigen Wochen haben wir eine Kategorisierungsversion bei Google Play verÃ¶ffentlicht (diese wird nach einer Weile im App Store angezeigt).  Es stellte sich so heraus: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/h1/tj/ie/h1tjiekixykrb_liuwftfnd8ufy.png" width="50%"></div><br>  In zukÃ¼nftigen Versionen planen wir, die MÃ¶glichkeit zur Korrektur von Kategorien hinzuzufÃ¼gen, damit wir schnell Kategorisierungsfehler erfassen und das Kategorisierungsmodell neu trainieren kÃ¶nnen (wÃ¤hrend wir es selbst tun). <br><br>  ErwÃ¤hnte Wettbewerbe bei Kaggle: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">www.kaggle.com/c/receipt-categorisation</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">www.kaggle.com/c/market-basket-analysis</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">www.kaggle.com/c/prod-price-prediction</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de430216/">https://habr.com/ru/post/de430216/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de430204/index.html">MIT-Kurs "Computer Systems Security". Vorlesung 18: â€Privates Surfen im Internetâ€œ, Teil 1</a></li>
<li><a href="../de430206/index.html">MIT-Kurs "Computer Systems Security". Vorlesung 18: Privates Surfen im Internet, Teil 2</a></li>
<li><a href="../de430208/index.html">MIT-Kurs "Computer Systems Security". Vorlesung 18: â€Privates Surfen im Internetâ€œ, Teil 3</a></li>
<li><a href="../de430210/index.html">Testen Sie meine Geduld mit der Check Point Security Academy</a></li>
<li><a href="../de430212/index.html">OpenSceneGraph: Grundlagen der Szenengeometrie</a></li>
<li><a href="../de430218/index.html">Energieoptimierung STM32: Ein praktischer Leitfaden</a></li>
<li><a href="../de430220/index.html">Wie man einen "hundertjÃ¤hrigen" USB-Hub in einen intelligent verwalteten verwandelt und 300 US-Dollar spart</a></li>
<li><a href="../de430222/index.html">Senior Engineer auf der Suche nach Arbeit. Wie ich 20 Interviews mit HR durchlaufen habe und was ich darÃ¼ber denke</a></li>
<li><a href="../de430224/index.html">Schizotypische StÃ¶rung: Ein Einblick</a></li>
<li><a href="../de430226/index.html">Von var b bis zum Interview</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>