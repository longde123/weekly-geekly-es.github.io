<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👃🏼 🧝🏻 🧚🏽 So wie ich es verstehe, esse ich viele Süßigkeiten oder die Klassifizierung von Waren durch Einchecken in der Anwendung 😧 👳 👩🏼‍⚕️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Herausforderung 
 In diesem Artikel möchten wir darüber sprechen, wie wir eine Lösung zum Klassifizieren von Produktnamen aus Belegen in der Anwendung...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>So wie ich es verstehe, esse ich viele Süßigkeiten oder die Klassifizierung von Waren durch Einchecken in der Anwendung</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430216/"><h2>  Herausforderung </h2><br>  In diesem Artikel möchten wir darüber sprechen, wie wir eine Lösung zum Klassifizieren von Produktnamen aus Belegen in der Anwendung zum Erfassen von Ausgaben für Schecks und den Einkaufsassistenten erstellt haben.  Wir wollten den Benutzern die Möglichkeit geben, Statistiken über Einkäufe anzuzeigen, die automatisch auf der Grundlage gescannter Belege gesammelt werden, und zwar alle vom Benutzer gekauften Waren nach Kategorien zu verteilen.  Weil es bereits das letzte Jahrhundert ist, den Benutzer zu zwingen, Produkte unabhängig zu gruppieren.  Es gibt verschiedene Ansätze zur Lösung dieses Problems: Sie können versuchen, Clustering-Algorithmen mit verschiedenen Arten der Vektordarstellung von Wörtern oder klassischen Klassifizierungsalgorithmen anzuwenden.  Wir haben nichts Neues erfunden und möchten in diesem Artikel nur einen kleinen Leitfaden über eine mögliche Lösung des Problems, Beispiele dafür, wie dies nicht funktioniert, eine Analyse, warum andere Methoden nicht funktionierten und auf welche Probleme Sie dabei stoßen könnten, veröffentlichen. <br><a name="habracut"></a><br><h2>  Clustering </h2><br>  Eines der Probleme war, dass die Namen der Waren, die wir aus Schecks erhalten, selbst für eine Person nicht immer leicht zu entziffern sind.  Es ist unwahrscheinlich, dass Sie wissen, welche Art von Produkt mit dem Namen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">„UTRUSTA krnsht“</a> in einem der russischen Geschäfte gekauft wurde?  Echte Kenner des schwedischen Designs werden uns sicherlich sofort antworten: Halterung für den Ofen von Utrust, aber solche Spezialisten im Hauptquartier zu halten, ist ziemlich teuer.  Außerdem hatten wir keine fertige, beschriftete Probe, die für unsere Daten geeignet war und an der wir das Modell trainieren konnten.  Daher werden wir zunächst darüber sprechen, wie wir mangels Daten für das Training Clustering-Algorithmen angewendet haben und warum es uns nicht gefallen hat. <br><br>  Solche Algorithmen basieren auf der Messung von Abständen zwischen Objekten, was deren Vektordarstellung oder die Verwendung einer Metrik zur Messung der Ähnlichkeit von Wörtern erfordert (z. B. Levenshtein-Abstand).  In diesem Schritt liegt die Schwierigkeit in der aussagekräftigen Vektordarstellung der Namen.  Es ist problematisch, Eigenschaften aus den Namen zu extrahieren, die das Produkt und seine Beziehung zu anderen Produkten vollständig und umfassend beschreiben. <br><br>  Die einfachste Option ist die Verwendung von Tf-Idf, aber in diesem Fall ist die Dimension des Vektorraums ziemlich groß und der Raum selbst ist spärlich.  Darüber hinaus extrahiert dieser Ansatz keine zusätzlichen Informationen aus den Namen.  So kann es in einem Cluster viele Produkte aus verschiedenen Kategorien geben, die durch ein gemeinsames Wort vereint sind, wie zum Beispiel „Kartoffel“ oder „Salat“: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pb/uh/bd/pbuhbdnf0bwmwvy0ywqwapil018.png"></div><br>  Wir können auch nicht steuern, welche Cluster zusammengestellt werden.  Das einzige, was angezeigt werden kann, ist die Anzahl der Cluster (wenn Algorithmen verwendet werden, die auf Nichtdichtespitzen im Raum basieren).  Wenn Sie jedoch eine zu kleine Menge angeben, wird ein großer Cluster gebildet, der alle Namen enthält, die nicht in andere Cluster passen könnten.  Wenn Sie einen ausreichend großen angeben, müssen wir nach dem Funktionieren des Algorithmus Hunderte von Clustern durchsuchen und diese manuell in semantische Kategorien kombinieren. <br><br>  Die folgenden Tabellen enthalten Informationen zu Clustern, die die Algorithmen KMeans und Tf-Idf zur Vektordarstellung verwenden.  Aus diesen Tabellen geht hervor, dass die Abstände zwischen den Zentren der Cluster geringer sind als der durchschnittliche Abstand zwischen den Objekten und den Zentren der Cluster, zu denen sie gehören.  Solche Daten können durch die Tatsache erklärt werden, dass es im Raum der Vektoren keine offensichtlichen Dichtespitzen gibt und sich die Zentren der Cluster um den Kreis befinden, wo sich die meisten Objekte außerhalb dieses Kreises befinden.  Zusätzlich wird ein Cluster gebildet, der die meisten Vektoren enthält.  Am wahrscheinlichsten werden in diesem Cluster Namen verwendet, die Wörter enthalten, die unter allen Produkten aus verschiedenen Kategorien häufiger als andere vorkommen. <br><br><table><caption>  Tabelle 1. Abstände zwischen Clustern. </caption><tbody><tr><th>  Cluster </th><th>  C1 </th><th>  C2 </th><th>  C3 </th><th>  C4 </th><th>  C5 </th><th>  C6 </th><th>  C7 </th><th>  C8 </th><th>  C9 </th></tr><tr><th>  C1 </th><td>  0.0 </td><td>  0,502 </td><td>  0,354 </td><td>  0,475 </td><td>  0,481 </td><td>  0,527 </td><td>  0,498 </td><td>  0,501 </td><td>  0,524 </td></tr><tr><th>  C2 </th><td>  0,502 </td><td>  0.0 </td><td>  0,614 </td><td>  0,685 </td><td>  0,696 </td><td>  0,728 </td><td>  0,706 </td><td>  0,709 </td><td>  0,725 </td></tr><tr><th>  C3 </th><td>  0,354 </td><td>  0,614 </td><td>  0.0 </td><td>  0,590 </td><td>  0,597 </td><td>  0,635 </td><td>  0,610 </td><td>  0,613 </td><td>  0,632 </td></tr><tr><th>  C4 </th><td>  0,475 </td><td>  0,685 </td><td>  0,590 </td><td>  0.0 </td><td>  0,673 </td><td>  0,709 </td><td>  0,683 </td><td>  0,687 </td><td>  0,699 </td></tr><tr><th>  C5 </th><td>  0,481 </td><td>  0,696 </td><td>  0,597 </td><td>  0,673 </td><td>  0.0 </td><td>  0,715 </td><td>  0,692 </td><td>  0,694 </td><td>  0,711 </td></tr><tr><th>  C6 </th><td>  0,527 </td><td>  0,727 </td><td>  0,635 </td><td>  0,709 </td><td>  0,715 </td><td>  0.0 </td><td>  0,726 </td><td>  0,728 </td><td>  0,741 </td></tr><tr><th>  C7 </th><td>  0,498 </td><td>  0,706 </td><td>  0,610 </td><td>  0,683 </td><td>  0,692 </td><td>  0,725 </td><td>  0.0 </td><td>  0,707 </td><td>  0,714 </td></tr><tr><th>  C8 </th><td>  0,501 </td><td>  0,709 </td><td>  0,612 </td><td>  0,687 </td><td>  0,694 </td><td>  0,728 </td><td>  0,707 </td><td>  0.0 </td><td>  0,725 </td></tr><tr><th>  C9 </th><td>  0,524 </td><td>  0,725 </td><td>  0,632 </td><td>  0,699 </td><td>  0,711 </td><td>  0,741 </td><td>  0,714 </td><td>  0,725 </td><td>  0.0 </td></tr></tbody></table><br><table><caption>  Tabelle 2. Kurzinformationen zu Clustern </caption><tbody><tr><th>  Cluster </th><th>  Anzahl der Objekte </th><th>  Durchschnittliche Entfernung </th><th>  Mindestabstand </th><th>  Maximale Entfernung </th></tr><tr><th>  C1 </th><td>  62530 </td><td>  0,999 </td><td>  0,041 </td><td>  1.001 </td></tr><tr><th>  C2 </th><td>  2159 </td><td>  0,864 </td><td>  0,527 </td><td>  0,964 </td></tr><tr><th>  C3 </th><td>  1099 </td><td>  0,934 </td><td>  0,756 </td><td>  0,993 </td></tr><tr><th>  C4 </th><td>  1292 </td><td>  0,879 </td><td>  0,733 </td><td>  0,980 </td></tr><tr><th>  C5 </th><td>  746 </td><td>  0,875 </td><td>  0,731 </td><td>  0,965 </td></tr><tr><th>  C6 </th><td>  2451 </td><td>  0,847 </td><td>  0,719 </td><td>  0,994 </td></tr><tr><th>  C7 </th><td>  1133 </td><td>  0,866 </td><td>  0,724 </td><td>  0,986 </td></tr><tr><th>  C8 </th><td>  876 </td><td>  0,863 </td><td>  0,704 </td><td>  0,999 </td></tr><tr><th>  C9 </th><td>  1879 </td><td>  0,849 </td><td>  0,526 </td><td>  0,981 </td></tr></tbody></table><br><br>  Aber an einigen Stellen erweisen sich die Cluster als recht anständig, wie zum Beispiel im Bild unten - dort sind fast alle Produkte Katzenfutter. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/oh/uy/5p/ohuy5p_bgiignp9ah_gokvvbzs4.png"></div><br><br>  Doc2Vec ist ein weiterer Algorithmus, mit dem Sie Texte in Vektorform darstellen können.  Bei Verwendung dieses Ansatzes wird jeder Name durch einen Vektor mit einer kleineren Dimension als bei Verwendung von Tf-Idf beschrieben.  In dem resultierenden Vektorraum sind ähnliche Texte nahe beieinander und verschiedene weit entfernt. <br><br>  Dieser Ansatz kann das Problem der großen Dimension und des entladenen Raums lösen, das durch das Tf-Idf-Verfahren erhalten wird.  Für diesen Algorithmus haben wir die einfachste Option der Tokenisierung verwendet: Wir haben den Namen in separate Wörter aufgeteilt und ihre ursprünglichen Formen angenommen.  Er wurde auf folgende Weise auf Daten geschult: <br><br><pre><code class="python hljs">max_epochs = <span class="hljs-number"><span class="hljs-number">100</span></span> vec_size = <span class="hljs-number"><span class="hljs-number">20</span></span> alpha = <span class="hljs-number"><span class="hljs-number">0.025</span></span> model = doc2vec.Doc2Vec(vector_size=vec_size, alpha=alpha, min_alpha=<span class="hljs-number"><span class="hljs-number">0.00025</span></span>, min_count=<span class="hljs-number"><span class="hljs-number">1</span></span>, dm =<span class="hljs-number"><span class="hljs-number">1</span></span>) model.build_vocab(train_corpus) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> epoch <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(max_epochs): print(<span class="hljs-string"><span class="hljs-string">'iteration {0}'</span></span>.format(epoch)) model.train(train_corpus, total_examples=model.corpus_count, epochs=model.iter) <span class="hljs-comment"><span class="hljs-comment"># decrease the learning rate model.alpha -= 0.0002 # fix the learning rate, no decay model.min_alpha = model.epochs</span></span></code> </pre> <br>  Bei diesem Ansatz haben wir jedoch Vektoren erhalten, die keine Informationen über den Namen enthalten. Mit demselben Erfolg können Sie zufällige Werte verwenden.  Hier ist ein Beispiel für die Funktionsweise des Algorithmus: Das Bild zeigt Produkte, die nach Ansicht des Algorithmus dem „Borodino-Brot der Form n pn 0,45 k“ ähnlich sind. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qd/m9/lp/qdm9lplwaidbilivtpb3jjskopo.png"></div><br>  Vielleicht liegt das Problem in der Länge und dem Kontext der Namen: Der Pass im Namen "__ club. Banana 200ml" kann entweder Joghurt, Saft oder eine große Dose Sahne sein.  Mit einem anderen Ansatz zur Namens-Tokenisierung können Sie ein besseres Ergebnis erzielen.  Wir hatten keine Erfahrung mit dieser Methode, und als die ersten Versuche fehlgeschlagen waren, fanden wir bereits einige markierte Sätze mit Produktnamen. Daher beschlossen wir, diese Methode für eine Weile zu verlassen und auf Klassifizierungsalgorithmen umzusteigen. <br><br><h2>  Klassifizierung </h2><br><h3>  Datenvorverarbeitung </h3><br>  Die Namen von Waren aus Schecks kommen uns nicht immer klar vor: Latein und Kyrillisch werden in Worten gemischt.  Zum Beispiel kann der Buchstabe "a" durch "a" lateinisch ersetzt werden, und dies erhöht die Anzahl der eindeutigen Namen - zum Beispiel werden die Wörter "Milch" und "Milch" als unterschiedlich angesehen.  Die Namen enthalten auch viele andere Tippfehler und Abkürzungen. <br><br>  Wir haben unsere Datenbank untersucht und typische Fehler in den Namen gefunden.  Zu diesem Zeitpunkt haben wir auf reguläre Ausdrücke verzichtet, mit deren Hilfe wir die Namen bereinigt und zu einer bestimmten allgemeinen Sichtweise gebracht haben.  Mit diesem Ansatz wird das Ergebnis um ca. 7% gesteigert.  Zusammen mit einer einfachen SGD-Klassifikatoroption basierend auf der Huber-Verlustfunktion mit verdrillten Parametern haben wir eine Genauigkeit von 81% für F1 erhalten (durchschnittliche Genauigkeit für alle Produktkategorien). <br><br><pre> <code class="python hljs">sgd_model = SGDClassifier() parameters_sgd = { <span class="hljs-string"><span class="hljs-string">'max_iter'</span></span>:[<span class="hljs-number"><span class="hljs-number">100</span></span>], <span class="hljs-string"><span class="hljs-string">'loss'</span></span>:[<span class="hljs-string"><span class="hljs-string">'modified_huber'</span></span>], <span class="hljs-string"><span class="hljs-string">'class_weight'</span></span>:[<span class="hljs-string"><span class="hljs-string">'balanced'</span></span>], <span class="hljs-string"><span class="hljs-string">'penalty'</span></span>:[<span class="hljs-string"><span class="hljs-string">'l2'</span></span>], <span class="hljs-string"><span class="hljs-string">'alpha'</span></span>:[<span class="hljs-number"><span class="hljs-number">0.0001</span></span>] } sgd_cv = GridSearchCV(sgd_model, parameters_sgd,n_jobs=<span class="hljs-number"><span class="hljs-number">-1</span></span>) sgd_cv.fit(tf_idf_data, prod_cat) sgd_cv.best_score_, sgd_cv.best_params_</code> </pre> <br>  Vergessen Sie auch nicht, dass einige Kategorien von Menschen häufiger einkaufen als andere: Zum Beispiel sind „Tee und Süßigkeiten“ und „Gemüse und Obst“ viel beliebter als „Dienstleistungen“ und „Kosmetik“.  Bei einer solchen Datenverteilung ist es besser, Algorithmen zu verwenden, mit denen Sie Gewichte (Wichtigkeitsgrad) für jede Klasse festlegen können.  Das Gewicht der Klasse kann umgekehrt mit dem Wert bestimmt werden, der dem Verhältnis der Anzahl der Produkte in der Klasse zur Gesamtzahl der Produkte entspricht.  Sie müssen jedoch nicht darüber nachdenken, da bei der Implementierung dieser Algorithmen das Gewicht von Kategorien automatisch ermittelt werden kann. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ty/o9/pk/tyo9pkfhw-ibby5jopobc5okotc.png"></div><br><h2>  Neue Daten für das Training erhalten </h2><br>  Unsere Anwendung erforderte geringfügig andere Kategorien als die im Wettbewerb verwendeten, und die Namen der Produkte aus unserer Datenbank unterschieden sich erheblich von den im Wettbewerb präsentierten.  Daher mussten wir die Waren von unseren Belegen markieren.  Wir haben versucht, dies alleine zu tun, aber wir haben festgestellt, dass es sehr lange dauern wird, selbst wenn wir unser gesamtes Team verbinden.  Deshalb haben wir uns für <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Yandexs „Toloka“ entschieden</a> . <br><br>  Dort haben wir diese Zuordnungsform verwendet: <br><br><ul><li>  In jeder Zelle haben wir ein Produkt vorgestellt, dessen Kategorie definiert werden muss </li><li>  seine hypothetische Kategorie, die von einem unserer Vorgängermodelle definiert wurde </li><li>  Antwortfeld (wenn die vorgeschlagene Kategorie falsch war) </li></ul><br>  Wir haben detaillierte Anweisungen mit Beispielen erstellt, in denen die Merkmale der einzelnen Kategorien erläutert wurden, und auch Methoden zur Qualitätskontrolle verwendet: ein Set mit Standardantworten, die zusammen mit den üblichen Aufgaben angezeigt wurden (wir haben die Standardantworten selbst implementiert und mehrere hundert Produkte markiert).  Entsprechend den Ergebnissen der Antworten auf diese Aufgaben wurden Benutzer, die die Daten falsch markiert hatten, herausgesucht.  Für das gesamte Projekt haben wir jedoch nur drei der über 600 Benutzer gesperrt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fx/ib/xt/fxibxt-v5h7vouodjoffwtl6egy.png"></div><br>  Mit den neuen Daten haben wir ein Modell erhalten, das besser zu unseren Daten passt, und die Genauigkeit hat sich etwas mehr erhöht (um ~ 11%) und hat bereits 92% erreicht. <br><br><h2>  Endmodell </h2><br>  Wir haben den Klassifizierungsprozess mit einer Kombination von Daten aus mehreren Datensätzen mit Kaggle begonnen - 74%. Danach haben wir die Vorverarbeitung verbessert - 81%, einen neuen Datensatz gesammelt - 92% und schließlich den Klassifizierungsprozess verbessert: Zunächst erhalten wir mithilfe der logistischen Regression vorläufige Wahrscheinlichkeiten für die Zugehörigkeit von Waren SGD gab Kategorien, die auf Produktnamen basierten, eine größere Genauigkeit, hatte jedoch immer noch große Werte für die Verlustfunktionen, was die Ergebnisse des endgültigen Klassifikators stark beeinflusste.  Darüber hinaus kombinieren wir die erhaltenen Daten mit anderen Daten zum Produkt (Preis des Produkts, des Geschäfts, in dem es gekauft wurde, Statistiken über das Geschäft, Scheck und andere Metainformationen), und XGBoost wird auf all dieses Datenvolumen geschult, was eine Genauigkeit von 98% ergab (Erhöhung) weitere 6%).  Wie sich herausstellte, leistete die Qualität der Trainingsstichprobe den größten Beitrag. <br><br><h2>  Wird auf dem Server ausgeführt </h2><br>  Um die Bereitstellung zu beschleunigen, haben wir einen einfachen Server auf Flask to Docker eingerichtet.  Es gab eine Methode, mit der Waren vom Server empfangen wurden, die kategorisiert und Waren mit Kategorien bereits zurückgegeben werden mussten.  So konnten wir uns problemlos in das bestehende System integrieren, dessen Zentrum Tomcat war, und wir mussten keine Änderungen an der Architektur vornehmen - wir haben nur einen weiteren Block hinzugefügt. <br><br><h2>  Erscheinungsdatum </h2><br>  Vor einigen Wochen haben wir eine Kategorisierungsversion bei Google Play veröffentlicht (diese wird nach einer Weile im App Store angezeigt).  Es stellte sich so heraus: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/h1/tj/ie/h1tjiekixykrb_liuwftfnd8ufy.png" width="50%"></div><br>  In zukünftigen Versionen planen wir, die Möglichkeit zur Korrektur von Kategorien hinzuzufügen, damit wir schnell Kategorisierungsfehler erfassen und das Kategorisierungsmodell neu trainieren können (während wir es selbst tun). <br><br>  Erwähnte Wettbewerbe bei Kaggle: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">www.kaggle.com/c/receipt-categorisation</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">www.kaggle.com/c/market-basket-analysis</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">www.kaggle.com/c/prod-price-prediction</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de430216/">https://habr.com/ru/post/de430216/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de430204/index.html">MIT-Kurs "Computer Systems Security". Vorlesung 18: „Privates Surfen im Internet“, Teil 1</a></li>
<li><a href="../de430206/index.html">MIT-Kurs "Computer Systems Security". Vorlesung 18: Privates Surfen im Internet, Teil 2</a></li>
<li><a href="../de430208/index.html">MIT-Kurs "Computer Systems Security". Vorlesung 18: „Privates Surfen im Internet“, Teil 3</a></li>
<li><a href="../de430210/index.html">Testen Sie meine Geduld mit der Check Point Security Academy</a></li>
<li><a href="../de430212/index.html">OpenSceneGraph: Grundlagen der Szenengeometrie</a></li>
<li><a href="../de430218/index.html">Energieoptimierung STM32: Ein praktischer Leitfaden</a></li>
<li><a href="../de430220/index.html">Wie man einen "hundertjährigen" USB-Hub in einen intelligent verwalteten verwandelt und 300 US-Dollar spart</a></li>
<li><a href="../de430222/index.html">Senior Engineer auf der Suche nach Arbeit. Wie ich 20 Interviews mit HR durchlaufen habe und was ich darüber denke</a></li>
<li><a href="../de430224/index.html">Schizotypische Störung: Ein Einblick</a></li>
<li><a href="../de430226/index.html">Von var b bis zum Interview</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>