<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🦂 🕷️ 🍻 Metamorphose beim Testen der Redux-Saga 🧑🏼‍🤝‍🧑🏼 💇🏼 🙇</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Das redux-saga Framework bietet eine Reihe interessanter Muster für die Arbeit mit Nebenwirkungen, aber wie echte blutige Unternehmensentwickler müsse...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Metamorphose beim Testen der Redux-Saga</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dodopizzadev/blog/458500/"> Das <code>redux-saga</code> Framework bietet eine Reihe interessanter Muster für die Arbeit mit Nebenwirkungen, aber wie echte blutige Unternehmensentwickler müssen wir unseren gesamten Code mit Tests abdecken.  Lassen Sie uns herausfinden, wie wir unsere Sagen testen werden. <br><br><img src="https://habrastorage.org/webt/bo/ex/ix/boexix6wnmkabte_okdbvippk2i.png"><br><a name="habracut"></a><br>  Nehmen Sie als Beispiel den einfachsten Clicker.  Der Datenfluss und die Bedeutung der Anwendung sind wie folgt: <br><br><ol><li>  Der Benutzer drückt eine Taste. </li><li>  Eine Anfrage wird an den Server gesendet und informiert, dass der Benutzer eine Schaltfläche gedrückt hat. </li><li>  Der Server gibt die Anzahl der Klicks zurück. </li><li>  Der Status zeichnet die Anzahl der Klicks auf. </li><li>  Die Benutzeroberfläche wird aktualisiert und der Benutzer sieht, dass die Anzahl der Klicks gestiegen ist. </li><li>  ... </li><li>  GEWINN. </li></ol><br>  In unserer Arbeit verwenden wir Typescript, sodass alle Beispiele in dieser Sprache vorliegen. <br><br>  Wie Sie wahrscheinlich schon vermutet haben, werden wir dies alles mit <code>redux-saga</code> umsetzen.  Hier ist der Code für die gesamte Sagendatei: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processClick</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> call(ServerApi.SendClick) <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> put(Actions.clickSuccess(result)) } <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">watchClick</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> takeEvery(ActionTypes.CLICK, processClick) }</code> </pre><br>  In diesem einfachen Beispiel deklarieren wir die Saga <code>watchClick</code> , die die Aktion direkt verarbeitet, und die Saga <code>watchClick</code> , die eine Schleife für die Verarbeitung von <code>action'</code> . <br><br><h2>  Generatoren </h2><br>  Wir haben also die einfachste Saga.  Es sendet eine Anfrage an den Server <code>( call)</code> , empfängt das Ergebnis und leitet es an den Reduzierer weiter <code>( put)</code> .  Wir müssen irgendwie testen, ob die Saga genau das überträgt, was sie vom Server empfängt.  Fangen wir an. <br><br>  Zum Testen müssen wir den Serveraufruf sperren und irgendwie prüfen, ob genau das, was vom Server kam, in den Reduzierer gelangt ist. <br><br>  Da Sagen Generatorfunktionen sind, ist die <code>next()</code> -Methode, die sich im Generatorprototyp befindet, die naheliegendste Methode zum Testen.  Bei Verwendung dieser Methode haben wir die Möglichkeit, sowohl den nächsten Wert vom Generator zu empfangen als auch den Wert an den Generator zu übertragen.  So haben wir sofort die Möglichkeit, nasse Anrufe zu erhalten.  Aber ist alles so rosig?  Hier ist ein Test, den ich für nackte Generatoren geschrieben habe: <br><br><pre> <code class="javascript hljs">it(<span class="hljs-string"><span class="hljs-string">'should increment click counter (behaviour test)'</span></span>, () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> saga = processClick() expect(saga.next().value).toEqual(call(ServerApi.SendClick)) expect(saga.next(<span class="hljs-number"><span class="hljs-number">10</span></span>).value).toEqual(put(Actions.clickSuccess(<span class="hljs-number"><span class="hljs-number">10</span></span>))) })</code> </pre><br>  Der Test war kurz, aber was testet er?  Tatsächlich wiederholt es einfach den Code der Saga-Methode, dh bei jeder Änderung der Saga muss der Test geändert werden. <br><br><blockquote>  Ein solcher Test hilft bei der Entwicklung nicht. </blockquote><br><h2>  Redux-Saga-Test-Plan </h2><br>  Nachdem wir auf dieses Problem gestoßen waren, entschieden wir uns, es zu googeln und stellten plötzlich fest, dass wir nicht die einzigen waren und weit vom ersten entfernt.  Direkt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in der Dokumentation</a> zur <code>redux-saga</code> bieten Entwickler einen Blick auf mehrere Bibliotheken, die speziell für <code>redux-saga</code> erstellt wurden. <br><br>  Aus der vorgeschlagenen Liste haben wir die <code>redux-saga-test-plan</code> Bibliothek <code>redux-saga-test-plan</code> .  Hier ist der Code für die erste Version des Tests, den ich damit geschrieben habe: <br><br><pre> <code class="javascript hljs">it(<span class="hljs-string"><span class="hljs-string">'should increment click counter (behaviour test with test-plan)'</span></span>, () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> expectSaga(processClick) .provide([ call(ServerApi.SendClick), <span class="hljs-number"><span class="hljs-number">2</span></span>] ]) .dispatch(Actions.click()) .call(ServerApi.SendClick) .put(Actions.clickSuccess(<span class="hljs-number"><span class="hljs-number">2</span></span>)) .run() })</code> </pre><br>  Der Testkonstruktor in <code>redux-saga-test-plan</code> ist die <code>expectSaga</code> Funktion, die die Schnittstelle zurückgibt, die den Test beschreibt.  Die Testsaga ( <code>processClick</code> aus der ersten Liste) wird an die Funktion selbst übergeben. <br><br>  Mit der <code>provide</code> können Sie Serveraufrufe oder andere Abhängigkeiten blockieren.  Es wird ein Array von <code>StaticProvider'</code> , die beschreiben, welche Methode zurückgegeben werden soll. <br><br>  Im <code>Act</code> Block haben wir eine einzige Methode - den <code>dispatch</code> .  Es wird eine Aktion übergeben, auf die die Saga reagiert. <br><br>  Der <code>assert</code> Block besteht aus den <code>call  put</code> Methoden, die prüfen, ob die entsprechenden Effekte während der Arbeit der Saga verursacht wurden. <br><br>  Alles endet mit der <code>run()</code> -Methode.  Diese Methode führt den Test direkt aus. <br><br><blockquote>  <b>Die Vorteile dieses Ansatzes:</b> <br><br><ul><li>  Es wird überprüft, ob die Methode aufgerufen wurde und nicht die Reihenfolge der Aufrufe. </li><li>  moki beschreibt klar, welche Funktion nass wird und was zurückkehrt. </li></ul><br>  <b>Es gibt jedoch noch viel zu tun:</b> <br><br><ul><li>  es gibt mehr Code; </li><li>  Der Test ist schwer zu lesen. </li><li>  Dies ist ein Verhaltenstest, was bedeutet, dass er immer noch mit der Umsetzung der Saga verbunden ist. </li></ul></blockquote><br><h2>  Die letzten beiden Schläge </h2><br><h4>  Zustandstest </h4><br>  Zuerst beheben wir den letzten: Wir machen einen Zustandstest aus einem Verhaltenstest.  Die Tatsache, dass Sie mit dem Testplan den Anfangszustand festlegen und den <code>reducer</code> passieren können, der auf die durch die Saga erzeugten <code>put</code> Effekte reagieren soll, hilft uns dabei.  Es sieht so aus: <br><br><pre> <code class="javascript hljs">it(<span class="hljs-string"><span class="hljs-string">'should increment click counter (state test with test-plan)'</span></span>, () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> initialState = { <span class="hljs-attr"><span class="hljs-attr">clickCount</span></span>: <span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> expectSaga(processClick) .provide([ call(ServerApi.SendClick), <span class="hljs-number"><span class="hljs-number">14</span></span>] ]) .withReducer(rootReducer, initialState) .dispatch(Actions.click()) .run() .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result</span></span></span><span class="hljs-function"> =&gt;</span></span> expect(result.storeState.clickCount).toBe(<span class="hljs-number"><span class="hljs-number">14</span></span>)) })</code> </pre><br>  In diesem Test überprüfen wir nicht mehr, ob Effekte ausgelöst wurden.  Wir überprüfen den endgültigen Zustand nach der Ausführung, und das ist in Ordnung. <br><br>  Wir haben es geschafft, die Implementierung der Saga loszuwerden. Versuchen wir nun, den Test verständlicher zu machen.  Dies ist einfach, wenn Sie <code>then()</code> durch <code>async/await</code> ersetzen: <br><br><pre> <code class="javascript hljs">it(<span class="hljs-string"><span class="hljs-string">'should increment click counter (state test with test-plan async-way)'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> initialState = { <span class="hljs-attr"><span class="hljs-attr">clickCount</span></span>: <span class="hljs-number"><span class="hljs-number">11</span></span>, } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> saga = expectSaga(processClick) .provide([ call(ServerApi.SendClick), <span class="hljs-number"><span class="hljs-number">14</span></span>] ]) .withReducer(rootReducer, initialState) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> saga.dispatch(Actions.click()).run() expect(result.storeState.clickCount).toBe(<span class="hljs-number"><span class="hljs-number">14</span></span>) })</code> </pre><br><h4>  Integrationstests </h4><br>  Aber was ist, wenn wir auch eine Reverse-Click-Operation haben (nennen wir es Unclick) und unsere Sag-Datei jetzt so aussieht: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processClick</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> call(ServerApi.SendClick) <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> put(Actions.clickSuccess(result)) } <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processUnclick</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> call(ServerApi.SendUnclick) <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> put(Actions.clickSuccess(result)) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">watchClick</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> takeEvery(ActionTypes.CLICK, processClick) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">watchUnclick</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> takeEvery(ActionTypes.UNCLICK, processUnclick) } <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mainSaga</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> all([watchClick(), watchUnclick()]) }</code> </pre><br>  Angenommen, wir müssen testen, ob das Ergebnis der letzten Fahrt zum Server in den Status geschrieben wird, wenn die Aktionen zum Klicken und Entfernen im Status aufgerufen werden.  Ein solcher Test kann auch leicht mit dem <code>redux-saga-test-plan</code> : <br><br><pre> <code class="javascript hljs">it(<span class="hljs-string"><span class="hljs-string">'should change click counter (integration test)'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> initialState = { <span class="hljs-attr"><span class="hljs-attr">clickCount</span></span>: <span class="hljs-number"><span class="hljs-number">11</span></span>, } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> saga = expectSaga(mainSaga) .provide([ call(ServerApi.SendClick), <span class="hljs-number"><span class="hljs-number">14</span></span>], call(ServerApi.SendUnclick), <span class="hljs-number"><span class="hljs-number">18</span></span>] ]) .withReducer(rootReducer, initialState) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> saga .dispatch(Actions.click()) .dispatch(Actions.unclick()) .run() expect(result.storeState.clickCount).toBe(<span class="hljs-number"><span class="hljs-number">18</span></span>) })</code> </pre><br>  Bitte beachten Sie, dass wir jetzt <code>mainSaga</code> testen und nicht einzelne <code>mainSaga</code> Handler. <br><br>  Wenn wir diesen Test jedoch so ausführen, wie er ist, erhalten wir das Vorning: <br><br><img src="https://habrastorage.org/webt/j3/-k/fz/j3-kfzdcrzhhsnhlapzuecdts2m.png"><br><br>  Dies ist auf den <code>takeEvery</code> Effekt zurückzuführen. Dies ist eine Nachrichtenverarbeitungsschleife, die funktioniert, solange unsere Anwendung geöffnet ist.  Dementsprechend kann der Test, in dem <code>takeEvery</code> aufgerufen <code>takeEvery</code> , die Arbeit nicht ohne fremde Hilfe abschließen, und der <code>redux-saga-test-plan</code> <code>takeEvery</code> beendet diese Effekte nach 250 ms nach Beginn des Tests zwangsweise.  Dieses Zeitlimit kann durch Aufrufen von expectedSaga.DEFAULT_TIMEOUT = 50 geändert werden. <br><blockquote>  Wenn Sie solche Vorings nicht erhalten möchten, einen für jeden Test mit einem komplexen Effekt, verwenden Sie einfach die <code>silentRun()</code> -Methode anstelle der <code>run()</code> -Methode. </blockquote><br><hr><br><h2>  Fallstricke </h2><br>  Wo ohne Fallstricke ... Zum Zeitpunkt dieses Schreibens war die neueste Version der Redux-Saga: 1.0.2.  Gleichzeitig kann <code>redux-saga-test-plan</code> nur mit JS damit arbeiten. <br><br>  Wenn Sie TypeScript möchten, müssen Sie die Version vom Beta-Kanal installieren: <br> <code>npm install redux-saga-test-plan@beta</code> <br>  und deaktivieren Sie Tests aus dem Build.  Dazu müssen Sie in der Datei tsconfig.json den Pfad "./src/**/*.spec.ts" im Feld "ausschließen" angeben. <br><br>  Trotzdem halten wir den <code>redux-saga-test-plan</code> <code>redux-saga</code> für die beste Bibliothek zum Testen der <code>redux-saga</code> .  Wenn Sie <code>redux-saga</code> in Ihrem Projekt haben, ist es vielleicht eine gute Wahl für Sie. <br><br>  Der Quellcode des Beispiels auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de458500/">https://habr.com/ru/post/de458500/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de458490/index.html">Halten Sie das Lenkrad fest ... Unser Projekt zur Überwachung des Fahrerzustands</a></li>
<li><a href="../de458492/index.html">„Wir haben immer an Wettbewerb und das Recht geglaubt, einen Benutzer auszuwählen“ © Yandex</a></li>
<li><a href="../de458494/index.html">Ein praktisches Beispiel für die Verwendung der Renderfunktionen von Vue: Erstellen eines typografischen Rasters für ein Entwurfssystem</a></li>
<li><a href="../de458496/index.html">Praktische Richtlinien für die Entwicklung umfangreicher React-Anwendungen. Planung, Aktionen, Datenquellen und APIs</a></li>
<li><a href="../de458498/index.html">Praktische Richtlinien für die Entwicklung umfangreicher React-Anwendungen. Teil 2: Zustandsverwaltung, Routing</a></li>
<li><a href="../de458502/index.html">Das Hauptgeheimnis für die Entwicklung guter Elektronenanwendungen</a></li>
<li><a href="../de458504/index.html">13 npm Tricks, um Zeit zu sparen</a></li>
<li><a href="../de458506/index.html">Nicht Portal 3, sondern nah: Quantenteleportation von Informationen innerhalb eines Diamanten</a></li>
<li><a href="../de458508/index.html">Ein Einblick: Graduiertenschule an der EPFL. Teil 4.2: die finanzielle Seite</a></li>
<li><a href="../de458514/index.html">Verstöße gegen die DSGVO werden aktiver bestraft - neue Bußgelder und die Auswirkungen von Vorschriften außerhalb der EU</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>