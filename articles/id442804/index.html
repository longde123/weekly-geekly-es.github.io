<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎨 🌇 🏂🏼 MVCC-1. Isolasi 👩🏾 ⚱️ 👨‍💼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habr! Dengan artikel ini, saya memulai serangkaian loop (atau serangkaian seri? Secara umum, ide besar) tentang struktur internal PostgreSQL. 

...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MVCC-1. Isolasi</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/442804/">  Halo, Habr!  Dengan artikel ini, saya memulai serangkaian loop (atau serangkaian seri? Secara umum, ide besar) tentang struktur internal PostgreSQL. <br><br>  Materi akan didasarkan pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kursus pelatihan</a> administrasi yang kami lakukan dengan Pavel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">pluzanov</a> .  Tidak semua orang suka menonton video (saya pasti tidak suka itu), tetapi membaca slide, bahkan dengan komentar, sepenuhnya “salah”. <br><br>  Tentu saja, artikel tidak akan mengulangi isi dari kursus satu ke satu.  Saya hanya akan berbicara tentang bagaimana semuanya berjalan, menghilangkan administrasi itu sendiri, tetapi saya akan mencoba melakukannya dengan lebih detail dan lebih detail.  Dan saya percaya bahwa pengetahuan semacam itu bermanfaat bagi pengembang aplikasi tidak kurang dari administrator. <br><br>  Saya akan fokus pada mereka yang sudah memiliki pengalaman menggunakan PostgreSQL dan setidaknya secara umum bayangkan apa yang terjadi.  Untuk pemula, teks akan sedikit berat.  Sebagai contoh, saya tidak akan mengatakan sepatah kata pun tentang cara menginstal PostgreSQL dan menjalankan psql. <br><br>  Hal-hal yang akan dibahas tidak banyak berubah dari versi ke versi, tetapi saya akan menggunakan PostgreSQL 11 vanilla saat ini. <br><br>  Siklus pertama dikhususkan untuk masalah yang berkaitan dengan isolasi dan multiversion, dan rencananya adalah sebagai berikut: <br><br><ol><li>  Isolasi, sebagaimana dipahami oleh standar dan PostgreSQL (artikel ini); </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Lapisan, file, halaman</a> - apa yang terjadi di tingkat fisik; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Versi baris, transaksi virtual dan bersarang</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Snapshots data dan visibilitas versi baris, horizon peristiwa</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pembersihan dalam-halaman dan pembaruan-HOT</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pembersihan normal</a> (vakum); </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pembersihan otomatis</a> (autovacuum); </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Transaksi counter overflow dan macet</a> . </li></ol><br>  Baiklah, ayo pergi. <br><a name="habracut"></a><br><h1>  Apa itu isolasi dan mengapa itu penting? </h1><br>  Mungkin semua orang setidaknya tahu tentang keberadaan transaksi, bertemu dengan singkatan ACID dan mendengar tentang tingkat isolasi.  Tetapi seseorang masih harus memenuhi pendapat bahwa ini adalah teori yang tidak perlu dalam praktek.  Karena itu, saya akan meluangkan waktu mencoba menjelaskan mengapa ini sangat penting. <br><br>  Tidak mungkin Anda akan senang jika aplikasi menerima data yang salah dari database, atau jika aplikasi menulis data yang salah ke database. <br><br>  Tetapi apakah data yang "benar"?  Diketahui bahwa pada tingkat basis data, Anda dapat membuat batasan integritas (seperti BUKAN NULL atau UNIK).  Jika data selalu memenuhi kendala integritas (dan ini karena DBMS menjamin ini), maka mereka bersifat holistik. <br><br>  <em>Apakah benar</em> dan tidak <em>terpisahkan</em> - hal yang sama?  Tidak juga.  Tidak semua batasan dapat dirumuskan di tingkat basis data.  Sebagian dari pembatasan terlalu rumit, misalnya, mencakup beberapa tabel sekaligus.  Dan bahkan jika pembatasan, pada prinsipnya, dapat didefinisikan dalam database, tetapi karena alasan tertentu mereka tidak melakukannya, itu tidak berarti bahwa itu dapat dilanggar. <br><br>  Jadi, <em>kebenaran</em> lebih ketat daripada <em>integritas</em> , tetapi kami tidak tahu persis apa itu.  Masih harus diakui bahwa standar kebenaran adalah aplikasi yang, seperti yang ingin kita yakini, ditulis <em>dengan benar</em> dan tidak pernah salah.  Bagaimanapun, jika aplikasi tidak melanggar integritas, tetapi melanggar kebenaran, DBMS tidak akan mengetahuinya dan tidak akan menangkapnya. <br><br>  Mulai sekarang, kami akan menyebut kebenaran istilah konsistensi. <br><br>  Mari kita asumsikan, bahwa aplikasi hanya mengeksekusi urutan pernyataan yang benar.  Lalu apa peran DBMS, jika aplikasi itu benar? <br><br>  Pertama, ternyata urutan pernyataan yang benar untuk sementara dapat mengganggu konsistensi data, dan ini - cukup aneh - adalah normal.  Contoh yang usang namun dapat dipahami adalah mentransfer dana dari satu akun ke akun lainnya.  Aturan konsistensi mungkin terdengar seperti ini: <em>transfer tidak pernah mengubah jumlah total uang dalam akun</em> (aturan semacam itu agak sulit untuk ditulis dalam SQL sebagai kendala integritas, sehingga ada di tingkat aplikasi dan tidak terlihat oleh DBMS).  Transfer terdiri dari dua operasi: yang pertama mengurangi dana dalam satu akun, yang kedua - meningkatkan yang lain.  Operasi pertama melanggar konsistensi data, yang kedua - mengembalikan. <br><br><blockquote>  Latihan yang baik adalah menerapkan aturan yang dijelaskan di atas pada tingkat kendala integritas.  Apakah kamu lemah?  © <br></blockquote><br>  Bagaimana jika operasi pertama selesai dan yang kedua tidak?  Lagi pula, itu mudah: selama operasi kedua, listrik dapat hilang, server bisa jatuh, pembagian dengan nol dapat terjadi - tetapi Anda tidak pernah tahu.  Jelas bahwa konsistensi dilanggar, dan ini tidak boleh dibiarkan.  Pada prinsipnya, adalah mungkin untuk menyelesaikan situasi seperti itu pada tingkat aplikasi dengan biaya upaya yang luar biasa, tetapi, untungnya, itu tidak perlu: DBMS menangani ini.  Tetapi untuk ini, dia harus tahu bahwa dua operasi merupakan keseluruhan yang tak terpisahkan.  Itu adalah <em>transaksi</em> . <br><br>  Ternyata menarik: mengetahui bahwa operasi merupakan suatu transaksi, DBMS membantu menjaga konsistensi dengan menjamin keaslian transaksi, sementara tidak mengetahui apa pun tentang aturan konsistensi tertentu. <br><br>  Tetapi ada titik kedua, yang lebih halus.  Segera setelah beberapa transaksi simultan muncul dalam sistem yang benar-benar benar satu per satu, bersama-sama mereka dapat bekerja secara salah.  Ini disebabkan oleh fakta bahwa urutan operasi dicampur: tidak dapat diasumsikan bahwa semua operasi dari satu transaksi dilakukan terlebih dahulu, dan hanya kemudian semua operasi dari yang lain. <br><br>  Catatan tentang simultanitas.  Memang, pada saat yang sama, transaksi dapat bekerja pada sistem dengan prosesor multi-core, dengan disk array, dll. Tetapi semua pertimbangan yang sama berlaku untuk server yang mengeksekusi perintah secara berurutan, dalam mode pembagian waktu: begitu banyak siklus, satu transaksi dieksekusi, begitu banyak siklus berbeda .  Terkadang istilah eksekusi <em>kompetitif</em> digunakan untuk meringkas. <br><br>  Situasi ketika transaksi yang benar tidak bekerja bersama dengan benar disebut <em>anomali</em> eksekusi simultan. <br><br>  Contoh sederhana: jika suatu aplikasi ingin mendapatkan data yang benar dari database, maka paling tidak itu tidak akan melihat perubahan dalam transaksi yang tidak dikomit lainnya.  Kalau tidak, Anda tidak hanya bisa mendapatkan data yang tidak konsisten, tetapi juga melihat sesuatu yang belum pernah ada dalam database (jika transaksi dibatalkan).  Anomali ini disebut <em>bacaan kotor</em> . <br><br>  Jika ada anomali lain yang lebih kompleks, yang akan kita bahas nanti. <br><br>  Tentu saja, tidak mungkin untuk menolak eksekusi simultan: jika tidak, kinerja seperti apa yang bisa didiskusikan?  Tetapi Anda tidak dapat bekerja dengan data yang salah. <br><br>  Dan lagi, DBMS datang untuk menyelamatkan.  Anda dapat membuat transaksi berjalan <em>seolah-olah</em> berurutan, <em>seolah-olah</em> satu demi satu.  Dengan kata lain, <em>terpisah</em> satu sama lain.  Pada kenyataannya, DBMS dapat melakukan operasi yang campur aduk, tetapi pada saat yang sama menjamin bahwa hasil eksekusi simultan akan bertepatan dengan hasil dari setiap eksekusi sekuensial yang mungkin.  Dan ini menghilangkan kemungkinan anomali. <br><br>  Jadi, kita sampai pada definisi: <br><br><blockquote>  Transaksi adalah serangkaian operasi yang dilakukan oleh aplikasi yang mentransfer basis data dari satu kondisi yang benar ke kondisi lain yang benar (konsistensi), asalkan transaksi tersebut selesai (atomicity) dan tanpa gangguan dari transaksi lain (isolasi). <br></blockquote><br>  Definisi ini menggabungkan tiga huruf pertama dari ACID akronim.  Mereka begitu erat terkait satu sama lain sehingga tidak masuk akal untuk mempertimbangkan satu tanpa yang lain.  Bahkan, sulit untuk merobek huruf D (daya tahan).  Lagi pula, jika terjadi crash sistem, perubahan pada transaksi yang tidak dikomit tetap ada di dalamnya, yang dengannya Anda harus melakukan sesuatu untuk mengembalikan konsistensi data. <br><br>  Semuanya akan baik-baik saja, tetapi implementasi isolasi lengkap adalah tugas yang sulit secara teknis, ditambah dengan penurunan throughput sistem.  Oleh karena itu, dalam praktiknya, sangat sering (tidak selalu, tetapi hampir selalu) pelemahan isolasi diterapkan, yang mencegah beberapa, tetapi tidak semua, anomali.  Dan ini berarti bagian dari pekerjaan untuk memastikan kebenaran data jatuh pada aplikasi.  Itulah mengapa sangat penting untuk memahami tingkat isolasi apa yang digunakan dalam sistem, jaminan apa yang diberikannya dan mana yang tidak, dan bagaimana menulis kode yang benar dalam kondisi seperti itu. <br><br><h1>  Level dan anomali isolasi SQL </h1><br>  Standar SQL telah lama menggambarkan empat level isolasi.  Level-level ini ditentukan dengan mendaftar anomali yang diperbolehkan atau tidak diizinkan saat melakukan transaksi pada level tersebut.  Oleh karena itu, untuk berbicara tentang level-level ini, Anda perlu berkenalan dengan anomali. <br><br>  Saya menekankan bahwa pada bagian ini kita berbicara tentang standar, yaitu, tentang teori tertentu yang menjadi dasar praktik, tetapi yang pada saat yang sama bertentangan.  Karena itu, semua contoh di sini adalah spekulatif.  Mereka akan menggunakan operasi yang sama pada akun pelanggan: ini cukup jelas, meskipun, diakui, itu tidak ada hubungannya dengan bagaimana operasi perbankan sebenarnya diatur. <br><br><h2>  Pembaruan yang hilang </h2><br>  Mari kita mulai dengan <em>pembaruan yang hilang</em> .  Anomali ini terjadi ketika dua transaksi membaca baris yang sama dalam tabel, kemudian satu transaksi memperbarui baris ini, dan setelah itu transaksi kedua juga memperbarui baris yang sama, tidak memperhitungkan perubahan yang dilakukan oleh transaksi pertama. <br><br>  Misalnya, dua transaksi akan meningkatkan jumlah pada akun yang sama sebesar 100 ₽.  Transaksi pertama membaca nilai saat ini (1000 ₽), kemudian transaksi kedua membaca nilai yang sama.  Transaksi pertama meningkatkan jumlah (ternyata 1100 ₽) dan menulis nilai ini.  Transaksi kedua melakukan hal yang sama - mendapatkan 1.100 same yang sama dan menulisnya.  Akibatnya, klien kehilangan 100 ₽. <br><br>  Pembaruan yang hilang tidak diizinkan oleh standar pada tingkat isolasi apa pun. <br><br><h2>  Membaca Kotor dan Membaca Tidak Berkomitmen </h2><br>  Dengan <em>bacaan kotor</em> kita sudah bertemu di atas.  Anomali ini terjadi ketika suatu transaksi membaca perubahan yang tertunda yang dibuat oleh transaksi lain. <br><br>  Misalnya, transaksi pertama mentransfer semua uang dari akun klien ke akun lain, tetapi tidak mencatat perubahan.  Transaksi lain membaca status akun, menerima 0 ₽ dan menolak untuk mengeluarkan uang tunai kepada klien - terlepas dari fakta bahwa transaksi pertama terganggu dan membatalkan perubahannya, sehingga nilai 0 tidak pernah ada dalam database. <br><br>  Bacaan kotor diizinkan oleh standar di tingkat Baca Tidak Berkomitmen. <br><br><h2>  Komitmen Baca dan Baca Non-Ulangi </h2><br>  Anomali <em>pembacaan non-berulang</em> terjadi ketika transaksi membaca baris yang sama dua kali, dan dalam interval antara pembacaan, transaksi kedua mengubah (atau menghapus) baris ini dan melakukan perubahan.  Maka transaksi pertama akan mendapatkan hasil yang berbeda. <br><br>  Misalnya, biarkan aturan konsistensi <em>melarang jumlah negatif di akun pelanggan</em> .  Transaksi pertama akan mengurangi jumlah dalam akun sebesar 100 ₽.  Dia memeriksa nilai saat ini, mendapatkan 1000 ₽ dan memutuskan bahwa pengurangan dimungkinkan.  Pada saat ini, transaksi kedua mengurangi jumlah dalam akun menjadi nol dan mencatat perubahan.  Jika sekarang transaksi pertama memeriksa ulang jumlahnya, dia akan menerima 0 ₽ (tetapi dia sudah memutuskan untuk mengurangi nilainya, dan akun "pergi ke minus"). <br><br>  Pembacaan tanpa pengulangan diizinkan oleh standar pada tingkat Read Uncommitted dan Read Committed.  Tapi pembacaan kotor Komitmen Baca tidak memungkinkan. <br><br><h2>  Phantom Read dan Repeatable Read </h2><br>  <em>Pembacaan hantu</em> terjadi ketika transaksi membaca satu set garis dua kali dalam kondisi yang sama, dan dalam interval antara membaca, transaksi kedua menambahkan baris yang memenuhi kondisi ini (dan melakukan perubahan).  Maka transaksi pertama akan menerima set baris yang berbeda. <br><br>  Misalnya, anggap aturan konsistensi <em>melarang pelanggan memiliki lebih dari 3 akun</em> .  Transaksi pertama akan membuka akun baru, memeriksa nomor mereka saat ini (katakanlah, 2) dan memutuskan bahwa pembukaan dimungkinkan.  Pada saat ini, transaksi kedua juga membuka akun baru untuk klien dan mencatat perubahan.  Jika sekarang transaksi pertama memeriksa ulang jumlahnya, maka akan menerima 3 (tetapi sudah membuka akun lain dan klien memiliki 4 dari mereka). <br><br>  Pembacaan hantu diizinkan oleh standar di tingkat Baca Tidak Berkomitmen, Baca Berkomitmen dan Diulang.  Tetapi pada tingkat Baca Berulang, pembacaan yang tidak berulang tidak diperbolehkan. <br><br><h2>  Kurangnya Anomali dan Serializable </h2><br>  Standar ini mendefinisikan level lain - Serializable - di mana tidak ada anomali yang diizinkan.  Dan ini sama sekali tidak sama dengan larangan pembaruan yang hilang dan pembacaan yang kotor, tidak berulang, dan hantu. <br><br>  Faktanya adalah bahwa ada anomali yang secara signifikan lebih diketahui daripada yang tercantum dalam standar, dan angka yang tidak diketahui masih belum diketahui. <br><br>  Serializable harus mencegah <em>semua</em> kelainan <em>pada umumnya</em> .  Ini berarti bahwa pada level ini, pengembang aplikasi tidak perlu berpikir untuk menjalankan secara bersamaan.  Jika transaksi melakukan urutan pernyataan yang benar, bekerja sendiri, data akan konsisten dengan operasi simultan dari transaksi ini. <br><br><h2>  Piring ringkasan </h2><br>  Sekarang Anda bisa membawa meja terkenal ke semua orang.  Tapi di sini, untuk kejelasan, kolom terakhir ditambahkan, yang tidak ada dalam standar. <br><div class="scrollable-table"><table><tbody><tr><th></th><th>  perubahan yang hilang </th><th>  bacaan kotor </th><th>  bacaan non-berulang </th><th>  pembacaan hantu </th><th>  anomali lainnya </th></tr><tr><th>  Baca Tidak Berkomitmen </th><th>  - </th><th>  iya </th><th>  iya </th><th>  iya </th><th>  iya </th></tr><tr><th>  Baca berkomitmen </th><th>  - </th><th>  - </th><th>  iya </th><th>  iya </th><th>  iya </th></tr><tr><th>  Baca berulang </th><th>  - </th><th>  - </th><th>  - </th><th>  iya </th><th>  iya </th></tr><tr><th>  Serializable </th><th>  - </th><th>  - </th><th>  - </th><th>  - </th><th>  - </th></tr></tbody></table></div><br><h2>  Mengapa justru anomali ini? </h2><br>  Mengapa hanya beberapa dari banyak anomali yang mungkin ada dalam standar yang tercantum, dan mengapa ini? <br><br>  Tampaknya, tidak ada yang tahu hal ini dengan pasti.  Tetapi praktik di sini jelas-jelas melampaui teori, jadi mungkin saja kita tidak memikirkan anomali lain (pidato tentang standar SQL: 92). <br><br>  Selain itu, diasumsikan bahwa isolasi harus dibangun di atas interlock.  Gagasan <em>protokol pemblokiran dua-fase</em> (2PL) yang banyak digunakan adalah bahwa selama transaksi, transaksi memblokir jalur yang digunakannya, dan ketika selesai, ia melepaskan kunci.  Sederhananya, semakin banyak kunci yang ditangkap transaksi, semakin baik itu diisolasi dari transaksi lainnya.  Tetapi kinerja sistem lebih menderita, karena alih-alih bekerja bersama, transaksi mulai berbaris untuk jalur yang sama. <br><br>  Tampak bagi saya bahwa perbedaan antara tingkat isolasi standar dijelaskan dengan tepat oleh jumlah kunci yang diperlukan. <br><br>  Jika suatu transaksi memblokir baris yang diubah dari perubahan, tetapi bukan dari pembacaan, kami mendapatkan tingkat Baca Tidak Berkomitmen: perubahan yang hilang tidak diizinkan, tetapi data yang tidak terikat dapat dibaca. <br><br>  Jika transaksi memblokir garis yang dapat berubah dari pembacaan dan perubahan, kami mendapatkan tingkat Komitmen Baca: Anda tidak dapat membaca data yang tidak dikomit, tetapi ketika Anda mengakses baris lagi, Anda bisa mendapatkan nilai yang berbeda (bacaan yang tidak berulang). <br><br>  Jika suatu transaksi memblokir garis yang dapat dibaca dan dapat diubah dari pembacaan dan perubahan, kita mendapatkan tingkat Baca Berulang: pembacaan berulang baris akan menghasilkan nilai yang sama. <br><br>  Tetapi ada masalah dengan Serializable: tidak mungkin untuk mengunci baris yang belum ada.  Karena itu, kemungkinan pembacaan hantu tetap: transaksi lain dapat menambahkan (tetapi tidak menghapus) baris yang berada dalam kondisi permintaan yang dieksekusi sebelumnya, dan baris ini akan diambil kembali. <br><br>  Oleh karena itu, untuk menerapkan tingkat Serializable, kunci biasa tidak cukup - Anda perlu memblokir bukan baris, tetapi kondisi (predikat).  Kunci semacam itu disebut <em>predikat</em> .  Mereka diusulkan kembali pada tahun 1976, tetapi penerapan praktis mereka dibatasi oleh kondisi yang agak sederhana, yang jelas bagaimana menggabungkan dua predikat yang berbeda.  Sejauh yang saya tahu, itu belum sampai pada implementasi kunci tersebut di sistem apa pun. <br><br><h1>  Tingkat isolasi PostgreSQL </h1><br>  Seiring waktu, Isolasi Snapshot menggantikan <em>protokol</em> manajemen transaksi pemblokiran.  Idenya adalah bahwa setiap transaksi bekerja dengan snapshot data yang konsisten pada titik waktu tertentu, di mana hanya perubahan yang dicatat sebelum penciptaan snapshot jatuh. <br><br>  Isolasi semacam itu tidak secara otomatis memungkinkan pembacaan yang kotor.  Secara formal, di PostgreSQL, Anda dapat menentukan level Read Uncommitted, tetapi akan berfungsi seperti Read Committed.  Oleh karena itu, kami tidak akan berbicara tentang tingkat Baca Tidak Berkomitmen lebih lanjut. <br><br>  PostgreSQL mengimplementasikan <em>multi-</em> versi protokol ini.  Gagasan multi-versi adalah bahwa beberapa versi dari string yang sama dapat hidup berdampingan dalam DBMS.  Ini memungkinkan Anda untuk membuat snapshot data menggunakan versi yang tersedia, dan bertahan dengan minimum kunci.  Bahkan, hanya perubahan yang diulangi pada baris yang sama yang diblokir.  Semua operasi lain dilakukan pada saat yang sama: transaksi penulisan tidak pernah memblokir transaksi membaca, dan transaksi membaca tidak pernah memblokir siapa pun. <br><br>  Dengan menggunakan snapshot data, isolasi dalam PostgreSQL lebih ketat daripada standar yang disyaratkan: tingkat Baca Berulang tidak hanya memungkinkan tidak berulang, tetapi juga membaca hantu (meskipun tidak memberikan isolasi lengkap).  Dan ini dicapai tanpa kehilangan efektivitas. <br><div class="scrollable-table"><table><tbody><tr><th></th><th>  perubahan yang hilang </th><th>  bacaan kotor </th><th>  bacaan non-berulang </th><th>  pembacaan hantu </th><th>  anomali lainnya </th></tr><tr><th>  Baca Tidak Berkomitmen </th><th>  - </th><th>  - </th><th>  iya </th><th>  iya </th><th>  iya </th></tr><tr><th>  Baca berkomitmen </th><th>  - </th><th>  - </th><th>  iya </th><th>  iya </th><th>  iya </th></tr><tr><th>  Baca berulang </th><th>  - </th><th>  - </th><th>  - </th><th>  - </th><th>  iya </th></tr><tr><th>  Serializable </th><th>  - </th><th>  - </th><th>  - </th><th>  - </th><th>  - </th></tr></tbody></table></div><br>  Bagaimana multi-versi diimplementasikan "di bawah tenda", kita akan berbicara dalam artikel berikut, dan sekarang kita akan melihat secara terperinci pada masing-masing tiga tingkat melalui mata pengguna (seperti yang Anda tahu, yang paling menarik tersembunyi di balik "anomali lain").  Untuk melakukan ini, buat tabel akun.  Alice dan Bob masing-masing memiliki $ 1.000, tetapi Bob memiliki dua akun terbuka: <br><br><pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> accounts( id <span class="hljs-type"><span class="hljs-type">integer</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PRIMARY KEY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GENERATED</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DEFAULT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IDENTITY</span></span>, number <span class="hljs-type"><span class="hljs-type">text</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UNIQUE</span></span>, client <span class="hljs-type"><span class="hljs-type">text</span></span>, amount <span class="hljs-type"><span class="hljs-type">numeric</span></span> ); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'1001'</span></span>, <span class="hljs-string"><span class="hljs-string">'alice'</span></span>, <span class="hljs-number"><span class="hljs-number">1000.00</span></span>), (<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'2001'</span></span>, <span class="hljs-string"><span class="hljs-string">'bob'</span></span>, <span class="hljs-number"><span class="hljs-number">100.00</span></span>), (<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">'2002'</span></span>, <span class="hljs-string"><span class="hljs-string">'bob'</span></span>, <span class="hljs-number"><span class="hljs-number">900.00</span></span>);</code> </pre> <br><h2>  Baca berkomitmen </h2><br><h3>  Kurang membaca kotor </h3><br>  Sangat mudah untuk memverifikasi bahwa data kotor tidak dapat dibaca.  Ayo mulai transaksi.  Secara default, ini akan menggunakan level isolasi Read Committed: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SHOW</span></span> transaction_isolation;</code> </pre><pre> <code class="plaintext hljs"> transaction_isolation ----------------------- read committed (1 row)</code> </pre><br>  Lebih tepatnya, level default diatur oleh parameter, itu dapat diubah jika perlu: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SHOW</span></span> default_transaction_isolation;</code> </pre><pre> <code class="plaintext hljs"> default_transaction_isolation ------------------------------- read committed (1 row)</code> </pre><br>  Jadi, dalam transaksi terbuka, kami menarik dana dari akun, tetapi tidak mencatat perubahan.  Transaksi melihat perubahannya sendiri: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">200</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'alice'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+-------- 1 | 1001 | alice | 800.00 (1 row)</code> </pre><br>  Di sesi kedua, kami memulai transaksi lain dengan tingkat Baca Komitmen yang sama.  Untuk membedakan antara transaksi yang berbeda, perintah dari transaksi kedua akan diindentasi dan dicoret. <br><br>  Untuk mengulangi perintah di atas (yang berguna), Anda perlu membuka dua terminal dan menjalankan psql di masing-masing.  Di yang pertama, Anda dapat memasukkan perintah dari satu transaksi, dan di yang kedua - perintah dari yang lain. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'alice'</span></span>;</code> </pre><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+--------- | 1 | 1001 | alice | 1000.00 | (1 row)</code> </pre><br>  Seperti yang diharapkan, transaksi lain tidak melihat perubahan yang tidak dikomit - pembacaan kotor tidak diperbolehkan. <br><br><h3>  Bacaan tanpa pengulangan </h3><br>  Sekarang biarkan transaksi pertama melakukan perubahan, dan yang kedua menjalankan kembali permintaan yang sama. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'alice'</span></span>;</code> </pre><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+-------- | 1 | 1001 | alice | 800.00 | (1 row)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Permintaan sudah menerima data baru - ini adalah anomali <em>pembacaan yang tidak berulang</em> , yang diizinkan pada tingkat Komitmen Baca. <br><br>  <em>Kesimpulan praktis</em> : dalam suatu transaksi tidak mungkin untuk membuat keputusan berdasarkan data yang dibaca oleh pernyataan sebelumnya - karena semuanya dapat berubah antara waktu pernyataan dieksekusi.  Berikut adalah contoh yang variasinya sangat umum dalam kode aplikasi sehingga merupakan antipattern klasik: <br><br><pre> <code class="pgsql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> amount <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>) &gt;= <span class="hljs-number"><span class="hljs-number">1000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">1000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span>;</code> </pre><br>  Selama waktu yang berlalu antara verifikasi dan pembaruan, transaksi lain dapat mengubah keadaan akun yang diinginkan, sehingga "cek" seperti itu tidak menyimpan apa pun.  Lebih mudah untuk membayangkan bahwa antara operator dari satu transaksi, operator lain dari transaksi lainnya dapat "mengganjal", misalnya, seperti ini: <br><br><pre> <code class="pgsql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> amount <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>) &gt;= <span class="hljs-number"><span class="hljs-number">1000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-comment"><span class="hljs-comment">----- | UPDATE accounts SET amount = amount - 200 WHERE id = 1; | COMMIT; ----- UPDATE accounts SET amount = amount - 1000 WHERE id = 1; END IF;</span></span></code> </pre><br>  Jika, menata ulang operator, Anda dapat merusak segalanya, maka kodenya ditulis secara tidak benar.  Dan jangan menipu diri sendiri bahwa kombinasi keadaan seperti itu tidak akan terjadi - itu akan terjadi. <br><br>  Bagaimana cara menulis kode dengan benar?  Peluang, sebagai aturannya, berbunyi sebagai berikut: <br><br><ul><li>  Jangan menulis kode. <br>  Ini bukan lelucon.  Misalnya, dalam kasus ini, pemeriksaan dengan mudah berubah menjadi kendala integritas: <br> <code>ALTER TABLE accounts ADD CHECK amount &gt;= 0;</code> <br>  Sekarang, tidak ada pemeriksaan yang diperlukan: itu cukup untuk hanya melakukan tindakan dan, jika perlu, menangani pengecualian yang akan muncul jika terjadi upaya untuk melanggar integritas. <br></li><li>  Gunakan pernyataan SQL tunggal. <br>  Masalah konsistensi muncul karena fakta bahwa dalam interval antara operator transaksi lain dapat berakhir dan data yang terlihat akan berubah.  Dan jika hanya ada satu operator, maka tidak ada celah. <br>  PostgreSQL memiliki cukup alat untuk menyelesaikan masalah yang kompleks dengan pernyataan SQL tunggal.  Kami mencatat ekspresi tabel umum (CTE), di mana, antara lain, Anda dapat menggunakan pernyataan INSERT / UPDATE / DELETE, serta pernyataan INSERT ON CONFLICT, yang mengimplementasikan logika "sisipkan, dan jika sudah ada baris, perbarui" dalam satu pernyataan. <br></li><li>  Kunci pengguna. <br>  Pilihan terakhir adalah secara manual mengatur kunci eksklusif baik pada semua baris yang diperlukan (PILIH UNTUK PEMBARUAN), atau pada seluruh tabel (LOCK TABLE).  Ini selalu berhasil, tetapi meniadakan manfaat multi-versi: daripada mengeksekusi secara bersamaan, bagian dari operasi akan dilakukan secara berurutan. <br></li></ul><br><h3>  Pembacaan tidak konsisten </h3><br>  Sebelum memulai tingkat isolasi berikutnya, kita harus mengakui bahwa tidak semuanya begitu sederhana.  Implementasi PostgreSQL sedemikian rupa sehingga memungkinkan anomali lain yang kurang terkenal yang tidak diatur oleh standar. <br><br>  Katakanlah transaksi pertama mulai mentransfer dana dari satu akun Bob ke yang lain: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><br>  Pada saat ini, transaksi lain menghitung saldo Bob, dengan perhitungan dilakukan dalam siklus di semua akun Bob.  Bahkan, transaksi dimulai dari akun pertama (dan, jelas, melihat keadaan sebelumnya): <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> amount <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><pre> <code class="plaintext hljs">| amount | -------- | 100.00 | (1 row)</code> </pre><br>  Pada titik ini, transaksi pertama selesai dengan sukses: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Dan yang lain membaca status akun kedua (dan sudah melihat nilai baru): <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> amount <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>;</code> </pre><pre> <code class="plaintext hljs">| amount | --------- | 1000.00 | (1 row)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Dengan demikian, transaksi kedua menerima total 1100 ₽, yaitu, data yang salah.  Ini adalah anomali <em>bacaan yang tidak konsisten</em> . <br><br>  Bagaimana cara menghindari anomali seperti itu dengan tetap di Read Committed?  Tentu saja, gunakan satu operator.  Misalnya, seperti ini: <br><br><pre> <code class="pgsql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> sum(amount) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><br><br>  Sejauh ini, saya berpendapat bahwa visibilitas data hanya dapat berubah di antara operator, tetapi apakah sudah jelas?  Dan jika permintaan itu dieksekusi untuk waktu yang lama, dapatkah ia melihat sebagian data dalam satu keadaan, dan sebagian lainnya? <br><br>  Lihat itu.  Cara mudah untuk melakukan ini adalah memasukkan penundaan buatan ke dalam operator dengan memanggil fungsi pg_sleep.  Parameternya menetapkan waktu tunda dalam detik. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> amount, pg_sleep(<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><br>  Saat konstruksi ini sedang berlangsung, dalam transaksi lain, kami mentransfer dana kembali: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Hasilnya menunjukkan bahwa operator melihat data dalam keadaan di mana ia dimulai.  Ini tentu saja benar. <br><br><pre> <code class="plaintext hljs"> amount | pg_sleep ---------+---------- 0.00 | 1000.00 | (2 rows)</code> </pre><br>  Tapi ini tidak sesederhana itu.  PostgreSQL memungkinkan Anda untuk mendefinisikan fungsi, sementara fungsi memiliki konsep <em>kategori variabilitas</em> .  Jika fungsi <em>volatil</em> (dengan kategori VOLATILE) dipanggil dalam permintaan, dan permintaan lain dijalankan dalam fungsi ini, maka permintaan ini di dalam fungsi akan melihat data yang tidak konsisten dengan data permintaan utama. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> get_amount(id <span class="hljs-type"><span class="hljs-type">integer</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-type"><span class="hljs-type">numeric</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">SELECT</span></span></span><span class="pgsql"> amount </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">FROM</span></span></span><span class="pgsql"> accounts a </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHERE</span></span></span><span class="pgsql"> a.id = get_amount.id; $$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span> <span class="hljs-keyword"><span class="hljs-keyword">VOLATILE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LANGUAGE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> get_amount(id), pg_sleep(<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Dalam hal ini, kami mendapatkan data yang salah - 100 ₽ hilang: <br><br><pre> <code class="plaintext hljs"> get_amount | pg_sleep ------------+---------- 100.00 | 800.00 | (2 rows)</code> </pre><br>  Saya menekankan bahwa efek seperti itu hanya mungkin pada tingkat isolasi yang dilakukan Read Read, dan hanya dengan kategori variabilitas VOLATILE.  Masalahnya adalah tingkat isolasi dan kategori variabilitas ini digunakan secara default, jadi saya harus akui - penggaruknya terletak sangat baik.  Jangan melangkah! <br><br><h3>  Pembacaan tidak konsisten dengan imbalan perubahan yang hilang </h3><br>  Pembacaan yang tidak konsisten dalam kerangka kerja satu operator dapat - dengan cara yang agak tak terduga - diperoleh selama pembaruan. <br><br>  Mari kita lihat apa yang terjadi ketika Anda mencoba mengubah baris yang sama dengan dua transaksi.  Bob sekarang memiliki 1000 ₽ pada dua akun: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+-------- 2 | 2001 | bob | 200.00 3 | 2002 | bob | 800.00 (2 rows)</code> </pre><br>  Kami memulai transaksi yang mengurangi saldo Bob: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>;</code> </pre><br>  Pada saat yang sama, transaksi lain menimbulkan bunga pada semua akun pelanggan dengan total saldo sama dengan atau lebih besar dari 1000 ₽: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount * <span class="hljs-number"><span class="hljs-number">1.01</span></span> | <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> ( | <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> client | <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts | <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> client | <span class="hljs-keyword"><span class="hljs-keyword">HAVING</span></span> sum(amount) &gt;= <span class="hljs-number"><span class="hljs-number">1000</span></span> | );</code> </pre><br>  Melaksanakan pernyataan UPDATE terdiri dari dua bagian.  Pertama, SELECT sebenarnya dieksekusi, yang memilih baris yang cocok dengan kondisi untuk memperbarui.  Karena perubahan transaksi pertama tidak tetap, transaksi kedua tidak dapat melihatnya dan itu tidak mempengaruhi pilihan garis untuk menghitung bunga.  Jadi, akun Bob jatuh dalam kondisi dan setelah pembaruan selesai, saldonya akan meningkat 10 ₽. <br><br>  Tahap kedua eksekusi - baris yang dipilih diperbarui satu demi satu.  Di sini transaksi kedua dipaksa untuk "membeku", karena baris id = 3 sudah dikunci oleh transaksi pertama. <br><br>  Sementara itu, transaksi pertama melakukan perubahan: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Apa hasilnya? <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+---------- 2 | 2001 | bob | 202.0000 3 | 2002 | bob | 707.0000 (2 rows)</code> </pre><br>  Ya, di satu sisi, perintah UPDATE seharusnya tidak melihat perubahan dalam transaksi kedua.  Tetapi di sisi lain, itu tidak boleh kehilangan perubahan yang dicatat dalam transaksi kedua. <br><br>  Setelah kunci dilepaskan, UPDATE membaca kembali baris yang sedang berusaha diperbarui (tetapi hanya satu!).  Hasilnya adalah Bob memperoleh 9 ₽, berdasarkan jumlah 900 ₽.  Tetapi jika Bob memiliki 900 ₽, akunnya seharusnya tidak dimasukkan dalam sampel sama sekali. <br><br>  Jadi, transaksi menerima data yang salah: beberapa baris terlihat pada satu titik waktu, beberapa di titik lainnya.  Alih-alih pembaruan yang hilang, kami kembali mendapatkan anomali dalam <em>pembacaan yang tidak konsisten</em> . <br><br><blockquote>  Pembaca yang penuh perhatian mencatat bahwa dengan bantuan dari aplikasi di level Read Committed, Anda bisa mendapatkan pembaruan yang hilang.  Misalnya, seperti ini: <br><br><pre> <code class="pgsql hljs"> x := (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> amount <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = x + <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br>  Basis data tidak bisa disalahkan: ia menerima dua pernyataan SQL dan tidak tahu apa-apa bahwa nilai x + 100 entah bagaimana terkait dengan accounts.amount.  Jangan menulis kode dengan cara ini. <br></blockquote><br><h2>  Baca berulang </h2><br><h3>  Kurangnya bacaan yang tidak berulang dan phantom </h3><br>  Nama tingkat isolasi itu sendiri menunjukkan bahwa bacaan tersebut dapat diulang.  Kami akan memverifikasi ini, dan pada saat yang sama kami akan diyakinkan tentang tidak adanya pembacaan hantu.  Untuk melakukan ini, dalam transaksi pertama, kembalikan akun Bob ke keadaan sebelumnya dan buat akun baru untuk Charlie: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = <span class="hljs-number"><span class="hljs-number">200.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = <span class="hljs-number"><span class="hljs-number">800.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">'3001'</span></span>, <span class="hljs-string"><span class="hljs-string">'charlie'</span></span>, <span class="hljs-number"><span class="hljs-number">100.00</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> id;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+---------+-------- 1 | 1001 | alice | 800.00 2 | 2001 | bob | 200.00 3 | 2002 | bob | 800.00 4 | 3001 | charlie | 100.00 (4 rows)</code> </pre><br>  Di sesi kedua, kami memulai transaksi dengan tingkat Baca Berulang, menunjukkannya dalam perintah BEGIN (tingkat transaksi pertama tidak penting). <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> id;</code> </pre><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+---------- | 1 | 1001 | alice | 800.00 | 2 | 2001 | bob | 202.0000 | 3 | 2002 | bob | 707.0000 | (3 rows)</code> </pre><br>  Sekarang transaksi pertama melakukan perubahan, dan yang kedua menjalankan kembali permintaan yang sama. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> id;</code> </pre><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+---------- | 1 | 1001 | alice | 800.00 | 2 | 2001 | bob | 202.0000 | 3 | 2002 | bob | 707.0000 | (3 rows)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Transaksi kedua terus melihat data yang sama persis seperti di awal: tidak ada perubahan pada baris yang ada maupun baris baru yang terlihat. <br><br>  Di tingkat ini, Anda tidak perlu khawatir tentang sesuatu yang berubah di antara kedua operator. <br><br><h3>  Kesalahan serialisasi dengan imbalan perubahan yang hilang </h3><br>  Kami mengatakan di atas bahwa ketika memperbarui baris yang sama dengan dua transaksi di tingkat Komitmen Baca, mungkin terjadi anomali pembacaan yang tidak konsisten.  Hal ini disebabkan oleh fakta bahwa transaksi yang tertunda membaca ulang baris yang terkunci dan dengan demikian melihatnya tidak pada titik waktu yang sama dengan sisa baris. <br><br>  Pada tingkat Repeatable Read, anomali seperti itu tidak diperbolehkan, tetapi jika itu terjadi, tidak ada yang bisa dilakukan - karena itu, transaksi berakhir dengan kesalahan serialisasi.  Kami memverifikasi dengan mengulangi skenario yang sama dengan persentase: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+-------- 2 | 2001 | bob | 200.00 3 | 2002 | bob | 800.00 (2 rows)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">100.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount * <span class="hljs-number"><span class="hljs-number">1.01</span></span> | <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> ( | <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> client | <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts | <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> client | <span class="hljs-keyword"><span class="hljs-keyword">HAVING</span></span> sum(amount) &gt;= <span class="hljs-number"><span class="hljs-number">1000</span></span> | );</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="plaintext hljs">| ERROR: could not serialize access due to concurrent update</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span>;</code> </pre><br>  Data tetap konsisten: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+-------- 2 | 2001 | bob | 200.00 3 | 2002 | bob | 700.00 (2 rows)</code> </pre><br>  Kesalahan yang sama akan terjadi dalam kasus perubahan baris kompetitif lainnya, bahkan jika kolom yang menarik bagi kami belum benar-benar berubah. <br><br>  <em>Kesimpulan praktis</em> : jika aplikasi menggunakan tingkat isolasi Read Repeatable untuk menulis transaksi, harus disiapkan untuk mengulangi transaksi yang gagal dengan kesalahan serialisasi.  Untuk transaksi read-only, hasil seperti itu tidak dimungkinkan. <br><br><h3>  Entri yang tidak konsisten </h3><br>  Jadi, dalam PostgreSQL, pada tingkat isolasi dari Repeatable Read, semua anomali yang dijelaskan dalam standar dicegah.  Tapi tidak semuanya.  Ternyata ada <em>dua</em> anomali yang mungkin terjadi.  (Ini berlaku tidak hanya untuk PostgreSQL, tetapi juga untuk implementasi isolasi berbasis snapshot lainnya.) <br><br>  Yang pertama dari anomali ini adalah <em>catatan yang tidak konsisten</em> . <br><br>  Biarkan aturan konsistensi ini berlaku: <em>jumlah negatif diperbolehkan di akun klien jika jumlah total pada semua akun klien ini tetap tidak negatif</em> . <br><br>  Transaksi pertama menerima jumlah dalam akun Bob: 900 ₽. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> sum(amount) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> sum -------- 900.00 (1 row)</code> </pre><br>  Transaksi kedua menerima jumlah yang sama. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> sum(amount) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs">| sum | -------- | 900.00 | (1 row)</code> </pre><br>  Transaksi pertama benar percaya bahwa jumlah salah satu akun dapat dikurangi hingga 600 ₽. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">600.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><br>  Dan transaksi kedua sampai pada kesimpulan yang sama.  Tetapi mengurangi skor lain: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">600.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+--------- 2 | 2001 | bob | -400.00 3 | 2002 | bob | 100.00 (2 rows)</code> </pre><br>  Kami berhasil mengurangi saldo Bob, meskipun masing-masing transaksi berfungsi dengan benar secara individual. <br><br><h3>  Anomali Hanya Baca </h3><br>  Ini adalah anomali kedua dan terakhir yang dimungkinkan pada tingkat Baca Berulang.  Untuk mendemonstrasikannya, Anda memerlukan tiga transaksi, dua di antaranya akan mengubah data, dan yang ketiga hanya membaca. <br><br>  Tapi pertama-tama, pulihkan status akun Bob: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = <span class="hljs-number"><span class="hljs-number">900.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+-------- 3 | 2002 | bob | 100.00 2 | 2001 | bob | 900.00 (2 rows)</code> </pre><br>  Transaksi pertama membebankan bunga kepada Bob pada jumlah dana di semua akun.  Bunga dikreditkan ke salah satu akunnya: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; <span class="hljs-comment"><span class="hljs-comment">-- 1 =&gt; UPDATE accounts SET amount = amount + ( SELECT sum(amount) FROM accounts WHERE client = 'bob' ) * 0.01 WHERE id = 2;</span></span></code> </pre><br>  Kemudian transaksi lain menarik uang dari akun lain Bob dan menangkap perubahannya: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; <span class="hljs-comment"><span class="hljs-comment">-- 2 | =&gt; UPDATE accounts SET amount = amount - 100.00 WHERE id = 3; | =&gt; COMMIT;</span></span></code> </pre><br>  Jika pada saat ini transaksi pertama dilakukan, tidak akan ada anomali: kita dapat berasumsi bahwa transaksi pertama selesai terlebih dahulu, dan kemudian yang kedua (tetapi bukan sebaliknya, karena transaksi pertama melihat status id akun = 3 sebelum akun ini diubah dengan transaksi kedua). <br><br>  Tetapi anggaplah bahwa pada saat ini transaksi ketiga (hanya baca) dimulai, yang membaca status beberapa akun yang tidak terpengaruh oleh dua transaksi pertama: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; <span class="hljs-comment"><span class="hljs-comment">-- 3 | =&gt; SELECT * FROM accounts WHERE client = 'alice';</span></span></code> </pre><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+-------- | 1 | 1001 | alice | 800.00 | (1 row)</code> </pre><br>  Dan hanya setelah itu transaksi pertama selesai: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Kondisi apa yang harus dilihat oleh transaksi ketiga sekarang? <br><br><pre> <code class="pgsql hljs">| <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><br>  Setelah dimulai, transaksi ketiga dapat melihat perubahan dalam transaksi kedua (yang sudah dilakukan), tetapi bukan yang pertama (yang belum dilakukan).  Di sisi lain, kami telah menetapkan di atas bahwa transaksi kedua harus dianggap telah dimulai setelah yang pertama.  Apa pun keadaan yang dilihat oleh transaksi ketiga, itu akan menjadi tidak konsisten - ini adalah anomali dari hanya transaksi pembacaan.  Tetapi pada level Repeatable Read, diizinkan: <br><br><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+-------- | 2 | 2001 | bob | 900.00 | 3 | 2002 | bob | 0.00 | (2 rows)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><h2>  Serializable </h2><br>  Pada tingkat Serializable, semua anomali yang mungkin dicegah.  Bahkan, Serializable diimplementasikan sebagai tambahan pada isolasi berdasarkan snapshot data.  Anomali yang tidak terjadi selama Baca Berulang (seperti kotor, tidak dapat diulang, baca hantu) tidak terjadi pada tingkat Serializable.  Dan anomali-anomali yang muncul (pencatatan yang tidak konsisten dan anomali hanya dari transaksi pembacaan) terdeteksi dan transaksi dibatalkan - kesalahan serialisasi yang sudah dikenal tidak bisa membuat serialisasi akses terjadi. <br><br><h3>  Entri yang tidak konsisten </h3><br>  Sebagai ilustrasi, kami ulangi skenario dengan anomali rekaman yang tidak konsisten: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SERIALIZABLE</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> sum(amount) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> sum ---------- 910.0000 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SERIALIZABLE</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> sum(amount) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs">| sum | ---------- | 910.0000 | (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">600.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">600.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><pre> <code class="plaintext hljs">ERROR: could not serialize access due to read/write dependencies among transactions DETAIL: Reason code: Canceled on identification as a pivot, during commit attempt. HINT: The transaction might succeed if retried.</code> </pre><br>  Selain pada level Repeatable Read, aplikasi yang menggunakan level isolasi Serializable harus mengulangi transaksi yang berakhir dengan kesalahan serialisasi, yang juga dilaporkan kepada kami melalui petunjuk dalam pesan kesalahan. <br><br>  Kami mendapatkan kesederhanaan pemrograman, tetapi harga untuk itu adalah pengelompokan paksa dari proporsi transaksi tertentu dan kebutuhan untuk mengulanginya.  Seluruh pertanyaan, tentu saja, seberapa besar bagian ini.  Jika hanya transaksi yang dihentikan yang benar-benar tidak kompatibel berpotongan dalam data dengan transaksi lain, semuanya akan baik.  Tetapi implementasi seperti itu pasti akan berubah menjadi sumber daya intensif dan tidak efisien, karena harus melacak operasi dengan setiap baris. <br><br>  Faktanya, implementasi PostgreSQL sedemikian rupa sehingga memungkinkan pemicu negatif palsu: beberapa transaksi yang benar-benar normal yang “tidak beruntung” akan terputus.  Seperti yang akan kita lihat nanti, ini tergantung pada banyak alasan, misalnya, ketersediaan indeks yang sesuai atau jumlah RAM yang tersedia.  Selain itu, ada beberapa pembatasan implementasi (agak serius) lainnya, misalnya, permintaan pada tingkat Serializable tidak akan berfungsi pada replika, rencana eksekusi paralel tidak akan digunakan untuk mereka.  Dan meskipun upaya meningkatkan implementasi tidak berhenti, pembatasan yang ada mengurangi daya tarik tingkat isolasi ini. <br><blockquote>  Paket paralel akan muncul di PostgreSQL 12 ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">patch</a> ).  Dan pertanyaan tentang replika dapat diperoleh di PostgreSQL 13 ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">patch lain</a> ). <br></blockquote><br><h3>  Anomali Hanya Baca </h3><br>  Sehingga hanya transaksi membaca yang tidak dapat menyebabkan anomali dan tidak dapat menderita dari itu, PostgreSQL menawarkan mekanisme yang menarik: transaksi seperti itu dapat diblokir sampai pelaksanaannya aman.  Ini adalah satu-satunya kasus di mana pernyataan SELECT dapat diblokir oleh pembaruan baris.  Begini tampilannya: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = <span class="hljs-number"><span class="hljs-number">900.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = <span class="hljs-number"><span class="hljs-number">100.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> id;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+-------- 2 | 2001 | bob | 900.00 3 | 2002 | bob | 100.00 (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SERIALIZABLE</span></span>; <span class="hljs-comment"><span class="hljs-comment">-- 1 =&gt; UPDATE accounts SET amount = amount + ( SELECT sum(amount) FROM accounts WHERE client = 'bob' ) * 0.01 WHERE id = 2;</span></span></code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SERIALIZABLE</span></span>; <span class="hljs-comment"><span class="hljs-comment">-- 2 | =&gt; UPDATE accounts SET amount = amount - 100.00 WHERE id = 3; | =&gt; COMMIT;</span></span></code> </pre><br>  Transaksi ketiga secara eksplisit dinyatakan hanya oleh pembaca (BACA SAJA) dan ditangguhkan (DITANGGUNG JAWAB): <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SERIALIZABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ONLY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DEFERRABLE</span></span>; <span class="hljs-comment"><span class="hljs-comment">-- 3 | =&gt; SELECT * FROM accounts WHERE client = 'alice';</span></span></code> </pre><br>  Ketika Anda mencoba mengeksekusi permintaan, transaksi diblokir, karena jika tidak dieksekusi akan menyebabkan anomali. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Dan hanya setelah transaksi pertama dilakukan, yang ketiga terus mengeksekusi: <br><br><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+-------- | 1 | 1001 | alice | 800.00 | (1 row)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+---------- | 2 | 2001 | bob | 910.0000 | 3 | 2002 | bob | 0.00 | (2 rows)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Catatan penting lainnya: jika isolasi Serializable digunakan, maka semua transaksi dalam aplikasi harus menggunakan level ini.  Anda tidak dapat mencampur transaksi Read Committed (atau Repeatable Read) dengan Serializable.  Artinya, Anda dapat mencampur sesuatu, tetapi kemudian Serializable akan berperilaku seperti Baca Berulang tanpa peringatan.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mengapa ini terjadi, kami akan pertimbangkan nanti ketika kami berbicara tentang implementasi. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jadi jika Anda memutuskan untuk menggunakan Serializble, yang terbaik adalah mengatur tingkat default secara global (meskipun ini, tentu saja, tidak melarang menentukan level yang salah secara eksplisit):</font></font><br><br><pre> <code class="pgsql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> default_transaction_isolation = <span class="hljs-string"><span class="hljs-string">'serializable'</span></span>;</code> </pre><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Presentasi yang lebih ketat tentang masalah-masalah yang berkaitan dengan transaksi, konsistensi dan anomali dapat ditemukan dalam </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">buku</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kuliah kuliah</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Boris Asenovich Novikov </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;">,</font></a><font style="vertical-align: inherit;"> "Fundamentals of Database Technologies".</font></font><br></blockquote><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tingkat isolasi apa yang harus saya gunakan? </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Level isolasi Read Committed digunakan secara default di PostgreSQL, dan tampaknya level ini digunakan di sebagian besar aplikasi. Akan lebih mudah jika terjadi pemutusan transaksi hanya jika terjadi kegagalan, tetapi tidak untuk mencegah ketidakkonsistenan. Dengan kata lain, kesalahan serialisasi tidak dapat terjadi.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sisi lain dari koin adalah banyaknya kemungkinan anomali yang telah dibahas secara rinci di atas. Pengembang harus selalu mengingat dan menulis kode sedemikian rupa untuk mencegah terjadinya. Jika tidak mungkin untuk merumuskan tindakan yang diperlukan dalam satu pernyataan SQL, Anda harus menggunakan kunci pengaturan secara eksplisit. Hal yang paling tidak menyenangkan adalah kode sulit untuk menguji kesalahan yang terkait dengan memperoleh data yang tidak konsisten, dan kesalahan itu sendiri dapat terjadi dengan cara yang tidak dapat diprediksi dan tidak dapat diproduksi ulang sehingga sulit untuk diperbaiki.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tingkat isolasi dari Repeatable Read menghilangkan beberapa masalah ketidakkonsistenan, tetapi, sayangnya, tidak semua. Oleh karena itu, Anda tidak hanya harus mengingat anomali yang tersisa, tetapi juga memodifikasi aplikasi sehingga memproses kesalahan serialisasi dengan benar. Ini, tentu saja, tidak nyaman. Tetapi untuk transaksi read-only, level ini secara sempurna melengkapi Read Committed dan sangat nyaman, misalnya, untuk membuat laporan yang menggunakan beberapa query SQL.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Akhirnya, tingkat Serializable menghilangkan perlunya inkonsistensi sama sekali, membuat penulisan kode jauh lebih mudah. </font><font style="vertical-align: inherit;">Satu-satunya hal yang diperlukan dari aplikasi adalah untuk dapat mengulangi transaksi ketika menerima kesalahan serialisasi. </font><font style="vertical-align: inherit;">Tetapi proporsi transaksi yang terputus, overhead tambahan, dan ketidakmampuan untuk memaralelkan permintaan dapat secara signifikan mengurangi throughput sistem. </font><font style="vertical-align: inherit;">Perhatikan juga bahwa level Serializable tidak berlaku pada replika, dan bahwa level tersebut tidak dapat dicampur dengan level isolasi lainnya. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk dilanjutkan</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id442804/">https://habr.com/ru/post/id442804/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id442790/index.html">Pendaftaran terbuka untuk Allure Server Meetup di St. Petersburg</a></li>
<li><a href="../id442794/index.html">Kami mengundang Anda ke konferensi "(TI) arsitek dalam proyek dan organisasi TI"</a></li>
<li><a href="../id442796/index.html">Survei: Teknologi cloud dalam layanan GIS dan geodata</a></li>
<li><a href="../id442798/index.html">Memantau ping antara host Kubernetes adalah resep kami</a></li>
<li><a href="../id442800/index.html">Bot Telegram sederhana dengan Python dalam 30 menit</a></li>
<li><a href="../id442806/index.html">Program pendahuluan DUMP-2019 siap. Pembicara dari Evil Martians, Tinkoff.ru, HTML Academy, SkyEng, 2GIS</a></li>
<li><a href="../id442808/index.html">Kami mengundang Anda ke Pesta Droid - pertemuan yang membahas masalah praktis pengembangan aplikasi dan perangkat Android</a></li>
<li><a href="../id442810/index.html">Mitos Fisika Populer, melanjutkan: Gravity</a></li>
<li><a href="../id442812/index.html">"Saya tidak melihat alasan untuk menggunakan Python untuk bekerja dengan Spark, kecuali kemalasan"</a></li>
<li><a href="../id442814/index.html">10 tahun telah berlalu, dan belum ada yang tahu cara menggunakan blockchain. Dan di sini lagi?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>