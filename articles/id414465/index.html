<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ’€ â˜¢ï¸ ğŸ‘©â€âš–ï¸ Meta Crush Saga: game kompilasi-waktu ğŸ ğŸ¥ âš”ï¸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam proses pemindahan ke judul yang sudah lama ditunggu-tunggu sebagai Pemimpin Senior C ++ Over-Engineer , tahun lalu saya memutuskan untuk menulis...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Meta Crush Saga: game kompilasi-waktu</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/414465/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a5b/f40/952/a5bf40952c8280e1f9c41e965600816f.gif" alt="gambar"></div><br>  Dalam proses pemindahan ke judul yang sudah lama ditunggu-tunggu sebagai <strong>Pemimpin Senior C ++ Over-Engineer</strong> , tahun lalu saya memutuskan untuk menulis ulang permainan yang saya kembangkan selama jam kerja (Candy Crush Saga), menggunakan saripati C ++ modern (C ++ 17).  Maka lahirlah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Meta Crush Saga</a> : sebuah <strong>game yang berjalan pada tahap kompilasi</strong> .  Saya sangat terinspirasi oleh permainan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Nibbler</a> Matt Birner, yang menggunakan pemrograman murni pada templat untuk menciptakan kembali Snake yang terkenal dengan Nokia 3310. <br><br>  â€œGim seperti apa yang <strong>sedang dijalankan pada tahap kompilasi</strong> ?â€, â€œBagaimana tampilannya?â€, â€œFungsi apa dari <strong>C ++ 17 yang</strong> Anda gunakan dalam proyek ini?â€, â€œApa yang Anda pelajari?â€  - Pertanyaan serupa mungkin muncul di benak Anda.  Untuk menjawabnya, Anda harus membaca seluruh posting, atau memasang kemalasan batin Anda dan menonton versi video dari posting - laporan saya dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">acara Meetup</a> di Stockholm: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/XV1lXtB3sqg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Catatan: demi kesehatan mental Anda dan karena <em>kesalahan manusia</em> , beberapa fakta alternatif diberikan dalam artikel ini. <br><a name="habracut"></a><br><h2>  Gim yang berjalan pada waktu kompilasi? </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/61c/1ab/166/61c1ab166775d7f49e32620b72abb6e4.png"></div><br>  Saya pikir untuk memahami apa yang saya maksudkan dengan "konsep" sebuah <strong>game yang dieksekusi pada tahap kompilasi</strong> , Anda perlu membandingkan siklus hidup dari game semacam itu dengan siklus hidup dari game biasa. <br><br><h3>  Siklus hidup dari game reguler: </h3><br>  Sebagai pengembang reguler game dengan kehidupan normal, bekerja pada pekerjaan reguler dengan tingkat kesehatan mental normal, Anda biasanya memulai dengan menulis <strong>logika game</strong> dalam bahasa favorit Anda (dalam C ++, tentu saja!), Dan kemudian jalankan <strong>kompiler</strong> untuk mengonversi ini, terlalu sering seperti spaghetti logika dalam <strong>file yang dapat dieksekusi</strong> .  Setelah mengklik dua kali pada <strong>file yang dapat dieksekusi</strong> (atau mulai dari konsol), sistem operasi memunculkan <strong>proses</strong> .  <strong>Proses</strong> ini akan mengeksekusi <strong>logika game</strong> , yang terdiri dari <strong>siklus game</strong> dalam 99,42% dari waktu.  <strong>Siklus permainan</strong> <strong>memperbarui</strong> keadaan permainan sesuai dengan aturan dan <strong>input pengguna</strong> tertentu, <strong>menjadikan</strong> status permainan yang dihitung dalam piksel, lagi, lagi, dan lagi, dan lagi. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7bc/e6c/3b2/7bce6c3b238299f98b6c16e339aa5b10.png"></div><br><h3>  Siklus hidup sebuah game berjalan selama proses kompilasi: </h3><br>  Sebagai seorang insinyur berlebihan yang menciptakan game kompilasi keren barunya, Anda masih menggunakan bahasa favorit Anda (masih C ++, tentu saja!) Untuk menulis <strong>logika game</strong> .  Kemudian, seperti sebelumnya, <strong>fase kompilasi</strong> berjalan, tetapi ada twist plot: Anda <strong>menjalankan</strong> <strong>logika game</strong> Anda pada tahap kompilasi.  Anda dapat menyebutnya "eksekusi" (kompilasi).  Dan di sini C ++ sangat berguna;  ia memiliki fitur-fitur seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Template Meta Programming (TMP)</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">constexpr</a> yang memungkinkan Anda untuk melakukan <strong>perhitungan</strong> dalam <strong>fase kompilasi</strong> .  Nanti kita akan mempertimbangkan fungsionalitas yang bisa digunakan untuk ini.  Karena pada tahap ini kami menjalankan <strong>logika</strong> permainan, maka pada saat ini kami juga perlu memasukkan <strong>input pemain</strong> .  Jelas, kompiler kami masih akan membuat <strong>file yang dapat dieksekusi</strong> pada output.  Untuk apa itu digunakan?  File yang dapat dieksekusi tidak lagi berisi <strong>loop game</strong> , tetapi memiliki misi yang sangat sederhana: menampilkan <strong>status terhitung</strong> baru.  Mari kita sebut <strong>file yang dapat dieksekusi</strong> ini <strong>renderer</strong> , dan <strong>data yang</strong> <strong>dihasilkannya dibuat</strong> .  Dalam <strong>rendering</strong> kami <strong>,</strong> efek partikel yang indah atau bayangan oklusi tidak akan terkandung, itu akan menjadi ASCII.  <strong>Render</strong> ASCII <strong>dari</strong> <strong>keadaan</strong> terhitung baru adalah properti yang nyaman yang dapat dengan mudah ditunjukkan kepada pemain, tetapi selain itu, kami menyalinnya ke file teks.  Mengapa file teks?  Jelas, karena entah bagaimana dapat dikombinasikan dengan <strong>kode</strong> dan melakukan kembali semua langkah sebelumnya, sehingga memperoleh satu <strong>loop</strong> . <br><br>  Seperti yang sudah Anda pahami, permainan yang <strong>dijalankan selama proses kompilasi</strong> terdiri dari <strong>siklus permainan</strong> di mana setiap <strong>frame</strong> permainan adalah <strong>tahap kompilasi</strong> .  Setiap <strong>tahap kompilasi</strong> menghitung <strong>keadaan</strong> baru <strong>dari</strong> game, yang dapat ditampilkan kepada pemain dan dimasukkan ke <strong>frame</strong> / <strong>tahap kompilasi berikutnya</strong> . <br><br>  Anda dapat merenungkan diagram luar biasa ini sebanyak yang Anda suka hingga Anda memahami apa yang baru saja saya tulis: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/95c/2b8/d88/95c2b8d88aa04173139e82f9b4410cd9.png"></div><br>  Sebelum kita masuk ke detail penerapan siklus seperti itu, saya yakin Anda ingin menanyakan satu-satunya pertanyaan ... <br><br><h3>  "Kenapa repot-repot melakukan ini?" </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/695/1db/ec8/6951dbec8feeb002a132f801ea6866ed.png"></div><br>  Apakah Anda benar-benar berpikir bahwa menghancurkan idap metaprogramming C ++ saya adalah pertanyaan mendasar?  Ya, tanpa hasil dalam hidup! <br><br><ul><li>  Hal pertama dan terpenting adalah <strong>bahwa permainan yang dieksekusi pada tahap kompilasi</strong> akan memiliki kecepatan waktu eksekusi yang luar biasa, karena sebagian besar perhitungan dilakukan dalam <strong>fase kompilasi</strong> .  Kecepatan runtime adalah kunci keberhasilan game AAA kami dengan grafis ASCII! </li><li>  Anda mengurangi kemungkinan bahwa beberapa crustacea akan muncul di repositori Anda dan meminta Anda untuk menulis ulang game di <strong>Rust</strong> .  Pidato yang dipersiapkan dengan baik akan berantakan segera setelah Anda menjelaskan kepadanya bahwa pointer tidak valid tidak ada pada waktu kompilasi.  Programmer <strong>Haskell yang</strong> percaya diri bahkan dapat mengonfirmasi <strong>keamanan ketik</strong> dalam kode Anda. </li><li>  Anda akan mendapatkan rasa hormat dari kerajaan hipster <strong>Javascript</strong> , di mana kerangka kerja yang dirancang ulang dengan sindrom NIH yang kuat dapat memerintah, asalkan muncul dengan nama keren. </li><li>  Seorang teman saya dulu mengatakan bahwa setiap baris kode Perl dapat digunakan secara de facto sebagai kata sandi yang sangat kuat.  Saya yakin dia tidak pernah mencoba membuat kata sandi dari <strong>waktu kompilasi C ++</strong> . </li></ul><br>  Bagaimana?  Apakah Anda puas dengan jawaban saya?  Maka mungkin pertanyaan Anda seharusnya: "Bagaimana Anda bisa melakukan ini?" <br><br>  Sebenarnya, saya benar-benar ingin bereksperimen dengan fungsi yang ditambahkan dalam <strong>C ++ 17</strong> .  Cukup banyak fitur yang dimaksudkan di dalamnya untuk meningkatkan efektivitas bahasa, serta untuk metaprogramming (terutama constexpr).  Saya berpikir bahwa alih-alih menulis contoh kode kecil akan jauh lebih menarik untuk mengubah semua ini menjadi permainan.  Proyek peliharaan adalah cara yang bagus untuk mempelajari konsep yang tidak sering Anda gunakan dalam pekerjaan Anda.  Kemampuan untuk mengeksekusi logika game dasar pada waktu kompilasi kembali membuktikan bahwa template dan constepxr adalah subset <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lengkap Turing</a> dari bahasa C ++. <br><br><h2>  Ulasan Game Meta Crush Saga </h2><br><h3>  Game pertandingan-3: </h3><br>  <strong>Meta Crush Saga</strong> adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">gim ubin yang bergabung dengan game yang</a> mirip dengan <strong>Bejeweled</strong> dan <strong>Candy Crush Saga</strong> .  Inti dari aturan permainan adalah menghubungkan tiga ubin dengan pola yang sama untuk mendapatkan poin.  Berikut ini sekilas <strong>kondisi permainan</strong> yang saya â€œbuangâ€ (dumping di ASCII sangat mudah didapat): <br><br><pre>  R "(
     Meta crush saga      
 ------------------------  
 |  | 
 |  RBGBBYGR | 
 |  | 
 |  | 
 |  YYGRBGBR | 
 |  | 
 |  | 
 |  RBYRGRYG | 
 |  | 
 |  | 
 |  RYBY (R) YGY | 
 |  | 
 |  | 
 |  BGYRYGGR | 
 |  | 
 |  | 
 |  RYBGYBBG | 
 |  | 
 ------------------------  
 &gt; skor: 9009
 &gt; Bergerak: 27
 ) " </pre><br><br>  Gameplay dari game Match-3 ini sendiri tidak terlalu menarik, tetapi bagaimana dengan arsitektur yang semuanya bekerja?  Agar Anda dapat memahaminya, saya akan mencoba menjelaskan setiap bagian dari siklus hidup game <strong>kompilasi</strong> ini dalam hal kode. <br><br><h3>  Injeksi status permainan: </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/942/20f/ffa/94220fffabe5eca432d47b90491fe7e7.png"></div><br>  Jika Anda seorang pencinta atau pedant C ++ yang bersemangat, Anda mungkin telah memperhatikan bahwa dump kondisi permainan sebelumnya dimulai dengan pola berikut: <strong>R "(</strong> . Sebenarnya, ini adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">string string C ++ 11 mentah</a> , artinya saya tidak perlu melarikan diri dari karakter khusus, misalnya, <strong>terjemahan string</strong> : Literal string baku disimpan dalam file yang disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">current_state.txt</a> . <br><br>  Bagaimana cara kami menyuntikkan kondisi gim saat ini ke dalam kondisi kompilasi?  Mari kita tambahkan saja ke loop input! <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// loop_inputs.hpp constexpr KeyboardInput keyboard_input = KeyboardInput::KEYBOARD_INPUT; //       constexpr auto get_game_state_string = []() constexpr { auto game_state_string = constexpr_string( //       #include "current_state.txt" ); return game_state_string; };</span></span></code> </pre> <br>  Apakah itu file <em>.txt</em> atau file <em>.h</em> , arahan <strong>sertakan</strong> dari preproses C akan bekerja dengan cara yang sama: menyalin konten file ke lokasi.  Di sini saya menyalin string string literal dari status permainan di ascii ke variabel yang disebut <strong>game_state_string</strong> . <br><br>  Perhatikan bahwa <a href="">file</a> header <a href="">loop_inputs.hpp</a> juga memperluas input keyboard ke langkah frame / kompilasi saat ini.  Berbeda dengan keadaan gim, keadaan papan ketik cukup kecil dan dapat dengan mudah diperoleh sebagai definisi preprosesor. <br><br><h3>  Menghitung status baru pada waktu kompilasi: </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b1a/adb/e44/b1aadbe44035019fdc8bdb89a02b31b1.png"></div><br>  Sekarang kami telah mengumpulkan cukup data, kami dapat menghitung status baru.  Akhirnya, kami telah mencapai titik di mana kami perlu menulis file <a href="">main.cpp</a> : <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// main.cpp #include "loop_inputs.hpp" //   ,   . // :    . constexpr auto current_state = parse_game_state(get_game_state_string); //      . constexpr auto new_state = game_engine(current_state) //    , .update(keyboard_input); //  ,    . constexpr auto array = print_game_state(new_state); //      std::array&lt;char&gt;. // :    . //  :   . for (const char&amp; c : array) { std::cout &lt;&lt; c; }</span></span></code> </pre> <br>  Aneh, tetapi kode C ++ ini tidak terlihat membingungkan mengingat fungsinya.  Sebagian besar kode dieksekusi dalam fase kompilasi, namun, mengikuti paradigma OOP tradisional dan pemrograman prosedural.  Hanya baris terakhir - rendering - yang menjadi penghalang untuk melakukan perhitungan sepenuhnya pada waktu kompilasi.  Seperti yang akan kita lihat di bawah ini, melempar sedikit constexpr di tempat yang tepat, kita bisa mendapatkan pemrograman yang cukup elegan di C ++ 17.  Saya menemukan kebebasan yang menyenangkan yang diberikan C ++ kepada kami saat melakukan eksekusi campuran saat runtime dan kompilasi. <br><br>  Anda juga akan melihat bahwa kode ini hanya mengeksekusi satu frame, tidak ada <strong>loop game</strong> .  Mari kita selesaikan masalah ini! <br><br><h3>  Kami merekatkan semuanya: </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8d0/c65/870/8d0c65870264bfff26fde91c230bb8db.png"></div><br>  Jika Anda menjijikkan trik saya dengan <strong>C ++</strong> , maka saya harap Anda tidak keberatan melihat keterampilan <strong>Bash</strong> saya.  Faktanya, <strong>loop game</strong> saya tidak lebih dari <a href="">script bash</a> yang terus-menerus dikompilasi. <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#  !  ,    !!! while; do : #      G++ g++ -o renderer main.cpp -DKEYBOARD_INPUT="$keypressed" keypressed=get_key_pressed() #  . clear #   current_state=$(./renderer) echo $current_state #    #     current_state.txt file       . echo "R\"(" &gt; current_state.txt echo $current_state &gt;&gt; current_state.txt echo ")\"" &gt;&gt; current_state.txt done</span></span></code> </pre> <br>  Sebenarnya, saya agak kesulitan mendapatkan input keyboard dari konsol.  Awalnya, saya ingin mendapatkan paralel dengan kompilasi.  Setelah banyak percobaan dan kesalahan, saya berhasil mendapatkan sesuatu yang kurang lebih bekerja dengan perintah <code>read</code> dari <strong>Bash</strong> .  Saya tidak pernah berani melawan <strong>Bash</strong> penyihir dalam duel - bahasa ini terlalu menyeramkan! <br><br>  Jadi, saya harus mengakui bahwa untuk mengelola siklus permainan saya harus menggunakan bahasa lain.  Meskipun secara teknis tidak ada yang menghalangi saya untuk menulis bagian kode ini dalam C ++.  Selain itu, ini tidak meniadakan fakta bahwa 90% dari logika permainan saya dieksekusi di dalam tim kompilasi <strong>g ++</strong> , yang sangat menakjubkan! <br><br><h3>  Sebuah gameplay kecil untuk membuat mata Anda beristirahat: </h3><br>  Sekarang setelah Anda mengalami siksaan untuk menjelaskan arsitektur gim, waktunya telah tiba untuk lukisan yang menarik: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a5b/f40/952/a5bf40952c8280e1f9c41e965600816f.gif"></div><br>  Gif pixelated ini adalah catatan tentang bagaimana saya memainkan <strong>Meta Crush Saga</strong> .  Seperti yang Anda lihat, permainan berjalan cukup lancar untuk dapat dimainkan secara real time.  Jelas, dia tidak begitu menarik sehingga saya bisa mengalirkan Twitch dan menjadi Pewdiepie baru, tetapi dia berhasil! <br><br>  Salah satu aspek menyenangkan menyimpan <strong>keadaan permainan</strong> dalam file <em>.txt</em> adalah kemampuan untuk menipu atau menguji kasus-kasus ekstrem dengan sangat mudah. <br><br>  Sekarang saya telah secara singkat memperkenalkan Anda pada arsitektur, kami akan mempelajari fungsionalitas C ++ 17 yang digunakan dalam proyek ini.  Saya tidak akan mempertimbangkan logika game secara terperinci, karena mengacu secara eksklusif pada Match-3, tetapi sebaliknya saya akan berbicara tentang aspek C ++ yang dapat diterapkan dalam proyek lain. <br><br><h2>  Tutorial saya tentang C ++ 17: </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c3f/325/d96/c3f325d9618c2a89dadb2873c61a7921.png"></div><br>  Tidak seperti C ++ 14, yang sebagian besar berisi perbaikan kecil, standar C ++ 17 yang baru bisa memberi kita banyak hal.  Ada harapan bahwa akhirnya fitur yang telah lama ditunggu-tunggu (modul, coroutine, konsep ...) akhirnya akan muncul, tetapi ... secara umum ... mereka tidak muncul;  itu membuat marah banyak dari kita.  Tetapi setelah menghilangkan duka, kami menemukan banyak harta tak terduga kecil yang jatuh ke standar. <br><br>  Saya berani mengatakan bahwa anak-anak yang suka metaprogramming terlalu manja tahun ini!  Pisahkan perubahan kecil dan tambahan pada bahasa sekarang memungkinkan Anda untuk menulis kode yang sangat berfungsi pada waktu kompilasi dan setelahnya, pada saat run time. <br><br><h3>  Constepxr di semua bidang: </h3><br>  Seperti yang diprediksi oleh Ben Dean dan Jason Turner dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">laporan</a> mereka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tentang C ++ 14</a> , C ++ memungkinkan Anda untuk dengan cepat meningkatkan kompilasi nilai pada waktu kompilasi dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">constexpr</a> kata kunci mahakuasa.  Dengan menempatkan kata kunci ini di tempat yang tepat, Anda dapat memberi tahu kompiler bahwa ekspresi itu konstan dan <strong>dapat</strong> dievaluasi langsung pada waktu kompilasi.  Di <strong>C ++ 11,</strong> kita sudah bisa menulis kode ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">factorial</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">//    constexpr       . { return n &lt;= 1? 1 : (n * factorial(n - 1)); } int i = factorial(5); //  constexpr-. //      : // int i = 120;</span></span></span></span></code> </pre> <br>  Meskipun kata kunci <strong>constexpr</strong> sangat kuat, ia memiliki beberapa batasan penggunaan, membuatnya sulit untuk menulis kode ekspresif dengan cara ini. <br><br>  <strong>C ++ 14 telah</strong> sangat mengurangi persyaratan untuk <strong>constexpr</strong> dan telah menjadi jauh lebih alami untuk digunakan.  Fungsi faktorial kami sebelumnya dapat ditulis ulang sebagai berikut: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">factorial</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n * factorial(n - <span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre> <br>  <strong>C ++ 14</strong> menyingkirkan aturan bahwa <strong>fungsi constexpr</strong> harus terdiri dari hanya satu pernyataan kembali, yang memaksa kita untuk menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">operator ternary</a> sebagai blok pembangun utama.  Sekarang <strong>C ++ 17</strong> membawa lebih banyak aplikasi kata kunci <strong>constexpr</strong> yang dapat kita jelajahi! <br><br><h4>  Bercabang pada waktu kompilasi: </h4><br>  Apakah Anda pernah berada dalam situasi di mana Anda perlu mendapatkan perilaku yang berbeda tergantung pada parameter template yang Anda manipulasi?  Misalkan kita memerlukan <code>serialize</code> function, yang akan memanggil <code>.serialize()</code> jika objek menyediakannya, jika tidak maka akan terpaksa memanggil <code>to_string</code> untuk itu.  Seperti dijelaskan lebih rinci dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">posting</a> ini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tentang SFINAE</a> , kemungkinan besar Anda harus menulis kode alien seperti itu: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-keyword"><span class="hljs-keyword">enable_if_t</span></span>&lt;has_serialize_v&lt;T&gt;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; serialize(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T&amp; obj) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> obj.serialize(); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-keyword"><span class="hljs-keyword">enable_if_t</span></span>&lt;!has_serialize_v&lt;T&gt;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; serialize(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T&amp; obj) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::to_string(obj); }</code> </pre> <br>  Hanya dalam mimpi Anda dapat menulis ulang <strong>trik</strong> jelek ini <strong>dari trik SFINAE</strong> menjadi <strong>C ++ 14</strong> menjadi kode yang luar biasa: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// has_serialize -  constexpr-,  serialize  . // .    SFINAE,  ,    . template &lt;class T&gt; constexpr bool has_serialize(const T&amp; /*t*/); template &lt;class T&gt; std::string serialize(const T&amp; obj) { //  ,  constexpr    . if (has_serialize(obj)) { return obj.serialize(); } else { return std::to_string(obj); } }</span></span></code> </pre> <br>  Sayangnya, ketika Anda bangun dan mulai menulis <strong>kode C ++ 14 yang asli</strong> , kompiler Anda memuntahkan pesan yang tidak menyenangkan tentang pemanggilan <code>serialize(42);</code>  .  Ini menjelaskan bahwa objek bertipe <code>int</code> tidak memiliki fungsi anggota <code>serialize()</code> .  Tidak peduli bagaimana itu membuat Anda marah, kompilernya benar!  Dengan kode ini, ia akan selalu mencoba untuk mengkompilasi kedua cabang - <code>return obj.serialize();</code>  dan <br> <code>return std::to_string(obj);</code>  .  Untuk <code>return obj.serialize();</code> cabang <code>return obj.serialize();</code>  Mungkin berubah menjadi semacam kode mati, karena <code>has_serialize(obj)</code> akan selalu mengembalikan <code>false</code> , tetapi kompiler masih harus mengkompilasinya. <br><br>  Seperti yang mungkin Anda tebak, <strong>C ++ 17</strong> menyelamatkan kami dari situasi yang tidak menyenangkan, karena memungkinkan untuk menambahkan <strong>constexpr</strong> setelah pernyataan if untuk "memaksa" bercabang pada waktu kompilasi dan membuang konstruksi yang tidak digunakan: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// has_serialize... // ... template &lt;class T&gt; std::string serialize(const T&amp; obj) if constexpr (has_serialize(obj)) { //     constexpr   'if'. return obj.serialize(); //    ,    ,  obj  int. } else { return std::to_string(obj);branch } }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6de/ae3/4d8/6deae34d807b14eb8ac178647abce09d.png"></div><br>  Jelas, ini adalah peningkatan besar <strong>atas trik SFINAE yang</strong> harus kami terapkan sebelumnya.  Setelah itu, kami mulai mendapatkan kecanduan yang sama dengan Ben dan Jason - kami mulai menggunakan <strong>constexpr di</strong> mana-mana dan selalu.  Sayangnya, ada tempat lain di mana kata kunci <strong>constexpr</strong> cocok, tetapi belum digunakan: <strong>parameter constexpr</strong> . <br><br><h4>  Parameter constexpr: </h4><br>  Jika Anda berhati-hati, Anda mungkin melihat pola aneh pada contoh kode sebelumnya.  Saya berbicara tentang input loop: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// loop_inputs.hpp constexpr auto get_game_state_string = []() constexpr // ? { auto game_state_string = constexpr_string( //       #include "current_state.txt" ); return game_state_string; };</span></span></code> </pre> <br>  Mengapa variabel <strong>game_state_string</strong> dienkapsulasi dalam lambda constexpr?  Kenapa dia tidak menjadikannya <strong>variabel global constexpr</strong> ? <br><br>  Saya ingin meneruskan variabel ini dan isinya ke beberapa fungsi.  Misalnya, <strong>Anda</strong> harus meneruskannya ke <strong>parse_board</strong> saya dan menggunakannya dalam beberapa ekspresi konstan: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_board_size</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* game_state_string)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_board</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* game_state_string)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt;GemType, parse_board_size(game_state_string)&gt; board{}; <span class="hljs-comment"><span class="hljs-comment">// ^ 'game_state_string' -   - // ... } parse_board(â€œ...something...â€);</span></span></code> </pre> <br>  Jika kita menggunakan cara ini, kompiler grouchy akan mengeluh bahwa parameter <strong>game_state_string</strong> bukan ekspresi konstan.  Ketika saya membuat array ubin saya, saya perlu langsung menghitung kapasitas tetapnya (kita tidak bisa menggunakan vektor pada waktu kompilasi karena mereka membutuhkan alokasi memori) dan meneruskannya sebagai argumen ke template nilai di <strong>std :: array</strong> .  Oleh karena itu, <strong>ekspresi parse_board_size (game_state_string)</strong> harus berupa ekspresi konstan.  Meskipun <strong>parse_board_size</strong> secara eksplisit ditandai sebagai <strong>constexpr</strong> , <strong>game_state_string</strong> tidak dan tidak bisa!  Dalam hal ini, dua aturan mengganggu kami: <br><br><ul><li>  Argumen fungsi constexpr bukanlah constexpr! </li><li>  Dan kami tidak dapat menambahkan constexpr di depannya! </li></ul><br>  Semua ini bermuara pada fakta bahwa <strong>fungsi constexpr</strong> HARUS berlaku dalam komputasi waktu runtime dan kompilasi.  Dengan asumsi adanya <strong>parameter constexpr</strong> , ini tidak akan memungkinkan mereka untuk digunakan pada saat run time. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/02f/9a7/1be/02f9a71be0409a96415fd5b4a542e70d.jpg"></div><br>  Untungnya, ada cara untuk meratakan masalah ini.  Alih-alih menerima nilai sebagai parameter fungsi biasa, kita dapat merangkum nilai ini menjadi tipe dan meneruskan tipe ini sebagai parameter templat: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GameStringType</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">auto</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">parse_board</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GameStringType</span></span></span><span class="hljs-class">&amp;&amp;) {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt;CellType, parse_board_size(GameStringType::value())&gt; board{}; <span class="hljs-comment"><span class="hljs-comment">// ... } struct GameString { static constexpr auto value() { return "...something..."; } }; parse_board(GameString{});</span></span></code> </pre> <br>  Dalam contoh kode ini, saya membuat tipe struktural GameString yang memiliki <strong>nilai</strong> constexpr fungsi anggota statis <strong>()</strong> yang mengembalikan string literal yang ingin saya sampaikan ke <strong>parse_board</strong> .  Di <strong>parse_board,</strong> saya mendapatkan tipe ini melalui <strong>parameter</strong> template <strong>GameStringType</strong> , menggunakan aturan untuk mengekstraksi argumen template.  Memiliki <strong>GameStringType</strong> , karena fakta bahwa <strong>value ()</strong> adalah constexpr, saya cukup memanggil nilai fungsi anggota statis <strong>()</strong> pada waktu yang tepat untuk mendapatkan string literal bahkan di tempat-tempat di mana ekspresi konstan diperlukan. <br><br>  Kami berhasil merangkum literal untuk entah bagaimana meneruskannya ke <strong>parse_board</strong> menggunakan constexpr.  Namun, sangat menjengkelkan untuk perlu mendefinisikan tipe baru setiap kali Anda perlu mengirim <strong>parse_board</strong> literal baru: "... something1 ...", "... something2 ...".  Untuk mengatasi masalah ini di <strong>C ++ 11</strong> , Anda bisa menerapkan beberapa pengalamatan makro dan tidak langsung yang buruk menggunakan penyatuan anonim dan lambda.  Michael Park menjelaskan topik ini dengan baik di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">salah satu postingnya</a> . <br><br>  Di <strong>C ++ 17,</strong> situasinya bahkan lebih baik.  Jika kami mencantumkan persyaratan untuk melewatkan string literal kami, kami mendapatkan yang berikut: <br><br><ul><li>  Fungsi yang dihasilkan </li><li>  Itu adalah constexpr </li><li>  Dengan nama yang unik atau anonim </li></ul><br>  Persyaratan ini harus memberi Anda petunjuk.  Yang kita butuhkan adalah <strong>constexpr lambda</strong> !  Dan di <strong>C ++ 17, mereka</strong> secara alami menambahkan kemampuan untuk menggunakan <strong>kata kunci constexpr</strong> untuk fungsi lambda.  Kami dapat menulis ulang kode sampel kami sebagai berikut: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LambdaType</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">auto</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">parse_board</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LambdaType</span></span></span><span class="hljs-class">&amp;&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">get_game_state_string</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt;CellType, parse_board_size(get_game_state_string())&gt; board{}; <span class="hljs-comment"><span class="hljs-comment">// ^      constexpr-. } parse_board([]() constexpr -&gt; { return â€œ...something...â€; }); // ^    constexpr.</span></span></code> </pre> <br>  Percayalah, ini sudah terlihat jauh lebih nyaman daripada peretasan sebelumnya di <strong>C ++ 11</strong> menggunakan makro.  Saya menemukan trik yang luar biasa ini berkat <strong>Bjorn Fahler</strong> , anggota grup mitok C ++ yang saya ikuti.  Baca lebih lanjut tentang trik ini di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">blog</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">nya</a> .  Perlu juga dipertimbangkan bahwa sebenarnya kata kunci <strong>constexpr</strong> adalah opsional dalam hal ini: semua <strong>lambdas</strong> dengan kemampuan untuk menjadi <strong>constexpr</strong> akan menjadi mereka secara default.  Menambahkan <strong>constexpr</strong> secara eksplisit adalah tanda tangan yang menyederhanakan pemecahan masalah kami. <br><br>  Sekarang Anda harus mengerti mengapa saya terpaksa menggunakan lambda <strong>constexpr</strong> untuk menurunkan string yang mewakili kondisi permainan.  Lihatlah fungsi lambda ini dan Anda akan memiliki pertanyaan lain lagi.  Apa tipe <strong>constexpr_string</strong> ini yang juga saya gunakan untuk membungkus stock literal? <br><br><h5>  constexpr_string dan constexpr_string_view: </h5><br>  Ketika bekerja dengan string, Anda seharusnya tidak memprosesnya dalam gaya C. Anda harus melupakan semua algoritma yang menjengkelkan ini yang melakukan iterasi mentah dan memeriksa nol penyelesaian!  Alternatif yang ditawarkan oleh <strong>C ++</strong> adalah <strong>algoritma</strong> <strong>stn :: string</strong> dan <strong>STL yang</strong> mahakuasa.  Sayangnya, <strong>std :: string</strong> mungkin memerlukan alokasi memori pada heap (bahkan dengan Optimasi String Kecil) untuk menyimpan kontennya.  Satu atau dua standar kembali, kita bisa menggunakan <strong>constexpr baru / menghapus</strong> atau kita bisa melewati <strong>pengalokasi constexpr</strong> ke <strong>std :: string</strong> , tetapi sekarang kita perlu menemukan solusi lain. <br><br>  Pendekatan saya adalah menulis kelas <strong>constexpr_string</strong> dengan kapasitas tetap.  Kapasitas ini diteruskan sebagai parameter ke templat nilai.  Berikut ini gambaran singkat kelas saya: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> N&gt; <span class="hljs-comment"><span class="hljs-comment">// N -    . class constexpr_string { private: std::array&lt;char, N&gt; data_; //  N char   -. std::size_t size_; //   . public: constexpr constexpr_string(const char(&amp;a)[N]): data_{}, size_(N -1) { //   data_ } // ... constexpr iterator begin() { return data_; } //    . constexpr iterator end() { return data_ + size_; } //     . // ... };</span></span></code> </pre> <br>  Kelas <a href="">constexpr_string</a> saya berusaha untuk meniru antarmuka <strong>std :: string</strong> sedekat mungkin (untuk operasi yang saya butuhkan): kita dapat meminta <strong>iterator dari awal dan akhir</strong> , mendapatkan <strong>ukuran (ukuran)</strong> , mengakses <strong>data (data)</strong> , mengakses bagian <strong>data (data)</strong> , <strong>menghapus (menghapus)</strong> bagian dari mereka, dapatkan substring menggunakan substring dan sebagainya.  Ini <strong>membuatnya</strong> sangat mudah untuk mengkonversi sepotong kode dari <strong>std :: string</strong> ke <strong>constexpr_string</strong> .  Anda mungkin bertanya-tanya apa yang terjadi ketika kita perlu menggunakan operasi yang biasanya memerlukan sorotan di <strong>std :: string</strong> .  Dalam kasus seperti itu, saya dipaksa untuk mengubahnya menjadi <strong>operasi</strong> yang <strong>tidak</strong> dapat <strong>diubah</strong> yang membuat instance baru dari <strong>constexpr_string</strong> . <br><br>  Mari kita lihat operasi <strong>append</strong> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> N&gt; <span class="hljs-comment"><span class="hljs-comment">// N -    . class constexpr_string { // ... template &lt;std::size_t M&gt; // M -    . constexpr auto append(const constexpr_string&lt;M&gt;&amp; other) { constexpr_string&lt;N + M&gt; output(*this, size() + other.size()); // ^    . ^     output. for (std::size_t i = 0; i &lt; other.size(); ++i) { output[size() + i] = other[i]; ^     output. } return output; } // ... };</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/481/745/1d0/4817451d03f8a4214afad8896e71b2b3.jpg"></div><br>  Anda tidak perlu memiliki hadiah Fields untuk mengasumsikan bahwa jika kita memiliki string ukuran <strong>N</strong> dan string ukuran <strong>M</strong> , maka string ukuran <strong>N + M</strong> akan cukup untuk menyimpan penggabungan mereka.  Kami mungkin membuang-buang bagian dari "repositori kompilasi-waktu", karena kedua lini mungkin tidak menggunakan seluruh kapasitas, tetapi ini adalah harga yang agak kecil untuk kenyamanan.  Jelas, saya juga menulis duplikat <strong>std :: string_view</strong> , yang disebut <a href="">constexpr_string_view</a> . <br><br>  Dengan dua kelas ini, saya siap untuk menulis kode elegan untuk menguraikan <strong>kondisi permainan</strong> saya.  Pikirkan sesuatu seperti ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> game_state = constexpr_string(â€œ...something...â€); <span class="hljs-comment"><span class="hljs-comment">//          : constexpr auto blue_gem = find_if(game_state.begin(), game_state.end(), [](char c) constexpr -&gt; { return c == 'B'; } );</span></span></code> </pre> <br>  Cukup mudah untuk beralih di sekitar permata di lapangan bermain - omong-omong, apakah Anda melihat fitur berharga lain dari <strong>C ++ 17</strong> dalam contoh kode ini? <br><br>  Ya!  Saya tidak harus secara eksplisit menentukan kapasitas <strong>constexpr_string</strong> ketika membangunnya.  Sebelumnya, ketika menggunakan <strong>templat kelas</strong> , kami harus menunjukkan argumennya secara eksplisit.  Untuk menghindari rasa sakit ini, kami membuat fungsi <em>make_xxx</em> karena parameter <strong>templat fungsi</strong> dapat dilacak.  Lihat bagaimana <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pelacakan argumen templat kelas</a> mengubah kehidupan kami menjadi lebih baik: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> N&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr_string</span></span></span><span class="hljs-class"> {</span></span> constexpr_string(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>(&amp;a)[N]) {} <span class="hljs-comment"><span class="hljs-comment">// .. }; // ****  C++17 **** template &lt;int N&gt; constexpr_string&lt;N&gt; make_constexpr_string(const char(&amp;a)[N]) { //      N ^   return constexpr_string&lt;N&gt;(a); // ^    . } auto test2 = make_constexpr_string("blablabla"); // ^      . constexpr_string&lt;7&gt; test("blabla"); // ^      ,    . // ****  C++17 **** constexpr_string test("blabla"); // ^    ,  .</span></span></code> </pre> <br>  Dalam beberapa situasi sulit, Anda perlu membantu kompilator untuk menghitung argumen dengan benar.  Jika Anda mengalami masalah seperti itu, maka pelajari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">manual untuk perhitungan argumen yang ditentukan pengguna</a> . <br><br><h4>  Makanan gratis dari STL: </h4><br>  Ya, kita selalu bisa menulis ulang semuanya sendiri.  Tapi mungkin anggota komite telah dengan murah hati menyiapkan sesuatu untuk kita di perpustakaan standar? <br><br><h5>  Jenis pembantu baru: </h5><br>  Dalam <strong>C ++ 17</strong> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">std :: varian</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">std :: opsional</a> ditambahkan ke jenis kamus standar, berdasarkan pada <strong>constexpr</strong> .  Yang pertama sangat menarik karena memungkinkan kita untuk mengekspresikan asosiasi tipe-aman, tetapi implementasi di <strong>libstdc ++ library</strong> dengan <strong>GCC 7.2</strong> memiliki masalah ketika menggunakan ekspresi konstan.  Oleh karena itu, saya meninggalkan ide untuk menambahkan <strong>std :: varian</strong> ke kode saya dan hanya menggunakan <strong>std :: opsional</strong> . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dengan tipe </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T,</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tipe </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: opsional</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> memungkinkan kita membuat tipe baru </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: opsional &lt;T&gt;</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , yang dapat berisi nilai tipe </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> atau tidak sama sekali. Ini sangat mirip dengan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tipe yang bermakna yang memungkinkan nilai yang tidak ditentukan</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dalam </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C #</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Mari kita lihat fungsi </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">find_in_board</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , yang mengembalikan posisi elemen pertama pada bidang yang mengkonfirmasi predikat sudah benar. Mungkin tidak ada elemen seperti itu di lapangan. Untuk menangani situasi ini, jenis posisi harus opsional:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Predicate</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:optional&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt; find_in_board(GameBoard&amp;&amp; g, Predicate&amp;&amp; p) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> item : g.items()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p(item)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {item.x, item.y}; } <span class="hljs-comment"><span class="hljs-comment">//   ,     . } return std::nullopt; //      . } auto item = find_in_board(g, [](const auto&amp; item) { return true; }); if (item) { // ,   optional. do_something(*item); //    optional, ""   *. /* ... */ }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sebelumnya, kami harus menggunakan </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">semantik pointer</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , atau menambahkan "keadaan kosong" langsung ke jenis posisi, atau mengembalikan boolean dan mengambil </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">parameter output</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Memang, itu cukup aneh! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beberapa tipe yang sudah ada sebelumnya juga menerima dukungan </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">constexpr</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tuple</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pair</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Saya tidak akan menjelaskan secara rinci penggunaannya, karena banyak yang telah ditulis tentang mereka, tetapi saya akan membagikan salah satu kekecewaan saya. Panitia menambahkan </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gula sintaksis</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ke </font><font style="vertical-align: inherit;">standar </font><font style="vertical-align: inherit;">untuk mengekstraksi nilai yang terkandung dalam </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tuple</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> atau </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pasangan</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Deklarasi jenis baru ini disebut </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pengikat terstruktur</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, menggunakan tanda kurung untuk menentukan variabel mana untuk menyimpan perpecahan </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tuple</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> atau </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pasangan</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; foo() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-number"><span class="hljs-number">42</span></span>, <span class="hljs-number"><span class="hljs-number">1337</span></span>}; } <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> [x, y] = foo(); <span class="hljs-comment"><span class="hljs-comment">// x = 42, y = 1337.</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sangat pintar! </font><font style="vertical-align: inherit;">Tetapi sangat disayangkan bahwa anggota komite [tidak bisa, tidak mau, tidak menemukan waktu, lupa] untuk membuat mereka ramah kepada </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">constexpr</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Saya mengharapkan sesuatu seperti ini:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> [x, y] = foo(); <span class="hljs-comment"><span class="hljs-comment">// OR auto [x, y] constexpr = foo();</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sekarang kita memiliki wadah dan jenis penolong yang rumit, tetapi bagaimana kita bisa memanipulasinya? </font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Algoritma: </font></font></h5><br><font style="vertical-align: inherit;"></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Memutakhirkan</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wadah untuk memproses </font><strong><font style="vertical-align: inherit;">constexpr</font></strong><font style="vertical-align: inherit;"> adalah tugas yang cukup monoton. </font><font style="vertical-align: inherit;">Dibandingkan dengan itu, porting </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">constexpr</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ke </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">algoritma non- </font></font></strong><font style="vertical-align: inherit;"><strong><font style="vertical-align: inherit;">modifikasi</font></strong><font style="vertical-align: inherit;"> tampaknya cukup sederhana. </font><font style="vertical-align: inherit;">Tetapi agak aneh bahwa di </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ 17</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kami tidak melihat kemajuan di area ini, hanya akan muncul di </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ 20</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Sebagai contoh, algoritma </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: find yang</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> indah </font><font style="vertical-align: inherit;">tidak menerima tanda tangan </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">constexpr</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tapi jangan takut! </font><font style="vertical-align: inherit;">Seperti yang dijelaskan Ben dan Jason, Anda dapat dengan mudah mengubah algoritme menjadi </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">constexpr</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dengan hanya menyalin implementasi saat ini (tetapi jangan lupa tentang hak cipta); </font><font style="vertical-align: inherit;">Preferensi baik. </font><font style="vertical-align: inherit;">Saudara-saudara, saya hadir untuk perhatian Anda</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">constexpr std :: find</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InputIt</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InputIt</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">find</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InputIt</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">first</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InputIt</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">last</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">value</span></span></span><span class="hljs-class">) // ^ !!!    </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class">. {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; first != last; ++first) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (*first == value) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> first; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> last; } <span class="hljs-comment"><span class="hljs-comment">//  http://en.cppreference.com/w/cpp/algorithm/find</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya sudah bisa mendengar dari tribun jeritan penggemar optimasi! </font><font style="vertical-align: inherit;">Ya, hanya menambahkan </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">constexpr</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> di depan kode sampel yang disediakan oleh </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cppreference</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mungkin tidak memberi kami </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kecepatan</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ideal </font><strong><font style="vertical-align: inherit;">saat runtime</font></strong><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Tetapi jika kita harus meningkatkan algoritma ini, itu akan diperlukan untuk </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kecepatan pada waktu kompilasi</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Sejauh yang saya tahu, dalam hal kecepatan </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kompilasi</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , solusi sederhana adalah yang terbaik.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kecepatan dan bug: </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pengembang game AAA mana pun harus berinvestasi dalam memecahkan masalah ini, bukan? </font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kecepatan: </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ketika saya berhasil membuat versi setengah kerja dari </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meta Crush Saga</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , pekerjaan menjadi lebih lancar. Bahkan, saya berhasil mencapai sedikit lebih dari </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3 FPS</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (frame per detik) pada laptop lama saya dengan overclock i5 menjadi 1,80 GHz (frekuensi penting dalam kasus ini). Seperti dalam proyek apa pun, saya segera menyadari bahwa kode yang ditulis sebelumnya menjijikkan, dan mulai menulis ulang penguraian keadaan permainan menggunakan </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">constexpr_string</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan algoritma standar. Meskipun ini membuat kode jauh lebih nyaman untuk dipelihara, perubahan tersebut sangat memengaruhi kecepatan; langit-langit baru adalah </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,5 FPS</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meskipun pepatah lama tentang C ++, "abstraksi nol-kepala" tidak berlaku untuk </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">perhitungan waktu kompilasi</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ini cukup logis jika kita menganggap kompiler sebagai penerjemah dari beberapa "kode waktu kompilasi". </font><font style="vertical-align: inherit;">Perbaikan untuk berbagai kompiler masih dimungkinkan, tetapi ada juga peluang pertumbuhan bagi kami, penulis kode tersebut. </font><font style="vertical-align: inherit;">Berikut adalah daftar pengamatan dan tip yang tidak lengkap yang saya temukan, mungkin khusus untuk GCC:</font></font><br><br><ul><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Array C</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bekerja jauh lebih baik daripada </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: array</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: array</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adalah sedikit kosmetik C ++ modern di atas </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">array gaya-C</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan Anda harus membayar harga untuk menggunakannya dalam kondisi seperti itu.</font></font></li><li>  ,  <strong> </strong>   (   )     <strong>  </strong> .  ,   ,          ,    .    :  ,         ,     ,    ,   (  )      ,        . </li><li>      ,      .        ,        . </li><li>         .            GCC.  ,     Â«Â». </li></ul><br><h4> : </h4><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/78c/000/4e9/78c0004e91d753a658fa8190626c3be9.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Banyak kali kompiler saya memuntahkan kesalahan kompilasi yang mengerikan, dan logika kode saya menderita. Tetapi bagaimana cara menemukan tempat di mana bug itu bersembunyi? Tanpa </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">debugger</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">printf,</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> segalanya menjadi lebih rumit. Jika "jenggot seorang programmer" metaforis Anda belum berkembang dengan sendirinya (baik metaforis dan jenggot saya yang sebenarnya masih jauh dari harapan ini), maka Anda mungkin tidak memiliki motivasi untuk menggunakan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">templight</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> atau untuk men-debug kompiler. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Teman pertama kita adalah </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">static_assert</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , yang memberi kita kesempatan untuk memeriksa nilai boolean waktu kompilasi. Teman kedua kami akan menjadi makro yang </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memungkinkan</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan menonaktifkan </font><strong><font style="vertical-align: inherit;">constexpr</font></strong><font style="vertical-align: inherit;"> sedapat mungkin:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CONSTEXPR constexpr </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//      //  #define CONSTEXPR //    </span></span></span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dengan makro ini, kita bisa membuat logika berfungsi saat runtime, yang berarti kita bisa melampirkan debugger ke dalamnya. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Meta Crush Saga II - berjuang untuk gameplay sepenuhnya saat runtime: </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jelas, </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meta Crush Saga</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tidak akan memenangkan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Game Awards</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tahun ini </font><font style="vertical-align: inherit;">. Ini memiliki potensi besar, tetapi gameplaynya tidak sepenuhnya dieksekusi </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pada waktu kompilasi</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Ini dapat mengganggu gamer hardcore ... Saya tidak dapat menyingkirkan skrip bash kecuali seseorang menambahkan </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">input keyboard</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan logika tidak bersih dalam fase kompilasi (dan ini adalah kegilaan yang terus terang!). Tetapi saya percaya bahwa suatu hari saya akan dapat sepenuhnya meninggalkan file yang dapat dieksekusi </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">renderer</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan menampilkan </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kondisi permainan</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pada </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">waktu kompilasi</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/661/efc/26d/661efc26dbb41f0b8800916058993a56.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Orang gila dengan alias </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">saarraz </font></font></strong> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memperpanjang GCC</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> untuk menambahkan konstruksi </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">static_print</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ke bahasa </font><font style="vertical-align: inherit;">. Konstruk ini harus mengambil beberapa ekspresi konstan atau string literal dan mengeluarkannya pada tahap kompilasi. Saya akan senang jika alat seperti itu ditambahkan ke standar, atau setidaknya extended </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">static_assert</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sehingga </font><strong><font style="vertical-align: inherit;">menerima</font></strong><font style="vertical-align: inherit;"> ekspresi konstan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Namun, dalam </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ 17,</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mungkin ada cara untuk mencapai hasil ini. Compiler sudah menghasilkan dua hal - </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kesalahan</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">peringatan</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ! Jika kita bisa mengelola atau mengubah </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">peringatan</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sesuai kebutuhan kita, kita sudah akan menerima kesimpulan yang layak. Saya mencoba beberapa solusi, khususnya</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">atribut usang</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>... words&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">useless</span></span></span><span class="hljs-class"> {</span></span> [[deprecated]] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-comment"><span class="hljs-comment">// Will trigger a warning. }; template &lt;char... words&gt; void output_as_warning() { useless&lt;words...&gt;().call(); } output_as_warning&lt;'a', 'b', 'c'&gt;(); // warning: 'void useless&lt;words&gt;::call() [with char ...words = {'a', 'b', 'c'}]' is deprecated // [-Wdeprecated-declarations]</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meskipun outputnya jelas ada dan dapat diurai, sayangnya, kode tidak dapat dimainkan! </font><font style="vertical-align: inherit;">Jika, secara kebetulan, Anda adalah anggota masyarakat rahasia programmer C ++ yang dapat melakukan output selama kompilasi, maka saya akan dengan senang hati mempekerjakan Anda di tim saya untuk menciptakan </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meta Crush Saga II yang sempurna</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> !</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kesimpulan: </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya akhirnya menjual Anda </font><font style="vertical-align: inherit;">permainan </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">scam</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> saya </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Saya harap Anda menemukan posting ini penasaran dan mempelajari sesuatu yang baru dalam proses membacanya. </font><font style="vertical-align: inherit;">Jika Anda menemukan kesalahan atau cara untuk meningkatkan artikel, maka hubungi saya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya ingin berterima kasih kepada </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tim SwedenCpp</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> karena </font><strong><font style="vertical-align: inherit;">mengizinkan</font></strong><font style="vertical-align: inherit;"> saya melakukan laporan proyek saya di salah satu acara mereka. </font><font style="vertical-align: inherit;">Selain itu, saya ingin mengucapkan terima kasih yang </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mendalam</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kepada </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;">Alexander Gurdeev</font></a><font style="vertical-align: inherit;"> , yang membantu saya meningkatkan aspek-aspek penting dari </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meta Crush Saga</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id414465/">https://habr.com/ru/post/id414465/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id414451/index.html">"Kalender Tester" untuk bulan Juni. Penguji harus menangkap bug, membaca Caner dan mengatur gerakan.</a></li>
<li><a href="../id414453/index.html">Menerapkan Path Finder untuk Agen AI dengan NavMesh</a></li>
<li><a href="../id414455/index.html">Algoritma Generasi Palet Warna</a></li>
<li><a href="../id414459/index.html">Detektor dan deskriptor poin tunggal CEPAT, SINGKAT, ORB</a></li>
<li><a href="../id414463/index.html">AI sendiri belajar cara membangun Rubik's Cube</a></li>
<li><a href="../id414467/index.html">Makalah dari Minsk C ++ Conference CoreHard Spring 2018</a></li>
<li><a href="../id414469/index.html">Minggu Keamanan 22: Dua Kunci Cerdas Kedua</a></li>
<li><a href="../id414471/index.html">11 lingkaran neraka bagi mereka yang tidak memiliki pengalaman dalam pekerjaan baru</a></li>
<li><a href="../id414473/index.html">Ninja DVR: Ulasan Neoline G-Tech X27 Dual</a></li>
<li><a href="../id414475/index.html">â€œPengguna akhir - kami bersama Andaâ€: â€‹â€‹tentang pengembangan Android di CFT</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>