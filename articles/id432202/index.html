<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕤 🕗 📐 Menghasilkan jenis karakter dengan cepat (atau gila dengan Rust) 😄 ✋🏿 👨🏿‍🤝‍👨🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pada artikel ini, kita akan mengolok-olok bahasa pemrograman Rust, dan khususnya, objek sifat. 


 Ketika saya berkenalan dengan Rust, salah satu deta...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Menghasilkan jenis karakter dengan cepat (atau gila dengan Rust)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/432202/"><p>  Pada artikel ini, kita akan mengolok-olok bahasa pemrograman Rust, dan khususnya, objek sifat. </p><br><p>  Ketika saya berkenalan dengan Rust, salah satu detail implementasi objek tipe tampak menarik bagi saya.  Yaitu, tabel fungsi virtual tidak dalam data itu sendiri, tetapi di pointer "tebal" untuk itu.  Setiap pointer ke objek tipe) berisi pointer ke data itu sendiri, serta tautan ke tabel virtual di mana alamat fungsi yang mengimplementasikan objek tipe ini untuk struktur tertentu akan ditempatkan (tetapi karena ini adalah detail implementasi, perilaku dapat berubah. </p><a name="habracut"></a><br><p>  Mari kita mulai dengan contoh sederhana yang menunjukkan pointer tebal.  Kode berikut akan ditampilkan pada arsitektur 64-bit 8 dan 16: </p><br><pre><code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-function"> </span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> v: &amp;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span> = &amp;<span class="hljs-string"><span class="hljs-string">"hello"</span></span>.into(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> disp: &amp;std::fmt::Display = v; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"  : {}"</span></span>, std::mem::size_of_val(&amp;v)); <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"   -: {}"</span></span>, std::mem::size_of_val(&amp;disp)); }</code> </pre> <br><p>  Mengapa ini menarik?  Ketika saya terlibat dalam perusahaan Java, salah satu tugas yang cukup sering muncul adalah adaptasi objek yang ada untuk diberikan antarmuka.  Yaitu, objek sudah ada, dikeluarkan sebagai tautan, tetapi harus disesuaikan dengan antarmuka yang ditentukan.  Dan Anda tidak dapat mengubah objek input, itu adalah apa adanya. </p><br><p>  Saya harus melakukan sesuatu seperti ini: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">Person </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">adapt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Json value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ...- , , ,  "value"  //   Person return new PersonJsonAdapter(value); }</span></span></code> </pre> <br><p>  Ada berbagai masalah dengan pendekatan ini.  Misalnya, jika objek yang sama "beradaptasi" dua kali, maka kita mendapatkan dua <code>Person</code> berbeda (dari sudut pandang perbandingan tautan).  Dan fakta bahwa Anda harus membuat objek baru setiap kali entah bagaimana jelek. </p><br><p>  Ketika saya melihat objek ketik di Rust, saya punya ide bahwa di Rust itu bisa dilakukan jauh lebih elegan!  Anda juga dapat mengambil dan menetapkan tabel virtual lain ke data dan mendapatkan objek sifat baru!  Dan jangan mengalokasikan memori untuk setiap instance.  Pada saat yang sama, seluruh logika "pinjaman" tetap ada - fungsi adaptasi kami akan terlihat seperti sesuatu seperti <code>fn adapt&lt;'a&gt;(value: &amp;'a Json) -&gt; &amp;'a Person</code> (yaitu, kami semacam meminjam dari sumber data). </p><br><p>  Bahkan lebih dari itu, Anda dapat "memaksa" jenis yang sama (misalnya, <code>String</code> ) untuk mengimplementasikan objek jenis kami beberapa kali, dengan perilaku yang berbeda.  Mengapa  Tetapi Anda tidak pernah tahu apa yang mungkin diperlukan dalam perusahaan ?! </p><br><p>  Mari kita coba implementasikan ini. </p><br><h2 id="postanovka-zadachi">  Pernyataan masalah </h2><br><p>  Kami menetapkan tugas dengan cara ini: membuat fungsi <code>annotate</code> , yang "menetapkan" objek tipe berikut ke tipe <code>String</code> biasa: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Object</span></span></span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">type_name</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">as_string</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; &amp;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>; }</code> </pre> <br><p>  Dan fungsi <code>annotate</code> itu sendiri: </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">///    - `Object`,   , ///   "" -- ,    `type_name`. fn annotate&lt;'a&gt;(input: &amp;'a String, type_name: &amp;str) -&gt; &amp;'a dyn Object { // ... }</span></span></code> </pre> <br><p>  Mari kita menulis ujian segera.  Pertama, pastikan bahwa tipe "yang ditugaskan" cocok dengan yang diharapkan.  Kedua, kami akan memastikan bahwa kami bisa mendapatkan baris asli dan itu akan menjadi baris yang sama (dari sudut pandang pointer): </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[test]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> input: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> = <span class="hljs-string"><span class="hljs-string">"hello"</span></span>.into(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> annotated1 = annotate(&amp;input, <span class="hljs-string"><span class="hljs-string">"Widget"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> annotated2 = annotate(&amp;input, <span class="hljs-string"><span class="hljs-string">"Gadget"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// -   ,    assert_eq!("Widget", annotated1.type_name()); assert_eq!("Gadget", annotated2.type_name()); let unwrapped1 = annotated1.as_string(); let unwrapped2 = annotated2.as_string(); //       --   assert_eq!(unwrapped1 as *const String, &amp;input as *const String); assert_eq!(unwrapped2 as *const String, &amp;input as *const String); }</span></span></code> </pre> <br><h2 id="podhod-1-a-posle-nas-hot-potop">  Pendekatan nomor 1: dan setelah kita setidaknya banjir! </h2><br><p>  Pertama, mari kita coba untuk membuat implementasi yang sepenuhnya naif.  Hanya bungkus data kami dalam "pembungkus", yang juga akan mengandung <code>type_name</code> : </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Wrapper</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt; { value: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, type_name: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt; Object <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Wrapper&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">type_name</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span> { &amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.type_name } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">as_string</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; &amp;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.value } }</code> </pre> <br><p>  Belum ada yang istimewa.  Semuanya seperti di Jawa.  Tetapi kami tidak memiliki pemulung, di mana kami akan menyimpan bungkus ini?  Kita perlu mengembalikan tautan, agar tetap valid setelah memanggil fungsi <code>annotate</code> .  Kami akan memasukkan sesuatu yang menakutkan ke dalam <code>Box</code> sehingga <code>Wrapper</code> disorot di heap.  Dan kemudian kita akan mengembalikan tautannya.  Dan agar pembungkus tetap hidup setelah memanggil fungsi <code>annotate</code> , kita akan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"membocorkan"</a> kotak ini: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">annotate</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;(input: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, type_name: &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) -&gt; &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> dyn Object { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> b = <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::new(Wrapper { value: input, type_name: type_name.into(), }); <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::leak(b) }</code> </pre> <br><p>  ... dan tes berlalu! </p><br><p>  Tapi ini beberapa keputusan yang meragukan.  Kita tidak hanya mengalokasikan memori dengan setiap "anotasi", sehingga memori bocor ( <code>Box::leak</code> mengembalikan tautan ke data yang disimpan di heap, tetapi pada saat yang sama "melupakan" kotak itu sendiri, yaitu, tidak akan ada rilis otomatis ) </p><br><h2 id="podhod-2-arena">  Pendekatan 2: Arena! </h2><br><p>  Untuk mulai dengan, mari kita coba untuk menyimpan pembungkus ini di suatu tempat sehingga mereka tetap dirilis di beberapa titik.  Tetapi pada saat yang sama mempertahankan tanda tangan yang <code>annotate</code> seperti itu.  Artinya, mengembalikan tautan dengan penghitungan referensi (misalnya, <code>Rc&lt;Wrapper&gt;</code> ) tidak berfungsi. </p><br><p>  Pilihan paling sederhana adalah membuat struktur tambahan, "sistem tipe", yang akan bertanggung jawab untuk menyimpan pembungkus ini.  Dan ketika kita selesai, kita akan melepaskan struktur ini dan semua pembungkusnya. </p><br><p>  Sesuatu seperti itu.  Perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>typed-arena</code></a> digunakan untuk menyimpan pembungkus, tetapi Anda bisa bertahan dengan jenis <code>Vec&lt;Box&lt;Wrapper&gt;&gt;</code> , yang utama adalah untuk memastikan bahwa <code>Wrapper</code> tidak bergerak di mana pun (di malam hari Karat Anda dapat menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pin API</a> untuk ini): </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TypeSystem</span></span></span></span> { wrappers: typed_arena::Arena&lt;Wrapper&gt;, } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> TypeSystem { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span></span>() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span> { wrappers: typed_arena::Arena::new(), } } <span class="hljs-comment"><span class="hljs-comment">///     `input`,      , ///    (  ,    , ///        )! pub fn annotate&lt;'a: 'b, 'b&gt;( &amp;'a self, input: &amp;'b String, type_name: &amp;str ) -&gt; &amp;'b dyn Object { self.wrappers.alloc(Wrapper { value: input, type_name: type_name.into(), }) } }</span></span></code> </pre> <br><p>  Tetapi ke mana parameter yang bertanggung jawab untuk masa pakai tautan untuk tipe <code>Wrapper</code> pergi?  Kami harus menyingkirkannya, karena kami tidak dapat mengaitkan masa hidup tetap dalam jenis <code>typed_arena::Arena&lt;Wrapper&lt;'?&gt;&gt;</code> .  Setiap bungkus memiliki parameter unik, tergantung pada <code>input</code> ! </p><br><p>  Sebagai gantinya, kami menaburkan sedikit Rust yang tidak aman untuk menyingkirkan parameter seumur hidup: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Wrapper</span></span></span></span> { value: *<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, type_name: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Object <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Wrapper { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">type_name</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span> { &amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.type_name } <span class="hljs-comment"><span class="hljs-comment">///   -- ,     (  /// `annotate`),     (    - /// `&amp;Object`)  ,      (`String`). fn as_string(&amp;self) -&gt; &amp;String { unsafe { &amp;*self.value } } }</span></span></code> </pre> <br><p>  Dan tes-tes itu berlalu lagi, dengan demikian memberi kita kepercayaan akan kebenaran keputusan.  Selain merasa tidak nyaman dengan yang <code>unsafe</code> (sebagaimana mestinya, lebih baik tidak bercanda dengan Rust yang tidak aman!). </p><br><p>  Namun, bagaimana dengan opsi yang dijanjikan, yang tidak membutuhkan alokasi memori tambahan untuk pembungkus? </p><br><h2 id="podhod-3-da-razverznutsya-vrata-ada">  Pendekatan # 3: Biarkan Gerbang Neraka Terbuka </h2><br><p>  Ide  Untuk setiap "tipe" ("Widget", "Gadget") yang unik, kami akan membuat tabel virtual.  Tangan selama pelaksanaan program.  Dan kami menempatkannya pada tautan yang diberikan kepada kami oleh data itu sendiri (yang, seingat kami, hanyalah <code>String</code> ). </p><br><p>  Pertama, deskripsi singkat tentang apa yang perlu kita dapatkan.  Jadi, referensi ke objek tipe, bagaimana cara mengaturnya?  Sebenarnya, ini hanya dua pointer, satu ke data itu sendiri, dan yang lainnya ke tabel virtual.  Jadi kami menulis: </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[repr(C)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TraitObject</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> data: *<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> (), <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> vtable: *<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> (), }</code> </pre> <br><p>  ( <code>#[repr(C)]</code> kita perlu menjamin lokasi yang benar dalam memori). </p><br><p>  Tampaknya semuanya sederhana, kami akan menghasilkan tabel baru untuk parameter yang diberikan dan "mengumpulkan" tautan ke objek tipe!  Tapi apa yang terdiri dari tabel ini? </p><br><p>  Jawaban yang benar untuk pertanyaan ini adalah "ini adalah detail implementasi."  Tetapi kami akan melakukannya;  buat file <code>rust-toolchain</code> di root proyek kami dan tulis di sana: <code>nightly-2018-12-01</code> .  Lagi pula, perakitan tetap dapat dianggap stabil, bukan? </p><br><p>  Sekarang kita telah memperbaiki versi Rust (pada kenyataannya, kita akan memerlukan perakitan malam untuk salah satu perpustakaan di bawah). </p><br><p>  Setelah beberapa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pencarian di Internet</a> , kami menemukan bahwa format tabelnya sederhana: pertama ada tautan ke destruktor, kemudian dua bidang yang terkait dengan alokasi memori (jenis ukuran dan perataan), dan kemudian fungsi berjalan satu demi satu (urutannya ada pada kebijaksanaan kompiler, tetapi kami memiliki hanya dua fungsi, jadi kemungkinan tebakannya cukup tinggi, 50%). </p><br><p>  Jadi kami menulis: </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[repr(C)]</span></span> <span class="hljs-meta"><span class="hljs-meta">#[derive(Clone, Copy)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VirtualTableHeader</span></span></span></span> { destructor_fn: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span></span>(*<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> ()), size: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, align: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, } <span class="hljs-meta"><span class="hljs-meta">#[repr(C)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ObjectVirtualTable</span></span></span></span> { header: VirtualTableHeader, type_name_fn: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span></span>(*<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>) -&gt; *<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">str</span></span>, as_string_fn: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span></span>(*<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>) -&gt; *<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, }</code> </pre> <br><p>  Demikian pula, <code>#[repr(C)]</code> diperlukan untuk menjamin lokasi yang benar dalam memori.  Saya dibagi menjadi dua struktur, sedikit kemudian akan bermanfaat bagi kita. </p><br><p>  Sekarang mari kita coba menulis sistem tipe kita, yang akan menyediakan fungsi <code>annotate</code> .  Kita perlu melakukan cache tabel yang dihasilkan, jadi mari kita cache: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TypeInfo</span></span></span></span> { vtable: ObjectVirtualTable, } <span class="hljs-meta"><span class="hljs-meta">#[derive(Default)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TypeSystem</span></span></span></span> { infos: RefCell&lt;HashMap&lt;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, TypeInfo&gt;&gt;, }</code> </pre> <br><p>  Kami menggunakan keadaan internal <code>RefCell</code> sehingga fungsi <code>TypeSystem::annotate</code> dapat menerima <code>&amp;self</code> sebagai tautan bersama.  Ini penting, karena kita "meminjam" dari <code>TypeSystem</code> untuk memastikan bahwa tabel virtual yang kita hasilkan hidup lebih lama daripada referensi ke objek tipe yang kita kembalikan dari <code>annotate</code> . </p><br><p>  Karena kami ingin dapat memberi anotasi pada banyak contoh, kami tidak dapat meminjam <code>&amp;mut self</code> sebagai tautan yang dapat diubah. </p><br><p>  Dan kami akan membuat sketsa kode ini: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> TypeSystem { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">annotate</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>: <span class="hljs-symbol"><span class="hljs-symbol">'b</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">'b</span></span>&gt;( &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, input: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'b</span></span> <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, type_name: &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span> ) -&gt; &amp;<span class="hljs-symbol"><span class="hljs-symbol">'b</span></span> dyn Object { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> type_name = type_name.to_string(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> infos = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.infos.borrow_mut(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> imp = infos.entry(type_name).or_insert_with(|| <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { <span class="hljs-comment"><span class="hljs-comment">//    ,  ? let vtable = unimplemented!(); TypeInfo { vtable } }); let object_obj = TraitObject { data: input as *const String as *const (), vtable: &amp;imp.vtable as *const ObjectVirtualTable as *const (), }; //       - unsafe { std::mem::transmute::&lt;TraitObject, &amp;dyn Object&gt;(object_obj) } } }</span></span></code> </pre> <br><p>  Dari mana kita mendapatkan tabel ini?  Tiga entri pertama di dalamnya akan cocok dengan entri untuk tabel virtual lainnya untuk jenis yang ditentukan.  Karena itu, ambil dan salin saja.  Pertama, mari kita dapatkan tipe ini: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Whatever</span></span></span></span> {} <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;T&gt; Whatever <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> T {}</code> </pre> <br><p>  Berguna bagi kita untuk mendapatkan "tabel virtual lainnya" ini.  Dan kemudian, kami menyalin tiga entri ini darinya: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> whatever = input <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> &amp;dyn Whatever; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> whatever_obj = std::mem::transmute::&lt;&amp;dyn Whatever, TraitObject&gt;(whatever); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> whatever_vtable_header = whatever_obj.vtable <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> VirtualTableHeader; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> vtable = ObjectVirtualTable { <span class="hljs-comment"><span class="hljs-comment">//  ! header: *whatever_vtable_header, type_name_fn: unimplemented!(), as_string_fn: unimplemented!(), }; TypeInfo { vtable }</span></span></code> </pre> <br><p>  Pada dasarnya, kita bisa mendapatkan ukuran dan perataan melalui <code>std::mem::size_of::&lt;String&gt;()</code> dan <code>std::mem::align_of::&lt;String&gt;()</code> .  Tapi dari mana lagi destruktor itu bisa "dicuri", saya tidak tahu. </p><br><p>  Ok, tapi dari mana kita mendapatkan alamat fungsi-fungsi ini, <code>as_string_fn</code> dan <code>as_string_fn</code> ?  Anda mungkin memperhatikan bahwa <code>as_string_fn</code> umumnya tidak diperlukan, penunjuk data selalu berjalan sebagai catatan pertama dalam representasi objek tipe.  Artinya, fungsi ini selalu sama: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Object <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ... fn as_string(&amp;self) -&gt; String { self } }</span></span></code> </pre> <br><p>  Tetapi dengan fungsi kedua itu tidak mudah!  Itu juga tergantung pada nama kami "type", <code>type_name</code> . </p><br><p>  Tidak masalah, kami hanya dapat menghasilkan fungsi ini di runtime.  Mari kita ambil perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>dynasm</code></a> untuk ini (saat ini, membutuhkan pembangunan malam Rust).  Baca tentang <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">konvensi fungsi panggilan</a> . </p><br><p>  Untuk kesederhanaan, anggaplah kita hanya tertarik pada Mac OS dan Linux (setelah semua transformasi yang menyenangkan ini, kompatibilitas tidak lagi mengganggu kita, bukan?).  Dan, ya, secara eksklusif x86-64, tentu saja. </p><br><p>  Fungsi kedua, <code>as_string</code> , mudah diimplementasikan.  Kami berjanji bahwa parameter pertama akan ada di register <code>RDI</code> .  Dan kembalikan nilainya ke <code>RAX</code> .  Artinya, kode fungsinya akan seperti: </p><br><pre> <code class="rust hljs">dynasm!(ops ; mov rax, rdi ; ret );</code> </pre> <br><p>  Tetapi fungsi pertama agak rumit.  Pertama, kita perlu mengembalikan <code>&amp;str</code> , yang merupakan pointer tebal.  Bagian pertama adalah pointer ke string, dan bagian kedua adalah panjang slice string.  Untungnya, konvensi di atas memungkinkan Anda mengembalikan hasil 128-bit menggunakan register <code>EDX</code> untuk bagian kedua. </p><br><p>  Masih ada tempat untuk mendapatkan tautan ke string slice yang berisi string <code>type_name</code> .  Kami tidak ingin bergantung pada <code>type_name</code> (meskipun melalui anotasi seumur hidup kami dapat menjamin bahwa <code>type_name</code> akan hidup lebih lama dari nilai yang dikembalikan). </p><br><p>  Tapi kami memiliki salinan dari baris ini, yang kami taruh di tabel hash.  Melintasi jari kami, kami akan membuat asumsi bahwa lokasi slice string yang <code>String::as_str</code> tidak akan <code>String::as_str</code> tidak berubah dari memindahkan <code>String</code> (dan <code>String</code> akan dipindahkan dalam proses mengubah ukuran <code>HashMap</code> mana string ini disimpan oleh kunci).  Saya tidak tahu apakah perpustakaan standar menjamin perilaku ini, tetapi apakah kami hanya memainkannya dengan mudah? </p><br><p>  Kami mendapatkan komponen yang diperlukan: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> type_name_ptr = type_name.as_str().as_ptr(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> type_name_len = type_name.as_str().len();</code> </pre> <br><p>  Dan tulis fungsi ini: </p><br><pre> <code class="rust hljs">dynasm!(ops ; mov rax, QWORD type_name_ptr <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">i64</span></span> ; mov rdx, QWORD type_name_len <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">i64</span></span> ; ret );</code> </pre> <br><p>  Dan akhirnya, kode <code>annotate</code> akhir: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">annotate</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>: <span class="hljs-symbol"><span class="hljs-symbol">'b</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">'b</span></span>&gt;(&amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, input: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'b</span></span> <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, type_name: &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) -&gt; &amp;<span class="hljs-symbol"><span class="hljs-symbol">'b</span></span> Object { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> type_name = type_name.to_string(); <span class="hljs-comment"><span class="hljs-comment">//       let type_name_ptr = type_name.as_str().as_ptr(); let type_name_len = type_name.as_str().len(); let mut infos = self.infos.borrow_mut(); let imp = infos.entry(type_name).or_insert_with(|| unsafe { let mut ops = dynasmrt::x64::Assembler::new().unwrap(); //     `type_name` let type_name_offset = ops.offset(); dynasm!(ops ; mov rax, QWORD type_name_ptr as i64 ; mov rdx, QWORD type_name_len as i64 ; ret ); //     `as_string` let as_string_offset = ops.offset(); dynasm!(ops ; mov rax, rdi ; ret ); let buffer = ops.finalize().unwrap(); //      let whatever = input as &amp;dyn Whatever; let whatever_obj = std::mem::transmute::&lt;&amp;dyn Whatever, TraitObject&gt;(whatever); let whatever_vtable_header = whatever_obj.vtable as *const VirtualTableHeader; let vtable = ObjectVirtualTable { header: *whatever_vtable_header, type_name_fn: std::mem::transmute(buffer.ptr(type_name_offset)), as_string_fn: std::mem::transmute(buffer.ptr(as_string_offset)), }; TypeInfo { vtable, buffer } }); assert_eq!(imp.vtable.header.size, std::mem::size_of::&lt;String&gt;()); assert_eq!(imp.vtable.header.align, std::mem::align_of::&lt;String&gt;()); let object_obj = TraitObject { data: input as *const String as *const (), vtable: &amp;imp.vtable as *const ObjectVirtualTable as *const (), }; unsafe { std::mem::transmute::&lt;TraitObject, &amp;dyn Object&gt;(object_obj) } }</span></span></code> </pre> <br><p>  Untuk keperluan <code>dynasm</code> kita juga perlu menambahkan bidang <code>buffer</code> ke struktur <code>TypeInfo</code> kita.  Bidang ini mengontrol memori yang menyimpan kode fungsi-fungsi kami yang dihasilkan: </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[allow(unused)]</span></span> buffer: dynasmrt::ExecutableBuffer,</code> </pre> <br><p>  Dan semua tes lulus! </p><br><h2 id="gotovo-master">  Selesai, tuan! </h2><br><p>  Jadi dengan mudah dan alami Anda dapat menghasilkan implementasi Anda sendiri dari objek tipe dalam kode Rust! </p><br><p>  Solusi terakhir secara aktif bergantung pada detail implementasi dan oleh karena itu tidak direkomendasikan untuk digunakan.  Tetapi pada kenyataannya, Anda harus melakukan apa yang harus Anda lakukan.  Masa putus asa membutuhkan tindakan putus asa! </p><br><p>  Namun, ada satu (lebih) satu fitur yang saya andalkan di sini.  Yaitu, aman untuk membebaskan memori yang ditempati secara virtual oleh tabel setelah tidak ada referensi ke objek tipe yang menggunakannya.  Di satu sisi, logis bahwa Anda dapat menggunakan tabel virtual hanya melalui referensi objek tipe.  Di sisi lain, tabel yang disediakan oleh Rust memiliki masa pakai <code>'static</code> .  Sangat mungkin untuk mengasumsikan beberapa kode yang akan memisahkan tabel dari tautan untuk beberapa tujuannya (Anda <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tidak pernah</a> tahu, misalnya, untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">beberapa trik kotornya</a> ). </p><br><p>  Kode sumber dapat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ditemukan di sini</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id432202/">https://habr.com/ru/post/id432202/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id432190/index.html">Prediksi fisika sisi klien dalam Unity</a></li>
<li><a href="../id432192/index.html">4 tanda bahwa Anda belum siap untuk mengimplementasikan solusi manajemen proyek</a></li>
<li><a href="../id432196/index.html">Tentang komposisi fungsi dalam JavaScript</a></li>
<li><a href="../id432198/index.html">Delivery Manager - Peran Baru di Dunia Agile</a></li>
<li><a href="../id432200/index.html">Bagaimana Ivan menyelidiki konversi tegakan</a></li>
<li><a href="../id432204/index.html">Seminar “20 hal kecil yang akan membuat pekerjaan di pusat data benar-benar nyaman”, 13 Desember, Moskow</a></li>
<li><a href="../id432206/index.html">Analisis terperinci tentang apa yang ditunjukkan Google di konferensi FlutterLive (dan apa artinya bagi Dart dan dunia)</a></li>
<li><a href="../id432208/index.html">Kubernetes 1.13: Tinjauan Umum Inovasi-inovasi Utama</a></li>
<li><a href="../id432210/index.html">Qualcomm memperkenalkan platform Snapdragon 855 dengan dukungan 5G</a></li>
<li><a href="../id432212/index.html">7 tahun proyek pendidikan Mail.Ru Group: berbagi pengalaman di bidang utama</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>