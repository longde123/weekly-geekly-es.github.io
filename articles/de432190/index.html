<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë∏üèª üßëüèº‚Äçü§ù‚Äçüßëüèº üèÇüèª Client-seitige Physikvorhersage in Unity üìü üôÇ ‚ôàÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="TL; DR 
 Ich habe eine Demo erstellt, die zeigt, wie die clientseitige Vorhersage der physischen Bewegung eines Spielers in Unity - GitHub implementie...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Client-seitige Physikvorhersage in Unity</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/432190/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a59/4f5/561/a594f5561a9452567464c512df8171e5.jpg" alt="Bild"></div><br><h3>  TL; DR </h3><br>  Ich habe eine Demo erstellt, die zeigt, wie die clientseitige Vorhersage der physischen Bewegung eines Spielers in Unity - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub</a> implementiert wird. <br><br><h3>  Einf√ºhrung </h3><br>  Anfang 2012 schrieb ich einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beitrag</a> √ºber die Implementierung von Prognosen auf der Client-Seite der physischen Bewegung eines Spielers in Unity.  Dank <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Physics.Simulate () wird</a> diese von mir beschriebene ungeschickte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Problemumgehung</a> nicht mehr ben√∂tigt.  Der alte Beitrag ist immer noch einer der beliebtesten in meinem Blog, aber f√ºr die moderne Einheit sind diese Informationen bereits falsch.  Daher ver√∂ffentliche ich die Version 2018. <br><br><h3>  Was ist auf der Client-Seite? </h3><br>  In wettbewerbsf√§higen Multiplayer-Spielen sollte Betrug nach M√∂glichkeit vermieden werden.  Normalerweise bedeutet dies, dass ein Netzwerkmodell mit einem autorit√§ren Server verwendet wird: Die Clients senden die eingegebenen Informationen an den Server, und der Server wandelt diese Informationen in die Bewegung eines Spielers um und sendet dann eine Momentaufnahme des Status des Spielers an den Client.  In diesem Fall gibt es eine Verz√∂gerung zwischen dem Dr√ºcken der Taste und der Anzeige des Ergebnisses, die f√ºr aktive Spiele nicht akzeptabel ist.  Die Vorhersage auf der Client-Seite ist eine sehr beliebte Technik, die die Verz√∂gerung verbirgt, die resultierende Bewegung vorhersagt und sie dem Spieler sofort anzeigt.  Wenn der Client die Ergebnisse vom Server empf√§ngt, vergleicht er sie mit den Vorhersagen des Clients. Wenn sie sich unterscheiden, war die Prognose fehlerhaft und muss korrigiert werden. <br><a name="habracut"></a><br>  Vom Server empfangene Snapshots stammen immer aus der Vergangenheit in Bezug auf den vorhergesagten Status des Clients (wenn beispielsweise die √úbertragung von Daten vom Client zum Server und zur√ºck 150 ms dauert, wird jeder Snapshot um mindestens 150 ms verz√∂gert).  Wenn der Kunde die falsche Prognose korrigieren muss, muss er daher zu diesem Punkt in der Vergangenheit zur√ºckkehren und dann alle in die L√ºcke eingegebenen Informationen reproduzieren, um zu seinem Standort zur√ºckzukehren.  Wenn die Bewegung des Spielers im Spiel auf Physik basiert, wird Physics.Simulate () ben√∂tigt, um mehrere Zyklen in einem Frame zu simulieren.  Wenn beim Bewegen des Players nur Character Controller (oder Kapselguss usw.) verwendet werden, k√∂nnen Sie auf Physics.Simulate () verzichten - und ich gehe davon aus, dass die Leistung besser ist. <br><br>  Ich werde Unity verwenden, um eine Netzwerkdemo namens <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Glenn Fiedlers</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zen of Networked Physics"</a> neu zu erstellen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">,</a> die mir seit langem Spa√ü macht.  Der Spieler hat einen physischen W√ºrfel, auf den er Kraft aus√ºben und ihn in die Szene schieben kann.  Die Demo simuliert verschiedene Netzwerkbedingungen, einschlie√ülich Verz√∂gerung und Paketverlust. <br><br><h3>  An die Arbeit gehen </h3><br>  Als erstes m√ºssen Sie die automatische Physiksimulation ausschalten.  Obwohl wir mit Physics.Simulate () dem physischen System mitteilen k√∂nnen, wann die Simulation gestartet werden soll, f√ºhrt es die Simulation standardm√§√üig automatisch basierend auf einem festen Projektzeitdelta durch.  Daher deaktivieren wir es unter <strong>Bearbeiten-&gt; Projekteinstellungen-&gt; Physik,</strong> indem wir das <strong>Kontrollk√§stchen "Automatische</strong> <strong>Simulation</strong> " deaktivieren. <br><br>  Zun√§chst erstellen wir eine einfache Einzelbenutzerimplementierung.  Die Eingabe wird abgetastet (w, a, s, d zum Bewegen und Platz zum Springen), und alles h√§ngt von den einfachen Kr√§ften ab, die mit AddForce () auf den starren K√∂rper ausge√ºbt werden. <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Logic</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameObject player; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> timer; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.timer = <span class="hljs-number"><span class="hljs-number">0.0f</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.timer += Time.deltaTime; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.timer &gt;= Time.fixedDeltaTime) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.timer -= Time.fixedDeltaTime; Inputs inputs; inputs.up = Input.GetKey(KeyCode.W); inputs.down = Input.GetKey(KeyCode.S); inputs.left = Input.GetKey(KeyCode.A); inputs.right = Input.GetKey(KeyCode.D); inputs.jump = Input.GetKey(KeyCode.Space); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.AddForcesToPlayer(player.GetComponent&lt;Rigidbody&gt;(), inputs); Physics.Simulate(Time.fixedDeltaTime); } } }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/BbC-MQX08KE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Spieler bewegen sich, w√§hrend das Netzwerk nicht verwendet wird</i> <br><br><h3>  Senden von Eingaben an den Server </h3><br>  Jetzt m√ºssen wir die Eingabe an den Server senden, der auch diesen Bewegungscode ausf√ºhrt, einen Schnappschuss des Status des Cubes erstellen und ihn an den Client zur√ºcksenden. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// client private void Update() { this.timer += Time.deltaTime; while (this.timer &gt;= Time.fixedDeltaTime) { this.timer -= Time.fixedDeltaTime; Inputs inputs = this.SampleInputs(); InputMessage input_msg; input_msg.inputs = inputs; input_msg.tick_number = this.tick_number; this.SendToServer(input_msg); this.AddForcesToPlayer(player.GetComponent&lt;Rigidbody&gt;(), inputs); Physics.Simulate(Time.fixedDeltaTime); ++this.tick_number; } }</span></span></code> </pre> <br>  Bisher nichts Besonderes hier, das einzige, worauf ich achten m√∂chte, ist das Hinzuf√ºgen der Variablen tick_number.  Wenn der Server Snapshots des Status des Cubes an den Client zur√ºcksendet, k√∂nnen wir herausfinden, welcher Takt des Clients diesem Status entspricht, damit wir diesen Status mit dem vorhergesagten Client vergleichen k√∂nnen (den wir etwas sp√§ter hinzuf√ºgen werden). <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// server private void Update() { while (this.HasAvailableInputMessages()) { InputMessage input_msg = this.GetInputMessage(); Rigidbody rigidbody = player.GetComponent&lt;Rigidbody&gt;(); this.AddForcesToPlayer(rigidbody, input_msg.inputs); Physics.Simulate(Time.fixedDeltaTime); StateMessage state_msg; state_msg.position = rigidbody.position; state_msg.rotation = rigidbody.rotation; state_msg.velocity = rigidbody.velocity; state_msg.angular_velocity = rigidbody.angularVelocity; state_msg.tick_number = input_msg.tick_number + 1; this.SendToClient(state_msg); } }</span></span></code> </pre> <br>  Alles ist einfach - der Server wartet auf Eingabenachrichten, simuliert beim Empfang einen Taktzyklus.  Dann macht er eine Momentaufnahme des resultierenden Zustands des Cubes und sendet ihn an den Client zur√ºck.  M√∂glicherweise stellen Sie fest, dass tick_number in der Statusnachricht um eins gr√∂√üer ist als tick_number in der Eingabenachricht.  Dies geschieht, weil es f√ºr mich pers√∂nlich intuitiv bequemer ist, den "Zustand des Spielers in Takt 100" als den "Zustand des Spielers zu <strong>Beginn von</strong> Takt 100" zu betrachten.  Daher erzeugt der Status des Spielers in Takt 100 in Kombination mit der Eingabe des Spielers in Takt 100 einen neuen Status f√ºr den Spieler in Takt 101. <br><br><h1>  Zustand <sub>n</sub> + Eingang <sub>n</sub> = Zustand <sub>n + 1</sub> </h1><br>  Ich sage nicht, dass Sie es genauso nehmen sollten, die Hauptsache ist die Konstanz des Ansatzes. <br><br>  Es muss auch gesagt werden, dass ich diese Nachrichten nicht √ºber einen echten Socket <em>sende</em> , sondern sie imitiere, indem ich sie in die Warteschlange schreibe und Paketverz√∂gerung und -verlust simuliere.  Die Szene enth√§lt zwei physische Cubes - einen f√ºr den Client und einen f√ºr den Server.  Beim Aktualisieren des Client-Cubes deaktiviere ich das GameObject des Server-Cubes und umgekehrt. <br><br>  Ich simuliere jedoch nicht Network Bounce und Paketzustellung in der falschen Reihenfolge, weshalb ich davon ausgehe, dass jede empfangene Eingangsnachricht neuer als die vorherige ist.  Diese Nachahmung wird ben√∂tigt, um ganz einfach "Client" und "Server" in einer Unity-Instanz auszuf√ºhren, sodass wir Server- und Client-Cubes in einer Szene kombinieren k√∂nnen. <br><br>  Sie k√∂nnen auch feststellen, dass der Server weniger Taktzyklen als der Client simuliert und daher einen anderen Status erstellt, wenn die Eingabenachricht verworfen wird und den Server nicht erreicht.  Dies ist wahr, aber selbst wenn wir diese Auslassungen simulieren w√ºrden, k√∂nnte die Eingabe immer noch falsch sein, was auch zu einem anderen Zustand f√ºhren w√ºrde.  Wir werden uns sp√§ter mit diesem Problem befassen. <br><br>  Es sollte auch hinzugef√ºgt werden, dass es in diesem Beispiel nur einen Client gibt, was die Arbeit vereinfacht.  Wenn wir mehrere Clients h√§tten, m√ºssten wir a) beim Aufrufen von Physics.Simulate () √ºberpr√ºfen, ob nur der Cube eines Spielers auf dem Server aktiviert ist, oder b) wenn der Server Eingaben von mehreren Cubes erhalten hat, alle zusammen simulieren. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/OUwWzUxZao0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Verz√∂gerung 75 ms (150 ms Hin- und R√ºckfahrt)</i> <i><br></i>  <i>0% verlorene Pakete</i> <i><br></i>  <i>Gelber W√ºrfel - Server-Spieler</i> <i><br></i>  <i>Blauer W√ºrfel - der letzte vom Client empfangene Schnappschuss</i> <br><br>  Bisher sieht alles gut aus, aber ich war ein wenig w√§hlerisch bei dem, was ich auf dem Video aufgenommen habe, um ein ziemlich ernstes Problem zu verbergen. <br><br><h3>  Bestimmungsfehler </h3><br>  Schauen Sie sich das jetzt an: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/7jbKgyUwnd4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Autsch ...</i> <br><br>  Dieses Video wurde aufgenommen, ohne Pakete zu verlieren. Die Simulationen variieren jedoch immer noch mit genau derselben Eingabe.  Ich verstehe nicht ganz, warum dies passiert - PhysX sollte ziemlich deterministisch sein, daher finde ich es auff√§llig, dass die Simulationen so oft voneinander abweichen.  Dies kann an der Tatsache liegen, dass ich GameObject-Cubes st√§ndig aktiviere und deaktiviere. Das hei√üt, es ist m√∂glich, dass das Problem bei Verwendung von zwei verschiedenen Unity-Instanzen abnimmt.  Es kann ein Fehler sein, wenn Sie es im Code auf GitHub sehen, dann lassen Sie es mich wissen. <br><br>  Wie dem auch sei, falsche Prognosen sind eine wesentliche Tatsache bei der Prognose auf Kundenseite. Lassen Sie uns also damit umgehen. <br><br><h3>  Kann ich zur√ºckspulen? </h3><br>  Der Vorgang ist recht einfach: Wenn der Kunde eine Bewegung vorhersagt, speichert er einen Statuspuffer (Position und Drehung) und eine Eingabe.  Nach dem Empfang einer Statusnachricht vom Server wird der empfangene Status mit dem vorhergesagten Status aus dem Puffer verglichen.  Wenn sie sich um einen zu gro√üen Wert unterscheiden, definieren wir den Status des Client-Cubes in der Vergangenheit neu und simulieren dann erneut alle Zwischenma√ünahmen. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// client private ClientState[] client_state_buffer = new ClientState[1024]; private Inputs[] client_input_buffer = new Inputs[1024]; private void Update() { this.timer += Time.deltaTime; while (this.timer &gt;= Time.fixedDeltaTime) { this.timer -= Time.fixedDeltaTime; Inputs inputs = this.SampleInputs(); InputMessage input_msg; input_msg.inputs = inputs; input_msg.tick_number = this.tick_number; this.SendToServer(input_msg); uint buffer_slot = this.tick_number % 1024; this.client_input_buffer[buffer_slot] = inputs; this.client_state_buffer[buffer_slot].position = rigidbody.position; this.client_state_buffer[buffer_slot].rotation = rigidbody.rotation; this.AddForcesToPlayer(player.GetComponent&lt;Rigidbody&gt;(), inputs); Physics.Simulate(Time.fixedDeltaTime); ++this.tick_number; } while (this.HasAvailableStateMessage()) { StateMessage state_msg = this.GetStateMessage(); uint buffer_slot = state_msg.tick_number % c_client_buffer_size; Vector3 position_error = state_msg.position - this.client_state_buffer[buffer_slot].position; if (position_error.sqrMagnitude &gt; 0.0000001f) { // rewind &amp; replay Rigidbody player_rigidbody = player.GetComponent&lt;Rigidbody&gt;(); player_rigidbody.position = state_msg.position; player_rigidbody.rotation = state_msg.rotation; player_rigidbody.velocity = state_msg.velocity; player_rigidbody.angularVelocity = state_msg.angular_velocity; uint rewind_tick_number = state_msg.tick_number; while (rewind_tick_number &lt; this.tick_number) { buffer_slot = rewind_tick_number % c_client_buffer_size; this.client_input_buffer[buffer_slot] = inputs; this.client_state_buffer[buffer_slot].position = player_rigidbody.position; this.client_state_buffer[buffer_slot].rotation = player_rigidbody.rotation; this.AddForcesToPlayer(player_rigidbody, inputs); Physics.Simulate(Time.fixedDeltaTime); ++rewind_tick_number; } } } }</span></span></code> </pre> <br>  Gepufferte Eingabe- und Statusdaten werden in einem sehr einfachen Umlaufpuffer gespeichert, in dem die Kennzahl als Index verwendet wird.  Und ich habe den Wert von 64 Hz f√ºr die Taktfrequenz der Physik gew√§hlt, dh ein Puffer von 1024 Elementen gibt uns Platz f√ºr 16 Sekunden, und dies ist viel mehr als das, was wir ben√∂tigen. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/_ZBOSycfANA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Korrektur ist an!</i> <br><br><h3>  Redundante Eingabe√ºbertragung </h3><br>  Eingabenachrichten sind normalerweise sehr klein - die gedr√ºckten Tasten k√∂nnen zu einem Bitfeld kombiniert werden, das nur wenige Bytes ben√∂tigt.  Unsere Nachricht enth√§lt immer noch eine Kennzahl, die 4 Byte belegt, aber wir k√∂nnen sie problemlos mit einem 8-Bit-Wert mit einem √úbertrag komprimieren (m√∂glicherweise ist das Intervall 0-255 zu klein, wir k√∂nnen sicher sein und es auf 9 oder 10 Bit erh√∂hen).  Wie dem auch sei, diese Nachrichten sind recht klein, und dies bedeutet, dass wir in jeder Nachricht viele Eingabedaten senden k√∂nnen (falls die vorherigen Eingabedaten verloren gingen).  Wie weit sollten wir zur√ºckgehen?  Nun, der Client kennt die Kennzahlnummer der letzten Statusmeldung, die er vom Server erhalten hat. Es macht also keinen Sinn, weiter als diese Kennzahl zur√ºckzugehen.  Wir m√ºssen auch die Menge der redundanten Eingabedaten, die vom Client gesendet werden, begrenzen.  Ich habe dies in meiner Demo nicht getan, aber es sollte im fertigen Code implementiert sein. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.HasAvailableStateMessage()) { StateMessage state_msg = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.GetStateMessage(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.client_last_received_state_tick = state_msg.tick_number;</code> </pre> <br>  Dies ist eine einfache √Ñnderung. Der Client schreibt einfach die Kennzahl der zuletzt empfangenen Statusmeldung. <br><br><pre> <code class="cs hljs">Inputs inputs = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.SampleInputs(); InputMessage input_msg; input_msg.start_tick_number = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.client_last_received_state_tick; input_msg.inputs = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Inputs&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> tick = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.client_last_received_state_tick; tick &lt;= <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tick_number; ++tick) { input_msg.inputs.Add(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.client_input_buffer[tick % <span class="hljs-number"><span class="hljs-number">1024</span></span>]); } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.SendToServer(input_msg);</code> </pre> <br>  Die vom Client gesendete Eingabenachricht enth√§lt jetzt eine Liste von Eingabedaten, nicht nur ein Element.  Der Teil mit der Kennzahl erh√§lt einen neuen Wert - dies ist nun die Kennzahl der ersten Eingabe in dieser Liste. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.HasAvailableInputMessages()) { InputMessage input_msg = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.GetInputMessage(); <span class="hljs-comment"><span class="hljs-comment">// message contains an array of inputs, calculate what tick the final one is uint max_tick = input_msg.start_tick_number + (uint)input_msg.inputs.Count - 1; // if that tick is greater than or equal to the current tick we're on, then it // has inputs which are new if (max_tick &gt;= server_tick_number) { // there may be some inputs in the array that we've already had, // so figure out where to start uint start_i = server_tick_number &gt; input_msg.start_tick_number ? (server_tick_number - input_msg.start_tick_number) : 0; // run through all relevant inputs, and step player forward Rigidbody rigidbody = player.GetComponent&lt;Rigidbody&gt;(); for (int i = (int)start_i; i &lt; input_msg.inputs.Count; ++i) { this.AddForcesToPlayer(rigidbody, input_msg.inputs[i]); Physics.Simulate(Time.fixedDeltaTime); } server_tick_number = max_tick + 1; } }</span></span></code> </pre> <br>  Wenn der Server eine Eingabenachricht empf√§ngt, kennt er die Kennzahl der ersten Eingabe und die Menge der Eingabedaten in der Nachricht.  Daher kann das Ma√ü der letzten Eingabe in der Nachricht berechnet werden.  Wenn diese letzte Kennzahl gr√∂√üer oder gleich der Server-Kennzahl ist, wei√ü sie, dass die Nachricht mindestens eine Eingabe enth√§lt, die der Server noch nicht gesehen hat.  Wenn ja, werden alle neuen Eingabedaten simuliert. <br><br>  M√∂glicherweise haben Sie bemerkt, dass <em>bei einer</em> begrenzten Anzahl redundanter Eingabedaten in der Eingabenachricht bei einer ausreichend gro√üen Anzahl verlorener Eingabenachrichten eine Simulationsl√ºcke zwischen dem Server und dem Client besteht.  Das hei√üt, der Server kann Ma√ünahme 100 simulieren, eine Statusnachricht senden, um Ma√ünahme 101 zu starten, und dann eine Eingangsnachricht ab Ma√ünahme 105 empfangen. Im obigen Code geht der Server zu 105 √ºber und versucht nicht, Zwischenma√ünahmen basierend auf den neuesten bekannten Eingabedaten zu simulieren.  Ob Sie es brauchen, h√§ngt von Ihrer Entscheidung ab und davon, wie das Spiel aussehen soll.  Pers√∂nlich w√ºrde ich den Server aufgrund des schlechten Zustands des Netzwerks nicht zwingen, den Player auf der Karte zu spekulieren und zu bewegen.  Ich glaube, dass es besser ist, den Player an Ort und Stelle zu lassen, bis die Verbindung wiederhergestellt ist. <br><br>  In der Demo ‚ÄûZen of Networked Physics‚Äú gibt es eine Funktion zum Senden von ‚Äûwichtigen Bewegungen‚Äú durch den Client, dh er sendet redundante Eingabedaten nur, wenn sie von den zuvor √ºbertragenen Eingaben abweichen.  Dies kann als Eingangsdelta-Komprimierung bezeichnet werden, und damit k√∂nnen Sie die Gr√∂√üe der Eingangsnachrichten weiter reduzieren.  Aber bisher habe ich es nicht getan, weil es in dieser Demo keine Optimierung der Netzwerklast gibt. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/XWUsdlNUG5Y" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Vor dem Senden redundanter Eingabedaten: Wenn 25% der Pakete verloren gehen, bewegt sich der Cube langsam und zuckt und wird weiterhin zur√ºckgeworfen.</i> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/ETFdFAB3s9c" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Nach dem Senden redundanter Eingabedaten: Bei einem Verlust von 25% der Pakete gibt es immer noch eine Zuckungskorrektur, aber die Cubes bewegen sich mit einer akzeptablen Geschwindigkeit.</i> <br><br><h3>  Variable Schnappschussfrequenz </h3><br>  In dieser Demo variiert die H√§ufigkeit, mit der der Server Snapshots an den Client sendet.  Bei einer reduzierten H√§ufigkeit ben√∂tigt der Client mehr Zeit, um Korrekturen vom Server zu erhalten.  Wenn sich der Kunde in der Prognose irrt, kann er daher vor dem Empfang einer Statusmeldung noch mehr abweichen, was zu einer deutlicheren Korrektur f√ºhrt.  Bei einer hohen H√§ufigkeit von Snapshots ist der Paketverlust viel weniger wichtig, sodass der Client nicht lange auf den Empfang des n√§chsten Snapshots warten muss. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/ukyFYNfvyDQ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Schnappschussfrequenz 64 Hz</i> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/yQdriQIUnkU" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Schnappschussfrequenz 16 Hz</i> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/RJPah4ucpF0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Schnappschussfrequenz 2 Hz</i> <br><br>  Je h√∂her die H√§ufigkeit von Schnappsch√ºssen ist, desto besser. Sie sollten sie daher so oft wie m√∂glich senden.  Dies h√§ngt jedoch auch von der Menge des zus√§tzlichen Datenverkehrs, seinen Kosten, der Verf√ºgbarkeit dedizierter Server, den Rechenkosten von Servern usw. ab. <br><br><h3>  Gl√§ttungskorrektur </h3><br>  Wir erstellen falsche Prognosen und erhalten h√§ufiger ruckartige Korrekturen, als wir m√∂chten.  Ohne ordnungsgem√§√üen Zugriff auf die Unity / PhysX-Integration kann ich diese fehlerhaften Prognosen kaum debuggen.  Ich habe das schon einmal gesagt, aber ich wiederhole es noch einmal - wenn Sie etwas in Bezug auf Physik finden, in dem ich falsch liege, dann lassen Sie es mich wissen. <br><br>  Ich habe die L√∂sung f√ºr dieses Problem umgangen, indem ich die Risse mit guter alter Gl√§ttung besch√∂nigt habe!  Wenn eine Korrektur erfolgt, gl√§ttet der Client einfach die Position und Drehung des Players in Richtung des richtigen Zustands f√ºr mehrere Frames.  Der physische W√ºrfel selbst wird sofort korrigiert (er ist unsichtbar), aber wir haben nur einen zweiten W√ºrfel zur Anzeige, der eine Gl√§ttung erm√∂glicht. <br><br><pre> <code class="cs hljs">Vector3 position_error = state_msg.position - predicted_state.position; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> rotation_error = <span class="hljs-number"><span class="hljs-number">1.f</span></span> - Quaternion.Dot(state_msg.rotation, predicted_state.rotation); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (position_error.sqrMagnitude &gt; <span class="hljs-number"><span class="hljs-number">0.0000001f</span></span> || rotation_error &gt; <span class="hljs-number"><span class="hljs-number">0.00001f</span></span>) { Rigidbody player_rigidbody = player.GetComponent&lt;Rigidbody&gt;(); <span class="hljs-comment"><span class="hljs-comment">// capture the current predicted pos for smoothing Vector3 prev_pos = player_rigidbody.position + this.client_pos_error; Quaternion prev_rot = player_rigidbody.rotation * this.client_rot_error; // rewind &amp; replay player_rigidbody.position = state_msg.position; player_rigidbody.rotation = state_msg.rotation; player_rigidbody.velocity = state_msg.velocity; player_rigidbody.angularVelocity = state_msg.angular_velocity; uint rewind_tick_number = state_msg.tick_number; while (rewind_tick_number &lt; this.tick_number) { buffer_slot = rewind_tick_number % c_client_buffer_size; this.client_input_buffer[buffer_slot] = inputs; this.client_state_buffer[buffer_slot].position = player_rigidbody.position; this.client_state_buffer[buffer_slot].rotation = player_rigidbody.rotation; this.AddForcesToPlayer(player_rigidbody, inputs); Physics.Simulate(Time.fixedDeltaTime); ++rewind_tick_number; } // if more than 2ms apart, just snap if ((prev_pos - player_rigidbody.position).sqrMagnitude &gt;= 4.0f) { this.client_pos_error = Vector3.zero; this.client_rot_error = Quaternion.identity; } else { this.client_pos_error = prev_pos - player_rigidbody.position; this.client_rot_error = Quaternion.Inverse(player_rigidbody.rotation) * prev_rot; } }</span></span></code> </pre> <br>  Wenn eine fehlerhafte Vorhersage auftritt, verfolgt der Client die Positions- / Rotationsdifferenz nach der Korrektur.  Wenn der Gesamtabstand der Positionskorrektur mehr als 2 Meter betr√§gt, bewegt sich der W√ºrfel einfach ruckartig - die Gl√§ttung w√ºrde immer noch schlecht aussehen. Lassen Sie ihn also zumindest so schnell wie m√∂glich in den richtigen Zustand zur√ºckkehren. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.client_pos_error *= <span class="hljs-number"><span class="hljs-number">0.9f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.client_rot_error = Quaternion.Slerp(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.client_rot_error, Quaternion.identity, <span class="hljs-number"><span class="hljs-number">0.1f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.smoothed_client_player.transform.position = player_rigidbody.position + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.client_pos_error; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.smoothed_client_player.transform.rotation = player_rigidbody.rotation * <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.client_rot_error;</code> </pre> <br>  In jedem Frame f√ºhrt der Client Lerp / Slerp in Richtung der richtigen Position / Drehung um 10% aus. Dies ist ein Standardansatz nach dem Potenzgesetz zur Mittelung der Bewegung.  Es h√§ngt von der Bildrate ab, aber f√ºr die Zwecke unserer Demo ist dies v√∂llig ausreichend. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/AQ3bMh0OQig" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>250 ms Verz√∂gerung</i> <i><br></i>  <i>10% der Pakete verloren</i> <i><br></i>  <i>Ohne Gl√§ttung ist die Korrektur sehr auff√§llig</i> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/2jhg8OJdqXY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>250 ms Verz√∂gerung</i> <i><br></i>  <i>10% der Pakete verloren</i> <i><br></i>  <i>Bei der Gl√§ttung ist die Korrektur viel schwieriger zu bemerken.</i> <br><br>  Das Endergebnis funktioniert ziemlich gut. Ich m√∂chte eine Version erstellen, die wirklich Pakete sendet, anstatt sie nachzuahmen.  Zumindest ist dies jedoch ein Proof of Concept f√ºr ein clientseitiges Prognosesystem mit realen physischen Objekten in Unity, ohne dass physische Plug-Ins und dergleichen erforderlich sind. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de432190/">https://habr.com/ru/post/de432190/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de432180/index.html">So steigern Sie Ihre Karriere mit GitHub</a></li>
<li><a href="../de432182/index.html">Wir holen Post ohne SMS und Registrierung ab</a></li>
<li><a href="../de432184/index.html">Problemidentit√§ten unter Testern</a></li>
<li><a href="../de432186/index.html">Verwenden von STP zum Erstellen von P2P-Kan√§len</a></li>
<li><a href="../de432188/index.html">APT28-Hacker griffen E-Mail-Boxen von Hunderten von Mitarbeitern des tschechischen Ministeriums an</a></li>
<li><a href="../de432192/index.html">4 Anzeichen daf√ºr, dass Sie nicht bereit sind, eine Projektmanagementl√∂sung zu implementieren</a></li>
<li><a href="../de432196/index.html">Informationen zur Funktionszusammensetzung in JavaScript</a></li>
<li><a href="../de432198/index.html">Delivery Manager - Eine neue Rolle in der agilen Welt</a></li>
<li><a href="../de432200/index.html">Wie Ivan die Standumwandlung untersuchte</a></li>
<li><a href="../de432202/index.html">Charaktertypen im laufenden Betrieb generieren (oder verr√ºckt nach Rust)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>