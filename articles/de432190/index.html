<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👸🏻 🧑🏼‍🤝‍🧑🏼 🏂🏻 Client-seitige Physikvorhersage in Unity 📟 🙂 ♈️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="TL; DR 
 Ich habe eine Demo erstellt, die zeigt, wie die clientseitige Vorhersage der physischen Bewegung eines Spielers in Unity - GitHub implementie...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Client-seitige Physikvorhersage in Unity</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/432190/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a59/4f5/561/a594f5561a9452567464c512df8171e5.jpg" alt="Bild"></div><br><h3>  TL; DR </h3><br>  Ich habe eine Demo erstellt, die zeigt, wie die clientseitige Vorhersage der physischen Bewegung eines Spielers in Unity - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub</a> implementiert wird. <br><br><h3>  Einführung </h3><br>  Anfang 2012 schrieb ich einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beitrag</a> über die Implementierung von Prognosen auf der Client-Seite der physischen Bewegung eines Spielers in Unity.  Dank <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Physics.Simulate () wird</a> diese von mir beschriebene ungeschickte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Problemumgehung</a> nicht mehr benötigt.  Der alte Beitrag ist immer noch einer der beliebtesten in meinem Blog, aber für die moderne Einheit sind diese Informationen bereits falsch.  Daher veröffentliche ich die Version 2018. <br><br><h3>  Was ist auf der Client-Seite? </h3><br>  In wettbewerbsfähigen Multiplayer-Spielen sollte Betrug nach Möglichkeit vermieden werden.  Normalerweise bedeutet dies, dass ein Netzwerkmodell mit einem autoritären Server verwendet wird: Die Clients senden die eingegebenen Informationen an den Server, und der Server wandelt diese Informationen in die Bewegung eines Spielers um und sendet dann eine Momentaufnahme des Status des Spielers an den Client.  In diesem Fall gibt es eine Verzögerung zwischen dem Drücken der Taste und der Anzeige des Ergebnisses, die für aktive Spiele nicht akzeptabel ist.  Die Vorhersage auf der Client-Seite ist eine sehr beliebte Technik, die die Verzögerung verbirgt, die resultierende Bewegung vorhersagt und sie dem Spieler sofort anzeigt.  Wenn der Client die Ergebnisse vom Server empfängt, vergleicht er sie mit den Vorhersagen des Clients. Wenn sie sich unterscheiden, war die Prognose fehlerhaft und muss korrigiert werden. <br><a name="habracut"></a><br>  Vom Server empfangene Snapshots stammen immer aus der Vergangenheit in Bezug auf den vorhergesagten Status des Clients (wenn beispielsweise die Übertragung von Daten vom Client zum Server und zurück 150 ms dauert, wird jeder Snapshot um mindestens 150 ms verzögert).  Wenn der Kunde die falsche Prognose korrigieren muss, muss er daher zu diesem Punkt in der Vergangenheit zurückkehren und dann alle in die Lücke eingegebenen Informationen reproduzieren, um zu seinem Standort zurückzukehren.  Wenn die Bewegung des Spielers im Spiel auf Physik basiert, wird Physics.Simulate () benötigt, um mehrere Zyklen in einem Frame zu simulieren.  Wenn beim Bewegen des Players nur Character Controller (oder Kapselguss usw.) verwendet werden, können Sie auf Physics.Simulate () verzichten - und ich gehe davon aus, dass die Leistung besser ist. <br><br>  Ich werde Unity verwenden, um eine Netzwerkdemo namens <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Glenn Fiedlers</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zen of Networked Physics"</a> neu zu erstellen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">,</a> die mir seit langem Spaß macht.  Der Spieler hat einen physischen Würfel, auf den er Kraft ausüben und ihn in die Szene schieben kann.  Die Demo simuliert verschiedene Netzwerkbedingungen, einschließlich Verzögerung und Paketverlust. <br><br><h3>  An die Arbeit gehen </h3><br>  Als erstes müssen Sie die automatische Physiksimulation ausschalten.  Obwohl wir mit Physics.Simulate () dem physischen System mitteilen können, wann die Simulation gestartet werden soll, führt es die Simulation standardmäßig automatisch basierend auf einem festen Projektzeitdelta durch.  Daher deaktivieren wir es unter <strong>Bearbeiten-&gt; Projekteinstellungen-&gt; Physik,</strong> indem wir das <strong>Kontrollkästchen "Automatische</strong> <strong>Simulation</strong> " deaktivieren. <br><br>  Zunächst erstellen wir eine einfache Einzelbenutzerimplementierung.  Die Eingabe wird abgetastet (w, a, s, d zum Bewegen und Platz zum Springen), und alles hängt von den einfachen Kräften ab, die mit AddForce () auf den starren Körper ausgeübt werden. <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Logic</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameObject player; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> timer; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.timer = <span class="hljs-number"><span class="hljs-number">0.0f</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.timer += Time.deltaTime; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.timer &gt;= Time.fixedDeltaTime) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.timer -= Time.fixedDeltaTime; Inputs inputs; inputs.up = Input.GetKey(KeyCode.W); inputs.down = Input.GetKey(KeyCode.S); inputs.left = Input.GetKey(KeyCode.A); inputs.right = Input.GetKey(KeyCode.D); inputs.jump = Input.GetKey(KeyCode.Space); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.AddForcesToPlayer(player.GetComponent&lt;Rigidbody&gt;(), inputs); Physics.Simulate(Time.fixedDeltaTime); } } }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/BbC-MQX08KE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Spieler bewegen sich, während das Netzwerk nicht verwendet wird</i> <br><br><h3>  Senden von Eingaben an den Server </h3><br>  Jetzt müssen wir die Eingabe an den Server senden, der auch diesen Bewegungscode ausführt, einen Schnappschuss des Status des Cubes erstellen und ihn an den Client zurücksenden. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// client private void Update() { this.timer += Time.deltaTime; while (this.timer &gt;= Time.fixedDeltaTime) { this.timer -= Time.fixedDeltaTime; Inputs inputs = this.SampleInputs(); InputMessage input_msg; input_msg.inputs = inputs; input_msg.tick_number = this.tick_number; this.SendToServer(input_msg); this.AddForcesToPlayer(player.GetComponent&lt;Rigidbody&gt;(), inputs); Physics.Simulate(Time.fixedDeltaTime); ++this.tick_number; } }</span></span></code> </pre> <br>  Bisher nichts Besonderes hier, das einzige, worauf ich achten möchte, ist das Hinzufügen der Variablen tick_number.  Wenn der Server Snapshots des Status des Cubes an den Client zurücksendet, können wir herausfinden, welcher Takt des Clients diesem Status entspricht, damit wir diesen Status mit dem vorhergesagten Client vergleichen können (den wir etwas später hinzufügen werden). <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// server private void Update() { while (this.HasAvailableInputMessages()) { InputMessage input_msg = this.GetInputMessage(); Rigidbody rigidbody = player.GetComponent&lt;Rigidbody&gt;(); this.AddForcesToPlayer(rigidbody, input_msg.inputs); Physics.Simulate(Time.fixedDeltaTime); StateMessage state_msg; state_msg.position = rigidbody.position; state_msg.rotation = rigidbody.rotation; state_msg.velocity = rigidbody.velocity; state_msg.angular_velocity = rigidbody.angularVelocity; state_msg.tick_number = input_msg.tick_number + 1; this.SendToClient(state_msg); } }</span></span></code> </pre> <br>  Alles ist einfach - der Server wartet auf Eingabenachrichten, simuliert beim Empfang einen Taktzyklus.  Dann macht er eine Momentaufnahme des resultierenden Zustands des Cubes und sendet ihn an den Client zurück.  Möglicherweise stellen Sie fest, dass tick_number in der Statusnachricht um eins größer ist als tick_number in der Eingabenachricht.  Dies geschieht, weil es für mich persönlich intuitiv bequemer ist, den "Zustand des Spielers in Takt 100" als den "Zustand des Spielers zu <strong>Beginn von</strong> Takt 100" zu betrachten.  Daher erzeugt der Status des Spielers in Takt 100 in Kombination mit der Eingabe des Spielers in Takt 100 einen neuen Status für den Spieler in Takt 101. <br><br><h1>  Zustand <sub>n</sub> + Eingang <sub>n</sub> = Zustand <sub>n + 1</sub> </h1><br>  Ich sage nicht, dass Sie es genauso nehmen sollten, die Hauptsache ist die Konstanz des Ansatzes. <br><br>  Es muss auch gesagt werden, dass ich diese Nachrichten nicht über einen echten Socket <em>sende</em> , sondern sie imitiere, indem ich sie in die Warteschlange schreibe und Paketverzögerung und -verlust simuliere.  Die Szene enthält zwei physische Cubes - einen für den Client und einen für den Server.  Beim Aktualisieren des Client-Cubes deaktiviere ich das GameObject des Server-Cubes und umgekehrt. <br><br>  Ich simuliere jedoch nicht Network Bounce und Paketzustellung in der falschen Reihenfolge, weshalb ich davon ausgehe, dass jede empfangene Eingangsnachricht neuer als die vorherige ist.  Diese Nachahmung wird benötigt, um ganz einfach "Client" und "Server" in einer Unity-Instanz auszuführen, sodass wir Server- und Client-Cubes in einer Szene kombinieren können. <br><br>  Sie können auch feststellen, dass der Server weniger Taktzyklen als der Client simuliert und daher einen anderen Status erstellt, wenn die Eingabenachricht verworfen wird und den Server nicht erreicht.  Dies ist wahr, aber selbst wenn wir diese Auslassungen simulieren würden, könnte die Eingabe immer noch falsch sein, was auch zu einem anderen Zustand führen würde.  Wir werden uns später mit diesem Problem befassen. <br><br>  Es sollte auch hinzugefügt werden, dass es in diesem Beispiel nur einen Client gibt, was die Arbeit vereinfacht.  Wenn wir mehrere Clients hätten, müssten wir a) beim Aufrufen von Physics.Simulate () überprüfen, ob nur der Cube eines Spielers auf dem Server aktiviert ist, oder b) wenn der Server Eingaben von mehreren Cubes erhalten hat, alle zusammen simulieren. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/OUwWzUxZao0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Verzögerung 75 ms (150 ms Hin- und Rückfahrt)</i> <i><br></i>  <i>0% verlorene Pakete</i> <i><br></i>  <i>Gelber Würfel - Server-Spieler</i> <i><br></i>  <i>Blauer Würfel - der letzte vom Client empfangene Schnappschuss</i> <br><br>  Bisher sieht alles gut aus, aber ich war ein wenig wählerisch bei dem, was ich auf dem Video aufgenommen habe, um ein ziemlich ernstes Problem zu verbergen. <br><br><h3>  Bestimmungsfehler </h3><br>  Schauen Sie sich das jetzt an: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/7jbKgyUwnd4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Autsch ...</i> <br><br>  Dieses Video wurde aufgenommen, ohne Pakete zu verlieren. Die Simulationen variieren jedoch immer noch mit genau derselben Eingabe.  Ich verstehe nicht ganz, warum dies passiert - PhysX sollte ziemlich deterministisch sein, daher finde ich es auffällig, dass die Simulationen so oft voneinander abweichen.  Dies kann an der Tatsache liegen, dass ich GameObject-Cubes ständig aktiviere und deaktiviere. Das heißt, es ist möglich, dass das Problem bei Verwendung von zwei verschiedenen Unity-Instanzen abnimmt.  Es kann ein Fehler sein, wenn Sie es im Code auf GitHub sehen, dann lassen Sie es mich wissen. <br><br>  Wie dem auch sei, falsche Prognosen sind eine wesentliche Tatsache bei der Prognose auf Kundenseite. Lassen Sie uns also damit umgehen. <br><br><h3>  Kann ich zurückspulen? </h3><br>  Der Vorgang ist recht einfach: Wenn der Kunde eine Bewegung vorhersagt, speichert er einen Statuspuffer (Position und Drehung) und eine Eingabe.  Nach dem Empfang einer Statusnachricht vom Server wird der empfangene Status mit dem vorhergesagten Status aus dem Puffer verglichen.  Wenn sie sich um einen zu großen Wert unterscheiden, definieren wir den Status des Client-Cubes in der Vergangenheit neu und simulieren dann erneut alle Zwischenmaßnahmen. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// client private ClientState[] client_state_buffer = new ClientState[1024]; private Inputs[] client_input_buffer = new Inputs[1024]; private void Update() { this.timer += Time.deltaTime; while (this.timer &gt;= Time.fixedDeltaTime) { this.timer -= Time.fixedDeltaTime; Inputs inputs = this.SampleInputs(); InputMessage input_msg; input_msg.inputs = inputs; input_msg.tick_number = this.tick_number; this.SendToServer(input_msg); uint buffer_slot = this.tick_number % 1024; this.client_input_buffer[buffer_slot] = inputs; this.client_state_buffer[buffer_slot].position = rigidbody.position; this.client_state_buffer[buffer_slot].rotation = rigidbody.rotation; this.AddForcesToPlayer(player.GetComponent&lt;Rigidbody&gt;(), inputs); Physics.Simulate(Time.fixedDeltaTime); ++this.tick_number; } while (this.HasAvailableStateMessage()) { StateMessage state_msg = this.GetStateMessage(); uint buffer_slot = state_msg.tick_number % c_client_buffer_size; Vector3 position_error = state_msg.position - this.client_state_buffer[buffer_slot].position; if (position_error.sqrMagnitude &gt; 0.0000001f) { // rewind &amp; replay Rigidbody player_rigidbody = player.GetComponent&lt;Rigidbody&gt;(); player_rigidbody.position = state_msg.position; player_rigidbody.rotation = state_msg.rotation; player_rigidbody.velocity = state_msg.velocity; player_rigidbody.angularVelocity = state_msg.angular_velocity; uint rewind_tick_number = state_msg.tick_number; while (rewind_tick_number &lt; this.tick_number) { buffer_slot = rewind_tick_number % c_client_buffer_size; this.client_input_buffer[buffer_slot] = inputs; this.client_state_buffer[buffer_slot].position = player_rigidbody.position; this.client_state_buffer[buffer_slot].rotation = player_rigidbody.rotation; this.AddForcesToPlayer(player_rigidbody, inputs); Physics.Simulate(Time.fixedDeltaTime); ++rewind_tick_number; } } } }</span></span></code> </pre> <br>  Gepufferte Eingabe- und Statusdaten werden in einem sehr einfachen Umlaufpuffer gespeichert, in dem die Kennzahl als Index verwendet wird.  Und ich habe den Wert von 64 Hz für die Taktfrequenz der Physik gewählt, dh ein Puffer von 1024 Elementen gibt uns Platz für 16 Sekunden, und dies ist viel mehr als das, was wir benötigen. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/_ZBOSycfANA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Korrektur ist an!</i> <br><br><h3>  Redundante Eingabeübertragung </h3><br>  Eingabenachrichten sind normalerweise sehr klein - die gedrückten Tasten können zu einem Bitfeld kombiniert werden, das nur wenige Bytes benötigt.  Unsere Nachricht enthält immer noch eine Kennzahl, die 4 Byte belegt, aber wir können sie problemlos mit einem 8-Bit-Wert mit einem Übertrag komprimieren (möglicherweise ist das Intervall 0-255 zu klein, wir können sicher sein und es auf 9 oder 10 Bit erhöhen).  Wie dem auch sei, diese Nachrichten sind recht klein, und dies bedeutet, dass wir in jeder Nachricht viele Eingabedaten senden können (falls die vorherigen Eingabedaten verloren gingen).  Wie weit sollten wir zurückgehen?  Nun, der Client kennt die Kennzahlnummer der letzten Statusmeldung, die er vom Server erhalten hat. Es macht also keinen Sinn, weiter als diese Kennzahl zurückzugehen.  Wir müssen auch die Menge der redundanten Eingabedaten, die vom Client gesendet werden, begrenzen.  Ich habe dies in meiner Demo nicht getan, aber es sollte im fertigen Code implementiert sein. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.HasAvailableStateMessage()) { StateMessage state_msg = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.GetStateMessage(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.client_last_received_state_tick = state_msg.tick_number;</code> </pre> <br>  Dies ist eine einfache Änderung. Der Client schreibt einfach die Kennzahl der zuletzt empfangenen Statusmeldung. <br><br><pre> <code class="cs hljs">Inputs inputs = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.SampleInputs(); InputMessage input_msg; input_msg.start_tick_number = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.client_last_received_state_tick; input_msg.inputs = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Inputs&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> tick = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.client_last_received_state_tick; tick &lt;= <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tick_number; ++tick) { input_msg.inputs.Add(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.client_input_buffer[tick % <span class="hljs-number"><span class="hljs-number">1024</span></span>]); } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.SendToServer(input_msg);</code> </pre> <br>  Die vom Client gesendete Eingabenachricht enthält jetzt eine Liste von Eingabedaten, nicht nur ein Element.  Der Teil mit der Kennzahl erhält einen neuen Wert - dies ist nun die Kennzahl der ersten Eingabe in dieser Liste. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.HasAvailableInputMessages()) { InputMessage input_msg = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.GetInputMessage(); <span class="hljs-comment"><span class="hljs-comment">// message contains an array of inputs, calculate what tick the final one is uint max_tick = input_msg.start_tick_number + (uint)input_msg.inputs.Count - 1; // if that tick is greater than or equal to the current tick we're on, then it // has inputs which are new if (max_tick &gt;= server_tick_number) { // there may be some inputs in the array that we've already had, // so figure out where to start uint start_i = server_tick_number &gt; input_msg.start_tick_number ? (server_tick_number - input_msg.start_tick_number) : 0; // run through all relevant inputs, and step player forward Rigidbody rigidbody = player.GetComponent&lt;Rigidbody&gt;(); for (int i = (int)start_i; i &lt; input_msg.inputs.Count; ++i) { this.AddForcesToPlayer(rigidbody, input_msg.inputs[i]); Physics.Simulate(Time.fixedDeltaTime); } server_tick_number = max_tick + 1; } }</span></span></code> </pre> <br>  Wenn der Server eine Eingabenachricht empfängt, kennt er die Kennzahl der ersten Eingabe und die Menge der Eingabedaten in der Nachricht.  Daher kann das Maß der letzten Eingabe in der Nachricht berechnet werden.  Wenn diese letzte Kennzahl größer oder gleich der Server-Kennzahl ist, weiß sie, dass die Nachricht mindestens eine Eingabe enthält, die der Server noch nicht gesehen hat.  Wenn ja, werden alle neuen Eingabedaten simuliert. <br><br>  Möglicherweise haben Sie bemerkt, dass <em>bei einer</em> begrenzten Anzahl redundanter Eingabedaten in der Eingabenachricht bei einer ausreichend großen Anzahl verlorener Eingabenachrichten eine Simulationslücke zwischen dem Server und dem Client besteht.  Das heißt, der Server kann Maßnahme 100 simulieren, eine Statusnachricht senden, um Maßnahme 101 zu starten, und dann eine Eingangsnachricht ab Maßnahme 105 empfangen. Im obigen Code geht der Server zu 105 über und versucht nicht, Zwischenmaßnahmen basierend auf den neuesten bekannten Eingabedaten zu simulieren.  Ob Sie es brauchen, hängt von Ihrer Entscheidung ab und davon, wie das Spiel aussehen soll.  Persönlich würde ich den Server aufgrund des schlechten Zustands des Netzwerks nicht zwingen, den Player auf der Karte zu spekulieren und zu bewegen.  Ich glaube, dass es besser ist, den Player an Ort und Stelle zu lassen, bis die Verbindung wiederhergestellt ist. <br><br>  In der Demo „Zen of Networked Physics“ gibt es eine Funktion zum Senden von „wichtigen Bewegungen“ durch den Client, dh er sendet redundante Eingabedaten nur, wenn sie von den zuvor übertragenen Eingaben abweichen.  Dies kann als Eingangsdelta-Komprimierung bezeichnet werden, und damit können Sie die Größe der Eingangsnachrichten weiter reduzieren.  Aber bisher habe ich es nicht getan, weil es in dieser Demo keine Optimierung der Netzwerklast gibt. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/XWUsdlNUG5Y" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Vor dem Senden redundanter Eingabedaten: Wenn 25% der Pakete verloren gehen, bewegt sich der Cube langsam und zuckt und wird weiterhin zurückgeworfen.</i> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/ETFdFAB3s9c" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Nach dem Senden redundanter Eingabedaten: Bei einem Verlust von 25% der Pakete gibt es immer noch eine Zuckungskorrektur, aber die Cubes bewegen sich mit einer akzeptablen Geschwindigkeit.</i> <br><br><h3>  Variable Schnappschussfrequenz </h3><br>  In dieser Demo variiert die Häufigkeit, mit der der Server Snapshots an den Client sendet.  Bei einer reduzierten Häufigkeit benötigt der Client mehr Zeit, um Korrekturen vom Server zu erhalten.  Wenn sich der Kunde in der Prognose irrt, kann er daher vor dem Empfang einer Statusmeldung noch mehr abweichen, was zu einer deutlicheren Korrektur führt.  Bei einer hohen Häufigkeit von Snapshots ist der Paketverlust viel weniger wichtig, sodass der Client nicht lange auf den Empfang des nächsten Snapshots warten muss. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/ukyFYNfvyDQ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Schnappschussfrequenz 64 Hz</i> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/yQdriQIUnkU" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Schnappschussfrequenz 16 Hz</i> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/RJPah4ucpF0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Schnappschussfrequenz 2 Hz</i> <br><br>  Je höher die Häufigkeit von Schnappschüssen ist, desto besser. Sie sollten sie daher so oft wie möglich senden.  Dies hängt jedoch auch von der Menge des zusätzlichen Datenverkehrs, seinen Kosten, der Verfügbarkeit dedizierter Server, den Rechenkosten von Servern usw. ab. <br><br><h3>  Glättungskorrektur </h3><br>  Wir erstellen falsche Prognosen und erhalten häufiger ruckartige Korrekturen, als wir möchten.  Ohne ordnungsgemäßen Zugriff auf die Unity / PhysX-Integration kann ich diese fehlerhaften Prognosen kaum debuggen.  Ich habe das schon einmal gesagt, aber ich wiederhole es noch einmal - wenn Sie etwas in Bezug auf Physik finden, in dem ich falsch liege, dann lassen Sie es mich wissen. <br><br>  Ich habe die Lösung für dieses Problem umgangen, indem ich die Risse mit guter alter Glättung beschönigt habe!  Wenn eine Korrektur erfolgt, glättet der Client einfach die Position und Drehung des Players in Richtung des richtigen Zustands für mehrere Frames.  Der physische Würfel selbst wird sofort korrigiert (er ist unsichtbar), aber wir haben nur einen zweiten Würfel zur Anzeige, der eine Glättung ermöglicht. <br><br><pre> <code class="cs hljs">Vector3 position_error = state_msg.position - predicted_state.position; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> rotation_error = <span class="hljs-number"><span class="hljs-number">1.f</span></span> - Quaternion.Dot(state_msg.rotation, predicted_state.rotation); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (position_error.sqrMagnitude &gt; <span class="hljs-number"><span class="hljs-number">0.0000001f</span></span> || rotation_error &gt; <span class="hljs-number"><span class="hljs-number">0.00001f</span></span>) { Rigidbody player_rigidbody = player.GetComponent&lt;Rigidbody&gt;(); <span class="hljs-comment"><span class="hljs-comment">// capture the current predicted pos for smoothing Vector3 prev_pos = player_rigidbody.position + this.client_pos_error; Quaternion prev_rot = player_rigidbody.rotation * this.client_rot_error; // rewind &amp; replay player_rigidbody.position = state_msg.position; player_rigidbody.rotation = state_msg.rotation; player_rigidbody.velocity = state_msg.velocity; player_rigidbody.angularVelocity = state_msg.angular_velocity; uint rewind_tick_number = state_msg.tick_number; while (rewind_tick_number &lt; this.tick_number) { buffer_slot = rewind_tick_number % c_client_buffer_size; this.client_input_buffer[buffer_slot] = inputs; this.client_state_buffer[buffer_slot].position = player_rigidbody.position; this.client_state_buffer[buffer_slot].rotation = player_rigidbody.rotation; this.AddForcesToPlayer(player_rigidbody, inputs); Physics.Simulate(Time.fixedDeltaTime); ++rewind_tick_number; } // if more than 2ms apart, just snap if ((prev_pos - player_rigidbody.position).sqrMagnitude &gt;= 4.0f) { this.client_pos_error = Vector3.zero; this.client_rot_error = Quaternion.identity; } else { this.client_pos_error = prev_pos - player_rigidbody.position; this.client_rot_error = Quaternion.Inverse(player_rigidbody.rotation) * prev_rot; } }</span></span></code> </pre> <br>  Wenn eine fehlerhafte Vorhersage auftritt, verfolgt der Client die Positions- / Rotationsdifferenz nach der Korrektur.  Wenn der Gesamtabstand der Positionskorrektur mehr als 2 Meter beträgt, bewegt sich der Würfel einfach ruckartig - die Glättung würde immer noch schlecht aussehen. Lassen Sie ihn also zumindest so schnell wie möglich in den richtigen Zustand zurückkehren. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.client_pos_error *= <span class="hljs-number"><span class="hljs-number">0.9f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.client_rot_error = Quaternion.Slerp(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.client_rot_error, Quaternion.identity, <span class="hljs-number"><span class="hljs-number">0.1f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.smoothed_client_player.transform.position = player_rigidbody.position + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.client_pos_error; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.smoothed_client_player.transform.rotation = player_rigidbody.rotation * <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.client_rot_error;</code> </pre> <br>  In jedem Frame führt der Client Lerp / Slerp in Richtung der richtigen Position / Drehung um 10% aus. Dies ist ein Standardansatz nach dem Potenzgesetz zur Mittelung der Bewegung.  Es hängt von der Bildrate ab, aber für die Zwecke unserer Demo ist dies völlig ausreichend. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/AQ3bMh0OQig" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>250 ms Verzögerung</i> <i><br></i>  <i>10% der Pakete verloren</i> <i><br></i>  <i>Ohne Glättung ist die Korrektur sehr auffällig</i> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/2jhg8OJdqXY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>250 ms Verzögerung</i> <i><br></i>  <i>10% der Pakete verloren</i> <i><br></i>  <i>Bei der Glättung ist die Korrektur viel schwieriger zu bemerken.</i> <br><br>  Das Endergebnis funktioniert ziemlich gut. Ich möchte eine Version erstellen, die wirklich Pakete sendet, anstatt sie nachzuahmen.  Zumindest ist dies jedoch ein Proof of Concept für ein clientseitiges Prognosesystem mit realen physischen Objekten in Unity, ohne dass physische Plug-Ins und dergleichen erforderlich sind. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de432190/">https://habr.com/ru/post/de432190/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de432180/index.html">So steigern Sie Ihre Karriere mit GitHub</a></li>
<li><a href="../de432182/index.html">Wir holen Post ohne SMS und Registrierung ab</a></li>
<li><a href="../de432184/index.html">Problemidentitäten unter Testern</a></li>
<li><a href="../de432186/index.html">Verwenden von STP zum Erstellen von P2P-Kanälen</a></li>
<li><a href="../de432188/index.html">APT28-Hacker griffen E-Mail-Boxen von Hunderten von Mitarbeitern des tschechischen Ministeriums an</a></li>
<li><a href="../de432192/index.html">4 Anzeichen dafür, dass Sie nicht bereit sind, eine Projektmanagementlösung zu implementieren</a></li>
<li><a href="../de432196/index.html">Informationen zur Funktionszusammensetzung in JavaScript</a></li>
<li><a href="../de432198/index.html">Delivery Manager - Eine neue Rolle in der agilen Welt</a></li>
<li><a href="../de432200/index.html">Wie Ivan die Standumwandlung untersuchte</a></li>
<li><a href="../de432202/index.html">Charaktertypen im laufenden Betrieb generieren (oder verrückt nach Rust)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>