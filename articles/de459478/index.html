<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üïØÔ∏è üë®üèª‚Äçüè´ ü§üüèº Meine Erfahrung beim Erstellen einer Multithread-Anwendung f√ºr die Arbeit mit Backups üïâÔ∏è üßö üß£</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Im Moment werden Sie niemanden mit Multithread-Anwendungen √ºberraschen, aber ich denke, dass Sie in diesem Artikel einige interessante Ideen finden k√∂...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Meine Erfahrung beim Erstellen einer Multithread-Anwendung f√ºr die Arbeit mit Backups</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459478/"><p>  Im Moment werden Sie niemanden mit Multithread-Anwendungen √ºberraschen, aber ich denke, dass Sie in diesem Artikel einige interessante Ideen finden k√∂nnen.  Mein Java-Studium begann mit diesem Projekt. Vielleicht irre ich mich an einigen Stellen sehr oder baue ein gro√ües Fahrrad, aber ich hoffe, dass sich jemand f√ºr die Erfahrung eines Anf√§ngers in Java interessiert.  Ich werde einige Funktionen der Anwendung geben: </p><br><ul><li>  Es funktioniert mit Sicherungen ausschlie√ülich im Speicher, unabh√§ngig von der Gr√∂√üe der Sicherung </li><li>  L√§dt nicht die gesamte Sicherung in den Speicher </li><li>  Sicherungs- / Wiederherstellungsvorg√§nge k√∂nnen abgebrochen werden </li></ul><br><p>  Unter dem Schnitt werden die Architektur der Anwendung sowie die aufgetretenen Hauptprobleme und deren L√∂sung betrachtet. </p><a name="habracut"></a><br><h2 id="obzor-prilozheniya">  Anwendungs√ºbersicht </h2><br><p>  Die Kommunikation mit der Anwendung erfolgt √ºber die Web-Benutzeroberfl√§che. In Zukunft kann jedoch bei Bedarf eine REST-API hinzugef√ºgt werden. </p><br><p>  Die Anwendung kann: </p><br><ol><li>  Erstellen Sie Backups und laden Sie sie in einen oder mehrere Speicher hoch </li><li>  Stellen Sie Sicherungen wieder her, indem Sie sie aus dem Speicher laden </li><li>  L√∂schen Sie Backups aus allen Speichern </li><li>  Erstellen Sie regelm√§√üig Backups </li></ol><br><p>  Derzeit unterst√ºtzte Repositorys: </p><br><ul><li>  Lokales Dateisystem (wird von Docker nicht unterst√ºtzt) </li><li>  Dropbox </li></ul><br><p>  Derzeit unterst√ºtzte Datenbanken: </p><br><ul><li>  PostgreSQL </li></ul><br><p>  Aus einer speziellen Anwendung kann ich Folgendes hervorgehen: </p><br><ol><li>  Richtige Arbeit in einer Clusterkonfiguration </li><li>  Ein Backup wird unabh√§ngig von der Gr√∂√üe des Backups niemals vollst√§ndig in den Speicher geladen.  Das Dateisystem f√ºr die tempor√§re Sicherungsspeicherung ist ebenfalls nicht beteiligt.  Sowohl die Erstellung einer Sicherung als auch die Wiederherstellung und damit das Laden / Entladen einer Sicherung erfolgen ausschlie√ülich im Speicher. </li><li>  Plattform√ºbergreifend - funktioniert sowohl unter Windows als auch unter Linux. </li><li>  Wir k√∂nnen alle laufenden Aufgaben √ºberwachen und bei Bedarf abbrechen. </li></ol><br><p>  Unten finden Sie Screenshots der Web-Benutzeroberfl√§che, in denen die Funktionen der Anwendung klar beschrieben werden. </p><br><div class="spoiler">  <b class="spoiler_title">Speicherverwaltung</b> <div class="spoiler_text"><p> <a href=""><img src="https://habrastorage.org/webt/vl/qg/n5/vlqgn5f58ub5jhxixeeg2uq-oa8.png" title="Speicher hinzuf√ºgen"></a> <br> <a href=""><img src="https://habrastorage.org/webt/oj/o5/uj/ojo5uj_raxkwd1btsjrktiowifo.png" title="Speicherliste"></a> </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Datenbankverwaltung</b> <div class="spoiler_text"><p> <a href=""><img src="https://habrastorage.org/webt/wn/6p/bk/wn6pbkcqg4qu_9btgrvnqm3l7x0.png" title="Hinzuf√ºgen einer Datenbank"></a> <br> <a href=""><img src="https://habrastorage.org/webt/wu/9a/4k/wu9a4ky7icuiyqdxeiii9xbu5d8.png" title="Liste der Datenbanken"></a> </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Backup-Erstellung</b> <div class="spoiler_text"><p> <a href=""><img src="https://habrastorage.org/webt/1d/zb/6s/1dzb6scvtua5v3m_3l11lch4rgm.png" title="Backup-Erstellung"></a> </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Backup-Wiederherstellung</b> <div class="spoiler_text"><p> <a href=""><img src="https://habrastorage.org/webt/gj/9f/w0/gj9fw0onqw7f0lf7ycw05aphinc.png" title="Backup-Wiederherstellung"></a> </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Verwalten Sie erstellte Backups</b> <div class="spoiler_text"><p> <a href=""><img src="https://habrastorage.org/webt/sy/jz/y6/syjzy68wqxgi8smgq74giqstgu0.png" title="Liste der erstellten Backups"></a> </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Regelm√§√üige Sicherungen</b> <div class="spoiler_text"><p> <a href=""><img src="https://habrastorage.org/webt/hk/pw/tg/hkpwtg3kf7c5ho3f7ae7_uos7v0.png" title="Erstellen Sie eine regelm√§√üige Aufgabe"></a> </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Verfolgen Sie laufende Aufgaben</b> <div class="spoiler_text"><p> <a href=""><img src="https://habrastorage.org/webt/al/dt/su/aldtsuel4amtjlvbbbusccxddh0.png" title="Liste der laufenden Aufgaben"></a> </p></div></div><br><hr><br><h2 id="arhitektura">  Architektur </h2><br><p>  Die Hauptarbeit wird in 3 Diensten stattfinden - <em>DatabaseBackup</em> , <em>Prozessor</em> , <em>Speicher</em> , und wir werden sie unter Verwendung <em>des Aufgabenkonzepts miteinander verbinden</em> .  √úber all das weiter. </p><br><h3 id="databasebackup">  Datenbanksicherung </h3><br><p>  Dieser Dienst ist f√ºr das Erstellen und Wiederherstellen von Klartextsicherungen verantwortlich. </p><br><p>  Serviceschnittstelle: </p><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DatabaseBackup</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">InputStream </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createBackup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DatabaseSettings databaseSettings, Integer id)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">restoreBackup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(InputStream in, DatabaseSettings databaseSettings, Integer id)</span></span></span></span>; }</code> </pre> <br><p>  Beide Schnittstellenmethoden arbeiten mit <strong>InputStream-</strong> Instanzen, da die gesamte Sicherung nicht in den Speicher geladen werden muss. Dies bedeutet, dass die Sicherung im Streaming-Modus gelesen / geschrieben werden muss.  Die <em>DatabaseSettings-</em> Entit√§t wird √ºber die Web-Benutzeroberfl√§che vorab erstellt und speichert die verschiedenen Einstellungen, die f√ºr den Zugriff auf die Datenbank erforderlich sind.  Was ist dieser Parameter - <code>id</code> - wird etwas weiter erkl√§rt. </p><br><p>  Die Serviceanforderungen lauten wie folgt: </p><br><ol><li>  Beide Methoden sollten nicht die gesamte Sicherung in den Speicher lesen. </li><li>  Die Methode <code>restoreBackup()</code> sollte die Sicherung in einer einzelnen Transaktion wiederherstellen, damit die Datenbank im Fehlerfall nicht in einem inkonsistenten Zustand <code>restoreBackup()</code> . </li></ol><br><div class="spoiler">  <b class="spoiler_title">Implementierung f√ºr PostgreSQL (Textbeschreibung)</b> <div class="spoiler_text"><p>  Insbesondere in der Implementierung f√ºr PostgreSQL wird der Dienst wie folgt implementiert: </p><br><ol><li>  <code>createBackup()</code> : Es wird ein <em>pg_dump-</em> Prozess erstellt, der ein Backup erstellt und in den Standardausgabestream schreibt.  Der Standardprozessausgabestream wird von der Methode zur√ºckgegeben (siehe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://docs.oracle.com/javase/8/docs/api/java/lang/Process.html#getInputStream--</a> ).  Die E / A-Streams im System basieren auf einem Puffer einer bestimmten Gr√∂√üe. Wenn ein Prozess in den Ausgabestream schreibt, schreibt er tats√§chlich in den Puffer im Speicher.  Das Wichtigste dabei ist, dass der Prozessthread erst dann in den <em>gef√ºllten</em> Puffer schreibt, wenn dieser von der anderen Seite gelesen wurde. Dies bedeutet, dass sich der Thread in einem gesperrten Zustand befindet und die Sicherung nicht vollst√§ndig in den Speicher geladen wird.  M√∂glicherweise ist Ihr Java-Programm bei der Arbeit mit Prozessen festgefahren, weil Sie das stdout oder stderr des Prozesses nicht gelesen haben.  Es ist √§u√üerst wichtig, dies zu √ºberwachen, da der Prozess nicht fortgesetzt werden kann, wenn er bei einem E / A-Blockierungsaufruf beim Schreiben in einen vollst√§ndigen Puffer blockiert wird und niemand diesen Puffer liest. </li><li>  <code>restoreBackup()</code> : Ein <em>psql-</em> Prozess wird erstellt, die Sicherung wird aus dem an die Methode √ºbergebenen <code>restoreBackup()</code> gelesen und gleichzeitig in den psql-Standardeingabestream geschrieben (siehe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://docs.oracle.com/javase/8/docs/api/java/lang/Process). html # getOutputStream--</a> ).  Dies funktioniert, da die PostgreSQL-Sicherung im Klartext nur eine Sammlung von DDL- und DML-Befehlen ist, die leicht verst√§ndlich sind. </li></ol><br><p>  Es gibt viel Code, daher werde ich ihn hier nicht weitergeben, aber Sie k√∂nnen GitHub √ºber den Link am Ende des Artikels ansehen. </p></div></div><br><h3 id="processor">  Prozessor </h3><br><p>  Dieser Service ist f√ºr die Verwendung von Prozessoren und die Wiederaufbereitung von Reverse Backups verantwortlich.  Prozessoren werden vor dem Herunterladen in den Speicher oder nach dem Entladen aus dem Speicher verwendet.  Prozessorbeispiel: Kompressor, Verschl√ºsselung. </p><br><p>  Serviceschnittstelle: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Processor</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">InputStream </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(InputStream in)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">InputStream </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deprocess</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(InputStream in)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">ProcessorType </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getType</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// ProcessorType -  Enum,     int getPrecedence(); //   }</span></span></code> </pre> <br><p>  Jeder Prozessor hat Priorit√§t. Wenn mehrere Prozessoren angegeben sind, werden diese in absteigender Reihenfolge der Priorit√§t angewendet.  Wenn Sie die Umkehrfunktion in derselben Reihenfolge anwenden, in der die Prozessoren angewendet wurden, erhalten Sie die urspr√ºngliche Sicherung. </p><br><h3 id="storage">  Lagerung </h3><br><p>  Dieser Dienst ist f√ºr das Laden und Entladen eines Backups sowie dessen Entfernung aus dem Speicher verantwortlich.  Speicherbeispiel: Dropbox, lokales Dateisystem. </p><br><p>  Serviceschnittstelle: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Storage</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uploadBackup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(InputStream in, StorageSettings storageSettings, String backupName, Integer id)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">InputStream </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">downloadBackup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StorageSettings storageSettings, String backupName, Integer id)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deleteBackup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StorageSettings storageSettings, String backupName, Integer id)</span></span></span></span>; }</code> </pre> <br><p>  Jedem erstellten Backup wird ein eindeutiger Name zugewiesen, sodass wir es in jedem der Speicher finden k√∂nnen, in die es heruntergeladen wurde.  Die Art und Weise, wie die Sicherung dem Speicher pr√§sentiert wird, h√§ngt ausschlie√ülich von der Implementierung des Dienstes ab. Wenn Sie jedoch den Sicherungsnamen auf eine der Funktionen √ºbertragen, sollten Sie das richtige Verhalten erwarten.  Die <em>StorageSettings-</em> Entit√§t wird √ºber die Web-Benutzeroberfl√§che vorab erstellt und speichert die erforderlichen Einstellungen f√ºr den Zugriff auf den Speicher. </p><br><hr><br><h3 id="koncepciya-taskov">  Aufgabenkonzept </h3><br><p>  Wir m√∂chten in der Lage sein, den Status unserer Aufgaben zu verfolgen, m√∂gliche Fehler abh√§ngig vom Fortschritt der Aufgabe zu behandeln und auch Aufgaben abzubrechen.  Daher werden wir weiterhin nur mit Aufgaben arbeiten.  Jede Aufgabe wird in der Datenbank durch einen Datensatz in der Tabelle und programmgesteuert durch die <strong>Future-</strong> Instanz dargestellt (siehe Java <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Future</a> ).  Jeder Datensatz in der Tabelle ist mit einer eigenen Zukunft verkn√ºpft (wenn mehrere Server ausgef√ºhrt werden, k√∂nnen sich zuk√ºnftige Instanzen im Speicher verschiedener Server befinden). </p><br><p>  Lass uns nacheinander gehen.  Zun√§chst ben√∂tigen wir einen Service zum Starten von Aufgaben - Erstellen, Wiederherstellen und L√∂schen von Backups. </p><br><h4 id="zapusk-zadach">  Aufgabenstart </h4><br><p>  <strong>Erstellen eines Backups:</strong> </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">startBackupTask</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull Task.RunType runType, @NotNull List&lt;String&gt; storageSettingsNameList, @Nullable List&lt;ProcessorType&gt; processors, @NotNull DatabaseSettings databaseSettings)</span></span></span><span class="hljs-function"> </span></span>{ Objects.requireNonNull(runType); Objects.requireNonNull(storageSettingsNameList); Objects.requireNonNull(processors); Objects.requireNonNull(databaseSettings); BackupProperties backupProperties = backupPropertiesManager.initNewBackupProperties(storageSettingsNameList, processors, databaseSettings.getName()); Task task = tasksManager.initNewTask(Task.Type.CREATE_BACKUP, runType, backupProperties.getId()); Integer taskId = task.getId(); Future future = tasksStarterExecutorService.submit(() -&gt; { tasksManager.updateTaskState(taskId, Task.State.CREATING); logger.info(<span class="hljs-string"><span class="hljs-string">"Creating backup..."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (InputStream backupStream = databaseBackupManager.createBackup(databaseSettings, taskId)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Thread.interrupted()) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InterruptedException(); } tasksManager.updateTaskState(taskId, Task.State.APPLYING_PROCESSORS); logger.info(<span class="hljs-string"><span class="hljs-string">"Applying processors on created backup. Processors: {}"</span></span>, processors); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (InputStream processedBackupStream = backupProcessorManager.process(backupStream, processors)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Thread.interrupted()) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InterruptedException(); } tasksManager.updateTaskState(taskId, Task.State.UPLOADING); logger.info(<span class="hljs-string"><span class="hljs-string">"Uploading backup..."</span></span>); backupLoadManager.uploadBackup(processedBackupStream, backupProperties, taskId); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Thread.interrupted()) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InterruptedException(); } tasksManager.updateTaskState(taskId, Task.State.COMPLETED); logger.info(<span class="hljs-string"><span class="hljs-string">"Creating backup completed. Backup properties: {}"</span></span>, backupProperties); } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (IOException ex) { logger.error(<span class="hljs-string"><span class="hljs-string">"Error occurred while closing input stream of created backup"</span></span>, ex); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (RuntimeException ex) { logger.error(<span class="hljs-string"><span class="hljs-string">"Error occurred while creating backup. Backup properties: {}"</span></span>, backupProperties, ex); errorTasksManager.addErrorTask(taskId); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (InterruptedException ex) { tasksManager.setInterrupted(taskId); logger.error(<span class="hljs-string"><span class="hljs-string">"Backup creating task was interrupted. Task ID: {}"</span></span>, taskId); } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { futures.remove(taskId); } }); futures.put(taskId, future); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> task; }</code> </pre> <br><p>  Das Erstellen eines Backups durchl√§uft drei Hauptschritte in der folgenden Reihenfolge: Erstellen eines Backups -&gt; Anwendung von Prozessoren -&gt; Hochladen in den Speicher.  Bei fast allen Dienstmethoden leiten wir die ID der aktuellen Aufgabe weiter, damit der Dienst einen Fehler von einem Thread melden kann, der im Hintergrund arbeitet.  √úber die Fehlerbehandlung, warum <em>InterruptedException</em> hier ist und was mit einem Fehler nach Erhalt einer <em>RuntimeException passiert,</em> wird sp√§ter erl√§utert. </p><br><p>  Und so f√ºhren wir die Aufgabe aus, ein Backup zu erstellen: </p><br><pre> <code class="java hljs">tasksStarterService.startBackupTask(Task.RunType.USER, storageSettingsNameList, processors, databaseSettings);</code> </pre> <br><p>  Der erste Parameter, den wir an den Initiator der Aufgabe √ºbergeben: der Benutzer oder die interne Serveraufgabe (ein Beispiel f√ºr eine interne Aufgabe ist eine regelm√§√üige Sicherung).  Das Wissen des Aufgabeninitiators erm√∂glicht es uns, in der Web-Benutzeroberfl√§che nur die Aufgaben anzuzeigen, die vom Benutzer gestartet wurden.  Die verbleibenden Parameter sind erforderlich, um eine Sicherung direkt zu erstellen - eine Liste der Speicher, der zu verwendenden Prozessoren und einer Datenbank, deren Speicherauszug Sie erstellen m√ºssen. </p><br><p>  Beim Erstellen einer Sicherung wird auch ein Datensatz in der Datenbank mit dem Namen <strong>BackupProperties erstellt</strong> .  Diese Entit√§t speichert Sicherungseigenschaften wie den Namen, die verwendeten Prozessoren und die Liste der Repositorys, in die die Sicherung heruntergeladen wurde.  Um die Sicherung wiederherzustellen oder zu l√∂schen, arbeiten wir mit dieser bestimmten Entit√§t. </p><br><p>  Die Aufgabe in der Datenbank wird in folgender Form gespeichert: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-meta"><span class="hljs-meta">@Table</span></span>(name = <span class="hljs-string"><span class="hljs-string">"backup_tasks"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Task</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * Identifier of each backup task. Identifier is generated by PostgreSQL database after saving of entity. */</span></span> <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> <span class="hljs-meta"><span class="hljs-meta">@Column</span></span>(insertable = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, updatable = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) <span class="hljs-meta"><span class="hljs-meta">@GeneratedValue</span></span>(strategy = GenerationType.IDENTITY) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Integer id; <span class="hljs-comment"><span class="hljs-comment">/** * Backup task type. * &lt;p&gt; * Type is set at the very start of any task and can't be changed. * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@see</span></span></span><span class="hljs-comment"> Type */</span></span> <span class="hljs-meta"><span class="hljs-meta">@Enumerated</span></span>(EnumType.STRING) <span class="hljs-meta"><span class="hljs-meta">@Column</span></span>(updatable = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Type type; <span class="hljs-comment"><span class="hljs-comment">/** * Who initiated a task: user or server. * &lt;p&gt; * We need to know it to show on front only these tasks that was started by user. * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@see</span></span></span><span class="hljs-comment"> RunType */</span></span> <span class="hljs-meta"><span class="hljs-meta">@Enumerated</span></span>(EnumType.STRING) <span class="hljs-meta"><span class="hljs-meta">@Column</span></span>(updatable = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> RunType runType; <span class="hljs-comment"><span class="hljs-comment">/** * Backup task state. * &lt;p&gt; * State is updated with every new step in task being executed. * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@see</span></span></span><span class="hljs-comment"> Task.State */</span></span> <span class="hljs-meta"><span class="hljs-meta">@Enumerated</span></span>(EnumType.STRING) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> State state; <span class="hljs-comment"><span class="hljs-comment">/** * Whether task has been interrupted or not. * &lt;p&gt; * Default is {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@literal</span></span></span><span class="hljs-comment"> false}. */</span></span> <span class="hljs-meta"><span class="hljs-meta">@Column</span></span>(insertable = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> interrupted; <span class="hljs-comment"><span class="hljs-comment">/** * Identifier of {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@link</span></span></span><span class="hljs-comment"> BackupProperties}. * &lt;p&gt; * We need to know backup ID to be able to handle occurred errors. */</span></span> <span class="hljs-meta"><span class="hljs-meta">@Column</span></span>(updatable = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Integer backupPropertiesId; <span class="hljs-comment"><span class="hljs-comment">/** * Start time of the task. */</span></span> <span class="hljs-meta"><span class="hljs-meta">@Column</span></span>(updatable = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> LocalDateTime date; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> RunType { USER, INTERNAL } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> State { PLANNED, CREATING, RESTORING, DELETING, APPLYING_PROCESSORS, APPLYING_DEPROCESSORS, DOWNLOADING, UPLOADING, COMPLETED, } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Type { CREATE_BACKUP { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"CREATE BACKUP"</span></span>; } }, RESTORE_BACKUP { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"RESTORE BACKUP"</span></span>; } }, DELETE_BACKUP { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"DELETE BACKUP"</span></span>; } } } <span class="hljs-comment"><span class="hljs-comment">// getters &amp; setters... }</span></span></code> </pre> <br><p>  So k√∂nnen Sie den Vorgang des Erstellens eines Backups in Form eines Diagramms wie folgt beschreiben: <br><img src="https://habrastorage.org/webt/bm/um/cy/bmumcyhyapjg4ono73qo8kiquom.png" alt="Sicherungsprozess" title="Sicherstellen"></p><br><hr><br><p>  Andere Arten von Aufgaben werden analog gestartet.  Um den Artikel nicht mit einer gro√üen Menge an Code zu √ºberladen, werde ich den Neugierigen den Code zum Starten von Aufgaben zum Wiederherstellen und L√∂schen von Backups separat im Spoiler geben. </p><br><div class="spoiler">  <b class="spoiler_title">Backup-Wiederherstellung</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">startRestoreTask</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull Task.RunType runType, @NotNull BackupProperties backupProperties, @NotNull String storageSettingsName, @NotNull DatabaseSettings databaseSettings)</span></span></span><span class="hljs-function"> </span></span>{ Objects.requireNonNull(runType); Objects.requireNonNull(backupProperties); Objects.requireNonNull(storageSettingsName); Objects.requireNonNull(databaseSettings); Task task = tasksManager.initNewTask(Task.Type.RESTORE_BACKUP, runType, backupProperties.getId()); Integer taskId = task.getId(); Future future = tasksStarterExecutorService.submit(() -&gt; { tasksManager.updateTaskState(taskId, Task.State.DOWNLOADING); logger.info(<span class="hljs-string"><span class="hljs-string">"Downloading backup..."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (InputStream downloadedBackup = backupLoadManager.downloadBackup(backupProperties.getBackupName(), storageSettingsName, taskId)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Thread.interrupted() || downloadedBackup == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InterruptedException(); } tasksManager.updateTaskState(taskId, Task.State.APPLYING_DEPROCESSORS); logger.info(<span class="hljs-string"><span class="hljs-string">"Deprocessing backup..."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (InputStream deprocessedBackup = backupProcessorManager.deprocess(downloadedBackup, backupProperties.getProcessors())) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Thread.interrupted()) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InterruptedException(); } tasksManager.updateTaskState(taskId, Task.State.RESTORING); logger.info(<span class="hljs-string"><span class="hljs-string">"Restoring backup..."</span></span>); databaseBackupManager.restoreBackup(deprocessedBackup, databaseSettings, taskId); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Thread.interrupted()) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InterruptedException(); } tasksManager.updateTaskState(taskId, Task.State.COMPLETED); logger.info(<span class="hljs-string"><span class="hljs-string">"Restoring backup completed. Backup properties: {}"</span></span>, backupProperties); } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (IOException ex) { logger.error(<span class="hljs-string"><span class="hljs-string">"Error occurred while closing input stream of downloaded backup"</span></span>, ex); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (RuntimeException ex) { logger.info(<span class="hljs-string"><span class="hljs-string">"Error occurred while restoring backup. Backup properties: {}"</span></span>, backupProperties, ex); errorTasksManager.addErrorTask(taskId); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (InterruptedException ex) { tasksManager.setInterrupted(taskId); logger.error(<span class="hljs-string"><span class="hljs-string">"Task was interrupted. Task ID: {}"</span></span>, taskId); } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { futures.remove(taskId); } }); futures.put(taskId, future); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> task; }</code> </pre> <br><p>  Das Wiederherstellen einer Sicherung durchl√§uft drei Hauptschritte in der folgenden Reihenfolge: Entladen einer Sicherung aus dem Speicher -&gt; Verwenden von Deprozessoren zum Abrufen der urspr√ºnglichen Klartextsicherung -&gt; Wiederherstellen einer Sicherung. </p><br><p>  Starten Sie die Wiederherstellung wie folgt: </p><br><pre> <code class="java hljs">tasksStarterService.startRestoreTask(Task.RunType.USER, backupProperties, storageSettingsName, databaseSettings);</code> </pre> <br><p>  Der Vorgang des Wiederherstellens einer Sicherung in Form eines Diagramms: <br><img src="https://habrastorage.org/webt/hr/_m/bk/hr_mbkvfkszhyhj6ebi1q_wa1nc.png" alt="  " title="Backup-Wiederherstellungsprozess"></p></div></div><br><div class="spoiler">  <b class="spoiler_title">Backup l√∂schen</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">startDeleteTask</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull Task.RunType runType, @NotNull BackupProperties backupProperties)</span></span></span><span class="hljs-function"> </span></span>{ Objects.requireNonNull(runType); Objects.requireNonNull(backupProperties); Task task = tasksManager.initNewTask(Task.Type.DELETE_BACKUP, runType, backupProperties.getId()); Integer taskId = task.getId(); Future future = tasksStarterExecutorService.submit(() -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { logger.info(<span class="hljs-string"><span class="hljs-string">"Deleting backup started. Backup properties: {}"</span></span>, backupProperties); tasksManager.updateTaskState(taskId, Task.State.DELETING); backupLoadManager.deleteBackup(backupProperties, taskId); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Thread.interrupted()) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InterruptedException(); } tasksManager.updateTaskState(taskId, Task.State.COMPLETED); logger.info(<span class="hljs-string"><span class="hljs-string">"Deleting backup completed. Backup properties: {}"</span></span>, backupProperties); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (RuntimeException ex) { logger.error(<span class="hljs-string"><span class="hljs-string">"Error occurred while deleting backup. Backup properties: {}"</span></span>, backupProperties, ex); errorTasksManager.addErrorTask(taskId); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (InterruptedException ex) { tasksManager.setInterrupted(taskId); logger.error(<span class="hljs-string"><span class="hljs-string">"Task was interrupted. Task ID: {}"</span></span>, taskId); } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { futures.remove(taskId); } }); futures.put(taskId, future); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> task; }</code> </pre> <br><p>  Das L√∂schen eines Backups ist ganz einfach: Ein Backup wird einfach aus allen Speichern gel√∂scht, in die es heruntergeladen wurde. </p><br><p>  F√ºhren Sie die Deinstallation wie folgt aus: </p><br><pre> <code class="java hljs">tasksStarterService.startDeleteTask(Task.RunType.USER, backupProperties);</code> </pre> <br><p>  Der Vorgang des L√∂schens einer Sicherung in Form eines Diagramms: <br><img src="https://habrastorage.org/webt/y4/ca/yp/y4cayp76w4v0tx8umvzcp6flzd4.png" alt="  " title="Backup-Entfernungsprozess"></p></div></div><br><hr><br><h3 id="otmena-taskov">  Aufgabe abbrechen </h3><br><p>  Was ist Aufgabenabbruch?  Dies ist nat√ºrlich nichts anderes als eine Thread-Beendigung.  Sie konnten sehen, dass der gesamte in Future ausgef√ºhrte Hauptcode in das folgende Try-Catch-Konstrukt eingeschlossen ist: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { ... } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (InterruptedException ex) { ... tasksManager.setInterrupted(taskId); }</code> </pre> <br><p>  Und auch nach jeder wichtigen Methode, deren Ausf√ºhrungsfluss wir steuern, wird die folgende Konstruktion installiert: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Thread.interrupted()) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InterruptedException(); }</code> </pre> <br><p>  Bevor Sie fortfahren, sollte eine kurze Theorie der Unterbrechungen und Zust√§nde von JVM-Threads gegeben werden. </p><br><p>  Threads in der JVM k√∂nnen den folgenden Status haben: </p><br><ol><li>  Neu </li><li>  Runnable </li><li>  Zeitgesteuertes Warten </li><li>  Warten </li><li>  Blockiert </li><li>  Beendet </li></ol><br><p>  Wir sind nur an den Wartezust√§nden und zeitgesteuerten Wartezust√§nden interessiert.  Der <code>Object.wait()</code> durch die Methoden <code>Object.wait()</code> , <code>Thread.join()</code> und andere in den Status <em>Warten versetzt</em> .  Der Thread wird unter Verwendung der Methoden <code>Object.wait(timeout)</code> , <code>Thread.join(timeout)</code> , <code>Thread.sleep(sleeping)</code> und anderer in den <em>zeitgesteuerten</em> Wartezustand (d. H. Eine Wartezeit, die einen bestimmten Zeitraum dauert <code>Thread.sleep(sleeping)</code> . </p><br><p>  Das Wichtigste dabei ist, dass der Thread aufwacht und eine <strong>InterruptedException</strong> ausl√∂st, wenn Sie den Thread unterbrechen, <em>bevor Sie in den</em> Wartezustand oder den zeitgesteuerten Wartezustand wechseln, oder wenn sich der Thread <em>in diesem Zustand</em> befindet. </p><br><p>  Das ist aber noch nicht alles.  Es ist √ºberhaupt keine Tatsache, dass ein Thread jemals in Statusdaten wechselt, indem er ein Backup erstellt, wiederherstellt oder l√∂scht.  Wie kann man dann den Thread dar√ºber informieren, dass er unterbrochen wurde? </p><br><p>  Die erste M√∂glichkeit besteht darin, das Interrupt-Flag mit dem Thread unabh√§ngig mit den Methoden Thread.interrupted <code>Thread.interrupted()</code> oder <code>Thread.currentThread.isInterrupted()</code> .  Der Unterschied zwischen ihnen besteht darin, dass der erste die private native Methode <code>currentThread.isInterrupted(boolean ClearInterrupted)</code> , wobei <code>true</code> , um <code>currentThread.isInterrupted(boolean ClearInterrupted)</code> , dass das Interrupt-Flag gel√∂scht wird, und der zweite <code>false</code> , wobei das Interrupt-Flag intakt bleibt.  Die Wahl zwischen diesen beiden Methoden h√§ngt ganz von der Situation ab.  Wenn eine InterruptedException ausgel√∂st wird, wird auch das Interrupt-Flag gel√∂scht - dies ist zu beachten. </p><br><p>  Aber es muss einen Weg geben, der einfacher ist - und das ist es auch.  In der Anwendung gibt es eine Menge Arbeit mit E / A-Streams und daher mit E / A-Methoden.  Unsere Aufgabe ist es sicherzustellen, dass beim Aufrufen der Methoden <code>read()</code> oder <code>write(int b)</code> im E / A-Stream w√§hrend der Unterbrechung ein Fehler ausgegeben wird, der darauf hinweist, dass der blockierende E / A-Aufruf unterbrochen wurde.  Gl√ºcklicherweise hat Java eine solche Ausnahme - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">InterruptedIOException</a> .  Allerdings √ºberwachen nicht alle Lese- / Schreib-Stream-Methoden Thread-Unterbrechungen, und speziell nur <em>PipedInputStream</em> √ºberwacht sie.  Daher m√ºssen wir an den Stellen, an denen dieser Stream nicht beteiligt ist, die Lese- / Schreibmethode so erweitern, dass bei einem Interrupt eine InterruptedIOException ausgel√∂st wird.  Tats√§chlich war die Erweiterung der read () -Methode f√ºr mich in der Anwendung nur an einer Stelle ausreichend - als der InputStream von der Backup-Upload-Methode zur√ºckkehrte.  Auf diese Weise k√∂nnen wir den Ursprung eines Interrupts ermitteln, ohne dass das Flag √ºberall mit Vorlagenpr√ºfungen versehen werden muss.  Es ist jedoch wichtig, diese Ausnahme getrennt von der IOException abzufangen und separat zu behandeln.  Nat√ºrlich kann man an einigen Stellen nicht auf die Hilfe einer Vorlagenpr√ºfung der Flagge verzichten, aber sie ist bereits besser geworden. </p><br><p>  Es ist auch wichtig zu beachten, dass, wenn das Flag w√§hrend der Interrupt-Verarbeitung gel√∂scht wurde, das Interrupt-Flag immer wieder gesetzt werden muss, damit wir nach der R√ºckkehr von der Methode herausfinden k√∂nnen, welcher Interrupt aufgetreten ist. </p><br><p>  Lassen Sie mich anhand eines Beispiels erkl√§ren, warum dies wichtig ist.  Angenommen, wir laden mit der Methode upload () ein Backup in den Speicher hoch und es tritt ein Interrupt auf.  Der Interrupt wird verarbeitet, die Arbeit gestoppt und die Methode zur√ºckgegeben.  Eine Unterbrechung tritt nicht gelegentlich auf - dies bedeutet, dass entweder irgendwo ein Fehler aufgetreten ist oder der Benutzer die Aufgabe abgebrochen hat.  Unabh√§ngig vom Grund m√ºssen wir alle Arbeiten in dieser Zukunft einstellen.  Wenn Sie das Interrupt-Flag jedoch nicht erneut setzen, bevor Sie von der Startmethode zur√ºckkehren, werden wir im Future-Hauptblock nie erfahren, welcher Interrupt aufgetreten ist. <br>  Das gleiche Codebeispiel: </p><br><pre> <code class="java hljs">backupLoadManager.uploadBackup(processedBackupStream, backupProperties, taskId); &lt;-   ,       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Thread.interrupted()) { <span class="hljs-comment"><span class="hljs-comment">//      ,      - ,    throw new InterruptedException(); }</span></span></code> </pre> <br><p>  Daher empfiehlt es sich, eine <strong>InterruptedException</strong> oder <strong>InterruptedIOException</strong> wie folgt zu behandeln: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { ... } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (InterruptedException e) { <span class="hljs-comment"><span class="hljs-comment">//  InterruptedIOException ... // re-interrupt the thread Thread.currentThread().interrupt(); }</span></span></code> </pre> <br><p>  Nun, wir k√∂nnen mit Unterbrechungen umgehen, aber wer wird die Threads tats√§chlich unterbrechen? <br>  Zu diesem <em>Zweck</em> erstellen wir eine weitere Entit√§t namens <em>CancelTask</em> , in der die ID der Aufgabe zum <em>Abbrechen gespeichert</em> wird, und schreiben eine <em>√úberwachung</em> , die versucht, die Aufgaben zu unterbrechen.  Warum versuchen?  Weil: </p><br><ol><li>  Der Thread im Speicher eines anderen Servers kann nicht beendet werden.  F√ºr uns k√∂nnen mehrere Server arbeiten, was bedeutet, dass Future auf verschiedene Server verteilt ist.  Wenn also eine Anforderung zum Abbrechen einer Aufgabe auf einem der Server eintrifft, befindet sich die gew√ºnschte Zukunft m√∂glicherweise im Speicher eines anderen Servers. </li><li>  Die Aufgabe kann nicht abgebrochen werden, da Future aufgrund eines Serverabsturzes verloren gegangen ist. </li></ol><br><p>  Beschreiben Sie kurz den Stornierungsalgorithmus am Abend: <br>  Watercher nimmt alle Datens√§tze aus der Tabelle <em>cancel_tasks heraus</em> (die Sperre wird nicht gleichzeitig gesetzt), geht jeden einzelnen durch und versucht, die entsprechende Zukunft aus seinem Speicher <em>abzurufen</em> .  Wenn Future erfolgreich empfangen wurde, wird der entsprechende Thread unterbrochen, die Aufgabe zur√ºckgesetzt und die Anforderung aus der Tabelle gel√∂scht.  Wenn die Timeout-Anforderung zum Abbrechen der Aufgabe √ºberschritten wird (was bedeutet, dass der Server abgest√ºrzt ist und Future verloren gegangen ist), wird die Anforderung einfach aus der Tabelle gel√∂scht.  Wenn mehrere Server eine Zeit√ºberschreitung feststellen und den Datensatz aus der Tabelle l√∂schen, geschieht nichts Schlimmes, da das L√∂schen in PostgreSQL idempotent ist. </p><br><p>  <strong>CancelTasksWatcher-Code:</strong> </p><br><div class="spoiler">  <b class="spoiler_title">Versteckter Text</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/** * This class scans for tasks to cancel and tries to cancel them. */</span></span> <span class="hljs-meta"><span class="hljs-meta">@Component</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CancelTasksWatcher</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Logger logger = LoggerFactory.getLogger(CancelTasksWatcher.class); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Duration cancelTimeout = Duration.ofMinutes(<span class="hljs-number"><span class="hljs-number">10</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> CancelTasksManager cancelTasksManager; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> TasksStarterService tasksStarterService; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> TasksManager tasksManager; <span class="hljs-comment"><span class="hljs-comment">// spring setters... /** * This watcher wakes up every time 10 seconds passed from the last completion, checks if there are any tasks to cancel and tries to * cancel each task. * &lt;p&gt; * Since there are can be working more that one instance of the program, {@literal Future} instance of task can belong to different * servers. We can't get access to {@literal Future} if it's not in memory of the server where task cancellation request was accepted. * So the purpose of this watcher is to be able cancel tasks that works in the other instance of program. Each server has this watcher * checking for available cancellation requests and if any, the watcher tries to cancel corresponding {@literal Future}. * If cancellation is successful task will be also reverted. * &lt;p&gt; * If task cancellation request timeout exceeded, then it means a server that had requested {@literal Future} instances has been * shutdown, so all {@literal Future} instances lost and task can't be canceled. In such case task cancellation request will be ignored. * * @see TasksStarterService#getFuture(Integer) * @see TasksManager#revertTask(Task) */ @Scheduled(fixedDelay = 10 * 1000) @Transactional(isolation = Isolation.READ_COMMITTED, propagation = Propagation.REQUIRES_NEW) public void watchTasksToCancel() { Iterable&lt;CancelTask&gt; cancelTasks = cancelTasksManager.findAll(); Iterable&lt;Task&gt; tasks = tasksManager.findAllById(StreamSupport.stream(cancelTasks.spliterator(), false) .map(CancelTask::getTaskId).collect(Collectors.toList())); Map&lt;Integer, Task&gt; tasksAsMap = StreamSupport.stream(tasks.spliterator(), false) .collect(Collectors.toMap(Task::getId, Function.identity())); List&lt;Integer&gt; taskIdsForDeleting = new ArrayList&lt;&gt;(); for (CancelTask cancelTask : cancelTasks) { Integer taskId = cancelTask.getTaskId(); Task task = tasksAsMap.get(taskId); if (task == null) { logger.error("Can't cancel task: no such entity with ID {}", taskId); taskIdsForDeleting.add(taskId); continue; } // timeout exceeded, that is server shutdown and lost all Future instances, so task can't be canceled if (LocalDateTime.now(ZoneOffset.UTC).isAfter(cancelTask.getPutTime().plus(cancelTimeout))) { logger.error("Can't cancel task: timeout exceed. Task ID: {}", taskId); taskIdsForDeleting.add(taskId); continue; } tasksStarterService.getFuture(taskId).ifPresent(future -&gt; { logger.info("Canceling task with ID {}", taskId); boolean canceled = future.cancel(true); if (canceled) { try { // give time to properly handle interrupt Thread.sleep(10000); } catch (InterruptedException e) { // should not happen } tasksManager.revertTask(task); } taskIdsForDeleting.add(taskId); logger.info("Task canceled: {}. Task ID: {}", canceled, taskId); }); } cancelTasksManager.deleteByTaskIdIn(taskIdsForDeleting); } }</span></span></code> </pre> </div></div><br><hr><br><h4 id="obrabotka-oshibok">  Fehlerbehandlung </h4><br><p>  Oben sehen Sie, dass der gesamte in Future ausgef√ºhrte Hauptcode in das folgende Try-Catch-Konstrukt eingeschlossen ist: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { ... } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (RuntimeException e) { ... errorTasksManager.addErrorTask(taskId); }</code> </pre> <br><p>     <em>RuntimeException</em>   ,     Future  ,         . </p><br><p>  <code>addErrorTask(taskId)</code>        ,   ID ,    . <br>      ?       ,    ,        ,   . </p><br><p>      : <br>                  ,        ,       .  ‚Äî  PostgreSQL <code>select for update</code> ,   select   <code>skip locked</code>      . ,  ,    <code>revertTask()</code> ,               . </p><br><p> <strong> ErrorTasksWatcher</strong> : </p><br><div class="spoiler">  <b class="spoiler_title">Versteckter Text</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/** * This class scans for erroneous tasks and handles them depending on their state. */</span></span> <span class="hljs-meta"><span class="hljs-meta">@Component</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ErrorTasksWatcher</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Logger logger = LoggerFactory.getLogger(ErrorTasksWatcher.class); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Integer nRows = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> TasksManager tasksManager; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ErrorTasksManager errorTasksManager; <span class="hljs-comment"><span class="hljs-comment">// spring setters... /** * This watcher wakes up every time 1 minute passed from the last completion, checks backup states periodically and handles erroneous * tasks if any. * &lt;p&gt; * The watcher handles at most N tasks as described by {@link #nRows} constant and skips already locked tasks. * When retrieving error tasks from database pessimistic lock is set. It allows safely run more than one copy of program, as no other * watcher can pick up already being handled error tasks. * &lt;p&gt; * If the server shutdowns while rows was locked, transaction will be rolled back and lock released, so these entities can be picked * up by the other running server. */ @Scheduled(fixedDelay = 60 * 1000) @Transactional(isolation = Isolation.READ_COMMITTED, propagation = Propagation.REQUIRES_NEW) public void watchErrorTasks() { for (ErrorTask errorTask : errorTasksManager.findFirstNAndLock(nRows)) { if (!errorTask.isErrorHandled()) { Integer backupTaskId = errorTask.getTaskId(); Optional&lt;Task&gt; optionalTask = tasksManager.findById(backupTaskId); if (!optionalTask.isPresent()) { logger.info("Can't handle erroneous task: no corresponding backup task entity. Backup task ID: {}", backupTaskId); continue; } tasksManager.revertTask(optionalTask.get()); errorTask.setErrorHandled(true); } } } }</span></span></code> </pre> </div></div><br><p> <strong> <code>revertTask(Task)</code> :</strong> </p><br><div class="spoiler">  <b class="spoiler_title">Versteckter Text</b> <div class="spoiler_text"><pre> <code class="java hljs"> <span class="hljs-comment"><span class="hljs-comment">/** * This function reverts erroneous task by its entity. * &lt;p&gt; * Use this function only after canceling related {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@literal</span></span></span><span class="hljs-comment"> Future}. * &lt;p&gt; * If the task was of the type {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@link</span></span></span><span class="hljs-comment"> Task.Type#CREATE_BACKUP} then related {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@link</span></span></span><span class="hljs-comment"> BackupProperties} will be deleted. * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> task the entity */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">revertTask</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull Task task)</span></span></span><span class="hljs-function"> </span></span>{ Objects.requireNonNull(task); Task.State state = task.getState(); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (state) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> DOWNLOADING: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> APPLYING_DEPROCESSORS: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> RESTORING: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> DELETING: { logger.info(<span class="hljs-string"><span class="hljs-string">"Handling broken operation. Operation: {}. No extra actions required"</span></span>, state.toString()); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CREATING: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> APPLYING_PROCESSORS: { logger.info(<span class="hljs-string"><span class="hljs-string">"Handling broken operation. Operation: {}. Delete backup properties..."</span></span>, state.toString()); Integer backupPropertiesID = task.getBackupPropertiesId(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!backupPropertiesManager.existsById(backupPropertiesID)) { logger.error(<span class="hljs-string"><span class="hljs-string">"Can't revert task: no related backup properties. Task info: {}"</span></span>, task); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } backupPropertiesManager.deleteById(backupPropertiesID); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> UPLOADING: { logger.info(<span class="hljs-string"><span class="hljs-string">"Handling broken operation. Operation: {}. Deleting backup from storage..."</span></span>, state); Integer backupPropertiesId = task.getBackupPropertiesId(); Optional&lt;BackupProperties&gt; optionalBackupProperties = backupPropertiesManager.findById(backupPropertiesId); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!optionalBackupProperties.isPresent()) { logger.error(<span class="hljs-string"><span class="hljs-string">"Can't revert task: no related backup properties. Task info: {}"</span></span>, task); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } tasksStarterService.startDeleteTask(Task.RunType.INTERNAL, optionalBackupProperties.get()); backupPropertiesManager.deleteById(backupPropertiesId); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: { logger.error(<span class="hljs-string"><span class="hljs-string">"Can't revert task: unknown state. Task info: {}"</span></span>, task); } } }</code> </pre> <br><p>   : </p><br><ol><li>     <em>DOWNLOADING</em> , <em>APPLYING_DEPROCESSORS</em> , <em>RESTORING</em> , <em>DELETING</em> ‚Äî    .      ,       . </li><li>     <em>CREATING</em> , <em>APPLYING_PROCESSORS</em> ‚Äî  ,       .      BackupProperties  ,       ( BackupProperties   Web UI    ). </li><li>     <em>UPLOADING</em> ‚Äî       .        BackupProperties   ,       .       . </li></ol></div></div><br><p> ,    .         ,    ? ,   ,    Future (  1),     ,          InputStream (  2). ,      2,   1            2    ? </p><br><p>  ,     ,    ,       .      Future (    1)     : </p><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull Throwable t, @NotNull Integer taskId)</span></span></span><span class="hljs-function"> </span></span>{ logger.error(<span class="hljs-string"><span class="hljs-string">"Exception caught. Task ID: {}"</span></span>, taskId, t); Optional&lt;Future&gt; optionalFuture = tasksStarterService.getFuture(taskId); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!optionalFuture.isPresent()) { logger.error(<span class="hljs-string"><span class="hljs-string">"Can't cancel the Future of task with ID {}: no such Future instance"</span></span>, taskId); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> canceled = optionalFuture.get().cancel(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!canceled) { logger.error(<span class="hljs-string"><span class="hljs-string">"Error canceling the Future of task with ID {}"</span></span>, taskId); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { logger.info(<span class="hljs-string"><span class="hljs-string">"Task canceled. Task ID: {}"</span></span>, taskId); errorTasksManager.setError(taskId); } } }</code> </pre> <br><p>   ,     ,      ID  ,   ,    Future   -  ,  ID     . </p><br><p>    ,          ,     ,     ,         ,          . </p><br><p> <strong>  ,   :</strong> </p><br><p> ,   ,        ,    .       ‚Äî       Future. </p><br><p>   ,      ,    ,      I/O ,          ‚Äî     /   .     ,      .       : </p><br><ol><li>  ,  .     ,      ‚Äî     . </li><li>     ‚Äî     Future   ,   .  , /   ,  ,     (  ,     ‚Äî    IOException  ,        ,   ). </li></ol><br><p>  ,   ‚Äî            (   ID       ,  ,    ),        . </p><br><hr><br><p>  ,    ,        .      ,    ,             . </p><br><h3 id="plany-na-buduschee">    </h3><br><ol><li>  Web UI:   ,   .     ,      </li><li>     </li><li>      </li><li>     </li><li>     </li></ol><br><h3 id="zaklyuchenie">  Fazit </h3><br><p>   : </p><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><strong>GitHub</strong></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><strong>Docker Hub</strong></a> </li></ul><br><p>   ,   !           ,       GitHub! <br></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de459478/">https://habr.com/ru/post/de459478/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de459464/index.html">Lua in Moskau 2019: Interview mit Roberto Jerusalem</a></li>
<li><a href="../de459466/index.html">Lua in Moskau 2019: Interview mit Roberto Ierusalimschy</a></li>
<li><a href="../de459470/index.html">Teil 4: Linux l√§uft immer noch unter RISC-V RISC-V</a></li>
<li><a href="../de459472/index.html">Heroku + Docker + Spring Boot</a></li>
<li><a href="../de459474/index.html">So erstellen Sie in einer Sekunde perfekt getippten Text: ein Makro in Word f√ºr diejenigen, die viel schreiben</a></li>
<li><a href="../de459480/index.html">Vivaldi: Wie verdient der Browser Geld?</a></li>
<li><a href="../de459482/index.html">Wie wir den Kategoriebaum besiegt haben</a></li>
<li><a href="../de459484/index.html">Generation Arduino. Was moderne Studenten erfinden</a></li>
<li><a href="../de459488/index.html">Spezielle Spielmodi im Kontext von Roguelike</a></li>
<li><a href="../de459490/index.html">Schmutzige Tricks von CRM-Anbietern: W√ºrden Sie ein Auto ohne R√§der kaufen?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>