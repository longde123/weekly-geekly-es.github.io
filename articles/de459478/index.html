<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕯️ 👨🏻‍🏫 🤟🏼 Meine Erfahrung beim Erstellen einer Multithread-Anwendung für die Arbeit mit Backups 🕉️ 🧚 🧣</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Im Moment werden Sie niemanden mit Multithread-Anwendungen überraschen, aber ich denke, dass Sie in diesem Artikel einige interessante Ideen finden kö...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Meine Erfahrung beim Erstellen einer Multithread-Anwendung für die Arbeit mit Backups</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459478/"><p>  Im Moment werden Sie niemanden mit Multithread-Anwendungen überraschen, aber ich denke, dass Sie in diesem Artikel einige interessante Ideen finden können.  Mein Java-Studium begann mit diesem Projekt. Vielleicht irre ich mich an einigen Stellen sehr oder baue ein großes Fahrrad, aber ich hoffe, dass sich jemand für die Erfahrung eines Anfängers in Java interessiert.  Ich werde einige Funktionen der Anwendung geben: </p><br><ul><li>  Es funktioniert mit Sicherungen ausschließlich im Speicher, unabhängig von der Größe der Sicherung </li><li>  Lädt nicht die gesamte Sicherung in den Speicher </li><li>  Sicherungs- / Wiederherstellungsvorgänge können abgebrochen werden </li></ul><br><p>  Unter dem Schnitt werden die Architektur der Anwendung sowie die aufgetretenen Hauptprobleme und deren Lösung betrachtet. </p><a name="habracut"></a><br><h2 id="obzor-prilozheniya">  Anwendungsübersicht </h2><br><p>  Die Kommunikation mit der Anwendung erfolgt über die Web-Benutzeroberfläche. In Zukunft kann jedoch bei Bedarf eine REST-API hinzugefügt werden. </p><br><p>  Die Anwendung kann: </p><br><ol><li>  Erstellen Sie Backups und laden Sie sie in einen oder mehrere Speicher hoch </li><li>  Stellen Sie Sicherungen wieder her, indem Sie sie aus dem Speicher laden </li><li>  Löschen Sie Backups aus allen Speichern </li><li>  Erstellen Sie regelmäßig Backups </li></ol><br><p>  Derzeit unterstützte Repositorys: </p><br><ul><li>  Lokales Dateisystem (wird von Docker nicht unterstützt) </li><li>  Dropbox </li></ul><br><p>  Derzeit unterstützte Datenbanken: </p><br><ul><li>  PostgreSQL </li></ul><br><p>  Aus einer speziellen Anwendung kann ich Folgendes hervorgehen: </p><br><ol><li>  Richtige Arbeit in einer Clusterkonfiguration </li><li>  Ein Backup wird unabhängig von der Größe des Backups niemals vollständig in den Speicher geladen.  Das Dateisystem für die temporäre Sicherungsspeicherung ist ebenfalls nicht beteiligt.  Sowohl die Erstellung einer Sicherung als auch die Wiederherstellung und damit das Laden / Entladen einer Sicherung erfolgen ausschließlich im Speicher. </li><li>  Plattformübergreifend - funktioniert sowohl unter Windows als auch unter Linux. </li><li>  Wir können alle laufenden Aufgaben überwachen und bei Bedarf abbrechen. </li></ol><br><p>  Unten finden Sie Screenshots der Web-Benutzeroberfläche, in denen die Funktionen der Anwendung klar beschrieben werden. </p><br><div class="spoiler">  <b class="spoiler_title">Speicherverwaltung</b> <div class="spoiler_text"><p> <a href=""><img src="https://habrastorage.org/webt/vl/qg/n5/vlqgn5f58ub5jhxixeeg2uq-oa8.png" title="Speicher hinzufügen"></a> <br> <a href=""><img src="https://habrastorage.org/webt/oj/o5/uj/ojo5uj_raxkwd1btsjrktiowifo.png" title="Speicherliste"></a> </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Datenbankverwaltung</b> <div class="spoiler_text"><p> <a href=""><img src="https://habrastorage.org/webt/wn/6p/bk/wn6pbkcqg4qu_9btgrvnqm3l7x0.png" title="Hinzufügen einer Datenbank"></a> <br> <a href=""><img src="https://habrastorage.org/webt/wu/9a/4k/wu9a4ky7icuiyqdxeiii9xbu5d8.png" title="Liste der Datenbanken"></a> </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Backup-Erstellung</b> <div class="spoiler_text"><p> <a href=""><img src="https://habrastorage.org/webt/1d/zb/6s/1dzb6scvtua5v3m_3l11lch4rgm.png" title="Backup-Erstellung"></a> </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Backup-Wiederherstellung</b> <div class="spoiler_text"><p> <a href=""><img src="https://habrastorage.org/webt/gj/9f/w0/gj9fw0onqw7f0lf7ycw05aphinc.png" title="Backup-Wiederherstellung"></a> </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Verwalten Sie erstellte Backups</b> <div class="spoiler_text"><p> <a href=""><img src="https://habrastorage.org/webt/sy/jz/y6/syjzy68wqxgi8smgq74giqstgu0.png" title="Liste der erstellten Backups"></a> </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Regelmäßige Sicherungen</b> <div class="spoiler_text"><p> <a href=""><img src="https://habrastorage.org/webt/hk/pw/tg/hkpwtg3kf7c5ho3f7ae7_uos7v0.png" title="Erstellen Sie eine regelmäßige Aufgabe"></a> </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Verfolgen Sie laufende Aufgaben</b> <div class="spoiler_text"><p> <a href=""><img src="https://habrastorage.org/webt/al/dt/su/aldtsuel4amtjlvbbbusccxddh0.png" title="Liste der laufenden Aufgaben"></a> </p></div></div><br><hr><br><h2 id="arhitektura">  Architektur </h2><br><p>  Die Hauptarbeit wird in 3 Diensten stattfinden - <em>DatabaseBackup</em> , <em>Prozessor</em> , <em>Speicher</em> , und wir werden sie unter Verwendung <em>des Aufgabenkonzepts miteinander verbinden</em> .  Über all das weiter. </p><br><h3 id="databasebackup">  Datenbanksicherung </h3><br><p>  Dieser Dienst ist für das Erstellen und Wiederherstellen von Klartextsicherungen verantwortlich. </p><br><p>  Serviceschnittstelle: </p><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DatabaseBackup</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">InputStream </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createBackup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DatabaseSettings databaseSettings, Integer id)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">restoreBackup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(InputStream in, DatabaseSettings databaseSettings, Integer id)</span></span></span></span>; }</code> </pre> <br><p>  Beide Schnittstellenmethoden arbeiten mit <strong>InputStream-</strong> Instanzen, da die gesamte Sicherung nicht in den Speicher geladen werden muss. Dies bedeutet, dass die Sicherung im Streaming-Modus gelesen / geschrieben werden muss.  Die <em>DatabaseSettings-</em> Entität wird über die Web-Benutzeroberfläche vorab erstellt und speichert die verschiedenen Einstellungen, die für den Zugriff auf die Datenbank erforderlich sind.  Was ist dieser Parameter - <code>id</code> - wird etwas weiter erklärt. </p><br><p>  Die Serviceanforderungen lauten wie folgt: </p><br><ol><li>  Beide Methoden sollten nicht die gesamte Sicherung in den Speicher lesen. </li><li>  Die Methode <code>restoreBackup()</code> sollte die Sicherung in einer einzelnen Transaktion wiederherstellen, damit die Datenbank im Fehlerfall nicht in einem inkonsistenten Zustand <code>restoreBackup()</code> . </li></ol><br><div class="spoiler">  <b class="spoiler_title">Implementierung für PostgreSQL (Textbeschreibung)</b> <div class="spoiler_text"><p>  Insbesondere in der Implementierung für PostgreSQL wird der Dienst wie folgt implementiert: </p><br><ol><li>  <code>createBackup()</code> : Es wird ein <em>pg_dump-</em> Prozess erstellt, der ein Backup erstellt und in den Standardausgabestream schreibt.  Der Standardprozessausgabestream wird von der Methode zurückgegeben (siehe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://docs.oracle.com/javase/8/docs/api/java/lang/Process.html#getInputStream--</a> ).  Die E / A-Streams im System basieren auf einem Puffer einer bestimmten Größe. Wenn ein Prozess in den Ausgabestream schreibt, schreibt er tatsächlich in den Puffer im Speicher.  Das Wichtigste dabei ist, dass der Prozessthread erst dann in den <em>gefüllten</em> Puffer schreibt, wenn dieser von der anderen Seite gelesen wurde. Dies bedeutet, dass sich der Thread in einem gesperrten Zustand befindet und die Sicherung nicht vollständig in den Speicher geladen wird.  Möglicherweise ist Ihr Java-Programm bei der Arbeit mit Prozessen festgefahren, weil Sie das stdout oder stderr des Prozesses nicht gelesen haben.  Es ist äußerst wichtig, dies zu überwachen, da der Prozess nicht fortgesetzt werden kann, wenn er bei einem E / A-Blockierungsaufruf beim Schreiben in einen vollständigen Puffer blockiert wird und niemand diesen Puffer liest. </li><li>  <code>restoreBackup()</code> : Ein <em>psql-</em> Prozess wird erstellt, die Sicherung wird aus dem an die Methode übergebenen <code>restoreBackup()</code> gelesen und gleichzeitig in den psql-Standardeingabestream geschrieben (siehe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://docs.oracle.com/javase/8/docs/api/java/lang/Process). html # getOutputStream--</a> ).  Dies funktioniert, da die PostgreSQL-Sicherung im Klartext nur eine Sammlung von DDL- und DML-Befehlen ist, die leicht verständlich sind. </li></ol><br><p>  Es gibt viel Code, daher werde ich ihn hier nicht weitergeben, aber Sie können GitHub über den Link am Ende des Artikels ansehen. </p></div></div><br><h3 id="processor">  Prozessor </h3><br><p>  Dieser Service ist für die Verwendung von Prozessoren und die Wiederaufbereitung von Reverse Backups verantwortlich.  Prozessoren werden vor dem Herunterladen in den Speicher oder nach dem Entladen aus dem Speicher verwendet.  Prozessorbeispiel: Kompressor, Verschlüsselung. </p><br><p>  Serviceschnittstelle: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Processor</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">InputStream </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(InputStream in)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">InputStream </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deprocess</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(InputStream in)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">ProcessorType </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getType</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// ProcessorType -  Enum,     int getPrecedence(); //   }</span></span></code> </pre> <br><p>  Jeder Prozessor hat Priorität. Wenn mehrere Prozessoren angegeben sind, werden diese in absteigender Reihenfolge der Priorität angewendet.  Wenn Sie die Umkehrfunktion in derselben Reihenfolge anwenden, in der die Prozessoren angewendet wurden, erhalten Sie die ursprüngliche Sicherung. </p><br><h3 id="storage">  Lagerung </h3><br><p>  Dieser Dienst ist für das Laden und Entladen eines Backups sowie dessen Entfernung aus dem Speicher verantwortlich.  Speicherbeispiel: Dropbox, lokales Dateisystem. </p><br><p>  Serviceschnittstelle: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Storage</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uploadBackup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(InputStream in, StorageSettings storageSettings, String backupName, Integer id)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">InputStream </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">downloadBackup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StorageSettings storageSettings, String backupName, Integer id)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deleteBackup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StorageSettings storageSettings, String backupName, Integer id)</span></span></span></span>; }</code> </pre> <br><p>  Jedem erstellten Backup wird ein eindeutiger Name zugewiesen, sodass wir es in jedem der Speicher finden können, in die es heruntergeladen wurde.  Die Art und Weise, wie die Sicherung dem Speicher präsentiert wird, hängt ausschließlich von der Implementierung des Dienstes ab. Wenn Sie jedoch den Sicherungsnamen auf eine der Funktionen übertragen, sollten Sie das richtige Verhalten erwarten.  Die <em>StorageSettings-</em> Entität wird über die Web-Benutzeroberfläche vorab erstellt und speichert die erforderlichen Einstellungen für den Zugriff auf den Speicher. </p><br><hr><br><h3 id="koncepciya-taskov">  Aufgabenkonzept </h3><br><p>  Wir möchten in der Lage sein, den Status unserer Aufgaben zu verfolgen, mögliche Fehler abhängig vom Fortschritt der Aufgabe zu behandeln und auch Aufgaben abzubrechen.  Daher werden wir weiterhin nur mit Aufgaben arbeiten.  Jede Aufgabe wird in der Datenbank durch einen Datensatz in der Tabelle und programmgesteuert durch die <strong>Future-</strong> Instanz dargestellt (siehe Java <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Future</a> ).  Jeder Datensatz in der Tabelle ist mit einer eigenen Zukunft verknüpft (wenn mehrere Server ausgeführt werden, können sich zukünftige Instanzen im Speicher verschiedener Server befinden). </p><br><p>  Lass uns nacheinander gehen.  Zunächst benötigen wir einen Service zum Starten von Aufgaben - Erstellen, Wiederherstellen und Löschen von Backups. </p><br><h4 id="zapusk-zadach">  Aufgabenstart </h4><br><p>  <strong>Erstellen eines Backups:</strong> </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">startBackupTask</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull Task.RunType runType, @NotNull List&lt;String&gt; storageSettingsNameList, @Nullable List&lt;ProcessorType&gt; processors, @NotNull DatabaseSettings databaseSettings)</span></span></span><span class="hljs-function"> </span></span>{ Objects.requireNonNull(runType); Objects.requireNonNull(storageSettingsNameList); Objects.requireNonNull(processors); Objects.requireNonNull(databaseSettings); BackupProperties backupProperties = backupPropertiesManager.initNewBackupProperties(storageSettingsNameList, processors, databaseSettings.getName()); Task task = tasksManager.initNewTask(Task.Type.CREATE_BACKUP, runType, backupProperties.getId()); Integer taskId = task.getId(); Future future = tasksStarterExecutorService.submit(() -&gt; { tasksManager.updateTaskState(taskId, Task.State.CREATING); logger.info(<span class="hljs-string"><span class="hljs-string">"Creating backup..."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (InputStream backupStream = databaseBackupManager.createBackup(databaseSettings, taskId)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Thread.interrupted()) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InterruptedException(); } tasksManager.updateTaskState(taskId, Task.State.APPLYING_PROCESSORS); logger.info(<span class="hljs-string"><span class="hljs-string">"Applying processors on created backup. Processors: {}"</span></span>, processors); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (InputStream processedBackupStream = backupProcessorManager.process(backupStream, processors)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Thread.interrupted()) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InterruptedException(); } tasksManager.updateTaskState(taskId, Task.State.UPLOADING); logger.info(<span class="hljs-string"><span class="hljs-string">"Uploading backup..."</span></span>); backupLoadManager.uploadBackup(processedBackupStream, backupProperties, taskId); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Thread.interrupted()) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InterruptedException(); } tasksManager.updateTaskState(taskId, Task.State.COMPLETED); logger.info(<span class="hljs-string"><span class="hljs-string">"Creating backup completed. Backup properties: {}"</span></span>, backupProperties); } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (IOException ex) { logger.error(<span class="hljs-string"><span class="hljs-string">"Error occurred while closing input stream of created backup"</span></span>, ex); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (RuntimeException ex) { logger.error(<span class="hljs-string"><span class="hljs-string">"Error occurred while creating backup. Backup properties: {}"</span></span>, backupProperties, ex); errorTasksManager.addErrorTask(taskId); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (InterruptedException ex) { tasksManager.setInterrupted(taskId); logger.error(<span class="hljs-string"><span class="hljs-string">"Backup creating task was interrupted. Task ID: {}"</span></span>, taskId); } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { futures.remove(taskId); } }); futures.put(taskId, future); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> task; }</code> </pre> <br><p>  Das Erstellen eines Backups durchläuft drei Hauptschritte in der folgenden Reihenfolge: Erstellen eines Backups -&gt; Anwendung von Prozessoren -&gt; Hochladen in den Speicher.  Bei fast allen Dienstmethoden leiten wir die ID der aktuellen Aufgabe weiter, damit der Dienst einen Fehler von einem Thread melden kann, der im Hintergrund arbeitet.  Über die Fehlerbehandlung, warum <em>InterruptedException</em> hier ist und was mit einem Fehler nach Erhalt einer <em>RuntimeException passiert,</em> wird später erläutert. </p><br><p>  Und so führen wir die Aufgabe aus, ein Backup zu erstellen: </p><br><pre> <code class="java hljs">tasksStarterService.startBackupTask(Task.RunType.USER, storageSettingsNameList, processors, databaseSettings);</code> </pre> <br><p>  Der erste Parameter, den wir an den Initiator der Aufgabe übergeben: der Benutzer oder die interne Serveraufgabe (ein Beispiel für eine interne Aufgabe ist eine regelmäßige Sicherung).  Das Wissen des Aufgabeninitiators ermöglicht es uns, in der Web-Benutzeroberfläche nur die Aufgaben anzuzeigen, die vom Benutzer gestartet wurden.  Die verbleibenden Parameter sind erforderlich, um eine Sicherung direkt zu erstellen - eine Liste der Speicher, der zu verwendenden Prozessoren und einer Datenbank, deren Speicherauszug Sie erstellen müssen. </p><br><p>  Beim Erstellen einer Sicherung wird auch ein Datensatz in der Datenbank mit dem Namen <strong>BackupProperties erstellt</strong> .  Diese Entität speichert Sicherungseigenschaften wie den Namen, die verwendeten Prozessoren und die Liste der Repositorys, in die die Sicherung heruntergeladen wurde.  Um die Sicherung wiederherzustellen oder zu löschen, arbeiten wir mit dieser bestimmten Entität. </p><br><p>  Die Aufgabe in der Datenbank wird in folgender Form gespeichert: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-meta"><span class="hljs-meta">@Table</span></span>(name = <span class="hljs-string"><span class="hljs-string">"backup_tasks"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Task</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * Identifier of each backup task. Identifier is generated by PostgreSQL database after saving of entity. */</span></span> <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> <span class="hljs-meta"><span class="hljs-meta">@Column</span></span>(insertable = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, updatable = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) <span class="hljs-meta"><span class="hljs-meta">@GeneratedValue</span></span>(strategy = GenerationType.IDENTITY) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Integer id; <span class="hljs-comment"><span class="hljs-comment">/** * Backup task type. * &lt;p&gt; * Type is set at the very start of any task and can't be changed. * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@see</span></span></span><span class="hljs-comment"> Type */</span></span> <span class="hljs-meta"><span class="hljs-meta">@Enumerated</span></span>(EnumType.STRING) <span class="hljs-meta"><span class="hljs-meta">@Column</span></span>(updatable = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Type type; <span class="hljs-comment"><span class="hljs-comment">/** * Who initiated a task: user or server. * &lt;p&gt; * We need to know it to show on front only these tasks that was started by user. * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@see</span></span></span><span class="hljs-comment"> RunType */</span></span> <span class="hljs-meta"><span class="hljs-meta">@Enumerated</span></span>(EnumType.STRING) <span class="hljs-meta"><span class="hljs-meta">@Column</span></span>(updatable = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> RunType runType; <span class="hljs-comment"><span class="hljs-comment">/** * Backup task state. * &lt;p&gt; * State is updated with every new step in task being executed. * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@see</span></span></span><span class="hljs-comment"> Task.State */</span></span> <span class="hljs-meta"><span class="hljs-meta">@Enumerated</span></span>(EnumType.STRING) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> State state; <span class="hljs-comment"><span class="hljs-comment">/** * Whether task has been interrupted or not. * &lt;p&gt; * Default is {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@literal</span></span></span><span class="hljs-comment"> false}. */</span></span> <span class="hljs-meta"><span class="hljs-meta">@Column</span></span>(insertable = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> interrupted; <span class="hljs-comment"><span class="hljs-comment">/** * Identifier of {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@link</span></span></span><span class="hljs-comment"> BackupProperties}. * &lt;p&gt; * We need to know backup ID to be able to handle occurred errors. */</span></span> <span class="hljs-meta"><span class="hljs-meta">@Column</span></span>(updatable = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Integer backupPropertiesId; <span class="hljs-comment"><span class="hljs-comment">/** * Start time of the task. */</span></span> <span class="hljs-meta"><span class="hljs-meta">@Column</span></span>(updatable = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> LocalDateTime date; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> RunType { USER, INTERNAL } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> State { PLANNED, CREATING, RESTORING, DELETING, APPLYING_PROCESSORS, APPLYING_DEPROCESSORS, DOWNLOADING, UPLOADING, COMPLETED, } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Type { CREATE_BACKUP { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"CREATE BACKUP"</span></span>; } }, RESTORE_BACKUP { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"RESTORE BACKUP"</span></span>; } }, DELETE_BACKUP { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"DELETE BACKUP"</span></span>; } } } <span class="hljs-comment"><span class="hljs-comment">// getters &amp; setters... }</span></span></code> </pre> <br><p>  So können Sie den Vorgang des Erstellens eines Backups in Form eines Diagramms wie folgt beschreiben: <br><img src="https://habrastorage.org/webt/bm/um/cy/bmumcyhyapjg4ono73qo8kiquom.png" alt="Sicherungsprozess" title="Sicherstellen"></p><br><hr><br><p>  Andere Arten von Aufgaben werden analog gestartet.  Um den Artikel nicht mit einer großen Menge an Code zu überladen, werde ich den Neugierigen den Code zum Starten von Aufgaben zum Wiederherstellen und Löschen von Backups separat im Spoiler geben. </p><br><div class="spoiler">  <b class="spoiler_title">Backup-Wiederherstellung</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">startRestoreTask</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull Task.RunType runType, @NotNull BackupProperties backupProperties, @NotNull String storageSettingsName, @NotNull DatabaseSettings databaseSettings)</span></span></span><span class="hljs-function"> </span></span>{ Objects.requireNonNull(runType); Objects.requireNonNull(backupProperties); Objects.requireNonNull(storageSettingsName); Objects.requireNonNull(databaseSettings); Task task = tasksManager.initNewTask(Task.Type.RESTORE_BACKUP, runType, backupProperties.getId()); Integer taskId = task.getId(); Future future = tasksStarterExecutorService.submit(() -&gt; { tasksManager.updateTaskState(taskId, Task.State.DOWNLOADING); logger.info(<span class="hljs-string"><span class="hljs-string">"Downloading backup..."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (InputStream downloadedBackup = backupLoadManager.downloadBackup(backupProperties.getBackupName(), storageSettingsName, taskId)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Thread.interrupted() || downloadedBackup == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InterruptedException(); } tasksManager.updateTaskState(taskId, Task.State.APPLYING_DEPROCESSORS); logger.info(<span class="hljs-string"><span class="hljs-string">"Deprocessing backup..."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (InputStream deprocessedBackup = backupProcessorManager.deprocess(downloadedBackup, backupProperties.getProcessors())) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Thread.interrupted()) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InterruptedException(); } tasksManager.updateTaskState(taskId, Task.State.RESTORING); logger.info(<span class="hljs-string"><span class="hljs-string">"Restoring backup..."</span></span>); databaseBackupManager.restoreBackup(deprocessedBackup, databaseSettings, taskId); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Thread.interrupted()) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InterruptedException(); } tasksManager.updateTaskState(taskId, Task.State.COMPLETED); logger.info(<span class="hljs-string"><span class="hljs-string">"Restoring backup completed. Backup properties: {}"</span></span>, backupProperties); } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (IOException ex) { logger.error(<span class="hljs-string"><span class="hljs-string">"Error occurred while closing input stream of downloaded backup"</span></span>, ex); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (RuntimeException ex) { logger.info(<span class="hljs-string"><span class="hljs-string">"Error occurred while restoring backup. Backup properties: {}"</span></span>, backupProperties, ex); errorTasksManager.addErrorTask(taskId); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (InterruptedException ex) { tasksManager.setInterrupted(taskId); logger.error(<span class="hljs-string"><span class="hljs-string">"Task was interrupted. Task ID: {}"</span></span>, taskId); } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { futures.remove(taskId); } }); futures.put(taskId, future); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> task; }</code> </pre> <br><p>  Das Wiederherstellen einer Sicherung durchläuft drei Hauptschritte in der folgenden Reihenfolge: Entladen einer Sicherung aus dem Speicher -&gt; Verwenden von Deprozessoren zum Abrufen der ursprünglichen Klartextsicherung -&gt; Wiederherstellen einer Sicherung. </p><br><p>  Starten Sie die Wiederherstellung wie folgt: </p><br><pre> <code class="java hljs">tasksStarterService.startRestoreTask(Task.RunType.USER, backupProperties, storageSettingsName, databaseSettings);</code> </pre> <br><p>  Der Vorgang des Wiederherstellens einer Sicherung in Form eines Diagramms: <br><img src="https://habrastorage.org/webt/hr/_m/bk/hr_mbkvfkszhyhj6ebi1q_wa1nc.png" alt="  " title="Backup-Wiederherstellungsprozess"></p></div></div><br><div class="spoiler">  <b class="spoiler_title">Backup löschen</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">startDeleteTask</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull Task.RunType runType, @NotNull BackupProperties backupProperties)</span></span></span><span class="hljs-function"> </span></span>{ Objects.requireNonNull(runType); Objects.requireNonNull(backupProperties); Task task = tasksManager.initNewTask(Task.Type.DELETE_BACKUP, runType, backupProperties.getId()); Integer taskId = task.getId(); Future future = tasksStarterExecutorService.submit(() -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { logger.info(<span class="hljs-string"><span class="hljs-string">"Deleting backup started. Backup properties: {}"</span></span>, backupProperties); tasksManager.updateTaskState(taskId, Task.State.DELETING); backupLoadManager.deleteBackup(backupProperties, taskId); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Thread.interrupted()) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InterruptedException(); } tasksManager.updateTaskState(taskId, Task.State.COMPLETED); logger.info(<span class="hljs-string"><span class="hljs-string">"Deleting backup completed. Backup properties: {}"</span></span>, backupProperties); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (RuntimeException ex) { logger.error(<span class="hljs-string"><span class="hljs-string">"Error occurred while deleting backup. Backup properties: {}"</span></span>, backupProperties, ex); errorTasksManager.addErrorTask(taskId); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (InterruptedException ex) { tasksManager.setInterrupted(taskId); logger.error(<span class="hljs-string"><span class="hljs-string">"Task was interrupted. Task ID: {}"</span></span>, taskId); } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { futures.remove(taskId); } }); futures.put(taskId, future); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> task; }</code> </pre> <br><p>  Das Löschen eines Backups ist ganz einfach: Ein Backup wird einfach aus allen Speichern gelöscht, in die es heruntergeladen wurde. </p><br><p>  Führen Sie die Deinstallation wie folgt aus: </p><br><pre> <code class="java hljs">tasksStarterService.startDeleteTask(Task.RunType.USER, backupProperties);</code> </pre> <br><p>  Der Vorgang des Löschens einer Sicherung in Form eines Diagramms: <br><img src="https://habrastorage.org/webt/y4/ca/yp/y4cayp76w4v0tx8umvzcp6flzd4.png" alt="  " title="Backup-Entfernungsprozess"></p></div></div><br><hr><br><h3 id="otmena-taskov">  Aufgabe abbrechen </h3><br><p>  Was ist Aufgabenabbruch?  Dies ist natürlich nichts anderes als eine Thread-Beendigung.  Sie konnten sehen, dass der gesamte in Future ausgeführte Hauptcode in das folgende Try-Catch-Konstrukt eingeschlossen ist: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { ... } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (InterruptedException ex) { ... tasksManager.setInterrupted(taskId); }</code> </pre> <br><p>  Und auch nach jeder wichtigen Methode, deren Ausführungsfluss wir steuern, wird die folgende Konstruktion installiert: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Thread.interrupted()) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InterruptedException(); }</code> </pre> <br><p>  Bevor Sie fortfahren, sollte eine kurze Theorie der Unterbrechungen und Zustände von JVM-Threads gegeben werden. </p><br><p>  Threads in der JVM können den folgenden Status haben: </p><br><ol><li>  Neu </li><li>  Runnable </li><li>  Zeitgesteuertes Warten </li><li>  Warten </li><li>  Blockiert </li><li>  Beendet </li></ol><br><p>  Wir sind nur an den Wartezuständen und zeitgesteuerten Wartezuständen interessiert.  Der <code>Object.wait()</code> durch die Methoden <code>Object.wait()</code> , <code>Thread.join()</code> und andere in den Status <em>Warten versetzt</em> .  Der Thread wird unter Verwendung der Methoden <code>Object.wait(timeout)</code> , <code>Thread.join(timeout)</code> , <code>Thread.sleep(sleeping)</code> und anderer in den <em>zeitgesteuerten</em> Wartezustand (d. H. Eine Wartezeit, die einen bestimmten Zeitraum dauert <code>Thread.sleep(sleeping)</code> . </p><br><p>  Das Wichtigste dabei ist, dass der Thread aufwacht und eine <strong>InterruptedException</strong> auslöst, wenn Sie den Thread unterbrechen, <em>bevor Sie in den</em> Wartezustand oder den zeitgesteuerten Wartezustand wechseln, oder wenn sich der Thread <em>in diesem Zustand</em> befindet. </p><br><p>  Das ist aber noch nicht alles.  Es ist überhaupt keine Tatsache, dass ein Thread jemals in Statusdaten wechselt, indem er ein Backup erstellt, wiederherstellt oder löscht.  Wie kann man dann den Thread darüber informieren, dass er unterbrochen wurde? </p><br><p>  Die erste Möglichkeit besteht darin, das Interrupt-Flag mit dem Thread unabhängig mit den Methoden Thread.interrupted <code>Thread.interrupted()</code> oder <code>Thread.currentThread.isInterrupted()</code> .  Der Unterschied zwischen ihnen besteht darin, dass der erste die private native Methode <code>currentThread.isInterrupted(boolean ClearInterrupted)</code> , wobei <code>true</code> , um <code>currentThread.isInterrupted(boolean ClearInterrupted)</code> , dass das Interrupt-Flag gelöscht wird, und der zweite <code>false</code> , wobei das Interrupt-Flag intakt bleibt.  Die Wahl zwischen diesen beiden Methoden hängt ganz von der Situation ab.  Wenn eine InterruptedException ausgelöst wird, wird auch das Interrupt-Flag gelöscht - dies ist zu beachten. </p><br><p>  Aber es muss einen Weg geben, der einfacher ist - und das ist es auch.  In der Anwendung gibt es eine Menge Arbeit mit E / A-Streams und daher mit E / A-Methoden.  Unsere Aufgabe ist es sicherzustellen, dass beim Aufrufen der Methoden <code>read()</code> oder <code>write(int b)</code> im E / A-Stream während der Unterbrechung ein Fehler ausgegeben wird, der darauf hinweist, dass der blockierende E / A-Aufruf unterbrochen wurde.  Glücklicherweise hat Java eine solche Ausnahme - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">InterruptedIOException</a> .  Allerdings überwachen nicht alle Lese- / Schreib-Stream-Methoden Thread-Unterbrechungen, und speziell nur <em>PipedInputStream</em> überwacht sie.  Daher müssen wir an den Stellen, an denen dieser Stream nicht beteiligt ist, die Lese- / Schreibmethode so erweitern, dass bei einem Interrupt eine InterruptedIOException ausgelöst wird.  Tatsächlich war die Erweiterung der read () -Methode für mich in der Anwendung nur an einer Stelle ausreichend - als der InputStream von der Backup-Upload-Methode zurückkehrte.  Auf diese Weise können wir den Ursprung eines Interrupts ermitteln, ohne dass das Flag überall mit Vorlagenprüfungen versehen werden muss.  Es ist jedoch wichtig, diese Ausnahme getrennt von der IOException abzufangen und separat zu behandeln.  Natürlich kann man an einigen Stellen nicht auf die Hilfe einer Vorlagenprüfung der Flagge verzichten, aber sie ist bereits besser geworden. </p><br><p>  Es ist auch wichtig zu beachten, dass, wenn das Flag während der Interrupt-Verarbeitung gelöscht wurde, das Interrupt-Flag immer wieder gesetzt werden muss, damit wir nach der Rückkehr von der Methode herausfinden können, welcher Interrupt aufgetreten ist. </p><br><p>  Lassen Sie mich anhand eines Beispiels erklären, warum dies wichtig ist.  Angenommen, wir laden mit der Methode upload () ein Backup in den Speicher hoch und es tritt ein Interrupt auf.  Der Interrupt wird verarbeitet, die Arbeit gestoppt und die Methode zurückgegeben.  Eine Unterbrechung tritt nicht gelegentlich auf - dies bedeutet, dass entweder irgendwo ein Fehler aufgetreten ist oder der Benutzer die Aufgabe abgebrochen hat.  Unabhängig vom Grund müssen wir alle Arbeiten in dieser Zukunft einstellen.  Wenn Sie das Interrupt-Flag jedoch nicht erneut setzen, bevor Sie von der Startmethode zurückkehren, werden wir im Future-Hauptblock nie erfahren, welcher Interrupt aufgetreten ist. <br>  Das gleiche Codebeispiel: </p><br><pre> <code class="java hljs">backupLoadManager.uploadBackup(processedBackupStream, backupProperties, taskId); &lt;-   ,       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Thread.interrupted()) { <span class="hljs-comment"><span class="hljs-comment">//      ,      - ,    throw new InterruptedException(); }</span></span></code> </pre> <br><p>  Daher empfiehlt es sich, eine <strong>InterruptedException</strong> oder <strong>InterruptedIOException</strong> wie folgt zu behandeln: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { ... } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (InterruptedException e) { <span class="hljs-comment"><span class="hljs-comment">//  InterruptedIOException ... // re-interrupt the thread Thread.currentThread().interrupt(); }</span></span></code> </pre> <br><p>  Nun, wir können mit Unterbrechungen umgehen, aber wer wird die Threads tatsächlich unterbrechen? <br>  Zu diesem <em>Zweck</em> erstellen wir eine weitere Entität namens <em>CancelTask</em> , in der die ID der Aufgabe zum <em>Abbrechen gespeichert</em> wird, und schreiben eine <em>Überwachung</em> , die versucht, die Aufgaben zu unterbrechen.  Warum versuchen?  Weil: </p><br><ol><li>  Der Thread im Speicher eines anderen Servers kann nicht beendet werden.  Für uns können mehrere Server arbeiten, was bedeutet, dass Future auf verschiedene Server verteilt ist.  Wenn also eine Anforderung zum Abbrechen einer Aufgabe auf einem der Server eintrifft, befindet sich die gewünschte Zukunft möglicherweise im Speicher eines anderen Servers. </li><li>  Die Aufgabe kann nicht abgebrochen werden, da Future aufgrund eines Serverabsturzes verloren gegangen ist. </li></ol><br><p>  Beschreiben Sie kurz den Stornierungsalgorithmus am Abend: <br>  Watercher nimmt alle Datensätze aus der Tabelle <em>cancel_tasks heraus</em> (die Sperre wird nicht gleichzeitig gesetzt), geht jeden einzelnen durch und versucht, die entsprechende Zukunft aus seinem Speicher <em>abzurufen</em> .  Wenn Future erfolgreich empfangen wurde, wird der entsprechende Thread unterbrochen, die Aufgabe zurückgesetzt und die Anforderung aus der Tabelle gelöscht.  Wenn die Timeout-Anforderung zum Abbrechen der Aufgabe überschritten wird (was bedeutet, dass der Server abgestürzt ist und Future verloren gegangen ist), wird die Anforderung einfach aus der Tabelle gelöscht.  Wenn mehrere Server eine Zeitüberschreitung feststellen und den Datensatz aus der Tabelle löschen, geschieht nichts Schlimmes, da das Löschen in PostgreSQL idempotent ist. </p><br><p>  <strong>CancelTasksWatcher-Code:</strong> </p><br><div class="spoiler">  <b class="spoiler_title">Versteckter Text</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/** * This class scans for tasks to cancel and tries to cancel them. */</span></span> <span class="hljs-meta"><span class="hljs-meta">@Component</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CancelTasksWatcher</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Logger logger = LoggerFactory.getLogger(CancelTasksWatcher.class); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Duration cancelTimeout = Duration.ofMinutes(<span class="hljs-number"><span class="hljs-number">10</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> CancelTasksManager cancelTasksManager; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> TasksStarterService tasksStarterService; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> TasksManager tasksManager; <span class="hljs-comment"><span class="hljs-comment">// spring setters... /** * This watcher wakes up every time 10 seconds passed from the last completion, checks if there are any tasks to cancel and tries to * cancel each task. * &lt;p&gt; * Since there are can be working more that one instance of the program, {@literal Future} instance of task can belong to different * servers. We can't get access to {@literal Future} if it's not in memory of the server where task cancellation request was accepted. * So the purpose of this watcher is to be able cancel tasks that works in the other instance of program. Each server has this watcher * checking for available cancellation requests and if any, the watcher tries to cancel corresponding {@literal Future}. * If cancellation is successful task will be also reverted. * &lt;p&gt; * If task cancellation request timeout exceeded, then it means a server that had requested {@literal Future} instances has been * shutdown, so all {@literal Future} instances lost and task can't be canceled. In such case task cancellation request will be ignored. * * @see TasksStarterService#getFuture(Integer) * @see TasksManager#revertTask(Task) */ @Scheduled(fixedDelay = 10 * 1000) @Transactional(isolation = Isolation.READ_COMMITTED, propagation = Propagation.REQUIRES_NEW) public void watchTasksToCancel() { Iterable&lt;CancelTask&gt; cancelTasks = cancelTasksManager.findAll(); Iterable&lt;Task&gt; tasks = tasksManager.findAllById(StreamSupport.stream(cancelTasks.spliterator(), false) .map(CancelTask::getTaskId).collect(Collectors.toList())); Map&lt;Integer, Task&gt; tasksAsMap = StreamSupport.stream(tasks.spliterator(), false) .collect(Collectors.toMap(Task::getId, Function.identity())); List&lt;Integer&gt; taskIdsForDeleting = new ArrayList&lt;&gt;(); for (CancelTask cancelTask : cancelTasks) { Integer taskId = cancelTask.getTaskId(); Task task = tasksAsMap.get(taskId); if (task == null) { logger.error("Can't cancel task: no such entity with ID {}", taskId); taskIdsForDeleting.add(taskId); continue; } // timeout exceeded, that is server shutdown and lost all Future instances, so task can't be canceled if (LocalDateTime.now(ZoneOffset.UTC).isAfter(cancelTask.getPutTime().plus(cancelTimeout))) { logger.error("Can't cancel task: timeout exceed. Task ID: {}", taskId); taskIdsForDeleting.add(taskId); continue; } tasksStarterService.getFuture(taskId).ifPresent(future -&gt; { logger.info("Canceling task with ID {}", taskId); boolean canceled = future.cancel(true); if (canceled) { try { // give time to properly handle interrupt Thread.sleep(10000); } catch (InterruptedException e) { // should not happen } tasksManager.revertTask(task); } taskIdsForDeleting.add(taskId); logger.info("Task canceled: {}. Task ID: {}", canceled, taskId); }); } cancelTasksManager.deleteByTaskIdIn(taskIdsForDeleting); } }</span></span></code> </pre> </div></div><br><hr><br><h4 id="obrabotka-oshibok">  Fehlerbehandlung </h4><br><p>  Oben sehen Sie, dass der gesamte in Future ausgeführte Hauptcode in das folgende Try-Catch-Konstrukt eingeschlossen ist: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { ... } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (RuntimeException e) { ... errorTasksManager.addErrorTask(taskId); }</code> </pre> <br><p>     <em>RuntimeException</em>   ,     Future  ,         . </p><br><p>  <code>addErrorTask(taskId)</code>        ,   ID ,    . <br>      ?       ,    ,        ,   . </p><br><p>      : <br>                  ,        ,       .  —  PostgreSQL <code>select for update</code> ,   select   <code>skip locked</code>      . ,  ,    <code>revertTask()</code> ,               . </p><br><p> <strong> ErrorTasksWatcher</strong> : </p><br><div class="spoiler">  <b class="spoiler_title">Versteckter Text</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/** * This class scans for erroneous tasks and handles them depending on their state. */</span></span> <span class="hljs-meta"><span class="hljs-meta">@Component</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ErrorTasksWatcher</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Logger logger = LoggerFactory.getLogger(ErrorTasksWatcher.class); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Integer nRows = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> TasksManager tasksManager; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ErrorTasksManager errorTasksManager; <span class="hljs-comment"><span class="hljs-comment">// spring setters... /** * This watcher wakes up every time 1 minute passed from the last completion, checks backup states periodically and handles erroneous * tasks if any. * &lt;p&gt; * The watcher handles at most N tasks as described by {@link #nRows} constant and skips already locked tasks. * When retrieving error tasks from database pessimistic lock is set. It allows safely run more than one copy of program, as no other * watcher can pick up already being handled error tasks. * &lt;p&gt; * If the server shutdowns while rows was locked, transaction will be rolled back and lock released, so these entities can be picked * up by the other running server. */ @Scheduled(fixedDelay = 60 * 1000) @Transactional(isolation = Isolation.READ_COMMITTED, propagation = Propagation.REQUIRES_NEW) public void watchErrorTasks() { for (ErrorTask errorTask : errorTasksManager.findFirstNAndLock(nRows)) { if (!errorTask.isErrorHandled()) { Integer backupTaskId = errorTask.getTaskId(); Optional&lt;Task&gt; optionalTask = tasksManager.findById(backupTaskId); if (!optionalTask.isPresent()) { logger.info("Can't handle erroneous task: no corresponding backup task entity. Backup task ID: {}", backupTaskId); continue; } tasksManager.revertTask(optionalTask.get()); errorTask.setErrorHandled(true); } } } }</span></span></code> </pre> </div></div><br><p> <strong> <code>revertTask(Task)</code> :</strong> </p><br><div class="spoiler">  <b class="spoiler_title">Versteckter Text</b> <div class="spoiler_text"><pre> <code class="java hljs"> <span class="hljs-comment"><span class="hljs-comment">/** * This function reverts erroneous task by its entity. * &lt;p&gt; * Use this function only after canceling related {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@literal</span></span></span><span class="hljs-comment"> Future}. * &lt;p&gt; * If the task was of the type {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@link</span></span></span><span class="hljs-comment"> Task.Type#CREATE_BACKUP} then related {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@link</span></span></span><span class="hljs-comment"> BackupProperties} will be deleted. * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> task the entity */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">revertTask</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull Task task)</span></span></span><span class="hljs-function"> </span></span>{ Objects.requireNonNull(task); Task.State state = task.getState(); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (state) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> DOWNLOADING: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> APPLYING_DEPROCESSORS: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> RESTORING: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> DELETING: { logger.info(<span class="hljs-string"><span class="hljs-string">"Handling broken operation. Operation: {}. No extra actions required"</span></span>, state.toString()); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CREATING: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> APPLYING_PROCESSORS: { logger.info(<span class="hljs-string"><span class="hljs-string">"Handling broken operation. Operation: {}. Delete backup properties..."</span></span>, state.toString()); Integer backupPropertiesID = task.getBackupPropertiesId(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!backupPropertiesManager.existsById(backupPropertiesID)) { logger.error(<span class="hljs-string"><span class="hljs-string">"Can't revert task: no related backup properties. Task info: {}"</span></span>, task); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } backupPropertiesManager.deleteById(backupPropertiesID); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> UPLOADING: { logger.info(<span class="hljs-string"><span class="hljs-string">"Handling broken operation. Operation: {}. Deleting backup from storage..."</span></span>, state); Integer backupPropertiesId = task.getBackupPropertiesId(); Optional&lt;BackupProperties&gt; optionalBackupProperties = backupPropertiesManager.findById(backupPropertiesId); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!optionalBackupProperties.isPresent()) { logger.error(<span class="hljs-string"><span class="hljs-string">"Can't revert task: no related backup properties. Task info: {}"</span></span>, task); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } tasksStarterService.startDeleteTask(Task.RunType.INTERNAL, optionalBackupProperties.get()); backupPropertiesManager.deleteById(backupPropertiesId); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: { logger.error(<span class="hljs-string"><span class="hljs-string">"Can't revert task: unknown state. Task info: {}"</span></span>, task); } } }</code> </pre> <br><p>   : </p><br><ol><li>     <em>DOWNLOADING</em> , <em>APPLYING_DEPROCESSORS</em> , <em>RESTORING</em> , <em>DELETING</em> —    .      ,       . </li><li>     <em>CREATING</em> , <em>APPLYING_PROCESSORS</em> —  ,       .      BackupProperties  ,       ( BackupProperties   Web UI    ). </li><li>     <em>UPLOADING</em> —       .        BackupProperties   ,       .       . </li></ol></div></div><br><p> ,    .         ,    ? ,   ,    Future (  1),     ,          InputStream (  2). ,      2,   1            2    ? </p><br><p>  ,     ,    ,       .      Future (    1)     : </p><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull Throwable t, @NotNull Integer taskId)</span></span></span><span class="hljs-function"> </span></span>{ logger.error(<span class="hljs-string"><span class="hljs-string">"Exception caught. Task ID: {}"</span></span>, taskId, t); Optional&lt;Future&gt; optionalFuture = tasksStarterService.getFuture(taskId); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!optionalFuture.isPresent()) { logger.error(<span class="hljs-string"><span class="hljs-string">"Can't cancel the Future of task with ID {}: no such Future instance"</span></span>, taskId); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> canceled = optionalFuture.get().cancel(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!canceled) { logger.error(<span class="hljs-string"><span class="hljs-string">"Error canceling the Future of task with ID {}"</span></span>, taskId); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { logger.info(<span class="hljs-string"><span class="hljs-string">"Task canceled. Task ID: {}"</span></span>, taskId); errorTasksManager.setError(taskId); } } }</code> </pre> <br><p>   ,     ,      ID  ,   ,    Future   -  ,  ID     . </p><br><p>    ,          ,     ,     ,         ,          . </p><br><p> <strong>  ,   :</strong> </p><br><p> ,   ,        ,    .       —       Future. </p><br><p>   ,      ,    ,      I/O ,          —     /   .     ,      .       : </p><br><ol><li>  ,  .     ,      —     . </li><li>     —     Future   ,   .  , /   ,  ,     (  ,     —    IOException  ,        ,   ). </li></ol><br><p>  ,   —            (   ID       ,  ,    ),        . </p><br><hr><br><p>  ,    ,        .      ,    ,             . </p><br><h3 id="plany-na-buduschee">    </h3><br><ol><li>  Web UI:   ,   .     ,      </li><li>     </li><li>      </li><li>     </li><li>     </li></ol><br><h3 id="zaklyuchenie">  Fazit </h3><br><p>   : </p><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><strong>GitHub</strong></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><strong>Docker Hub</strong></a> </li></ul><br><p>   ,   !           ,       GitHub! <br></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de459478/">https://habr.com/ru/post/de459478/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de459464/index.html">Lua in Moskau 2019: Interview mit Roberto Jerusalem</a></li>
<li><a href="../de459466/index.html">Lua in Moskau 2019: Interview mit Roberto Ierusalimschy</a></li>
<li><a href="../de459470/index.html">Teil 4: Linux läuft immer noch unter RISC-V RISC-V</a></li>
<li><a href="../de459472/index.html">Heroku + Docker + Spring Boot</a></li>
<li><a href="../de459474/index.html">So erstellen Sie in einer Sekunde perfekt getippten Text: ein Makro in Word für diejenigen, die viel schreiben</a></li>
<li><a href="../de459480/index.html">Vivaldi: Wie verdient der Browser Geld?</a></li>
<li><a href="../de459482/index.html">Wie wir den Kategoriebaum besiegt haben</a></li>
<li><a href="../de459484/index.html">Generation Arduino. Was moderne Studenten erfinden</a></li>
<li><a href="../de459488/index.html">Spezielle Spielmodi im Kontext von Roguelike</a></li>
<li><a href="../de459490/index.html">Schmutzige Tricks von CRM-Anbietern: Würden Sie ein Auto ohne Räder kaufen?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>