<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚õπüèæ ü§™ ‚úÇÔ∏è MIT-Kurs "Computer Systems Security". Vorlesung 2: ‚ÄûKontrolle von Hackerangriffen‚Äú, Teil 3 üç™ ‚ô®Ô∏è üåô</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Massachusetts Institute of Technology. Vorlesung # 6.858. "Sicherheit von Computersystemen." Nikolai Zeldovich, James Mickens. 2014 Jahr 
 Computer Sy...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MIT-Kurs "Computer Systems Security". Vorlesung 2: ‚ÄûKontrolle von Hackerangriffen‚Äú, Teil 3</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ua-hosting/blog/416727/"><h3>  Massachusetts Institute of Technology.  Vorlesung # 6.858.  "Sicherheit von Computersystemen."  Nikolai Zeldovich, James Mickens.  2014 Jahr </h3><br>  Computer Systems Security ist ein Kurs zur Entwicklung und Implementierung sicherer Computersysteme.  Die Vortr√§ge behandeln Bedrohungsmodelle, Angriffe, die die Sicherheit gef√§hrden, und Sicherheitstechniken, die auf j√ºngsten wissenschaftlichen Arbeiten basieren.  Zu den Themen geh√∂ren Betriebssystemsicherheit, Funktionen, Informationsflussmanagement, Sprachsicherheit, Netzwerkprotokolle, Hardwaresicherheit und Sicherheit von Webanwendungen. <br><br>  Vorlesung 1: ‚ÄûEinf√ºhrung: Bedrohungsmodelle‚Äú <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3</a> <br>  Vorlesung 2: ‚ÄûKontrolle von Hackerangriffen‚Äú <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3</a> <a name="habracut"></a><br><br>  K√∂nnen Sie mir sagen, was das Fehlen eines Sicherheitsansatzes ist, der eine <b>Schutzseite verwendet</b> ? <br><br>  <b>Teilnehmerin:</b> Es dauert l√§nger! <br><br>  <b>Professor:</b> genau!  Stellen Sie sich also vor, dieser Haufen ist sehr, sehr klein, aber ich habe eine ganze Seite ausgew√§hlt, um sicherzustellen, dass dieses kleine Ding nicht von einem Zeiger angegriffen wurde.  Dies ist ein sehr r√§umlich intensiver Prozess, und die Leute setzen so etwas nicht in einer Arbeitsumgebung ein.  Dies kann n√ºtzlich sein, um "Fehler" zu testen, aber Sie w√ºrden dies niemals f√ºr ein echtes Programm tun.  Ich denke, jetzt verstehen Sie, was ein <b>Elektrozaun-</b> Speicher-Debugger ist. <br><br>  <b>Teilnehmerin:</b> Warum sollte die <b>Schutzseite</b> so gro√ü sein? <br><br>  <b>Professor: Der</b> Grund daf√ºr ist, dass sie normalerweise auf Hardware wie den Schutz auf Seitenebene angewiesen sind, um die Seitengr√∂√üen zu bestimmen.  Bei den meisten Computern werden jedem zugewiesenen Puffer 2 Seiten mit einer Gr√∂√üe von 4 KB zugewiesen, insgesamt 8 KB.  Da der Heap aus Objekten besteht, wird jeder <b>Malloc-</b> Funktion eine separate Seite zugewiesen.  In einigen Modi gibt dieser Debugger den reservierten Speicherplatz nicht an das Programm zur√ºck, sodass der <b>Elektrozaun</b> in Bezug auf den Speicher sehr uners√§ttlich ist und nicht mit Arbeitscode kompiliert werden sollte. <br><br><img src="https://habrastorage.org/webt/cm/l6/oh/cml6ohlrz3im72yoa5u_6n9pomg.jpeg"><br><br>  Ein weiterer Sicherheitsansatz, der einen Blick wert ist, hei√üt <b>Fat Pointers</b> oder "Thick Pointers".  In diesem Fall bedeutet der Begriff "dick", dass eine gro√üe Datenmenge an den Zeiger angeh√§ngt wird.  In diesem Fall besteht die Idee darin, die Darstellung des Zeigers zu √§ndern, um Informationen √ºber die Grenzen in seine Zusammensetzung aufzunehmen. <br><br>  Ein regul√§rer 32-Bit-Zeiger besteht aus 32 Bit, und Adressen befinden sich darin.  Wenn wir den "dicken Zeiger" betrachten, dann besteht er aus 3 Teilen.  Der erste Teil ist eine 4-Byte-Basis, an die auch ein Ende von 4 Bytes angeh√§ngt ist.  Im ersten Teil beginnt das Objekt, im zweiten endet es und im dritten, ebenfalls 4 Byte, ist die Adresse <b>cur</b> eingeschlossen.  Und innerhalb dieser gemeinsamen Grenzen befindet sich ein Zeiger. <br><br><img src="https://habrastorage.org/webt/jd/2o/83/jd2o83flkobiu3caqetom5wpwj8.jpeg"><br><br>  Wenn der Compiler einen Zugriffscode f√ºr diesen "dicken Zeiger" generiert, aktualisiert er den Inhalt des letzten Teils der <b>aktuellen Adresse</b> und √ºberpr√ºft gleichzeitig den Inhalt der ersten beiden Teile, um sicherzustellen, dass w√§hrend des Aktualisierungsvorgangs nichts Schlimmes mit dem Zeiger passiert ist. <br><br>  Stellen Sie sich vor, ich habe diesen Code: <b>int * ptr = malloc (8)</b> , dies ist ein Zeiger, dem 8 Bytes zugewiesen sind.  Als n√§chstes habe ich eine <b>while-Schleife</b> , die gerade dabei ist, dem Zeiger einen Wert zuzuweisen, und dann folgt das <b>ptr ++ -</b> Zeigerinkrement.  Jedes Mal, wenn dieser Code an der aktuellen Adresse des aktuellen Adresszeigers ausgef√ºhrt wird, wird gepr√ºft, ob sich der Zeiger innerhalb der im ersten und zweiten Teil angegebenen Grenzen befindet. <br><br>  Dies ist bei dem neuen Code der Fall, den der Compiler generiert.  Eine Online-Gruppe wirft h√§ufig die Frage auf, was ‚ÄûWerkzeugcode‚Äú ist.  Dies ist der Code, den der Compiler generiert.  Als Programmierer sehen Sie nur das, was rechts angezeigt wird - diese 4 Zeilen.  Vor dieser Operation f√ºgt der Compiler jedoch einen neuen C-Code in die <b>aktuelle Adresse ein</b> , weist dem Zeiger einen Wert zu und √ºberpr√ºft jedes Mal die Grenzen. <br><br><img src="https://habrastorage.org/webt/w7/am/vx/w7amvxvkol7dhdi3qdrpkupsgga.jpeg"><br><br>  Und wenn bei Verwendung des neuen Codes der Wert die Grenzen √ºberschreitet, wird die Funktion unterbrochen.  Dies wird als "Werkzeugcode" bezeichnet.  Dies bedeutet, dass Sie den Quellcode mit einem C-Programm verwenden, dann den neuen C-Quellcode hinzuf√ºgen und dann das neue Programm kompilieren.  Die Grundidee hinter <b>Fat Pointers</b> ist also ziemlich einfach. <br><br>  Dieser Ansatz weist einige Nachteile auf.  Der gr√∂√üte Nachteil ist die Gr√∂√üe des Zeigers.  Dies bedeutet, dass Sie den "dicken Zeiger" nicht einfach unver√§ndert au√üerhalb der Shell-Bibliothek √ºbergeben k√∂nnen.  M√∂glicherweise wird erwartet, dass der Zeiger eine Standardgr√∂√üe hat, und das Programm stellt ihm diese Gr√∂√üe zur Verf√ºgung, in die er ‚Äûnicht passt‚Äú, wodurch alles explodiert.  Es gibt auch Probleme, wenn Sie Zeiger dieses Typs in eine <b>Struktur</b> oder √§hnliches aufnehmen m√∂chten, da sie die Gr√∂√üe der <b>Struktur</b> √§ndern k√∂nnen. <br><br>  Daher ist es in C-Code sehr beliebt, etwas von der Gr√∂√üe einer <b>Struktur</b> zu nehmen und dann etwas basierend auf dieser Gr√∂√üe zu tun - reservieren Sie Speicherplatz f√ºr Strukturen dieser Gr√∂√üe und so weiter. <br><br>  Und noch heikler ist, dass diese Zeiger in der Regel nicht atomar aktualisiert werden k√∂nnen.  F√ºr 32-Bit-Architekturen ist es typisch, eine atomare 32-Bit-Variable zu schreiben.  "Dicke Zeiger" enthalten jedoch 3 <b>Ganzzahlgr√∂√üen.</b> Wenn Sie also Code haben, der erwartet, dass der Zeiger einen atomaren Wert hat, k√∂nnen Probleme auftreten.  Denn um einige dieser √úberpr√ºfungen durchzuf√ºhren, m√ºssen Sie sich die aktuelle Adresse und dann die Gr√∂√üen ansehen, und dann m√ºssen Sie sie m√∂glicherweise erh√∂hen, und so weiter und so fort.  Dies kann daher zu sehr subtilen Fehlern f√ºhren, wenn Sie Code verwenden, der versucht, Parallelen zwischen regul√§ren und dicken Zeigern zu ziehen.  Daher k√∂nnen Sie in einigen F√§llen <b>Fettzeiger</b> wie <b>Elektroz√§une verwenden</b> , aber die Nebenwirkungen ihrer Verwendung sind so bedeutend, dass diese Ans√§tze in der normalen Praxis nicht verwendet werden. <br><br>  Und jetzt werden wir √ºber das √úberpr√ºfen von Grenzen in Bezug auf die Struktur von Schattendaten sprechen.  Die Hauptidee der Struktur besteht darin, dass Sie wissen, wie gro√ü jedes Objekt ist, das Sie platzieren m√∂chten, dh dass Sie die Gr√∂√üe kennen, die Sie f√ºr dieses Objekt reservieren m√ºssen.  Wenn Sie beispielsweise einen Zeiger haben, den Sie mit der Funktion <b>malloc</b> aufrufen, m√ºssen Sie die Gr√∂√üe des Objekts angeben: <b>char xp = malloc (Gr√∂√üe)</b> . <br><br><img src="https://habrastorage.org/webt/40/5x/vq/405xvqrcdftphffsqkxgqxprhfo.jpeg"><br><br>  Wenn Sie so etwas wie eine statische Variable wie dieses <b>char p [256] haben</b> , kann der Compiler automatisch herausfinden, welche Grenzen f√ºr seine Platzierung gelten sollen. <br><br>  Daher m√ºssen Sie f√ºr jeden dieser Zeiger zwei Operationen einf√ºgen.  Dies ist haupts√§chlich eine Arithmetik wie <b>q = p + 7</b> oder √§hnliches.  Diese Einf√ºgung erfolgt durch Dereferenzieren eines Links vom Typ <b>deref * q = 'q'</b> .  Sie fragen sich vielleicht, warum Sie sich beim Einf√ºgen nicht auf den Link verlassen k√∂nnen?  Warum m√ºssen wir diese Arithmetik machen?  Tatsache ist, dass Sie bei Verwendung von C und c ++ einen Zeiger haben, der auf einen Durchgang zum g√ºltigen Ende des Objekts auf der rechten Seite zeigt. Danach verwenden Sie ihn als Stoppbedingung.  Sie gehen also zum Objekt und sobald Sie diesen nachfolgenden Zeiger erreichen, stoppen Sie tats√§chlich die Schleife oder brechen die Operation ab. <br><br>  Wenn wir also die Arithmetik ignorieren, verursachen wir immer einen schwerwiegenden Fehler, bei dem der Zeiger die Grenzen √ºberschreitet, was die Arbeit vieler Anwendungen tats√§chlich st√∂ren kann.  Wir k√∂nnen also nicht einfach den Link einf√ºgen, denn woher wissen Sie, dass dies au√üerhalb der festgelegten Grenzen geschieht?  Die Arithmetik erlaubt es uns zu sagen, ob es so ist oder nicht, und hier wird alles rechtm√§√üig und korrekt sein.  Da Sie mit diesem Arithmetik-Keil verfolgen k√∂nnen, wo sich der Zeiger relativ zu seiner urspr√ºnglichen Grundlinie befindet. <br><br>  Die n√§chste Frage lautet also: Wie implementieren wir tats√§chlich die Grenzvalidierung?  Weil wir die spezifische Adresse des Zeigers irgendwie mit einer Art Grenzinformation f√ºr diesen Zeiger abgleichen m√ºssen.  Daher verwenden viele Ihrer vorherigen Entscheidungen Dinge wie beispielsweise eine Hash-Tabelle oder einen Baum, mit denen Sie die richtige Suche durchf√ºhren k√∂nnen.  Angesichts der Adresse des Zeigers suche ich in dieser Datenstruktur und finde heraus, welche Grenzen sie hat.  Angesichts dieser Grenzen entscheide ich, ob ich die Aktion zulassen kann oder nicht.  Das Problem ist, dass dies eine langsame Suche ist, da diese Datenstrukturen verzweigt sind. Wenn Sie einen Baum untersuchen, m√ºssen Sie eine Reihe solcher Verzweigungen untersuchen, bis Sie den richtigen Wert gefunden haben.  Und selbst wenn es sich um eine Hash-Tabelle handelt, m√ºssen Sie den Codeketten folgen und so weiter.  Daher m√ºssen wir eine sehr effektive Datenstruktur definieren, die ihre Grenzen verfolgt und die diese √úberpr√ºfung sehr einfach und klar macht.  Also lasst uns gleich loslegen. <br><br>  Aber bevor wir das tun, m√∂chte ich Ihnen kurz erl√§utern, wie der Ansatz der <b>Buddy-Speicherzuweisung</b> funktioniert.  Weil dies eines der Dinge ist, die oft gefragt werden. <br>  <b>Die Buddy-Speicherzuweisung</b> unterteilt den Speicher in Partitionen mit einem Vielfachen der Zweierpotenz und versucht, Speicheranforderungen in ihnen zuzuweisen.  Mal sehen, wie es funktioniert.  Zu Beginn behandelt die <b>Buddy-Zuweisung</b> nicht zugewiesenen Speicher als einen gro√üen Block - dies ist das obere 128-Bit-Rechteck.  Wenn Sie dann einen kleineren Block f√ºr die dynamische Zuordnung anfordern, wird versucht, diesen Adressraum in Schritten von 2 in Teile aufzuteilen, bis ein f√ºr Ihre Anforderungen ausreichender Block gefunden wird. <br><br>  Angenommen, eine Anforderung vom Typ <b>a = malloc (28) ist</b> eingetroffen, <b>dh</b> eine Anforderung zum Zuweisen von 28 Bytes.  Wir haben einen 128-Byte-Block, der zu verschwenderisch ist, um ihn f√ºr diese Anforderung zuzuweisen.  Daher ist unser Block in zwei Bl√∂cke mit 64 Bytes unterteilt - von 0 bis 64 Bytes und von 64 Bytes bis 128 Bytes.  Und diese Gr√∂√üe ist auch gro√ü f√ºr unsere Anfrage, so dass <b>Buddy</b> wieder einen Block von 64 Bytes in 2 Teile teilt und 2 Bl√∂cke von 32 Bytes empf√§ngt. <br><br><img src="https://habrastorage.org/webt/uj/mt/er/ujmter8tqrakf5gu4pel0v8eawc.jpeg"><br><br>  Weniger ist unm√∂glich, da 28 Bytes nicht passen und 32 die am besten geeignete Mindestgr√∂√üe ist.  Dieser 32-Byte-Block wird nun unserer Adresse a zugewiesen.  Angenommen, wir haben eine andere Abfrage f√ºr <b>b = malloc (50)</b> .  <b>Buddy</b> √ºberpr√ºft die ausgew√§hlten Bl√∂cke und setzt den Wert b in den Block ganz rechts, da 50 gr√∂√üer als die H√§lfte von 64, aber kleiner als 64 ist. <br><br>  Schlie√ülich haben wir eine weitere Anforderung f√ºr 20 Bytes: <b>c = malloc (20)</b> , dieser Wert wird in den mittleren Block gestellt. <br><br><img src="https://habrastorage.org/webt/mu/zh/cm/muzhcmr1dbp7u7fhz6myj4d1iom.jpeg"><br><br>  <b>Buddy</b> hat eine interessante Eigenschaft: Wenn Sie Speicher in einem Block freigeben und daneben ein Block derselben Gr√∂√üe ist, kombiniert <b>Buddy</b> nach dem Freigeben beider Bl√∂cke zwei leere benachbarte Bl√∂cke zu einem. <br><br><img src="https://habrastorage.org/webt/72/0z/9t/720z9tqbxfmo-umch8rnd9uffry.jpeg"><br><br>  Wenn wir beispielsweise den Befehl <b>free ¬© geben</b> , wird <b>der</b> mittlere Block freigegeben, aber die Vereinigung wird nicht stattfinden, sodass der Block daneben weiterhin besch√§ftigt ist.  Nach dem Freigeben des ersten Blocks mit dem Befehl <b>free (a)</b> werden beide Bl√∂cke zu einem zusammengef√ºhrt.  Wenn wir dann den Wert von b freigeben, werden die benachbarten Bl√∂cke wieder zusammengef√ºhrt und wir erhalten einen ganzen Block mit einer Gr√∂√üe von 128 Bytes, wie es am Anfang war.  Der Vorteil dieses Ansatzes besteht darin, dass Sie durch einfache Arithmetik leicht herausfinden k√∂nnen, wo sich der Kumpel befindet, und Speichergrenzen bestimmen k√∂nnen.  So funktioniert die Speicherzuweisung mit dem <b>Buddy-Speicherzuweisungsansatz</b> . <br><br>  Allen meinen Vortr√§gen wird oft die Frage gestellt, ob ein solcher Ansatz nicht verschwenderisch ist.  Stellen Sie sich vor, ich h√§tte zu Beginn eine Anfrage f√ºr 65 Bytes, ich m√ºsste den gesamten Block von 128 Bytes daf√ºr zuweisen.  Ja, dies ist verschwenderisch. Tats√§chlich verf√ºgen Sie nicht √ºber einen dynamischen Speicher und k√∂nnen keine Ressourcen mehr im selben Block zuweisen.  Andererseits ist dies ein Kompromiss, da es sehr einfach ist, eine Berechnung durchzuf√ºhren, eine Fusion durchzuf√ºhren und dergleichen.  Wenn Sie also eine genauere Speicherzuordnung w√ºnschen, m√ºssen Sie einen anderen Ansatz verwenden. <br><br>  Was macht das <b>BBC-System (Buggy Bounce Checking)</b> ? <br><br><img src="https://habrastorage.org/webt/bw/ps/a9/bwpsa9a28xloyxprpcco0vw79ca.jpeg"><br><br>  Sie f√ºhrt mehrere Tricks aus, von denen einer die Trennung des Speicherblocks in zwei Teile ist, von denen einer ein Objekt enth√§lt und der zweite eine Erg√§nzung dazu ist.  Wir haben also zwei Arten von Grenzen - die Grenzen des Objekts und die Grenzen der Verteilung des Ged√§chtnisses.  Der Vorteil ist, dass die Basisadresse nicht gespeichert werden muss und eine schnelle Suche anhand einer Linientabelle m√∂glich ist. <br><br>  Alle unsere Verteilungsgr√∂√üen sind 2 hoch <b>n</b> , wobei <b>n</b> eine ganze Zahl ist.  Dieses <b>2n-</b> Prinzip nennt man <b>Zweierpotenz</b> .  Daher brauchen wir nicht viele Bits, um uns vorzustellen, wie gro√ü eine bestimmte Verteilungsgr√∂√üe ist.  Wenn die Clustergr√∂√üe beispielsweise 16 ist, m√ºssen Sie nur 4 Bits ausw√§hlen - dies ist das Konzept eines Logarithmus, dh 4 ist ein Exponent von <b>n</b> , in dem Sie die Zahl 2 erh√∂hen m√ºssen, um 16 zu erhalten. <br><br>  Dies ist ein ziemlich wirtschaftlicher Ansatz f√ºr die Speicherzuweisung, da die Mindestanzahl von Bytes verwendet wird, diese jedoch ein Vielfaches von 2 sein muss, dh Sie k√∂nnen 16 oder 32, jedoch nicht 33 Bytes haben.  Dar√ºber hinaus k√∂nnen Sie mit der <b>Buggy-Bounce-Pr√ºfung</b> Informationen zu Grenzwerten in einem linearen Array (1 Byte pro Datensatz) speichern und Speicher in einem Steckplatz mit einer Gr√∂√üe von 16 Byte zuweisen.  Ordnen Sie Speicher mit Steckplatzgranularit√§t zu.  Was bedeutet das? <br><br><img src="https://habrastorage.org/webt/3w/26/nm/3w26nmli9ja80jxthanvcktdhqq.jpeg"><br><br>  Wenn wir einen 16-Byte-Steckplatz haben, in den wir den Wert <b>p = malloc (16) setzen</b> , sieht der Wert in der Tabelle wie in <b>Tabelle [p / slot.size] = 4 aus</b> . <br><br><img src="https://habrastorage.org/webt/al/x7/vj/alx7vjrhny1zzkkjusqvt3iuv3c.jpeg"><br><br>  Angenommen, wir m√ºssen jetzt einen Wert von 32 Bytes in der Gr√∂√üe <b>p = malloc (32) platzieren</b> .  Wir m√ºssen die Randtabelle aktualisieren, um sie an die neue Gr√∂√üe anzupassen.  Dies geschieht zweimal: zuerst als <b>Tabelle [p / slot.size] = 5</b> und dann als <b>Tabelle [(p / slot.size) + 1] = 5</b> - das erste Mal f√ºr den ersten Steckplatz, der diesem Speicher zugewiesen ist, und den zweiten mal - f√ºr den zweiten Slot.  Somit weisen wir 32 Bytes Speicher zu.  So sieht das Gr√∂√üenverteilungsprotokoll aus.  Somit wird f√ºr zwei Speicherzuweisungsschlitze die Begrenzungstabelle zweimal aktualisiert.  Das ist klar?  Dieses Beispiel richtet sich an Personen, die bezweifeln, ob Protokolle und Tabellen eine Bedeutung haben oder nicht.  Weil Tabellen jedes Mal multipliziert werden, wenn eine Speicherzuweisung erfolgt. <br><br>  Mal sehen, was mit der Grenztabelle passiert.  Angenommen, wir haben einen Code C, der so aussieht: <b>p '= p + i</b> , dh der Zeiger <b>p' wird</b> aus <b>p durch</b> Hinzuf√ºgen einer Variablen <b>i erhalten</b> .  Wie erhalten wir also die f√ºr <b>p</b> zugewiesene Speichergr√∂√üe?  Dazu betrachten Sie die Tabelle unter den folgenden logischen Bedingungen: <br><br>  <b>size = 1 &lt;&lt; table [p &gt;&gt; log von slot_size]</b> <br><br><img src="https://habrastorage.org/webt/bo/pw/nv/bopwnvj0ek93xhrzu4vqwhcqcf8.jpeg"><br><br>  Rechts haben wir die Gr√∂√üe der f√ºr <b>p</b> zugewiesenen Daten, die 1 sein sollte. Dann verschieben Sie sie nach links und sehen sich die Tabelle an, nehmen diese Zeigergr√∂√üe und bewegen sich dann nach rechts, wo sich das Protokoll der Slot-Gr√∂√üentabelle befindet.  Wenn die Arithmetik funktioniert, haben wir den Zeiger korrekt an die Randtabelle gebunden.  Das hei√üt, die Gr√∂√üe des Zeigers muss gr√∂√üer als 1 sein, aber kleiner als die Gr√∂√üe des Schlitzes.  Links haben wir den Wert und rechts die Gr√∂√üe des Slots und der Zeigerwert befindet sich zwischen ihnen. <br><br>  Angenommen, die Gr√∂√üe des Zeigers betr√§gt 32 Byte, dann haben wir in der Tabelle in den Klammern die Nummer 5. <br><br>  Angenommen, wir m√∂chten das Basisschl√ºsselwort dieses Zeigers finden: <b>base = p &amp; n (Gr√∂√üe - 1)</b> .  Was wir tun werden, gibt uns eine bestimmte Masse, und diese Masse wird es uns erm√∂glichen, die hier befindliche <b>Basis</b> wiederherzustellen.  Stellen Sie sich vor, unsere Gr√∂√üe ist 16, bin√§r 16 = ... 0010000.  Die Auslassungspunkte bedeuten, dass es immer noch viele Nullen gibt, aber wir interessieren uns f√ºr diese Einheit und die Nullen dahinter.  Wenn wir (16 -1) betrachten, sieht es ungef√§hr so ‚Äã‚Äãaus: (16-1) = ... 0001111.  Im Bin√§rcode sieht die Umkehrung folgenderma√üen aus: ~ (16-1) ... 1110000. <br><br><img src="https://habrastorage.org/webt/8q/yj/xz/8qyjxz4dqge5f0oygbg1bhszkks.jpeg"><br><br><img src="https://habrastorage.org/webt/ue/2h/hb/ue2hhb2uzpelqgvzpmzi75c6-mo.jpeg"><br><br>  Auf diese Weise k√∂nnen wir das Bit, das im Wesentlichen vom aktuellen Zeiger gerendert wird, im Grunde l√∂schen und uns seine <b>Basis geben</b> .  Dank dessen ist es f√ºr uns sehr einfach zu √ºberpr√ºfen, ob sich dieser Zeiger innerhalb der Grenzen befindet.  Wir k√∂nnen also einfach √ºberpr√ºfen, ob <b>(p ')&gt; = Basis ist</b> und ob der Wert ( <b>p'</b> - Basis) kleiner als die ausgew√§hlte Gr√∂√üe ist. <br><br><img src="https://habrastorage.org/webt/x6/w8/il/x6w8ilmsiya6i3irbyat6nd51cy.jpeg"><br><br>  Dies ist eine ziemlich einfache Sache, um herauszufinden, ob sich der Zeiger innerhalb der Speichergrenzen befindet.  Ich werde nicht auf Details eingehen, es gen√ºgt zu sagen, dass alle bin√§ren Arithmetiken auf die gleiche Weise aufgel√∂st werden.  Mit solchen Tricks k√∂nnen Sie komplexere Berechnungen vermeiden. <br><br>  Es gibt noch eine f√ºnfte Eigenschaft der <b>Buggy-Bounce-Pr√ºfung</b> : Sie verwendet ein virtuelles Speichersystem, um zu verhindern, dass die f√ºr den Zeiger festgelegten Grenzen √ºberschritten werden.  Die Hauptidee ist, dass wir, wenn wir eine solche Arithmetik f√ºr den Zeiger haben, mit dem wir den Ausweg bestimmen, ein Bit h√∂herer Ordnung f√ºr den Zeiger setzen k√∂nnen. <br><br><img src="https://habrastorage.org/webt/ns/56/tz/ns56tz8drovqvtuwnrsc6qanksc.jpeg"><br><br>  Auf diese Weise stellen wir sicher, dass die Dereferenzierung des Zeigers keine Hardwareprobleme verursacht.  Das Setzen des <b>Bits hoher Ordnung</b> allein verursacht keine Probleme, die Dereferenzierung des Zeigers kann ein Problem verursachen. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/r4KjHEgg9Wg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Die Vollversion des Kurses finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><br>  Vielen Dank f√ºr Ihren Aufenthalt bei uns.  Gef√§llt dir unser Artikel?  M√∂chten Sie weitere interessante Materialien sehen?  Unterst√ºtzen Sie uns, indem Sie eine Bestellung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">aufgeben</a> oder sie Ihren Freunden empfehlen. <b>Habr-Benutzer erhalten 30% Rabatt auf ein einzigartiges Analogon von Einstiegsservern, das wir f√ºr Sie erfunden haben:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die ganze Wahrheit √ºber VPS (KVM) E5-2650 v4 (6 Kerne) 10 GB DDR4 240 GB SSD 1 Gbit / s $ 20 oder wie teilt man den Server?</a>  (Optionen sind mit RAID1 und RAID10, bis zu 24 Kernen und bis zu 40 GB DDR4 verf√ºgbar). <br><br>  <b>Dell R730xd 2 mal g√ºnstiger?</b>  Nur wir haben <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2 x Intel Dodeca-Core Xeon E5-2650v4 128 GB DDR4 6 x 480 GB SSD 1 Gbit / s 100 TV von 249 US-Dollar</a> in den Niederlanden und den USA!</b>  Lesen Sie mehr √ºber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">den Aufbau eines Infrastrukturgeb√§udes.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Klasse mit Dell R730xd E5-2650 v4 Servern f√ºr 9.000 Euro f√ºr einen Cent?</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de416727/">https://habr.com/ru/post/de416727/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de416713/index.html">Bericht des Club of Rome 2018, Kapitel 3.14: ‚ÄûKein einziges BIP ...‚Äú</a></li>
<li><a href="../de416719/index.html">Erweiterung PHP und Kotlin Native. Teil Zwei, bewusst</a></li>
<li><a href="../de416721/index.html">DIY House: Puppenh√§user f√ºr Erwachsene</a></li>
<li><a href="../de416723/index.html">API-Barrierefreiheit: Schnittstellen in nat√ºrlicher Sprache</a></li>
<li><a href="../de416725/index.html">Kotlin DSL: Theorie und Praxis</a></li>
<li><a href="../de416729/index.html">Das Programm von PYCON RUSSIA ist fertig: 25 Berichte und 3 Workshops von Rednern von Google, Red Hat, Yelp und Yandex</a></li>
<li><a href="../de416731/index.html">Frost auf Glas: Wie man Hochleistungskunststoff aus Metall herstellt</a></li>
<li><a href="../de416737/index.html">A * Pfadfindungsalgorithmus in einem Voxel 3d Unity-Spiel</a></li>
<li><a href="../de416739/index.html">Neues ASUS auf der Computex 2018</a></li>
<li><a href="../de416741/index.html">Angreifer verwendeten gestohlene D-Link-Zertifikate in ihrer Software f√ºr Passwortdiebstahl</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>