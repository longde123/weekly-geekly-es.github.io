<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⛹🏾 🤪 ✂️ MIT-Kurs "Computer Systems Security". Vorlesung 2: „Kontrolle von Hackerangriffen“, Teil 3 🍪 ♨️ 🌙</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Massachusetts Institute of Technology. Vorlesung # 6.858. "Sicherheit von Computersystemen." Nikolai Zeldovich, James Mickens. 2014 Jahr 
 Computer Sy...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MIT-Kurs "Computer Systems Security". Vorlesung 2: „Kontrolle von Hackerangriffen“, Teil 3</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ua-hosting/blog/416727/"><h3>  Massachusetts Institute of Technology.  Vorlesung # 6.858.  "Sicherheit von Computersystemen."  Nikolai Zeldovich, James Mickens.  2014 Jahr </h3><br>  Computer Systems Security ist ein Kurs zur Entwicklung und Implementierung sicherer Computersysteme.  Die Vorträge behandeln Bedrohungsmodelle, Angriffe, die die Sicherheit gefährden, und Sicherheitstechniken, die auf jüngsten wissenschaftlichen Arbeiten basieren.  Zu den Themen gehören Betriebssystemsicherheit, Funktionen, Informationsflussmanagement, Sprachsicherheit, Netzwerkprotokolle, Hardwaresicherheit und Sicherheit von Webanwendungen. <br><br>  Vorlesung 1: „Einführung: Bedrohungsmodelle“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3</a> <br>  Vorlesung 2: „Kontrolle von Hackerangriffen“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3</a> <a name="habracut"></a><br><br>  Können Sie mir sagen, was das Fehlen eines Sicherheitsansatzes ist, der eine <b>Schutzseite verwendet</b> ? <br><br>  <b>Teilnehmerin:</b> Es dauert länger! <br><br>  <b>Professor:</b> genau!  Stellen Sie sich also vor, dieser Haufen ist sehr, sehr klein, aber ich habe eine ganze Seite ausgewählt, um sicherzustellen, dass dieses kleine Ding nicht von einem Zeiger angegriffen wurde.  Dies ist ein sehr räumlich intensiver Prozess, und die Leute setzen so etwas nicht in einer Arbeitsumgebung ein.  Dies kann nützlich sein, um "Fehler" zu testen, aber Sie würden dies niemals für ein echtes Programm tun.  Ich denke, jetzt verstehen Sie, was ein <b>Elektrozaun-</b> Speicher-Debugger ist. <br><br>  <b>Teilnehmerin:</b> Warum sollte die <b>Schutzseite</b> so groß sein? <br><br>  <b>Professor: Der</b> Grund dafür ist, dass sie normalerweise auf Hardware wie den Schutz auf Seitenebene angewiesen sind, um die Seitengrößen zu bestimmen.  Bei den meisten Computern werden jedem zugewiesenen Puffer 2 Seiten mit einer Größe von 4 KB zugewiesen, insgesamt 8 KB.  Da der Heap aus Objekten besteht, wird jeder <b>Malloc-</b> Funktion eine separate Seite zugewiesen.  In einigen Modi gibt dieser Debugger den reservierten Speicherplatz nicht an das Programm zurück, sodass der <b>Elektrozaun</b> in Bezug auf den Speicher sehr unersättlich ist und nicht mit Arbeitscode kompiliert werden sollte. <br><br><img src="https://habrastorage.org/webt/cm/l6/oh/cml6ohlrz3im72yoa5u_6n9pomg.jpeg"><br><br>  Ein weiterer Sicherheitsansatz, der einen Blick wert ist, heißt <b>Fat Pointers</b> oder "Thick Pointers".  In diesem Fall bedeutet der Begriff "dick", dass eine große Datenmenge an den Zeiger angehängt wird.  In diesem Fall besteht die Idee darin, die Darstellung des Zeigers zu ändern, um Informationen über die Grenzen in seine Zusammensetzung aufzunehmen. <br><br>  Ein regulärer 32-Bit-Zeiger besteht aus 32 Bit, und Adressen befinden sich darin.  Wenn wir den "dicken Zeiger" betrachten, dann besteht er aus 3 Teilen.  Der erste Teil ist eine 4-Byte-Basis, an die auch ein Ende von 4 Bytes angehängt ist.  Im ersten Teil beginnt das Objekt, im zweiten endet es und im dritten, ebenfalls 4 Byte, ist die Adresse <b>cur</b> eingeschlossen.  Und innerhalb dieser gemeinsamen Grenzen befindet sich ein Zeiger. <br><br><img src="https://habrastorage.org/webt/jd/2o/83/jd2o83flkobiu3caqetom5wpwj8.jpeg"><br><br>  Wenn der Compiler einen Zugriffscode für diesen "dicken Zeiger" generiert, aktualisiert er den Inhalt des letzten Teils der <b>aktuellen Adresse</b> und überprüft gleichzeitig den Inhalt der ersten beiden Teile, um sicherzustellen, dass während des Aktualisierungsvorgangs nichts Schlimmes mit dem Zeiger passiert ist. <br><br>  Stellen Sie sich vor, ich habe diesen Code: <b>int * ptr = malloc (8)</b> , dies ist ein Zeiger, dem 8 Bytes zugewiesen sind.  Als nächstes habe ich eine <b>while-Schleife</b> , die gerade dabei ist, dem Zeiger einen Wert zuzuweisen, und dann folgt das <b>ptr ++ -</b> Zeigerinkrement.  Jedes Mal, wenn dieser Code an der aktuellen Adresse des aktuellen Adresszeigers ausgeführt wird, wird geprüft, ob sich der Zeiger innerhalb der im ersten und zweiten Teil angegebenen Grenzen befindet. <br><br>  Dies ist bei dem neuen Code der Fall, den der Compiler generiert.  Eine Online-Gruppe wirft häufig die Frage auf, was „Werkzeugcode“ ist.  Dies ist der Code, den der Compiler generiert.  Als Programmierer sehen Sie nur das, was rechts angezeigt wird - diese 4 Zeilen.  Vor dieser Operation fügt der Compiler jedoch einen neuen C-Code in die <b>aktuelle Adresse ein</b> , weist dem Zeiger einen Wert zu und überprüft jedes Mal die Grenzen. <br><br><img src="https://habrastorage.org/webt/w7/am/vx/w7amvxvkol7dhdi3qdrpkupsgga.jpeg"><br><br>  Und wenn bei Verwendung des neuen Codes der Wert die Grenzen überschreitet, wird die Funktion unterbrochen.  Dies wird als "Werkzeugcode" bezeichnet.  Dies bedeutet, dass Sie den Quellcode mit einem C-Programm verwenden, dann den neuen C-Quellcode hinzufügen und dann das neue Programm kompilieren.  Die Grundidee hinter <b>Fat Pointers</b> ist also ziemlich einfach. <br><br>  Dieser Ansatz weist einige Nachteile auf.  Der größte Nachteil ist die Größe des Zeigers.  Dies bedeutet, dass Sie den "dicken Zeiger" nicht einfach unverändert außerhalb der Shell-Bibliothek übergeben können.  Möglicherweise wird erwartet, dass der Zeiger eine Standardgröße hat, und das Programm stellt ihm diese Größe zur Verfügung, in die er „nicht passt“, wodurch alles explodiert.  Es gibt auch Probleme, wenn Sie Zeiger dieses Typs in eine <b>Struktur</b> oder ähnliches aufnehmen möchten, da sie die Größe der <b>Struktur</b> ändern können. <br><br>  Daher ist es in C-Code sehr beliebt, etwas von der Größe einer <b>Struktur</b> zu nehmen und dann etwas basierend auf dieser Größe zu tun - reservieren Sie Speicherplatz für Strukturen dieser Größe und so weiter. <br><br>  Und noch heikler ist, dass diese Zeiger in der Regel nicht atomar aktualisiert werden können.  Für 32-Bit-Architekturen ist es typisch, eine atomare 32-Bit-Variable zu schreiben.  "Dicke Zeiger" enthalten jedoch 3 <b>Ganzzahlgrößen.</b> Wenn Sie also Code haben, der erwartet, dass der Zeiger einen atomaren Wert hat, können Probleme auftreten.  Denn um einige dieser Überprüfungen durchzuführen, müssen Sie sich die aktuelle Adresse und dann die Größen ansehen, und dann müssen Sie sie möglicherweise erhöhen, und so weiter und so fort.  Dies kann daher zu sehr subtilen Fehlern führen, wenn Sie Code verwenden, der versucht, Parallelen zwischen regulären und dicken Zeigern zu ziehen.  Daher können Sie in einigen Fällen <b>Fettzeiger</b> wie <b>Elektrozäune verwenden</b> , aber die Nebenwirkungen ihrer Verwendung sind so bedeutend, dass diese Ansätze in der normalen Praxis nicht verwendet werden. <br><br>  Und jetzt werden wir über das Überprüfen von Grenzen in Bezug auf die Struktur von Schattendaten sprechen.  Die Hauptidee der Struktur besteht darin, dass Sie wissen, wie groß jedes Objekt ist, das Sie platzieren möchten, dh dass Sie die Größe kennen, die Sie für dieses Objekt reservieren müssen.  Wenn Sie beispielsweise einen Zeiger haben, den Sie mit der Funktion <b>malloc</b> aufrufen, müssen Sie die Größe des Objekts angeben: <b>char xp = malloc (Größe)</b> . <br><br><img src="https://habrastorage.org/webt/40/5x/vq/405xvqrcdftphffsqkxgqxprhfo.jpeg"><br><br>  Wenn Sie so etwas wie eine statische Variable wie dieses <b>char p [256] haben</b> , kann der Compiler automatisch herausfinden, welche Grenzen für seine Platzierung gelten sollen. <br><br>  Daher müssen Sie für jeden dieser Zeiger zwei Operationen einfügen.  Dies ist hauptsächlich eine Arithmetik wie <b>q = p + 7</b> oder ähnliches.  Diese Einfügung erfolgt durch Dereferenzieren eines Links vom Typ <b>deref * q = 'q'</b> .  Sie fragen sich vielleicht, warum Sie sich beim Einfügen nicht auf den Link verlassen können?  Warum müssen wir diese Arithmetik machen?  Tatsache ist, dass Sie bei Verwendung von C und c ++ einen Zeiger haben, der auf einen Durchgang zum gültigen Ende des Objekts auf der rechten Seite zeigt. Danach verwenden Sie ihn als Stoppbedingung.  Sie gehen also zum Objekt und sobald Sie diesen nachfolgenden Zeiger erreichen, stoppen Sie tatsächlich die Schleife oder brechen die Operation ab. <br><br>  Wenn wir also die Arithmetik ignorieren, verursachen wir immer einen schwerwiegenden Fehler, bei dem der Zeiger die Grenzen überschreitet, was die Arbeit vieler Anwendungen tatsächlich stören kann.  Wir können also nicht einfach den Link einfügen, denn woher wissen Sie, dass dies außerhalb der festgelegten Grenzen geschieht?  Die Arithmetik erlaubt es uns zu sagen, ob es so ist oder nicht, und hier wird alles rechtmäßig und korrekt sein.  Da Sie mit diesem Arithmetik-Keil verfolgen können, wo sich der Zeiger relativ zu seiner ursprünglichen Grundlinie befindet. <br><br>  Die nächste Frage lautet also: Wie implementieren wir tatsächlich die Grenzvalidierung?  Weil wir die spezifische Adresse des Zeigers irgendwie mit einer Art Grenzinformation für diesen Zeiger abgleichen müssen.  Daher verwenden viele Ihrer vorherigen Entscheidungen Dinge wie beispielsweise eine Hash-Tabelle oder einen Baum, mit denen Sie die richtige Suche durchführen können.  Angesichts der Adresse des Zeigers suche ich in dieser Datenstruktur und finde heraus, welche Grenzen sie hat.  Angesichts dieser Grenzen entscheide ich, ob ich die Aktion zulassen kann oder nicht.  Das Problem ist, dass dies eine langsame Suche ist, da diese Datenstrukturen verzweigt sind. Wenn Sie einen Baum untersuchen, müssen Sie eine Reihe solcher Verzweigungen untersuchen, bis Sie den richtigen Wert gefunden haben.  Und selbst wenn es sich um eine Hash-Tabelle handelt, müssen Sie den Codeketten folgen und so weiter.  Daher müssen wir eine sehr effektive Datenstruktur definieren, die ihre Grenzen verfolgt und die diese Überprüfung sehr einfach und klar macht.  Also lasst uns gleich loslegen. <br><br>  Aber bevor wir das tun, möchte ich Ihnen kurz erläutern, wie der Ansatz der <b>Buddy-Speicherzuweisung</b> funktioniert.  Weil dies eines der Dinge ist, die oft gefragt werden. <br>  <b>Die Buddy-Speicherzuweisung</b> unterteilt den Speicher in Partitionen mit einem Vielfachen der Zweierpotenz und versucht, Speicheranforderungen in ihnen zuzuweisen.  Mal sehen, wie es funktioniert.  Zu Beginn behandelt die <b>Buddy-Zuweisung</b> nicht zugewiesenen Speicher als einen großen Block - dies ist das obere 128-Bit-Rechteck.  Wenn Sie dann einen kleineren Block für die dynamische Zuordnung anfordern, wird versucht, diesen Adressraum in Schritten von 2 in Teile aufzuteilen, bis ein für Ihre Anforderungen ausreichender Block gefunden wird. <br><br>  Angenommen, eine Anforderung vom Typ <b>a = malloc (28) ist</b> eingetroffen, <b>dh</b> eine Anforderung zum Zuweisen von 28 Bytes.  Wir haben einen 128-Byte-Block, der zu verschwenderisch ist, um ihn für diese Anforderung zuzuweisen.  Daher ist unser Block in zwei Blöcke mit 64 Bytes unterteilt - von 0 bis 64 Bytes und von 64 Bytes bis 128 Bytes.  Und diese Größe ist auch groß für unsere Anfrage, so dass <b>Buddy</b> wieder einen Block von 64 Bytes in 2 Teile teilt und 2 Blöcke von 32 Bytes empfängt. <br><br><img src="https://habrastorage.org/webt/uj/mt/er/ujmter8tqrakf5gu4pel0v8eawc.jpeg"><br><br>  Weniger ist unmöglich, da 28 Bytes nicht passen und 32 die am besten geeignete Mindestgröße ist.  Dieser 32-Byte-Block wird nun unserer Adresse a zugewiesen.  Angenommen, wir haben eine andere Abfrage für <b>b = malloc (50)</b> .  <b>Buddy</b> überprüft die ausgewählten Blöcke und setzt den Wert b in den Block ganz rechts, da 50 größer als die Hälfte von 64, aber kleiner als 64 ist. <br><br>  Schließlich haben wir eine weitere Anforderung für 20 Bytes: <b>c = malloc (20)</b> , dieser Wert wird in den mittleren Block gestellt. <br><br><img src="https://habrastorage.org/webt/mu/zh/cm/muzhcmr1dbp7u7fhz6myj4d1iom.jpeg"><br><br>  <b>Buddy</b> hat eine interessante Eigenschaft: Wenn Sie Speicher in einem Block freigeben und daneben ein Block derselben Größe ist, kombiniert <b>Buddy</b> nach dem Freigeben beider Blöcke zwei leere benachbarte Blöcke zu einem. <br><br><img src="https://habrastorage.org/webt/72/0z/9t/720z9tqbxfmo-umch8rnd9uffry.jpeg"><br><br>  Wenn wir beispielsweise den Befehl <b>free © geben</b> , wird <b>der</b> mittlere Block freigegeben, aber die Vereinigung wird nicht stattfinden, sodass der Block daneben weiterhin beschäftigt ist.  Nach dem Freigeben des ersten Blocks mit dem Befehl <b>free (a)</b> werden beide Blöcke zu einem zusammengeführt.  Wenn wir dann den Wert von b freigeben, werden die benachbarten Blöcke wieder zusammengeführt und wir erhalten einen ganzen Block mit einer Größe von 128 Bytes, wie es am Anfang war.  Der Vorteil dieses Ansatzes besteht darin, dass Sie durch einfache Arithmetik leicht herausfinden können, wo sich der Kumpel befindet, und Speichergrenzen bestimmen können.  So funktioniert die Speicherzuweisung mit dem <b>Buddy-Speicherzuweisungsansatz</b> . <br><br>  Allen meinen Vorträgen wird oft die Frage gestellt, ob ein solcher Ansatz nicht verschwenderisch ist.  Stellen Sie sich vor, ich hätte zu Beginn eine Anfrage für 65 Bytes, ich müsste den gesamten Block von 128 Bytes dafür zuweisen.  Ja, dies ist verschwenderisch. Tatsächlich verfügen Sie nicht über einen dynamischen Speicher und können keine Ressourcen mehr im selben Block zuweisen.  Andererseits ist dies ein Kompromiss, da es sehr einfach ist, eine Berechnung durchzuführen, eine Fusion durchzuführen und dergleichen.  Wenn Sie also eine genauere Speicherzuordnung wünschen, müssen Sie einen anderen Ansatz verwenden. <br><br>  Was macht das <b>BBC-System (Buggy Bounce Checking)</b> ? <br><br><img src="https://habrastorage.org/webt/bw/ps/a9/bwpsa9a28xloyxprpcco0vw79ca.jpeg"><br><br>  Sie führt mehrere Tricks aus, von denen einer die Trennung des Speicherblocks in zwei Teile ist, von denen einer ein Objekt enthält und der zweite eine Ergänzung dazu ist.  Wir haben also zwei Arten von Grenzen - die Grenzen des Objekts und die Grenzen der Verteilung des Gedächtnisses.  Der Vorteil ist, dass die Basisadresse nicht gespeichert werden muss und eine schnelle Suche anhand einer Linientabelle möglich ist. <br><br>  Alle unsere Verteilungsgrößen sind 2 hoch <b>n</b> , wobei <b>n</b> eine ganze Zahl ist.  Dieses <b>2n-</b> Prinzip nennt man <b>Zweierpotenz</b> .  Daher brauchen wir nicht viele Bits, um uns vorzustellen, wie groß eine bestimmte Verteilungsgröße ist.  Wenn die Clustergröße beispielsweise 16 ist, müssen Sie nur 4 Bits auswählen - dies ist das Konzept eines Logarithmus, dh 4 ist ein Exponent von <b>n</b> , in dem Sie die Zahl 2 erhöhen müssen, um 16 zu erhalten. <br><br>  Dies ist ein ziemlich wirtschaftlicher Ansatz für die Speicherzuweisung, da die Mindestanzahl von Bytes verwendet wird, diese jedoch ein Vielfaches von 2 sein muss, dh Sie können 16 oder 32, jedoch nicht 33 Bytes haben.  Darüber hinaus können Sie mit der <b>Buggy-Bounce-Prüfung</b> Informationen zu Grenzwerten in einem linearen Array (1 Byte pro Datensatz) speichern und Speicher in einem Steckplatz mit einer Größe von 16 Byte zuweisen.  Ordnen Sie Speicher mit Steckplatzgranularität zu.  Was bedeutet das? <br><br><img src="https://habrastorage.org/webt/3w/26/nm/3w26nmli9ja80jxthanvcktdhqq.jpeg"><br><br>  Wenn wir einen 16-Byte-Steckplatz haben, in den wir den Wert <b>p = malloc (16) setzen</b> , sieht der Wert in der Tabelle wie in <b>Tabelle [p / slot.size] = 4 aus</b> . <br><br><img src="https://habrastorage.org/webt/al/x7/vj/alx7vjrhny1zzkkjusqvt3iuv3c.jpeg"><br><br>  Angenommen, wir müssen jetzt einen Wert von 32 Bytes in der Größe <b>p = malloc (32) platzieren</b> .  Wir müssen die Randtabelle aktualisieren, um sie an die neue Größe anzupassen.  Dies geschieht zweimal: zuerst als <b>Tabelle [p / slot.size] = 5</b> und dann als <b>Tabelle [(p / slot.size) + 1] = 5</b> - das erste Mal für den ersten Steckplatz, der diesem Speicher zugewiesen ist, und den zweiten mal - für den zweiten Slot.  Somit weisen wir 32 Bytes Speicher zu.  So sieht das Größenverteilungsprotokoll aus.  Somit wird für zwei Speicherzuweisungsschlitze die Begrenzungstabelle zweimal aktualisiert.  Das ist klar?  Dieses Beispiel richtet sich an Personen, die bezweifeln, ob Protokolle und Tabellen eine Bedeutung haben oder nicht.  Weil Tabellen jedes Mal multipliziert werden, wenn eine Speicherzuweisung erfolgt. <br><br>  Mal sehen, was mit der Grenztabelle passiert.  Angenommen, wir haben einen Code C, der so aussieht: <b>p '= p + i</b> , dh der Zeiger <b>p' wird</b> aus <b>p durch</b> Hinzufügen einer Variablen <b>i erhalten</b> .  Wie erhalten wir also die für <b>p</b> zugewiesene Speichergröße?  Dazu betrachten Sie die Tabelle unter den folgenden logischen Bedingungen: <br><br>  <b>size = 1 &lt;&lt; table [p &gt;&gt; log von slot_size]</b> <br><br><img src="https://habrastorage.org/webt/bo/pw/nv/bopwnvj0ek93xhrzu4vqwhcqcf8.jpeg"><br><br>  Rechts haben wir die Größe der für <b>p</b> zugewiesenen Daten, die 1 sein sollte. Dann verschieben Sie sie nach links und sehen sich die Tabelle an, nehmen diese Zeigergröße und bewegen sich dann nach rechts, wo sich das Protokoll der Slot-Größentabelle befindet.  Wenn die Arithmetik funktioniert, haben wir den Zeiger korrekt an die Randtabelle gebunden.  Das heißt, die Größe des Zeigers muss größer als 1 sein, aber kleiner als die Größe des Schlitzes.  Links haben wir den Wert und rechts die Größe des Slots und der Zeigerwert befindet sich zwischen ihnen. <br><br>  Angenommen, die Größe des Zeigers beträgt 32 Byte, dann haben wir in der Tabelle in den Klammern die Nummer 5. <br><br>  Angenommen, wir möchten das Basisschlüsselwort dieses Zeigers finden: <b>base = p &amp; n (Größe - 1)</b> .  Was wir tun werden, gibt uns eine bestimmte Masse, und diese Masse wird es uns ermöglichen, die hier befindliche <b>Basis</b> wiederherzustellen.  Stellen Sie sich vor, unsere Größe ist 16, binär 16 = ... 0010000.  Die Auslassungspunkte bedeuten, dass es immer noch viele Nullen gibt, aber wir interessieren uns für diese Einheit und die Nullen dahinter.  Wenn wir (16 -1) betrachten, sieht es ungefähr so ​​aus: (16-1) = ... 0001111.  Im Binärcode sieht die Umkehrung folgendermaßen aus: ~ (16-1) ... 1110000. <br><br><img src="https://habrastorage.org/webt/8q/yj/xz/8qyjxz4dqge5f0oygbg1bhszkks.jpeg"><br><br><img src="https://habrastorage.org/webt/ue/2h/hb/ue2hhb2uzpelqgvzpmzi75c6-mo.jpeg"><br><br>  Auf diese Weise können wir das Bit, das im Wesentlichen vom aktuellen Zeiger gerendert wird, im Grunde löschen und uns seine <b>Basis geben</b> .  Dank dessen ist es für uns sehr einfach zu überprüfen, ob sich dieser Zeiger innerhalb der Grenzen befindet.  Wir können also einfach überprüfen, ob <b>(p ')&gt; = Basis ist</b> und ob der Wert ( <b>p'</b> - Basis) kleiner als die ausgewählte Größe ist. <br><br><img src="https://habrastorage.org/webt/x6/w8/il/x6w8ilmsiya6i3irbyat6nd51cy.jpeg"><br><br>  Dies ist eine ziemlich einfache Sache, um herauszufinden, ob sich der Zeiger innerhalb der Speichergrenzen befindet.  Ich werde nicht auf Details eingehen, es genügt zu sagen, dass alle binären Arithmetiken auf die gleiche Weise aufgelöst werden.  Mit solchen Tricks können Sie komplexere Berechnungen vermeiden. <br><br>  Es gibt noch eine fünfte Eigenschaft der <b>Buggy-Bounce-Prüfung</b> : Sie verwendet ein virtuelles Speichersystem, um zu verhindern, dass die für den Zeiger festgelegten Grenzen überschritten werden.  Die Hauptidee ist, dass wir, wenn wir eine solche Arithmetik für den Zeiger haben, mit dem wir den Ausweg bestimmen, ein Bit höherer Ordnung für den Zeiger setzen können. <br><br><img src="https://habrastorage.org/webt/ns/56/tz/ns56tz8drovqvtuwnrsc6qanksc.jpeg"><br><br>  Auf diese Weise stellen wir sicher, dass die Dereferenzierung des Zeigers keine Hardwareprobleme verursacht.  Das Setzen des <b>Bits hoher Ordnung</b> allein verursacht keine Probleme, die Dereferenzierung des Zeigers kann ein Problem verursachen. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/r4KjHEgg9Wg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Die Vollversion des Kurses finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><br>  Vielen Dank für Ihren Aufenthalt bei uns.  Gefällt dir unser Artikel?  Möchten Sie weitere interessante Materialien sehen?  Unterstützen Sie uns, indem Sie eine Bestellung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">aufgeben</a> oder sie Ihren Freunden empfehlen. <b>Habr-Benutzer erhalten 30% Rabatt auf ein einzigartiges Analogon von Einstiegsservern, das wir für Sie erfunden haben:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die ganze Wahrheit über VPS (KVM) E5-2650 v4 (6 Kerne) 10 GB DDR4 240 GB SSD 1 Gbit / s $ 20 oder wie teilt man den Server?</a>  (Optionen sind mit RAID1 und RAID10, bis zu 24 Kernen und bis zu 40 GB DDR4 verfügbar). <br><br>  <b>Dell R730xd 2 mal günstiger?</b>  Nur wir haben <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2 x Intel Dodeca-Core Xeon E5-2650v4 128 GB DDR4 6 x 480 GB SSD 1 Gbit / s 100 TV von 249 US-Dollar</a> in den Niederlanden und den USA!</b>  Lesen Sie mehr über <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">den Aufbau eines Infrastrukturgebäudes.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Klasse mit Dell R730xd E5-2650 v4 Servern für 9.000 Euro für einen Cent?</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de416727/">https://habr.com/ru/post/de416727/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de416713/index.html">Bericht des Club of Rome 2018, Kapitel 3.14: „Kein einziges BIP ...“</a></li>
<li><a href="../de416719/index.html">Erweiterung PHP und Kotlin Native. Teil Zwei, bewusst</a></li>
<li><a href="../de416721/index.html">DIY House: Puppenhäuser für Erwachsene</a></li>
<li><a href="../de416723/index.html">API-Barrierefreiheit: Schnittstellen in natürlicher Sprache</a></li>
<li><a href="../de416725/index.html">Kotlin DSL: Theorie und Praxis</a></li>
<li><a href="../de416729/index.html">Das Programm von PYCON RUSSIA ist fertig: 25 Berichte und 3 Workshops von Rednern von Google, Red Hat, Yelp und Yandex</a></li>
<li><a href="../de416731/index.html">Frost auf Glas: Wie man Hochleistungskunststoff aus Metall herstellt</a></li>
<li><a href="../de416737/index.html">A * Pfadfindungsalgorithmus in einem Voxel 3d Unity-Spiel</a></li>
<li><a href="../de416739/index.html">Neues ASUS auf der Computex 2018</a></li>
<li><a href="../de416741/index.html">Angreifer verwendeten gestohlene D-Link-Zertifikate in ihrer Software für Passwortdiebstahl</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>