<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘€ ğŸ‘©ğŸ¿â€ğŸ¤â€ğŸ‘©ğŸ½ ğŸ¤ğŸ¾ Bagaimana grafik jaringan saraf membantu ğŸ‘¨ğŸ¾â€ğŸ¤â€ğŸ‘¨ğŸ¼ ğŸ›¢ï¸ ğŸ‘€</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pada tahun 1943, neuropsikolog Amerika, McCallock dan Pitts mengembangkan model komputer dari jaringan saraf, dan pada tahun 1958 jaringan single-laye...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana grafik jaringan saraf membantu</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/441260/">  Pada tahun 1943, neuropsikolog Amerika, McCallock dan Pitts mengembangkan model komputer dari jaringan saraf, dan pada tahun 1958 jaringan single-layer <strong>pertama yang bekerja</strong> mengenali beberapa huruf.  Sekarang, jaringan saraf tidak hanya digunakan untuk apa: untuk memprediksi nilai tukar, mendiagnosis penyakit, autopilot, dan membuat grafik dalam permainan komputer.  Tentang yang terakhir dan bicara. <br><br>  <strong>Evgeni Tumanov</strong> bekerja sebagai insinyur Deep Learning di <strong>NVIDIA</strong> .  Berdasarkan hasil pidatonya di konferensi HighLoad ++, kami menyiapkan cerita tentang penggunaan Machine Learning dan Deep Learning dalam grafik.  Pembelajaran mesin tidak berakhir dengan NLP, Visi Komputer, sistem rekomendasi, dan tugas pencarian.  Bahkan jika Anda tidak terlalu mengenal bidang ini, Anda dapat menerapkan praktik terbaik dari artikel di bidang atau industri Anda. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/eeCYmJQAyKA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Kisah itu akan terdiri dari tiga bagian.  Kami akan meninjau tugas-tugas dalam grafik yang diselesaikan dengan bantuan pembelajaran mesin, mendapatkan ide utama, dan menggambarkan kasus penerapan ide ini dalam tugas tertentu, dan khususnya dalam <b>rendering awan</b> . <a name="habracut"></a><br><br><h2>  DL / ML yang diawasi dalam grafik, atau pelatihan guru dalam grafik </h2><br>  Mari kita menganalisis dua kelompok tugas.  Untuk memulainya, kami secara singkat menunjukkannya. <br><br>  <strong>Dunia Nyata atau render engine</strong> : <br><br><ul><li>  Pembuatan animasi yang dapat dipercaya: penggerak, animasi wajah. </li><li>  Gambar yang diberikan setelah pemrosesan: supersampling, anti-aliasing. </li><li>  Slowmotion: interpolasi bingkai. </li><li>  Generasi material. </li></ul><br>  Kelompok tugas kedua sekarang secara konvensional disebut " <strong>Algoritma berat</strong> ".  Kami menyertakan tugas-tugas seperti rendering objek kompleks, seperti awan, dan <strong>simulasi fisik</strong> : air, asap. <br><br>  Tujuan kami adalah untuk memahami perbedaan mendasar antara kedua kelompok.  Mari kita bahas tugas-tugasnya lebih detail. <br><br><h3>  Pembuatan animasi yang dapat dipercaya: penggerak, animasi wajah <br></h3><br>  Dalam beberapa tahun terakhir, banyak <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel telah muncul</a> , di mana para peneliti menawarkan cara-cara baru untuk menghasilkan animasi yang indah.  Menggunakan karya seniman itu mahal, dan menggantinya dengan algoritma akan sangat bermanfaat bagi semua orang.  Setahun yang lalu, di NVIDIA, kami mengerjakan sebuah proyek di mana kami terlibat dalam animasi wajah karakter dalam game: menyinkronkan wajah pahlawan dengan trek audio pidato.  Kami mencoba untuk "menghidupkan kembali" wajah sehingga setiap titik di atasnya bergerak, dan di atas semua bibir, karena ini adalah momen paling sulit dalam animasi.  Secara manual seorang seniman melakukan ini secara mahal dan untuk waktu yang lama.  Apa saja pilihan untuk mengatasi masalah ini dan membuat <strong>dataset</strong> untuknya? <br><br>  Pilihan pertama adalah <strong>mengidentifikasi vokal: mulut terbuka pada vokal, vokal di mulut</strong> .  Ini adalah algoritma yang sederhana, tetapi terlalu sederhana.  Dalam permainan, kami menginginkan lebih banyak kualitas.  Pilihan kedua adalah <strong>membuat orang membaca teks yang berbeda dan menuliskan wajah mereka, dan kemudian membandingkan huruf yang mereka ucapkan dengan ekspresi wajah.</strong>  Ini adalah ide yang bagus, dan kami melakukannya dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">proyek</a> bersama dengan Remedy Entertainment.  Satu-satunya perbedaan adalah bahwa dalam permainan kami tidak menampilkan video, tetapi model 3D titik.  Untuk merakit dataset, Anda perlu memahami bagaimana titik-titik spesifik pada gerakan wajah.  Kami mengambil aktor, diminta untuk membaca teks dengan intonasi yang berbeda, memotret pada kamera yang sangat bagus dari sudut yang berbeda, setelah itu kami mengembalikan model wajah 3D pada setiap frame, dan memperkirakan posisi titik pada wajah dengan suara. <br><br><h3>  Render Image Post-Processing: supersampling, anti-aliasing <br></h3><br>  Pertimbangkan kasus dari permainan tertentu: kami memiliki mesin yang menghasilkan gambar dalam resolusi yang berbeda.  Kami ingin membuat gambar dalam resolusi 1000 Ã— 500 piksel, dan menunjukkan kepada pemain 2000 Ã— 1000 - ini akan lebih cantik.  Bagaimana cara menyusun dataset untuk tugas ini? <br><br>  Pertama-tama render gambar dalam resolusi tinggi, kemudian turunkan kualitasnya, dan kemudian coba latih sistem untuk mengubah gambar dari resolusi rendah ke resolusi tinggi. <br><br><h3>  Slowmotion: interpolasi bingkai <br></h3><br>  Kami memiliki video, dan kami ingin jaringan menambahkan frame di tengah - untuk menginterpolasi frame.  Idenya jelas - untuk merekam video nyata dengan sejumlah besar bingkai, menghapus yang menengah dan mencoba memprediksi apa yang dihapus oleh jaringan. <br><br><h3>  Generasi Material <br></h3><br>  Kami tidak akan terlalu memikirkan generasi bahan.  Esensinya adalah bahwa kita mengambil, misalnya, sepotong kayu di beberapa sudut pencahayaan, dan menyisipkan pandangan dari sudut lain. <br><br>  Kami memeriksa kelompok masalah pertama.  Yang kedua berbeda secara mendasar.  Kita akan berbicara tentang rendering objek kompleks, seperti awan, nanti, tetapi sekarang kita akan berurusan dengan simulasi fisik. <br><br><h3>  Simulasi fisik air dan asap <br></h3><br>  Bayangkan sebuah kolam di mana benda padat bergerak berada.  Kami ingin memprediksi pergerakan partikel cairan.  Ada partikel di kolam pada waktu <strong>t</strong> , dan pada waktu <strong>t + wet</strong> kami ingin mendapatkan posisi mereka.  Untuk setiap partikel, kami memanggil jaringan saraf dan mendapatkan jawaban di mana itu akan berada di frame berikutnya. <br><br>  Untuk mengatasi masalah, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kami</a> menggunakan <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">persamaan Navier-Stokes</a></strong> , yang menggambarkan gerakan fluida.  Untuk simulasi air yang masuk akal dan benar secara fisik, kita harus menyelesaikan persamaan atau perkiraannya.  Ini dapat dilakukan dengan cara komputasi, yang telah banyak ditemukan selama 50 tahun terakhir: algoritma SPH, FLIP, atau Position Based Fluid. <br><br><h3>  Perbedaan antara kelompok tugas pertama dari yang kedua <br></h3><br>  Pada kelompok pertama, guru untuk algoritme adalah sesuatu di atas: rekaman dari kehidupan nyata, seperti dalam kasus individu, atau sesuatu dari mesin, misalnya, rendering gambar.  Dalam kelompok masalah kedua, kami menggunakan metode matematika komputasi.  Dari pembagian tematik ini, sebuah ide tumbuh. <br><br><h2>  Ide utama <br></h2><br>  Kami memiliki tugas komputasi yang kompleks yang panjang, sulit dan sulit untuk diselesaikan dengan metode universitas komputasi klasik.  Untuk mengatasinya dan mempercepat, bahkan mungkin kehilangan sedikit kualitas, kita perlu: <br><br><blockquote><ul><li>  menemukan tempat yang paling memakan waktu dalam tugas di mana kode bertahan paling lama; </li><li>  lihat apa yang dihasilkan garis ini; </li><li>  cobalah untuk memprediksi hasil garis menggunakan jaringan saraf atau algoritma pembelajaran mesin lainnya. </li></ul></blockquote><br>  Ini adalah metodologi umum dan ide utamanya adalah resep tentang cara menemukan aplikasi untuk pembelajaran mesin.  Apa yang harus Anda lakukan agar ide ini bermanfaat?  Tidak ada jawaban yang pasti - gunakan kreativitas, lihat pekerjaan Anda dan temukan.  Saya membuat grafik, dan saya tidak begitu akrab dengan bidang lain, tetapi saya bisa membayangkan bahwa di lingkungan akademik - dalam fisika, kimia, robotika - Anda pasti dapat menemukan aplikasi.  Jika Anda memecahkan persamaan fisik yang kompleks di tempat kerja Anda, maka Anda juga dapat menemukan aplikasi untuk ide ini.  Untuk kejelasan, pertimbangkan kasus tertentu. <br><br><h2>  Tugas rendering cloud <br></h2><br>  Kami terlibat dalam proyek ini di NVIDIA enam bulan lalu: tugasnya adalah menggambar awan yang benar secara fisik, yang direpresentasikan sebagai kepadatan tetesan cairan di ruang angkasa. <br><br><blockquote>  Awan adalah objek yang kompleks secara fisik, suspensi tetesan cairan yang tidak dapat dimodelkan sebagai objek padat. </blockquote><br>  Tidak akan mungkin untuk memaksakan tekstur dan render di awan, karena tetesan air sulit secara geometris terletak di ruang 3d dan rumit dalam dirinya sendiri: mereka praktis tidak menyerap warna, tetapi memantulkannya, secara anisotropis - ke segala arah dengan cara yang berbeda. <br><br>  Jika Anda melihat setetes air, yang disinari matahari, dan vektor-vektor dari mata dan matahari yang jatuh itu sejajar, maka puncak besar dalam intensitas cahaya akan diamati.  Ini menjelaskan fenomena fisik yang dilihat semua orang: dalam cuaca cerah, salah satu batas awan sangat cerah, hampir putih.  Kami melihat perbatasan awan, dan garis pandang dan vektor dari perbatasan ke matahari ini hampir paralel. <br><img src="https://habrastorage.org/webt/yt/hz/ij/ythzijgn-xfjhl3xri9mefn4vrg.png"><br><br>  Cloud adalah objek yang kompleks secara fisik dan renderingnya oleh algoritma klasik membutuhkan banyak waktu.  Kami akan berbicara tentang algoritma klasik sedikit kemudian.  Bergantung pada parameternya, prosesnya bisa memakan waktu berjam-jam atau bahkan berhari-hari.  Bayangkan bahwa Anda seorang seniman dan menggambar film dengan efek khusus.  Anda memiliki pemandangan yang rumit dengan pencahayaan berbeda yang ingin Anda mainkan.  Kami membuat satu topologi cloud - saya tidak menyukainya, dan Anda ingin menggambar ulang dan mendapatkan jawaban di sana.  Penting untuk mendapatkan jawaban dari satu perubahan parameter secepat mungkin.  Ini masalah.  Karena itu, mari kita coba mempercepat proses ini. <br><br><h3>  Solusi klasik <br></h3><br>  Untuk menyelesaikan masalah, Anda harus menyelesaikan persamaan rumit ini. <br><img src="https://habrastorage.org/webt/vs/fg/hq/vsfghqwn4s0rkmnsnescb1h62ma.png"><br><br>  Persamaannya keras, tetapi mari kita pahami makna fisiknya.  Pertimbangkan balok yang tertembus awan yang menembus awan.  Bagaimana cahaya masuk ke kamera ke arah ini?  Pertama, cahaya dapat mencapai titik keluarnya sinar dari awan, dan kemudian merambat sepanjang sinar ini di dalam awan. <br><br>  Untuk metode kedua "perambatan cahaya sepanjang arah" adalah istilah integral dari persamaan.  Arti fisiknya adalah sebagai berikut. <br><br>  Pertimbangkan segmen di dalam cloud pada ray - dari titik masuk ke titik keluar.  Integrasi dilakukan tepat di atas segmen ini, dan untuk setiap titik di atasnya kami mempertimbangkan apa yang disebut <strong>energi cahaya tidak langsung L (x, Ï‰)</strong> - arti integral I <sub>1</sub> - pencahayaan tidak langsung pada titik tersebut.  Tampaknya karena fakta bahwa tetes dengan cara yang berbeda memantulkan sinar matahari.  Oleh karena itu, sejumlah besar sinar yang dimediasi dari tetesan sekitarnya sampai pada intinya.  I <sub>1</sub> adalah integral dari bola yang mengelilingi titik pada sinar.  Dalam algoritma klasik, dihitung menggunakan metode <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Monte Carlo</a></strong> . <br><br>  Algoritma klasik. <br><br><ul><li>  Render gambar dari piksel, dan hasilkan sinar yang bergerak dari tengah kamera ke piksel lalu lebih jauh. </li><li>  Kami menyeberangi sinar dengan awan, kami menemukan titik masuk dan keluar. </li><li>  Kami mempertimbangkan istilah terakhir dari persamaan: untuk menyeberang, terhubung dengan matahari. </li><li>  Memulai <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sampling kepentingan</a></strong> </li></ul><br>  Bagaimana mempertimbangkan perkiraan Monte Carlo I <sub>1</sub> kita tidak akan menganalisis, karena itu sulit dan tidak begitu penting.  Cukuplah untuk mengatakan bahwa ini adalah bagian terpanjang dan paling sulit dalam keseluruhan algoritma. <br><br><h3>  Kami menghubungkan jaringan saraf <br></h3><br>  Dari ide utama dan deskripsi algoritma klasik, berikut adalah resep tentang cara menerapkan jaringan saraf untuk tugas ini.  Yang paling sulit adalah menghitung skor Monte Carlo.  Ini memberikan angka yang berarti pencahayaan tidak langsung pada suatu titik, dan inilah yang ingin kita prediksi. <br><img src="https://habrastorage.org/webt/nz/on/st/nzonstvyqkk3uaiylmqjbs6fny0.png"><br><br>  Kami memutuskan pada pintu keluar, sekarang kami akan memahami pintu masuk - dari informasi apa akan jelas berapa besar cahaya tidak langsung pada titik tersebut.  Ini adalah cahaya yang dipantulkan dari banyak tetesan air yang mengelilingi titik.  Topologi cahaya sangat dipengaruhi oleh topologi kerapatan di sekitar titik, arah ke sumber dan arah ke kamera. <br><img src="https://habrastorage.org/webt/ks/x6/hc/ksx6hc2boi4sgdp3_j7det6firo.png"><br><br>  Untuk membangun pintu masuk ke jaringan saraf, kami menggambarkan kepadatan lokal.  Ada banyak cara untuk melakukan ini, tetapi kami fokus pada artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Deep Scattering: Rendering Awan Atmospheric dengan Radiance Predicting Neural Networks, Kallwcit et al.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">2017</a> dan banyak ide datang dari sana. <br><br>  Secara singkat, metode representasi lokal kepadatan di sekitar titik terlihat seperti ini. <br><br><ul><li>  <strong>Perbaiki konstanta yang cukup kecil</strong> .  Biarkan itu menjadi jalan bebas rata-rata di awan. <br></li><li>  <strong>Gambarkan titik di segmen kami dengan kotak persegi panjang volumetrik dengan ukuran tetap</strong> , misalnya 5 * 5 * 9.  Di tengah kubus ini akan menjadi poin kami.  Spasi kisi adalah konstanta tetap kecil.  Pada node grid kita akan mengukur kepadatan awan. </li><li>  <strong>Mari kita tingkatkan konstanta sebanyak 2 kali</strong> , gambar grid yang lebih besar, dan lakukan hal yang sama - mengukur kerapatan pada node grid. </li><li>  <strong>Ulangi langkah sebelumnya beberapa kali</strong> .  Kami melakukan ini 10 kali, dan setelah prosedur kami mendapatkan 10 grid - 10 tensor, masing-masing menyimpan kepadatan awan, dan masing-masing tensor mencakup lingkungan yang semakin besar di sekitar titik. </li></ul><br>  Pendekatan ini memberi kita deskripsi paling rinci tentang area kecil - semakin dekat ke titik, semakin detail deskripsi.  Memutuskan output dan input jaringan, masih harus mengerti bagaimana melatihnya. <br><br><h3>  Pelatihan <br></h3><br>  Kami akan menghasilkan 100 cloud yang berbeda dengan topologi yang berbeda.  Kami hanya akan membuat mereka menggunakan algoritma klasik, menuliskan apa yang diterima algoritma di baris di mana ia melakukan integrasi Monte Carlo, dan menuliskan properti yang sesuai dengan titik.  Jadi kami mendapatkan dataset untuk dipelajari. <br><img src="https://habrastorage.org/webt/yc/im/rh/ycimrhfbcbhfhx_rjwsqoc-xt1q.png"><br><br><h3>  Apa yang diajarkan, atau arsitektur jaringan <br></h3><br>  Arsitektur jaringan untuk tugas ini bukanlah kuncinya, dan jika Anda tidak mengerti apa-apa, jangan khawatir - ini bukan hal terpenting yang ingin saya sampaikan.  Kami menggunakan arsitektur berikut: untuk setiap titik ada 10 tensor, yang masing-masing dihitung pada grid skala yang semakin besar.  Masing-masing tensor ini jatuh ke blok yang sesuai. <br><br><ul><li>  Pertama ke dalam <strong>layer</strong> reguler yang <strong>terhubung penuh</strong> . </li><li>  Setelah keluar dari lapisan pertama yang terhubung sepenuhnya, pada lapisan kedua yang terhubung penuh, yang tidak memiliki aktivasi. </li></ul><br>  Lapisan yang sepenuhnya terhubung tanpa aktivasi hanyalah perkalian dengan sebuah matriks.  Untuk hasil mengalikan dengan matriks kami menambahkan output dari <strong>blok-residual</strong> sebelumnya, dan hanya kemudian menerapkan aktivasi. <br><img src="https://habrastorage.org/webt/he/fb/pn/hefbpncqogvya11gpsmzjwxtawi.png"><br><br>  Kami mengambil titik, menghitung nilai pada masing-masing grid, meletakkan tensor yang diperoleh di blok residu yang sesuai - dan Anda dapat melakukan <strong>inferensi jaringan saraf</strong> - mode produksi jaringan.  Kami melakukan ini dan memastikan bahwa kami mendapatkan gambar awan. <br><br><h3>  Hasil <br></h3><br>  Pengamatan pertama - kami mendapatkan apa yang kami inginkan: panggilan jaringan saraf, dibandingkan dengan estimasi Monte Carlo, bekerja lebih cepat, yang sudah baik. <br><br>  Tetapi ada pengamatan lain pada hasil pelatihan - ini adalah konvergensi dalam jumlah sampel.  Apa yang kamu bicarakan <br><img src="https://habrastorage.org/webt/mb/wd/eg/mbwdegnr_cpk6irbcsvrmyhe3n4.png"><br><br>  Saat merender gambar, mari kita potong menjadi ubin kecil - kuadrat piksel, katakan 16 * 16.  Pertimbangkan satu ubin gambar tanpa kehilangan keumuman.  Ketika kami membuat ubin ini, untuk setiap piksel dari kamera kami melepaskan banyak sinar yang sesuai dengan satu piksel, dan menambahkan sedikit noise ke sinar sehingga mereka sedikit berbeda.  Sinar ini disebut <strong>anti-aliasing</strong> dan diciptakan untuk mengurangi noise pada gambar akhir. <br><br><ul><li>  Kami merilis beberapa sinar anti-aliasing untuk setiap piksel. </li><li>  Di bagian dalam sinar dari kamera, di awan, di segmen, kami menghitung <em>n</em> sampel titik di mana kami ingin melakukan penilaian Monte Carlo, atau memanggil jaringan untuk mereka. </li></ul><br>  Masih ada sampel yang sesuai dengan koneksi dengan sumber cahaya.  Mereka muncul ketika kita menghubungkan suatu titik dengan sumber cahaya, misalnya, dengan matahari.  Ini mudah dilakukan, karena matahari adalah sinar yang jatuh di bumi yang sejajar satu sama lain.  Sebagai contoh, langit, sebagai sumber cahaya, jauh lebih rumit, karena muncul sebagai bola yang sangat jauh, yang memiliki fungsi warna dalam arah.  Jika vektor terlihat lurus secara vertikal ke langit, maka warnanya biru.  Semakin rendah terang.  Di bagian bawah bola biasanya warna netral meniru bumi: hijau, coklat. <br><br>  Ketika kita menghubungkan suatu titik dengan langit untuk memahami seberapa banyak cahaya yang masuk ke dalamnya, kita selalu melepaskan beberapa sinar untuk mendapatkan jawaban yang menyatu dengan kebenaran.  Kami melepaskan lebih dari satu sinar untuk mendapatkan nilai yang lebih baik.  Oleh karena itu, seluruh <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">render pipa</a></strong> membutuhkan begitu banyak sampel. <br><br>  Ketika kami melatih jaringan saraf, kami memperhatikan bahwa itu mempelajari solusi yang jauh lebih rata-rata.  Jika kami memperbaiki jumlah sampel, kami melihat bahwa algoritma klasik konvergen ke baris kiri kolom gambar, dan jaringan belajar ke kanan.  Ini tidak berarti bahwa metode asli buruk - kami hanya bertemu lebih cepat.  Ketika kita menambah jumlah sampel, metode asli akan semakin dekat dengan apa yang kita dapatkan. <br><br>  Hasil utama kami yang ingin kami dapatkan adalah peningkatan kecepatan rendering.  Untuk cloud tertentu dalam resolusi spesifik dengan parameter sampel, kami melihat bahwa gambar yang diperoleh oleh jaringan dan metode klasik hampir identik, tetapi kami mendapatkan gambar yang tepat 800 kali lebih cepat. <br><img src="https://habrastorage.org/webt/qp/ly/xn/qplyxntotijyhtzhgeqzsygahmc.png"><br><br><h2>  Implementasi <br></h2><br>  Ada program Open Source untuk pemodelan 3D - <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Blender</a></strong> , yang mengimplementasikan algoritma klasik.  Kami sendiri tidak menulis algoritme, tetapi menggunakan program ini: kami melatih Blender, menuliskan semua yang kami butuhkan di balik algoritme.  Produksi juga dilakukan dalam program: kami melatih jaringan di <strong>TensorFlow</strong> , mentransfernya ke C ++ menggunakan TensorRT, dan kami sudah mengintegrasikan jaringan TensorRT ke dalam Blender, karena kodenya terbuka. <br><br>  Karena kami melakukan segalanya untuk Blender, solusi kami memiliki semua fitur dari program ini: kami dapat membuat semua jenis pemandangan dan banyak awan.  Awan dalam solusi kami ditetapkan dengan membuat kubus, di dalamnya kami menentukan fungsi kepadatan dengan cara tertentu untuk program 3D.  Kami mengoptimalkan proses ini - kepadatan cache.  Jika pengguna ingin menggambar cloud yang sama pada tumpukan pengaturan adegan yang berbeda: di bawah kondisi pencahayaan yang berbeda, dengan objek yang berbeda di atas panggung, maka ia tidak perlu terus-menerus menghitung ulang kepadatan awan.  Apa yang terjadi, Anda dapat menonton <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">videonya</a> . <br><br>  Sebagai kesimpulan, saya ulangi sekali lagi ide utama yang ingin saya sampaikan: <em>jika dalam pekerjaan Anda untuk waktu yang lama dan sulit Anda menganggap sesuatu sebagai beberapa algoritma komputasi tertentu, dan ini tidak cocok untuk Anda - temukan tempat tersulit dalam kode, ganti dengan jaringan saraf, dan mungkin ini akan membantu Anda.</em> <br><br><blockquote>  Jaringan saraf dan kecerdasan buatan adalah salah satu topik baru yang akan kita bahas di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Saint HighLoad ++ 2019</a> pada bulan April.  Kami telah menerima beberapa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">aplikasi</a> tentang topik ini, dan jika Anda memiliki pengalaman yang keren, tidak harus di jaringan saraf, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kirimkan aplikasi untuk laporan</a> sebelum <strong>1 Maret</strong> .  Kami akan senang melihat Anda di antara pembicara kami. <br><br>  Untuk mengikuti perkembangan program dan laporan apa yang diterima, berlangganan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">buletin</a> .  Di dalamnya, kami hanya menerbitkan koleksi tematik laporan, artikel, dan video baru. <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id441260/">https://habr.com/ru/post/id441260/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id441248/index.html">Rusia menempati peringkat ke-9 dalam peringkat SSL global, di atas Cina, Denmark, dan Swiss</a></li>
<li><a href="../id441250/index.html">Mulai Cepat: Buka + Apache Kafka + Redis</a></li>
<li><a href="../id441252/index.html">"Artikel mengisap penis": para ilmuwan memproses 109 jam seks oral untuk mengembangkan AI yang mengisap anggota</a></li>
<li><a href="../id441254/index.html">Seminar â€œMengapa kami menghubungi Kubernetes dan apa yang kami dapatkan darinyaâ€, 28 Februari, Moskow</a></li>
<li><a href="../id441258/index.html">Penelusuran dinamis berfitur lengkap di Linux menggunakan eBPF dan bpftrace</a></li>
<li><a href="../id441262/index.html">Tugas yang sederhana dan panjang menyingkirkan kandidat lebih baik daripada yang pendek dan kompleks</a></li>
<li><a href="../id441264/index.html">Panduan Pengguna Kibana. Visualisasi. Bagian 2</a></li>
<li><a href="../id441266/index.html">Bagaimana kerangka kerja tiOPF untuk delphi / lazarus bekerja. Template Pengunjung</a></li>
<li><a href="../id441268/index.html">Ceedling + Eclipse atau unit test untuk mikrokontroler</a></li>
<li><a href="../id441270/index.html">Pertama-tama lihat Apple's FoundationDB</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>