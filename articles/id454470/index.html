<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👠 🛤️ 💇🏻 Hidup sebelum runtime. Laporan Yandex 🤞🏾 ⚛️ 🔲</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam proyek besar, tugas mengidentifikasi perubahan untuk pengguna akhir dengan perbedaan dalam kode aplikasi front-end dapat muncul. Pengembang dari...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Hidup sebelum runtime. Laporan Yandex</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/454470/">  Dalam proyek besar, tugas mengidentifikasi perubahan untuk pengguna akhir dengan perbedaan dalam kode aplikasi front-end dapat muncul.  Pengembang dari Yandex.Market Nikita Sidorov @nickshevr memberi tahu bagaimana kami memecahkan masalah ini menggunakan pustaka Diffector, tentang membangun dan menganalisis grafik modul di aplikasi Node.js dan tentang menemukan cacat pada kode sebelum diluncurkan. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/qw/uu/uy/qwuuuy_de8impvpifwc9qdflrka.jpeg"></a> <br><br>  - Hari ini aku akan mencoba untuk berterus terang kepadamu. <a name="habracut"></a>  Saya telah bekerja di Yandex.Market selama kurang lebih satu setengah tahun.  Saya melakukan jumlah web yang sama, dan saya mulai melihat perubahan pada diri saya, Anda juga bisa melihatnya.  Panjang rambut rata-rata saya meningkat dan janggut mulai muncul.  Dan Anda tahu, hari ini saya melihat rekan-rekan saya: di Sergei Berezhnoy <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">berbelok</a> , di Vova Grinenko <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">tadatuta</a> , dan saya menyadari - ini adalah kriteria yang baik untuk apa yang hampir saya kembangkan sebagai pengembang front-end nyata. <br><br>  Dan datang ke sumpah ini, saya memutuskan untuk berbicara dengan Anda tentang kehidupan, tentang kehidupan di mana kita semua berpartisipasi.  Sebagian besar tentang kehidupan sebelum runtime.  Sekarang saya akan menjelaskan tentang apa semua ini. <br><br><img src="https://habrastorage.org/webt/cy/-_/bm/cy-_bmshiyn9hj20-9dbgekd7fo.jpeg"><br><br>  Bagaimana dengan kehidupan?  Tentang kehidupan kode, tentu saja.  Kode adalah apa yang kami lakukan.  Biarkan saya mengingatkan Anda, saya memutuskan untuk tulus dengan Anda di sini, jadi slide pertama sesederhana mungkin.  Saya mengambil kebenaran, tahap pertama - adopsi, Anda tahu, tidak ada yang akan berdebat dengan aksioma ini. <br><br><img src="https://habrastorage.org/webt/p5/si/5n/p5si5n0oneks__xee8nrdwtfbt8.jpeg"><br><br>  Dan kemudian saya menyadari bahwa saya harus memodifikasinya, tetapi supaya jelas.  Biarlah semacam penerimaan persyaratan.  Kode apa pun dimulai dengan fakta bahwa Anda melihat tugas dan mencoba menerima persyaratan yang membuat Anda. <br><br><img src="https://habrastorage.org/webt/kv/g0/qx/kvg0qxlxoatcyd7mtxhhcbhvsqa.jpeg"><br><br>  Setelah itu, tentu saja, kita memulai tahap penulisan - kita menulis kode kita.  Lalu kami menutupinya dengan tes, kami memeriksa efektivitasnya sendiri.  Setelah itu, kami sudah memeriksa apakah aplikasi kami berfungsi dengan kode kami secara keseluruhan.  Setelah itu, kami berikan ke tester - biarkan dia memeriksa.  Apa yang Anda pikirkan setelah itu?  Saya ingatkan Anda, kehidupan sebelum runtime.  Apakah Anda pikir runtime mengikuti ini?  Bahkan, ternyata begini.  Dan ini bukan kesalahan dalam presentasi.  Sangat sering pada setiap tahap pemeriksaan - dan mungkin ada lebih banyak dari yang saya sebutkan - Anda mungkin memiliki beberapa panggilan goto untuk menulis lagi.  Setuju, ini bisa menjadi masalah yang cukup besar.  Ini dapat memperlambat pengiriman beberapa fitur dalam produksi dan, pada prinsipnya, memperlambat Anda sebagai pengembang, karena tiket akan tergantung pada Anda.  Dan di sini semuanya berlalu, berlalu.  Ada beberapa kali M lagi untuk cek N, dan hanya kemudian kode sampai ke pengguna di browser.  Tapi ini tujuan kami.  Tujuan kami adalah menulis kode yang benar-benar akan tersedia bagi pengguna dan benar-benar berfungsi untuk keuntungannya. <br><br>  Hari ini kita akan berbicara tentang bagian pertama.  Tentang apa yang terjadi sebelumnya, tetapi tidak benar-benar tentang tes. <br><br><img src="https://habrastorage.org/webt/cd/lo/of/cdlooffg2v4i0j6gmel3c16g0r8.jpeg"><br><br>  Ngomong-ngomong, tampilannya seperti ini.  Aku mengambil giliran kami di pelacak, mengumpulkan milikku, menghitung median.  Ternyata tiket saya jauh lebih sedikit dalam pengembangan daripada dalam memeriksa.  Dan seperti yang Anda tahu, semakin lama di cek, semakin tinggi kemungkinan goto akan muncul di awal atau goto akan muncul di akhir - dan saya tidak ingin melakukan ini sama sekali. <br><br>  Dan juga, jika Anda memperhatikan, ada dua kata di slide di sini - pengembangan (inilah yang kami lakukan, pengembang lakukan) dan verifikasi (inilah yang kami lakukan, tetapi juga penguji).  Oleh karena itu, masalahnya relevan, pada kenyataannya, untuk penguji. <br><br><img src="https://habrastorage.org/webt/fm/sc/qc/fmscqcprnl87tudqe7yqg1p9nky.jpeg"><br><br>  Tujuannya sangat sederhana.  Secara umum, saya suka mengatakan bahwa hidup perlu disederhanakan: kami sudah banyak bekerja dengan Anda.  Tujuannya terlihat seperti ini, tetapi Anda harus mengakui, itu agak sementara, jadi mari kita sorot beberapa kriteria dasar yang menjadi tujuan tujuan itu. <br><br>  Tentu saja, semakin sedikit kode, semakin mudah bagi kita.  Semakin cepat kita melakukan pemeriksaan CI, semakin cepat kita menyadari apakah kita benar atau tidak.  Artinya, secara lokal, umumnya dapat dimulai selamanya.  Kecepatan verifikasi - ini berlaku langsung ke tester.  Jika aplikasi kita besar dan perlu diperiksa secara keseluruhan, ini adalah waktu yang sangat lama.  Kecepatan rilis tergantung pada semua ini.  Termasuk tidak mungkin untuk melepaskannya sampai kita telah melewati semua pemeriksaan, dan sampai kita mengerti bahwa kodenya persis seperti yang kita inginkan. <br><br>  Untuk memecahkan beberapa masalah yang sedang kita bicarakan, mari kita menganalisis grafik dependensi modul dalam bahasa pemrograman kita.  Dan, sebenarnya, mari kita gambarkan. <br><br><img src="https://habrastorage.org/webt/cm/ry/c-/cmryc-ofgxh240_-rjepob2g3ui.jpeg"><br><br>  Grafik berorientasi: memiliki tepi dengan arah.  Dalam node grafik, kita hanya akan memiliki modul bahasa yang sedang kita bicarakan.  Iga adalah jenis ikatan khusus.  Ada beberapa jenis komunikasi. <br><br><img src="https://habrastorage.org/webt/7h/2a/ob/7h2aobcl3tntwcoton3qr5qmaoo.jpeg"><br><br>  Mari kita lihat contoh biasa.  Ada file A. Di sini, sesuatu dari file B diimpor ke dalamnya, dan ini adalah hubungan antara node. <br><br><img src="https://habrastorage.org/webt/mn/xn/vb/mnxnvbajewbedo_drzafbppqnda.jpeg"><br><br>  Hal yang sama akan terjadi jika Anda mengganti impor dengan persyaratan.  Faktanya, semuanya tidak begitu sederhana di sini. <br><br><img src="https://habrastorage.org/webt/fl/1x/ub/fl1xub0n5kpjz6nh3ais7trybk4.jpeg"><br><br>  Saya menyarankan, karena kita berbicara tentang jenis ketergantungan, pertimbangkan dua jenis setidaknya - untuk mempercepat pipa Anda, untuk mempercepat grafik traversal.  Penting untuk menonton tidak hanya modul dependen, tetapi juga modul dependen.  Saya mengusulkan untuk memanggil modul A - orang tua, B - anak, dan saya menyarankan Anda untuk selalu menjaga tautannya sebagai daftar yang ditautkan ganda.  Ini akan menyederhanakan hidup Anda, saya informasikan sebelumnya. <br><br>  Setelah kami mendeskripsikan grafik, mari kita sepakati bagaimana kami akan membangunnya. <br><br><img src="https://habrastorage.org/webt/oi/ir/lf/oiirlfsr0tciu_thxadfismnutm.jpeg"><br><br>  Ada dua cara.  Entah alat favorit Anda dalam bahasa pemrograman favorit Anda menggunakan AST yang sama (pohon sintaksis abstrak) atau tetap.  Apa untungnya di sini?  Fakta bahwa di sini Anda tidak terikat dengan siapa pun, tetapi pada saat yang sama Anda harus menerapkan semuanya sendiri.  Anda harus menggambarkan semua jenis koneksi dari semua hal dan teknologi yang Anda gunakan, apakah itu kolektor CSS yang terpisah, sesuatu yang lain seperti itu.  Tetapi Anda memiliki kebebasan penuh untuk terbang. <br><br>  Selain itu, opsi kedua, saya juga akan mempromosikannya sedikit, ini adalah opsi hanya untuk kebanyakan orang yang sudah memiliki sistem build yang dikonfigurasi.  Faktanya adalah bahwa sistem perakitan mengumpulkan grafik tergantung pada desain, secara default. <br><br><img src="https://habrastorage.org/webt/xc/gk/wk/xcgkwkeunrz5vi_eri49mqub7c0.jpeg"><br><br>  Mari kita lihat salah satu sistem perakitan paling populer di Yandex, ini adalah webpack.  Di sini saya memberi contoh bagaimana Anda dapat mengumpulkan seluruh hasil webpack ke file terpisah, yang kemudian dapat dimasukkan ke kami atau beberapa penganalisa lain.  Dia mengumpulkannya dengan bantuan AST, perpustakaan pohon ek digunakan.  Anda mungkin telah memperhatikannya ketika sesuatu telah jatuh.  Saya perhatikan. <br><br>  Dan apa kelebihannya.  Faktanya adalah ketika Anda mendeskripsikan sistem build Anda, Anda benar-benar secara jujur ​​meminta entri.  Ini adalah file-file yang darinya dependensi Anda dicabut, titik pintas awal.  Ini bagus, karena Anda tidak perlu merekamnya lagi.  Selain itu, webpack dan babel, dan semua ini, dan biji, termasuk, masih belum Anda pertahankan.  Dan oleh karena itu, semua jenis fitur baru bahasa, semua jenis bug dan yang lainnya, diperbaiki lebih cepat daripada jika Anda melakukannya, terutama jika Anda tidak memiliki tim yang sangat besar.  Ya, meskipun itu besar, maka itu tidak sebesar open source. <br><br>  Faktanya, ini adalah plus dan minus.  Sepertinya ujung ganda (pedang bermata dua) diperoleh.  Faktanya adalah bahwa grafik ini dibangun selama perakitan.  Agak bagus, yaitu, kita dapat mengumpulkan proyek dan segera menggunakan kembali hasil perakitan.  Tetapi bagaimana jika kita tidak ingin membuat proyek, tetapi hanya ingin mendapatkan grafik ini? <br><br>  Dan minus besar seperti itu, sebenarnya.  Jika Anda memiliki hal-hal khusus yang terhubung, kami akan berbicara banyak tentang koneksi nanti, maka sistem build tidak akan membiarkan Anda melakukan ini.  Atau, Anda harus mengintegrasikan ini, seperti plugin webpack Anda. <br><br><img src="https://habrastorage.org/webt/x0/c4/ye/x0c4yefpe8-w1hgcfeit-n50v8g.jpeg"><br><br>  Pertimbangkan contoh spesifik.  Saya menjalankan perintah pada proyeksi saya, di mana hanya ada tiga file, dan mendapat output ini.  Dan ini saya hanya menunjukkan satu kunci, yang disebut modul.  Kami hanya berbicara dengan Anda tentang grafik dependensi modul, jadi kami melihat modul, semuanya logis. <br><br><img src="https://habrastorage.org/webt/d_/ky/58/d_ky58s8cbrozt6bzoohxfzvzea.jpeg"><br><br>  Cukup banyak informasi, tetapi kami tidak membutuhkan semuanya.  Tinggalkan beberapa poin dan mari kita bicarakan.  Misalkan kita mempertimbangkan modul pertama.  Dia punya nama, ada alasannya.  Alasannya hanya koneksi, pada kenyataannya, dengan modul "tergantung", ternyata mereka yang mengimpor modul ini untuk diri mereka sendiri.  Ini adalah data dasar untuk membuat grafik di atasnya. <br><br><img src="https://habrastorage.org/webt/ld/of/e3/ldofe3q3cyna7bav1ltegf1zwyw.jpeg"><br><br>  Selain itu, harap perhatikan SportsEkspor bekas danEkspor yang disediakan.  Kami akan membicarakannya nanti.  Tetapi ini juga hal yang sangat penting. <br><br><img src="https://habrastorage.org/webt/ld/of/e3/ldofe3q3cyna7bav1ltegf1zwyw.jpeg"><br><br><img src="https://habrastorage.org/webt/me/db/80/medb80ytkohl1ee0ryh-zaoubak.jpeg"><br><br>  Dan jika Anda menggambarkan keputusan Anda, maka Anda perlu berbicara tentang jenis koneksi yang terjadi antar modul.  Yaitu, kita memiliki, tentu saja, sistem modul kita di dalam bahasa kita: apakah itu cjs-modules, atau esm-modules.  Selain itu, Anda harus setuju bahwa kami mungkin memiliki koneksi antara file dalam sistem file di tingkat sistem file itu sendiri.  Ini adalah semacam kerangka kerja: semacam kerangka kerja akan tergantung pada bagaimana ayah adalah. <br><br><img src="https://habrastorage.org/webt/9k/cz/hv/9kczhv-gdxjdxwomdj7czjeuqxk.jpeg"><br><br>  Dan contoh yang biasa - jika Anda menulis sisi server Node, maka cukup sering Anda bisa melihat paket npm populer seperti Config.  Ini memungkinkan Anda untuk dengan mudah menentukan konfigurasi Anda. <br><br><img src="https://habrastorage.org/webt/4d/94/oz/4d94ozf6xvfugnjkxvnsuylgnq4.jpeg"><br><br>  Untuk menggunakannya, Anda perlu mendapatkan folder konfigurasi, di mana Anda memiliki NODE_PATH, dan tentukan beberapa file JavaScript - hanya untuk menyajikan konfigurasi di sana untuk lingkungan yang berbeda.  Sebagai contoh, saya membuat ayah, standar yang ditentukan, pengembangan dan produksi. <br><br><img src="https://habrastorage.org/webt/mk/b8/ms/mkb8mse2x2bim9kv6ps4dwdkmg0.jpeg"><br><br>  Dan, pada kenyataannya, seluruh konfigurasi bekerja seperti ini.  Artinya, ketika Anda menulis membutuhkan ('config'), itu hanya membaca modul di dalam dirinya sendiri dan mengambil nama modul dari variabel lingkungan.  Seperti yang Anda pahami, tidak jelas di sana bahwa file-file ini entah bagaimana digunakan, karena tidak ada impor / persyaratan langsung, webpack bahkan tidak akan mengenalinya. <br><br><img src="https://habrastorage.org/webt/bk/pr/wv/bkprwvhuxqslrha7tz5x7nddawo.jpeg"><br><h5>  <sup><sub><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tautan dari slide</a></sub></sup> </h5><br>  Hari ini kita juga berbicara tentang Injeksi Ketergantungan.  Saya bukan sesuatu yang diilhami, tetapi dalam dukungan saya melihat salah satu perpustakaan di sini.  Ini disebut inversify JS.  Seperti yang Anda lihat, ini menyediakan sintaks yang agak khusus: lazyInject, nameProvider, dan ini dia.  Dan, Anda harus mengakui, tidak jelas penyedia apa itu, modul apa yang benar-benar disuntikkan di sini.  Dan kita membutuhkannya, dan kita harus memahaminya.  Sekali lagi, sistem pembangunan tidak akan terpecahkan, dan kita harus melakukannya sendiri. <br><br>  Misalkan kita telah membuat grafik, dan saya sarankan Anda mulai dengan menyimpannya di suatu tempat.  Apa yang akan memungkinkan kita melakukan ini?  Ini akan memungkinkan kita untuk melakukan semacam analisis heuristik, memainkan sedikit Ilmu Data, dan melakukannya, dengan fokus pada sepotong waktu. <br><br><img src="https://habrastorage.org/webt/gx/uv/t1/gxuvt1vsmjz1rkihuwoc_t93nua.jpeg"><br><br>  Apa idenya?  Di sini, memang, secara langsung data kami.  Kami baru saja menerapkan sistem desain kami di Yandex.Market dan, khususnya, menerapkan perpustakaan komponen sebagai bagian dari sistem desain ini.  Dan di sini Anda dapat melihat: kami mempertimbangkan jumlah impor, komponen reaksi dari perpustakaan kami, komponen umum.  Dan Anda dapat mendistribusikan di direktori.  Dalam hal ini, kami memiliki repositori non-mono, dan karenanya kami memiliki platform.desktop, platform.touch dan src. <br><br>  Apa yang bisa kita pikirkan ketika kita melihat angka-angka ini?  Kita dapat berhipotesis bahwa perintah sentuh tampaknya tidak meningkatkan penggunaan komponen umum.  Ini berarti komponennya buruk untuk ponsel - dibuat dengan buruk, atau perintah sentuhnya malas.  Tapi benarkah demikian? <br><br><img src="https://habrastorage.org/webt/u9/k_/gf/u9k_gfggsknyqnwdnmustdmsy1g.jpeg"><br><br>  Jika kita melihat dalam periode yang lebih lama, dalam waktu yang lebih lama, ini memungkinkan kita untuk melakukan penyimpanan grafik setelah setiap rilis, maka kita akan memahami bahwa, pada kenyataannya, semuanya ok untuk disentuh, indikator semakin berkembang di dalamnya.  Untuk src, ini lebih baik, untuk desktop, ternyata tidak. <br><br><img src="https://habrastorage.org/webt/o4/k-/ro/o4k-ronqjbk7g6w_p3mmph2uywe.jpeg"><br><br>  Masih ada pertanyaan dari audiens bagaimana menjelaskan kepentingan manajer.  Berikut adalah jumlah total impor perpustakaan, juga berdasarkan waktu.  Manajer mana yang tidak suka grafik?  Anda dapat membuat jadwal seperti itu dan melihat bahwa penggunaan perpustakaan bertambah, yang berarti bahwa ini setidaknya merupakan hal yang bermanfaat. <br><br>  Salah satu bagian favorit saya.  Saya akan membahasnya secara singkat.  Ini adalah pencarian cacat pada grafik.  Hari ini saya ingin berbicara dengan Anda tentang dua jenis cacat: ini adalah ketergantungan siklikal dari modul dan beberapa modul yang tidak digunakan, yaitu masalah penghilangan kode mati. <br><br><img src="https://habrastorage.org/webt/pv/zz/kc/pvzzkcqb1xx6dk5ko7slsrz2iia.jpeg"><br><br>  Mari kita mulai dengan ketergantungan melingkar. <br><br><img src="https://habrastorage.org/webt/2g/nx/u3/2gnxu3ruhrjtdjhhwfmeomypv-e.jpeg"><br><br>  Segalanya tampak sangat sederhana di sini.  Anda sudah memiliki grafik yang diarahkan, Anda hanya perlu menemukan lingkaran di sana.  Saya akan menjelaskan mengapa saya membicarakan hal ini.  Faktanya adalah bahwa sebelum saya menulis, pada dasarnya, sisi server pada Node.js, dan kami tidak menggunakan, pada prinsipnya, webpack / babel, tidak ada.  Artinya, mereka diluncurkan apa adanya.  Dan ada yang membutuhkan.  Siapa yang ingat bagaimana impor berbeda dari yang dibutuhkan?  Semuanya benar.  Jika Anda menulis kode dengan buruk, tetapi saya benar-benar melakukannya, Anda dapat mengetahui di server Anda bahwa modul Anda berada dalam semacam ketergantungan siklus hanya ketika beberapa permintaan datang dari pengguna, atau acara lain akan berfungsi.  Itu adalah masalah yang agak global.  Sampai runtime tidak mengerti.  Artinya, impor jauh lebih baik, tidak akan ada masalah seperti itu. <br><br><img src="https://habrastorage.org/webt/ss/ly/az/sslyazi877vucvcpjj21kth7vle.jpeg"><br><br>  Kemudian ambil saja algoritma yang Anda suka.  Di sini saya mengambil algoritma yang cukup sederhana.  Kita perlu menemukan simpul yang hanya memiliki satu jenis tepi - baik inbound atau outbound.  Jika ada titik seperti itu, kami menghapusnya, menghapus tepi, dan, pada kenyataannya, melanjutkan proses ini, kami akan menemukan dan membuktikan bahwa ada siklus lima siklus dalam grafik ini. <br><br>  Setuju, jika Anda melihatnya dengan kode, yaitu, di sana Anda masih dapat menemukan siklus dua atau tiga panjang, tetapi lebih tidak realistis, dan kami benar-benar memiliki siklus tujuh di proyek, tetapi tidak dalam produksi. <br><br><img src="https://habrastorage.org/webt/yj/cz/kb/yjczkbpye4suwsuhgvmw-ku1azu.jpeg"><br><br>  Tentang modul yang tidak digunakan.  Ada juga algoritma yang agak sepele.  Kita perlu menyorot komponen yang terhubung dalam grafik kita, dan lihat saja, cari komponen-komponen itu, yang tidak termasuk salah satu node entri.  Dalam hal ini, ini adalah komponen keterhubungan, kedua simpul, ternyata, kedua node.  Kemudian disebut entry.js.  Sebenarnya, tidak peduli apa namanya, ini adalah apa yang telah Anda gambarkan dalam konfigurasi assembly entri. <br><br><img src="https://habrastorage.org/webt/u3/g9/yo/u3g9yo0xtwjegnyxpe-gb1xpk_0.jpeg"><br><br>  Tetapi ada pendekatan lain.  Jika Anda belum mengumpulkan grafik, dan Anda hanya memiliki sistem build, lalu bagaimana cara termurah untuk melakukannya?  Mari kita tandai semua file yang masuk ke perakitan selama perakitan.  Tandai dan buat banyak.  Setelah itu, kita harus mendapatkan banyak semua file yang Anda miliki di proyek, dan cukup kurangi.  Itu adalah operasi yang sangat sederhana. <br><br><img src="https://habrastorage.org/webt/e2/yc/zn/e2yczn1scag0kmnvd97aqvdg_hc.jpeg"><br><br>  Dan sekarang saya tidak hanya mengatakan sesuatu yang teoretis kepada Anda, saya terinspirasi, datang ke proyek saya, dan melakukan ini.  Dan perhatian!  Saya bahkan tidak menghapus node_modules.  Ini saya tinggalkan sebagai titik pertumbuhan untuk ulasan selanjutnya.  Singkatnya, saya sangat terinspirasi oleh diri saya sendiri sehingga saya memutuskan untuk membuat slide ini, mengaturnya kembali.  Biarkan terlihat seperti ini, karena ini sangat keren! <br><br>  Angka yang bagus, dapatkah Anda bayangkan bagaimana semuanya menjadi baik?  Dan kemudian saya didorong ke padang rumput sehingga saya merasa seperti seorang desainer, dan berpikir bahwa ini adalah pencapaian yang ingin saya tambahkan ke bingkai.  Dan, seperti yang Anda tahu, saya bangun, melihat dan menyadari bahwa saya lebih cenderung bukan perancang, tetapi, memang, seorang pengembang web.  Tapi aku bukan orang bodoh.  Saya mengambil bingkai ini, ditambahkan ke situs saya untuk jimat SEO. <br><br><img src="https://habrastorage.org/webt/ji/14/nq/ji14nqwj-qsydqvw-ennrzkonqi.jpeg"><br><br>  Anda dapat menggunakan, bahkan tautannya.  Dan agar Anda tidak berpikir bahwa saya menipu Anda - kami jujur ​​hari ini - saya benar-benar melihat ulasan.  Saya pikir Anda bisa mempercayai mereka. <br><br><img src="https://habrastorage.org/webt/j0/0j/9v/j00j9vldpwzp39028m0uojaoxia.jpeg"><br><br>  Sejujurnya, terlihat seperti ini.  Saya melihat perpustakaan hypo thanos-js, mengambilnya, membuat permintaan kumpulan.  Secara rahasia, saya memiliki hak administrator di repositori kami.  Dan saya mengambil dan membingungkan tuannya.  Bagaimana kamu suka itu?  Ya, Anda dan saya jujur, dan, pada kenyataannya, semuanya tampak seperti ini.  Jika ada yang tidak tahu, thanos-js adalah pustaka yang hanya menghapus 50% kode Anda secara acak. <br><br><img src="https://habrastorage.org/webt/nt/0g/q1/nt0gq16vrnioiabs2sgcyj51qve.jpeg"><br><br>  Sebenarnya, saya menggunakan perpustakaan di sana, tetapi perpustakaan itu disebut berbeda.  Itu disebut diffector, dan sekarang kami akan membicarakannya dengan Anda.  Dan di sini saya ingin mencatat bahwa permintaan kumpulan cukup signifikan, minus 44 ribu baris kode, dan Anda bisa bayangkan - itu lulus ujian pertama kali.  Artinya, apa yang saya bicarakan benar-benar dapat bekerja. <br><br><img src="https://habrastorage.org/webt/ue/2i/5w/ue2i5wil5tev67r5vcrzbjsyzmq.jpeg"><br><br>  Penyebar  Bahkan, ia terlibat tidak hanya dalam tugas mengeluarkan modul yang tidak digunakan, mencari cacat dalam grafik, tetapi juga dalam tugas yang lebih penting.  Apa yang awalnya saya nyatakan adalah untuk membantu pengembang dan penguji, sekarang kita akan membicarakannya.  Dan kerjanya kira-kira seperti ini. <br><br>  Kami mendapatkan daftar file yang dimodifikasi menggunakan sistem kontrol versi.  Kami telah membuat grafik - diffector membangunnya.  Dan untuk setiap file yang dimodifikasi tersebut, kami mencari jalur masuk dan menandai entri yang dimodifikasi.  Dan entri akan berhubungan dengan halaman aplikasi yang akan dilihat pengguna.  Tapi ini cukup logis. <br><br>  Dan apa ini memberi kita?  Untuk pengujian - kami tahu halaman mana dalam aplikasi yang telah berubah.  Kami dapat memberi tahu tester bahwa hanya mereka yang layak untuk diuji.  Kami juga dapat memberi tahu ci-job kami, yang menjalankan autotest, bahwa hanya halaman ini yang layak untuk diuji.  Dan untuk pengembang, semuanya jauh lebih sederhana, karena sekarang penguji tidak menulis kepada Anda dan tidak bertanya: "Mengapa Anda perlu menguji?" <br><br><img src="https://habrastorage.org/webt/wb/jr/se/wbjrsedhjgtn7xkmh7xzxurf5z4.jpeg"><br><br>  Mari kita lihat contoh bagaimana diffector bekerja.  Di sini kita memiliki direktori tertentu, pages.desktop / *.  Itu hanya berisi daftar halaman itu sendiri.  Dan halaman-halamannya juga dijelaskan oleh beberapa file.  Pengontrol adalah sisi server dari halaman.  Lihat adalah semacam bagian reaksi.  Dan deps, ini dari sistem build lain.  Kami tidak hanya memiliki webpack, tetapi juga ENB. <br><br><img src="https://habrastorage.org/webt/iq/dv/qo/iqdvqoq5yf4xpfpfqnl9ozxmwws.jpeg"><br><br>  Dan saya membuat beberapa perubahan pada proyek, ke file kosong, struktur yang Anda lihat.  Inilah yang memberi saya diffector.  Saya baru saja memulainya, diffector adalah aplikasi baris perintah.  Saya meluncurkannya, dia memberi tahu saya bahwa saya telah mengubah satu halaman, yang disebut BindBonusPage. <br><br><img src="https://habrastorage.org/webt/vy/na/y3/vynay3b95xwzhuuawbjwz7jpbfm.jpeg"><br><br>  Saya juga dapat menjalankannya dalam mode verbose, melihat laporan yang lebih rinci, dan benar-benar melihat bahwa itu setidaknya berfungsi dalam kasus yang sangat sederhana.  Seperti yang kita lihat, di BindBonusPage kita file indeks dan pengontrol telah berubah. <br><br>  Tapi mari kita lihat apa yang terjadi jika kita mengubah sesuatu yang lain. <br><br><img src="https://habrastorage.org/webt/dd/rh/tl/ddrhtl_drtw2aqq5rt36r4ncqiu.jpeg"><br><br>  Saya mengubah sesuatu yang lain.  Dan difektor mengatakan kepada saya bahwa saya telah mengubah sembilan halaman.  Dan ini tidak membuat saya bahagia lagi, seolah-olah dia tidak akan membantu saya. <br><br><img src="https://habrastorage.org/webt/ew/qh/ce/ewqhceogxq9z42d5zxl4yvfcyvy.jpeg"><br><br>  Mari kita lihat mengapa?  Sekarang menunjukkan alasan mengapa halaman ini dianggap dimodifikasi.    ,     .  -    uikit. <br><br><img src="https://habrastorage.org/webt/li/wd/ws/liwdwsd_ujkbc-abp18vcmceaim.jpeg"><br><br>    diff.        .  ,    diffector  .          ,    - ,       . <br><br><img src="https://habrastorage.org/webt/zj/kf/uy/zjkfuy1ybdcht1hbuxktaznup2g.jpeg"><br><br>  , , .     ,   ,           entry, , ,       test-scope,     .     . <br><br> . ,    , ,  ,    . <br><br><img src="https://habrastorage.org/webt/pb/ep/ks/pbepksc2lwyezimbbytd6ngbujs.jpeg"><br><br>        .    - ,   .   — i18n,    ,    .  , ,  ,         .   ,    ,   - . <br><br>      ?           ,     , , , ,     . <br><br><img src="https://habrastorage.org/webt/zg/07/au/zg07aumxne59rvavifrhtxyi0p8.jpeg"><br><br>   - .     ,      B  ,  ,   -2    .       .        ,  esm. <br><br><img src="https://habrastorage.org/webt/4o/io/d0/4oiod0-nkygafo_zp6ztfh2txju.jpeg"><br><br>      . <br><br><img src="https://habrastorage.org/webt/th/ic/zz/thiczzasr1ggt87bgqy_ddhxlym.jpeg"><br><br>    . <br><br><img src="https://habrastorage.org/webt/vp/sh/4o/vpsh4ozm_pfjbgakddnvri-bzey.jpeg"><br><br> ,     value,          .       ,     ,     .        ,        . <br><br> ,       AST,  ,         250  ,   ,     . ,   ,     -  ,     ,     . <br><br><img src="https://habrastorage.org/webt/yg/og/9p/ygog9p0lhvoiffbm6ilak-b7db8.jpeg"><br><br>  ,     - GlobalContext  - ,   .    ,     modify,    , ?   ,  -   GlobalContext.    .       . ,    side effects. ,  ,   webpack,   ,    .  ,      webpack sideEffects: true,       .     . <br><br><img src="https://habrastorage.org/webt/ov/wn/ph/ovwnphvbkewixae0ypihcambj1k.jpeg"><br><br>    ,   - -       . ,   .      diffector,        . ,   ,      .       — ,      .   ,   . <br><br>   ,     ,   diff, expand, log,   ,     ,      ,   . <br><br><img src="https://habrastorage.org/webt/tr/3s/qa/tr3sqaezwkxap8pdbrjuh-jjewe.jpeg"><br><br>  , .        D,  diff.      ,   , ,   .    ,   ,     .          ,   ,    .        . <br><br> ,   ,     .          .    . ,  —   ,    .      .    .        ,     , , ,   ,      .      .       ,         . <br><br>    —     diffector ?    ,     ,   ,    . <br><br><img src="https://habrastorage.org/webt/pq/rf/lf/pqrflfrep6fp0ffzhsntxw_lbm0.jpeg"><br><br>     - ,    ,     . <br><br><img src="https://habrastorage.org/webt/1k/qs/u4/1kqsu4cuurzk-8ib7n4sus4b8-g.jpeg"><br><br>       , ,      entry.        entry.     diffector. <br><br><img src="https://habrastorage.org/webt/3a/t4/gi/3at4giub3oqpahtey5yznumq1xy.jpeg"><br><br>     .    -.      ,    . <br><br><img src="https://habrastorage.org/webt/rt/s1/nc/rts1ncwpwfo2gchhdglbx5ogevs.jpeg"><br><br>  ,   entry     -,   . <br><br><img src="https://habrastorage.org/webt/cz/6i/lr/cz6ilrthse-hs0awccmuxizen0g.jpeg"><br><br>    .   diffector.      .  ,    ,  -    ,       -.   ,  .   : ,  BindBonusPage,    -,     .    .   , , -  .   . <br><br><img src="https://habrastorage.org/webt/ev/wx/va/evwxvahpj0honucu2yysxvtow6s.jpeg"><br><br><img src="https://habrastorage.org/webt/c5/9j/o6/c59jo6uyprhncjcrlnwevxrx4eu.jpeg"><br><br>    —    CI.      .    :   ,   ,          . <br><br><img src="https://habrastorage.org/webt/7r/14/j9/7r14j90rvxqce-tuqobcjwrdewc.jpeg"><br><br>  ,    . 43  —   testing,     ,     . <br><br><img src="https://habrastorage.org/webt/bz/-w/9r/bz-w9rnatawaxbqdjdlqws7ppki.jpeg"><br><br>    .  , ,      . <br><br><img src="https://habrastorage.org/webt/fq/jw/gl/fqjwglsxt9v3qdpby861svprpve.jpeg"><br><br>    ,          .   :       ,      ,      .  ,     ,      ,     ,         ,   .    ,    ,     - . <br><br><img src="https://habrastorage.org/webt/pk/oy/pg/pkoypg3-8saqxh-endw9soc-t-o.jpeg"><br><br> . , ,      ,      .      - ,        -   ,   , ,   .         . <br><br>  ,       ,   ,      output   .    ,     .    — .   —      .  Terima kasih </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id454470/">https://habr.com/ru/post/id454470/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id454456/index.html">Pelatihan Cisco 200-125 CCNA v3.0. Hari 7. FAQ</a></li>
<li><a href="../id454458/index.html">Pengujian metamorf: mengapa hampir tidak ada yang tahu tentang teknik yang menjanjikan ini</a></li>
<li><a href="../id454460/index.html">Intisari materi menarik untuk pengembang ponsel # 300 (27 Mei - 2 Juni)</a></li>
<li><a href="../id454462/index.html">Fotogram tanpa kertas foto</a></li>
<li><a href="../id454464/index.html">Pengembangan tes visual berdasarkan Gemini dan Storybook</a></li>
<li><a href="../id454472/index.html">Yang Perlu Anda Ketahui Tentang Patch Router Terbaru Cisco</a></li>
<li><a href="../id454474/index.html">Acara digital di Moskow dari 3 hingga 9 Juni</a></li>
<li><a href="../id454476/index.html">Praktik Terbaik Node.js - Tip Struktur Proyek</a></li>
<li><a href="../id454478/index.html">Ekstensi Azure IoT Edge Tools (Pratinjau) diumumkan</a></li>
<li><a href="../id454482/index.html">Pelajaran pahit di industri AI</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>