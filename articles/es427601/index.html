<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöì üë©üèº‚Äçüé® üç≤ Caso 5 + 1 donde la especificaci√≥n REST API juega un papel muy importante üßëüèª‚Äçü§ù‚Äçüßëüèª üíÖ ü§µüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Este art√≠culo se centrar√° en escribir y respaldar una especificaci√≥n √∫til y relevante para un proyecto API REST, que ahorrar√° mucho c√≥digo adicional, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Caso 5 + 1 donde la especificaci√≥n REST API juega un papel muy importante</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/427601/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/b1/dg/ob/b1dgobh5dxfw3q-firfz-77qu-0.png"></div><br><p> Este art√≠culo se centrar√° en escribir y respaldar una especificaci√≥n √∫til y relevante para un proyecto API REST, que ahorrar√° mucho c√≥digo adicional, y mejorar√° seriamente la integridad, la fiabilidad y la transparencia del proyecto en su conjunto. </p><br><h3 id="chto-takoe-restful-api">  ¬øQu√© es una API RESTful? </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dde/ee8/857/ddeee88570832b82d7a7ff7231255c3f.png"></div><br><p>  Esto es un mito </p><br><p>  En serio, si crees que tu proyecto tiene una API RESTful, es casi seguro que te equivocas.  La idea de RESTful es construir una API que, en todos los aspectos, cumpla con las reglas y restricciones arquitect√≥nicas descritas por el estilo REST, pero en condiciones reales esto es <em>casi imposible</em> . </p><a name="habracut"></a><br><p>  Por un lado, REST contiene demasiadas definiciones vagas y ambiguas.  Por ejemplo, algunos t√©rminos de los diccionarios de m√©todos HTTP y c√≥digos de estado no se usan en la pr√°ctica para su prop√≥sito previsto, y muchos de ellos no se usan en absoluto. </p><br><p>  Por otro lado, REST crea demasiadas restricciones.  Por ejemplo, el uso at√≥mico de los recursos en el mundo real no es racional para las API utilizadas por las aplicaciones m√≥viles.  Una negativa total a almacenar el estado entre solicitudes es esencialmente una prohibici√≥n del mecanismo de las sesiones de usuario utilizadas en muchas API. </p><br><p>  <strong>Pero espera, ¬°no todo es tan malo!</strong> </p><br><h3 id="zachem-nuzhna-specifikaciya-rest-api">  ¬øPor qu√© necesitamos la especificaci√≥n REST API? </h3><br><p>  A pesar de estas deficiencias, con un enfoque razonable, REST sigue siendo una base excelente para dise√±ar API realmente geniales.  Tal API deber√≠a tener uniformidad interna, una estructura clara, documentaci√≥n conveniente y una buena cobertura de prueba unitaria.  Todo esto se puede lograr desarrollando una <strong>especificaci√≥n de</strong> calidad para su API. </p><br><p>  Muy a menudo, <em>la especificaci√≥n</em> REST API <em>est√°</em> asociada con su <em>documentaci√≥n</em> .  A diferencia del primero (que es una descripci√≥n formal de su API), la documentaci√≥n est√° destinada a ser le√≠da por personas: por ejemplo, por desarrolladores de una aplicaci√≥n m√≥vil o web que utiliza su API. </p><br><p>  Sin embargo, adem√°s de crear documentaci√≥n, una descripci√≥n adecuada de la API puede traer muchos beneficios.  En el art√≠culo quiero compartir ejemplos de c√≥mo, utilizando el uso competente de la especificaci√≥n, puede: </p><br><ul><li>  hacer que las pruebas unitarias sean m√°s simples y confiables; </li><li>  configurar el preprocesamiento y la validaci√≥n de los datos de entrada; </li><li>  automatizar la serializaci√≥n y garantizar la integridad de las respuestas; </li><li>  e incluso aprovechar la escritura est√°tica. </li></ul><br><h3 id="openapi">  Openapi </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/222/aae/af9/222aaeaf95adf9cb50af1ed7702d4c9b.png" width="500"></div><br><p>  El formato generalmente aceptado para describir la API REST hoy es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><strong>OpenAPI</strong></a> , que tambi√©n se conoce como <em>Swagger</em> .  Esta especificaci√≥n es un archivo √∫nico en formato JSON o YAML, que consta de tres secciones: </p><br><ul><li>  un encabezado que contiene el nombre, la descripci√≥n y la versi√≥n de la API, as√≠ como informaci√≥n adicional; </li><li>  una descripci√≥n de todos los recursos, incluidos sus identificadores, m√©todos HTTP, todos los par√°metros de entrada, as√≠ como los c√≥digos y formatos del cuerpo de respuesta, con enlaces a definiciones; </li><li>  todas las definiciones de objetos en formato de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><strong>esquema JSON</strong></a> que se pueden usar tanto en par√°metros de entrada como en respuestas. </li></ul><br><p>  OpenAPI tiene un serio inconveniente: la <em>complejidad de la estructura y, a menudo, la redundancia</em> .  Para un proyecto peque√±o, el contenido del archivo JSON de especificaci√≥n puede crecer r√°pidamente hasta varios miles de l√≠neas.  No es posible mantener este archivo manualmente en este formulario.  Esta es una seria amenaza para la idea misma de mantener una especificaci√≥n actualizada a medida que evoluciona la API. </p><br><p>  Hay muchos editores visuales que le permiten describir la API y formar la especificaci√≥n de OpenAPI resultante.  A su vez, los servicios adicionales y las soluciones en la nube se basan en ellos, por ejemplo, <em>Swagger</em> , <em>Apiary</em> , <em>Stoplight</em> , <em>Restlet</em> y otros. </p><br><p>  Sin embargo, para m√≠, tales servicios no eran muy convenientes debido a la dificultad de editar r√°pidamente la especificaci√≥n y combinarla con el proceso de escritura del c√≥digo.  Otro inconveniente es la dependencia del conjunto de funciones de cada servicio en particular.  Por ejemplo, es casi imposible implementar pruebas unitarias completas solo por medio de un servicio en la nube.  La generaci√≥n de c√≥digo e incluso la creaci√≥n de "enchufes" para puntos finales, aunque parece muy posible, son pr√°cticamente in√∫tiles en la pr√°ctica. </p><br><h3 id="tinyspec">  Tinyspec </h3><br><p>  En este art√≠culo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><strong>usar√©</strong></a> ejemplos basados ‚Äã‚Äãen el formato de descripci√≥n de la API REST nativa: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><strong>tinyspec</strong></a> .  El formato son archivos peque√±os que describen los puntos finales y los modelos de datos utilizados en el proyecto con una sintaxis intuitiva.  Los archivos se almacenan al lado del c√≥digo, lo que le permite consultarlos y editarlos directamente en el proceso de escritura.  Al mismo tiempo, tinyspec se compila autom√°ticamente en un OpenAPI completo, que puede usarse inmediatamente en el proyecto.  Es hora de decirte exactamente c√≥mo. </p><br><p>  En este art√≠culo, dar√© ejemplos de Node.js (koa, express) y Ruby on Rails, aunque estas pr√°cticas se aplican a la mayor√≠a de las tecnolog√≠as, incluidas Python, PHP y Java. </p><br><h2 id="kogda-eschyo-specifikaciya-okazyvaetsya-neveroyatno-poleznoy">  Cuando la especificaci√≥n es incre√≠blemente √∫til </h2><br><h3 id="1-unit-testy-endpointov">  1. Pruebas unitarias de puntos finales </h3><br><p>  <em>El desarrollo impulsado por el comportamiento (BDD) es</em> ideal para desarrollar una API REST.  La forma m√°s conveniente de escribir pruebas unitarias no es para clases individuales, modelos y controladores, sino para puntos finales espec√≠ficos.  En cada prueba, emula una solicitud HTTP real y verifica la respuesta del servidor.  En Node.js, para emular solicitudes de prueba, hay <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">supertest</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=http://www.chaijs.com/plugins/chai-">chai-http</a> , en Ruby on Rails, en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aire</a> . </p><br><p> Supongamos que tenemos un esquema de <code>User</code> y un punto final <code>GET /users</code> que devuelve todos los usuarios.  Aqu√≠ est√° la sintaxis de tinyspec que describe esto: </p><br><ol><li>  Archivo <em>User.models.tinyspec</em> : </li></ol><br><pre> <code class="python hljs">User {name, isAdmin: b, age?: i}</code> </pre> <br><ol><li>  Archivo <em>users.endpoints.tinyspec</em> : </li></ol><br><pre> <code class="python hljs">GET /users =&gt; {users: User[]}</code> </pre> <br><p>  As√≠ se ver√° nuestra prueba: </p><br><h4 id="nodejs">  Node.js </h4><br><pre> <code class="javascript hljs">describe(<span class="hljs-string"><span class="hljs-string">'/users'</span></span>, () =&gt; { it(<span class="hljs-string"><span class="hljs-string">'List all users'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { status, <span class="hljs-attr"><span class="hljs-attr">body</span></span>: { users } } = request.get(<span class="hljs-string"><span class="hljs-string">'/users'</span></span>); expect(status).to.equal(<span class="hljs-number"><span class="hljs-number">200</span></span>); expect(users[<span class="hljs-number"><span class="hljs-number">0</span></span>].name).to.be(<span class="hljs-string"><span class="hljs-string">'string'</span></span>); expect(users[<span class="hljs-number"><span class="hljs-number">0</span></span>].isAdmin).to.be(<span class="hljs-string"><span class="hljs-string">'boolean'</span></span>); expect(users[<span class="hljs-number"><span class="hljs-number">0</span></span>].age).to.be.oneOf([<span class="hljs-string"><span class="hljs-string">'boolean'</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>]); }); });</code> </pre> <br><h4 id="ruby-on-rails">  Ruby on Rails </h4><br><pre> <code class="ruby hljs">describe <span class="hljs-string"><span class="hljs-string">'GET /users'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> it <span class="hljs-string"><span class="hljs-string">'List all users'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> get <span class="hljs-string"><span class="hljs-string">'/users'</span></span> expect_status(<span class="hljs-number"><span class="hljs-number">200</span></span>) expect_json_types(<span class="hljs-string"><span class="hljs-string">'users.*'</span></span>, { <span class="hljs-symbol"><span class="hljs-symbol">name:</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:string</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">isAdmin:</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:boolean</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">age:</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:integer_or_null</span></span>, }) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  Cuando tenemos una especificaci√≥n que describe los formatos de respuesta del servidor, podemos simplificar la prueba y simplemente <em>comparar la respuesta con esta especificaci√≥n</em> .  Para hacer esto, aprovecharemos el hecho de que nuestros modelos tinyspec se transforman en definiciones OpenAPI, que a su vez corresponden al formato de esquema JSON. </p><br><p>  Cualquier <em>objeto literal</em> en JS (o <code>Hash</code> en Ruby, un <code>dict</code> en Python, <em>una matriz asociativa</em> en PHP e incluso un <code>Map</code> en Java) se puede probar para verificar el cumplimiento de un esquema JSON.  E incluso hay complementos correspondientes para probar marcos, por ejemplo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">jest-ajv</a> (npm), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">chai-ajv-json-schema</a> (npm) y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">json_matchers</a> (rubygem) para RSpec. </p><br><p>  Antes de usar los esquemas, debe conectarlos al proyecto.  Primero, generaremos el archivo de especificaci√≥n openapi.json basado en tinyspec (esta acci√≥n se puede realizar autom√°ticamente antes de cada ejecuci√≥n de prueba): </p><br><pre> <code class="bash hljs">tinyspec -j -o openapi.json</code> </pre> <br><h4 id="nodejs-1">  Node.js </h4><br><p>  Ahora podemos usar el JSON recibido en el proyecto y tomarle la clave de <code>definitions</code> , que contiene todos los esquemas JSON.  Los esquemas pueden contener referencias cruzadas ( <code>$ref</code> ), por lo tanto, si tenemos esquemas anidados (por ejemplo, <code>Blog {posts: Post[]}</code> ), entonces necesitamos "expandirlos" para usarlos en las validaciones.  Para hacer esto, usaremos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">json-schema-deref-sync</a> (npm). </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> deref <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'json-schema-deref-sync'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> spec = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./openapi.json'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> schemas = deref(spec).definitions; describe(<span class="hljs-string"><span class="hljs-string">'/users'</span></span>, () =&gt; { it(<span class="hljs-string"><span class="hljs-string">'List all users'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { status, <span class="hljs-attr"><span class="hljs-attr">body</span></span>: { users } } = request.get(<span class="hljs-string"><span class="hljs-string">'/users'</span></span>); expect(status).to.equal(<span class="hljs-number"><span class="hljs-number">200</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Chai expect(users[0]).to.be.validWithSchema(schemas.User); // Jest expect(users[0]).toMatchSchema(schemas.User); }); });</span></span></code> </pre> <br><h4 id="ruby-on-rails-1">  Ruby on Rails </h4><br><p>  <code>json_matchers</code> puede manejar enlaces <code>$ref</code> , pero requiere archivos separados con esquemas en el sistema de archivos de cierta manera, as√≠ que primero debe "dividir" <code>swagger.json</code> en muchos archivos peque√±os (m√°s sobre esto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> ): </p><br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment"># ./spec/support/json_schemas.rb require 'json' require 'json_matchers/rspec' JsonMatchers.schema_root = 'spec/schemas' # Fix for json_matchers single-file restriction file = File.read 'spec/schemas/openapi.json' swagger = JSON.parse(file, symbolize_names: true) swagger[:definitions].keys.each do |key| File.open("spec/schemas/#{key}.json", 'w') do |f| f.write(JSON.pretty_generate({ '$ref': "swagger.json#/definitions/#{key}" })) end end</span></span></code> </pre> <br><p>  Despu√©s de eso, podemos escribir nuestra prueba as√≠: </p><br><pre> <code class="ruby hljs">describe <span class="hljs-string"><span class="hljs-string">'GET /users'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> it <span class="hljs-string"><span class="hljs-string">'List all users'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> get <span class="hljs-string"><span class="hljs-string">'/users'</span></span> expect_status(<span class="hljs-number"><span class="hljs-number">200</span></span>) expect(result[<span class="hljs-symbol"><span class="hljs-symbol">:users</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>]).to match_json_schema(<span class="hljs-string"><span class="hljs-string">'User'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  Nota: escribir pruebas de esta manera es incre√≠blemente conveniente.  Especialmente si su IDE admite la ejecuci√≥n de pruebas y depuraci√≥n (como WebStorm, RubyMine y Visual Studio).  Por lo tanto, no puede utilizar ning√∫n otro software, y todo el ciclo de desarrollo de la API se reduce a 3 pasos consecutivos: </p><br><ol><li>  dise√±o de especificaci√≥n (por ejemplo, en tinyspec); </li><li>  escribir un conjunto completo de pruebas para puntos finales agregados / modificados; </li><li>  desarrollando c√≥digo que satisfaga todas las pruebas. </li></ol><br><h3 id="2-validaciya-vhodnyh-dannyh">  2. Validaci√≥n de entrada </h3><br><p>  OpenAPI describe el formato de no solo respuestas, sino tambi√©n datos de entrada.  Esto nos permite <em>validar los datos</em> recibidos del usuario directamente durante la solicitud. </p><br><p>  Supongamos que tenemos la siguiente especificaci√≥n que describe la actualizaci√≥n de los datos del usuario, as√≠ como todos los campos que se pueden cambiar: </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># user.models.tinyspec UserUpdate !{name?, age?: i} # users.endpoints.tinyspec PATCH /users/:id {user: UserUpdate} =&gt; {success: b}</span></span></code> </pre> <br><p>  Anteriormente analizamos los complementos para la validaci√≥n dentro de las pruebas, sin embargo, para casos m√°s generales hay m√≥dulos de validaci√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ajv</a> (npm) y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">json-schema</a> (rubygem), us√©moslos y escribamos un controlador con validaci√≥n. </p><br><h4 id="nodejs-koa">  Node.js (Koa) </h4><br><p>  Este es un ejemplo para <strong>Koa</strong> , el sucesor de Express, pero para Express, el c√≥digo ser√° similar. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Router <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'koa-router'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Ajv <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'ajv'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { schemas } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./schemas'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> router = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Router(); <span class="hljs-comment"><span class="hljs-comment">// Standard resource update action in Koa. router.patch('/:id', async (ctx) =&gt; { const updateData = ctx.body.user; // Validation using JSON schema from API specification. await validate(schemas.UserUpdate, updateData); const user = await User.findById(ctx.params.id); await user.update(updateData); ctx.body = { success: true }; }); async function validate(schema, data) { const ajv = new Ajv(); if (!ajv.validate(schema, data)) { const err = new Error(); err.errors = ajv.errors; throw err; } }</span></span></code> </pre> <br><p>  En este ejemplo, si los datos de entrada no cumplen con la especificaci√≥n, el servidor devolver√° una respuesta <code>500 Internal Server Error</code> al cliente.  Para evitar que esto suceda, podemos interceptar el error del validador y formar nuestra propia respuesta, que contendr√° informaci√≥n m√°s detallada sobre campos espec√≠ficos que no han pasado la prueba, y tambi√©n <em>cumplir√° con la especificaci√≥n</em> . </p><br><p>  Agregue una descripci√≥n del modelo <code>FieldsValidationError</code> en el archivo <code>FieldsValidationError</code> : </p><br><pre> <code class="python hljs">Error {error: b, message} InvalidField {name, message} FieldsValidationError &lt; Error {fields: InvalidField[]}</code> </pre> <br><p>  Y ahora lo indicamos como una de las posibles respuestas de nuestro punto final: </p><br><pre> <code class="python hljs">PATCH /users/:id {user: UserUpdate} =&gt; <span class="hljs-number"><span class="hljs-number">200</span></span> {success: b} =&gt; <span class="hljs-number"><span class="hljs-number">422</span></span> FieldsValidationError</code> </pre> <br><p>  Este enfoque le permitir√° escribir pruebas unitarias que verifiquen la correcci√≥n de la formaci√≥n de errores con datos incorrectos recibidos del cliente. </p><br><h3 id="3-serializaciya-modeley">  3. Serializaci√≥n de modelos. </h3><br><p>  Casi todos los marcos de servidores modernos usan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ORM de una</a> forma u otra.  Esto significa que la mayor√≠a de los recursos utilizados en la API dentro del sistema se presentan en forma de modelos, sus instancias y colecciones. </p><br><p>  El proceso de generar una representaci√≥n JSON de estas entidades para su transmisi√≥n en la respuesta API se llama <em>serializaci√≥n</em> .  Hay una serie de complementos para diferentes marcos que realizan funciones de serializaci√≥n, por ejemplo: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">sequelize-to-json</a> (npm), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">act_as_api</a> (rubygem), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">jsonapi-rails</a> (rubygem).  De hecho, estos complementos permiten que un modelo espec√≠fico especifique una lista de campos que deben incluirse en el objeto JSON, as√≠ como reglas adicionales, por ejemplo, para cambiarles el nombre o calcular valores din√°micamente. </p><br><p>  Las dificultades comienzan cuando necesitamos tener varias representaciones JSON diferentes del mismo modelo o cuando un objeto contiene entidades anidadas: asociaciones.  Es necesario <em>heredar, reutilizar y vincular los serializadores</em> . </p><br><p>  Los diferentes m√≥dulos resuelven estos problemas de diferentes maneras, pero pensemos, ¬øpuede la especificaci√≥n ayudarnos nuevamente?  De hecho, de hecho, toda la informaci√≥n sobre los requisitos para las representaciones JSON, todas las combinaciones posibles de campos, incluidas las entidades anidadas, ya est√°n en √©l.  Entonces podemos escribir un serializador autom√°tico. </p><br><p>  Le traigo a su atenci√≥n un peque√±o m√≥dulo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">secuenciaci√≥n-serializaci√≥n</a> (npm), que le permite hacer esto para los modelos Sequelize.  Toma una instancia del modelo o una matriz, as√≠ como el circuito requerido, y construye iterativamente un objeto serializado, teniendo en cuenta todos los campos requeridos y utilizando circuitos anidados para las entidades asociadas. </p><br><p>  Por lo tanto, supongamos que tenemos que devolver de la API a todos los usuarios que tienen publicaciones de blog, incluidos los comentarios sobre esas publicaciones.  Describimos esto usando la siguiente especificaci√≥n: </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># models.tinyspec Comment {authorId: i, message} Post {topic, message, comments?: Comment[]} User {name, isAdmin: b, age?: i} UserWithPosts &lt; User {posts: Post[]} # blogUsers.endpoints.tinyspec GET /blog/users =&gt; {users: UserWithPosts[]}</span></span></code> </pre> <br><p>  Ahora podemos construir la consulta usando Sequelize y devolver un objeto serializado que coincida exactamente con la especificaci√≥n que se acaba de describir: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Router <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'koa-router'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> serialize <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'sequelize-serialize'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { schemas } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./schemas'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> router = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Router(); router.get(<span class="hljs-string"><span class="hljs-string">'/blog/users'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (ctx) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> users = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> User.findAll({ <span class="hljs-attr"><span class="hljs-attr">include</span></span>: [{ <span class="hljs-attr"><span class="hljs-attr">association</span></span>: User.posts, <span class="hljs-attr"><span class="hljs-attr">required</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">include</span></span>: [Post.comments] }] }); ctx.body = serialize(users, schemas.UserWithPosts); });</code> </pre> <br><p>  Es casi m√°gico, ¬øverdad? </p><br><h3 id="4-staticheskaya-tipizaciya">  4. Mecanograf√≠a est√°tica </h3><br><p>  Si eres tan genial que est√°s usando TypeScript o Flow, es posible que ya te hayas preguntado: <em>"¬øQu√© pasa con mis queridos tipos est√°ticos?"</em>  .  Usando los <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">m√≥dulos sw2dts</a> o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">swagger-to-flowtype,</a> puede generar todas las definiciones necesarias basadas en esquemas JSON y usarlas para la tipificaci√≥n est√°tica de pruebas, datos de entrada y serializadores. </p><br><pre> <code class="bash hljs">tinyspec -j sw2dts ./swagger.json -o Api.d.ts --namespace Api</code> </pre> <br><p>  Ahora podemos usar tipos en controladores: </p><br><pre> <code class="hljs pgsql">router.patch(<span class="hljs-string"><span class="hljs-string">'/users/:id'</span></span>, async (ctx) =&gt; { // Specify <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> request data <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> const userData: Api.UserUpdate = ctx.request.body.<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>; // Run spec validation await <span class="hljs-keyword"><span class="hljs-keyword">validate</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">schemas</span></span>.UserUpdate, userData); // Query the <span class="hljs-keyword"><span class="hljs-keyword">database</span></span> const <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> = await <span class="hljs-keyword"><span class="hljs-keyword">User</span></span>.findById(ctx.params.id); await <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">update</span></span>(userData); // <span class="hljs-keyword"><span class="hljs-keyword">Return</span></span> serialized result const serialized: Api.<span class="hljs-keyword"><span class="hljs-keyword">User</span></span> = serialize(<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">schemas</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">User</span></span>); ctx.body = { <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: serialized }; });</code> </pre> <br><p>  Y en las pruebas: </p><br><pre> <code class="hljs pgsql">it(<span class="hljs-string"><span class="hljs-string">'Update user'</span></span>, async () =&gt; { // Static <span class="hljs-keyword"><span class="hljs-keyword">check</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> test <span class="hljs-keyword"><span class="hljs-keyword">input</span></span> data. const updateData: Api.UserUpdate = { <span class="hljs-type"><span class="hljs-type">name</span></span>: MODIFIED }; const res = await request.patch(<span class="hljs-string"><span class="hljs-string">'/users/1'</span></span>, { <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: updateData }); // <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> helper <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> request response: const <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: Api.<span class="hljs-keyword"><span class="hljs-keyword">User</span></span> = res.body.<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>; expect(<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>).<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>.be.validWithSchema(<span class="hljs-keyword"><span class="hljs-keyword">schemas</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">User</span></span>); expect(<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>).<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>.containSubset(updateData); });</code> </pre> <br><p>  Tenga en cuenta que las definiciones de tipo generadas se pueden usar no solo en el proyecto API en s√≠, sino tambi√©n en proyectos de aplicaci√≥n cliente para describir los tipos de funciones en las que funciona la API.  Los desarrolladores de clientes angulares estar√°n especialmente satisfechos con este regalo. </p><br><h3 id="5-privedenie-tipov-query-string">  5. Tipo de conversi√≥n de cadena de consulta </h3><br><p>  Si por alguna raz√≥n su API acepta solicitudes con el tipo MIME <code>application/x-www-form-urlencoded</code> y no <code>application/json</code> , el cuerpo de la solicitud se ver√° as√≠: </p><br><pre> <code class="python hljs">param1=value&amp;param2=<span class="hljs-number"><span class="hljs-number">777</span></span>&amp;param3=false</code> </pre> <br><p>  Lo mismo se aplica a los par√°metros de consulta (por ejemplo, en solicitudes GET).  En este caso, el servidor web no podr√° reconocer autom√°ticamente los tipos: todos los datos estar√°n en forma de cadenas ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠ hay una discusi√≥n</a> en el repositorio del m√≥dulo qpm npm), por lo que despu√©s del an√°lisis obtendr√° el siguiente objeto: </p><br><pre> <code class="python hljs">{ param1: <span class="hljs-string"><span class="hljs-string">'value'</span></span>, param2: <span class="hljs-string"><span class="hljs-string">'777'</span></span>, param3: <span class="hljs-string"><span class="hljs-string">'false'</span></span> }</code> </pre> <br><p>  En este caso, la solicitud no se validar√° de acuerdo con el esquema, lo que significa que ser√° necesario verificar manualmente que cada par√°metro tenga el formato correcto y llevarlo al tipo requerido. </p><br><p>  Como puede suponer, esto se puede hacer utilizando los mismos esquemas de nuestra especificaci√≥n.  Imagine que tenemos un punto final y un esquema de este tipo: </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># posts.endpoints.tinyspec GET /posts?PostsQuery # post.models.tinyspec PostsQuery { search, limit: i, offset: i, filter: { isRead: b } }</span></span></code> </pre> <br><p>  Aqu√≠ hay un ejemplo de una solicitud a dicho punto final </p><br><pre> <code class="python hljs">GET /posts?search=needle&amp;offset=<span class="hljs-number"><span class="hljs-number">10</span></span>&amp;limit=<span class="hljs-number"><span class="hljs-number">1</span></span>&amp;filter[isRead]=true</code> </pre> <br><p>  Escribamos una funci√≥n <code>castQuery</code> , que <code>castQuery</code> todos los par√°metros a los tipos necesarios para nosotros.  Se ver√° m√°s o menos as√≠: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">castQuery</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">query, schema</span></span></span><span class="hljs-function">) </span></span>{ _.mapValues(query, (value, key) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { type } = schema.properties[key] || {}; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!value || !type) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value; } <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'integer'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">parseInt</span></span>(value, <span class="hljs-number"><span class="hljs-number">10</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'number'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">parseFloat</span></span>(value); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'boolean'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value !== <span class="hljs-string"><span class="hljs-string">'false'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value; } }); }</code> </pre> <br><p>  Su implementaci√≥n m√°s completa con soporte para esquemas anidados, matrices y tipos <code>null</code> est√° disponible en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cast-with-schema</a> (npm).  Ahora podemos usarlo en nuestro c√≥digo: </p><br><pre> <code class="javascript hljs">router.get(<span class="hljs-string"><span class="hljs-string">'/posts'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (ctx) =&gt; { <span class="hljs-comment"><span class="hljs-comment">// Cast parameters to expected types const query = castQuery(ctx.query, schemas.PostsQuery); // Run spec validation await validate(schemas.PostsQuery, query); // Query the database const posts = await Post.search(query); // Return serialized result ctx.body = { posts: serialize(posts, schemas.Post) }; });</span></span></code> </pre> <br><p>  Observe c√≥mo de las cuatro l√≠neas del c√≥digo de punto final, los tres usan esquemas de la especificaci√≥n. </p><br><h2 id="luchshie-praktiki">  Mejores pr√°cticas </h2><br><h3 id="otdelnye-shemy-dlya-sozdaniya-i-izmeneniya">  Esquemas separados para crear y modificar </h3><br><p>  Por lo general, los esquemas que describen la respuesta del servidor son diferentes de los que describen la entrada utilizada para crear y modificar modelos.  Por ejemplo, la lista de campos disponibles para las <code>POST</code> y <code>PATCH</code> debe estar estrictamente limitada, mientras que en las solicitudes <code>PATCH</code> , generalmente todos los campos del esquema se hacen opcionales.  Los esquemas que determinan la respuesta pueden ser m√°s gratuitos. </p><br><p>  La <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">generaci√≥n</a> autom√°tica <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">de puntos</a> finales <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CRUDL de tinyspec</a> utiliza los <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">postfixes</a> <code>New</code> y <code>Update</code> .  <code>User*</code> se pueden definir de la siguiente manera: </p><br><pre> <code class="python hljs">User {id, email, name, isAdmin: b} UserNew !{email, name} UserUpdate !{email?, name?}</code> </pre> <br><p>  Intente no usar los mismos esquemas para diferentes tipos de acciones para evitar problemas de seguridad accidentales debido a la reutilizaci√≥n o herencia de esquemas antiguos. </p><br><h3 id="semantika-v-nazvaniyah-shem">  Sem√°ntica en nombres de esquema </h3><br><p>  El contenido de los mismos modelos puede variar en diferentes puntos finales.  Utilice los postfixes <code>With*</code> y <code>For*</code> en los nombres de esquema para mostrar en qu√© se diferencian y para qu√© sirven.  En modelos tinyspec tambi√©n se pueden heredar unos de otros.  Por ejemplo: </p><br><pre> <code class="python hljs">User {name, surname} UserWithPhotos &lt; User {photos: Photo[]} UserForAdmin &lt; User {id, email, lastLoginAt: d}</code> </pre> <br><p>  Los postfixes pueden ser variados y combinados.  Lo principal es que su nombre refleja la esencia y simplifica la familiaridad con la documentaci√≥n. </p><br><h3 id="razdelenie-endpointov-po-tipu-klienta">  Separaci√≥n de puntos finales por tipo de cliente </h3><br><p>  A menudo, los mismos puntos finales devuelven datos diferentes seg√∫n el tipo de cliente o la funci√≥n del usuario que accede al punto final.  Por ejemplo, los puntos finales de <code>GET /users</code> y <code>GET /messages</code> pueden ser muy diferentes para los usuarios de su aplicaci√≥n m√≥vil y para los administradores de back office.  Al mismo tiempo, cambiar el nombre del punto final en s√≠ puede ser una complicaci√≥n excesiva. </p><br><p>  Para describir el mismo punto final varias veces, puede agregar su tipo entre par√©ntesis despu√©s de la ruta.  Adem√°s, es √∫til usar etiquetas: esto ayudar√° a dividir la documentaci√≥n de sus puntos finales en grupos, cada uno de los cuales estar√° dise√±ado para un grupo espec√≠fico de clientes de su API.  Por ejemplo: </p><br><pre> <code class="python hljs">Mobile app: GET /users (mobile) =&gt; UserForMobile[] CRM admin panel: GET /users (admin) =&gt; UserForAdmin[]</code> </pre> <br><h2 id="dokumentaciya-rest-api">  Documentaci√≥n API REST </h2><br><p>  Una vez que tenga una especificaci√≥n en formato tinyspec u OpenAPI, puede generar documentaci√≥n hermosa en HTML y publicarla para deleite de los desarrolladores que usan su API. </p><br><p>  Adem√°s de los servicios en la nube mencionados anteriormente, existen herramientas de CLI que convierten OpenAPI 2.0 a HTML y PDF, despu√©s de lo cual puede descargarlo a cualquier alojamiento est√°tico.  Ejemplos: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">bootprint-openapi</a> (npm, usado por defecto en tinyspec) </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">swagger2markup-cli</a> (jar, hay <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">un ejemplo de uso</a> , se usar√° en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tinyspec Cloud</a> ) </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">redoc-cli</a> (npm) </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">widdershins</a> (npm) </li></ul><br><p>  <em>¬øSabes m√°s ejemplos?</em>  <em>Comp√°rtelos en los comentarios.</em> </p><br><p>  Desafortunadamente, OpenAPI 3.0, lanzado hace un a√±o, todav√≠a tiene un soporte deficiente y no pude encontrar ejemplos decentes de documentaci√≥n basados ‚Äã‚Äãen √©l: ni entre soluciones en la nube ni entre herramientas de CLI.  Por la misma raz√≥n, OpenAPI 3.0 a√∫n no es compatible con tinyspec. </p><br><h3 id="publikaciya-v-github">  Publicar en GitHub </h3><br><p>  Una de las formas m√°s f√°ciles de publicar documentaci√≥n es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GitHub Pages</a> .  Simplemente habilite el soporte de p√°ginas est√°ticas para el directorio <code>/docs</code> en la configuraci√≥n de su repositorio y almacene la documentaci√≥n HTML en esta carpeta. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/09b/5ad/775/09b5ad7757239f4405cb370cb59c6a7b.png"></p><br><p>  Puede agregar un comando para generar documentaci√≥n a trav√©s de tinyspec u otra herramienta CLI en los <code>scripts</code> en <code>package.json</code> y actualizar la documentaci√≥n con cada confirmaci√≥n: </p><br><pre> <code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">"scripts"</span></span>: { <span class="hljs-string"><span class="hljs-string">"docs"</span></span>: <span class="hljs-string"><span class="hljs-string">"tinyspec -h -o docs/"</span></span>, <span class="hljs-string"><span class="hljs-string">"precommit"</span></span>: <span class="hljs-string"><span class="hljs-string">"npm run docs"</span></span> }</code> </pre> <br><h3 id="continuous-integration">  Integraci√≥n continua </h3><br><p>  Puede incluir la generaci√≥n de documentaci√≥n en el ciclo de CI y publicarla, por ejemplo, en Amazon S3 en diferentes direcciones seg√∫n el entorno o la versi√≥n de su API, por ejemplo: <code>/docs/2.0</code> , <code>/docs/stable</code> , <code>/docs/staging</code> . </p><br><h3 id="tinyspec-cloud">  Nube Tinyspec </h3><br><p>  Si le gust√≥ la sintaxis de tinyspec, puede registrarse como uno de los primeros <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">usuarios</a> en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tinyspec.cloud</a> .  Vamos a construir sobre una base un servicio en la nube y CLI para la publicaci√≥n autom√°tica de documentaci√≥n con una amplia selecci√≥n de plantillas y la capacidad de desarrollar nuestras propias plantillas. </p><br><h2 id="zaklyuchenie">  Conclusi√≥n </h2><br><p>  Desarrollar una API REST es quiz√°s la actividad m√°s divertida de todas las que existen en el proceso de trabajar en servicios m√≥viles y web modernos.  No existe un zool√≥gico de navegadores, sistemas operativos y tama√±os de pantalla, todo est√° completamente bajo nuestro control, "a su alcance". </p><br><p>  Mantener la especificaci√≥n actual y las bonificaciones en forma de varias automatizaciones, que se proporcionan al mismo tiempo, hacen que este proceso sea a√∫n m√°s agradable.  Tal API se vuelve estructurada, transparente y confiable. </p><br><p>  <em>De hecho, incluso si estamos comprometidos en la creaci√≥n de un mito, ¬øpor qu√© no lo hacemos hermoso?</em> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es427601/">https://habr.com/ru/post/es427601/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es427587/index.html">Java concentrado para mil quinientas personas. Como fue el Joker 2018</a></li>
<li><a href="../es427589/index.html">Escribimos un chat en l√≠nea en Websockets usando Swoole</a></li>
<li><a href="../es427591/index.html">La arquitectura como carga</a></li>
<li><a href="../es427593/index.html">Magia de comando r√°pido en Vivaldi 2.1</a></li>
<li><a href="../es427595/index.html">Prueba Micronaut o Darling, reduje el marco</a></li>
<li><a href="../es427603/index.html">C√≥mo finalmente comenzar a escribir pruebas y no arrepentirse</a></li>
<li><a href="../es427605/index.html">C√≥mo la plataforma de crowdsourcing de Yandex ayuda a entrenar drones y evaluar la calidad del servicio</a></li>
<li><a href="../es427607/index.html">Datacenter en Suiza: trabajar como un reloj</a></li>
<li><a href="../es427609/index.html">Resolviendo la ecuaci√≥n con divisi√≥n entera sin fuerza bruta</a></li>
<li><a href="../es427611/index.html">La historia de c√≥mo actualic√© Yandex MapKit en iOS o mapas, dinero, 2 mapas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>