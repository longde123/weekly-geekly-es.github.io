<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèæ‚Äçüöí üåª üë®üèæ‚Äçü§ù‚Äçüë®üèΩ Indizes in PostgreSQL - 5 (GiST) ü•® üë≤ ü•å</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In den vorherigen Artikeln haben wir die PostgreSQL- Indexierungs-Engine , die Schnittstelle von Zugriffsmethoden und zwei Zugriffsmethoden erl√§utert:...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Indizes in PostgreSQL - 5 (GiST)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/444742/">  In den vorherigen Artikeln haben wir die PostgreSQL- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Indexierungs-Engine</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die Schnittstelle von Zugriffsmethoden</a> und zwei Zugriffsmethoden erl√§utert: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hash-Index</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">B-Tree</a> .  In diesem Artikel werden GiST-Indizes beschrieben. <br><br><h1>  Kern </h1><br>  GiST ist eine Abk√ºrzung f√ºr "Generalized Search Tree".  Dies ist ein ausgewogener Suchbaum, genau wie der zuvor beschriebene "B-Baum". <br><br>  Was ist der Unterschied?  Der "Btree" -Index ist eng mit der Vergleichssemantik verbunden: Die Unterst√ºtzung von "gr√∂√üeren", "kleineren" und "gleichen" Operatoren ist alles, was er kann (aber sehr f√§hig!). Moderne Datenbanken speichern jedoch Datentypen, f√ºr die diese Operatoren geeignet sind macht einfach keinen Sinn: Geodaten, Textdokumente, Bilder, ... <br><br>  F√ºr diese Datentypen hilft uns die GiST-Indexmethode.  Es erm√∂glicht das Definieren einer Regel zum Verteilen von Daten eines beliebigen Typs √ºber einen ausgeglichenen Baum und eine Methode zum Verwenden dieser Darstellung f√ºr den Zugriff durch einen Operator.  Beispielsweise kann der GiST-Index den R-Baum f√ºr r√§umliche Daten mit Unterst√ºtzung relativer Positionsoperatoren (links, rechts, enth√§lt usw.) oder den RD-Baum f√ºr Mengen mit Unterst√ºtzung von Schnitt- oder Einschlussoperatoren "aufnehmen". <br><br>  Dank der Erweiterbarkeit kann in PostgreSQL eine v√∂llig neue Methode von Grund auf neu erstellt werden: Zu diesem Zweck muss eine Schnittstelle zur Indexierungs-Engine implementiert werden.  Dies erfordert jedoch nicht nur eine vors√§tzliche Indizierungslogik, sondern auch die Zuordnung von Datenstrukturen zu Seiten, die effiziente Implementierung von Sperren und die Unterst√ºtzung eines Write-Ahead-Protokolls.  All dies setzt hohe Entwicklerf√§higkeiten und einen gro√üen menschlichen Aufwand voraus.  GiST vereinfacht die Aufgabe, indem es Probleme auf niedriger Ebene √ºbernimmt und eine eigene Schnittstelle bietet: verschiedene Funktionen, die sich nicht auf Techniken, sondern auf die Anwendungsdom√§ne beziehen.  In diesem Sinne k√∂nnen wir GiST als Rahmen f√ºr die Erstellung neuer Zugriffsmethoden betrachten. <br><a name="habracut"></a><br><h2>  Struktur </h2><br>  GiST ist ein Baum mit ausgeglichener H√∂he, der aus Knotenseiten besteht.  Die Knoten bestehen aus Indexzeilen. <br><br>  Jede Zeile eines Blattknotens (Blattzeile) enth√§lt im Allgemeinen ein <em>Pr√§dikat</em> (Boolescher Ausdruck) und einen Verweis auf eine Tabellenzeile (TID).  Indizierte Daten (Schl√ºssel) m√ºssen dieses Pr√§dikat erf√ºllen. <br><br>  Jede Zeile eines internen Knotens (interne Zeile) enth√§lt auch ein <em>Pr√§dikat</em> und einen Verweis auf einen untergeordneten Knoten, und alle indizierten Daten des untergeordneten Teilbaums m√ºssen diesem Pr√§dikat entsprechen.  Mit anderen Worten, das Pr√§dikat einer internen Zeile <em>enth√§lt</em> die Pr√§dikate aller untergeordneten Zeilen.  Dieses wichtige Merkmal des GiST-Index ersetzt die einfache Reihenfolge des B-Baums. <br><br>  Die Suche im GiST-Baum verwendet eine spezielle <em>Konsistenzfunktion</em> ("konsistent") - eine der Funktionen, die von der Schnittstelle definiert und f√ºr jede unterst√ºtzte Operatorfamilie auf ihre eigene Weise implementiert werden. <br><br>  Die Konsistenzfunktion wird f√ºr eine Indexzeile aufgerufen und bestimmt, ob das Pr√§dikat dieser Zeile mit dem Suchpr√§dikat √ºbereinstimmt (angegeben als " <em>Operatorausdruck f√ºr indizierte Felder</em> ").  F√ºr eine interne Zeile bestimmt diese Funktion tats√§chlich, ob ein Abstieg zum entsprechenden Teilbaum erforderlich ist, und f√ºr eine Blattzeile bestimmt die Funktion, ob die indizierten Daten dem Pr√§dikat entsprechen. <br><br>  Die Suche beginnt mit einem Wurzelknoten wie eine normale Baumsuche.  Mit der Konsistenzfunktion k√∂nnen Sie herausfinden, welche untergeordneten Knoten sinnvoll sind (m√∂glicherweise mehrere) und welche nicht.  Der Algorithmus wird dann f√ºr jeden gefundenen untergeordneten Knoten wiederholt.  Wenn der Knoten Blatt ist, wird die von der Konsistenzfunktion ausgew√§hlte Zeile als eines der Ergebnisse zur√ºckgegeben. <br><br>  Die Suche erfolgt in der Tiefe zuerst: Der Algorithmus versucht zun√§chst, einen Blattknoten zu erreichen.  Dies erm√∂glicht es, m√∂glichst bald erste Ergebnisse zur√ºckzugeben (was wichtig sein kann, wenn der Benutzer nur an mehreren Ergebnissen und nicht an allen interessiert ist). <br><br>  Beachten wir noch einmal, dass die Konsistenzfunktion nichts mit "gr√∂√üeren", "kleineren" oder "gleichen" Operatoren zu tun haben muss.  Die Semantik der Konsistenzfunktion kann sehr unterschiedlich sein, und daher wird nicht angenommen, dass der Index Werte in einer bestimmten Reihenfolge zur√ºckgibt. <br><br>  Wir werden keine Algorithmen zum Einf√ºgen und L√∂schen von Werten in GiST diskutieren: Einige weitere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schnittstellenfunktionen</a> f√ºhren diese Operationen aus.  Es gibt jedoch einen wichtigen Punkt.  Wenn ein neuer Wert in den Index eingef√ºgt wird, wird die Position f√ºr diesen Wert im Baum so ausgew√§hlt, dass die Pr√§dikate der √ºbergeordneten Zeilen so wenig wie m√∂glich erweitert werden (idealerweise √ºberhaupt nicht erweitert).  Wenn jedoch ein Wert gel√∂scht wird, wird das Pr√§dikat der √ºbergeordneten Zeile nicht mehr reduziert.  Dies geschieht nur in solchen F√§llen: Eine Seite wird in zwei Teile geteilt (wenn auf der Seite nicht gen√ºgend Platz zum Einf√ºgen einer neuen Indexzeile vorhanden ist) oder der Index wird von Grund auf neu erstellt (mit dem Befehl REINDEX oder VACUUM FULL).  Daher kann sich die Effizienz des GiST-Index f√ºr h√§ufig wechselnde Daten im Laufe der Zeit verschlechtern. <br><br>  Weiter werden wir einige Beispiele f√ºr Indizes f√ºr verschiedene Datentypen und n√ºtzliche Eigenschaften von GiST betrachten: <br><br><ul><li>  Punkte (und andere geometrische Objekte) und Suche nach n√§chsten Nachbarn. </li><li>  Intervalle und Ausschlussbeschr√§nkungen. </li><li>  Volltextsuche. </li></ul><br><h2>  R-Baum f√ºr Punkte </h2><br>  Wir werden das Obige anhand eines Index f√ºr Punkte in einer Ebene veranschaulichen (wir k√∂nnen √§hnliche Indizes auch f√ºr andere geometrische Objekte erstellen).  Ein regul√§rer B-Baum passt nicht zu diesem Datentyp, da f√ºr Punkte keine Vergleichsoperatoren definiert sind. <br><br>  Die Idee des R-Baums besteht darin, die Ebene in Rechtecke aufzuteilen, die insgesamt alle indizierten Punkte abdecken.  In einer Indexzeile wird ein Rechteck gespeichert, und das Pr√§dikat kann folgenderma√üen definiert werden: "Der gesuchte Punkt liegt innerhalb des angegebenen Rechtecks." <br><br>  Die Wurzel des R-Baums enth√§lt mehrere gr√∂√üte Rechtecke (die sich m√∂glicherweise schneiden).  Untergeordnete Knoten enthalten kleinere Rechtecke, die in das √ºbergeordnete eingebettet sind und insgesamt alle zugrunde liegenden Punkte abdecken. <br><br>  Theoretisch m√ºssen Blattknoten Punkte enthalten, die indiziert werden, aber der Datentyp muss in allen Indexzeilen gleich sein, und daher werden wieder Rechtecke gespeichert, aber zu Punkten ‚Äûreduziert‚Äú. <br><br>  Um eine solche Struktur zu visualisieren, stellen wir Bilder f√ºr drei Ebenen des R-Baums bereit.  Punkte sind Koordinaten von Flugh√§fen (√§hnlich wie in der Tabelle "Flugh√§fen" der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Demo-Datenbank</a> , es werden jedoch weitere Daten von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">openflights.org</a> bereitgestellt). <br><br><img src="https://habrastorage.org/web/492/fd0/a28/492fd0a2883b4ee39d75618f8f501e50.png"><br>  <em>Stufe eins: Zwei gro√üe sich √ºberschneidende Rechtecke sind sichtbar.</em> <br><br><img src="https://habrastorage.org/web/e42/78d/843/e4278d8439a3485e88128182f741b696.png"><br>  <em>Stufe zwei: Gro√üe Rechtecke werden in kleinere Bereiche aufgeteilt.</em> <br><br><img src="https://habrastorage.org/web/60e/c9d/99b/60ec9d99b4fe46c88bed2a9cc65dd0f5.png"><br>  <em>Stufe drei: Jedes Rechteck enth√§lt so viele Punkte, wie auf eine Indexseite passen.</em> <br><br>  Betrachten wir nun ein sehr einfaches "einstufiges" Beispiel: <br><br><img src="https://habrastorage.org/web/d89/478/666/d894786665774a76943e72338aec874c.png"><br><br><pre><code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> points(p <span class="hljs-type"><span class="hljs-type">point</span></span>); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> points(p) <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(1,1)'</span></span>), (<span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(3,2)'</span></span>), (<span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(6,3)'</span></span>), (<span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(5,5)'</span></span>), (<span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(7,8)'</span></span>), (<span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(8,6)'</span></span>); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> points <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gist(p);</code> </pre> <br>  Bei dieser Aufteilung sieht die Indexstruktur wie folgt aus: <br><br><img src="https://habrastorage.org/web/caf/919/8a5/caf9198a538d46f48985d42a301a0b2d.png"><br><br>  Der erstellte Index kann verwendet werden, um die folgende Abfrage zu beschleunigen, z. B. "Alle im angegebenen Rechteck enthaltenen Punkte finden".  Diese Bedingung kann wie folgt formalisiert werden: <code>p &lt;@ box '(2,1),(6,3)'</code> (Operator <code>&lt;@</code> aus der Familie "points_ops" bedeutet "enthalten in"): <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> enable_seqscan = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>; postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> points <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> p &lt;@ <span class="hljs-type"><span class="hljs-type">box</span></span> <span class="hljs-string"><span class="hljs-string">'(2,1),(7,4)'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ---------------------------------------------- Index Only Scan using points_p_idx on points Index Cond: (p &lt;@ '(7,4),(2,1)'::box) (2 rows)</code> </pre><br>  Die Konsistenzfunktion des Operators (" <em>indiziertes Feld</em> &lt;@ <em>Ausdruck</em> ", wobei <em>indiziertes Feld</em> ein Punkt und <em>Ausdruck</em> ein Rechteck ist) ist wie folgt definiert.  F√ºr eine interne Zeile wird "Ja" zur√ºckgegeben, wenn sich das Rechteck mit dem durch den <em>Ausdruck</em> definierten Rechteck schneidet.  F√ºr eine Blattzeile gibt die Funktion "Ja" zur√ºck, wenn ihr Punkt ("reduziertes" Rechteck) in dem durch den Ausdruck definierten Rechteck enthalten ist. <br><br><img src="https://habrastorage.org/web/226/f28/493/226f28493e15430193a69781e1600b9f.png"><br><br>  Die Suche beginnt mit dem Wurzelknoten.  Das Rechteck (2,1) - (7,4) schneidet sich mit (1,1) - (6,3), schneidet sich jedoch nicht mit (5,5) - (8,8), daher besteht keine Notwendigkeit zum zweiten Teilbaum absteigen. <br><br><img src="https://habrastorage.org/web/d52/792/511/d527925110fb46deadb382762561a621.png"><br><br>  Bei Erreichen eines Blattknotens gehen wir die drei dort enthaltenen Punkte durch und geben zwei davon als Ergebnis zur√ºck: (3.2) und (6.3). <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> points <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> p &lt;@ <span class="hljs-type"><span class="hljs-type">box</span></span> <span class="hljs-string"><span class="hljs-string">'(2,1),(7,4)'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> p ------- (3,2) (6,3) (2 rows)</code> </pre><br><h3>  Interna </h3><br>  Leider erlaubt die √ºbliche "Seiteninspektion" keinen Blick in den GiST-Index.  Es gibt aber auch einen anderen Weg: die Erweiterung "Gevel".  Es ist nicht in der Standardlieferung enthalten, siehe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Installationsanweisungen</a> . <br><br>  Wenn alles richtig gemacht ist, stehen Ihnen drei Funktionen zur Verf√ºgung.  Erstens k√∂nnen wir einige Statistiken erhalten: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> gist_stat(<span class="hljs-string"><span class="hljs-string">'airports_coordinates_idx'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> gist_stat ------------------------------------------ Number of levels: 4 + Number of pages: 690 + Number of leaf pages: 625 + Number of tuples: 7873 + Number of invalid tuples: 0 + Number of leaf tuples: 7184 + Total size of tuples: 354692 bytes + Total size of leaf tuples: 323596 bytes + Total size of index: 5652480 bytes+ (1 row)</code> </pre><br>  Es ist klar, dass der Index f√ºr Flughafenkoordinaten 690 Seiten gro√ü ist und dass der Index aus vier Ebenen besteht: Die Wurzel- und zwei interne Ebenen wurden in den obigen Abbildungen gezeigt, und die vierte Ebene ist Blatt. <br><br>  Tats√§chlich wird der Index f√ºr achttausend Punkte deutlich kleiner sein: Hier wurde er aus Gr√ºnden der √úbersichtlichkeit mit einem 10% -F√ºllfaktor erstellt. <br><br>  Zweitens k√∂nnen wir den Indexbaum ausgeben: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> gist_tree(<span class="hljs-string"><span class="hljs-string">'airports_coordinates_idx'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> gist_tree ----------------------------------------------------------------------------------------- 0(l:0) blk: 0 numTuple: 5 free: 7928b(2.84%) rightlink:4294967295 (InvalidBlockNumber) + 1(l:1) blk: 335 numTuple: 15 free: 7488b(8.24%) rightlink:220 (OK) + 1(l:2) blk: 128 numTuple: 9 free: 7752b(5.00%) rightlink:49 (OK) + 1(l:3) blk: 57 numTuple: 12 free: 7620b(6.62%) rightlink:35 (OK) + 2(l:3) blk: 62 numTuple: 9 free: 7752b(5.00%) rightlink:57 (OK) + 3(l:3) blk: 72 numTuple: 7 free: 7840b(3.92%) rightlink:23 (OK) + 4(l:3) blk: 115 numTuple: 17 free: 7400b(9.31%) rightlink:33 (OK) + ...</code> </pre><br>  Und drittens k√∂nnen wir die in Indexzeilen gespeicherten Daten ausgeben.  Beachten Sie die folgende Nuance: Das Ergebnis der Funktion muss in den gew√ºnschten Datentyp umgewandelt werden.  In unserer Situation ist dieser Typ "Box" (ein Begrenzungsrechteck).  Beachten Sie beispielsweise f√ºnf Zeilen auf der obersten Ebene: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">level</span></span>, a <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> gist_print(<span class="hljs-string"><span class="hljs-string">'airports_coordinates_idx'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> t(<span class="hljs-keyword"><span class="hljs-keyword">level</span></span> <span class="hljs-type"><span class="hljs-type">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">valid</span></span> <span class="hljs-type"><span class="hljs-type">bool</span></span>, a <span class="hljs-type"><span class="hljs-type">box</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">level</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><pre> <code class="plaintext hljs"> level | a -------+----------------------------------------------------------------------- 1 | (47.663586,80.803207),(-39.2938003540039,-90) 1 | (179.951004028,15.6700000762939),(15.2428998947144,-77.9634017944336) 1 | (177.740997314453,73.5178070068359),(15.0664,10.57970047) 1 | (-77.3191986083984,79.9946975708),(-179.876998901,-43.810001373291) 1 | (-39.864200592041,82.5177993774),(-81.254096984863,-64.2382965088) (5 rows)</code> </pre><br>  Tats√§chlich wurden die oben angegebenen Zahlen nur aus diesen Daten erstellt. <br><br><h2>  Operatoren f√ºr die Suche und Bestellung </h2><br>  Bisher diskutierte Operatoren (wie <code>&lt;@</code> im Pr√§dikat <code>p &lt;@ box '(2,1),(7,4)'</code> ) k√∂nnen als Suchoperatoren bezeichnet werden, da sie Suchbedingungen in einer Abfrage angeben. <br><br>  Es gibt auch einen anderen Operatortyp: Bestelloperatoren.  Sie werden f√ºr Spezifikationen der Sortierreihenfolge in der ORDER BY-Klausel anstelle herk√∂mmlicher Spezifikationen f√ºr Spaltennamen verwendet.  Das Folgende ist ein Beispiel f√ºr eine solche Abfrage: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> points <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> p &lt;-&gt; <span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(4,7)'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><pre> <code class="plaintext hljs"> p ------- (5,5) (7,8) (2 rows)</code> </pre><br>  <code>p &lt;-&gt; point '(4,7)'</code> hier ein Ausdruck, der einen Ordnungsoperator <code>&lt;-&gt;</code> , der den Abstand von einem Argument zum anderen angibt.  Die Bedeutung der Abfrage besteht darin, zwei Punkte zur√ºckzugeben, die dem Punkt am n√§chsten liegen (4.7).  Eine solche Suche wird als k-NN - k-Suche nach dem n√§chsten Nachbarn bezeichnet. <br><br>  Um Abfragen dieser Art zu unterst√ºtzen, muss eine Zugriffsmethode eine zus√§tzliche <em>Distanzfunktion</em> definieren, und der Bestelloperator muss in der entsprechenden Operatorklasse enthalten sein (z. B. "points_ops" -Klasse f√ºr Punkte).  Die folgende Abfrage zeigt Operatoren mit ihren Typen ("s" - Suche und "o" - Reihenfolge): <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> amop.amopopr::<span class="hljs-type"><span class="hljs-type">regoperator</span></span>, amop.amoppurpose, amop.amopstrategy <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_opclass opc, pg_opfamily opf, pg_am am, pg_amop amop <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> opc.opcname = <span class="hljs-string"><span class="hljs-string">'point_ops'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> opf.oid = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.oid = opf.opfmethod <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amopfamily = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.amname = <span class="hljs-string"><span class="hljs-string">'gist'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amoplefttype = opc.opcintype;</code> </pre><pre> <code class="plaintext hljs"> amopopr | amoppurpose | amopstrategy -------------------+-------------+-------------- &lt;&lt;(point,point) | s | 1 strictly left &gt;&gt;(point,point) | s | 5 strictly right ~=(point,point) | s | 6 coincides &lt;^(point,point) | s | 10 strictly below &gt;^(point,point) | s | 11 strictly above &lt;-&gt;(point,point) | o | 15 distance &lt;@(point,box) | s | 28 contained in rectangle &lt;@(point,polygon) | s | 48 contained in polygon &lt;@(point,circle) | s | 68 contained in circle (9 rows)</code> </pre><br>  Die Anzahl der Strategien wird ebenfalls angezeigt und ihre Bedeutung erkl√§rt.  Es ist klar, dass es weit mehr Strategien als f√ºr "btree" gibt, von denen nur einige f√ºr Punkte unterst√ºtzt werden.  F√ºr andere Datentypen k√∂nnen unterschiedliche Strategien definiert werden. <br><br>  Die Distanzfunktion wird f√ºr ein Indexelement aufgerufen und muss die Distanz (unter Ber√ºcksichtigung der Operatorsemantik) von dem durch den Ausdruck definierten Wert (" <em>indizierter Feldordnungsoperatorausdruck</em> ") zu dem angegebenen Element berechnen.  Bei einem Blattelement ist dies nur der Abstand zum indizierten Wert.  F√ºr ein internes Element muss die Funktion das Minimum der Abst√§nde zu den untergeordneten Blattelementen zur√ºckgeben.  Da das Durchsuchen aller untergeordneten Zeilen ziemlich kostspielig w√§re, kann die Funktion die Entfernung optimistisch untersch√§tzen, jedoch auf Kosten der Verringerung der Sucheffizienz.  Die Funktion darf jedoch niemals die Entfernung √ºbersch√§tzen, da dies die Arbeit des Index st√∂rt. <br><br>  Die Distanzfunktion kann Werte eines beliebigen sortierbaren Typs zur√ºckgeben (um Werte zu ordnen, verwendet PostgreSQL die Vergleichssemantik aus der entsprechenden Operatorfamilie der Zugriffsmethode "btree", wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zuvor beschrieben</a> ). <br><br>  F√ºr Punkte in einer Ebene wird der Abstand in einem sehr √ºblichen Sinne interpretiert: Der Wert von <code>(x1,y1) &lt;-&gt; (x2,y2)</code> entspricht der Quadratwurzel der Summe der Quadrate der Differenzen der Abszissen und Ordinaten.  Der Abstand von einem Punkt zu einem Begrenzungsrechteck wird als minimaler Abstand vom Punkt zu diesem Rechteck oder als Null angenommen, wenn der Punkt innerhalb des Rechtecks ‚Äã‚Äãliegt.  Es ist einfach, diesen Wert zu berechnen, ohne durch untergeordnete Punkte zu gehen, und der Wert ist mit Sicherheit nicht gr√∂√üer als der Abstand zu einem untergeordneten Punkt. <br><br>  Betrachten wir den Suchalgorithmus f√ºr die obige Abfrage. <br><br><img src="https://habrastorage.org/web/84b/56a/075/84b56a075dbd42d6b5d8cc8cb10c4b01.png"><br><br>  Die Suche beginnt mit dem Wurzelknoten.  Der Knoten enth√§lt zwei Begrenzungsrechtecke.  Der Abstand zu (1,1) - (6,3) betr√§gt 4,0 und zu (5,5) - (8,8) betr√§gt 1,0. <br><br>  Untergeordnete Knoten werden in der Reihenfolge der Vergr√∂√üerung durchlaufen.  Auf diese Weise steigen wir zuerst zum n√§chsten untergeordneten Knoten ab und berechnen die Abst√§nde zu den Punkten (wir zeigen die Zahlen in der Abbildung zur besseren Sichtbarkeit): <br><br><img src="https://habrastorage.org/web/491/959/f07/491959f070754781b794e0dff01d5aec.png"><br><br>  Diese Information reicht aus, um die ersten beiden Punkte (5,5) und (7,8) zur√ºckzugeben.  Da wir uns bewusst sind, dass der Abstand zu Punkten, die innerhalb des Rechtecks ‚Äã‚Äã(1,1) - (6,3) liegen, 4,0 oder mehr betr√§gt, m√ºssen wir nicht zum ersten untergeordneten Knoten absteigen. <br><br>  Aber was w√§re, wenn wir die ersten <em>drei</em> Punkte finden m√ºssten? <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> points <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> p &lt;-&gt; <span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(4,7)'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>;</code> </pre><pre> <code class="pgsql hljs"> p <span class="hljs-comment"><span class="hljs-comment">------- (5,5) (7,8) (8,6) (3 rows)</span></span></code> </pre><br>  Obwohl der zweite untergeordnete Knoten alle diese Punkte enth√§lt, k√∂nnen wir nicht zur√ºckkehren (8,6), ohne in den ersten untergeordneten Knoten zu schauen, da dieser Knoten n√§here Punkte enthalten kann (da 4.0 &lt;4.1). <br><br><img src="https://habrastorage.org/web/9bb/43a/775/9bb43a775fc445769e37af8bb50daae0.png"><br><br>  In diesem Beispiel werden f√ºr interne Zeilen die Anforderungen f√ºr die Abstandsfunktion erl√§utert.  Durch Auswahl eines kleineren Abstands (4,0 anstelle des tats√§chlichen Abstands 4,5) f√ºr die zweite Zeile haben wir die Effizienz verringert (der Algorithmus hat unn√∂tigerweise begonnen, einen zus√§tzlichen Knoten zu untersuchen), aber die Korrektheit des Algorithmus nicht beeintr√§chtigt. <br><br>  Bis vor kurzem war GiST die einzige Zugriffsmethode, die mit bestellenden Betreibern umgehen konnte.  Die Situation hat sich jedoch ge√§ndert: Die RUM-Zugriffsmethode (wird weiter diskutiert) hat sich bereits dieser Gruppe von Methoden angeschlossen, und es ist nicht unwahrscheinlich, dass sich ein guter alter B-Baum ihnen anschlie√üt: Ein Patch, der von Nikita Glukhov, unserem Kollegen, entwickelt wurde, wird gerade erstellt von der Community diskutiert. <br><blockquote>  Ab M√§rz 2019 wird k-NN-Unterst√ºtzung f√ºr SP-GiST im kommenden PostgreSQL 12 (ebenfalls von Nikita verfasst) hinzugef√ºgt.  Patch f√ºr B-Tree ist noch in Bearbeitung. <br></blockquote><br><h2>  R-Baum f√ºr Intervalle </h2><br>  Ein weiteres Beispiel f√ºr die Verwendung der GiST-Zugriffsmethode ist die Indizierung von Intervallen, z. B. Zeitintervallen (Typ "tsrange").  Der Unterschied besteht darin, dass interne Knoten Begrenzungsintervalle anstelle von Begrenzungsrechtecken enthalten. <br><br>  Betrachten wir ein einfaches Beispiel.  Wir werden ein Ferienhaus vermieten und Reservierungsintervalle in einer Tabelle speichern: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> reservations(during <span class="hljs-type"><span class="hljs-type">tsrange</span></span>); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> reservations(during) <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-string"><span class="hljs-string">'[2016-12-30, 2017-01-09)'</span></span>), (<span class="hljs-string"><span class="hljs-string">'[2017-02-23, 2017-02-27)'</span></span>), (<span class="hljs-string"><span class="hljs-string">'[2017-04-29, 2017-05-02)'</span></span>); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> reservations <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gist(during);</code> </pre><br>  Der Index kann verwendet werden, um beispielsweise die folgende Abfrage zu beschleunigen: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> reservations <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> during &amp;&amp; <span class="hljs-string"><span class="hljs-string">'[2017-01-01, 2017-04-01)'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> during ----------------------------------------------- ["2016-12-30 00:00:00","2017-01-08 00:00:00") ["2017-02-23 00:00:00","2017-02-26 00:00:00") (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> reservations <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> during &amp;&amp; <span class="hljs-string"><span class="hljs-string">'[2017-01-01, 2017-04-01)'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------------------------------------------------------------------ Index Only Scan using reservations_during_idx on reservations Index Cond: (during &amp;&amp; '["2017-01-01 00:00:00","2017-04-01 00:00:00")'::tsrange) (2 rows)</code> </pre><br>  <code>&amp;&amp;</code> Operator f√ºr Intervalle bezeichnet Schnittpunkt;  Daher muss die Abfrage alle Intervalle zur√ºckgeben, die sich mit dem angegebenen Intervall √ºberschneiden.  F√ºr einen solchen Operator bestimmt die Konsistenzfunktion, ob sich das angegebene Intervall mit einem Wert in einer internen oder einer Blattzeile √ºberschneidet. <br><br>  Beachten Sie, dass es entweder nicht darum geht, Intervalle in einer bestimmten Reihenfolge abzurufen, obwohl Vergleichsoperatoren f√ºr Intervalle definiert sind.  Wir k√∂nnen den "btree" -Index f√ºr Intervalle verwenden, aber in diesem Fall m√ºssen wir auf die Unterst√ºtzung solcher Operationen verzichten: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> amop.amopopr::<span class="hljs-type"><span class="hljs-type">regoperator</span></span>, amop.amoppurpose, amop.amopstrategy <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_opclass opc, pg_opfamily opf, pg_am am, pg_amop amop <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> opc.opcname = <span class="hljs-string"><span class="hljs-string">'range_ops'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> opf.oid = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.oid = opf.opfmethod <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amopfamily = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.amname = <span class="hljs-string"><span class="hljs-string">'gist'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amoplefttype = opc.opcintype;</code> </pre><pre> <code class="plaintext hljs"> amopopr | amoppurpose | amopstrategy -------------------------+-------------+-------------- @&gt;(anyrange,anyelement) | s | 16 contains element &lt;&lt;(anyrange,anyrange) | s | 1 strictly left &amp;&lt;(anyrange,anyrange) | s | 2 not beyond right boundary &amp;&amp;(anyrange,anyrange) | s | 3 intersects &amp;&gt;(anyrange,anyrange) | s | 4 not beyond left boundary &gt;&gt;(anyrange,anyrange) | s | 5 strictly right -|-(anyrange,anyrange) | s | 6 adjacent @&gt;(anyrange,anyrange) | s | 7 contains interval &lt;@(anyrange,anyrange) | s | 8 contained in interval =(anyrange,anyrange) | s | 18 equals (10 rows)</code> </pre><br>  (Mit Ausnahme der Gleichheit, die in der Operatorklasse f√ºr die Zugriffsmethode "btree" enthalten ist.) <br><br><h3>  Interna </h3><br>  Wir k√∂nnen mit der gleichen "Gevel" -Erweiterung nach innen schauen.  Wir m√ºssen nur daran denken, den Datentyp im Aufruf von gist_print zu √§ndern: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">level</span></span>, a <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> gist_print(<span class="hljs-string"><span class="hljs-string">'reservations_during_idx'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> t(<span class="hljs-keyword"><span class="hljs-keyword">level</span></span> <span class="hljs-type"><span class="hljs-type">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">valid</span></span> <span class="hljs-type"><span class="hljs-type">bool</span></span>, a <span class="hljs-type"><span class="hljs-type">tsrange</span></span>);</code> </pre><pre> <code class="plaintext hljs"> level | a -------+----------------------------------------------- 1 | ["2016-12-30 00:00:00","2017-01-09 00:00:00") 1 | ["2017-02-23 00:00:00","2017-02-27 00:00:00") 1 | ["2017-04-29 00:00:00","2017-05-02 00:00:00") (3 rows)</code> </pre><br><h2>  Ausschlussbeschr√§nkung </h2><br>  Der GiST-Index kann zur Unterst√ºtzung von Ausschlussbeschr√§nkungen (EXCLUDE) verwendet werden. <br><br>  Die Ausschlussbeschr√§nkung stellt sicher, dass bestimmte Felder von zwei beliebigen Tabellenzeilen in Bezug auf einige Operatoren nicht miteinander "korrespondieren".  Wenn der Operator "gleich" gew√§hlt wird, erhalten wir genau die eindeutige Einschr√§nkung: Die angegebenen Felder von zwei beliebigen Zeilen sind nicht gleich. <br><br>  Die Ausschlussbeschr√§nkung wird vom Index sowie von der eindeutigen Einschr√§nkung unterst√ºtzt.  Wir k√∂nnen jeden Operator so ausw√§hlen, dass: <br><br><ol><li>  Es wird von der Indexmethode "can_exclude" unterst√ºtzt (z. B. "btree", GiST oder SP-GiST, jedoch nicht GIN). </li><li>  Es ist kommutativ, dh die Bedingung ist erf√ºllt: a Operator b = b Operator a. </li></ol><br>  Dies ist eine Liste geeigneter Strategien und Beispiele f√ºr Operatoren (Operatoren k√∂nnen, wie wir uns erinnern, unterschiedliche Namen haben und nicht f√ºr alle Datentypen verf√ºgbar sein): <br><br><ul><li>  F√ºr "btree": <br><ul><li>  "Gleich" <code>=</code> </li></ul></li><li>  F√ºr GiST und SP-GiST: <br><ul><li>  "Kreuzung" <code>&amp;&amp;</code> </li><li>  "Zufall" <code>~=</code> </li><li>  Nachbarschaft <code>-|-</code> </li></ul></li></ul><br>  Beachten Sie, dass wir den Gleichheitsoperator in einer Ausschlussbedingung verwenden k√∂nnen, dies jedoch unpraktisch ist: Eine eindeutige Einschr√§nkung ist effizienter.  Genau deshalb haben wir bei der Er√∂rterung von B-B√§umen keine Ausschlussbeschr√§nkungen angesprochen. <br><br>  Lassen Sie uns ein Beispiel f√ºr die Verwendung einer Ausschlussbeschr√§nkung geben.  Es ist vern√ºnftig, keine Reservierungen f√ºr sich √ºberschneidende Intervalle zuzulassen. <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> reservations <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> <span class="hljs-keyword"><span class="hljs-keyword">exclude</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gist(during <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> &amp;&amp;);</code> </pre><br>  Sobald wir die Ausschlussbeschr√§nkung erstellt haben, k√∂nnen wir Zeilen hinzuf√ºgen: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> reservations(during) <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-string"><span class="hljs-string">'[2017-06-10, 2017-06-13)'</span></span>);</code> </pre><br>  Der Versuch, ein Schnittintervall in die Tabelle einzuf√ºgen, f√ºhrt jedoch zu einem Fehler: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> reservations(during) <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-string"><span class="hljs-string">'[2017-05-15, 2017-06-15)'</span></span>);</code> </pre><pre> <code class="plaintext hljs">ERROR: conflicting key value violates exclusion constraint "reservations_during_excl" DETAIL: Key (during)=(["2017-05-15 00:00:00","2017-06-15 00:00:00")) conflicts with existing key (during)=(["2017-06-10 00:00:00","2017-06-13 00:00:00")).</code> </pre><br><h3>  Erweiterung "Btree_gist" </h3><br>  Lassen Sie uns das Problem komplizieren.  Wir erweitern unser bescheidenes Gesch√§ft und werden mehrere Cottages vermieten: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> reservations <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> house_no <span class="hljs-type"><span class="hljs-type">integer</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br>  Wir m√ºssen die Ausschlussbeschr√§nkung √§ndern, damit die Hausnummern ber√ºcksichtigt werden.  GiST unterst√ºtzt jedoch nicht die Gleichheitsoperation f√ºr Ganzzahlen: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> reservations <span class="hljs-keyword"><span class="hljs-keyword">drop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constraint</span></span> reservations_during_excl; postgres=# <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> reservations <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> <span class="hljs-keyword"><span class="hljs-keyword">exclude</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gist(during <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> &amp;&amp;, house_no <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> =);</code> </pre><pre> <code class="plaintext hljs">ERROR: data type integer has no default operator class for access method "gist" HINT: You must specify an operator class for the index or define a default operator class for the data type.</code> </pre><br>  In diesem Fall <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hilft die</a> Erweiterung " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">btree_gist</a> ", die die GiST-Unterst√ºtzung f√ºr Operationen hinzuf√ºgt, die B-B√§umen eigen sind.  GiST kann schlie√ülich alle Operatoren unterst√ºtzen. Warum sollten wir es nicht lehren, "gr√∂√üere", "kleinere" und "gleiche" Operatoren zu unterst√ºtzen? <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extension</span></span> btree_gist; postgres=# <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> reservations <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> <span class="hljs-keyword"><span class="hljs-keyword">exclude</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gist(during <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> &amp;&amp;, house_no <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> =);</code> </pre><br>  Jetzt k√∂nnen wir das erste Cottage noch nicht f√ºr die gleichen Daten reservieren: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> reservations(during, house_no) <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-string"><span class="hljs-string">'[2017-05-15, 2017-06-15)'</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><pre> <code class="plaintext hljs">ERROR: conflicting key value violates exclusion constraint "reservations_during_house_no_excl"</code> </pre><br>  Wir k√∂nnen jedoch den zweiten reservieren: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> reservations(during, house_no) <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-string"><span class="hljs-string">'[2017-05-15, 2017-06-15)'</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre><br>  Beachten Sie jedoch, dass GiST die Operatoren "gr√∂√üer", "kleiner" und "gleich" zwar irgendwie unterst√ºtzen kann, B-tree dies jedoch immer noch besser kann.  Daher lohnt es sich, diese Technik nur zu verwenden, wenn der GiST-Index im Wesentlichen ben√∂tigt wird, wie in unserem Beispiel. <br><br><h2>  RD-Baum f√ºr die Volltextsuche </h2><br><h3>  √úber die Volltextsuche </h3><br>  Beginnen wir mit einer minimalistischen Einf√ºhrung in die PostgreSQL-Volltextsuche (wenn Sie sich auskennen, k√∂nnen Sie diesen Abschnitt √ºberspringen). <br><br>  Die Aufgabe der Volltextsuche besteht darin, aus dem <em>Dokumentensatz</em> diejenigen Dokumente auszuw√§hlen, die der Suchabfrage entsprechen.  (Wenn es viele √ºbereinstimmende Dokumente gibt, ist es wichtig, <em>die besten</em> √ºbereinstimmenden Dokumente zu finden, aber wir werden an dieser Stelle nichts dazu sagen.) <br><br>  Zu Suchzwecken wird ein Dokument in einen speziellen Typ "tsvector" konvertiert, der <em>Lexeme</em> und ihre Positionen im Dokument enth√§lt.  Lexeme sind W√∂rter, die in die f√ºr die Suche geeignete Form konvertiert wurden.  Beispielsweise werden W√∂rter normalerweise in Kleinbuchstaben umgewandelt und variable Endungen abgeschnitten: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> to_tsvector(<span class="hljs-string"><span class="hljs-string">'There was a crooked man, and he walked a crooked mile'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> to_tsvector ----------------------------------------- 'crook':4,10 'man':5 'mile':11 'walk':8 (1 row)</code> </pre><br>  Wir k√∂nnen auch sehen, dass einige W√∂rter ( <em>Stoppw√∂rter genannt</em> ) vollst√§ndig gel√∂scht werden ("dort", "war", "a", "und", er "), da sie vermutlich zu oft vorkommen, als dass eine Suche nach ihnen sinnvoll w√§re.  All diese Konvertierungen k√∂nnen sicherlich konfiguriert werden, aber das ist eine andere Geschichte. <br><br>  Eine Suchabfrage wird mit einem anderen Typ dargestellt: "tsquery".  Eine Abfrage besteht ungef√§hr aus einem oder mehreren Lexemen, die durch Konnektive verbunden sind: "und" &amp; "oder" |, "nicht"! .. Wir k√∂nnen auch Klammern verwenden, um die Priorit√§t der Operation zu kl√§ren. <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> to_tsquery(<span class="hljs-string"><span class="hljs-string">'man &amp; (walking | running)'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> to_tsquery ---------------------------- 'man' &amp; ( 'walk' | 'run' ) (1 row)</code> </pre><br>  F√ºr die <code>@@</code> wird nur ein √úbereinstimmungsoperator <code>@@</code> verwendet. <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> to_tsvector(<span class="hljs-string"><span class="hljs-string">'There was a crooked man, and he walked a crooked mile'</span></span>) @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'man &amp; (walking | running)'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ?column? ---------- t (1 row)</code> </pre><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> to_tsvector(<span class="hljs-string"><span class="hljs-string">'There was a crooked man, and he walked a crooked mile'</span></span>) @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'man &amp; (going | running)'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ?column? ---------- f (1 row)</code> </pre><br>  Diese Information reicht vorerst aus.  In einem n√§chsten Artikel mit GIN-Index werden wir uns etwas eingehender mit der Volltextsuche befassen. <br><br><h3>  RD-B√§ume </h3><br>  F√ºr eine schnelle Volltextsuche muss zum einen in der Tabelle eine Spalte vom Typ "tsvector" gespeichert werden (um zu vermeiden, dass bei der Suche jedes Mal eine kostspielige Konvertierung durchgef√ºhrt wird), und zum anderen muss ein Index f√ºr diese Spalte erstellt werden.  Eine der m√∂glichen Zugriffsmethoden hierf√ºr ist GiST. <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> ts(doc <span class="hljs-type"><span class="hljs-type">text</span></span>, doc_tsv <span class="hljs-type"><span class="hljs-type">tsvector</span></span>); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> ts <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gist(doc_tsv); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> ts(doc) <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-string"><span class="hljs-string">'Can a sheet slitter slit sheets?'</span></span>), (<span class="hljs-string"><span class="hljs-string">'How many sheets could a sheet slitter slit?'</span></span>), (<span class="hljs-string"><span class="hljs-string">'I slit a sheet, a sheet I slit.'</span></span>), (<span class="hljs-string"><span class="hljs-string">'Upon a slitted sheet I sit.'</span></span>), (<span class="hljs-string"><span class="hljs-string">'Whoever slit the sheets is a good sheet slitter.'</span></span>), (<span class="hljs-string"><span class="hljs-string">'I am a sheet slitter.'</span></span>), (<span class="hljs-string"><span class="hljs-string">'I slit sheets.'</span></span>), (<span class="hljs-string"><span class="hljs-string">'I am the sleekest sheet slitter that ever slit sheets.'</span></span>), (<span class="hljs-string"><span class="hljs-string">'She slits the sheet she sits on.'</span></span>); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> ts <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> doc_tsv = to_tsvector(doc);</code> </pre><br>  Es ist sicherlich zweckm√§√üig, einen Ausl√∂ser mit dem letzten Schritt zu beauftragen (Konvertierung des Dokuments in "tsvector"). <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ts;</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]---------------------------------------------------- doc | Can a sheet slitter slit sheets? doc_tsv | 'sheet':3,6 'slit':5 'slitter':4 -[ RECORD 2 ]---------------------------------------------------- doc | How many sheets could a sheet slitter slit? doc_tsv | 'could':4 'mani':2 'sheet':3,6 'slit':8 'slitter':7 -[ RECORD 3 ]---------------------------------------------------- doc | I slit a sheet, a sheet I slit. doc_tsv | 'sheet':4,6 'slit':2,8 -[ RECORD 4 ]---------------------------------------------------- doc | Upon a slitted sheet I sit. doc_tsv | 'sheet':4 'sit':6 'slit':3 'upon':1 -[ RECORD 5 ]---------------------------------------------------- doc | Whoever slit the sheets is a good sheet slitter. doc_tsv | 'good':7 'sheet':4,8 'slit':2 'slitter':9 'whoever':1 -[ RECORD 6 ]---------------------------------------------------- doc | I am a sheet slitter. doc_tsv | 'sheet':4 'slitter':5 -[ RECORD 7 ]---------------------------------------------------- doc | I slit sheets. doc_tsv | 'sheet':3 'slit':2 -[ RECORD 8 ]---------------------------------------------------- doc | I am the sleekest sheet slitter that ever slit sheets. doc_tsv | 'ever':8 'sheet':5,10 'sleekest':4 'slit':9 'slitter':6 -[ RECORD 9 ]---------------------------------------------------- doc | She slits the sheet she sits on. doc_tsv | 'sheet':4 'sit':6 'slit':2</code> </pre><br>  Wie soll der Index aufgebaut sein?  Die direkte Verwendung des R-Baums ist keine Option, da unklar ist, wie ein "Begrenzungsrechteck" f√ºr Dokumente definiert werden soll.  Wir k√∂nnen diesen Ansatz jedoch f√ºr Mengen modifizieren, einen sogenannten RD-Baum (RD steht f√ºr "Russian Doll").  Unter einer Menge wird in diesem Fall eine Menge von Lexemen verstanden, aber im Allgemeinen kann eine Menge eine beliebige sein. <br><br>  Eine Idee von RD-B√§umen besteht darin, ein Begrenzungsrechteck durch eine Begrenzungsmenge zu ersetzen, dh eine Menge, die alle Elemente von untergeordneten Mengen enth√§lt. <br><br>  Es stellt sich eine wichtige Frage, wie Mengen in Indexzeilen dargestellt werden sollen.  Am einfachsten ist es, alle Elemente der Menge aufzulisten.  Dies k√∂nnte wie folgt aussehen: <br><br><img src="https://habrastorage.org/webt/cp/ul/cx/cpulcxgydwxo8fl0ul0bdlsn3ws.png"><br><br>  F√ºr den Zugriff √ºber die Bedingung <code>doc_tsv @@ to_tsquery('sit')</code> k√∂nnten wir dann beispielsweise nur zu den Knoten absteigen, die das "sit" <code>doc_tsv @@ to_tsquery('sit')</code> enthalten: <br><br><img src="https://habrastorage.org/webt/h9/2g/4j/h92g4jpzw_7wj-x3katxlwrw3ac.png"><br><br>  Diese Darstellung hat offensichtliche Probleme.  Die Anzahl der Lexeme in einem Dokument kann sehr gro√ü sein, sodass Indexzeilen eine gro√üe Gr√∂√üe haben und in TOAST gelangen, wodurch der Index weitaus weniger effizient wird.  Selbst wenn jedes Dokument nur wenige eindeutige Lexeme enth√§lt, kann die Vereinigung von Mengen dennoch sehr gro√ü sein: Je h√∂her der Stamm, desto gr√∂√üer die Indexzeilen. <br><br>  Eine Darstellung wie diese wird manchmal verwendet, jedoch f√ºr andere Datentypen.  Bei der Volltextsuche wird eine andere, kompaktere L√∂sung verwendet - ein sogenannter <em>Signaturbaum</em> .  Die Idee ist allen bekannt, die sich mit Bloom-Filtern befasst haben. <br><br>  Jedes Lexem kann mit seiner <em>Signatur dargestellt werden</em> : eine Bitfolge einer bestimmten L√§nge, bei der alle Bits bis auf eins Null sind.  Die Position dieses Bits wird durch den Wert der Hash-Funktion des Lexems bestimmt (wir haben die Interna von Hash-Funktionen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">fr√ºher</a> besprochen). <br><br>  Die Dokumentensignatur ist das bitweise ODER der Signaturen aller Dokumentlexeme. <br><br>  Nehmen wir die folgenden Signaturen von Lexemen an: <br><br><pre> k√∂nnte 1.000.000
 jemals 0001000
 gut 0000010
 mani 0000100
 Blatt 0000100
 schlankste 0100000
 sitzen 0010000
 Schlitz 0001000
 Slitter 0000001
 auf 0000010
 wer auch immer 0010000
</pre><br>  Dann sind die Unterschriften der Dokumente wie folgt: <br><br><pre> Kann ein Blechschneider Bl√§tter schneiden?  0001101
 Wie viele Bl√§tter k√∂nnte ein Blattschneider schneiden?  1001101
 Ich schneide ein Blatt, ein Blatt, das ich schneide.  0001100
 Auf einem geschlitzten Laken sitze ich.  0011110
 Wer die Bl√§tter schneidet, ist ein guter Blattschneider.  0011111
 Ich bin ein Blechschneider.  0000101
 Ich schneide Laken.  0001100
 Ich bin der glatteste Blattschneider, der jemals Bl√§tter geschnitten hat.  0101101
 Sie schneidet das Blatt, auf dem sie sitzt.  0011100
</pre><br>  Der Indexbaum kann wie folgt dargestellt werden: <br><br><img src="https://habrastorage.org/webt/ou/f9/gz/ouf9gz7l7wgmgmgzi5gik7nrg50.png"><br><br>  Die Vorteile dieses Ansatzes liegen auf der Hand: Indexzeilen sind gleich klein, und ein solcher Index ist kompakt.  Ein Nachteil ist aber auch klar: Die Genauigkeit wird der Kompaktheit geopfert. <br><br>  Betrachten wir die gleiche Bedingung <code>doc_tsv @@ to_tsquery('sit')</code> .  Und berechnen wir die Signatur der Suchabfrage auf die gleiche Weise wie f√ºr das Dokument: 0010000 in diesem Fall.  Die Konsistenzfunktion muss alle untergeordneten Knoten zur√ºckgeben, deren Signaturen mindestens ein Bit aus der Abfragesignatur enthalten: <br><br><img src="https://habrastorage.org/webt/qi/qm/l4/qiqml4l5yu8_qiyvidk-3j8iqhs.png"><br><br>  Vergleichen Sie mit der obigen Abbildung: Wir k√∂nnen sehen, dass der Baum gelb geworden ist, was bedeutet, dass w√§hrend der Suche falsch positive Ergebnisse auftreten und √ºberm√§√üige Knoten durchlaufen werden.  Hier haben wir das "whoever" -Lexem aufgenommen, dessen Signatur leider mit der Signatur des "sit" -Lexems √ºbereinstimmt.  Es ist wichtig, dass im Muster keine falschen Negative auftreten k√∂nnen. Das hei√üt, wir werden die ben√∂tigten Werte sicher nicht verpassen. <br><br>  Au√üerdem kann es vorkommen, dass verschiedene Dokumente auch die gleichen Signaturen erhalten: In unserem Beispiel sind ungl√ºckliche Dokumente "Ich schneide ein Blatt, ein Blatt, das ich schneide" und "Ich schneide Bl√§tter" (beide haben die Signatur 0001100).  Und wenn eine Blattindexzeile nicht den Wert von "tsvector" speichert, gibt der Index selbst falsch positive Ergebnisse aus.  In diesem Fall fordert die Methode die Indizierungs-Engine nat√ºrlich auf, das Ergebnis mit der Tabelle erneut zu √ºberpr√ºfen, damit der Benutzer diese Fehlalarme nicht sieht.  Die Sucheffizienz kann jedoch beeintr√§chtigt werden. <br><br>  Tats√§chlich ist eine Signatur in der aktuellen Implementierung 124 Byte gro√ü, in den Abbildungen 7 Bit, sodass die oben genannten Probleme viel seltener auftreten als im Beispiel.  In Wirklichkeit werden aber auch viel mehr Dokumente indiziert.  Um die Anzahl der Fehlalarme der Indexmethode irgendwie zu verringern, wird die Implementierung etwas schwierig: Der indizierte "tsvector" wird in einer Blattindexzeile gespeichert, jedoch nur, wenn seine Gr√∂√üe nicht gro√ü ist (etwas weniger als 1/16 von eine Seite, die f√ºr 8-KB-Seiten etwa ein halbes Kilobyte entspricht). <br><br><h3>  Beispiel </h3><br>  Um zu sehen, wie die Indizierung f√ºr tats√§chliche Daten funktioniert, nehmen wir das Archiv der E-Mails "pgsql-hackers".  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die im Beispiel verwendete Version</a> enth√§lt 356125 Nachrichten mit dem Versanddatum, dem Betreff, dem Autor und dem Text: <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> sent <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]------------------------------------------------------------------------ id | 1572389 parent_id | 1562808 sent | 1997-06-24 11:31:09 subject | Re: [HACKERS] Array bug is still there.... author | "Thomas G. Lockhart" &lt;Thomas.Lockhart@jpl.nasa.gov&gt; body_plain | Andrew Martin wrote: + | &gt; Just run the regression tests on 6.1 and as I suspected the array bug + | &gt; is still there. The regression test passes because the expected output+ | &gt; has been fixed to the *wrong* output. + | + | OK, I think I understand the current array behavior, which is apparently+ | different than the behavior for v1.0x. + ...</code> </pre><br>  Hinzuf√ºgen und Ausf√ºllen der Spalte vom Typ "tsvector" und Erstellen des Index.  Hier werden drei Werte in einem Vektor (Betreff, Autor und Nachrichtentext) zusammengefasst, um zu zeigen, dass das Dokument kein Feld sein muss, sondern aus v√∂llig unterschiedlichen beliebigen Teilen bestehen kann. <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> <span class="hljs-keyword"><span class="hljs-keyword">column</span></span> tsv <span class="hljs-type"><span class="hljs-type">tsvector</span></span>; fts=# <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> tsv = to_tsvector(subject||<span class="hljs-string"><span class="hljs-string">' '</span></span>||author||<span class="hljs-string"><span class="hljs-string">' '</span></span>||body_plain);</code> </pre><pre> <code class="plaintext hljs">NOTICE: word is too long to be indexed DETAIL: Words longer than 2047 characters are ignored. ... UPDATE 356125</code> </pre><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gist(tsv);</code> </pre><br>  Wie wir sehen k√∂nnen, wurde eine bestimmte Anzahl von W√∂rtern wegen zu gro√üer Gr√∂√üe gel√∂scht.  Der Index wird jedoch schlie√ülich erstellt und kann Suchanfragen unterst√ºtzen: <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'magic &amp; value'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ---------------------------------------------------------- Index Scan using mail_messages_tsv_idx on mail_messages (actual time=0.998..416.335 rows=898 loops=1) Index Cond: (tsv @@ to_tsquery('magic &amp; value'::text)) Rows Removed by Index Recheck: 7859 Planning time: 0.203 ms Execution time: 416.492 ms (5 rows)</code> </pre><br>  Wir k√∂nnen sehen, dass die Zugriffsmethode zusammen mit 898 Zeilen, die der Bedingung entsprechen, 7859 weitere Zeilen zur√ºckgab, die durch erneutes √úberpr√ºfen mit der Tabelle herausgefiltert wurden.  Dies zeigt einen negativen Einfluss des Genauigkeitsverlustes auf die Effizienz. <br><br><h3>  Interna </h3><br>  Um den Inhalt des Index zu analysieren, verwenden wir erneut die Erweiterung "gevel": <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">level</span></span>, a <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> gist_print(<span class="hljs-string"><span class="hljs-string">'mail_messages_tsv_idx'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> t(<span class="hljs-keyword"><span class="hljs-keyword">level</span></span> <span class="hljs-type"><span class="hljs-type">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">valid</span></span> <span class="hljs-type"><span class="hljs-type">bool</span></span>, a gtsvector) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>;</code> </pre><pre> <code class="plaintext hljs"> level | a -------+------------------------------- 1 | 992 true bits, 0 false bits 2 | 988 true bits, 4 false bits 3 | 573 true bits, 419 false bits 4 | 65 unique words 4 | 107 unique words 4 | 64 unique words 4 | 42 unique words ...</code> </pre><br>  Werte des speziellen Typs "gtsvector", die in Indexzeilen gespeichert sind, sind tats√§chlich die Signatur und m√∂glicherweise die Quelle "tsvector".  Wenn der Vektor verf√ºgbar ist, enth√§lt die Ausgabe die Anzahl der Lexeme (eindeutige W√∂rter), andernfalls die Anzahl der wahren und falschen Bits in der Signatur. <br><br>  Es ist klar, dass im Wurzelknoten die Signatur zu "allen" degeneriert ist, dh eine Indexebene wurde absolut nutzlos (und eine weitere wurde mit nur vier falschen Bits fast nutzlos). <br><br><h2>  Eigenschaften </h2><br>  Schauen wir uns die Eigenschaften der GiST-Zugriffsmethode an (Abfragen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wurden fr√ºher bereitgestellt</a> ): <br><br><pre> <code class="plaintext hljs"> amname | name | pg_indexam_has_property --------+---------------+------------------------- gist | can_order | f gist | can_unique | f gist | can_multi_col | t gist | can_exclude | t</code> </pre><br>  Das Sortieren von Werten und eindeutige Einschr√§nkungen werden nicht unterst√ºtzt.  Wie wir gesehen haben, kann der Index auf mehreren Spalten aufgebaut und in Ausschlussbeschr√§nkungen verwendet werden. <br><br>  Die folgenden Indexschicht-Eigenschaften sind verf√ºgbar: <br><br><pre> <code class="plaintext hljs"> name | pg_index_has_property ---------------+----------------------- clusterable | t index_scan | t bitmap_scan | t backward_scan | f</code> </pre><br>  Und die interessantesten Eigenschaften sind die der S√§ulenschicht.  Einige der Eigenschaften sind unabh√§ngig von Operatorklassen: <br><br><pre> <code class="plaintext hljs"> name | pg_index_column_has_property --------------------+------------------------------ asc | f desc | f nulls_first | f nulls_last | f orderable | f search_array | f search_nulls | t</code> </pre><br>  (Die Sortierung wird nicht unterst√ºtzt. Der Index kann nicht zum Durchsuchen eines Arrays verwendet werden. NULL-Werte werden unterst√ºtzt.) <br><br>  Die beiden verbleibenden Eigenschaften "distance_orderable" und "returnable" h√§ngen jedoch von der verwendeten Operatorklasse ab.  Zum Beispiel erhalten wir f√ºr Punkte: <br><br><pre> <code class="plaintext hljs"> name | pg_index_column_has_property --------------------+------------------------------ distance_orderable | t returnable | t</code> </pre><br>  Die erste Eigenschaft gibt an, dass der Entfernungsoperator f√ºr die Suche nach n√§chsten Nachbarn verf√ºgbar ist.  Und der zweite besagt, dass der Index nur f√ºr den Index-Scan verwendet werden kann.  Obwohl Blattindexzeilen Rechtecke anstelle von Punkten speichern, kann die Zugriffsmethode das zur√ºckgeben, was ben√∂tigt wird. <br><br>  Die folgenden Eigenschaften gelten f√ºr Intervalle: <br><br><pre> <code class="plaintext hljs"> name | pg_index_column_has_property --------------------+------------------------------ distance_orderable | f returnable | t</code> </pre><br>  F√ºr Intervalle ist die Distanzfunktion nicht definiert und daher ist die Suche nach n√§chsten Nachbarn nicht m√∂glich. <br><br>  Und f√ºr die Volltextsuche erhalten wir: <br><br><pre> <code class="plaintext hljs"> name | pg_index_column_has_property --------------------+------------------------------ distance_orderable | f returnable | f</code> </pre><br>  Die Unterst√ºtzung des Nur-Index-Scans ist verloren gegangen, da Blattzeilen nur die Signatur ohne die Daten selbst enthalten k√∂nnen.  Dies ist jedoch ein geringf√ºgiger Verlust, da sich ohnehin niemand f√ºr den Wert vom Typ "tsvector" interessiert: Dieser Wert wird zur Auswahl von Zeilen verwendet, w√§hrend der Quelltext angezeigt werden muss, aber dennoch im Index fehlt. <br><br><h2>  Andere Datentypen </h2><br>  Abschlie√üend werden einige weitere Typen erw√§hnt, die derzeit von der GiST-Zugriffsmethode unterst√ºtzt werden, zus√§tzlich zu den bereits diskutierten geometrischen Typen (am Beispiel von Punkten), Intervallen und Volltextsucharten. <br><br>  Bei Standardtypen ist dies der Typ " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">inet</a> " f√ºr IP-Adressen.  Der Rest wird durch Erweiterungen hinzugef√ºgt: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">cube</a> bietet den Datentyp "cube" f√ºr mehrdimensionale Cubes.  F√ºr diesen Typ wird ebenso wie f√ºr geometrische Typen in einer Ebene die GiST-Operatorklasse definiert: R-Baum, der die Suche nach n√§chsten Nachbarn unterst√ºtzt. <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">seg</a> bietet den Datentyp "seg" f√ºr Intervalle mit Grenzen, die mit einer bestimmten Genauigkeit angegeben wurden, und unterst√ºtzt den GiST-Index f√ºr diesen Datentyp (R-Tree). <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">intarray</a> erweitert die Funktionalit√§t von Integer-Arrays und f√ºgt ihnen GiST-Unterst√ºtzung hinzu.  Es sind zwei Operatorklassen implementiert: "gist__int_ops" (RD-Baum mit vollst√§ndiger Darstellung der Schl√ºssel in Indexzeilen) und "gist__bigint_ops" (Signatur-RD-Baum).  Die erste Klasse kann f√ºr kleine Arrays verwendet werden, die zweite f√ºr gr√∂√üere Arrays. <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ltree</a> f√ºgt den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Datentyp</a> "ltree" f√ºr baumartige Strukturen und die GiST-Unterst√ºtzung f√ºr diesen Datentyp (RD-Baum) hinzu. <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">pg_trgm</a> f√ºgt eine spezielle Operatorklasse "gist_trgm_ops" zur Verwendung von Trigrammen bei der Volltextsuche hinzu.  Dies ist jedoch zusammen mit dem GIN-Index weiter zu er√∂rtern. <br></li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lesen Sie weiter</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de444742/">https://habr.com/ru/post/de444742/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de444728/index.html">Als ich ein Buch √ºber die Moskauer Staatsuniversit√§t oder 12 kritische Fehler schrieb und ver√∂ffentlichte</a></li>
<li><a href="../de444730/index.html">Warum serverlose Technologie eine Revolution im Produktmanagement ist</a></li>
<li><a href="../de444732/index.html">Leistungsoptimierung apache2</a></li>
<li><a href="../de444734/index.html">Habraseminar: echte Geschichten √ºber Content Marketing</a></li>
<li><a href="../de444738/index.html">Pixelkunst: Vom Entwurf zum Spielobjekt</a></li>
<li><a href="../de444744/index.html">Senden von E-Mails mit PHP</a></li>
<li><a href="../de444746/index.html">Wir laden Sie zum MskDotNet Meetup # 34 in der Raiffeisenbank upd Broadcast ein</a></li>
<li><a href="../de444748/index.html">3 Schl√ºsselqualit√§ten eines erfolgreichen Produktmanagers: Yuri Golikov, VP of Engineering Wrike</a></li>
<li><a href="../de444752/index.html">Die Geschichte von SXSW: Wie alles begann</a></li>
<li><a href="../de444756/index.html">DARPA wird einen Raketen-Nuklearmotor entwickeln</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>