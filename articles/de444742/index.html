<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏾‍🚒 🌻 👨🏾‍🤝‍👨🏽 Indizes in PostgreSQL - 5 (GiST) 🥨 👲 🥌</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In den vorherigen Artikeln haben wir die PostgreSQL- Indexierungs-Engine , die Schnittstelle von Zugriffsmethoden und zwei Zugriffsmethoden erläutert:...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Indizes in PostgreSQL - 5 (GiST)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/444742/">  In den vorherigen Artikeln haben wir die PostgreSQL- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Indexierungs-Engine</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die Schnittstelle von Zugriffsmethoden</a> und zwei Zugriffsmethoden erläutert: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hash-Index</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">B-Tree</a> .  In diesem Artikel werden GiST-Indizes beschrieben. <br><br><h1>  Kern </h1><br>  GiST ist eine Abkürzung für "Generalized Search Tree".  Dies ist ein ausgewogener Suchbaum, genau wie der zuvor beschriebene "B-Baum". <br><br>  Was ist der Unterschied?  Der "Btree" -Index ist eng mit der Vergleichssemantik verbunden: Die Unterstützung von "größeren", "kleineren" und "gleichen" Operatoren ist alles, was er kann (aber sehr fähig!). Moderne Datenbanken speichern jedoch Datentypen, für die diese Operatoren geeignet sind macht einfach keinen Sinn: Geodaten, Textdokumente, Bilder, ... <br><br>  Für diese Datentypen hilft uns die GiST-Indexmethode.  Es ermöglicht das Definieren einer Regel zum Verteilen von Daten eines beliebigen Typs über einen ausgeglichenen Baum und eine Methode zum Verwenden dieser Darstellung für den Zugriff durch einen Operator.  Beispielsweise kann der GiST-Index den R-Baum für räumliche Daten mit Unterstützung relativer Positionsoperatoren (links, rechts, enthält usw.) oder den RD-Baum für Mengen mit Unterstützung von Schnitt- oder Einschlussoperatoren "aufnehmen". <br><br>  Dank der Erweiterbarkeit kann in PostgreSQL eine völlig neue Methode von Grund auf neu erstellt werden: Zu diesem Zweck muss eine Schnittstelle zur Indexierungs-Engine implementiert werden.  Dies erfordert jedoch nicht nur eine vorsätzliche Indizierungslogik, sondern auch die Zuordnung von Datenstrukturen zu Seiten, die effiziente Implementierung von Sperren und die Unterstützung eines Write-Ahead-Protokolls.  All dies setzt hohe Entwicklerfähigkeiten und einen großen menschlichen Aufwand voraus.  GiST vereinfacht die Aufgabe, indem es Probleme auf niedriger Ebene übernimmt und eine eigene Schnittstelle bietet: verschiedene Funktionen, die sich nicht auf Techniken, sondern auf die Anwendungsdomäne beziehen.  In diesem Sinne können wir GiST als Rahmen für die Erstellung neuer Zugriffsmethoden betrachten. <br><a name="habracut"></a><br><h2>  Struktur </h2><br>  GiST ist ein Baum mit ausgeglichener Höhe, der aus Knotenseiten besteht.  Die Knoten bestehen aus Indexzeilen. <br><br>  Jede Zeile eines Blattknotens (Blattzeile) enthält im Allgemeinen ein <em>Prädikat</em> (Boolescher Ausdruck) und einen Verweis auf eine Tabellenzeile (TID).  Indizierte Daten (Schlüssel) müssen dieses Prädikat erfüllen. <br><br>  Jede Zeile eines internen Knotens (interne Zeile) enthält auch ein <em>Prädikat</em> und einen Verweis auf einen untergeordneten Knoten, und alle indizierten Daten des untergeordneten Teilbaums müssen diesem Prädikat entsprechen.  Mit anderen Worten, das Prädikat einer internen Zeile <em>enthält</em> die Prädikate aller untergeordneten Zeilen.  Dieses wichtige Merkmal des GiST-Index ersetzt die einfache Reihenfolge des B-Baums. <br><br>  Die Suche im GiST-Baum verwendet eine spezielle <em>Konsistenzfunktion</em> ("konsistent") - eine der Funktionen, die von der Schnittstelle definiert und für jede unterstützte Operatorfamilie auf ihre eigene Weise implementiert werden. <br><br>  Die Konsistenzfunktion wird für eine Indexzeile aufgerufen und bestimmt, ob das Prädikat dieser Zeile mit dem Suchprädikat übereinstimmt (angegeben als " <em>Operatorausdruck für indizierte Felder</em> ").  Für eine interne Zeile bestimmt diese Funktion tatsächlich, ob ein Abstieg zum entsprechenden Teilbaum erforderlich ist, und für eine Blattzeile bestimmt die Funktion, ob die indizierten Daten dem Prädikat entsprechen. <br><br>  Die Suche beginnt mit einem Wurzelknoten wie eine normale Baumsuche.  Mit der Konsistenzfunktion können Sie herausfinden, welche untergeordneten Knoten sinnvoll sind (möglicherweise mehrere) und welche nicht.  Der Algorithmus wird dann für jeden gefundenen untergeordneten Knoten wiederholt.  Wenn der Knoten Blatt ist, wird die von der Konsistenzfunktion ausgewählte Zeile als eines der Ergebnisse zurückgegeben. <br><br>  Die Suche erfolgt in der Tiefe zuerst: Der Algorithmus versucht zunächst, einen Blattknoten zu erreichen.  Dies ermöglicht es, möglichst bald erste Ergebnisse zurückzugeben (was wichtig sein kann, wenn der Benutzer nur an mehreren Ergebnissen und nicht an allen interessiert ist). <br><br>  Beachten wir noch einmal, dass die Konsistenzfunktion nichts mit "größeren", "kleineren" oder "gleichen" Operatoren zu tun haben muss.  Die Semantik der Konsistenzfunktion kann sehr unterschiedlich sein, und daher wird nicht angenommen, dass der Index Werte in einer bestimmten Reihenfolge zurückgibt. <br><br>  Wir werden keine Algorithmen zum Einfügen und Löschen von Werten in GiST diskutieren: Einige weitere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schnittstellenfunktionen</a> führen diese Operationen aus.  Es gibt jedoch einen wichtigen Punkt.  Wenn ein neuer Wert in den Index eingefügt wird, wird die Position für diesen Wert im Baum so ausgewählt, dass die Prädikate der übergeordneten Zeilen so wenig wie möglich erweitert werden (idealerweise überhaupt nicht erweitert).  Wenn jedoch ein Wert gelöscht wird, wird das Prädikat der übergeordneten Zeile nicht mehr reduziert.  Dies geschieht nur in solchen Fällen: Eine Seite wird in zwei Teile geteilt (wenn auf der Seite nicht genügend Platz zum Einfügen einer neuen Indexzeile vorhanden ist) oder der Index wird von Grund auf neu erstellt (mit dem Befehl REINDEX oder VACUUM FULL).  Daher kann sich die Effizienz des GiST-Index für häufig wechselnde Daten im Laufe der Zeit verschlechtern. <br><br>  Weiter werden wir einige Beispiele für Indizes für verschiedene Datentypen und nützliche Eigenschaften von GiST betrachten: <br><br><ul><li>  Punkte (und andere geometrische Objekte) und Suche nach nächsten Nachbarn. </li><li>  Intervalle und Ausschlussbeschränkungen. </li><li>  Volltextsuche. </li></ul><br><h2>  R-Baum für Punkte </h2><br>  Wir werden das Obige anhand eines Index für Punkte in einer Ebene veranschaulichen (wir können ähnliche Indizes auch für andere geometrische Objekte erstellen).  Ein regulärer B-Baum passt nicht zu diesem Datentyp, da für Punkte keine Vergleichsoperatoren definiert sind. <br><br>  Die Idee des R-Baums besteht darin, die Ebene in Rechtecke aufzuteilen, die insgesamt alle indizierten Punkte abdecken.  In einer Indexzeile wird ein Rechteck gespeichert, und das Prädikat kann folgendermaßen definiert werden: "Der gesuchte Punkt liegt innerhalb des angegebenen Rechtecks." <br><br>  Die Wurzel des R-Baums enthält mehrere größte Rechtecke (die sich möglicherweise schneiden).  Untergeordnete Knoten enthalten kleinere Rechtecke, die in das übergeordnete eingebettet sind und insgesamt alle zugrunde liegenden Punkte abdecken. <br><br>  Theoretisch müssen Blattknoten Punkte enthalten, die indiziert werden, aber der Datentyp muss in allen Indexzeilen gleich sein, und daher werden wieder Rechtecke gespeichert, aber zu Punkten „reduziert“. <br><br>  Um eine solche Struktur zu visualisieren, stellen wir Bilder für drei Ebenen des R-Baums bereit.  Punkte sind Koordinaten von Flughäfen (ähnlich wie in der Tabelle "Flughäfen" der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Demo-Datenbank</a> , es werden jedoch weitere Daten von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">openflights.org</a> bereitgestellt). <br><br><img src="https://habrastorage.org/web/492/fd0/a28/492fd0a2883b4ee39d75618f8f501e50.png"><br>  <em>Stufe eins: Zwei große sich überschneidende Rechtecke sind sichtbar.</em> <br><br><img src="https://habrastorage.org/web/e42/78d/843/e4278d8439a3485e88128182f741b696.png"><br>  <em>Stufe zwei: Große Rechtecke werden in kleinere Bereiche aufgeteilt.</em> <br><br><img src="https://habrastorage.org/web/60e/c9d/99b/60ec9d99b4fe46c88bed2a9cc65dd0f5.png"><br>  <em>Stufe drei: Jedes Rechteck enthält so viele Punkte, wie auf eine Indexseite passen.</em> <br><br>  Betrachten wir nun ein sehr einfaches "einstufiges" Beispiel: <br><br><img src="https://habrastorage.org/web/d89/478/666/d894786665774a76943e72338aec874c.png"><br><br><pre><code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> points(p <span class="hljs-type"><span class="hljs-type">point</span></span>); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> points(p) <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(1,1)'</span></span>), (<span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(3,2)'</span></span>), (<span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(6,3)'</span></span>), (<span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(5,5)'</span></span>), (<span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(7,8)'</span></span>), (<span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(8,6)'</span></span>); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> points <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gist(p);</code> </pre> <br>  Bei dieser Aufteilung sieht die Indexstruktur wie folgt aus: <br><br><img src="https://habrastorage.org/web/caf/919/8a5/caf9198a538d46f48985d42a301a0b2d.png"><br><br>  Der erstellte Index kann verwendet werden, um die folgende Abfrage zu beschleunigen, z. B. "Alle im angegebenen Rechteck enthaltenen Punkte finden".  Diese Bedingung kann wie folgt formalisiert werden: <code>p &lt;@ box '(2,1),(6,3)'</code> (Operator <code>&lt;@</code> aus der Familie "points_ops" bedeutet "enthalten in"): <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> enable_seqscan = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>; postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> points <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> p &lt;@ <span class="hljs-type"><span class="hljs-type">box</span></span> <span class="hljs-string"><span class="hljs-string">'(2,1),(7,4)'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ---------------------------------------------- Index Only Scan using points_p_idx on points Index Cond: (p &lt;@ '(7,4),(2,1)'::box) (2 rows)</code> </pre><br>  Die Konsistenzfunktion des Operators (" <em>indiziertes Feld</em> &lt;@ <em>Ausdruck</em> ", wobei <em>indiziertes Feld</em> ein Punkt und <em>Ausdruck</em> ein Rechteck ist) ist wie folgt definiert.  Für eine interne Zeile wird "Ja" zurückgegeben, wenn sich das Rechteck mit dem durch den <em>Ausdruck</em> definierten Rechteck schneidet.  Für eine Blattzeile gibt die Funktion "Ja" zurück, wenn ihr Punkt ("reduziertes" Rechteck) in dem durch den Ausdruck definierten Rechteck enthalten ist. <br><br><img src="https://habrastorage.org/web/226/f28/493/226f28493e15430193a69781e1600b9f.png"><br><br>  Die Suche beginnt mit dem Wurzelknoten.  Das Rechteck (2,1) - (7,4) schneidet sich mit (1,1) - (6,3), schneidet sich jedoch nicht mit (5,5) - (8,8), daher besteht keine Notwendigkeit zum zweiten Teilbaum absteigen. <br><br><img src="https://habrastorage.org/web/d52/792/511/d527925110fb46deadb382762561a621.png"><br><br>  Bei Erreichen eines Blattknotens gehen wir die drei dort enthaltenen Punkte durch und geben zwei davon als Ergebnis zurück: (3.2) und (6.3). <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> points <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> p &lt;@ <span class="hljs-type"><span class="hljs-type">box</span></span> <span class="hljs-string"><span class="hljs-string">'(2,1),(7,4)'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> p ------- (3,2) (6,3) (2 rows)</code> </pre><br><h3>  Interna </h3><br>  Leider erlaubt die übliche "Seiteninspektion" keinen Blick in den GiST-Index.  Es gibt aber auch einen anderen Weg: die Erweiterung "Gevel".  Es ist nicht in der Standardlieferung enthalten, siehe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Installationsanweisungen</a> . <br><br>  Wenn alles richtig gemacht ist, stehen Ihnen drei Funktionen zur Verfügung.  Erstens können wir einige Statistiken erhalten: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> gist_stat(<span class="hljs-string"><span class="hljs-string">'airports_coordinates_idx'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> gist_stat ------------------------------------------ Number of levels: 4 + Number of pages: 690 + Number of leaf pages: 625 + Number of tuples: 7873 + Number of invalid tuples: 0 + Number of leaf tuples: 7184 + Total size of tuples: 354692 bytes + Total size of leaf tuples: 323596 bytes + Total size of index: 5652480 bytes+ (1 row)</code> </pre><br>  Es ist klar, dass der Index für Flughafenkoordinaten 690 Seiten groß ist und dass der Index aus vier Ebenen besteht: Die Wurzel- und zwei interne Ebenen wurden in den obigen Abbildungen gezeigt, und die vierte Ebene ist Blatt. <br><br>  Tatsächlich wird der Index für achttausend Punkte deutlich kleiner sein: Hier wurde er aus Gründen der Übersichtlichkeit mit einem 10% -Füllfaktor erstellt. <br><br>  Zweitens können wir den Indexbaum ausgeben: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> gist_tree(<span class="hljs-string"><span class="hljs-string">'airports_coordinates_idx'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> gist_tree ----------------------------------------------------------------------------------------- 0(l:0) blk: 0 numTuple: 5 free: 7928b(2.84%) rightlink:4294967295 (InvalidBlockNumber) + 1(l:1) blk: 335 numTuple: 15 free: 7488b(8.24%) rightlink:220 (OK) + 1(l:2) blk: 128 numTuple: 9 free: 7752b(5.00%) rightlink:49 (OK) + 1(l:3) blk: 57 numTuple: 12 free: 7620b(6.62%) rightlink:35 (OK) + 2(l:3) blk: 62 numTuple: 9 free: 7752b(5.00%) rightlink:57 (OK) + 3(l:3) blk: 72 numTuple: 7 free: 7840b(3.92%) rightlink:23 (OK) + 4(l:3) blk: 115 numTuple: 17 free: 7400b(9.31%) rightlink:33 (OK) + ...</code> </pre><br>  Und drittens können wir die in Indexzeilen gespeicherten Daten ausgeben.  Beachten Sie die folgende Nuance: Das Ergebnis der Funktion muss in den gewünschten Datentyp umgewandelt werden.  In unserer Situation ist dieser Typ "Box" (ein Begrenzungsrechteck).  Beachten Sie beispielsweise fünf Zeilen auf der obersten Ebene: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">level</span></span>, a <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> gist_print(<span class="hljs-string"><span class="hljs-string">'airports_coordinates_idx'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> t(<span class="hljs-keyword"><span class="hljs-keyword">level</span></span> <span class="hljs-type"><span class="hljs-type">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">valid</span></span> <span class="hljs-type"><span class="hljs-type">bool</span></span>, a <span class="hljs-type"><span class="hljs-type">box</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">level</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><pre> <code class="plaintext hljs"> level | a -------+----------------------------------------------------------------------- 1 | (47.663586,80.803207),(-39.2938003540039,-90) 1 | (179.951004028,15.6700000762939),(15.2428998947144,-77.9634017944336) 1 | (177.740997314453,73.5178070068359),(15.0664,10.57970047) 1 | (-77.3191986083984,79.9946975708),(-179.876998901,-43.810001373291) 1 | (-39.864200592041,82.5177993774),(-81.254096984863,-64.2382965088) (5 rows)</code> </pre><br>  Tatsächlich wurden die oben angegebenen Zahlen nur aus diesen Daten erstellt. <br><br><h2>  Operatoren für die Suche und Bestellung </h2><br>  Bisher diskutierte Operatoren (wie <code>&lt;@</code> im Prädikat <code>p &lt;@ box '(2,1),(7,4)'</code> ) können als Suchoperatoren bezeichnet werden, da sie Suchbedingungen in einer Abfrage angeben. <br><br>  Es gibt auch einen anderen Operatortyp: Bestelloperatoren.  Sie werden für Spezifikationen der Sortierreihenfolge in der ORDER BY-Klausel anstelle herkömmlicher Spezifikationen für Spaltennamen verwendet.  Das Folgende ist ein Beispiel für eine solche Abfrage: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> points <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> p &lt;-&gt; <span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(4,7)'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><pre> <code class="plaintext hljs"> p ------- (5,5) (7,8) (2 rows)</code> </pre><br>  <code>p &lt;-&gt; point '(4,7)'</code> hier ein Ausdruck, der einen Ordnungsoperator <code>&lt;-&gt;</code> , der den Abstand von einem Argument zum anderen angibt.  Die Bedeutung der Abfrage besteht darin, zwei Punkte zurückzugeben, die dem Punkt am nächsten liegen (4.7).  Eine solche Suche wird als k-NN - k-Suche nach dem nächsten Nachbarn bezeichnet. <br><br>  Um Abfragen dieser Art zu unterstützen, muss eine Zugriffsmethode eine zusätzliche <em>Distanzfunktion</em> definieren, und der Bestelloperator muss in der entsprechenden Operatorklasse enthalten sein (z. B. "points_ops" -Klasse für Punkte).  Die folgende Abfrage zeigt Operatoren mit ihren Typen ("s" - Suche und "o" - Reihenfolge): <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> amop.amopopr::<span class="hljs-type"><span class="hljs-type">regoperator</span></span>, amop.amoppurpose, amop.amopstrategy <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_opclass opc, pg_opfamily opf, pg_am am, pg_amop amop <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> opc.opcname = <span class="hljs-string"><span class="hljs-string">'point_ops'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> opf.oid = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.oid = opf.opfmethod <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amopfamily = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.amname = <span class="hljs-string"><span class="hljs-string">'gist'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amoplefttype = opc.opcintype;</code> </pre><pre> <code class="plaintext hljs"> amopopr | amoppurpose | amopstrategy -------------------+-------------+-------------- &lt;&lt;(point,point) | s | 1 strictly left &gt;&gt;(point,point) | s | 5 strictly right ~=(point,point) | s | 6 coincides &lt;^(point,point) | s | 10 strictly below &gt;^(point,point) | s | 11 strictly above &lt;-&gt;(point,point) | o | 15 distance &lt;@(point,box) | s | 28 contained in rectangle &lt;@(point,polygon) | s | 48 contained in polygon &lt;@(point,circle) | s | 68 contained in circle (9 rows)</code> </pre><br>  Die Anzahl der Strategien wird ebenfalls angezeigt und ihre Bedeutung erklärt.  Es ist klar, dass es weit mehr Strategien als für "btree" gibt, von denen nur einige für Punkte unterstützt werden.  Für andere Datentypen können unterschiedliche Strategien definiert werden. <br><br>  Die Distanzfunktion wird für ein Indexelement aufgerufen und muss die Distanz (unter Berücksichtigung der Operatorsemantik) von dem durch den Ausdruck definierten Wert (" <em>indizierter Feldordnungsoperatorausdruck</em> ") zu dem angegebenen Element berechnen.  Bei einem Blattelement ist dies nur der Abstand zum indizierten Wert.  Für ein internes Element muss die Funktion das Minimum der Abstände zu den untergeordneten Blattelementen zurückgeben.  Da das Durchsuchen aller untergeordneten Zeilen ziemlich kostspielig wäre, kann die Funktion die Entfernung optimistisch unterschätzen, jedoch auf Kosten der Verringerung der Sucheffizienz.  Die Funktion darf jedoch niemals die Entfernung überschätzen, da dies die Arbeit des Index stört. <br><br>  Die Distanzfunktion kann Werte eines beliebigen sortierbaren Typs zurückgeben (um Werte zu ordnen, verwendet PostgreSQL die Vergleichssemantik aus der entsprechenden Operatorfamilie der Zugriffsmethode "btree", wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zuvor beschrieben</a> ). <br><br>  Für Punkte in einer Ebene wird der Abstand in einem sehr üblichen Sinne interpretiert: Der Wert von <code>(x1,y1) &lt;-&gt; (x2,y2)</code> entspricht der Quadratwurzel der Summe der Quadrate der Differenzen der Abszissen und Ordinaten.  Der Abstand von einem Punkt zu einem Begrenzungsrechteck wird als minimaler Abstand vom Punkt zu diesem Rechteck oder als Null angenommen, wenn der Punkt innerhalb des Rechtecks ​​liegt.  Es ist einfach, diesen Wert zu berechnen, ohne durch untergeordnete Punkte zu gehen, und der Wert ist mit Sicherheit nicht größer als der Abstand zu einem untergeordneten Punkt. <br><br>  Betrachten wir den Suchalgorithmus für die obige Abfrage. <br><br><img src="https://habrastorage.org/web/84b/56a/075/84b56a075dbd42d6b5d8cc8cb10c4b01.png"><br><br>  Die Suche beginnt mit dem Wurzelknoten.  Der Knoten enthält zwei Begrenzungsrechtecke.  Der Abstand zu (1,1) - (6,3) beträgt 4,0 und zu (5,5) - (8,8) beträgt 1,0. <br><br>  Untergeordnete Knoten werden in der Reihenfolge der Vergrößerung durchlaufen.  Auf diese Weise steigen wir zuerst zum nächsten untergeordneten Knoten ab und berechnen die Abstände zu den Punkten (wir zeigen die Zahlen in der Abbildung zur besseren Sichtbarkeit): <br><br><img src="https://habrastorage.org/web/491/959/f07/491959f070754781b794e0dff01d5aec.png"><br><br>  Diese Information reicht aus, um die ersten beiden Punkte (5,5) und (7,8) zurückzugeben.  Da wir uns bewusst sind, dass der Abstand zu Punkten, die innerhalb des Rechtecks ​​(1,1) - (6,3) liegen, 4,0 oder mehr beträgt, müssen wir nicht zum ersten untergeordneten Knoten absteigen. <br><br>  Aber was wäre, wenn wir die ersten <em>drei</em> Punkte finden müssten? <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> points <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> p &lt;-&gt; <span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(4,7)'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>;</code> </pre><pre> <code class="pgsql hljs"> p <span class="hljs-comment"><span class="hljs-comment">------- (5,5) (7,8) (8,6) (3 rows)</span></span></code> </pre><br>  Obwohl der zweite untergeordnete Knoten alle diese Punkte enthält, können wir nicht zurückkehren (8,6), ohne in den ersten untergeordneten Knoten zu schauen, da dieser Knoten nähere Punkte enthalten kann (da 4.0 &lt;4.1). <br><br><img src="https://habrastorage.org/web/9bb/43a/775/9bb43a775fc445769e37af8bb50daae0.png"><br><br>  In diesem Beispiel werden für interne Zeilen die Anforderungen für die Abstandsfunktion erläutert.  Durch Auswahl eines kleineren Abstands (4,0 anstelle des tatsächlichen Abstands 4,5) für die zweite Zeile haben wir die Effizienz verringert (der Algorithmus hat unnötigerweise begonnen, einen zusätzlichen Knoten zu untersuchen), aber die Korrektheit des Algorithmus nicht beeinträchtigt. <br><br>  Bis vor kurzem war GiST die einzige Zugriffsmethode, die mit bestellenden Betreibern umgehen konnte.  Die Situation hat sich jedoch geändert: Die RUM-Zugriffsmethode (wird weiter diskutiert) hat sich bereits dieser Gruppe von Methoden angeschlossen, und es ist nicht unwahrscheinlich, dass sich ein guter alter B-Baum ihnen anschließt: Ein Patch, der von Nikita Glukhov, unserem Kollegen, entwickelt wurde, wird gerade erstellt von der Community diskutiert. <br><blockquote>  Ab März 2019 wird k-NN-Unterstützung für SP-GiST im kommenden PostgreSQL 12 (ebenfalls von Nikita verfasst) hinzugefügt.  Patch für B-Tree ist noch in Bearbeitung. <br></blockquote><br><h2>  R-Baum für Intervalle </h2><br>  Ein weiteres Beispiel für die Verwendung der GiST-Zugriffsmethode ist die Indizierung von Intervallen, z. B. Zeitintervallen (Typ "tsrange").  Der Unterschied besteht darin, dass interne Knoten Begrenzungsintervalle anstelle von Begrenzungsrechtecken enthalten. <br><br>  Betrachten wir ein einfaches Beispiel.  Wir werden ein Ferienhaus vermieten und Reservierungsintervalle in einer Tabelle speichern: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> reservations(during <span class="hljs-type"><span class="hljs-type">tsrange</span></span>); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> reservations(during) <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-string"><span class="hljs-string">'[2016-12-30, 2017-01-09)'</span></span>), (<span class="hljs-string"><span class="hljs-string">'[2017-02-23, 2017-02-27)'</span></span>), (<span class="hljs-string"><span class="hljs-string">'[2017-04-29, 2017-05-02)'</span></span>); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> reservations <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gist(during);</code> </pre><br>  Der Index kann verwendet werden, um beispielsweise die folgende Abfrage zu beschleunigen: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> reservations <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> during &amp;&amp; <span class="hljs-string"><span class="hljs-string">'[2017-01-01, 2017-04-01)'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> during ----------------------------------------------- ["2016-12-30 00:00:00","2017-01-08 00:00:00") ["2017-02-23 00:00:00","2017-02-26 00:00:00") (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> reservations <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> during &amp;&amp; <span class="hljs-string"><span class="hljs-string">'[2017-01-01, 2017-04-01)'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------------------------------------------------------------------ Index Only Scan using reservations_during_idx on reservations Index Cond: (during &amp;&amp; '["2017-01-01 00:00:00","2017-04-01 00:00:00")'::tsrange) (2 rows)</code> </pre><br>  <code>&amp;&amp;</code> Operator für Intervalle bezeichnet Schnittpunkt;  Daher muss die Abfrage alle Intervalle zurückgeben, die sich mit dem angegebenen Intervall überschneiden.  Für einen solchen Operator bestimmt die Konsistenzfunktion, ob sich das angegebene Intervall mit einem Wert in einer internen oder einer Blattzeile überschneidet. <br><br>  Beachten Sie, dass es entweder nicht darum geht, Intervalle in einer bestimmten Reihenfolge abzurufen, obwohl Vergleichsoperatoren für Intervalle definiert sind.  Wir können den "btree" -Index für Intervalle verwenden, aber in diesem Fall müssen wir auf die Unterstützung solcher Operationen verzichten: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> amop.amopopr::<span class="hljs-type"><span class="hljs-type">regoperator</span></span>, amop.amoppurpose, amop.amopstrategy <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_opclass opc, pg_opfamily opf, pg_am am, pg_amop amop <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> opc.opcname = <span class="hljs-string"><span class="hljs-string">'range_ops'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> opf.oid = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.oid = opf.opfmethod <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amopfamily = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.amname = <span class="hljs-string"><span class="hljs-string">'gist'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amoplefttype = opc.opcintype;</code> </pre><pre> <code class="plaintext hljs"> amopopr | amoppurpose | amopstrategy -------------------------+-------------+-------------- @&gt;(anyrange,anyelement) | s | 16 contains element &lt;&lt;(anyrange,anyrange) | s | 1 strictly left &amp;&lt;(anyrange,anyrange) | s | 2 not beyond right boundary &amp;&amp;(anyrange,anyrange) | s | 3 intersects &amp;&gt;(anyrange,anyrange) | s | 4 not beyond left boundary &gt;&gt;(anyrange,anyrange) | s | 5 strictly right -|-(anyrange,anyrange) | s | 6 adjacent @&gt;(anyrange,anyrange) | s | 7 contains interval &lt;@(anyrange,anyrange) | s | 8 contained in interval =(anyrange,anyrange) | s | 18 equals (10 rows)</code> </pre><br>  (Mit Ausnahme der Gleichheit, die in der Operatorklasse für die Zugriffsmethode "btree" enthalten ist.) <br><br><h3>  Interna </h3><br>  Wir können mit der gleichen "Gevel" -Erweiterung nach innen schauen.  Wir müssen nur daran denken, den Datentyp im Aufruf von gist_print zu ändern: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">level</span></span>, a <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> gist_print(<span class="hljs-string"><span class="hljs-string">'reservations_during_idx'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> t(<span class="hljs-keyword"><span class="hljs-keyword">level</span></span> <span class="hljs-type"><span class="hljs-type">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">valid</span></span> <span class="hljs-type"><span class="hljs-type">bool</span></span>, a <span class="hljs-type"><span class="hljs-type">tsrange</span></span>);</code> </pre><pre> <code class="plaintext hljs"> level | a -------+----------------------------------------------- 1 | ["2016-12-30 00:00:00","2017-01-09 00:00:00") 1 | ["2017-02-23 00:00:00","2017-02-27 00:00:00") 1 | ["2017-04-29 00:00:00","2017-05-02 00:00:00") (3 rows)</code> </pre><br><h2>  Ausschlussbeschränkung </h2><br>  Der GiST-Index kann zur Unterstützung von Ausschlussbeschränkungen (EXCLUDE) verwendet werden. <br><br>  Die Ausschlussbeschränkung stellt sicher, dass bestimmte Felder von zwei beliebigen Tabellenzeilen in Bezug auf einige Operatoren nicht miteinander "korrespondieren".  Wenn der Operator "gleich" gewählt wird, erhalten wir genau die eindeutige Einschränkung: Die angegebenen Felder von zwei beliebigen Zeilen sind nicht gleich. <br><br>  Die Ausschlussbeschränkung wird vom Index sowie von der eindeutigen Einschränkung unterstützt.  Wir können jeden Operator so auswählen, dass: <br><br><ol><li>  Es wird von der Indexmethode "can_exclude" unterstützt (z. B. "btree", GiST oder SP-GiST, jedoch nicht GIN). </li><li>  Es ist kommutativ, dh die Bedingung ist erfüllt: a Operator b = b Operator a. </li></ol><br>  Dies ist eine Liste geeigneter Strategien und Beispiele für Operatoren (Operatoren können, wie wir uns erinnern, unterschiedliche Namen haben und nicht für alle Datentypen verfügbar sein): <br><br><ul><li>  Für "btree": <br><ul><li>  "Gleich" <code>=</code> </li></ul></li><li>  Für GiST und SP-GiST: <br><ul><li>  "Kreuzung" <code>&amp;&amp;</code> </li><li>  "Zufall" <code>~=</code> </li><li>  Nachbarschaft <code>-|-</code> </li></ul></li></ul><br>  Beachten Sie, dass wir den Gleichheitsoperator in einer Ausschlussbedingung verwenden können, dies jedoch unpraktisch ist: Eine eindeutige Einschränkung ist effizienter.  Genau deshalb haben wir bei der Erörterung von B-Bäumen keine Ausschlussbeschränkungen angesprochen. <br><br>  Lassen Sie uns ein Beispiel für die Verwendung einer Ausschlussbeschränkung geben.  Es ist vernünftig, keine Reservierungen für sich überschneidende Intervalle zuzulassen. <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> reservations <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> <span class="hljs-keyword"><span class="hljs-keyword">exclude</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gist(during <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> &amp;&amp;);</code> </pre><br>  Sobald wir die Ausschlussbeschränkung erstellt haben, können wir Zeilen hinzufügen: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> reservations(during) <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-string"><span class="hljs-string">'[2017-06-10, 2017-06-13)'</span></span>);</code> </pre><br>  Der Versuch, ein Schnittintervall in die Tabelle einzufügen, führt jedoch zu einem Fehler: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> reservations(during) <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-string"><span class="hljs-string">'[2017-05-15, 2017-06-15)'</span></span>);</code> </pre><pre> <code class="plaintext hljs">ERROR: conflicting key value violates exclusion constraint "reservations_during_excl" DETAIL: Key (during)=(["2017-05-15 00:00:00","2017-06-15 00:00:00")) conflicts with existing key (during)=(["2017-06-10 00:00:00","2017-06-13 00:00:00")).</code> </pre><br><h3>  Erweiterung "Btree_gist" </h3><br>  Lassen Sie uns das Problem komplizieren.  Wir erweitern unser bescheidenes Geschäft und werden mehrere Cottages vermieten: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> reservations <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> house_no <span class="hljs-type"><span class="hljs-type">integer</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br>  Wir müssen die Ausschlussbeschränkung ändern, damit die Hausnummern berücksichtigt werden.  GiST unterstützt jedoch nicht die Gleichheitsoperation für Ganzzahlen: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> reservations <span class="hljs-keyword"><span class="hljs-keyword">drop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constraint</span></span> reservations_during_excl; postgres=# <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> reservations <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> <span class="hljs-keyword"><span class="hljs-keyword">exclude</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gist(during <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> &amp;&amp;, house_no <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> =);</code> </pre><pre> <code class="plaintext hljs">ERROR: data type integer has no default operator class for access method "gist" HINT: You must specify an operator class for the index or define a default operator class for the data type.</code> </pre><br>  In diesem Fall <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hilft die</a> Erweiterung " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">btree_gist</a> ", die die GiST-Unterstützung für Operationen hinzufügt, die B-Bäumen eigen sind.  GiST kann schließlich alle Operatoren unterstützen. Warum sollten wir es nicht lehren, "größere", "kleinere" und "gleiche" Operatoren zu unterstützen? <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extension</span></span> btree_gist; postgres=# <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> reservations <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> <span class="hljs-keyword"><span class="hljs-keyword">exclude</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gist(during <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> &amp;&amp;, house_no <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> =);</code> </pre><br>  Jetzt können wir das erste Cottage noch nicht für die gleichen Daten reservieren: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> reservations(during, house_no) <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-string"><span class="hljs-string">'[2017-05-15, 2017-06-15)'</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><pre> <code class="plaintext hljs">ERROR: conflicting key value violates exclusion constraint "reservations_during_house_no_excl"</code> </pre><br>  Wir können jedoch den zweiten reservieren: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> reservations(during, house_no) <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-string"><span class="hljs-string">'[2017-05-15, 2017-06-15)'</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre><br>  Beachten Sie jedoch, dass GiST die Operatoren "größer", "kleiner" und "gleich" zwar irgendwie unterstützen kann, B-tree dies jedoch immer noch besser kann.  Daher lohnt es sich, diese Technik nur zu verwenden, wenn der GiST-Index im Wesentlichen benötigt wird, wie in unserem Beispiel. <br><br><h2>  RD-Baum für die Volltextsuche </h2><br><h3>  Über die Volltextsuche </h3><br>  Beginnen wir mit einer minimalistischen Einführung in die PostgreSQL-Volltextsuche (wenn Sie sich auskennen, können Sie diesen Abschnitt überspringen). <br><br>  Die Aufgabe der Volltextsuche besteht darin, aus dem <em>Dokumentensatz</em> diejenigen Dokumente auszuwählen, die der Suchabfrage entsprechen.  (Wenn es viele übereinstimmende Dokumente gibt, ist es wichtig, <em>die besten</em> übereinstimmenden Dokumente zu finden, aber wir werden an dieser Stelle nichts dazu sagen.) <br><br>  Zu Suchzwecken wird ein Dokument in einen speziellen Typ "tsvector" konvertiert, der <em>Lexeme</em> und ihre Positionen im Dokument enthält.  Lexeme sind Wörter, die in die für die Suche geeignete Form konvertiert wurden.  Beispielsweise werden Wörter normalerweise in Kleinbuchstaben umgewandelt und variable Endungen abgeschnitten: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> to_tsvector(<span class="hljs-string"><span class="hljs-string">'There was a crooked man, and he walked a crooked mile'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> to_tsvector ----------------------------------------- 'crook':4,10 'man':5 'mile':11 'walk':8 (1 row)</code> </pre><br>  Wir können auch sehen, dass einige Wörter ( <em>Stoppwörter genannt</em> ) vollständig gelöscht werden ("dort", "war", "a", "und", er "), da sie vermutlich zu oft vorkommen, als dass eine Suche nach ihnen sinnvoll wäre.  All diese Konvertierungen können sicherlich konfiguriert werden, aber das ist eine andere Geschichte. <br><br>  Eine Suchabfrage wird mit einem anderen Typ dargestellt: "tsquery".  Eine Abfrage besteht ungefähr aus einem oder mehreren Lexemen, die durch Konnektive verbunden sind: "und" &amp; "oder" |, "nicht"! .. Wir können auch Klammern verwenden, um die Priorität der Operation zu klären. <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> to_tsquery(<span class="hljs-string"><span class="hljs-string">'man &amp; (walking | running)'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> to_tsquery ---------------------------- 'man' &amp; ( 'walk' | 'run' ) (1 row)</code> </pre><br>  Für die <code>@@</code> wird nur ein Übereinstimmungsoperator <code>@@</code> verwendet. <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> to_tsvector(<span class="hljs-string"><span class="hljs-string">'There was a crooked man, and he walked a crooked mile'</span></span>) @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'man &amp; (walking | running)'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ?column? ---------- t (1 row)</code> </pre><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> to_tsvector(<span class="hljs-string"><span class="hljs-string">'There was a crooked man, and he walked a crooked mile'</span></span>) @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'man &amp; (going | running)'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ?column? ---------- f (1 row)</code> </pre><br>  Diese Information reicht vorerst aus.  In einem nächsten Artikel mit GIN-Index werden wir uns etwas eingehender mit der Volltextsuche befassen. <br><br><h3>  RD-Bäume </h3><br>  Für eine schnelle Volltextsuche muss zum einen in der Tabelle eine Spalte vom Typ "tsvector" gespeichert werden (um zu vermeiden, dass bei der Suche jedes Mal eine kostspielige Konvertierung durchgeführt wird), und zum anderen muss ein Index für diese Spalte erstellt werden.  Eine der möglichen Zugriffsmethoden hierfür ist GiST. <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> ts(doc <span class="hljs-type"><span class="hljs-type">text</span></span>, doc_tsv <span class="hljs-type"><span class="hljs-type">tsvector</span></span>); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> ts <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gist(doc_tsv); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> ts(doc) <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-string"><span class="hljs-string">'Can a sheet slitter slit sheets?'</span></span>), (<span class="hljs-string"><span class="hljs-string">'How many sheets could a sheet slitter slit?'</span></span>), (<span class="hljs-string"><span class="hljs-string">'I slit a sheet, a sheet I slit.'</span></span>), (<span class="hljs-string"><span class="hljs-string">'Upon a slitted sheet I sit.'</span></span>), (<span class="hljs-string"><span class="hljs-string">'Whoever slit the sheets is a good sheet slitter.'</span></span>), (<span class="hljs-string"><span class="hljs-string">'I am a sheet slitter.'</span></span>), (<span class="hljs-string"><span class="hljs-string">'I slit sheets.'</span></span>), (<span class="hljs-string"><span class="hljs-string">'I am the sleekest sheet slitter that ever slit sheets.'</span></span>), (<span class="hljs-string"><span class="hljs-string">'She slits the sheet she sits on.'</span></span>); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> ts <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> doc_tsv = to_tsvector(doc);</code> </pre><br>  Es ist sicherlich zweckmäßig, einen Auslöser mit dem letzten Schritt zu beauftragen (Konvertierung des Dokuments in "tsvector"). <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ts;</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]---------------------------------------------------- doc | Can a sheet slitter slit sheets? doc_tsv | 'sheet':3,6 'slit':5 'slitter':4 -[ RECORD 2 ]---------------------------------------------------- doc | How many sheets could a sheet slitter slit? doc_tsv | 'could':4 'mani':2 'sheet':3,6 'slit':8 'slitter':7 -[ RECORD 3 ]---------------------------------------------------- doc | I slit a sheet, a sheet I slit. doc_tsv | 'sheet':4,6 'slit':2,8 -[ RECORD 4 ]---------------------------------------------------- doc | Upon a slitted sheet I sit. doc_tsv | 'sheet':4 'sit':6 'slit':3 'upon':1 -[ RECORD 5 ]---------------------------------------------------- doc | Whoever slit the sheets is a good sheet slitter. doc_tsv | 'good':7 'sheet':4,8 'slit':2 'slitter':9 'whoever':1 -[ RECORD 6 ]---------------------------------------------------- doc | I am a sheet slitter. doc_tsv | 'sheet':4 'slitter':5 -[ RECORD 7 ]---------------------------------------------------- doc | I slit sheets. doc_tsv | 'sheet':3 'slit':2 -[ RECORD 8 ]---------------------------------------------------- doc | I am the sleekest sheet slitter that ever slit sheets. doc_tsv | 'ever':8 'sheet':5,10 'sleekest':4 'slit':9 'slitter':6 -[ RECORD 9 ]---------------------------------------------------- doc | She slits the sheet she sits on. doc_tsv | 'sheet':4 'sit':6 'slit':2</code> </pre><br>  Wie soll der Index aufgebaut sein?  Die direkte Verwendung des R-Baums ist keine Option, da unklar ist, wie ein "Begrenzungsrechteck" für Dokumente definiert werden soll.  Wir können diesen Ansatz jedoch für Mengen modifizieren, einen sogenannten RD-Baum (RD steht für "Russian Doll").  Unter einer Menge wird in diesem Fall eine Menge von Lexemen verstanden, aber im Allgemeinen kann eine Menge eine beliebige sein. <br><br>  Eine Idee von RD-Bäumen besteht darin, ein Begrenzungsrechteck durch eine Begrenzungsmenge zu ersetzen, dh eine Menge, die alle Elemente von untergeordneten Mengen enthält. <br><br>  Es stellt sich eine wichtige Frage, wie Mengen in Indexzeilen dargestellt werden sollen.  Am einfachsten ist es, alle Elemente der Menge aufzulisten.  Dies könnte wie folgt aussehen: <br><br><img src="https://habrastorage.org/webt/cp/ul/cx/cpulcxgydwxo8fl0ul0bdlsn3ws.png"><br><br>  Für den Zugriff über die Bedingung <code>doc_tsv @@ to_tsquery('sit')</code> könnten wir dann beispielsweise nur zu den Knoten absteigen, die das "sit" <code>doc_tsv @@ to_tsquery('sit')</code> enthalten: <br><br><img src="https://habrastorage.org/webt/h9/2g/4j/h92g4jpzw_7wj-x3katxlwrw3ac.png"><br><br>  Diese Darstellung hat offensichtliche Probleme.  Die Anzahl der Lexeme in einem Dokument kann sehr groß sein, sodass Indexzeilen eine große Größe haben und in TOAST gelangen, wodurch der Index weitaus weniger effizient wird.  Selbst wenn jedes Dokument nur wenige eindeutige Lexeme enthält, kann die Vereinigung von Mengen dennoch sehr groß sein: Je höher der Stamm, desto größer die Indexzeilen. <br><br>  Eine Darstellung wie diese wird manchmal verwendet, jedoch für andere Datentypen.  Bei der Volltextsuche wird eine andere, kompaktere Lösung verwendet - ein sogenannter <em>Signaturbaum</em> .  Die Idee ist allen bekannt, die sich mit Bloom-Filtern befasst haben. <br><br>  Jedes Lexem kann mit seiner <em>Signatur dargestellt werden</em> : eine Bitfolge einer bestimmten Länge, bei der alle Bits bis auf eins Null sind.  Die Position dieses Bits wird durch den Wert der Hash-Funktion des Lexems bestimmt (wir haben die Interna von Hash-Funktionen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">früher</a> besprochen). <br><br>  Die Dokumentensignatur ist das bitweise ODER der Signaturen aller Dokumentlexeme. <br><br>  Nehmen wir die folgenden Signaturen von Lexemen an: <br><br><pre> könnte 1.000.000
 jemals 0001000
 gut 0000010
 mani 0000100
 Blatt 0000100
 schlankste 0100000
 sitzen 0010000
 Schlitz 0001000
 Slitter 0000001
 auf 0000010
 wer auch immer 0010000
</pre><br>  Dann sind die Unterschriften der Dokumente wie folgt: <br><br><pre> Kann ein Blechschneider Blätter schneiden?  0001101
 Wie viele Blätter könnte ein Blattschneider schneiden?  1001101
 Ich schneide ein Blatt, ein Blatt, das ich schneide.  0001100
 Auf einem geschlitzten Laken sitze ich.  0011110
 Wer die Blätter schneidet, ist ein guter Blattschneider.  0011111
 Ich bin ein Blechschneider.  0000101
 Ich schneide Laken.  0001100
 Ich bin der glatteste Blattschneider, der jemals Blätter geschnitten hat.  0101101
 Sie schneidet das Blatt, auf dem sie sitzt.  0011100
</pre><br>  Der Indexbaum kann wie folgt dargestellt werden: <br><br><img src="https://habrastorage.org/webt/ou/f9/gz/ouf9gz7l7wgmgmgzi5gik7nrg50.png"><br><br>  Die Vorteile dieses Ansatzes liegen auf der Hand: Indexzeilen sind gleich klein, und ein solcher Index ist kompakt.  Ein Nachteil ist aber auch klar: Die Genauigkeit wird der Kompaktheit geopfert. <br><br>  Betrachten wir die gleiche Bedingung <code>doc_tsv @@ to_tsquery('sit')</code> .  Und berechnen wir die Signatur der Suchabfrage auf die gleiche Weise wie für das Dokument: 0010000 in diesem Fall.  Die Konsistenzfunktion muss alle untergeordneten Knoten zurückgeben, deren Signaturen mindestens ein Bit aus der Abfragesignatur enthalten: <br><br><img src="https://habrastorage.org/webt/qi/qm/l4/qiqml4l5yu8_qiyvidk-3j8iqhs.png"><br><br>  Vergleichen Sie mit der obigen Abbildung: Wir können sehen, dass der Baum gelb geworden ist, was bedeutet, dass während der Suche falsch positive Ergebnisse auftreten und übermäßige Knoten durchlaufen werden.  Hier haben wir das "whoever" -Lexem aufgenommen, dessen Signatur leider mit der Signatur des "sit" -Lexems übereinstimmt.  Es ist wichtig, dass im Muster keine falschen Negative auftreten können. Das heißt, wir werden die benötigten Werte sicher nicht verpassen. <br><br>  Außerdem kann es vorkommen, dass verschiedene Dokumente auch die gleichen Signaturen erhalten: In unserem Beispiel sind unglückliche Dokumente "Ich schneide ein Blatt, ein Blatt, das ich schneide" und "Ich schneide Blätter" (beide haben die Signatur 0001100).  Und wenn eine Blattindexzeile nicht den Wert von "tsvector" speichert, gibt der Index selbst falsch positive Ergebnisse aus.  In diesem Fall fordert die Methode die Indizierungs-Engine natürlich auf, das Ergebnis mit der Tabelle erneut zu überprüfen, damit der Benutzer diese Fehlalarme nicht sieht.  Die Sucheffizienz kann jedoch beeinträchtigt werden. <br><br>  Tatsächlich ist eine Signatur in der aktuellen Implementierung 124 Byte groß, in den Abbildungen 7 Bit, sodass die oben genannten Probleme viel seltener auftreten als im Beispiel.  In Wirklichkeit werden aber auch viel mehr Dokumente indiziert.  Um die Anzahl der Fehlalarme der Indexmethode irgendwie zu verringern, wird die Implementierung etwas schwierig: Der indizierte "tsvector" wird in einer Blattindexzeile gespeichert, jedoch nur, wenn seine Größe nicht groß ist (etwas weniger als 1/16 von eine Seite, die für 8-KB-Seiten etwa ein halbes Kilobyte entspricht). <br><br><h3>  Beispiel </h3><br>  Um zu sehen, wie die Indizierung für tatsächliche Daten funktioniert, nehmen wir das Archiv der E-Mails "pgsql-hackers".  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die im Beispiel verwendete Version</a> enthält 356125 Nachrichten mit dem Versanddatum, dem Betreff, dem Autor und dem Text: <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> sent <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]------------------------------------------------------------------------ id | 1572389 parent_id | 1562808 sent | 1997-06-24 11:31:09 subject | Re: [HACKERS] Array bug is still there.... author | "Thomas G. Lockhart" &lt;Thomas.Lockhart@jpl.nasa.gov&gt; body_plain | Andrew Martin wrote: + | &gt; Just run the regression tests on 6.1 and as I suspected the array bug + | &gt; is still there. The regression test passes because the expected output+ | &gt; has been fixed to the *wrong* output. + | + | OK, I think I understand the current array behavior, which is apparently+ | different than the behavior for v1.0x. + ...</code> </pre><br>  Hinzufügen und Ausfüllen der Spalte vom Typ "tsvector" und Erstellen des Index.  Hier werden drei Werte in einem Vektor (Betreff, Autor und Nachrichtentext) zusammengefasst, um zu zeigen, dass das Dokument kein Feld sein muss, sondern aus völlig unterschiedlichen beliebigen Teilen bestehen kann. <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> <span class="hljs-keyword"><span class="hljs-keyword">column</span></span> tsv <span class="hljs-type"><span class="hljs-type">tsvector</span></span>; fts=# <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> tsv = to_tsvector(subject||<span class="hljs-string"><span class="hljs-string">' '</span></span>||author||<span class="hljs-string"><span class="hljs-string">' '</span></span>||body_plain);</code> </pre><pre> <code class="plaintext hljs">NOTICE: word is too long to be indexed DETAIL: Words longer than 2047 characters are ignored. ... UPDATE 356125</code> </pre><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gist(tsv);</code> </pre><br>  Wie wir sehen können, wurde eine bestimmte Anzahl von Wörtern wegen zu großer Größe gelöscht.  Der Index wird jedoch schließlich erstellt und kann Suchanfragen unterstützen: <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'magic &amp; value'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ---------------------------------------------------------- Index Scan using mail_messages_tsv_idx on mail_messages (actual time=0.998..416.335 rows=898 loops=1) Index Cond: (tsv @@ to_tsquery('magic &amp; value'::text)) Rows Removed by Index Recheck: 7859 Planning time: 0.203 ms Execution time: 416.492 ms (5 rows)</code> </pre><br>  Wir können sehen, dass die Zugriffsmethode zusammen mit 898 Zeilen, die der Bedingung entsprechen, 7859 weitere Zeilen zurückgab, die durch erneutes Überprüfen mit der Tabelle herausgefiltert wurden.  Dies zeigt einen negativen Einfluss des Genauigkeitsverlustes auf die Effizienz. <br><br><h3>  Interna </h3><br>  Um den Inhalt des Index zu analysieren, verwenden wir erneut die Erweiterung "gevel": <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">level</span></span>, a <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> gist_print(<span class="hljs-string"><span class="hljs-string">'mail_messages_tsv_idx'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> t(<span class="hljs-keyword"><span class="hljs-keyword">level</span></span> <span class="hljs-type"><span class="hljs-type">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">valid</span></span> <span class="hljs-type"><span class="hljs-type">bool</span></span>, a gtsvector) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>;</code> </pre><pre> <code class="plaintext hljs"> level | a -------+------------------------------- 1 | 992 true bits, 0 false bits 2 | 988 true bits, 4 false bits 3 | 573 true bits, 419 false bits 4 | 65 unique words 4 | 107 unique words 4 | 64 unique words 4 | 42 unique words ...</code> </pre><br>  Werte des speziellen Typs "gtsvector", die in Indexzeilen gespeichert sind, sind tatsächlich die Signatur und möglicherweise die Quelle "tsvector".  Wenn der Vektor verfügbar ist, enthält die Ausgabe die Anzahl der Lexeme (eindeutige Wörter), andernfalls die Anzahl der wahren und falschen Bits in der Signatur. <br><br>  Es ist klar, dass im Wurzelknoten die Signatur zu "allen" degeneriert ist, dh eine Indexebene wurde absolut nutzlos (und eine weitere wurde mit nur vier falschen Bits fast nutzlos). <br><br><h2>  Eigenschaften </h2><br>  Schauen wir uns die Eigenschaften der GiST-Zugriffsmethode an (Abfragen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wurden früher bereitgestellt</a> ): <br><br><pre> <code class="plaintext hljs"> amname | name | pg_indexam_has_property --------+---------------+------------------------- gist | can_order | f gist | can_unique | f gist | can_multi_col | t gist | can_exclude | t</code> </pre><br>  Das Sortieren von Werten und eindeutige Einschränkungen werden nicht unterstützt.  Wie wir gesehen haben, kann der Index auf mehreren Spalten aufgebaut und in Ausschlussbeschränkungen verwendet werden. <br><br>  Die folgenden Indexschicht-Eigenschaften sind verfügbar: <br><br><pre> <code class="plaintext hljs"> name | pg_index_has_property ---------------+----------------------- clusterable | t index_scan | t bitmap_scan | t backward_scan | f</code> </pre><br>  Und die interessantesten Eigenschaften sind die der Säulenschicht.  Einige der Eigenschaften sind unabhängig von Operatorklassen: <br><br><pre> <code class="plaintext hljs"> name | pg_index_column_has_property --------------------+------------------------------ asc | f desc | f nulls_first | f nulls_last | f orderable | f search_array | f search_nulls | t</code> </pre><br>  (Die Sortierung wird nicht unterstützt. Der Index kann nicht zum Durchsuchen eines Arrays verwendet werden. NULL-Werte werden unterstützt.) <br><br>  Die beiden verbleibenden Eigenschaften "distance_orderable" und "returnable" hängen jedoch von der verwendeten Operatorklasse ab.  Zum Beispiel erhalten wir für Punkte: <br><br><pre> <code class="plaintext hljs"> name | pg_index_column_has_property --------------------+------------------------------ distance_orderable | t returnable | t</code> </pre><br>  Die erste Eigenschaft gibt an, dass der Entfernungsoperator für die Suche nach nächsten Nachbarn verfügbar ist.  Und der zweite besagt, dass der Index nur für den Index-Scan verwendet werden kann.  Obwohl Blattindexzeilen Rechtecke anstelle von Punkten speichern, kann die Zugriffsmethode das zurückgeben, was benötigt wird. <br><br>  Die folgenden Eigenschaften gelten für Intervalle: <br><br><pre> <code class="plaintext hljs"> name | pg_index_column_has_property --------------------+------------------------------ distance_orderable | f returnable | t</code> </pre><br>  Für Intervalle ist die Distanzfunktion nicht definiert und daher ist die Suche nach nächsten Nachbarn nicht möglich. <br><br>  Und für die Volltextsuche erhalten wir: <br><br><pre> <code class="plaintext hljs"> name | pg_index_column_has_property --------------------+------------------------------ distance_orderable | f returnable | f</code> </pre><br>  Die Unterstützung des Nur-Index-Scans ist verloren gegangen, da Blattzeilen nur die Signatur ohne die Daten selbst enthalten können.  Dies ist jedoch ein geringfügiger Verlust, da sich ohnehin niemand für den Wert vom Typ "tsvector" interessiert: Dieser Wert wird zur Auswahl von Zeilen verwendet, während der Quelltext angezeigt werden muss, aber dennoch im Index fehlt. <br><br><h2>  Andere Datentypen </h2><br>  Abschließend werden einige weitere Typen erwähnt, die derzeit von der GiST-Zugriffsmethode unterstützt werden, zusätzlich zu den bereits diskutierten geometrischen Typen (am Beispiel von Punkten), Intervallen und Volltextsucharten. <br><br>  Bei Standardtypen ist dies der Typ " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">inet</a> " für IP-Adressen.  Der Rest wird durch Erweiterungen hinzugefügt: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">cube</a> bietet den Datentyp "cube" für mehrdimensionale Cubes.  Für diesen Typ wird ebenso wie für geometrische Typen in einer Ebene die GiST-Operatorklasse definiert: R-Baum, der die Suche nach nächsten Nachbarn unterstützt. <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">seg</a> bietet den Datentyp "seg" für Intervalle mit Grenzen, die mit einer bestimmten Genauigkeit angegeben wurden, und unterstützt den GiST-Index für diesen Datentyp (R-Tree). <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">intarray</a> erweitert die Funktionalität von Integer-Arrays und fügt ihnen GiST-Unterstützung hinzu.  Es sind zwei Operatorklassen implementiert: "gist__int_ops" (RD-Baum mit vollständiger Darstellung der Schlüssel in Indexzeilen) und "gist__bigint_ops" (Signatur-RD-Baum).  Die erste Klasse kann für kleine Arrays verwendet werden, die zweite für größere Arrays. <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ltree</a> fügt den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Datentyp</a> "ltree" für baumartige Strukturen und die GiST-Unterstützung für diesen Datentyp (RD-Baum) hinzu. <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">pg_trgm</a> fügt eine spezielle Operatorklasse "gist_trgm_ops" zur Verwendung von Trigrammen bei der Volltextsuche hinzu.  Dies ist jedoch zusammen mit dem GIN-Index weiter zu erörtern. <br></li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lesen Sie weiter</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de444742/">https://habr.com/ru/post/de444742/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de444728/index.html">Als ich ein Buch über die Moskauer Staatsuniversität oder 12 kritische Fehler schrieb und veröffentlichte</a></li>
<li><a href="../de444730/index.html">Warum serverlose Technologie eine Revolution im Produktmanagement ist</a></li>
<li><a href="../de444732/index.html">Leistungsoptimierung apache2</a></li>
<li><a href="../de444734/index.html">Habraseminar: echte Geschichten über Content Marketing</a></li>
<li><a href="../de444738/index.html">Pixelkunst: Vom Entwurf zum Spielobjekt</a></li>
<li><a href="../de444744/index.html">Senden von E-Mails mit PHP</a></li>
<li><a href="../de444746/index.html">Wir laden Sie zum MskDotNet Meetup # 34 in der Raiffeisenbank upd Broadcast ein</a></li>
<li><a href="../de444748/index.html">3 Schlüsselqualitäten eines erfolgreichen Produktmanagers: Yuri Golikov, VP of Engineering Wrike</a></li>
<li><a href="../de444752/index.html">Die Geschichte von SXSW: Wie alles begann</a></li>
<li><a href="../de444756/index.html">DARPA wird einen Raketen-Nuklearmotor entwickeln</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>