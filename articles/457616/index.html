<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😈 🥘 🎨 Mi "¡Guau, no lo sabía!" momentos con broma 📦 🌻 🛒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola a todos! El curso para desarrolladores de JavaScript comienza este jueves. En este sentido, decidimos compartir la traducción de otro material in...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mi "¡Guau, no lo sabía!" momentos con broma</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/457616/">  Hola a todos!  El curso para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">desarrolladores de JavaScript</a> comienza este jueves.  En este sentido, decidimos compartir la traducción de otro material interesante.  Que tengas una buena lectura. <br><br><img src="https://habrastorage.org/webt/nj/it/db/njitdbm66p75yhokzwoeudcnti8.png"><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Jest</a> siempre ha sido mi herramienta de prueba de unidad indispensable.  Es tan confiable que empiezo a pensar que siempre lo he infrautilizado.  Aunque las pruebas funcionaron, con el tiempo las refactoré aquí y allá, porque no sabía que Jest podía hacer eso.  Cada vez que se trata de un código nuevo cuando reviso la documentación de Jest. <a name="habracut"></a><br><br>  Por lo tanto, voy a compartir algunos de mis trucos favoritos de Jest que algunos de ustedes ya saben porque leyeron la documentación y no me gustaron (vergüenza), pero espero que esto ayude a aquellos que lo revisaron rápidamente ! <br><br>  Por cierto, uso Jest v24.8.0 como material de referencia, así que tenga cuidado, algunas cosas pueden no funcionar en la versión de Jest que está utilizando actualmente.  Además, los ejemplos no representan el código de prueba real, esto es solo una demostración. <br><br><h2>  # 1  .toBe vs .toEqual </h2><br>  Al principio, todas estas declaraciones me parecieron normales: <br><br><pre><code class="javascript hljs">expect(<span class="hljs-string"><span class="hljs-string">'foo'</span></span>).toEqual(<span class="hljs-string"><span class="hljs-string">'foo'</span></span>) expect(<span class="hljs-number"><span class="hljs-number">1</span></span>).toEqual(<span class="hljs-number"><span class="hljs-number">1</span></span>) expect([<span class="hljs-string"><span class="hljs-string">'foo'</span></span>]).toEqual([<span class="hljs-string"><span class="hljs-string">'foo'</span></span>])</code> </pre> <br>  Basado en el uso de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">chai</a> para declaraciones de igualdad (to.equal), esto es simplemente natural.  De hecho, Jest no se quejará, y estas declaraciones pasan como de costumbre. <br><br>  Sin embargo, Jest tiene .toBe y .toEqual.  El primero se usa para afirmar la igualdad usando <a href="">Object.is</a> , y el segundo es proporcionar una comparación profunda de objetos y matrices.  .toEqual tiene una alternativa al uso de <a href="">Object.is</a> si resulta que no necesita una comparación profunda, como afirmar igualdades para valores primitivos, lo que explica por qué el ejemplo anterior fue muy bueno. <br><br><pre> <code class="javascript hljs">expect(<span class="hljs-string"><span class="hljs-string">'foo'</span></span>).toBe(<span class="hljs-string"><span class="hljs-string">'foo'</span></span>) expect(<span class="hljs-number"><span class="hljs-number">1</span></span>).toBe(<span class="hljs-number"><span class="hljs-number">1</span></span>) expect([<span class="hljs-string"><span class="hljs-string">'foo'</span></span>]).toEqual([<span class="hljs-string"><span class="hljs-string">'foo'</span></span>])</code> </pre> <br>  De esa manera, puede omitir todos los <code>if-else</code> en <code>.toEqual</code> usando <code>.toBe</code> si ya sabe qué valores está probando. <br>  Un error común es que usará <code>.toBe</code> para afirmar la igualdad de valores primitivos. <br><br><pre> <code class="javascript hljs">expect([<span class="hljs-string"><span class="hljs-string">'foo'</span></span>]).toBe([<span class="hljs-string"><span class="hljs-string">'foo'</span></span>])</code> </pre> <br>  Si observa el <a href="">código fuente</a> cuando se bloquea .toBe, intentará determinar si realmente cometió este error <a href="">llamando a la función</a> que utiliza .toEqual.  Esto puede ser un cuello de botella al optimizar su prueba. <br><br>  Si está seguro de que está utilizando valores primitivos, su código puede reorganizarse como tal para fines de optimización: <br><br><pre> <code class="javascript hljs">expect(<span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.is(<span class="hljs-string"><span class="hljs-string">'foo'</span></span>, <span class="hljs-string"><span class="hljs-string">'foo'</span></span>)).toBe(<span class="hljs-literal"><span class="hljs-literal">true</span></span>)</code> </pre> <br>  Más detalles en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentación</a> . <br><br><h2>  # 2  Comparaciones más adecuadas. </h2><br>  Técnicamente, puede usar <code>.toBe</code> para validar cualquier valor.  Con Jest, puede usar específicamente ciertas herramientas de comparación para hacer que su prueba sea más legible (y en algunos casos más corta). <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// expect([1,2,3].length).toBe(3) // expect([1,2,3]).toHaveLength(3) const canBeUndefined = foo() // expect(typeof canBeUndefined !== 'undefined').toBe(true) // expect(typeof canBeUndefined).not.toBe('undefined') // expect(canBeUndefined).not.toBe(undefined) // expect(canBeUndefined).toBeDefined() class Foo { constructor(param) { this.param = param } // expect(new Foo('bar') instanceof Foo).toBe(true) // expect(new Foo('bar')).toBeInstanceOf(Foo)</span></span></code> </pre> <br>  Estos son solo algunos de los que seleccioné de la larga lista de compiladores de Jest en la documentación, puede ver el resto usted mismo. <br><br><h2>  # 3  Prueba de instantáneas en elementos sin una interfaz de usuario </h2><br>  Es posible que haya escuchado sobre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">las pruebas de instantáneas en Jest</a> , donde ayuda a rastrear los cambios en los elementos de su interfaz de usuario.  Pero las pruebas con instantáneas no se limitan a esto. <br><br>  Considere este ejemplo: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> allEmployees = getEmployees() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> happyEmployees = giveIncrementByPosition(allEmployees) expect(happyEmployees[<span class="hljs-number"><span class="hljs-number">0</span></span>].nextMonthPaycheck).toBe(<span class="hljs-number"><span class="hljs-number">1000</span></span>) expect(happyEmployees[<span class="hljs-number"><span class="hljs-number">1</span></span>].nextMonthPaycheck).toBe(<span class="hljs-number"><span class="hljs-number">5000</span></span>) expect(happyEmployees[<span class="hljs-number"><span class="hljs-number">2</span></span>].nextMonthPaycheck).toBe(<span class="hljs-number"><span class="hljs-number">4000</span></span>) <span class="hljs-comment"><span class="hljs-comment">// ...etc</span></span></code> </pre> <br>  Sería agotador si reclamara cada vez más empleados.  Además, si resulta que se necesitan más reclamos para cada empleado, multiplique el número de reclamos nuevos por el número de empleados y obtendrá una idea. <br>  Con la prueba de instantáneas, todo esto se puede hacer simplemente así: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> allEmployees = getEmployees() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> happyEmployees = giveIncrementByPosition(allEmployees) expect(happyEmployees).toMatchSnapshot()</code> </pre> <br>  Siempre que ocurran regresiones, sabría exactamente qué árbol en el nodo no coincide con la imagen. <br><br>  Pero la conveniencia tiene un precio: este método es más propenso a errores.  Existe la posibilidad de que no sepa que la imagen es realmente incorrecta, y al final la tomará de todos modos.  Por lo tanto, verifique su instantánea como si fuera su propio código de aprobación (porque lo es). <br><br>  Por supuesto, las pruebas no se limitan a las instantáneas.  Lea la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentación</a> completa. <br><br><h2>  # 4  describe.each y test.each </h2><br>  ¿Alguna vez has escrito una prueba que sea algo similar a esto? <br><br><pre> <code class="javascript hljs">describe(<span class="hljs-string"><span class="hljs-string">'When I am a supervisor'</span></span>, () =&gt; { test(<span class="hljs-string"><span class="hljs-string">'I should have a supervisor badge'</span></span>, () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> employee = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Employee({ <span class="hljs-attr"><span class="hljs-attr">level</span></span>: <span class="hljs-string"><span class="hljs-string">'supervisor'</span></span> }) expect(employee.badges).toContain(<span class="hljs-string"><span class="hljs-string">'badge-supervisor'</span></span>) }) test(<span class="hljs-string"><span class="hljs-string">'I should have a supervisor level'</span></span>, () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> employee = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Employee({ <span class="hljs-attr"><span class="hljs-attr">level</span></span>: <span class="hljs-string"><span class="hljs-string">'supervisor'</span></span> }) expect(employee.level).toBe(<span class="hljs-string"><span class="hljs-string">'supervisor'</span></span>) }) }) describe(<span class="hljs-string"><span class="hljs-string">'When I am a manager'</span></span>, () =&gt; { test(<span class="hljs-string"><span class="hljs-string">'I should have a manager badge'</span></span>, () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> employee = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Employee({ <span class="hljs-attr"><span class="hljs-attr">level</span></span>: <span class="hljs-string"><span class="hljs-string">'manager'</span></span> }) expect(employee.badges).toContain(<span class="hljs-string"><span class="hljs-string">'badge-manager'</span></span>) }) test(<span class="hljs-string"><span class="hljs-string">'I should have a manager level'</span></span>, () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> employee = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Employee({ <span class="hljs-attr"><span class="hljs-attr">level</span></span>: <span class="hljs-string"><span class="hljs-string">'manager'</span></span> }) expect(employee.level).toBe(<span class="hljs-string"><span class="hljs-string">'manager'</span></span>) }) })</code> </pre> <br>  Esto es monótono y rutinario, ¿verdad?  Imagina hacer esto con muchos casos. <br>  Con <code>description.each</code> y <code>test.each</code> puede comprimir el código de la siguiente manera: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> levels = [[<span class="hljs-string"><span class="hljs-string">'manager'</span></span>], [<span class="hljs-string"><span class="hljs-string">'supervisor'</span></span>]] <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> privileges = [[<span class="hljs-string"><span class="hljs-string">'badges'</span></span>, <span class="hljs-string"><span class="hljs-string">'toContain'</span></span>, <span class="hljs-string"><span class="hljs-string">'badge-'</span></span>], [<span class="hljs-string"><span class="hljs-string">'level'</span></span>, <span class="hljs-string"><span class="hljs-string">'toBe'</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>]] describe.each(levels)(<span class="hljs-string"><span class="hljs-string">'When I am a %s'</span></span>, (level) =&gt; { test.each(privileges)(<span class="hljs-string"><span class="hljs-string">`I should have a </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${level}</span></span></span><span class="hljs-string"> %s`</span></span>, (kind, assert, prefix) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> employee = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Employee({ level }) expect(employee[kind])[assert](<span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${prefix}</span></span></span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${level}</span></span></span><span class="hljs-string">`</span></span>) }) })</code> </pre> <br>  Sin embargo, todavía tengo que usar esto en mi propia prueba, ya que prefiero que mi prueba sea detallada, pero pensé que sería un truco interesante. <br><br>  Consulte la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentación</a> para obtener más detalles sobre los argumentos (spoiler: la sintaxis de la tabla es realmente genial). <br><br><h2>  # 5  Imitación única de funciones globales. </h2><br>  En algún momento, tendrá que probar algo que depende de las funciones globales en un caso de prueba en particular.  Por ejemplo, una función que recibe información sobre la fecha actual utilizando el objeto JavaScript de fecha, o una biblioteca que se basa en él.  La dificultad es que cuando se trata de la fecha actual, nunca se puede obtener la declaración correcta. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now() } expect(foo()).toBe(<span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now()) <span class="hljs-comment"><span class="hljs-comment">// This would throw occasionally: // expect(received).toBe(expected) // Object.is equality // // Expected: 1558881400838 // Received: 1558881400837</span></span></code> </pre> <br><br>  Al final, tendría que redefinir el objeto Fecha global para que sea coherente y manejable: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now() } <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-number"><span class="hljs-number">1234567890123</span></span> expect(foo()).toBe(<span class="hljs-number"><span class="hljs-number">1234567890123</span></span>) <span class="hljs-comment"><span class="hljs-comment">//</span></span></code> </pre> <br>  Sin embargo, esto se considera una mala práctica, ya que la redefinición se mantiene entre pruebas.  No lo notará si no hay otra prueba basada en Date.now, pero también se filtrará. <br><br><pre> <code class="javascript hljs">test(<span class="hljs-string"><span class="hljs-string">'First test'</span></span>, () =&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now() <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-number"><span class="hljs-number">1234567890123</span></span> expect(foo()).toBe(<span class="hljs-number"><span class="hljs-number">1234567890123</span></span>) <span class="hljs-comment"><span class="hljs-comment">// }) test('Second test', () =&gt; { function foo () { return Date.now() expect(foo()).not.toBe(1234567890123) // ??? })</span></span></code> </pre><br>  Solía ​​"romperlo" para que no goteara: <br><br><pre> <code class="javascript hljs">test(<span class="hljs-string"><span class="hljs-string">'First test'</span></span>, () =&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> oriDateNow = <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-number"><span class="hljs-number">1234567890123</span></span> expect(foo()).toBe(<span class="hljs-number"><span class="hljs-number">1234567890123</span></span>) <span class="hljs-comment"><span class="hljs-comment">// Date.now = oriDateNow }) test('Second test', () =&gt; { function foo () { return Date.now() expect(foo()).not.toBe(1234567890123) // as expected })</span></span></code> </pre> <br>  Sin embargo, hay una forma mucho mejor y menos hacker de hacer esto: <br><br><pre> <code class="javascript hljs">test(<span class="hljs-string"><span class="hljs-string">'First test'</span></span>, () =&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now() jest.spyOn(<span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>, <span class="hljs-string"><span class="hljs-string">'now'</span></span>).mockImplementationOnce(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-number"><span class="hljs-number">1234567890123</span></span>) expect(foo()).toBe(<span class="hljs-number"><span class="hljs-number">1234567890123</span></span>) <span class="hljs-comment"><span class="hljs-comment">// }) test('Second test', () =&gt; { function foo () { return Date.now() expect(foo()).not.toBe(1234567890123) // as expected })</span></span></code> </pre> <br>  Por lo tanto, <code>jest.spyOn</code> sigue al objeto global Date e imita la implementación de la función now para una sola llamada.  Esto a su vez dejará Date.now intacto para el resto de las pruebas. <br><br>  Definitivamente hay más información sobre los talones en Jest.  Consulte la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentación</a> completa para más detalles. <br><br>  Este artículo se está haciendo lo suficientemente largo, así que creo que eso es todo por ahora.  Esto afecta solo una pequeña parte de las capacidades de Jest, y solo destaco mis favoritos.  Si tiene otros datos interesantes, hágamelo saber. <br><br>  Además, si ha usado Jest con frecuencia, consulte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Majestic</a> , que es una GUI sin GUI para Jest, una muy buena alternativa a la salida de terminal aburrida.  No estoy seguro si el autor está en dev.to, pero no obstante respeto por esta persona. <br><br>  Como siempre, ¡gracias por su atención! <br><br>  Eso es todo.  Nos vemos en el curso. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/457616/">https://habr.com/ru/post/457616/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../457606/index.html">Alan Kay: ¿Qué se puede llamar lo más sorprendente que las computadoras hicieron posible?</a></li>
<li><a href="../457608/index.html">Cómo visualizar datos en una historia convincente</a></li>
<li><a href="../457610/index.html">Análisis de vulnerabilidades de Evil Parcel</a></li>
<li><a href="../457612/index.html">¿Cómo acelerar la descompresión de LZ4 en ClickHouse?</a></li>
<li><a href="../457614/index.html">Secretos de encontrar un trabajo en el extranjero de un cazatalentos en ejercicio</a></li>
<li><a href="../457618/index.html">Ser un desarrollador moderno de pila completa</a></li>
<li><a href="../457622/index.html">Medición del rendimiento de Qt</a></li>
<li><a href="../457624/index.html">Cómo rompimos la vieja choza y construimos un rascacielos en su lugar</a></li>
<li><a href="../457626/index.html">Revisión de los niveles de acceso del usuario utilizando Power BI utilizando el ejemplo de Bitrix CMS (BUS)</a></li>
<li><a href="../457628/index.html">Programa P2M efectivo y gestión de proyectos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>