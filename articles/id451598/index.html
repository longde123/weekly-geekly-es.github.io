<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✴️ 👩🏿‍🤝‍👨🏾 ☸️ Unit Fairy Magic Fairy: DSL dalam C # ✂️ 🎢 🕵🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Seberapa sering hal itu terjadi ketika Anda menulis tes unit kerja, Anda melihat kodenya, dan apakah itu ... buruk? Dan Anda berpikir seperti itu: "In...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Unit Fairy Magic Fairy: DSL dalam C #</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dodopizzadev/blog/451598/">  Seberapa sering hal itu terjadi ketika Anda menulis tes unit kerja, Anda melihat kodenya, dan apakah itu ... buruk?  Dan Anda berpikir seperti itu: "Ini ujian, mari kita biarkan seperti itu ...".  Tidak,% nama pengguna%, jadi jangan tinggalkan.  Pengujian adalah bagian penting dari sistem yang menyediakan dukungan kode, dan sangat penting bahwa bagian ini juga didukung.  Sayangnya, kami tidak memiliki banyak cara untuk memastikan hal ini (kami tidak akan menulis tes untuk tes), tetapi masih ada pasangan. <br><br><img src="https://habrastorage.org/webt/9_/cb/xb/9_cbxb0psq2mvlfwzkxf0uvpwru.png"><a name="habracut"></a><br>  Di sekolah pengembang Dodo DevSchool kami, kami menyoroti, antara lain, kriteria berikut untuk ujian yang baik: <br><br><ul><li>  reproduktifitas: menjalankan tes pada kode dan input yang sama selalu mengarah pada hasil yang sama; </li><li>  fokus: seharusnya hanya ada satu alasan untuk tes jatuh; </li><li>  dimengerti: baik, ini dia jelas.  :) </li></ul><br>  Bagaimana Anda menyukai tes seperti itu dalam hal kriteria ini? <br><br><pre><code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Fact</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AcceptOrder_Successful</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ingredient1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Ingredient(<span class="hljs-string"><span class="hljs-string">"Ingredient1"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ingredient2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Ingredient(<span class="hljs-string"><span class="hljs-string">"Ingredient2"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ingredient3 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Ingredient(<span class="hljs-string"><span class="hljs-string">"Ingredient3"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> order = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Order(DateTime.Now); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> product1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Product(<span class="hljs-string"><span class="hljs-string">"Pizza1"</span></span>); product1.AddIngredient(ingredient1); product1.AddIngredient(ingredient2); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> orderLine1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> OrderLine(product1, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">500</span></span>); order.AddLine(orderLine1); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> product2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Product(<span class="hljs-string"><span class="hljs-string">"Pizza2"</span></span>); product2.AddIngredient(ingredient1); product2.AddIngredient(ingredient3); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> orderLine2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> OrderLine(product2, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">650</span></span>); order.AddLine(orderLine2); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> orderRepositoryMock = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mock&lt;IOrderRepository&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ingredientsRepositoryMock = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mock&lt;IIngredientRepository&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> service = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PizzeriaService(orderRepositoryMock.Object, ingredientsRepositoryMock.Object); service.AcceptOrder(order); orderRepositoryMock.Verify(r =&gt; r.Add(order), Times.Once); ingredientsRepositoryMock.Verify(r =&gt; r.ReserveIngredients(order), Times.Once); }</code> </pre> <br>  Bagi saya - sangat buruk. <br><br>  Itu tidak bisa dipahami: misalnya, saya bahkan tidak bisa mengalokasikan blok Atur, Tindakan, dan Tegas. <br><br>  Tidak dapat diputar: Properti DateTime.Now digunakan.  Dan akhirnya, itu tidak fokus, karena  memiliki 2 alasan untuk musim gugur: panggilan ke metode dua repositori diperiksa. <br><br>  Selain itu, meskipun penamaan tes berada di luar cakupan artikel ini, saya masih memperhatikan namanya: dengan seperangkat sifat negatif, sulit untuk merumuskannya sehingga ketika melihat nama tes, orang luar segera mengerti mengapa tes ini umumnya dalam proyek. <br><blockquote>  Jika Anda tidak dapat memberi nama tes secara ringkas, maka ada yang salah dengan tes tersebut. </blockquote>  Karena tes ini tidak dapat dipahami, beri tahu Anda apa yang terjadi di dalamnya: <br><br><ol><li>  Bahan dibuat. </li><li>  Dari bahan, produk (pizza) dibuat. </li><li>  Pesanan dibuat dari produk. </li><li>  Layanan dibuat untuk repositori basah. </li><li>  Pesanan diteruskan ke metode layanan AcceptOrder. </li><li>  Telah diverifikasi bahwa metode Tambah dan Cadangan Bahan repositori masing-masing telah dipanggil. </li></ol><br>  Jadi bagaimana kita membuat tes ini lebih baik?  Anda perlu mencoba untuk meninggalkan dalam tes hanya apa yang benar-benar penting.  Dan untuk itu, orang pintar seperti Martin Fowler dan Rebecca Parsons datang dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">DSL (Domain Specific Language)</a> .  Di sini saya akan berbicara tentang pola DSL yang kami gunakan di Dodo untuk memastikan bahwa unit test kami lunak dan halus, dan pengembang merasa percaya diri setiap hari. <br><br>  Rencananya adalah ini: pertama kita akan membuat tes ini dapat dimengerti, kemudian kita akan bekerja pada kemampuan reproduksi dan berakhir dengan membuatnya fokus.  Kami melaju ... <br><br><h2>  Pembuangan bahan (objek domain yang ditentukan sebelumnya) </h2><br>  Mari kita mulai dengan blok pembuatan pesanan.  Memesan adalah salah satu entitas domain pusat.  Akan lebih keren jika kita bisa menggambarkan urutan sedemikian rupa sehingga bahkan orang yang tidak tahu cara menulis kode tetapi memahami logika domain dapat memahami jenis pesanan yang kita buat.  Untuk melakukan ini, pertama-tama, kita harus meninggalkan penggunaan abstrak "Ingredient1" dan "Pizza1" menggantikan mereka dengan bahan-bahan nyata, pizza dan objek domain lainnya. <br><br>  Kandidat pertama untuk optimasi adalah bahan.  Semuanya sederhana dengan mereka: mereka tidak memerlukan penyesuaian, hanya panggilan ke konstruktor.  Cukup membawa mereka ke dalam wadah terpisah dan menamainya sehingga jelas bagi para pakar domain: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Ingredients</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Ingredient Dough = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Ingredient(<span class="hljs-string"><span class="hljs-string">"Dough"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Ingredient Pepperoni = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Ingredient(<span class="hljs-string"><span class="hljs-string">"Pepperoni"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Ingredient Mozzarella = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Ingredient(<span class="hljs-string"><span class="hljs-string">"Mozzarella"</span></span>); }</code> </pre><br>  Alih-alih Ingredient1 yang benar-benar gila, Ingredient2 dan Ingredient3, kami mendapatkan Dough, Pepperoni dan Mozzarella. <br><blockquote>  Gunakan objek domain yang telah ditentukan sebelumnya untuk entitas domain yang umum digunakan. </blockquote><br><h2>  Builder untuk produk </h2><br>  Entitas domain berikutnya adalah produk.  Semuanya sedikit lebih rumit dengan mereka: setiap produk terdiri dari beberapa bahan dan kami harus menambahkannya ke produk sebelum digunakan. <br><br>  Di sini, pola Builder tua yang baik berguna.  Ini adalah versi build saya untuk produk: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ProductBuilder</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Product _product; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProductBuilder</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name</span></span></span><span class="hljs-function">)</span></span> { _product = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Product(name); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ProductBuilder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Containing</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Ingredient ingredient</span></span></span><span class="hljs-function">)</span></span> { _product.AddIngredient(ingredient); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Product </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Please</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _product; } }</code> </pre><br>  Ini terdiri dari konstruktor parameter, metode <code>Containing</code> kustom, dan metode terminal <code>Please</code> .  Jika Anda tidak suka berbaik hati dengan kode tersebut, maka Anda dapat mengganti <code>Please</code> with <code>Now</code> .  Builder menyembunyikan konstruktor kompleks dan pemanggilan metode yang mengkonfigurasi objek.  Kode menjadi lebih bersih dan lebih mudah dimengerti.  Dengan cara yang baik, pembangun harus menyederhanakan pembuatan objek sehingga kode jelas bagi pakar domain.  Sangat layak menggunakan pembangun untuk objek yang memerlukan konfigurasi sebelum mulai bekerja. <br><br>  Pembangun produk akan memungkinkan Anda untuk membuat desain seperti: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pepperoni = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ProductBuilder(<span class="hljs-string"><span class="hljs-string">"Pepperoni"</span></span>) .Containing(Ingredients.Dough) .Containing(Ingredients.Pepperoni) .Please();</code> </pre><br><blockquote>  Builds membantu Anda membuat objek yang perlu dikustomisasi.  Pertimbangkan untuk membuat builder walaupun konfigurasi terdiri dari satu baris. </blockquote><br><h2>  ObjectMother </h2><br>  Terlepas dari kenyataan bahwa penciptaan produk telah menjadi jauh lebih baik, perancang <code>new ProductBuilder</code> masih terlihat sangat jelek.  Perbaiki dengan pola ObjectMother (Father). <br><br>  Polanya sederhana seperti 5 kopecks: kami membuat kelas statis dan mengumpulkan semua pembangun ke dalamnya. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Create</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> ProductBuilder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Product</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name</span></span></span><span class="hljs-function">)</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ProductBuilder(name); }</code> </pre><br>  Sekarang Anda dapat menulis seperti ini: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pepperoni = Create.Product(<span class="hljs-string"><span class="hljs-string">"Pepperoni"</span></span>) .Containing(Ingredients.Dough) .Containing(Ingredients.Pepperoni) .Please();</code> </pre><br>  ObjectMother diciptakan untuk pembuatan objek deklaratif.  Selain itu, membantu untuk memperkenalkan pengembang baru ke dalam domain, sebagai  saat menulis kata <code>Create</code> IDE sendiri akan memberi tahu Anda apa yang dapat Anda buat di domain ini. <br><br>  Dalam kode kami, ObjectMother kadang-kadang disebut Bukan <code>Create</code> , tapi <code>Given</code> .  Saya suka kedua opsi.  Jika Anda punya ide lain - bagikan di komentar. <br><blockquote>  Untuk secara deklaratif membuat objek, gunakan ObjectMother.  Kode akan menjadi lebih bersih, dan akan lebih mudah bagi pengembang baru untuk mempelajari domain. </blockquote><br><h2>  Penghapusan produk </h2><br>  Sudah menjadi jauh lebih baik, tetapi produk masih memiliki ruang untuk tumbuh.  Kami memiliki sejumlah produk dan, seperti bahan, mereka dapat dikumpulkan dalam kelas terpisah dan tidak diinisialisasi untuk setiap tes: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Pizza</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Product Pepperoni =&gt; Create.Product(<span class="hljs-string"><span class="hljs-string">"Pepperoni"</span></span>) .Containing(Ingredients.Dough) .Containing(Ingredients.Pepperoni) .Please(); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Product Margarita =&gt; Create.Product(<span class="hljs-string"><span class="hljs-string">"Margarita"</span></span>) .Containing(Ingredients.Dough) .Containing(Ingredients.Mozzarella) .Please(); }</code> </pre><br>  Di sini saya menyebut wadah bukan <code>Products</code> , melainkan <code>Pizza</code> .  Nama ini membantu membaca tes.  Misalnya, ada baiknya Anda menghilangkan pertanyaan seperti “Apakah Pepperoni pizza atau sosis?”. <br><blockquote>  Cobalah untuk menggunakan objek domain nyata, bukan pengganti seperti Product1. </blockquote><br><h2>  Pembangun untuk pesanan (contoh dari belakang) </h2><br>  Sekarang kita menerapkan pola yang dijelaskan untuk membuat pembangun pesanan, tapi sekarang mari kita pergi bukan dari pembangun, tetapi dari apa yang ingin kita terima.  Ini adalah bagaimana saya ingin membuat pesanan: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> order = Create.Order .Dated(DateTime.Now) .With(Pizza.Pepperoni.CountOf(<span class="hljs-number"><span class="hljs-number">1</span></span>).For(<span class="hljs-number"><span class="hljs-number">500</span></span>)) .With(Pizza.Margarita.CountOf(<span class="hljs-number"><span class="hljs-number">1</span></span>).For(<span class="hljs-number"><span class="hljs-number">650</span></span>)) .Please();</code> </pre><br>  Bagaimana kita bisa mencapai ini?  Kami jelas membutuhkan pembangun untuk pesanan dan jalur pemesanan.  Dengan pembangun untuk memesan semuanya jernih.  Ini dia: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">OrderBuilder</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> DateTime _date; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> List&lt;OrderLine&gt; _lines = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;OrderLine&gt;(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> OrderBuilder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Dated</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">DateTime date</span></span></span><span class="hljs-function">)</span></span> { _date = date; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> OrderBuilder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">With</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">OrderLine orderLine</span></span></span><span class="hljs-function">)</span></span> { _lines.Add(orderLine); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Order </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Please</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> order = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Order(_date); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> line <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> _lines) { order.AddLine(line); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> order; } }</code> </pre><br>  Tetapi dengan <code>OrderLine</code> situasinya lebih menarik: pertama, terminal Tolong metode tidak dipanggil di sini, dan kedua, akses ke pembangun disediakan bukan oleh <code>Create</code> statis dan bukan konstruktor pembangun itu sendiri.  Kami akan memecahkan masalah pertama menggunakan <code>implicit operator</code> dan pembangun kami akan terlihat seperti ini: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">OrderLineBuilder</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Product _product; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">decimal</span></span> _count; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">decimal</span></span> _price; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> OrderLineBuilder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Of</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">decimal</span></span></span></span><span class="hljs-function"><span class="hljs-params"> count, Product product</span></span></span><span class="hljs-function">)</span></span> { _product = product; _count = count; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> OrderLineBuilder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">For</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">decimal</span></span></span></span><span class="hljs-function"><span class="hljs-params"> price</span></span></span><span class="hljs-function">)</span></span> { _price = price; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">implicit</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">operator</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OrderLine</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">OrderLineBuilder b</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> OrderLine(b._product, b._count, b._price); } }</code> </pre><br>  Metode kedua akan membantu kami memahami metode Ekstensi untuk kelas <code>Product</code> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ProductExtensions</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> OrderLineBuilder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CountOf</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Product product, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">decimal</span></span></span></span><span class="hljs-function"><span class="hljs-params"> count</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Create.OrderLine.Of(count, product) } }</code> </pre> <br>  Secara umum, metode ekstensi adalah teman baik DSL.  Mereka dapat membuat deskripsi yang deklaratif dan dapat dimengerti dari logika yang sepenuhnya jahat. <br><blockquote>  Gunakan metode ekstensi.  Gunakan saja.  :) </blockquote>  Setelah melakukan semua tindakan ini, kami mendapatkan kode tes berikut: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Fact</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AcceptOrder_Successful</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> order = Create.Order .Dated(DateTime.Now) .With(Pizza.Pepperoni.CountOf(<span class="hljs-number"><span class="hljs-number">1</span></span>).For(<span class="hljs-number"><span class="hljs-number">500</span></span>)) .With(Pizza.Margarita.CountOf(<span class="hljs-number"><span class="hljs-number">1</span></span>).For(<span class="hljs-number"><span class="hljs-number">650</span></span>)) .Please(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> orderRepositoryMock = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mock&lt;IOrderRepository&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ingredientsRepositoryMock = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mock&lt;IIngredientRepository&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> service = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PizzeriaService(orderRepositoryMock.Object, ingredientsRepositoryMock.Object); service.AcceptOrder(order); orderRepositoryMock.Verify(r =&gt; r.Add(order), Times.Once); ingredientsRepositoryMock.Verify(r =&gt; r.ReserveIngredients(order), Times.Once); }</code> </pre><br>  Di sini kita telah mengambil pendekatan yang kita sebut "Peri Peri".  Ini adalah saat Anda pertama kali menulis kode siaga seperti yang Anda ingin melihatnya, dan kemudian mencoba untuk membungkus apa yang Anda tulis dalam DSL.  Ini sangat berguna untuk bertindak - kadang-kadang Anda sendiri tidak dapat membayangkan apa yang mampu dilakukan oleh C #. <br><blockquote>  Bayangkan bahwa peri ajaib telah tiba dan memungkinkan Anda untuk menulis kode seperti yang Anda inginkan, dan kemudian mencoba untuk membungkus semua yang ditulis dalam DSL. </blockquote><br><h2>  Menciptakan layanan (pola yang dapat diuji) </h2><br>  Dengan pesanan sekarang semuanya kurang lebih tidak buruk.  Waktunya telah tiba untuk berurusan dengan mokas dari repositori.  Layak dikatakan di sini bahwa tes itu sendiri, yang kami pertimbangkan, adalah tes untuk perilaku.  Tes perilaku sangat terkait dengan penerapan metode, dan jika mungkin untuk tidak menulis tes seperti itu, maka lebih baik tidak melakukannya.  Namun, terkadang mereka berguna, dan kadang-kadang, Anda tidak dapat melakukannya tanpa mereka sama sekali.  Teknik berikut ini membantu untuk menulis dengan tepat tes untuk perilaku, dan jika Anda tiba-tiba menyadari bahwa Anda ingin menggunakannya, pertama-tama pikirkan apakah Anda dapat menulis ulang tes sedemikian rupa sehingga mereka memeriksa keadaan, bukan perilaku. <br><br>  Jadi, saya ingin memastikan bahwa dalam metode pengujian saya tidak ada satu pel.  Untuk melakukan ini, saya akan membuat pembungkus untuk <code>PizzeriaService</code> di mana saya merangkum semua logika yang memeriksa panggilan metode: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">PizzeriaServiceTestable</span></span> : <span class="hljs-title"><span class="hljs-title">PizzeriaService</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Mock&lt;IOrderRepository&gt; _orderRepositoryMock; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Mock&lt;IIngredientRepository&gt; _ingredientRepositoryMock; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PizzeriaServiceTestable</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Mock&lt;IOrderRepository&gt; orderRepositoryMock, Mock&lt;IIngredientRepository&gt; ingredientRepositoryMock</span></span></span><span class="hljs-function">) : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">base</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">orderRepositoryMock.Object, ingredientRepositoryMock.Object</span></span></span><span class="hljs-function">)</span></span> { _orderRepositoryMock = orderRepositoryMock; _ingredientRepositoryMock = ingredientRepositoryMock; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">VerifyAddWasCalledWith</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Order order</span></span></span><span class="hljs-function">)</span></span> { _orderRepositoryMock.Verify(r =&gt; r.Add(order), Times.Once); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">VerifyReserveIngredientsWasCalledWith</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Order order</span></span></span><span class="hljs-function">)</span></span> { _ingredientRepositoryMock.Verify(r =&gt; r.ReserveIngredients(order), Times.Once); } }</code> </pre><br>  Kelas ini akan memungkinkan kita untuk memeriksa pemanggilan metode, tetapi kita masih perlu membuatnya entah bagaimana.  Untuk melakukan ini, kita akan menggunakan pembuat yang sudah kita ketahui: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">PizzeriaServiceBuilder</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> PizzeriaServiceTestable </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Please</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> orderRepositoryMock = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mock&lt;IOrderRepository&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ingredientsRepositoryMock = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mock&lt;IIngredientRepository&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PizzeriaServiceTestable(orderRepositoryMock, ingredientsRepositoryMock); } }</code> </pre><br>  Saat ini, metode pengujian kami terlihat seperti ini: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Fact</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AcceptOrder_Successful</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> order = Create.Order .Dated(DateTime.Now) .With(Pizza.Pepperoni.CountOf(<span class="hljs-number"><span class="hljs-number">1</span></span>).For(<span class="hljs-number"><span class="hljs-number">500</span></span>)) .With(Pizza.Margarita.CountOf(<span class="hljs-number"><span class="hljs-number">1</span></span>).For(<span class="hljs-number"><span class="hljs-number">650</span></span>)) .Please(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> service = Create.PizzeriaService.Please(); service.AcceptOrder(order); service.VerifyAddWasCalledWith(order); service.VerifyReserveIngredientsWasCalledWith(order); }</code> </pre><br>  Metode panggilan pengujian bukan satu-satunya alasan kelas Testable dapat digunakan.  Di sini, misalnya, di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> Dima Pavlov kami menggunakannya untuk refactoring kode legacy yang kompleks. <br><blockquote>  Dapat diuji mampu menyelamatkan situasi dalam kasus yang paling sulit.  Untuk tes perilaku, ini membantu untuk membungkus cek panggilan jelek menjadi metode yang indah. </blockquote>  Pada saat yang penting ini, kami selesai untuk memahami kemampuan ujian.  Tetap membuatnya reproduktif dan fokus. <br><br><h2>  Reproducibilitas (Ekstensi Literal) </h2><br>  Pola Perluasan Literal tidak secara langsung terkait dengan reproduktifitas, tetapi itu akan membantu kita.  Masalah kami saat ini adalah kami menggunakan <code>DateTime.Now</code> sebagai tanggal pesanan.  Jika tiba-tiba mulai dari tanggal tertentu, logika penerimaan pesanan berubah, maka dalam logika bisnis kita, kita harus setidaknya untuk beberapa waktu mendukung 2 logika penerimaan pesanan, memisahkannya dengan memeriksa seperti <code>if (order.Date &gt; edgeDate)</code> .  Dalam hal ini, pengujian kami memiliki peluang untuk jatuh ketika tanggal sistem melewati batas.  Ya, kami akan segera memperbaiki ini, dan bahkan membuat dua dari satu tes: satu akan memeriksa logika sebelum tanggal batas, dan yang lainnya setelah.  Namun demikian, lebih baik untuk menghindari situasi seperti itu dan segera membuat semua data input konstan. <br><br>  "Dan di mana DSL?"  - kamu bertanya.  Faktanya adalah bahwa itu nyaman untuk memasukkan tanggal dalam tes melalui metode Extension, misalnya <code>3.May(2019)</code> .  Bentuk rekaman ini akan dimengerti tidak hanya untuk pengembang, tetapi juga untuk bisnis.  Untuk melakukan ini, cukup buat kelas statis seperti itu <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">DateConstructionExtensions</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> DateTime </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">May</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> day, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> year</span></span></span><span class="hljs-function">)</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DateTime(year, <span class="hljs-number"><span class="hljs-number">5</span></span>, day); }</code> </pre><br>  Secara alami, kurma bukan satu-satunya hal yang menggunakan pola ini.  Misalnya, jika kami memperkenalkan jumlah bahan dalam komposisi produk, kami dapat menulis sekitar <code>42.Grams("flour")</code> . <br><blockquote>  Objek dan tanggal kuantitatif dibuat dengan mudah melalui metode ekstensi yang sudah dikenal. </blockquote><br><h2>  Fokus </h2><br>  Mengapa penting untuk membuat tes tetap fokus?  Faktanya adalah bahwa tes terfokus lebih mudah dipertahankan, tetapi mereka masih harus didukung.  Misalnya, mereka harus diubah ketika mengubah kode dan dihapus ketika melihat fitur lama.  Jika tes tidak fokus, maka ketika mengubah logika, Anda perlu memahami tes besar, dan memotong bagian dari fungsionalitas yang diuji dari mereka.  Jika tes terfokus dan namanya jelas, maka Anda hanya perlu menghapus tes yang sudah usang dan menulis yang baru.  Jika tes memiliki DSL yang baik, maka ini bukan masalah sama sekali. <br><br>  Jadi, setelah kami selesai menulis DSL, kami berkesempatan untuk membuat tes ini fokus dengan membaginya menjadi 2 tes: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Fact</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WhenAcceptOrder_AddIsCalled</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> order = Create.Order .Dated(<span class="hljs-number"><span class="hljs-number">3.</span></span>May(<span class="hljs-number"><span class="hljs-number">2019</span></span>)) .With(Pizza.Pepperoni.CountOf(<span class="hljs-number"><span class="hljs-number">1</span></span>).For(<span class="hljs-number"><span class="hljs-number">500</span></span>)) .With(Pizza.Margarita.CountOf(<span class="hljs-number"><span class="hljs-number">1</span></span>).For(<span class="hljs-number"><span class="hljs-number">650</span></span>)) .Please(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> service = Create.PizzeriaService.Please(); service.AcceptOrder(order); service.VerifyAddWasCalledWith(order); } [Fact] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WhenAcceptOrder_ReserveIngredientsIsCalled</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> order = Create.Order .Dated(<span class="hljs-number"><span class="hljs-number">3.</span></span>May(<span class="hljs-number"><span class="hljs-number">2019</span></span>)) .With(Pizza.Pepperoni.CountOf(<span class="hljs-number"><span class="hljs-number">1</span></span>).For(<span class="hljs-number"><span class="hljs-number">500</span></span>)) .With(Pizza.Margarita.CountOf(<span class="hljs-number"><span class="hljs-number">1</span></span>).For(<span class="hljs-number"><span class="hljs-number">650</span></span>)) .Please(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> service = Create.PizzeriaService.Please(); service.AcceptOrder(order); service.VerifyReserveIngredientsWasCalledWith(order); }</code> </pre><br>  Kedua tes itu ternyata pendek, jelas, dapat direproduksi, dan fokus. <br><br>  Harap dicatat bahwa sekarang nama-nama tes mencerminkan tujuan penulisan mereka dan sekarang setiap pengembang yang datang ke proyek saya akan mengerti mengapa masing-masing tes ditulis dan apa yang terjadi dalam tes ini. <br><blockquote>  Fokus tes membuatnya didukung.  Tes yang baik harus fokus. </blockquote>  Dan sekarang, saya sudah bisa mendengar Anda berteriak kepada saya, “Yura, apa-apaan kamu?  Kami menulis sejuta kode hanya untuk membuat beberapa tes cantik? "  Ya persis.  Meskipun kami hanya memiliki beberapa tes, masuk akal untuk berinvestasi dalam DSL dan membuat tes ini dapat dimengerti.  Setelah Anda menulis DSL, Anda mendapatkan banyak barang: <br><br><ul><li>  Menjadi mudah untuk menulis tes baru.  Tidak perlu mengatur diri Anda selama 2 jam untuk pengujian unit, cukup ambil dan tulis. </li><li>  Tes menjadi dapat dimengerti dan dibaca.  Setiap pengembang yang melihat tes memahami mengapa itu ditulis dan apa yang diperiksa. </li><li>  Ambang untuk mengikuti tes (dan mungkin dalam domain) untuk pengembang baru berkurang.  Misalnya, melalui ObjectMother, Anda dapat dengan mudah mengetahui objek apa yang dapat dibuat di domain. </li><li>  Dan akhirnya, itu bagus untuk bekerja dengan tes, dan sebagai hasilnya, kode menjadi lebih didukung. </li></ul><br>  Kode sumber dan tes sampel tersedia di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id451598/">https://habr.com/ru/post/id451598/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id451588/index.html">Catatan Pengujian Integrasi Menggunakan Jenkins di Kubernetes</a></li>
<li><a href="../id451590/index.html">100 hal diumumkan di I / O No. 19</a></li>
<li><a href="../id451592/index.html">Rekaman laporan dari QA-mitap Redmadrobot kedua</a></li>
<li><a href="../id451594/index.html">PHP Russia 2019 Report Guide</a></li>
<li><a href="../id451596/index.html">Grey Cardinal .NET - John Galloway</a></li>
<li><a href="../id451600/index.html">Cara menulis surat pengantar saat mencari pekerjaan di AS: 7 tips</a></li>
<li><a href="../id451602/index.html">Kami mempelajari MITER ATT & CK. Matriks Seluler: Akses Perangkat. Bagian 1</a></li>
<li><a href="../id451604/index.html">Artikel ini terlalu banyak air.</a></li>
<li><a href="../id451606/index.html">Sejarah Internet: Peluruhan, Bagian 2</a></li>
<li><a href="../id451610/index.html">Security Week 20: menonaktifkan ekstensi Firefox</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>