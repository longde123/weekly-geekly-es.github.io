<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎐 💃 🧗🏿 Kompatibilitas biner: sekarang atau tidak sama sekali 🚣🏽 👄 ☀️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Terjemahan publikasi Titus Winters di Kelompok Kerja 21 (WG21) - C ++ Komite Standardisasi Bahasa. Penulis membahas masalah penting: dukungan untuk ko...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kompatibilitas biner: sekarang atau tidak sama sekali</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/474294/"><p>  <i>Terjemahan publikasi Titus Winters di Kelompok Kerja 21 (WG21) - C ++ Komite Standardisasi Bahasa.</i>  <i>Penulis membahas masalah penting: dukungan untuk kompatibilitas mundur biner atau ABI (antarmuka biner aplikasi).</i> <br><br></p><p>  Selama beberapa tahun terakhir di WG21, saya secara aktif mempromosikan bahwa kemajuan lebih penting daripada kompatibilitas ke belakang.  Tapi saya sendiri tidak lagi percaya akan hal ini, terutama yang berkaitan dengan menjaga kompatibilitas biner (ABI). <a name="habracut"></a>  Dalam tiga rilis terakhir (C ++ 14, C ++ 17 dan C ++ 20) ABI stabil seperti yang kami mampu.  Bahkan jika WG21 memutuskan untuk memutus kompatibilitas ABI di C ++ 23, kami telah menyediakan kompatibilitas biner pada banyak platform selama lebih dari 10 tahun.  Menurut pendapat saya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">hukum Hyrum</a> mendominasi perubahan besar-besaran sistem perangkat lunak.  Sekarang Anda tidak dapat memberi tahu berapa banyak pengguna yang memiliki asumsi stabilitas perpustakaan standar ABI (tidak peduli seberapa bijak atau seberapa eksplisit atau implisit) dengan tegas "dijahit dalam subkorteks", mungkin setengah dari pengembang C ++ di dunia. </p><br><p> Saya menyimpan daftar apa yang bisa diperbaiki oleh WG21 dalam bahasa ini jika kami memutuskan untuk "memecahkan" ABI.  Dan saya tidak bisa mengatakan dengan yakin bahwa total biaya pengerjaan ulang, yang akan memerlukan hanya penerapan daftar ini, sebanding dengan biaya pelanggaran ABI di seluruh ekosistem.  Kami melihat banyak perbaikan kecil dalam konsistensi API, kualitas kode perpustakaan standar, dll., Tetapi tanpa keraguan tidak ada satu pun perubahan "terobosan" yang akan membenarkan biaya ini untuk pengembang rata-rata.  Mungkin kita akan mendapatkan implementasi standar yang lebih baik, memberikan kesempatan untuk menyelesaikan masalah implementasi yang tidak memenuhi spesifikasi standar saat ini.  Tetapi tidak ada satu perbaikan pun dalam daftar saya yang jelas sepadan dengan biayanya. </p><br><p>  Lebih penting lagi, karena keterbatasan ABI, kami tidak dapat menghilangkan kerugian kinerja yang signifikan.  Kami tidak dapat menghilangkan biaya signifikan mentransmisikan unique_ptr dengan nilai [Performa Chandler pada CppCon 2019, yang akan diterbitkan kemudian], kami tidak dapat mengubah std :: hash atau penempatan kelas dalam memori untuk unordered_map tanpa memaksa semua orang untuk mengkompilasi ulang semuanya di mana pun.  Kinerja hash telah dipelajari secara ekstensif selama bertahun-tahun dan, dengan mempertimbangkan optimalisasi pencarian dalam tabel dan hashing yang tepat, kami yakin bahwa kami dapat menyediakan implementasi hash unordered_map / std :: hash yang kompatibel dengan API dan menyediakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">peningkatan kinerja</a> 200-300%.  Tetapi pembatasan ABI tidak mengizinkan ini.  Studi tambahan tentang pengoptimalan dan penyetelan SSO untuk std :: string menunjukkan peningkatan kinerja yang tidak sepele (1% dalam microbenchmark dan penskalaan) - API tidak terpengaruh, tetapi pembatasan ABI tidak mengizinkan hal ini. <br><br>  Hilangnya total produktivitas yang diblokir secara eksklusif oleh ABI mencapai beberapa poin persentase - mungkin hingga 5-10%.  Ini bukan sesuatu yang secara keseluruhan tidak dapat dilakukan ekosistem tanpa, tetapi mungkin tidak dapat diterima oleh beberapa organisasi (Google di antaranya).  Ini, tentu saja, adalah kehilangan kinerja besar daripada yang dapat diterima untuk C ++: ingat bahwa ini adalah bahasa yang mengklaim bahwa ia tidak meninggalkan ruang untuk pesaing yang lebih produktif.  Sebagian besar pengguna tampaknya tidak peduli dengan penurunan kinerja ini: ada implementasi tabel hash lainnya untuk mereka yang khawatir tentang kinerja absolut.  Inefisiensi umum yang terkait dengan melewatkan unique_ptr dalam nilai dan masalah lain dari bahasa ABI mengemuka dalam sejumlah tugas yang sangat kecil.  Organisasi yang membutuhkan produktivitas maksimum dapat berjalan sendiri (dan melakukannya), menggunakan perpustakaan non-standar dan alat konfigurasi non-standar.  Ini wajar dan harus dipahami dengan jelas. </p><br><br>  Perubahan ABI akan memengaruhi jumlah pengguna yang relatif lebih besar.  Saya menduga sebagian besar pengguna ini tidak menduga seberapa kuat ketergantungan mereka pada ABI.  Dalam ekosistem server Google, hampir semuanya dikumpulkan dari sumbernya, ada beberapa ketergantungan eksternal dan ada peluang yang lebih baik daripada rata-rata untuk melakukan refactoring skala besar.  Tetapi bahkan bagi kami, perubahan ABI baru-baru ini pada perpustakaan standar menghabiskan biaya 5-10 tahun teknik. <br><p>  Total biaya pemecahan kompatibilitas ABI untuk seluruh ekosistem C ++ dapat diperkirakan secara konservatif dalam " <b>Millennium Engineer</b> ": mengoordinasikan pembangunan kembali untuk setiap penyedia plug-in, .so atau dll di dunia akan membutuhkan sumber daya manusia yang sangat besar.  Bersama dengan pemisahan ekosistem karena modul C ++ 20, mengubah ABI dalam waktu pengembangan dan implementasi C ++ 23 dapat menyebabkan pemisahan ekosistem yang keras. </p><br><br><p>  Ada banyak pertanyaan yang tidak bisa dijawab dengan diskusi ini.  Berapa lama kita bisa terus ke titik di mana mengubah ABI dari hanya berguna akan menjadi kebutuhan penting?  Jika kita secara eksplisit memilih dukungan stabilitas ABI, seberapa mahal perubahan itu kapan dan kapan kebutuhan kritis seperti itu muncul?  Jika masalah keamanan seperti Specter dan Meltdown memerlukan perubahan pada konvensi pemanggilan, berapa biaya C ++ untuk mengatasi tonggak sejarah ini?  Berapa proporsi pengembang yang menggunakan C ++ karena kami mengklaim menempatkan kinerja di atas segalanya?  Lebih buruk lagi: berapa lama C ++ mengklaim sebagai bahasa tercepat dan tidak harus melakukan optimasi seperti itu? </p><br><p>  Jika kita secara sadar tidak dapat mengizinkan atau tidak ingin mengubah ABI, maka keputusan ini harus disuarakan dengan keras.  Kita harus dengan jelas mengatakan bahwa ini adalah bahasa yang menempatkan stabilitas ABI di atas beberapa persen produktivitas terakhir.  Saya bersedia berargumen bahwa dalam praktiknya ini telah terjadi selama beberapa tahun terakhir.  Kami perlu memberi tahu pengguna apa yang diharapkan dari kami, dan memberi tahu mereka bahwa perpustakaan seperti Boost, Folly atau Absail diharapkan untuk membuat pilihan yang tepat jika kinerja diperlukan.  Tapi ini tidak membantu dengan pembatasan terkait ABI dalam bahasa itu sendiri sebagai biaya pengiriman unique_ptr.  Perpustakaan standar mempertahankan signifikansi dalam model pengembangan ini: perpustakaan standar adalah apa yang kami gunakan untuk kompatibilitas dan stabilitas.  Ini mungkin memerlukan perubahan fokus dan arah pengembangan: kita mungkin ingin merancang lebih banyak fleksibilitas dalam kondisi yang berubah, dan bukan untuk kinerja "bersih". </p><br><p>  Jika kami berpendapat bahwa produktivitas lebih penting daripada stabilitas ABI, kita harus segera memutuskan kapan tepatnya kita akan "mematahkan" kompatibilitas ke belakang dan melakukan segala yang mungkin agar ekosistem menerima perubahan seperti itu.  Dan dengan jelas dan keras menyatakan bahwa kita akan pergi dengan cara ini.  Anda perlu memahami bahwa semakin banyak waktu berlalu di antara perubahan seperti itu, semakin mahal jadinya - karena seiring waktu akan semakin banyak ketergantungan yang tidak didukung pada ABI.  “Implementer” kami membuatnya sangat jelas bahwa perubahan yang merusak kompatibilitas C ++ 11 itu menyakitkan dan mahal.  Keinginan untuk menghindari pengulangan biaya semacam itu adalah wajar, tetapi Anda harus memilih: apakah kami tidak mengulanginya, karena kami tidak mengubah ABI, atau membuat biayanya lebih murah. </p><br><p>  Intinya, ada tiga kemungkinan untuk WG21: <br><br></p><ol><li>  Memutuskan di mana rilis ABI akan diubah tidak masalah di C ++ 23 atau C ++ 26.  Peringatkan orang dan segera kembangkan alat dan diagnostik untuk membantu mengidentifikasi tempat yang akan rusak.  Berfokus pada praktik dan alat yang lebih konsisten untuk mendukung perubahan ABI di masa depan.  Bukan kepentingan pelaksana tertentu untuk mengekspos penggunanya pada konsekuensi mengubah ABI, jika implementasi lain tidak, mengubah ABI harus menjadi kegiatan yang terkoordinasi untuk keuntungan pengguna di masa mendatang.  Idealnya, Anda harus menghancurkan semuanya - untuk membuatnya jelas bahwa kode yang dikompilasi dalam mode C ++ 23 tidak kompatibel dengan kode yang dikompilasi dalam mode sebelumnya.  Jika seseorang dapat melakukannya tanpa membangun kembali, dan orang lain akan memiliki kesalahan dalam tata letak atau pada waktu berjalan - ini hanya akan meningkatkan kesalahpahaman dan kekecewaan. </li><li>  Memutuskan bahwa kami mengupayakan stabilitas ABI dengan memformalkan praktik hari ini.  Ini telah menjadi kasus selama bertahun-tahun ketika pelaksana standar memiliki hak untuk memveto perubahan ABI - kami telah menetapkan kompatibilitas ABI di atas kebersihan dan kinerja desain.  Jika kami mengenali ini dan memberi tahu pengguna dengan jelas, ekosistem akan lebih baik.  Nilai perpustakaan tambahan akan tumbuh bagi mereka yang perlu memeras tetes kinerja terakhir, tetapi tidak memerlukan stabilitas yang disediakan oleh standar.  Bahasa berorientasi kinerja lain mungkin menantang posisi kami di masa depan. </li><li>  Tidak dapat memilih arah dan menyimpan status quo.  Ini adalah skenario terburuk bagi saya: kami terus secara implisit lebih memperhatikan kompatibilitas ABI.  Kami mengatakan "kinerja" dan memilih "kompatibilitas biner".  Disonansi seperti itu membahayakan ekosistem dan menyiratkan kurangnya kesepakatan tentang prioritas bahasa.  Saya dengan tulus berharap bahwa melalui upaya pelaksana dan Dirjen, kami akan mencapai konsensus yang diperlukan. </li></ol><br><p>  Saya percaya bahwa opsi No. 1 lebih cocok untuk pengguna yang membutuhkan kinerja maksimal, tetapi memiliki biaya yang luar biasa bagi ekosistem dan dapat menyebabkan fragmentasi bahasa di masa depan.  Opsi nomor 2 adalah pilihan yang membosankan, bertanggung jawab, dan layak: menyedihkan untuk mengakui bahwa kita melukis diri kita sendiri di sudut ruangan dan mencoba meminimalkan kerugian yang terkait dengan ini.  Memilih opsi No. 3 berarti tidak mengelola, dan saya berdoa semoga ini akan dihindari: setiap pilihan eksplisit lebih baik daripada disonansi saat ini dan ketidakmampuan untuk mencapai kesepakatan mengenai pilihan tujuan jangka panjang. <br><br>  Saya mengerti bahwa kami telah mencapai posisi kami saat ini melalui banyak tindakan kecil yang tampaknya tidak masuk akal.  Selama 10 tahun terakhir, tidak ada satu pun perubahan yang dibuat yang dapat membenarkan pelanggaran kompatibilitas biner, tetapi kebijakan implisit mempertahankan kompatibilitas mundur telah menjadi merusak bagi ekosistem.  Namun, dengan mengadopsi kebijakan seperti itu secara eksplisit, kami akan membuka kemungkinan lain bagi C ++ untuk secara bertahap meninggalkan panggung: Anda tidak bisa menjadi bahasa yang berorientasi sistem, berorientasi pada kinerja, menyisakan begitu banyak ruang untuk bahasa yang lebih produktif.  Secara teori, masing-masing vendor dapat memutuskan untuk "mematahkan" ABI dalam rilis apa pun di masa mendatang, tetapi arah pemikiran umum tampaknya berbeda.  Saya yakin bahwa diskusi dan konsensus antara para pelaksana standar dan WG21 diperlukan: prioritas apa yang harus saya pilih? </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id474294/">https://habr.com/ru/post/id474294/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id474280/index.html">Ingin DBMS tangan pertama? Pertemuan terbuka di Nizhny Novgorod - menjadi</a></li>
<li><a href="../id474282/index.html">Datacenter TCP menjelaskan</a></li>
<li><a href="../id474284/index.html">Bukan hanya berjangka dan opsi: apa instrumen keuangan sekunder lainnya yang ada di bursa dan tidak hanya</a></li>
<li><a href="../id474286/index.html">Analisis terperinci dari metode simpleks</a></li>
<li><a href="../id474292/index.html">Tutorial JavaFX: Memulai</a></li>
<li><a href="../id474298/index.html">Menerapkan Operasi Transfer Kartu-ke-Kartu P2P Gateway</a></li>
<li><a href="../id474300/index.html">Cadangan yang andal, aman, dan serbaguna untuk U2F</a></li>
<li><a href="../id474302/index.html">Cara menulis skrip uji kegunaan aplikasi yang efektif</a></li>
<li><a href="../id474306/index.html">Buat gaya penunjuk, fokus, dan status aktif berbeda.</a></li>
<li><a href="../id474308/index.html">Jenis untuk HTTP API yang ditulis dalam Python: pengalaman Instagram</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>