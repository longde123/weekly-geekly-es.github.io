<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👵🏻 🤠 ⚰️ 10 فوائد غير واضحة لاستخدام الصدأ 🧚🏽 🛡️ ♉️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Rust هي لغة برمجة نظام شابة وطموحة. ينفذ إدارة الذاكرة التلقائية دون جامع القمامة وغيرها من وقت التنفيذ. بالإضافة إلى ذلك ، يتم استخدام اللغة الافتراض...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>10 فوائد غير واضحة لاستخدام الصدأ</h1><div class="post__body post__body_full" style=";text-align:right;direction:rtl"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430294/" style=";text-align:right;direction:rtl"><p style=";text-align:right;direction:rtl">  Rust هي لغة برمجة نظام شابة وطموحة.  ينفذ إدارة الذاكرة التلقائية دون جامع القمامة وغيرها من وقت التنفيذ.  بالإضافة إلى ذلك ، يتم استخدام اللغة الافتراضية في لغة Rust ، وهناك قواعد غير مسبوقة للوصول إلى البيانات القابلة للتغيير ، كما يتم مراعاة عمر الارتباطات.  هذا يسمح له بضمان أمن الذاكرة ويسهل البرمجة متعددة الخيوط ، بسبب نقص سباقات البيانات. </p><br><p style=";text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/4q/db/t-/4qdbt-1pfubt4paba4gojjth7zs.jpeg"></p><br><p style=";text-align:right;direction:rtl"> كل هذا معروف جيدًا بالفعل لكل من يتابع تطور تقنيات البرمجة الحديثة على الأقل قليلاً.  ولكن ماذا لو لم تكن مبرمج نظام ، وليس هناك العديد من التعليمات البرمجية في مشاريعك ، ولكنك لا تزال تنجذب إلى أداء Rust.  هل ستحصل على أي فوائد إضافية من استخدامه في التطبيقات؟  أو كل ما سيعطيك إياه هو صراع صعب مع المترجم ، مما سيجبرك على كتابة البرنامج بحيث يتبع باستمرار قواعد اللغة في الاقتراض والملكية؟ </p><br><p style=";text-align:right;direction:rtl">  جمعت هذه المقالة عشرات المزايا غير الواضحة وغير المعلن عنها بشكل خاص لاستخدام Rust ، والتي آمل أن تساعدك على تحديد اختيار هذه اللغة لمشاريعك. </p><a name="habracut"></a><br><h2 id="1-universalnost-yazyka" style=";text-align:right;direction:rtl">  1. شمولية اللغة </h2><br><p style=";text-align:right;direction:rtl">  على الرغم من حقيقة أن Rust يتم وضعها كلغة لبرمجة النظام ، إلا أنها مناسبة أيضًا لحل المشكلات التطبيقية عالية المستوى.  لست مضطرًا للعمل مع المؤشرات الأولية ما لم تكن بحاجة إليها لمهمتك.  نفذت مكتبة اللغات القياسية بالفعل معظم الأنواع والوظائف التي قد تكون مطلوبة في تطوير التطبيقات.  يمكنك أيضًا توصيل المكتبات الخارجية بسهولة واستخدامها.  يسمح نظام النوع والبرمجة المعممة في Rust باستخدام تجريدات بمستوى عالٍ إلى حد ما ، على الرغم من عدم وجود دعم مباشر لـ OOP في اللغة. </p><br><p style=";text-align:right;direction:rtl">  دعونا نلقي نظرة على بعض الأمثلة البسيطة لاستخدام Rust. </p><br><p style=";text-align:right;direction:rtl">  مثال على دمج مكررين في مكرر واحد على أزواج من العناصر: </p><br><pre style=";text-align:right;direction:rtl"><code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> zipper: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;_&gt; = (<span class="hljs-number"><span class="hljs-number">1</span></span>..).zip(<span class="hljs-string"><span class="hljs-string">"foo"</span></span>.chars()).collect(); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>((<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'f'</span></span>), zipper[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>((<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'o'</span></span>), zipper[<span class="hljs-number"><span class="hljs-number">1</span></span>]); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>((<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">'o'</span></span>), zipper[<span class="hljs-number"><span class="hljs-number">2</span></span>]);</code> </pre> <br><p style=";text-align:right;direction:rtl">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><em>اركض</em></a> </p><br><blockquote style=";text-align:right;direction:rtl">  ملاحظة: استدعاء <code>name!(...)</code> التنسيق <code>name!(...)</code> هو استدعاء لماكرو وظيفي.  تنتهي أسماء وحدات الماكرو في Rust دائمًا برمز <code>!</code>  بحيث يمكن تمييزها عن أسماء الوظائف والمعرفات الأخرى.  سيتم مناقشة فوائد استخدام وحدات الماكرو أدناه. </blockquote><p style=";text-align:right;direction:rtl">  مثال على استخدام مكتبة <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><code>regex</code></a> الخارجية للعمل مع التعبيرات العادية: </p><br><pre style=";text-align:right;direction:rtl"> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> regex; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> regex::Regex; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> re = Regex::new(<span class="hljs-string"><span class="hljs-string">r"^\d{4}-\d{2}-\d{2}$"</span></span>).unwrap(); <span class="hljs-built_in"><span class="hljs-built_in">assert!</span></span>(re.is_match(<span class="hljs-string"><span class="hljs-string">"2018-12-06"</span></span>));</code> </pre> <br><p style=";text-align:right;direction:rtl">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><em>اركض</em></a> </p><br><p style=";text-align:right;direction:rtl">  مثال على تنفيذ <code>Add</code> لبنية <code>Point</code> الخاصة بها لزيادة التحميل على عامل الإضافة: </p><br><pre style=";text-align:right;direction:rtl"> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::ops::Add; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span></span> { x: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, y: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Add <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Point { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Output</span></span></span></span> = Point; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, other: Point) -&gt; Point { Point { x: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.x + other.x, y: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.y + other.y } } } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> p1 = Point { x: <span class="hljs-number"><span class="hljs-number">1</span></span>, y: <span class="hljs-number"><span class="hljs-number">0</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> p2 = Point { x: <span class="hljs-number"><span class="hljs-number">2</span></span>, y: <span class="hljs-number"><span class="hljs-number">3</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> p3 = p1 + p2;</code> </pre> <br><p style=";text-align:right;direction:rtl">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><em>اركض</em></a> </p><br><p style=";text-align:right;direction:rtl">  مثال على استخدام نوع عام في هيكل: </p><br><pre style=";text-align:right;direction:rtl"> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span></span>&lt;T&gt; { x: T, y: T, } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> int_origin = Point { x: <span class="hljs-number"><span class="hljs-number">0</span></span>, y: <span class="hljs-number"><span class="hljs-number">0</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> float_origin = Point { x: <span class="hljs-number"><span class="hljs-number">0.0</span></span>, y: <span class="hljs-number"><span class="hljs-number">0.0</span></span> };</code> </pre> <br><p style=";text-align:right;direction:rtl">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><em>اركض</em></a> </p><br><p style=";text-align:right;direction:rtl">  في Rust ، يمكنك كتابة أدوات مساعدة فعالة للنظام ، وتطبيقات سطح المكتب الكبيرة ، والخدمات الصغيرة ، وتطبيقات الويب (بما في ذلك جزء العميل ، حيث يمكن تجميع Rust في Wasm) ، والتطبيقات المحمولة (على الرغم من أن النظام البيئي للغات لا يزال ضعيفًا في هذا الاتجاه).  يمكن أن يكون هذا التنوع بمثابة ميزة للفرق متعددة المشاريع ، لأنه يسمح لك باستخدام نفس النهج ونفس الوحدات في العديد من المشاريع المختلفة.  إذا كنت معتادًا على حقيقة أن كل أداة مصممة لمجال تطبيقها الضيق ، فحاول النظر إلى Rust كصندوق أدوات بنفس الموثوقية والراحة.  ربما هذا هو بالضبط ما كنت تفتقده. </p><br><h2 id="2-udobnye-instrumenty-sborki-i-upravleniya-zavisimostyami" style=";text-align:right;direction:rtl">  2. أدوات بناء وإدارة تبعية مريحة </h2><br><p style=";text-align:right;direction:rtl">  من الواضح أنه لم يتم الإعلان عن ذلك ، ولكن يلاحظ الكثير أن Rust لديها أحد أفضل أنظمة إدارة البناء والتبعية المتاحة اليوم.  إذا كنت مبرمجًا في C أو C ++ ، وكانت مسألة الاستخدام غير المؤلم للمكتبات الخارجية حادة للغاية بالنسبة لك ، فإن استخدام Rust مع أداة البناء ومدير تبعية الشحن سيكون خيارًا جيدًا لمشاريعك الجديدة. </p><br><p style=";text-align:right;direction:rtl">  بالإضافة إلى حقيقة أن Cargo ستقوم بتنزيل التنزيلات من أجلك وإدارة إصداراتها ، وإنشاء تطبيقاتك وتشغيلها ، وإجراء الاختبارات وإنشاء الوثائق ، يمكن أيضًا توسيعها باستخدام مكونات إضافية لوظائف مفيدة أخرى.  على سبيل المثال ، هناك ملحقات تسمح لـ Cargo بتحديد التبعيات القديمة لمشروعك ، وإجراء تحليل ثابت لشفرة المصدر ، وإنشاء أجزاء العميل الخاصة بتطبيقات الويب وإعادة نشرها ، وغير ذلك الكثير. </p><br><p style=";text-align:right;direction:rtl">  يستخدم ملف تهيئة Cargo لغة الترميز الودية والحد الأدنى لوصف إعدادات المشروع.  فيما يلي مثال <code>Cargo.toml</code> تكوين <code>Cargo.toml</code> النموذجي: </p><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">[package] name = "some_app" version = "0.1.0" authors = ["Your Name &lt;you@example.com&gt;"] [dependencies] regex = "1.0" chrono = "0.4" [dev-dependencies] rand = "*"</code> </pre> <br><p style=";text-align:right;direction:rtl">  وفيما يلي ثلاثة أوامر نموذجية لاستخدام Cargo: </p><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">$ cargo check $ cargo test $ cargo run</code> </pre> <br><p style=";text-align:right;direction:rtl">  بمساعدتهم ، سيتم التحقق من التعليمات البرمجية المصدر لأخطاء التجميع ، وتجميع المشروع وإطلاق الاختبارات ، وتجميع وإطلاق برنامج التنفيذ ، على التوالي. </p><br><h2 id="3-vstroennye-testy" style=";text-align:right;direction:rtl">  3. الاختبارات المدمجة </h2><br><p style=";text-align:right;direction:rtl">  اختبارات وحدة الكتابة في Rust سهلة وبسيطة لدرجة أنك تريد القيام بذلك مرارًا وتكرارًا.  :) غالبًا ما يكون من الأسهل كتابة اختبار الوحدة بدلاً من محاولة اختبار الوظيفة بطريقة أخرى.  فيما يلي مثال على وظائف واختبارات لهم: </p><br><pre style=";text-align:right;direction:rtl"> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_false</span></span></span></span>(a: <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span> { !a } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_two</span></span></span></span>(a: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span> { a + <span class="hljs-number"><span class="hljs-number">2</span></span> } <span class="hljs-meta"><span class="hljs-meta">#[cfg(test)]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mod</span></span> test { <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> super::*; <span class="hljs-meta"><span class="hljs-meta">#[test]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_false_works</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">assert!</span></span>(is_false(<span class="hljs-literal"><span class="hljs-literal">false</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">assert!</span></span>(!is_false(<span class="hljs-literal"><span class="hljs-literal">true</span></span>)); } <span class="hljs-meta"><span class="hljs-meta">#[test]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_two_works</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>, add_two(-<span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>, add_two(<span class="hljs-number"><span class="hljs-number">0</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(<span class="hljs-number"><span class="hljs-number">4</span></span>, add_two(<span class="hljs-number"><span class="hljs-number">2</span></span>)); } }</code> </pre> <br><p style=";text-align:right;direction:rtl">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><em>اركض</em></a> </p><br><p style=";text-align:right;direction:rtl">  الوظائف في وحدة <code>test</code> ، المميزة بسمة <code>#[test]</code> ، هي اختبارات وحدة.  سيتم تنفيذها بالتوازي عندما يتم استدعاء أمر <code>cargo test</code> .  إن سمة <code>#[cfg(test)]</code> الشرطي <code>#[cfg(test)]</code> ، التي تحدد الوحدة بأكملها باختبارات ، ستؤدي إلى حقيقة أن الوحدة النمطية سيتم تجميعها فقط عند تنفيذ الاختبارات ، ولن تدخل في التجميع العادي. </p><br><p style=";text-align:right;direction:rtl">  من الملائم للغاية وضع الاختبارات في نفس الوحدة الوظيفية تحت الاختبار ، وذلك ببساطة عن طريق إضافة وحدة <code>test</code> الفرعية إليها.  وإذا كنت بحاجة إلى اختبارات التكامل ، فما عليك سوى وضع الاختبارات في دليل <code>tests</code> في جذر المشروع ، واستخدام تطبيقك فيها كحزمة خارجية.  لا يلزم إضافة وحدة <code>test</code> منفصلة وتوجيهات الترجمة الشرطية في هذه الحالة. </p><br><p style=";text-align:right;direction:rtl">  تستحق الأمثلة الخاصة للوثائق التي يتم تنفيذها كاختبارات اهتمامًا خاصًا ، ولكن سيتم مناقشة ذلك أدناه. </p><br><p style=";text-align:right;direction:rtl">  تتوفر أيضًا اختبارات الأداء المضمنة (المعايير) ، ولكنها ليست مستقرة بعد ، وبالتالي فهي متاحة فقط في التجميعات الليلية المجمعة.  في Rust Rust ، سيكون عليك استخدام مكتبات خارجية لهذا النوع من الاختبارات. </p><br><h2 id="4-horoshaya-dokumentaciya-s-aktualnymi-primerami" style=";text-align:right;direction:rtl">  4. توثيق جيد مع الأمثلة الحالية </h2><br><p style=";text-align:right;direction:rtl">  مكتبة Rust القياسية موثقة جيدًا.  يتم إنشاء وثائق HTML تلقائيًا من التعليمات البرمجية المصدر مع أوصاف تخفيض السعر في تعليقات المرسى.  علاوة على ذلك ، تحتوي تعليقات المستندات في رمز Rust على نموذج التعليمات البرمجية الذي يتم تنفيذه عند تشغيل الاختبارات.  وهذا يضمن ملاءمة الأمثلة: </p><br><pre style=";text-align:right;direction:rtl"> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">/// Returns a byte slice of this `String`'s contents. /// /// The inverse of this method is [`from_utf8`]. /// /// [`from_utf8`]: #method.from_utf8 /// /// # Examples /// /// Basic usage: /// /// ``` /// let s = String::from("hello"); /// /// assert_eq!(&amp;[104, 101, 108, 108, 111], s.as_bytes()); /// ``` #[inline] #[stable(feature = "rust1", since = "1.0.0")] pub fn as_bytes(&amp;self) -&gt; &amp;[u8] { &amp;self.vec }</span></span></code> </pre> <br><p style=";text-align:right;direction:rtl">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><em>التوثيق</em></a> </p><br><p style=";text-align:right;direction:rtl">  فيما يلي مثال على استخدام طريقة <code>as_bytes</code> من النوع <code>String</code> </p><br><pre style=";text-align:right;direction:rtl"> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> s = <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>::from(<span class="hljs-string"><span class="hljs-string">"hello"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(&amp;[<span class="hljs-number"><span class="hljs-number">104</span></span>, <span class="hljs-number"><span class="hljs-number">101</span></span>, <span class="hljs-number"><span class="hljs-number">108</span></span>, <span class="hljs-number"><span class="hljs-number">108</span></span>, <span class="hljs-number"><span class="hljs-number">111</span></span>], s.as_bytes());</code> </pre> <br><p style=";text-align:right;direction:rtl">  سيتم تنفيذه كاختبار أثناء إطلاق الاختبارات. </p><br><p style=";text-align:right;direction:rtl">  بالإضافة إلى ذلك ، فإن ممارسة إنشاء أمثلة على استخدامها في شكل برامج مستقلة صغيرة موجودة في دليل <code>examples</code> في جذر المشروع شائعة في مكتبات Rust.  تعتبر هذه الأمثلة أيضًا جزءًا مهمًا من التوثيق ويتم أيضًا تجميعها وتنفيذها أثناء التشغيل التجريبي ، ولكن يمكن تشغيلها بشكل مستقل عن الاختبارات. </p><br><h2 id="5-umnoe-avtovyvedenie-tipov" style=";text-align:right;direction:rtl">  5. خصم تلقائي ذكي للأنواع </h2><br><p style=";text-align:right;direction:rtl">  في برنامج Rust ، لا يمكنك تحديد نوع التعبير بشكل صريح إذا كان المترجم قادرًا على إخراجه تلقائيًا بناءً على سياق الاستخدام.  وهذا لا ينطبق فقط على تلك الأماكن حيث يتم التصريح عن المتغيرات.  دعونا نلقي نظرة على مثال: </p><br><pre style=";text-align:right;direction:rtl"> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> vec = <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>::new(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> text = <span class="hljs-string"><span class="hljs-string">"Message"</span></span>; vec.push(text);</code> </pre> <br><p style=";text-align:right;direction:rtl">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><em>اركض</em></a> </p><br><p style=";text-align:right;direction:rtl">  إذا قمنا بترتيب نوع التعليقات التوضيحية ، فسيبدو هذا المثال كما يلي: </p><br><pre style=";text-align:right;direction:rtl"> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> vec: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;&amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>&gt; = <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>::new(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> text: &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span> = <span class="hljs-string"><span class="hljs-string">"Message"</span></span>; vec.push(text);</code> </pre> <br><p style=";text-align:right;direction:rtl">  أي ، لدينا متجه لشرائح السلسلة ومتغير من نوع شريحة السلسلة.  ولكن في هذه الحالة ، يعد تحديد الأنواع متكررًا تمامًا ، حيث يمكن للمترجم إخراجها بنفسها (باستخدام النسخة الموسعة من خوارزمية <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">Hindley-Milner</a> ).  حقيقة أن <code>vec</code> هو ناقل واضح بالفعل من خلال نوع القيمة <code>Vec::new()</code> من <code>Vec::new()</code> ، ولكن لم يتضح بعد نوع عناصره.  حقيقة أن نوع <code>text</code> هو شريحة سلسلة أمر مفهوم من خلال حقيقة أنه تم تعيين حرفيا من هذا النوع.  وهكذا ، بعد <code>vec.push(text)</code> ، يصبح نوع عناصر المتجه واضحًا.  لاحظ أن نوع متغير <code>vec</code> تم تحديده بالكامل من خلال استخدامه في سلسلة التنفيذ ، وليس في مرحلة التهيئة. </p><br><p style=";text-align:right;direction:rtl">  يزيل مثل هذا النظام من نوع الاستدلال الضوضاء من التعليمات البرمجية ويجعلها موجزة مثل التعليمات البرمجية في بعض لغات البرمجة المكتوبة ديناميكيًا.  وهذا مع الحفاظ على كتابة ثابتة صارمة! </p><br><p style=";text-align:right;direction:rtl">  بالطبع ، لا يمكننا التخلص تمامًا من الكتابة بلغة مكتوبة بشكل ثابت.  يجب أن يحتوي البرنامج على نقاط يتم فيها ضمان معرفة أنواع الكائنات ، بحيث يمكن عرض هذه الأنواع في أماكن أخرى.  هذه النقاط في Rust هي إعلانات لأنواع البيانات المعرفة من قبل المستخدم والتوقيعات الوظيفية ، حيث لا يمكن للمرء إلا تحديد الأنواع المستخدمة.  ولكن يمكنك إدخال "المتغيرات الفوقية للأنواع" فيها ، باستخدام البرمجة المعممة. </p><br><h2 id="6-sopostavlenie-s-obrazcom-v-mestah-obyavleniya-peremennyh" style=";text-align:right;direction:rtl">  6. مطابقة النمط عند نقاط التصريح المتغيرة </h2><br><p style=";text-align:right;direction:rtl">  <code>let</code> العملية </p><br><pre style=";text-align:right;direction:rtl"> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> p = Point::new();</code> </pre> <br><p style=";text-align:right;direction:rtl">  لا يقتصر على مجرد الإعلان عن متغيرات جديدة.  ما تفعله بالفعل هو مطابقة التعبير على يمين علامة المساواة مع النمط الموجود على اليسار.  ويمكن إدخال متغيرات جديدة كجزء من العينة (وهكذا فقط).  نلقي نظرة على المثال التالي ، وسوف يصبح أكثر وضوحا لك: </p><br><pre style=";text-align:right;direction:rtl"> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> Point { x, y } = Point::new();</code> </pre> <br><p style=";text-align:right;direction:rtl">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><em>اركض</em></a> </p><br><p style=";text-align:right;direction:rtl">  يتم تنفيذ التدمير هنا: ستقدم هذه المقارنة المتغيرات <code>x</code> و <code>y</code> ، والتي سيتم تهيئتها بقيمة الحقول <code>x</code> و <code>y</code> لكائن بنية <code>Point</code> ، والتي يتم إرجاعها عن طريق استدعاء <code>Point::new()</code> .  في نفس الوقت ، تكون المقارنة صحيحة ، لأن نوع التعبير على اليمين يتوافق مع نمط <code>Point</code> من النوع <code>Point</code> على اليسار.  بطريقة مشابهة ، يمكنك أن تأخذ ، على سبيل المثال ، أول عنصرين من المصفوفة: </p><br><pre style=";text-align:right;direction:rtl"> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> [a, b, _] = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>];</code> </pre> <br><p style=";text-align:right;direction:rtl">  وأكثر من ذلك بكثير.  الشيء الأكثر بروزًا هو أن مثل هذه المقارنات يتم إجراؤها في جميع الأماكن حيث يمكن إدخال أسماء متغيرات جديدة في Rust ، وهي: في <code>match</code> ، <code>let</code> ، <code>if let</code> ، <code>while let</code> <code>if let</code> ، في رأس حلقة <code>for</code> ، في الحجج الخاصة بالوظائف والإغلاق.  في ما يلي مثال على استخدام الأنماط المتطابقة في حلقة للتكرار: </p><br><pre style=";text-align:right;direction:rtl"> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i, ch) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-string"><span class="hljs-string">"foo"</span></span>.chars().enumerate() { <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Index: {}, char: {}"</span></span>, i, ch); }</code> </pre> <br><p style=";text-align:right;direction:rtl">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><em>اركض</em></a> </p><br><p style=";text-align:right;direction:rtl">  طريقة <code>enumerate</code> ، التي تسمى بالمكرر ، تبني مكررًا جديدًا ، والذي سيكرر ليس القيم الأولية ، ولكن الصفوف ، أزواج "الفهرس الترتيبي ، القيمة الأولية".  سيتم تعيين كل من هذه الصفوف أثناء تكرار الدورة إلى النمط المحدد <code>(i, ch)</code> ، ونتيجة لذلك سيتلقى المتغير <code>i</code> القيمة الأولى من الصف - الفهرس والمتغير <code>ch</code> - الثاني ، أي حرف السلسلة.  علاوة على ذلك ، في جسم الحلقة يمكننا استخدام هذه المتغيرات. </p><br><p style=";text-align:right;direction:rtl">  مثال شائع آخر على استخدام نمط في حلقة <code>for</code> : </p><br><pre style=";text-align:right;direction:rtl"> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">5</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   5  }</span></span></code> </pre> <br><p style=";text-align:right;direction:rtl">  هنا نتجاهل ببساطة قيمة المكرر باستخدام النمط <code>_</code> .  لأننا لا نستخدم رقم التكرار في نص الحلقة.  يمكن فعل الشيء نفسه ، على سبيل المثال ، بحجة دالة: </p><br><pre style=";text-align:right;direction:rtl"> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(a: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, _: <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//      }</span></span></code> </pre> <br><p style=";text-align:right;direction:rtl">  أو عند المطابقة في عبارة <code>match</code> : </p><br><pre style=";text-align:right;direction:rtl"> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">match</span></span> p { Point { x: <span class="hljs-number"><span class="hljs-number">1</span></span>, .. } =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Point with x == 1 detected"</span></span>), Point { y: <span class="hljs-number"><span class="hljs-number">2</span></span>, .. } =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Point with x != 1 and y == 2 detected"</span></span>), _ =&gt; (), <span class="hljs-comment"><span class="hljs-comment">//        }</span></span></code> </pre> <br><p style=";text-align:right;direction:rtl">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><em>اركض</em></a> </p><br><p style=";text-align:right;direction:rtl">  مطابقة الأنماط تجعل الشفرة مضغوطة للغاية ومعبرة ، وفي بيان <code>match</code> لا يمكن الاستغناء عنها بشكل عام.  عامل <code>match</code> هو عامل التحليل التبايني الكامل ، لذلك لن تتمكن من نسيان الخطأ عن طريق التحقق من بعض التطابقات المحتملة للتعبير الذي تم تحليله فيه. </p><br><h2 id="7-rasshirenie-sintaksisa-i-polzovatelskie-dsl" style=";text-align:right;direction:rtl">  7. تمديد بناء الجملة و DSL مخصص </h2><br><p style=";text-align:right;direction:rtl">  بنية الصدأ محدودة ، ويرجع ذلك إلى حد كبير إلى تعقيد نظام النوع المستخدم في اللغة.  على سبيل المثال ، ليس لدى Rust وسيطات دالة أو دالات لها عدد متغير من الوسائط.  ولكن يمكنك تجاوز هذه القيود وغيرها باستخدام وحدات الماكرو.  يحتوي الصدأ على نوعين من وحدات الماكرو: تعريفية وإجرائية.  مع وحدات الماكرو التوضيحية ، لن تواجهك أبدًا نفس المشاكل كما لو كانت وحدات الماكرو في لغة C ، لأنها صحية ولا تعمل على مستوى استبدال النص ، ولكن على مستوى الاستبدال في شجرة بناء الجملة المجردة.  تتيح لك وحدات الماكرو إنشاء ملخصات على مستوى بناء الجملة اللغوي.  على سبيل المثال: </p><br><pre style=";text-align:right;direction:rtl"> <code class="rust hljs"><span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Hello, {name}! Do you know about {}?"</span></span>, <span class="hljs-number"><span class="hljs-number">42</span></span>, name = <span class="hljs-string"><span class="hljs-string">"User"</span></span>);</code> </pre> <br><p style=";text-align:right;direction:rtl">  بالإضافة إلى حقيقة أن هذا الماكرو يوسع القدرات النحوية لاستدعاء "وظيفة" طباعة سلسلة منسقة ، فإنه سيتحقق أيضًا في تنفيذه من أن وسيطات الإدخال تتطابق مع سلسلة التنسيق المحددة في وقت الترجمة ، وليس في وقت التشغيل.  باستخدام وحدات الماكرو ، يمكنك إدخال بناء جملة موجز لاحتياجات التصميم الخاصة بك ، وإنشاء واستخدام DSL.  فيما يلي مثال على استخدام كود JavaScript داخل برنامج Rust مترجم في Wasm: </p><br><pre style=";text-align:right;direction:rtl"> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name = <span class="hljs-string"><span class="hljs-string">"Bob"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result = js! { var msg = <span class="hljs-string"><span class="hljs-string">"Hello from JS, "</span></span> + @{name} + <span class="hljs-string"><span class="hljs-string">"!"</span></span>; console.log(msg); alert(msg); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>; }; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"2 + 2 = {:?}"</span></span>, result);</code> </pre> <br><p style=";text-align:right;direction:rtl">  <code>js!</code> الماكرو <code>js!</code>  محدد في حزمة <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><code>stdweb</code></a> ويسمح لك بتضمين شفرة جافا سكريبت كاملة في برنامجك (باستثناء السلاسل أحادية الاقتباس والعوامل غير المكتملة بفاصلة منقوطة) واستخدام كائنات من شفرة Rust باستخدام بناء الجملة <code>@{expr}</code> . </p><br><p style=";text-align:right;direction:rtl">  تقدم وحدات الماكرو فرصًا هائلة لتكييف بنية برامج Rust مع المهام المحددة لمجال معين.  سيوفر وقتك واهتمامك عند تطوير التطبيقات المعقدة.  ليس عن طريق زيادة وقت التشغيل ، ولكن عن طريق زيادة وقت التجميع.  :) </p><br><h2 id="8-avtogeneraciya-zavisimogo-koda" style=";text-align:right;direction:rtl">  8. التوليد التلقائي للشفرة التابعة </h2><br><p style=";text-align:right;direction:rtl">  تُستخدم وحدات الماكرو المشتقة من Rust على نطاق واسع لتنفيذ السمات تلقائيًا وتوليد التعليمات البرمجية الأخرى.  هنا مثال: </p><br><pre style=";text-align:right;direction:rtl"> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[derive(Copy, Clone, Debug, Default, PartialEq, Eq)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span></span> { x: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, y: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, }</code> </pre> <br><p style=";text-align:right;direction:rtl">  نظرًا لأن جميع هذه الأنواع ( <code>Copy</code> و <code>Clone</code> و <code>Debug</code> و <code>Default</code> و <code>PartialEq</code> و <code>PartialEq</code> ) من المكتبة القياسية يتم تنفيذها لنوع حقول بنية <code>i32</code> ، يمكن عرض تنفيذها تلقائيًا للبنية بأكملها ككل.  مثال آخر: </p><br><pre style=";text-align:right;direction:rtl"> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> serde_derive; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> serde_json; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> serde_derive::{Serialize, Deserialize}; <span class="hljs-meta"><span class="hljs-meta">#[derive(Serialize, Deserialize)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span></span> { x: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, y: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> point = Point { x: <span class="hljs-number"><span class="hljs-number">1</span></span>, y: <span class="hljs-number"><span class="hljs-number">2</span></span> }; <span class="hljs-comment"><span class="hljs-comment">//  Point  JSON . let serialized = serde_json::to_string(&amp;point).unwrap(); assert_eq!("{\"x\":1,\"y\":2}", serialized); //  JSON   Point. let deserialized: Point = serde_json::from_str(&amp;serialized).unwrap();</span></span></code> </pre> <br><p style=";text-align:right;direction:rtl">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><em>اركض</em></a> </p><br><p style=";text-align:right;direction:rtl">  هنا ، باستخدام <code>Deserialize</code> and <code>Deserialize</code> من مكتبة <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><code>serde</code></a> لبنية <code>Point</code> ، يتم إنشاء طرق تسلسلها <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><code>serde</code></a> تسلسلها تلقائيًا.  بعد ذلك ، يمكنك تمرير مثيل من هذه البنية إلى العديد من وظائف التسلسل ، على سبيل المثال ، تحويلها إلى سلسلة JSON. </p><br><p style=";text-align:right;direction:rtl">  يمكنك إنشاء وحدات الماكرو الإجرائية الخاصة بك التي ستنشئ التعليمات البرمجية التي تحتاجها.  أو استخدم العديد من وحدات الماكرو التي تم إنشاؤها بالفعل من قبل المطورين الآخرين.  بالإضافة إلى حفظ المبرمج من كتابة شفرة مرجعية ، تتمتع وحدات الماكرو أيضًا بميزة أنك لا تحتاج إلى الحفاظ على أقسام مختلفة من التعليمات البرمجية في حالة متسقة.  على سبيل المثال ، إذا تمت إضافة حقل ثالث <code>z</code> إلى بنية <code>Point</code> ، فعندئذ قم بإجراء التسلسل بشكل صحيح ، إذا كنت تستخدم المشتق ، فلن تحتاج إلى القيام بأي شيء آخر.  إذا قمنا بأنفسنا بتنفيذ الصفات اللازمة لتسلسل <code>Point</code> ، فسيتعين علينا التأكد من أن هذا التطبيق متسق دائمًا مع أحدث التغييرات في بنية <code>Point</code> . </p><br><h2 id="9-algebraicheskiy-tip-dannyh" style=";text-align:right;direction:rtl">  9. نوع البيانات الجبرية </h2><br><p style=";text-align:right;direction:rtl">  ببساطة ، نوع البيانات الجبرية هو نوع بيانات مركب هو اتحاد الهياكل.  بشكل أكثر رسمية ، هو نوع من أنواع المنتجات.  في الصدأ ، يتم تعريف هذا النوع باستخدام الكلمة <code>enum</code> : </p><br><pre style=";text-align:right;direction:rtl"> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Message</span></span></span></span> { Quit, ChangeColor(<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>), Move { x: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, y: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span> }, Write(<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>), }</code> </pre> <br><p style=";text-align:right;direction:rtl">  يمكن أن يكون نوع قيمة معينة لمتغير من نوع <code>Message</code> واحدًا فقط من أنواع البنية المدرجة في <code>Message</code> .  هذا إما هيكل <code>Quit</code> بدون حقل شبيه بالوحدة ، أو أحد هياكل <code>ChangeColor</code> أو <code>Write</code> مجموعة tuple مع حقول مجهولة الاسم ، أو بنية <code>Move</code> المعتادة.  يمكن تمثيل نوع تعداد تقليدي كحالة خاصة لنوع بيانات جبري: </p><br><pre style=";text-align:right;direction:rtl"> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Color</span></span></span></span> { Red, Green, Blue, White, Black, Unknown, }</code> </pre> <br><p style=";text-align:right;direction:rtl">  من الممكن معرفة النوع الذي أخذ قيمة بالفعل في حالة معينة باستخدام مطابقة الأنماط: </p><br><pre style=";text-align:right;direction:rtl"> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> color: Color = get_color(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> text = <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> color { Color::Red =&gt; <span class="hljs-string"><span class="hljs-string">"Red"</span></span>, Color::Green =&gt; <span class="hljs-string"><span class="hljs-string">"Green"</span></span>, Color::Blue =&gt; <span class="hljs-string"><span class="hljs-string">"Blue"</span></span>, _ =&gt; <span class="hljs-string"><span class="hljs-string">"Other color"</span></span>, }; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, text); ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process_message</span></span></span></span>(msg: Message) { <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> msg { Message::Quit =&gt; quit(), Message::ChangeColor(r, g, b) =&gt; change_color(r, g, b), Message::Move { x, y } =&gt; move_cursor(x, y), Message::Write(s) =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, s), }; }</code> </pre> <br><p style=";text-align:right;direction:rtl">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><em>اركض</em></a> </p><br><p style=";text-align:right;direction:rtl">  في شكل أنواع البيانات الجبرية ، يطبق الصدأ أنواعًا مهمة مثل <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><code>Option</code></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><code>Result</code></a> ، والتي تستخدم لتمثيل القيمة المفقودة والنتيجة الصحيحة / الخاطئة ، على التوالي.  إليك كيفية تعريف <code>Option</code> في المكتبة القياسية: </p><br><pre style=";text-align:right;direction:rtl"> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Option</span></span></span></span>&lt;T&gt; { <span class="hljs-literal"><span class="hljs-literal">None</span></span>, <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(T), }</code> </pre> <br><p style=";text-align:right;direction:rtl">  لا يحتوي الصدأ على قيمة فارغة ، تمامًا مثل الأخطاء المزعجة لمكالمة غير متوقعة إليه.  بدلاً من ذلك ، عندما يكون من الضروري حقًا الإشارة إلى إمكانية وجود قيمة مفقودة ، <code>Option</code> استخدام <code>Option</code> : </p><br><pre style=";text-align:right;direction:rtl"> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">divide</span></span></span></span>(numerator: <span class="hljs-built_in"><span class="hljs-built_in">f64</span></span>, denominator: <span class="hljs-built_in"><span class="hljs-built_in">f64</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">f64</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> denominator == <span class="hljs-number"><span class="hljs-number">0.0</span></span> { <span class="hljs-literal"><span class="hljs-literal">None</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(numerator / denominator) } } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result = divide(<span class="hljs-number"><span class="hljs-number">2.0</span></span>, <span class="hljs-number"><span class="hljs-number">3.0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> result { <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(x) =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Result: {}"</span></span>, x), <span class="hljs-literal"><span class="hljs-literal">None</span></span> =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Cannot divide by 0"</span></span>), }</code> </pre> <br><p style=";text-align:right;direction:rtl">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><em>اركض</em></a> </p><br><p style=";text-align:right;direction:rtl">  نوع البيانات الجبرية هو أداة قوية ومعبرة تفتح الباب أمام تطوير مدفوع بالنوع.  يعين برنامج مكتوب بكفاءة في هذا النموذج معظم عمليات التحقق من صحة عمله لنظام النوع.  لذلك ، إذا كنت تفتقر إلى القليل من Haskell في البرمجة الصناعية اليومية ، يمكن أن يكون Rust هو منفذك.  :) </p><br><h2 id="10-legkiy-refaktoring" style=";text-align:right;direction:rtl">  10. إعادة بيع ديون سهلة </h2><br><p style=";text-align:right;direction:rtl">  يؤدي نظام النوع الثابت المطوّر في Rust ومحاولة إجراء أكبر عدد ممكن من الفحوصات أثناء التجميع إلى حقيقة أن تعديل الرمز وإعادة هيكلته يصبح بسيطًا وآمنًا.  إذا تم ، بعد التغييرات ، تجميع البرنامج ، فهذا يعني أنه ترك فقط أخطاء منطقية لا تتعلق بالوظيفة التي تم تعيين التحقق منها للمترجم.  إلى جانب سهولة إضافة اختبارات الوحدة لاختبار المنطق ، يؤدي هذا إلى ضمانات جدية لموثوقية البرامج وزيادة ثقة المبرمج في التشغيل الصحيح لشفرته بعد إجراء التغييرات. </p><br><hr><br><p style=";text-align:right;direction:rtl">  ربما هذا هو كل ما أردت التحدث عنه في هذه المقالة.  بالطبع ، تتمتع رست بالعديد من المزايا الأخرى ، بالإضافة إلى عدد من العوائق (بعض الرطوبة في اللغة ، ونقص التعابير المألوفة في البرمجة ، وبناء الجملة "غير الأدبي") ، والتي لم يتم ذكرها هنا.  إذا كان لديك ما تقوله عنهم ، فاكتب في التعليقات.  بشكل عام ، جرب الصدأ عمليًا.  وربما تفوق مزاياه بالنسبة لك على جميع عيوبه ، كما حدث في حالتي.  وأخيرًا ، ستحصل على مجموعة الأدوات التي تحتاجها لفترة طويلة. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/ar430294/">https://habr.com/ru/post/ar430294/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar430282/index.html">يوافق 9 من كل 10 أشخاص على كسب القليل مقابل عمل ذي معنى</a></li>
<li><a href="../ar430284/index.html">ملخص المواد المثيرة للاهتمام لمطور الجوال رقم 275 (12 - 18 نوفمبر)</a></li>
<li><a href="../ar430286/index.html">تفاصيل الجانب الفوضوي والمظلم لألعاب القراصنة لـ Nintendo Switch</a></li>
<li><a href="../ar430290/index.html">محاولة للتنبؤ بالتكرار الرابع لمشروع SpaceX BFR</a></li>
<li><a href="../ar430292/index.html">مؤسسة الحدود الإلكترونية: أداء شبكة لوحة ترخيص الشرطة الأمريكية 0.5٪</a></li>
<li><a href="../ar430296/index.html">اجعل أفكارك تأتي التطبيق. تطبيق بدون خادم - تعليمات خطوة بخطوة</a></li>
<li><a href="../ar430300/index.html">Microservices on Go مع مجموعة Go: مقدمة</a></li>
<li><a href="../ar430302/index.html">مقدمة عن ptrace أو إدخال الرمز في sshd من أجل المتعة</a></li>
<li><a href="../ar430304/index.html">موقع رائع في المدار</a></li>
<li><a href="../ar430306/index.html">النفق الأول لشركة مملة حفر بواسطة إيلونا ماسك</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>