<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧑🏽‍🤝‍🧑🏼 🔟 🌕 À propos de l'anonymat dans les chaînes de blocs basées sur les comptes 🥟 🚚 🌾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nous nous intéressons depuis longtemps au sujet de l'anonymat dans les crypto-monnaies et essayons de suivre le développement des technologies dans ce...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>À propos de l'anonymat dans les chaînes de blocs basées sur les comptes</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/exante/blog/452184/">  Nous nous intéressons depuis longtemps au sujet de l'anonymat dans les crypto-monnaies et essayons de suivre le développement des technologies dans ce domaine.  Dans nos articles, nous avons déjà examiné en détail les principes de fonctionnement des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">transactions confidentielles</a> dans Monero, et également effectué une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">revue comparative des</a> technologies qui existent dans ce domaine.  Cependant, toutes les crypto-monnaies anonymes sont aujourd'hui construites sur le modèle de données proposé par Bitcoin - Sortie de transaction non dépensée (ci-après UTXO).  Pour les chaînes de blocs basées sur des comptes comme Ethereum, les solutions existantes pour la mise en œuvre de l'anonymat et de la confidentialité (par exemple, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Mobius</a> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Aztec</a> ) ont essayé de répéter le modèle UTXO dans les contrats intelligents. <br><br>  En février 2019, un groupe de chercheurs de l'Université de Stanford et de Visa Research <a name="habracut"></a>  a publié la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">préimpression</a> «Zether: vers la confidentialité dans le monde des contrats intelligents».  Les auteurs ont d'abord proposé une approche pour garantir l'anonymat dans les chaînes de blocs basées sur les comptes et ont présenté deux options pour un contrat intelligent: pour les transactions confidentielles (masquage des soldes et des montants de transfert) et anonymes (masquage des destinataires et des expéditeurs).  Nous trouvons la technologie proposée intéressante et aimerions partager son appareil, ainsi que discuter pourquoi le problème d'anonymat dans les blockchains basées sur les comptes est considéré comme très complexe et si les auteurs ont réussi à le résoudre dans son intégralité. <br><br><cut></cut><br><br><h3>  À propos de l'appareil de ces modèles de données </h3><br>  Dans le modèle UTXO, une transaction comprend des «entrées» et des «sorties».  Un analogue direct des «sorties» est le billet de banque dans votre portefeuille: chaque «sortie» a une certaine dénomination.  Lorsque vous payez avec quelqu'un (formez une transaction), vous dépensez une ou plusieurs «sorties», alors qu'elles deviennent des «entrées» de la transaction, et la blockchain les marque comme dépensées.  Dans le même temps, le destinataire de votre paiement (ou vous-même, si vous avez besoin d'un changement) reçoit les «sorties» nouvellement générées.  Schématiquement, cela peut être représenté comme suit: <br><br><img src="https://habrastorage.org/webt/tj/ed/8o/tjed8olalcrirbjpupoms6bwejo.png" alt="image"><br><br>  Les blockchains basées sur un compte sont structurées comme votre compte bancaire.  Ils n'opèrent que sur le montant de votre compte et le montant du virement.  Lorsque vous transférez un certain montant depuis votre compte, vous ne gravez aucune «sortie», le réseau n'a pas besoin de se rappeler quelles pièces sont dépensées et lesquelles ne le sont pas.  Dans le cas le plus simple, la vérification d'une transaction se réduit à vérifier la signature de l'expéditeur et le montant de son bilan: <br><br><img src="https://habrastorage.org/webt/kw/pg/zn/kwpgzn1wg1mmztznetqntcdfbca.png" alt="image"><br><br><h3>  Analyse technologique </h3><br>  Ensuite, nous parlerons de la façon dont Zether masque le montant des transactions, le destinataire et l'expéditeur.  Au cours de la description des principes de son travail, nous noterons les différences de version confidentielle et anonyme.  Étant donné que garantir la confidentialité dans les chaînes de blocs basées sur les comptes est beaucoup plus simple, certaines des restrictions imposées par l'anonymisation ne seront pas pertinentes pour une version confidentielle de la technologie. <br><br><h4>  Dissimulation des soldes et des montants de transfert </h4><br>  Zether utilise le schéma de cryptage <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">El Gamal</a> pour crypter les soldes et les montants de transfert.  Cela fonctionne comme suit.  Quand Alice veut envoyer des pièces Bob <i><b>b</b></i> à l'adresse (sa clé publique) <i><b>Y</b></i> , elle choisit un nombre aléatoire <i><b>r</b></i> et chiffre le montant: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ky/t6/3x/kyt63xxqcoleppvesgfpoubyj8y.png" alt="image"></div><br>  où <i><b>C</b></i> est la somme chiffrée, <i><b>D</b></i> est la valeur auxiliaire nécessaire pour déchiffrer cette somme, <i><b>G</b></i> est le point fixe sur la courbe elliptique, lorsque la clé secrète est multipliée par laquelle la clé publique est obtenue. <br><br>  Lorsque Bob reçoit ces valeurs, il les ajoute simplement à son solde, chiffré de la même manière, ce qui est pratique pour ce schéma. <br><br>  De même, Alice soustrait les mêmes valeurs de son bilan, utilise uniquement <i><b>Y</b></i> comme clé publique. <br><br><h4>  Dissimulation du destinataire et de l'expéditeur </h4><br>  Le mélange des «sorties» dans UTXO est apparu à l'aube des crypto-monnaies et permet de cacher l'expéditeur.  Pour ce faire, l'expéditeur, lors d'un transfert, recueille des «sorties» aléatoires dans la blockchain et les pétrit avec les siennes.  Il signe ensuite les «sorties» avec une signature en anneau - un mécanisme cryptographique qui lui permet de convaincre le vérificateur que parmi les «sorties» impliquées, il y a des pièces émettrices.  Les pièces impliquées elles-mêmes, bien sûr, ne sont pas gaspillées. <br><br>  Cependant, pour cacher le destinataire, nous ne serons pas en mesure de générer de fausses «sorties».  Par conséquent, dans UTXO, chaque «sortie» a sa propre adresse unique, et elle est associée cryptographiquement à l'adresse du destinataire de ces pièces.  Pour le moment, il n'y a aucun moyen d'identifier la relation entre l'adresse unique de «sortie» et l'adresse du destinataire sans connaître ses clés secrètes. <br><br>  Dans un modèle basé sur un compte, nous ne pouvons pas utiliser d'adresses uniques (sinon ce sera déjà un modèle de "sorties").  Par conséquent, le destinataire et l'expéditeur doivent être pétris parmi d'autres comptes dans la blockchain.  Dans le même temps, les pièces cryptées 0 sont débitées des comptes malaxés (ou 0 est ajouté - dans le cas d'un destinataire malaxé), sans pour autant modifier réellement leur solde réel. <br><br>  Étant donné que l'expéditeur et le destinataire ont toujours une adresse permanente, il devient alors nécessaire d'utiliser les mêmes groupes pour mélanger aux mêmes adresses.  Il est plus facile de considérer cela avec un exemple. <br><br>  Supposons qu'Alice décide de contribuer à la charité de Bob, mais préfère que le transfert reste anonyme pour un observateur extérieur.  Ensuite, afin de se déguiser dans le champ de l'expéditeur, elle entre également dans les comptes Adam et Adele.  Et pour cacher Bob - dans le champ destinataire en plus des comptes Ben et Bill.  En faisant le prochain versement, Alice a décidé d'entrer Alex et Amanda à côté d'elle, et Bruce et Bengen à côté de Bob.  Dans ce cas, lors de l'analyse de la chaîne de blocs dans ces deux transactions, il n'y a qu'une seule paire de participants qui se croisent - Alice et Bob, qui désanonymise ces transactions. <br><br><img src="https://habrastorage.org/webt/dj/o6/x0/djo6x0r31q3_bzpa78t0cklzt_i.png" alt="image"><br><br><h4>  Transaction Racing </h4><br>  Comme nous l'avons déjà mentionné, afin de masquer son solde dans les systèmes basés sur les comptes, l'utilisateur chiffre son solde et le montant du virement.  De plus, il doit prouver que le solde de son compte reste non négatif.  Le problème est que lors de la formation d'une transaction, l'utilisateur crée des preuves concernant son état actuel du compte.  Et que se passe-t-il si Bob envoie une transaction à Alice et qu'elle sera acceptée plus tôt que celle envoyée par Alice?  La transaction d'Alice sera alors considérée comme non valide, car la preuve de l'équilibre a été établie avant l'adoption de la transaction Bob. <br><br><img src="https://habrastorage.org/webt/bn/d0/7z/bnd07z43bu5m76fbbvjlvda7ek0.png" alt="image"><br><br>  La première solution qui se présente dans une telle situation est de geler votre compte avant la transaction.  Mais cette approche n'est pas appropriée, car en plus de la complexité de résoudre un tel problème dans un système distribué, dans un schéma anonyme, il ne sera pas clair de savoir à qui bloquer. <br><br>  Pour résoudre ce problème, la technologie sépare les transactions entrantes et sortantes: dépenser de l'argent a un effet immédiat sur le bilan et les revenus sont différés.  Pour cela, le concept d '«ère» est introduit - un groupe de blocs de taille fixe.  L '«ère» actuelle est déterminée en divisant la hauteur du bloc par la taille du groupe.  En traitant la transaction, le réseau met immédiatement à jour le solde de l'expéditeur et ajoute les fonds du destinataire au lecteur.  Les fonds accumulés ne sont disponibles pour le bénéficiaire que lorsqu'une nouvelle «ère» s'installe. <br><br>  En conséquence, l'utilisateur peut envoyer des transactions quelle que soit la fréquence à laquelle il reçoit des fonds (dans la mesure où son solde le permet, bien sûr).  La taille d'une époque est déterminée en fonction de la rapidité avec laquelle les blocs se propagent sur le réseau et de la rapidité avec laquelle la transaction tombe dans le bloc. <br><br>  Cette solution fonctionne bien dans le cas de transferts confidentiels, mais avec des transactions anonymes, comme nous le verrons plus loin, cela crée de sérieux problèmes. <br><br><h4>  Rejouer la protection contre les attaques </h4><br>  Dans les chaînes de blocs basées sur les comptes, chaque transaction est signée par la clé privée de l'expéditeur, qui convainc le vérificateur que la transaction n'a pas été modifiée et a été créée par le propriétaire de cette clé.  Mais que se passe-t-il si l'attaquant qui écoutait le canal de transmission intercepte ce message et envoie exactement la même seconde?  Le vérificateur vérifiera la signature de la transaction et sera convaincu de sa paternité, et le réseau débitera à nouveau le même montant du solde de l'expéditeur. <br><br>  Cette attaque est appelée attaque de rejeu.  Dans le modèle UTXO, de telles attaques ne sont pas pertinentes, car l'attaquant tentera d'utiliser les sorties dépensées, ce qui en soi n'est pas valide et est rejeté par le réseau. <br><br>  Pour éviter que cela ne se produise, un champ de données aléatoires est inséré dans la transaction, qui est appelé nonce ou simplement «sel».  Lors de la nouvelle soumission d'une transaction avec un sel, le réviseur vérifie si ce nonce a déjà été utilisé et, dans le cas contraire, considère que cette transaction est valide.  Afin de ne pas stocker tout l'historique des utilisateurs nonce sur la blockchain, il est généralement considéré comme nul lors de la toute première transaction, puis augmenté d'une unité.  Le réseau ne peut que vérifier que le nonce de la nouvelle transaction diffère du passé d'une unité. <br><br>  Dans un schéma de traduction anonyme, le problème de la validation des transactions nonce se pose.  Nous ne pouvons pas lier explicitement nonce à l'adresse de l'expéditeur, car, évidemment, cela désanonymise la traduction.  Nous ne pouvons pas non plus en ajouter un au nonce de tous les comptes participants, car cela peut entrer en conflit avec d'autres traductions en cours de traitement. <br><br>  Les auteurs de Zether proposent de générer du nonce cryptographiquement - en fonction de "l'ère".  Par exemple: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/5q/ku/zu/5qkuzus5hr-5168x4ieihiwtbjw.png" alt="image"></div><br>  Ici <b><i>x</i></b> est la clé secrète de l'expéditeur, et <b><i>G <sub>epoch</sub></i></b> est un générateur supplémentaire pour l'époque, obtenu en hachant une chaîne de la forme «Zether +».  Maintenant, le problème, semble-t-il, est en train d'être résolu - nous ne divulguons pas le nonce de l'expéditeur et n'interférons pas avec le nonce des participants non impliqués.  Mais cette approche impose une sérieuse limitation: un compte ne peut envoyer plus d'une transaction à «l'ère».  Ce problème, malheureusement, n'est toujours pas résolu et rend actuellement une version anonyme de Zether, à notre avis, difficilement utilisable. <br><br><h4>  Preuve de confiance zéro </h4><br>  En UTXO, l'expéditeur doit prouver au réseau qu'il ne dépense pas un montant négatif, sinon il devient possible de générer de nouvelles pièces de l'air (pourquoi cela était possible, nous l'avons écrit dans l'un des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">articles</a> précédents).  Et signez également les «entrées» avec une signature en anneau pour prouver que parmi les pièces à pétrir, il y a des fonds qui lui appartiennent. <br><br>  Dans la version anonyme de la blockchain basée sur les comptes, les expressions de preuve sont beaucoup plus compliquées.  L'expéditeur prouve que: <br><br><ol><li>  Le montant envoyé est positif; </li><li>  Le solde reste non négatif; </li><li>  L'expéditeur a correctement chiffré le montant des transferts (y compris zéro); </li><li>  Le solde du solde est modifié uniquement par l'expéditeur et le destinataire; </li><li>  L'expéditeur possède la clé secrète de son compte et il est vraiment dans la liste des expéditeurs (parmi ceux impliqués); </li><li>  Le nonce utilisé dans la transaction est correctement composé. </li></ol><br>  Pour une preuve aussi complexe, les auteurs utilisent un mélange de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Bulletproof</a> (l'un des auteurs a d'ailleurs participé à sa création) et du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">protocole Sigma</a> , qui s'appelle Sigma-bullets.  La preuve formelle d'une telle déclaration est une tâche assez difficile, et elle limite considérablement le nombre de personnes qui souhaitent se lancer dans la mise en œuvre de la technologie. <br><br><h4>  Quel est le résultat? </h4><br>  À notre avis, la partie de Zether, qui ajoute de la confidentialité aux chaînes de blocs basées sur les comptes, pourrait bien être utilisée maintenant.  Mais pour le moment, une version anonyme de la technologie impose de sérieuses restrictions à son utilisation et à sa complexité de mise en œuvre.  Cependant, n'oubliez pas que les auteurs l'ont publié il y a seulement quelques mois, et peut-être que quelqu'un d'autre trouvera une solution aux problèmes aujourd'hui.  En effet, c'est ainsi que la science se fait. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr452184/">https://habr.com/ru/post/fr452184/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr452172/index.html">Systèmes complexes. Atteindre un niveau critique</a></li>
<li><a href="../fr452174/index.html">Il n'a pas besoin de toi</a></li>
<li><a href="../fr452178/index.html">Analyse: 23 erreurs populaires en anglais écrit et comment les éviter</a></li>
<li><a href="../fr452180/index.html">Nous augmentons les performances des SSD des genoux, où cliquer et pourquoi</a></li>
<li><a href="../fr452182/index.html">Enquête auprès des employés. L'erreur principale</a></li>
<li><a href="../fr452186/index.html">Les langages de programmation les plus rares et les plus chers</a></li>
<li><a href="../fr452188/index.html">Test d'unité de sérialisation Json dans Spring Boot</a></li>
<li><a href="../fr452190/index.html">Utilisation de WebAssembly 20x Web Application Accelerated</a></li>
<li><a href="../fr452192/index.html">Qu'est-ce que c'est ici? Fonctionnement interne des objets JavaScript</a></li>
<li><a href="../fr452198/index.html">Que devrait savoir chaque ingénieur QA à propos de Selenium 4?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>