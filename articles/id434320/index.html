<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üí¨ ‚ùì üóÑÔ∏è Bagaimana kami menguji Sberbank Online di iOS ü¶í üëºüèø ‚úåüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pada artikel sebelumnya, kami berkenalan dengan piramida pengujian dan manfaat pengujian otomatis. Tetapi teori biasanya berbeda dari praktik. Hari in...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana kami menguji Sberbank Online di iOS</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/sberbank/blog/434320/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/rf/a1/ju/rfa1ju6fy69h4mfvjjr6rd2tw2u.jpeg"></div><br><br>  Pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel sebelumnya,</a> kami berkenalan dengan piramida pengujian dan manfaat pengujian otomatis.  Tetapi teori biasanya berbeda dari praktik.  Hari ini kami ingin berbicara tentang pengalaman kami dalam menguji kode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">aplikasi yang</a> digunakan oleh jutaan pengguna iOS.  Dan juga tentang jalur sulit yang harus dilalui tim kami untuk mencapai kode stabil. <br><br>  Situasinya adalah ini: misalkan pengembang berhasil meyakinkan diri mereka sendiri dan bisnis kebutuhan untuk menutupi basis kode dengan tes.  Seiring waktu, proyek ini telah menjadi lebih dari selusin ribu unit - dan lebih dari seribu tes UI.  Basis uji yang begitu besar memunculkan beberapa masalah, solusi yang ingin kami sampaikan. <br><br>  Di bagian pertama artikel, kita akan berkenalan dengan kesulitan yang muncul saat bekerja dengan tes unit bersih (non-integrasi), di bagian kedua kita akan mempertimbangkan tes UI.  Untuk mengetahui bagaimana kami meningkatkan stabilitas uji coba, selamat datang di Cat. <br><a name="habracut"></a><br>  Dalam dunia yang ideal, dengan kode sumber yang tidak berubah, tes unit harus selalu menunjukkan hasil yang sama, terlepas dari jumlah dan urutan awal.  Dan tes yang terus-menerus jatuh seharusnya tidak melewati penghalang Continuous Integration server (CI). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ad/ov/l7/adovl78pnaoa27omkrcqpugikdc.jpeg"></div><br>  Pada kenyataannya, seseorang mungkin menemukan fakta bahwa unit-test yang sama akan menunjukkan hasil positif atau negatif - yang berarti "berkedip".  Alasan perilaku ini terletak pada implementasi yang buruk dari kode tes.  Selain itu, tes semacam itu dapat lulus CI dengan menjalankan yang sukses, dan kemudian akan mulai jatuh pada Tarik Permintaan orang lain (PR).  Dalam situasi yang serupa, ada keinginan untuk menonaktifkan tes ini atau memainkan roulette dan menjalankan CI run lagi.  Namun, pendekatan ini anti-produktif, karena merusak kredibilitas tes dan memuat CI dengan pekerjaan yang tidak berarti. <br><br>  Masalah ini disorot tahun ini di konferensi internasional WWDC Apple: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sesi</a> ini berbicara tentang pengujian paralel, analisis cakupan kode target individu dengan tes, dan juga tentang urutan tes yang berjalan. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Di sini</a> Apple berbicara tentang pengujian permintaan jaringan, peretasan, pengujian pemberitahuan dan kecepatan pengujian. </li></ul><br><h4>  Tes unit </h4><br>  Untuk memerangi tes yang berkedip, kami menggunakan urutan tindakan berikut: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/636/25f/226/63625f226b610e87e94e088f4444aedb.png" alt="gambar"><br><br>  0. Kami mengevaluasi kode uji kualitas sesuai dengan kriteria dasar: isolasi, kebenaran moka, dll.  Kami mengikuti aturan: dengan tes yang berkedip, kami mengubah kode tes, dan bukan kode tes. <br><br>  Jika item ini tidak membantu, maka lakukan sebagai berikut: <br><br>  1. Kami memperbaiki dan mereproduksi kondisi di mana tes jatuh; <br>  2. Temukan alasan mengapa jatuh; <br>  3. Ubah kode uji atau kode uji; <br>  4. Pergi ke langkah pertama dan periksa apakah penyebab kejatuhan telah dieliminasi. <br><br><h4>  Mainkan jatuh </h4><br>  Opsi paling sederhana dan paling jelas adalah menjalankan tes masalah pada versi iOS yang sama dan pada perangkat yang sama.  Sebagai aturan, dalam hal ini tes berhasil, dan muncul pemikiran: "Semuanya bekerja untuk saya secara lokal, saya akan memulai kembali perakitan pada CI".  Itu sebenarnya masalah belum terselesaikan, dan tes terus jatuh ke orang lain. <br><br>  Oleh karena itu, pada langkah verifikasi berikutnya, Anda harus menjalankan semua tes unit aplikasi secara lokal untuk mengidentifikasi dampak potensial dari satu tes pada tes lainnya.  Tetapi bahkan setelah verifikasi semacam itu, hasil tes Anda mungkin positif, tetapi masalahnya tetap tidak terdeteksi. <br><br>  Jika seluruh urutan pengujian berhasil dan penurunan yang diharapkan tidak dicatat, Anda dapat mengulangi proses tersebut beberapa kali secara signifikan. <br>  Untuk melakukan ini, pada baris perintah, Anda perlu menjalankan loop dengan xcodebuild: <br><br><pre><code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#! /bin/sh x=0 while [ $x -le 100 ]; do xcodebuild -configuration Debug -scheme </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"TargetScheme"</span></span></span><span class="hljs-meta"> -workspace App.wcworkspace -sdk iphonesimulator -destination </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"platfrom=iOS Simulator, OS=11.3, name=iPhone 7"</span></span></span><span class="hljs-meta"> test &gt;&gt; </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"report.txt"</span></span></span><span class="hljs-meta">; x=$(( $x +1 )); done</span></span></code> </pre> <br>  Sebagai aturan, ini cukup untuk mereproduksi jatuhnya dan beralih ke langkah berikutnya - mengidentifikasi penyebab jatuhnya yang tercatat. <br><br><h4>  Alasan kejatuhan dan kemungkinan solusi </h4><br>  Pertimbangkan penyebab utama berkedipnya unit-tes yang mungkin Anda temui dalam pekerjaan Anda, alat untuk mengidentifikasi mereka, dan kemungkinan solusi. <br><br>  Ada tiga kelompok utama alasan jatuhnya tes: <br><br>  <b>Isolasi yang buruk</b> <br><br>  Yang kami maksud dengan isolasi adalah kasus enkapsulasi khusus, yaitu: mekanisme bahasa yang memungkinkan pembatasan akses beberapa komponen program ke yang lain. <br><br>  Isolasi lingkungan memainkan peran penting, karena untuk kemurnian tes, tidak ada yang mempengaruhi entitas yang diuji.  Perhatian khusus harus diberikan pada tes yang ditujukan untuk memeriksa kode.  Mereka menggunakan entitas negara global, seperti: variabel global, Keychain, Network, CoreData, Singleton, NSUserDefaults, dan sebagainya.  Di daerah-daerah inilah sejumlah besar tempat potensial untuk manifestasi isolasi yang buruk muncul.  Misalkan, saat membuat lingkungan pengujian, keadaan global diatur, yang secara implisit digunakan dalam kode pengujian lain.  Dalam kasus ini, tes yang memeriksa kode yang sedang diuji mungkin mulai "berkedip" - karena tergantung pada urutan tes, dua situasi dapat muncul - ketika negara global diatur dan ketika tidak diatur.  Seringkali, dependensi yang dijelaskan adalah implisit, sehingga Anda mungkin tidak sengaja lupa untuk mengatur / mengatur ulang negara global tersebut. <br><br>  Untuk membuat dependensi terlihat jelas, Anda dapat menggunakan prinsip Dependency Injection (DI), yaitu: meneruskan dependensi melalui parameter konstruktor, atau properti objek.  Ini akan membuatnya mudah untuk menggantikan dependensi tiruan alih-alih objek nyata. <br><br>  <b>Hubungi asynchrony</b> <br><br>  Semua tes unit dilakukan secara sinkron.  Kesulitan pengujian asinkron muncul karena panggilan metode pengujian dalam tes ‚Äúmembeku‚Äù untuk mengantisipasi penyelesaian ruang lingkup unit tes.  Hasilnya akan menjadi tes yang stabil. <br><br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">//act [self.testService loadImageFromUrl:@"www.google.ru" handler:^(UIImage * _Nullable image, NSError * _Nullable error) { //assert OCMVerify([cacheMock imageAtPath:OCMOCK_ANY]); OCMVerify([cacheMock dateOfFileAtPath:OCMOCK_ANY]); OCMVerify([imageMock new]); [imageMock stopMocking]; }]; [self waitInterval:0.2];</span></span></code> </pre> <br>  Untuk menguji tes semacam itu, ada beberapa pendekatan: <br><br><ol><li>  Jalankan NSRunLoop </li><li>  waitForExpectationsWithTimeout </li></ol><br>  Kedua opsi mengharuskan Anda untuk menentukan argumen dengan batas waktu.  Namun, tidak dapat dijamin bahwa interval yang dipilih akan cukup.  Secara lokal, tes Anda akan berlalu, tetapi pada CI yang penuh mungkin tidak ada daya yang cukup dan akan jatuh - dari sini "blink" akan muncul. <br><br>  Mari kita memiliki semacam layanan pemrosesan data.  Kami ingin memverifikasi bahwa setelah menerima respons dari server, ini akan mentransfer data ini untuk diproses lebih lanjut. <br><br>  Untuk mengirim permintaan melalui jaringan, layanan menggunakan klien untuk bekerja dengannya. <br><br>  Tes semacam itu dapat ditulis secara tidak sinkron menggunakan server tiruan untuk menjamin respons jaringan yang stabil. <br><br><pre> <code class="objectivec hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">@interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Service</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSObject</span></span></span><span class="hljs-class"> @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">property</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nonatomic</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">strong</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">id</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">APIClient</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">apiClient</span></span></span><span class="hljs-class">; @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span><span class="hljs-class"> @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">APIClient</span></span></span><span class="hljs-class"> &lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSObject</span></span></span><span class="hljs-class">&gt; - (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class">)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">getDataWithCompletion</span></span></span><span class="hljs-class">:(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> (^)(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">id</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">responseJSONData</span></span></span><span class="hljs-class">))</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">completion</span></span></span><span class="hljs-class">; @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span><span class="hljs-class"> - (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class">)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">testRequestAsync</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// arrange __auto_type service = [Service new]; service.apiClient = [APIClient new]; XCTestExpectation *expectation = [self expectationWithDescription:@"Request"]; // act id receivedData = nil; [self.service receiveDataWithCompletion:^(id responseJSONData) { receivedData = responseJSONData; [expectation fulfill]; }]; [self waitForExpectationsWithTimeout:10 handler:^(NSError * _Nullable error) { expect(receivedData).notTo.beNil(); expect(error).to.beNil(); }]; }</span></span></code> </pre><br>  Tetapi versi uji sinkron akan lebih stabil dan memungkinkan Anda untuk tidak bekerja dengan timeout. <br><br>  Untuknya kita perlu APIClient tiruan tiruan <br><br><pre> <code class="objectivec hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">@interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">APIClientMock</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSObject</span></span></span><span class="hljs-class"> &lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">APIClient</span></span></span><span class="hljs-class">&gt; @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span><span class="hljs-class"> @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">implementation</span></span></span><span class="hljs-class"> - (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class">)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">getDataWithCompletion</span></span></span><span class="hljs-class">:(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> (^)(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">id</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">responseJSONData</span></span></span><span class="hljs-class">))</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">completion</span></span></span><span class="hljs-class"> </span></span>{ __auto_type fakeData = @{ <span class="hljs-string"><span class="hljs-string">@"key"</span></span> : <span class="hljs-string"><span class="hljs-string">@"value"</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (completion != <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) { completion(fakeData); } } <span class="hljs-keyword"><span class="hljs-keyword">@end</span></span></code> </pre><br>  Maka tes akan terlihat lebih sederhana dan bekerja lebih stabil <br><br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)testRequestSync { <span class="hljs-comment"><span class="hljs-comment">// arrange __auto_type service = [Service new]; service.apiClient = [APIClientMock new]; // act id receivedData = nil; [self.service receiveDataWithCompletion:^(id responseJSONData) { receivedData = responseJSONData; }]; expect(receivedData).notTo.beNil(); expect(error).to.beNil(); }</span></span></code> </pre><br>  Operasi asinkron dapat diisolasi dengan mengenkapsulasi entitas terpisah, yang dapat diuji secara independen.  Sisa dari logika perlu diuji secara serempak.  Pendekatan ini akan menghindari sebagian besar jebakan yang dibawa oleh asynchrony. <br><br>  Atau, dalam hal memperbarui lapisan UI dari utas latar belakang, Anda dapat memeriksa untuk melihat apakah kami ada di utas utama dan apa yang akan terjadi jika kami melakukan panggilan dari pengujian: <br><br><pre> <code class="objectivec hljs">func performUIUpdate(using closure: @escaping () -&gt; Void) { <span class="hljs-comment"><span class="hljs-comment">// If we are already on the main thread, execute the closure directly if Thread.isMainThread { closure() } else { DispatchQueue.main.async(execute: closure) } }</span></span></code> </pre><br>  Untuk penjelasan terperinci, lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel oleh D. Sandell</a> . <br><br>  <b>Menguji kode di luar kendali Anda</b> <br>  Seringkali kita melupakan hal-hal berikut: <br><br><ul><li>  implementasi metode mungkin tergantung pada lokalisasi aplikasi, </li><li>  ada metode pribadi di SDK yang bisa dipanggil oleh kelas framework, </li><li>  implementasi metode mungkin tergantung pada versi SDK </li></ul><br><img src="https://habrastorage.org/webt/ym/-c/le/ym-clect83a4rmvz0gnjp1dyz7c.jpeg" align="left"><div style="text-align:center;"><img src="https://habrastorage.org/webt/v7/70/8t/v7708tdiyctsy-yxxmnqnjukeni.jpeg"></div><br>  Kasus-kasus di atas menimbulkan ketidakpastian saat menulis dan menjalankan tes.  Untuk menghindari konsekuensi negatif, Anda perlu menjalankan tes di semua lokal, serta pada versi iOS yang didukung oleh aplikasi Anda.  Secara terpisah, perlu dicatat bahwa tidak perlu menguji kode yang implementasinya tersembunyi dari Anda. <br><br>  Dengan ini, kami ingin menyelesaikan bagian pertama artikel tentang pengujian otomatis aplikasi Sberbank Online iOS, yang didedikasikan untuk pengujian unit. <br><br>  Di bagian kedua artikel, kita akan berbicara tentang masalah yang terjadi saat menulis 1500 tes UI, serta resep untuk mengatasinya. <br><br>  Artikel ini ditulis dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">regno</a> - Anton Vlasov, kepala pengembangan dan pengembang iOS. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id434320/">https://habr.com/ru/post/id434320/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id434300/index.html">Kode komentar: hack kehidupan kecil</a></li>
<li><a href="../id434306/index.html">Bagaimana kami memperbarui intranet dengan pemirsa harian 2K + pengguna. Tanpa anggaran</a></li>
<li><a href="../id434312/index.html">Waktu konferensi! Menjumlahkan 2018</a></li>
<li><a href="../id434314/index.html">Alternatif untuk LastPass. Evaluasi komparatif dari enam manajer kata sandi</a></li>
<li><a href="../id434316/index.html">Secret Santa, quests, quiz dan skating rink - bagaimana kami bertemu ABBYY Tahun Baru</a></li>
<li><a href="../id434322/index.html">Akurasi kedalaman jelas</a></li>
<li><a href="../id434326/index.html">Balet di udara: levitasi partikel yang dikendalikan karena gelombang suara</a></li>
<li><a href="../id434328/index.html">Tanda tangan elektronik untuk partisipasi dalam pengadaan</a></li>
<li><a href="../id434330/index.html">Apa yang Baru di YouTrack 2018.4</a></li>
<li><a href="../id434332/index.html">Dan sekali lagi tentang KIB SearchInform: kami berurusan dengan yang terbaru</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>