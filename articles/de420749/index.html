<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚘 🍦 🚷 GitLab für Continuous Delivery-Projekt auf InterSystems Technologies: Container ♐️ 🔁 👵🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dieser Artikel ist eine Fortsetzung eines Artikels über die Organisation von Continuous Integration / Continuous Delivery-Prozessen, die das Zusammens...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>GitLab für Continuous Delivery-Projekt auf InterSystems Technologies: Container</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/intersystems/blog/420749/"><p>  Dieser Artikel ist eine Fortsetzung eines <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikels</a> über die Organisation von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Continuous Integration</a> / Continuous Delivery-Prozessen, die das Zusammenstellen, Testen und Bereitstellen von Anwendungen für Lösungen automatisieren, die auf der InterSystems-Plattform basieren. </p><br><p>  Betrachten Sie Themen wie: </p><br><ul><li>  Behälter 101 </li><li>  Container in verschiedenen Phasen des Softwareentwicklungszyklus </li><li>  Kontinuierliche Lieferung mit Containern <a name="habracut"></a></li></ul><br><h1 id="konteynery-101">  Behälter 101 </h1><br><p>  Es wurden viele Artikel und Bücher über Container und Containerisierung geschrieben, daher werde ich hier eine kleine Einführung machen, die jedoch nicht den Anspruch erhebt, endgültig zu sein.  Also fangen wir an. </p><br><p>  Container sind technisch gesehen eine Virtualisierungsmethode, bei der der Kernel des Betriebssystems mehrere isolierte Instanzen des Benutzerbereichs (Container) anstelle von einer unterstützt.  Das sieht optisch so aus: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/114/c21/985/114c21985549c134bf91685e2b15d1d3.jpg" alt="Docker gegen VM"></p><br><p>  Es ist wichtig zu beachten, dass Container keine virtuellen Maschinen sind. Hier ist ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">guter Artikel</a> über ihre Unterschiede. </p><br><h2 id="preimuschestva-konteynerov">  Containervorteile </h2><br><p>  Die Verwendung von Containern bietet mehrere Vorteile: </p><br><ul><li>  Portabilität </li><li>  Wirksamkeit </li><li>  Isolierung </li><li>  Leichtigkeit </li><li>  Unveränderlichkeit </li></ul><br><h3 id="portativnost">  Portabilität </h3><br><p>  Der Container enthält die Anwendung zusammen mit allen Abhängigkeiten.  Dies erleichtert das Ausführen von Anwendungen in verschiedenen Umgebungen, z. B. physischen Servern, virtuellen Maschinen, Testumgebungen und Produktumgebungen sowie Clouds. </p><br><p>  Die Portabilität besteht auch in der Tatsache, dass das Docker-Image nach dem Zusammenstellen und der korrekten Funktion überall funktioniert, wenn Docker dort arbeitet, d. H.  auf Windows-, Linux- und MacOS-Servern. </p><br><h3 id="effektivnost">  Wirksamkeit </h3><br><p>  Benötigen Sie bei der Arbeit mit Anwendungen für virtuelle Maschinen wirklich Betriebssystemprozesse, Systemprogramme usw.?  Nein, in der Regel ist nur der Prozess Ihrer Bewerbung interessant.  Container bieten genau dies: Im Container werden nur die Prozesse gestartet, die eindeutig benötigt werden, und nicht mehr.  Da Container kein separates Betriebssystem benötigen, verbrauchen sie weniger Ressourcen.  Eine virtuelle Maschine nimmt häufig mehrere Gigabyte ein, während ein Container nur wenige Megabyte groß sein kann, sodass Sie viel mehr Container als virtuelle Maschinen auf einem einzelnen Server ausführen können. </p><br><p> Da Container eine höhere Serverauslastung aufweisen, ist weniger Hardware erforderlich, was zu geringeren Kosten führt. </p><br><h3 id="izolyaciya">  Isolierung </h3><br><p>  Container isolieren die Anwendung von allen anderen Prozessen, und obwohl mehrere Container auf demselben Server ausgeführt werden können, können sie völlig unabhängig voneinander sein.  Jede Interaktion zwischen Containern muss explizit deklariert werden.  Wenn ein Container ausfällt, wirkt sich dies nicht auf andere Container aus und kann schnell neu gestartet werden.  Die Sicherheit wird auch durch diese Isolierung erhöht.  Wenn Sie beispielsweise eine Webserver-Sicherheitsanfälligkeit auf einem Host ausnutzen, kann ein Angreifer Zugriff auf den gesamten Server erhalten. Bei einem Container erhält ein Angreifer jedoch nur Zugriff auf den Webserver-Container. </p><br><h3 id="lyogkost">  Leichtigkeit </h3><br><p>  Da für die Container kein separates Betriebssystem erforderlich ist, können sie innerhalb von Sekunden gestartet, gestoppt oder neu gestartet werden, wodurch alle zugehörigen Prozesse, einschließlich der Prozesse für die kontinuierliche Integration, beschleunigt werden.  Sie können schneller mit der Entwicklung beginnen und keine Zeit damit verschwenden, Ihre Umgebung einzurichten. </p><br><h3 id="neizmennost-immutability">  Unveränderlichkeit </h3><br><p>  Die unveränderliche Infrastruktur besteht aus unveränderlichen Komponenten, die bei jeder Bereitstellung ersetzt und nicht aktualisiert werden.  Konsistenz reduziert Inkonsistenzen und ermöglicht es Ihnen, einfach und schnell zu replizieren und zwischen verschiedenen Status Ihrer Anwendung zu wechseln.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mehr zur Unveränderlichkeit</a> . </p><br><h2 id="novye-vozmozhnosti">  Neue Funktionen </h2><br><p>  Mit all diesen Vorteilen können Sie Ihre Infrastruktur und Anwendungen auf neue Weise verwalten. </p><br><h3 id="orkestraciya">  Orchestrierung </h3><br><p>  Virtuelle Maschinen und Server gewinnen im Laufe der Zeit häufig an "Persönlichkeit", was in Zukunft zu vielen allgemein unangenehmen Überraschungen führt.  Eine Lösung für dieses Problem ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Infrastructure as a Code</a> (IoC) - Infrastrukturverwaltung unter Verwendung eines beschreibenden Modells unter Verwendung eines Versionskontrollsystems. </p><br><p>  Bei Verwendung von IoC bringt das Umgebungsbereitstellungsteam die Zielumgebung unabhängig vom Ausgangszustand der Umgebung immer auf dieselbe Konfiguration.  Dies wird erreicht, indem automatisch eine vorhandene Umgebung eingerichtet oder die Umgebung von Grund auf neu erstellt wird. </p><br><p>  Mit IoC nehmen Entwickler Änderungen an der Beschreibung der Umgebung vor.  Anschließend wird die Zielumgebung in einen neuen Status geändert.  Wenn Sie am Mittwoch Änderungen vornehmen müssen, wird die Beschreibung bearbeitet. </p><br><p>  All dies ist mit Containern viel einfacher.  Das Herunterfahren des Containers und das Starten eines neuen Containers dauert einige Sekunden, und das Zuweisen einer neuen virtuellen Maschine dauert einige Minuten. </p><br><h3 id="masshtabirovanie">  Skalieren </h3><br><p>  Orchestrierungswerkzeuge können auch eine horizontale Skalierung basierend auf der aktuellen Last bereitstellen.  Es ist möglich, so viele Container wie derzeit erforderlich auszuführen und die Anwendung entsprechend zu skalieren.  All dies reduziert auch die Kosten der Anwendung. </p><br><h1 id="konteynery-na-raznyh-etapah-zhiznennogo-cikla-po">  Container in verschiedenen Phasen des Software-Lebenszyklus </h1><br><p>  Berücksichtigen Sie die Vorteile von Containern in verschiedenen Phasen des Software-Lebenszyklus. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/639/58e/062/63958e06271594a0c8fbe5a8e8785ca7.png" alt="Software-Lebenszyklus"></p><br><h2 id="razrabotka">  Entwicklung </h2><br><p> Der wichtigste Vorteil ist der einfache Start der Entwicklung.  Nach der <a href="">Installation von Docker</a> reichen zwei Befehle aus: <code>docker pull</code> zum Laden des Images und <code>docker run</code> zum Starten.  Alle Abhängigkeiten werden bereits in der Phase der Anwendungserstellung aufgelöst. </p><br><h2 id="otladka">  Debuggen </h2><br><p>  Alle Umgebungen sind konsistent und ihre Definitionen existieren. Darüber hinaus ist es einfach, die erforderliche Umgebung bereitzustellen.  Es reicht aus, <code>docker pull</code> zu bringen, den <code>docker pull</code> Container zu <code>docker pull</code> und auszuführen. </p><br><h2 id="testirovanie--qa">  Testen / QS </h2><br><p>  Im Fehlerfall können die Problemumgebung und die Bedingungen für die Reproduktion des Fehlers mit dem Container übertragen werden.  Alle Infrastrukturänderungen werden „dokumentiert“.  Die Anzahl der Variablen nimmt ab - Versionen von Bibliotheken, Frameworks, Betriebssystemen ... Es ist möglich, mehrere Container auszuführen, um Tests zu parallelisieren. </p><br><h2 id="dostavka">  Lieferung </h2><br><p>  Durch die Verwendung von Containern können Sie einmal erstellen. Zusätzlich zur Verwendung von Containern benötigen Sie einen hohen Automatisierungsgrad der Montage- und Bereitstellungsprozesse.  Die Containerzustellung einer Anwendung kann aufgrund zusätzlicher Isolation sicherer sein. </p><br><h1 id="continuous-delivery">  Kontinuierliche Lieferung </h1><br><p>  Gehen wir von der Theorie zur Praxis.  Hier ein allgemeiner Überblick über unsere Montage- und Lieferautomatisierungslösung: </p><br><p><img src="https://habrastorage.org/webt/yv/dn/qc/yvdnqcgyrlswgft4-zhnm-2mabc.png" alt="CD"></p><br><p>  Drei Hauptstufen können unterschieden werden: </p><br><ul><li>  Montage </li><li>  Lieferung </li><li>  Starten </li></ul><br><h2 id="sborka">  Montage </h2><br><p>  Im vorherigen Artikel war die Assembly inkrementell - wir haben den Unterschied zwischen der aktuellen Umgebung und der neuen Codebasis berücksichtigt und unsere Umgebung so geändert, dass sie der neuen Codebasis entspricht.  Bei Containern ist jede Montage abgeschlossen.  Das Build-Ergebnis ist ein Docker-Image, das überall ausgeführt werden kann. </p><br><h2 id="dostavka-1">  Lieferung </h2><br><p>  Nachdem unser Image kompiliert und getestet wurde, wird es in die Docker-Registrierung hochgeladen, eine spezielle Anwendung zum Hosten des Docker-Images.  Dort kann er das vorherige Bild durch den gleichen Namen (Tag) ersetzen.  Zum Beispiel haben wir aufgrund eines neuen Commits für den Master-Zweig ein neues Image ( <code>MyProject/MyApp:master</code> ) zusammengestellt. Wenn die Tests bestanden wurden, können wir das Image in der Docker-Registrierung aktualisieren und jeder, der <code>MyProject/MyApp:master</code> herunterlädt, erhält eine neue Version. </p><br><h2 id="zapusk">  Starten </h2><br><p>  Schließlich muss das Image gestartet werden.  Ein CD-System wie GitLab kann dies entweder direkt oder mithilfe eines spezialisierten Orchestrators verwalten. Der Vorgang ist jedoch im Allgemeinen der gleiche: Einige Images werden gestartet, regelmäßig auf ihre Leistung überprüft und aktualisiert, wenn eine neue Version verfügbar wird. </p><br><p>  Lesen Sie das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Webinar</a> , in dem diese Schritte erläutert werden. </p><br><p>  Alternativ in Bezug auf Commit: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/ced/48d/84c/ced48d84c0a2213b3bd9c2bda109146e.png"></p><br><p>  In unserer Konfiguration für die kontinuierliche Lieferung haben wir: </p><br><ul><li>  Übernehmen Sie den Code in das GitLab-Repository </li><li>  Wir sammeln das Bild </li><li>  Testen </li><li>  Veröffentlichen Sie ein neues Bild in unserer Docker-Registrierung </li><li>  Aktualisieren Sie den alten Container aus der Docker-Registrierung auf die neue Version </li></ul><br><p>  Dafür brauchen wir: </p><br><ul><li>  Docker </li><li>  Docker-Registrierung </li><li>  Registrierte Domain (optional, aber wünschenswert) </li><li>  GUI-Tools (optional) </li></ul><br><h3 id="docker">  Docker </h3><br><p>  Zunächst müssen wir Docker starten.  Ich würde empfehlen, mit einem einzelnen Server mit einer gängigen Linux-Version wie Ubuntu, RHEL oder Suse zu beginnen.  Ich empfehle nicht, mit Distributionen wie CoreOS, RancherOS usw. zu beginnen - sie richten sich nicht an Anfänger.  <a href="">Denken Sie daran, den Speichertreiber auf Devicemapper umzustellen</a> . </p><br><p>  Wenn wir über umfangreiche Bereitstellungen sprechen und Orchestrierungs-Tools wie Kubernetes, Rancher oder Swarm verwenden, können Sie die meisten Aufgaben automatisieren, aber wir werden sie nicht diskutieren (zumindest im Rahmen dieses Artikels). </p><br><h3 id="docker-registry">  Docker-Registrierung </h3><br><p>  Dies ist der erste Container, den wir ausführen müssen. Es handelt sich um eine eigenständige Anwendung, mit der wir Docker-Images speichern und verteilen können.  Sie müssen die Docker-Registrierung verwenden, wenn Sie: </p><br><ul><li>  Steuern Sie, wo Ihre Bilder gespeichert werden </li><li>  Besitzen Sie einen Bildverteilungsserver </li><li>  Integrieren Sie die Speicherung und Verteilung von Bildern in den Entwicklungsprozess </li></ul><br><p>  Hier finden Sie die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> zum Starten und Konfigurieren der Docker-Registrierung. </p><br><h3 id="podklyuchenie-docker-registry-i-gitlab">  Verbinden Sie Docker Registry und GitLab </h3><br><p>  Um die Docker-Registrierung mit GitLab zu verbinden, müssen Sie die Docker-Registrierung mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">HTTPS-Unterstützung</a> ausführen.  Ich verwende Let's Encrypt, um Zertifikate zu erhalten, und habe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diese Anweisung</a> befolgt, um ein Zertifikat zu erhalten.  Nachdem Sie überprüft haben, ob auf die Docker-Registrierung über HTTPS zugegriffen werden kann (Sie können dies im Browser überprüfen), befolgen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diese Anweisungen</a> , um die Docker-Registrierung mit GitLab zu verbinden.  Diese Anweisungen unterscheiden sich je nach Ihrer GitLab-Installation und der von Ihnen benötigten Konfiguration.  In meinem Fall bestand das Setup darin, das Docker-Registrierungszertifikat und den Schlüssel zu <code>/etc/gitlab/ssl</code> und diese Zeilen zu <code>/etc/gitlab/gitlab.rb</code> : </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">registry_external_url</span></span> <span class="hljs-string"><span class="hljs-string">'https://docker.domain.com'</span></span> gitlab_rails [<span class="hljs-string"><span class="hljs-string">'registry_api_url'</span></span>] = <span class="hljs-string"><span class="hljs-string">"https://docker.domain.com"</span></span></code> </pre> <br><p>  Nach der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Neukonfiguration von GitLab</a> wurde eine neue Registerkarte "Registrierung" angezeigt, die Informationen zum korrekten Benennen der erstellten Bilder enthält, damit sie hier angezeigt werden. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/a54/6b0/f85/a546b0f853ab022249ef03232927461d.png"></p><br><h3 id="domen">  Domain </h3><br><p>  In unserer Continuous Delivery-Konfiguration erstellen wir automatisch ein Image für jeden Zweig. Wenn das Image die Tests besteht, wird es in der Docker-Registrierung veröffentlicht und automatisch gestartet, sodass unsere Anwendung automatisch von allen Zweigen bereitgestellt wird, z. </p><br><ul><li>  Mehrere <code>&lt;featureName&gt;.docker.domain.com</code> Zweige unter <code>&lt;featureName&gt;.docker.domain.com</code> </li><li>  <code>master.docker.domain.com</code> unter <code>master.docker.domain.com</code> </li><li>  <code>preprod.docker.domain.com</code> unter <code>preprod.docker.domain.com</code> </li><li>  Produktversion unter <code>prod.docker.domain.com</code> </li></ul><br><p>  Dazu benötigen wir einen Domainnamen und einen Platzhalter-DNS- <code>* .docker.domain.com</code> , der Anforderungen an <code>* .docker.domain.com</code> an die IP-Adresse von <code>docker.domain.com</code> .  Alternativ können Sie verschiedene Ports verwenden. </p><br><h3 id="nginx">  Nginx </h3><br><p>  Da wir mehrere Umgebungen haben, müssen wir Anforderungen automatisch an Subdomains in den richtigen Container umleiten.  Hierfür können wir Nginx als Reverse-Proxy verwenden.  Hier ist eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Anleitung</a> . </p><br><h3 id="gui-instrumenty">  GUI-Tools </h3><br><p>  Um mit Containern zu arbeiten, können Sie entweder die Befehlszeile oder eine der grafischen Oberflächen verwenden.  Es sind viele verfügbar, zum Beispiel: </p><br><ul><li>  Rancher </li><li>  Mikrobadger </li><li>  Portainer </li><li>  Einfache Docker-Benutzeroberfläche </li><li>  ... </li></ul><br><p>  Mit ihnen können Sie Container erstellen und über die GUI anstelle der CLI verwalten.  So sieht Rancher aus: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/574/485/d9c/574485d9c01d464510f79097f6b823b4.png" alt="Rancher"></p><br><h3 id="gitlab-runner">  Gitlab-Läufer </h3><br><p>  Wie zuvor müssen wir den GitLab-Runner installieren, um Skripte auf anderen Servern ausführen zu können.  Diese Frage wurde in einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">früheren Artikel</a> ausführlich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">beschrieben</a> . </p><br><p>  Beachten Sie, dass Sie die Executor-Shell verwenden müssen, nicht den Docker.  Executor Docker wird verwendet, wenn Sie etwas aus dem Image benötigen, z. B. wenn Sie eine Android-Anwendung in einem Java-Container erstellen, und wenn Sie nur apk benötigen.  In unserem Fall ist das Artefakt der gesamte Container, und dies erfordert die Executor-Shell. </p><br><h1 id="konfiguraciya-continuous-delivery">  Continuous Delivery-Konfiguration </h1><br><p>  Nachdem alle erforderlichen Komponenten konfiguriert wurden, können Sie mit der Erstellung einer Konfiguration für die kontinuierliche Bereitstellung beginnen. </p><br><h2 id="sborka-1">  Montage </h2><br><p>  Zuerst müssen wir ein Bild zusammenstellen. </p><br><p>  Unser Code wird wie immer im Repository gespeichert, die Konfiguration der CD in <code>gitlab-ci.yml</code> , aber zusätzlich (um die Sicherheit zu verbessern) werden wir mehrere Dateien, die sich auf das Image beziehen, auf dem Build-Server speichern. </p><br><h3 id="gitlabxml">  Gitlab.xml </h3><br><p>  Enthält Rückrufcode für CD.  Es wurde in einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">früheren Artikel entwickelt</a> und ist auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub</a> verfügbar.  Dies ist eine kleine Bibliothek zum Herunterladen von Code, Ausführen verschiedener Rückrufe und zum Testen von Code.  Es ist vorzuziehen, Git-Submodule zu verwenden, um dieses Projekt oder ähnliches in Ihr Repository aufzunehmen.  Submodule sind besser, weil es einfacher ist, sie auf dem neuesten Stand zu halten.  Eine andere Alternative besteht darin, eine Version auf GitLab zu erstellen und diese bereits zum Zeitpunkt der Erstellung mit dem Befehl ADD herunterzuladen. </p><br><h3 id="iriskey">  iris.key </h3><br><p>  Lizenzschlüssel.  Es kann während der Montage des Containers geladen und nicht auf dem Server gespeichert werden.  Es ist nicht sicher, den Schlüssel im Repository zu speichern.  Sie können einen Testschlüssel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bei WRC erhalten</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">InterSystems IRIS Experience</a> ausprobieren. </p><br><h3 id="pwdtxt">  pwd.txt </h3><br><p>  Datei mit dem Standardkennwort.  Auch hier ist das Speichern des Kennworts im Repository ziemlich unsicher. </p><br><h3 id="load_ciscript">  load_ci.script </h3><br><p>  Ein Skript, das: </p><br><ul><li>  Beinhaltet die <a href="">Betriebssystemauthentifizierung</a> in InterSystems IRIS </li><li>  Lädt GitLab.xml </li><li>  Initialisiert die GitLab-Rückrufeinstellungen </li><li>  Lädt Code </li></ul><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">set</span></span> sc = ##Class(Security.System).Get(<span class="hljs-string"><span class="hljs-string">"SYSTEM"</span></span>,.Properties) write:(<span class="hljs-string"><span class="hljs-string">'sc) $System.Status.GetErrorText(sc) set AutheEnabled = Properties("AutheEnabled") set AutheEnabled = $ZBOOLEAN(+AutheEnabled,16,7) set Properties("AutheEnabled") = AutheEnabled set sc = ##Class(Security.System).Modify("SYSTEM",.Properties) write:('</span></span>sc) $System.Status.GetErrorText(sc) zn <span class="hljs-string"><span class="hljs-string">"USER"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> ##<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span></span>(%SYSTEM.OBJ).Load(##<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span></span>(%File).ManagerDirectory() _ <span class="hljs-string"><span class="hljs-string">"GitLab.xml"</span></span>,<span class="hljs-string"><span class="hljs-string">"cdk"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> ##<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span></span>(isc.git.Settings).setSetting(<span class="hljs-string"><span class="hljs-string">"hooks"</span></span>, <span class="hljs-string"><span class="hljs-string">"MyApp/Hooks/"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> ##<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span></span>(isc.git.Settings).setSetting(<span class="hljs-string"><span class="hljs-string">"tests"</span></span>, <span class="hljs-string"><span class="hljs-string">"MyApp/Tests/"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> ##<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span></span>(isc.git.GitLab).load() halt</code> </pre> <br><p>  Beachten Sie, dass die erste Zeile absichtlich leer gelassen wird.  Wenn dieses anfängliche Skript immer dasselbe ist, können Sie es einfach im Repository speichern. </p><br><h2 id="gitlab-ciyml">  gitlab-ci.yml </h2><br><p>  Fahren wir nun mit der Konfiguration für die kontinuierliche Lieferung fort: </p><br><pre> <code class="hljs bash">build image: stage: build tags: - <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> script: - cp -r /InterSystems/mount ci - <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> ci - <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">'SuperUser'</span></span> | cat - pwd.txt load_ci.script &gt; temp.txt - mv temp.txt load_ci.script - <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> .. - docker build --build-arg CI_PROJECT_DIR=<span class="hljs-variable"><span class="hljs-variable">$CI_PROJECT_DIR</span></span> -t docker.domain.com/<span class="hljs-built_in"><span class="hljs-built_in">test</span></span>/docker:<span class="hljs-variable"><span class="hljs-variable">$CI_COMMIT_REF_NAME</span></span> .</code> </pre> <br><p>  Was ist hier los? </p><br><p>  Da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der Image-Assemblierungsprozess</a> nur auf Unterverzeichnisse des Basisverzeichnisses zugreifen kann - in unserem Fall auf das Stammverzeichnis des Repositorys - müssen Sie zunächst das "geheime" Verzeichnis (mit <code>GitLab.xml</code> , <code>iris.key</code> , <code>pwd.txt</code> und <code>load_ci.skript</code> ) <code>load_ci.skript</code> geklontes Repository. </p><br><p>  Außerdem ist ein Benutzer / Passwort erforderlich, um auf das Terminal zuzugreifen, sodass wir sie zu <code>load_ci.script</code> hinzufügen (dazu benötigen wir eine leere Zeile am Anfang von <code>load_ci.script</code> ). </p><br><p>  Schließlich erstellen wir ein Docker-Image und nennen es: <code>docker.domain.com/test/docker:$CI_COMMIT_REF_NAME</code> </p><br><p>  Dabei ist <code>$CI_COMMIT_REF_NAME</code> der Name des Zweigs.  Bitte beachten Sie: Der erste Teil des Image-Tags muss mit dem Namen des Repositorys in GitLab übereinstimmen, damit er auf der Registerkarte "Registrierung" angezeigt wird (ausführlichere Anweisungen zum korrekten Tagging finden Sie dort). </p><br><h3 id="dockerfile">  Dockerfile </h3><br><p>  Docker Image wird mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dockerfile erstellt</a> . Hier ist es: </p><br><pre> <code class="hljs mel">FROM docker.intersystems.com/intersystems/iris:<span class="hljs-number"><span class="hljs-number">2018.1</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span><span class="hljs-number"><span class="hljs-number">.613</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span> ENV SRC_DIR=/tmp/src ENV CI_DIR=$SRC_DIR/ci ENV CI_PROJECT_DIR=$SRC_DIR COPY ./ $SRC_DIR RUN cp $CI_DIR/iris.key $ISC_PACKAGE_INSTALLDIR/mgr/ \ &amp;&amp; cp $CI_DIR/GitLab.xml $ISC_PACKAGE_INSTALLDIR/mgr/ \ &amp;&amp; $ISC_PACKAGE_INSTALLDIR/dev/Cloud/ICM/changePassword.sh $CI_DIR/<span class="hljs-keyword"><span class="hljs-keyword">pwd</span></span>.txt \ &amp;&amp; iris start $ISC_PACKAGE_INSTANCENAME \ &amp;&amp; irissession $ISC_PACKAGE_INSTANCENAME -U%SYS &lt; $CI_DIR/load_ci.script \ &amp;&amp; iris stop $ISC_PACKAGE_INSTANCENAME quietly</code> </pre> <br><p>  Die folgenden Aktionen werden ausgeführt: </p><br><ul><li>  Wir nehmen das Bild von InterSystems IRIS als Grundlage.  Es sollte sich in Ihrer Docker-Registrierung befinden.  Wenn Sie zuvor noch nicht mit Docker gearbeitet haben, versuchen Sie es mit <a href="">First Look: Docker</a> , in dem beschrieben wird, wie Sie ein InterSystems-IRIS-Image erhalten, es der Docker-Registrierung hinzufügen und manuell starten. </li><li>  Kopieren Sie zunächst unser Repository (und das "geheime" Verzeichnis) in den Container. </li><li>  Kopieren Sie den Lizenzschlüssel und <code>GitLab.xml</code> in das Verzeichnis <code>mgr</code> . </li><li>  Ändern Sie das Passwort in den Wert von <code>pwd.txt</code> .  Beachten Sie, dass <code>pwd.txt</code> während dieses Vorgangs gelöscht wird. </li><li>  Startet InterSystems IRIS. </li><li>  Das <code>load_ci.script</code> wird <code>load_ci.script</code> . </li><li>  InterSystems IRIS stoppt. </li></ul><br><div class="spoiler">  <b class="spoiler_title">Hier ist ein Teil-Build-Protokoll</b> <div class="spoiler_text"><pre> <code class="hljs perl">Running with gitlab-runner <span class="hljs-number"><span class="hljs-number">10.6</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> (a3543a27) on docker <span class="hljs-number"><span class="hljs-number">7</span></span>b21e0c4 Using Shell executor... Running on docker... Fetching changes... Removing ci/ Removing temp.txt HEAD is now at <span class="hljs-number"><span class="hljs-number">5</span></span>ef9904 Build load_ci.script From http:<span class="hljs-regexp"><span class="hljs-regexp">//gitlab</span></span>.eduard.win/test/docker <span class="hljs-number"><span class="hljs-number">5</span></span>ef9904..<span class="hljs-number"><span class="hljs-number">9753</span></span>a8d master -&gt; origin/master Checking out <span class="hljs-number"><span class="hljs-number">9753</span></span>a8db as master... Skipping Git submodules setup $ cp -r /InterSystems/mount ci $ cd ci $ echo <span class="hljs-string"><span class="hljs-string">'SuperUser'</span></span> | cat - pwd.txt load_ci.script &gt; temp.txt $ mv temp.txt load_ci.script $ cd .. $ docker build --build-arg CI_PROJECT_DIR=$CI_PROJECT_DIR -t docker.eduard.win/test/docker:$CI_COMMIT_REF_NAME . Sending build context to Docker daemon <span class="hljs-number"><span class="hljs-number">401.4</span></span>kB Step <span class="hljs-number"><span class="hljs-number">1</span></span>/<span class="hljs-number"><span class="hljs-number">6</span></span> : FROM docker.intersystems.com/intersystems/iris:<span class="hljs-number"><span class="hljs-number">2018.1</span></span>.<span class="hljs-number"><span class="hljs-number">1.613</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> ---&gt; cd2e53e7f85<span class="hljs-number"><span class="hljs-number">0</span></span> Step <span class="hljs-number"><span class="hljs-number">2</span></span>/<span class="hljs-number"><span class="hljs-number">6</span></span> : ENV SRC_DIR=<span class="hljs-regexp"><span class="hljs-regexp">/tmp/src</span></span> ---&gt; Using cache ---&gt; <span class="hljs-number"><span class="hljs-number">68</span></span>ba1cb00aff Step <span class="hljs-number"><span class="hljs-number">3</span></span>/<span class="hljs-number"><span class="hljs-number">6</span></span> : ENV CI_DIR=$SRC_DIR/ci ---&gt; Using cache ---&gt; <span class="hljs-number"><span class="hljs-number">6784</span></span>c34a9ee6 Step <span class="hljs-number"><span class="hljs-number">4</span></span>/<span class="hljs-number"><span class="hljs-number">6</span></span> : ENV CI_PROJECT_DIR=$SRC_DIR ---&gt; Using cache ---&gt; <span class="hljs-number"><span class="hljs-number">3757</span></span>fa88a28a Step <span class="hljs-number"><span class="hljs-number">5</span></span>/<span class="hljs-number"><span class="hljs-number">6</span></span> : COPY ./ $SRC_DIR ---&gt; <span class="hljs-number"><span class="hljs-number">5515</span></span>e13741b<span class="hljs-number"><span class="hljs-number">0</span></span> Step <span class="hljs-number"><span class="hljs-number">6</span></span>/<span class="hljs-number"><span class="hljs-number">6</span></span> : RUN cp $CI_DIR/iris.key $ISC_PACKAGE_INSTALLDIR/mgr/ &amp;&amp; cp $CI_DIR/GitLab.xml $ISC_PACKAGE_INSTALLDIR/mgr/ &amp;&amp; $ISC_PACKAGE_INSTALLDIR/dev/Cloud/ICM/changePassword.sh $CI_DIR/pwd.txt &amp;&amp; iris start $ISC_PACKAGE_INSTANCENAME &amp;&amp; irissession $ISC_PACKAGE_INSTANCENAME -U%SYS &lt; $CI_DIR/load_ci.script &amp;&amp; iris stop $ISC_PACKAGE_INSTANCENAME quietly ---&gt; Running in <span class="hljs-number"><span class="hljs-number">86526183</span></span>cf7c . Waited <span class="hljs-number"><span class="hljs-number">1</span></span> seconds <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> InterSystems IRIS to start This copy of InterSystems IRIS has been licensed <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> exclusively by: ISC Internal Container Sharding Copyright (c) <span class="hljs-number"><span class="hljs-number">1986</span></span>-<span class="hljs-number"><span class="hljs-number">2018</span></span> by InterSystems Corporation Any other <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> is a violation of your license agreement %SYS&gt; <span class="hljs-number"><span class="hljs-number">1</span></span> %SYS&gt; Using <span class="hljs-string"><span class="hljs-string">'iris.cpf'</span></span> configuration file This copy of InterSystems IRIS has been licensed <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> exclusively by: ISC Internal Container Sharding Copyright (c) <span class="hljs-number"><span class="hljs-number">1986</span></span>-<span class="hljs-number"><span class="hljs-number">2018</span></span> by InterSystems Corporation Any other <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> is a violation of your license agreement <span class="hljs-number"><span class="hljs-number">1</span></span> alert(<span class="hljs-keyword"><span class="hljs-keyword">s</span></span>) during startup. See messages.log <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> details. Starting IRIS Node: <span class="hljs-number"><span class="hljs-number">39702</span></span>b122ab6, Instance: IRIS Username: Password: Load started on <span class="hljs-number"><span class="hljs-number">04</span></span>/<span class="hljs-number"><span class="hljs-number">06</span></span>/<span class="hljs-number"><span class="hljs-number">2018</span></span> <span class="hljs-number"><span class="hljs-number">17</span></span>:<span class="hljs-number"><span class="hljs-number">38</span></span>:<span class="hljs-number"><span class="hljs-number">21</span></span> Loading file /usr/irissys/mgr/GitLab.xml as xml Load finished successfully. USER&gt; USER&gt; [<span class="hljs-number"><span class="hljs-number">2018</span></span>-<span class="hljs-number"><span class="hljs-number">04</span></span>-<span class="hljs-number"><span class="hljs-number">06</span></span> <span class="hljs-number"><span class="hljs-number">17</span></span>:<span class="hljs-number"><span class="hljs-number">38</span></span>:<span class="hljs-number"><span class="hljs-number">22.017</span></span>] Running init hooks: before [<span class="hljs-number"><span class="hljs-number">2018</span></span>-<span class="hljs-number"><span class="hljs-number">04</span></span>-<span class="hljs-number"><span class="hljs-number">06</span></span> <span class="hljs-number"><span class="hljs-number">17</span></span>:<span class="hljs-number"><span class="hljs-number">38</span></span>:<span class="hljs-number"><span class="hljs-number">22.017</span></span>] Importing hooks dir /tmp/src/MyApp/Hooks/ [<span class="hljs-number"><span class="hljs-number">2018</span></span>-<span class="hljs-number"><span class="hljs-number">04</span></span>-<span class="hljs-number"><span class="hljs-number">06</span></span> <span class="hljs-number"><span class="hljs-number">17</span></span>:<span class="hljs-number"><span class="hljs-number">38</span></span>:<span class="hljs-number"><span class="hljs-number">22.374</span></span>] Executing hook class: MyApp.Hooks.Global [<span class="hljs-number"><span class="hljs-number">2018</span></span>-<span class="hljs-number"><span class="hljs-number">04</span></span>-<span class="hljs-number"><span class="hljs-number">06</span></span> <span class="hljs-number"><span class="hljs-number">17</span></span>:<span class="hljs-number"><span class="hljs-number">38</span></span>:<span class="hljs-number"><span class="hljs-number">22.375</span></span>] Executing hook class: MyApp.Hooks.Local [<span class="hljs-number"><span class="hljs-number">2018</span></span>-<span class="hljs-number"><span class="hljs-number">04</span></span>-<span class="hljs-number"><span class="hljs-number">06</span></span> <span class="hljs-number"><span class="hljs-number">17</span></span>:<span class="hljs-number"><span class="hljs-number">38</span></span>:<span class="hljs-number"><span class="hljs-number">22.375</span></span>] Importing dir /tmp/src/ Loading file /tmp/src/MyApp/Tests/TestSuite.cls as udl Compilation started on <span class="hljs-number"><span class="hljs-number">04</span></span>/<span class="hljs-number"><span class="hljs-number">06</span></span>/<span class="hljs-number"><span class="hljs-number">2018</span></span> <span class="hljs-number"><span class="hljs-number">17</span></span>:<span class="hljs-number"><span class="hljs-number">38</span></span>:<span class="hljs-number"><span class="hljs-number">22</span></span> with qualifiers <span class="hljs-string"><span class="hljs-string">'c'</span></span> Compilation finished successfully in <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">194</span></span>s. Load finished successfully. [<span class="hljs-number"><span class="hljs-number">2018</span></span>-<span class="hljs-number"><span class="hljs-number">04</span></span>-<span class="hljs-number"><span class="hljs-number">06</span></span> <span class="hljs-number"><span class="hljs-number">17</span></span>:<span class="hljs-number"><span class="hljs-number">38</span></span>:<span class="hljs-number"><span class="hljs-number">22.876</span></span>] Running init hooks: after [<span class="hljs-number"><span class="hljs-number">2018</span></span>-<span class="hljs-number"><span class="hljs-number">04</span></span>-<span class="hljs-number"><span class="hljs-number">06</span></span> <span class="hljs-number"><span class="hljs-number">17</span></span>:<span class="hljs-number"><span class="hljs-number">38</span></span>:<span class="hljs-number"><span class="hljs-number">22.878</span></span>] Executing hook class: MyApp.Hooks.Local [<span class="hljs-number"><span class="hljs-number">2018</span></span>-<span class="hljs-number"><span class="hljs-number">04</span></span>-<span class="hljs-number"><span class="hljs-number">06</span></span> <span class="hljs-number"><span class="hljs-number">17</span></span>:<span class="hljs-number"><span class="hljs-number">38</span></span>:<span class="hljs-number"><span class="hljs-number">22.921</span></span>] Executing hook class: MyApp.Hooks.Global Removing intermediate container <span class="hljs-number"><span class="hljs-number">39702</span></span>b122ab6 ---&gt; dea6b2123165 [Warning] One <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> more build-args [CI_PROJECT_DIR] were <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> consumed Successfully built dea6b2123165 Successfully tagged docker.domain.com/test/docker:master Job succeeded</code> </pre> </div></div><br><h2 id="zapusk-1">  Starten </h2><br><p>  Wir haben ein Bild, führen Sie es aus.  Bei Feature-Zweigen können Sie einfach den alten Container zerstören und einen neuen starten.  Im Fall der Produktumgebung können wir zuerst den temporären Container starten und den mittleren Container ersetzen, wenn die Tests erfolgreich bestanden wurden. </p><br><p>  Zuerst das Skript zum Löschen des alten Containers. </p><br><pre> <code class="hljs ruby">destroy <span class="hljs-symbol"><span class="hljs-symbol">old:</span></span> <span class="hljs-symbol"><span class="hljs-symbol">stage:</span></span> destroy <span class="hljs-symbol"><span class="hljs-symbol">tags:</span></span> - test <span class="hljs-symbol"><span class="hljs-symbol">script:</span></span> - docker stop iris-$CI_COMMIT_REF_NAME <span class="hljs-params"><span class="hljs-params">||</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> - docker rm -f iris-$CI_COMMIT_REF_NAME <span class="hljs-params"><span class="hljs-params">||</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre> <br><p>  Dieses Skript zerstört den laufenden Container und ist immer erfolgreich (standardmäßig gibt Docker einen Fehler zurück, wenn versucht wird, einen nicht vorhandenen Container zu stoppen / löschen). </p><br><p>  Danach starten wir einen neuen Container und registrieren ihn als Umgebung. </p><br><pre> <code class="hljs powershell">run image: stage: run environment: name: <span class="hljs-variable"><span class="hljs-variable">$CI_COMMIT_REF_NAME</span></span> url: http://<span class="hljs-variable"><span class="hljs-variable">$CI_COMMIT_REF_SLUG</span></span>.docker.eduard.win/index.html tags: - test script: - docker run <span class="hljs-literal"><span class="hljs-literal">-d</span></span> -<span class="hljs-literal"><span class="hljs-literal">-expose</span></span> <span class="hljs-number"><span class="hljs-number">52773</span></span> -<span class="hljs-literal"><span class="hljs-literal">-volume</span></span> /InterSystems/durable/<span class="hljs-variable"><span class="hljs-variable">$CI_COMMIT_REF_SLUG:</span></span>/<span class="hljs-keyword"><span class="hljs-keyword">data</span></span> -<span class="hljs-literal"><span class="hljs-literal">-env</span></span> ISC_DATA_DIRECTORY=/<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>/sys -<span class="hljs-literal"><span class="hljs-literal">-env</span></span> VIRTUAL_HOST=<span class="hljs-variable"><span class="hljs-variable">$CI_COMMIT_REF_SLUG</span></span>.docker.eduard.win -<span class="hljs-literal"><span class="hljs-literal">-name</span></span> iris-<span class="hljs-variable"><span class="hljs-variable">$CI_COMMIT_REF_NAME</span></span> docker.eduard.win/test/docker:<span class="hljs-variable"><span class="hljs-variable">$CI_COMMIT_REF_NAME</span></span> -<span class="hljs-literal"><span class="hljs-literal">-log</span></span> <span class="hljs-variable"><span class="hljs-variable">$ISC_PACKAGE_INSTALLDIR</span></span>/mgr/messages.log</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der Nginx-Container</a> leitet Anforderungen mithilfe der Umgebungsvariablen <code>VIRTUAL_HOST</code> automatisch an den angegebenen Port um - in diesem Fall 52773. </p><br><p>  Da in InterSystems IRIS einige Daten (Kennwörter,% SYS, Anwendungsdaten) auf dem Host gespeichert werden müssen, gibt es eine <a href="">dauerhafte% SYS-</a> Funktion, mit der Sie Daten auf dem Host speichern können, z. </p><br><ul><li>  <code>iris.cpf</code> ist die Hauptkonfigurationsdatei. </li><li>  Das <code>/csp</code> mit Webanwendungsdateien. </li><li>  <code>/httpd/httpd.conf</code> mit privater Apache-Serverkonfiguration. </li><li>  Das Verzeichnis <code>/mgr</code> in dem gespeichert sind: <br><ul><li>  Datenbanken <code>IRISSYS</code> , <code>IRISTEMP</code> , <code>IRISAUDIT</code> , <code>IRIS</code> , <code>USER</code> . </li><li>  <code>IRIS.WIJ</code> . </li><li>  Verzeichnis <code>/journal</code> gespeichert sind. </li><li>  Das Verzeichnis <code>/temp</code> für temporäre Dateien. </li><li>  Protokolliert <code>messages.log</code> , <code>journal.log</code> , <code>SystemMonitor.log</code> . </li></ul></li></ul><br><p>  Um Durable% SYS zu aktivieren, wird das <code>volume</code> Argument angegeben, das <code>ISC_DATA_DIRECTORY</code> Host-Verzeichnis <code>ISC_DATA_DIRECTORY</code> und die Variable <code>ISC_DATA_DIRECTORY</code> legt das Verzeichnis zum Speichern von Durable% SYS-Dateien fest.  Dieses Verzeichnis sollte nicht existieren, es wird automatisch erstellt. </p><br><p>  Daher ist die Architektur unserer containerisierten Anwendung wie folgt: </p><br><p><img src="https://habrastorage.org/webt/61/0q/ze/610qzezlqdilphfkapj5vac9t84.png" alt="containerisierte Anwendungsarchitektur"></p><br><p>  Um eine solche Anwendung zu erstellen, müssen wir mindestens eine zusätzliche Datenbank erstellen (um den Anwendungscode zu speichern) und deren Zuordnung im Anwendungsbereich erstellen.  Ich habe den <code>USER</code> Bereich zum Speichern von Anwendungsdaten verwendet, da dieser Bereich standardmäßig zu Durable% SYS hinzugefügt wurde.  Der Anwendungscode wird in einem Container gespeichert, damit er aktualisiert werden kann. </p><br><p>  Basierend auf dem Vorstehenden sollte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">% Installer</a> : </p><br><ul><li>  <code>APP</code> Bereich / Datenbank erstellen </li><li>  Laden Sie den Code in den <code>APP</code> Bereich <code>APP</code> </li><li>  Erstellen Sie Mapping-Klassen unserer Anwendung im <code>USER</code> Bereich </li><li>  Führen Sie eine andere Konfiguration durch (ich habe eine CSP-Webanwendung und eine REST-Webanwendung erstellt). </li></ul><br><div class="spoiler">  <b class="spoiler_title">Code% Installer</b> <div class="spoiler_text"><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">Class</span></span> MyApp.Hooks.<span class="hljs-keyword"><span class="hljs-keyword">Local</span></span> { Parameter Namespace = "APP"; /// See <span class="hljs-keyword"><span class="hljs-keyword">generated</span></span> code <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> zsetup+<span class="hljs-number"><span class="hljs-number">1</span></span>^MyApp.Hooks.<span class="hljs-keyword"><span class="hljs-keyword">Local</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span> XData Install [ XMLNamespace = INSTALLER ] { &lt;Manifest&gt; &lt;<span class="hljs-keyword"><span class="hljs-keyword">Log</span></span> <span class="hljs-type"><span class="hljs-type">Text</span></span>="Creating namespace ${Namespace}" <span class="hljs-keyword"><span class="hljs-keyword">Level</span></span>="0"/&gt; &lt;Namespace <span class="hljs-type"><span class="hljs-type">Name</span></span>="${Namespace}" <span class="hljs-keyword"><span class="hljs-keyword">Create</span></span>="yes" Code="${Namespace}" Ensemble="" Data="IRISTEMP"&gt; &lt;<span class="hljs-keyword"><span class="hljs-keyword">Configuration</span></span>&gt; &lt;<span class="hljs-keyword"><span class="hljs-keyword">Database</span></span> <span class="hljs-type"><span class="hljs-type">Name</span></span>="${Namespace}" Dir="/usr/irissys/mgr/${Namespace}" <span class="hljs-keyword"><span class="hljs-keyword">Create</span></span>="yes" MountRequired="true" Resource="%DB_${Namespace}" PublicPermissions="RW" MountAtStartup="true"/&gt; &lt;/<span class="hljs-keyword"><span class="hljs-keyword">Configuration</span></span>&gt; &lt;<span class="hljs-keyword"><span class="hljs-keyword">Import</span></span> File="${Dir}Form" Recurse="1" Flags="cdk" IgnoreErrors="1" /&gt; &lt;/Namespace&gt; &lt;<span class="hljs-keyword"><span class="hljs-keyword">Log</span></span> <span class="hljs-type"><span class="hljs-type">Text</span></span>="End Creating namespace ${Namespace}" <span class="hljs-keyword"><span class="hljs-keyword">Level</span></span>="0"/&gt; &lt;<span class="hljs-keyword"><span class="hljs-keyword">Log</span></span> <span class="hljs-type"><span class="hljs-type">Text</span></span>="Mapping to USER" <span class="hljs-keyword"><span class="hljs-keyword">Level</span></span>="0"/&gt; &lt;Namespace <span class="hljs-type"><span class="hljs-type">Name</span></span>="USER" <span class="hljs-keyword"><span class="hljs-keyword">Create</span></span>="no" Code="USER" Data="USER" Ensemble="0"&gt; &lt;<span class="hljs-keyword"><span class="hljs-keyword">Configuration</span></span>&gt; &lt;<span class="hljs-keyword"><span class="hljs-keyword">Log</span></span> <span class="hljs-type"><span class="hljs-type">Text</span></span>="Mapping Form package to USER namespace" <span class="hljs-keyword"><span class="hljs-keyword">Level</span></span>="0"/&gt; &lt;ClassMapping <span class="hljs-keyword"><span class="hljs-keyword">From</span></span>="${Namespace}" Package="Form"/&gt; &lt;RoutineMapping <span class="hljs-keyword"><span class="hljs-keyword">From</span></span>="${Namespace}" <span class="hljs-keyword"><span class="hljs-keyword">Routines</span></span>="Form" /&gt; &lt;/<span class="hljs-keyword"><span class="hljs-keyword">Configuration</span></span>&gt; &lt;CSPApplication Url="/" Directory="${Dir}client" AuthenticationMethods="64" IsNamespaceDefault="false" <span class="hljs-keyword"><span class="hljs-keyword">Grant</span></span>="%ALL" Recurse="1" /&gt; &lt;/Namespace&gt; &lt;/Manifest&gt; } /// This <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">method</span></span> generator whose code <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">generated</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> XGL. /// Main setup <span class="hljs-keyword"><span class="hljs-keyword">method</span></span> /// <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> vars("Namespace")="TEMP3" /// <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> ##<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(MyApp.Hooks.<span class="hljs-keyword"><span class="hljs-keyword">Global</span></span>).setup(.vars) ClassMethod setup(ByRef pVars, pLogLevel <span class="hljs-keyword"><span class="hljs-keyword">As</span></span> %<span class="hljs-type"><span class="hljs-type">Integer</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>, pInstaller <span class="hljs-keyword"><span class="hljs-keyword">As</span></span> %Installer.Installer) <span class="hljs-keyword"><span class="hljs-keyword">As</span></span> %Status [ CodeMode = objectgenerator, <span class="hljs-type"><span class="hljs-type">Internal</span></span> ] { Quit ##<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(%Installer.Manifest).%Generate(%compiledclass, %code, "Install") } /// Entry <span class="hljs-type"><span class="hljs-type">point</span></span> ClassMethod onAfter() <span class="hljs-keyword"><span class="hljs-keyword">As</span></span> %Status { try { <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> "START INSTALLER",! <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> vars("Namespace") = ..#Namespace <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> vars("Dir") = ..getDir() <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> sc = ..setup(.vars) <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> !,$<span class="hljs-keyword"><span class="hljs-keyword">System</span></span>.Status.GetErrorText(sc),! <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> sc = ..createWebApp() } catch ex { <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> sc = ex.AsStatus() <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> !,$<span class="hljs-keyword"><span class="hljs-keyword">System</span></span>.Status.GetErrorText(sc),! } quit sc } /// Modify web app REST ClassMethod createWebApp(appName <span class="hljs-keyword"><span class="hljs-keyword">As</span></span> %String = "/forms") <span class="hljs-keyword"><span class="hljs-keyword">As</span></span> %Status { <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>:$e(appName)<span class="hljs-string"><span class="hljs-string">'="/" appName = "/" _ appName #dim sc As %Status = $$$OK new $namespace set $namespace = "%SYS" if '</span></span>##<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">Security</span></span>.Applications).<span class="hljs-keyword"><span class="hljs-keyword">Exists</span></span>(appName) { <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> props("AutheEnabled") = $$<span class="bash"><span class="hljs-variable"><span class="bash"><span class="hljs-variable">$AutheUnauthenticated</span></span></span><span class="bash"> </span><span class="hljs-built_in"><span class="bash"><span class="hljs-built_in">set</span></span></span><span class="bash"> props(</span><span class="hljs-string"><span class="bash"><span class="hljs-string">"NameSpace"</span></span></span><span class="bash">) = </span><span class="hljs-string"><span class="bash"><span class="hljs-string">"USER"</span></span></span><span class="bash"> </span><span class="hljs-built_in"><span class="bash"><span class="hljs-built_in">set</span></span></span><span class="bash"> props(</span><span class="hljs-string"><span class="bash"><span class="hljs-string">"IsNameSpaceDefault"</span></span></span><span class="bash">) = $$</span></span>$<span class="hljs-keyword"><span class="hljs-keyword">NO</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> props("DispatchClass") = "Form.REST.Main" <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> props("MatchRoles")=":" _ $$<span class="bash"><span class="hljs-variable"><span class="bash"><span class="hljs-variable">$AllRoleName</span></span></span><span class="bash"> </span><span class="hljs-built_in"><span class="bash"><span class="hljs-built_in">set</span></span></span><span class="bash"> sc = </span><span class="hljs-comment"><span class="bash"><span class="hljs-comment">##class(Security.Applications).Create(appName, .props) } quit sc } ClassMethod getDir() [ CodeMode = expression ] { ##class(%File).NormalizeDirectory($system.Util.GetEnviron("CI_PROJECT_DIR")) } }</span></span></span></span></code> </pre> </div></div><br><p>  Ich <code>/usr/irissys/mgr</code> fest, dass ich zum Erstellen einer Datenbank, die sich nicht auf dem Host befindet, das Verzeichnis <code>/usr/irissys/mgr</code> , da der Aufruf <code>/usr/irissys/mgr</code> <code>##class(%File).ManagerDirectory()</code> den Pfad zum Verzeichnis für Durable% SYS zurückgibt. </p><br><h2 id="testy">  Tests </h2><br><p>  Führen Sie nun die Tests aus. </p><br><pre> <code class="hljs bash"><span class="hljs-built_in"><span class="hljs-built_in">test</span></span> image: stage: <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> tags: - <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> script: - docker <span class="hljs-built_in"><span class="hljs-built_in">exec</span></span> iris-<span class="hljs-variable"><span class="hljs-variable">$CI_COMMIT_REF_NAME</span></span> irissession iris -U USER <span class="hljs-string"><span class="hljs-string">"##class(isc.git.GitLab).test()"</span></span></code> </pre> <br><h2 id="dostavka-2">  Lieferung </h2><br><p>  Wenn die Tests bestanden sind, werden wir unser Bild in der Docker-Registrierung veröffentlichen. </p><br><pre> <code class="hljs pgsql">publish image: stage: publish tags: - test script: - docker <span class="hljs-keyword"><span class="hljs-keyword">login</span></span> docker.<span class="hljs-keyword"><span class="hljs-keyword">domain</span></span>.com -u <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> -p pass - docker push docker.<span class="hljs-keyword"><span class="hljs-keyword">domain</span></span>.com/test/docker:$CI_COMMIT_REF_NAME</code> </pre> <br><p>  Login / Passwort kann mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">geheimen Variablen übergeben werden</a> . </p><br><p>  Jetzt wird das Bild auf GitLab angezeigt. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/064/0b3/56f/0640b356f33ea72491c91d55399a4670.png"></p><br><p>  Andere Entwickler können es aus der Docker-Registrierung herunterladen.  Auf der Registerkarte "Umgebungen" können alle unsere Umgebungen angezeigt werden: </p><br><h1 id="vyvody">  Schlussfolgerungen </h1><br><p>  In dieser Artikelserie werden gängige Ansätze zur kontinuierlichen Integration erörtert.  Die Automatisierung der Montage, des Testens und der Bereitstellung Ihrer Anwendung auf InterSystems-Plattformen ist möglich und einfach zu implementieren. </p><br><p>  Der Einsatz von Containerisierungstechnologien wird dazu beitragen, die Anwendungsentwicklungs- und Bereitstellungsprozesse zu optimieren.  Das Beseitigen von Inkonsistenzen zwischen Umgebungen erleichtert das Testen und Debuggen.  Mit Orchestration können Sie skalierbare Anwendungen erstellen. </p><br><h1 id="ssylki">  Referenzen </h1><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vorheriger Artikel</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">InterSystems Community Series</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Code</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Github-Code</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de420749/">https://habr.com/ru/post/de420749/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de420731/index.html">Zabbix über Steroide: Funktionsweise der einheitlichen Überwachungsplattform von Sbertech</a></li>
<li><a href="../de420735/index.html">Wir laden Sie zum Finale des Find Yourself in Digital-Marathons im Büro der Mail.Ru Group ein</a></li>
<li><a href="../de420737/index.html">Mini ai cup 2 oder fast AgarIO - was könnte man tun, um zu gewinnen?</a></li>
<li><a href="../de420739/index.html">Die Box ist noch im Griff: Warum müssen Sie 2018 noch selbst Sprachen lernen?</a></li>
<li><a href="../de420741/index.html">Spickzettel für Programmierer oder "Wir werden für Sie googeln"</a></li>
<li><a href="../de420753/index.html">Microservice Frontend - ein moderner Ansatz zur Trennung der Front</a></li>
<li><a href="../de420757/index.html">Programmierwettbewerb: Handel (Ergebnisse)</a></li>
<li><a href="../de420761/index.html">TypeScript 3.0</a></li>
<li><a href="../de420763/index.html">KDD 2018, zweiter Tag, Workshops</a></li>
<li><a href="../de420765/index.html">Impressionen des Gemini PDA. Pocket Dual-Boot Harvester oder nutzloses Spielzeug?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>