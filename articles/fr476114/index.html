<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëºüèæ üí° ü§µüèΩ Et si sans Python? Julia pour l'apprentissage automatique et en g√©n√©ral üö™ üëêüèæ üïß</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nous voulons toujours √©crire du code rapidement, mais vous devez payer pour cela. Dans les langages flexibles de haut niveau ordinaires, les programme...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Et si sans Python? Julia pour l'apprentissage automatique et en g√©n√©ral</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/476114/">  Nous voulons toujours √©crire du code rapidement, mais vous devez payer pour cela.  Dans les langages flexibles de haut niveau ordinaires, les programmes peuvent √™tre d√©velopp√©s rapidement, mais ils s'ex√©cutent lentement apr√®s le lancement.  Par exemple, il est monstrueusement lent de lire quelque chose de lourd en Python pur.  Les langages de type C fonctionnent beaucoup plus rapidement, mais il est plus facile d'y faire des erreurs, dont la recherche r√©duira √† n√©ant tout le gain de vitesse. <br><br>  Habituellement, ce dilemme est r√©solu comme suit: ils √©crivent d'abord un prototype sur quelque chose de flexible, par exemple, sur Python ou R, puis le r√©√©crivent sur C / C ++ ou Fortran.  Mais ce cycle est trop long, pouvez-vous vous en passer? <br><br><img src="https://habrastorage.org/webt/c0/hu/mw/c0humwwihszecprm5u7-j1ofego.jpeg"><br><br>  Il y a peut-√™tre une solution.  Julia est un langage de programmation de haut niveau, flexible mais rapide.  Julia dispose de plusieurs r√©partiteurs, d'un compilateur intelligent int√©gr√© et d'outils de m√©taprogrammation.  <strong>Gleb Ivashkevich</strong> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">phtRaveller</a> ), le fondateur de datarythmics, qui d√©veloppe des syst√®mes d'apprentissage automatique pour l'industrie et d'autres industries, un ancien physicien, vous en dira plus sur ce que Julia a. <br><br>  Gleb expliquera pourquoi de nouveaux langages sont n√©cessaires et pourquoi parfois Python manque.  Il vous expliquera ce qui est int√©ressant chez Julia, ses forces et ses faiblesses, le comparera avec d'autres langues, et montrera ce que la langue a de la perspective de l'apprentissage automatique et de l'informatique en g√©n√©ral. <br><br>  <em>Clause de non-responsabilit√©.</em>  <em>Il n'y aura pas d'analyse syntaxique.</em>  <em>Habrazhiteli, d√©veloppeurs exp√©riment√©s, il est donc inutile de montrer comment √©crire une boucle, par exemple.</em> <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/REVmhiJ1Zi8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2>  Le probl√®me des deux langues </h2><blockquote>  Si vous √©crivez du code rapidement, les programmes s'ex√©cutent lentement.  Si les programmes fonctionnent rapidement, √©crivez-les pendant longtemps. </blockquote> Le Python classique tombe dans la premi√®re cat√©gorie.  Si vous supprimez NumPy, consid√©rez lentement quelque chose en pur Python.  D'un autre c√¥t√©, il existe des langages comme C et C ++.  Il est difficile de trouver un √©quilibre. Le plus souvent, ils √©crivent d'abord un prototype sur quelque chose de flexible et apr√®s avoir d√©bogu√© l'algorithme, ils le r√©√©crivent plus rapidement dans la langue.  Ceci est un exemple d'un <strong>probl√®me clair dans deux langues</strong> : un long cycle lorsque vous devez √©crire en Python, et le r√©√©crire en C ou en Cython, par exemple. <br><br>  Les sp√©cialistes de l'apprentissage automatique et de la science des donn√©es ont NumPy, Sklearn, TensorFlow.  Ils r√©solvent leurs probl√®mes depuis des ann√©es sans une seule ligne en C, et il semble que le probl√®me des deux langues ne les concerne pas.  Ce n'est pas le cas, le probl√®me se manifeste <strong>implicitement</strong> , car le code dans NumPy ou dans TensorFlow n'est en fait pas vraiment Python.  Il est utilis√© comme m√©talangage pour lancer ce qui est √† l'int√©rieur.  L'int√©rieur est exactement C / Fortran (dans le cas de NumPy) ou C ++ (dans le cas de TensorFlow). <br><br>  Cette ¬´fonctionnalit√©¬ª est mal visible, par exemple, dans PyTorch, mais dans Numpy, elle est clairement visible.  Par exemple, si un cycle Python classique est apparu dans les calculs, alors quelque chose s'est mal pass√©.  Dans le code productif, les boucles ne sont pas n√©cessaires; vous devez tout r√©√©crire pour que NumPy puisse le vectoriser et le calculer rapidement. <br><br>  En m√™me temps, il semble √† beaucoup que NumPy est rapide et tout va bien.  Voyons ce que NumPy a sous le capot pour voir cela. <br><br><ul><li>  NumPy essaie de r√©soudre le probl√®me de flexibilit√© du type Python, il a donc un <strong>syst√®me de type</strong> assez <strong>strict</strong> .  Si le tableau a un certain type, il ne peut rien y avoir d'autre; si <code>Float64</code> est <code>Float64</code> , rien ne peut √™tre fait √† ce sujet. </li><li>  <strong>Envoi.</strong>  Selon les types de tableaux et les op√©rations que vous devez effectuer, NumPy d√©cidera en lui-m√™me quelle fonction appeler pour effectuer les calculs le plus rapidement possible.  La biblioth√®que essaiera de jeter Python classique hors de la boucle de calcul. </li></ul><br>  Il s'av√®re que Numpy n'est pas aussi rapide qu'il n'y para√Æt.  C'est pourquoi il existe des projets comme <strong>Cython</strong> ou <strong>Numba</strong> .  Le premier g√©n√®re du code C √† partir de "l'hybride" de Python et C, et le second compile le code en Python et g√©n√©ralement c'est plus rapide. <br><blockquote>  Si NumPy √©tait vraiment aussi rapide qu'il y para√Æt, alors l'existence de Cython et Numba n'aurait aucun sens. </blockquote>  Nous r√©√©crivons tout en Cython si nous voulons trouver rapidement quelque chose de grand et de complexe.  L'un des crit√®res de qualit√© d'un wrapper en Cython est la pr√©sence ou l'absence d'appels Python purs dans le code g√©n√©r√©. <br><br>  Un exemple simple: nous ajoutons le type (bon) ou n'ajoutons pas (mauvais), et nous obtenons deux codes compl√®tement diff√©rents, bien qu'en plus des types les options initiales ne soient pas diff√©rentes. <br><br><img src="https://habrastorage.org/webt/23/nj/e0/23nje0ddwbpf8c9debfufjvg0h8.png"><br><br>  Lorsque nous g√©n√©rons le code C, dans le premier cas, nous obtenons ce qui suit: <br><br><pre> <code class="cpp hljs">__pyx_t_4 = __pyx_v_i; __pyx_v_result = (__pyx_v_result + (*((<span class="hljs-keyword"><span class="hljs-keyword">double</span></span> *) ( <span class="hljs-comment"><span class="hljs-comment">/* dim=0 */</span></span> (__pyx_v_a.data + __pyx_t_4 * __pyx_v_a.strides[<span class="hljs-number"><span class="hljs-number">0</span></span>]) ))));</code> </pre> <br>  Et dans le deuxi√®me <code>result =0.</code>  se transformera en ceci: <br><br><pre> <code class="cpp hljs">__pyx_t_6 = PyFloat_FromDouble((*((<span class="hljs-keyword"><span class="hljs-keyword">double</span></span> *) ( <span class="hljs-comment"><span class="hljs-comment">/* dim=0 */</span></span> (__pyx_v_a.data + __pyx_t_4 * __pyx_v_a.strides[<span class="hljs-number"><span class="hljs-number">0</span></span>]) )))); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (unlikely(!__pyx_t_6)) __PYX_ERR(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, __pyx_L1_error) __Pyx_GOTREF(__pyx_t_6); __pyx_t_7 = PyNumber_InPlaceAdd(__pyx_v_result, __pyx_t_6); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (unlikely(!__pyx_t_7)) __PYX_ERR(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, __pyx_L1_error) __Pyx_GOTREF(__pyx_t_7); __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = <span class="hljs-number"><span class="hljs-number">0</span></span>; __Pyx_DECREF_SET(__pyx_v_result, __pyx_t_7); __pyx_t_7 = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br>  Lorsqu'un type est sp√©cifi√©, le code C s'ex√©cute rapidement comme l'√©clair.  Si le type n'est pas sp√©cifi√©, nous voyons Python normal, mais du c√¥t√© C: les appels Python standard, o√π pour une raison quelconque, des <code>float</code> sont cr√©√©s √† partir de <code>double</code> , les liens sont compt√©s et beaucoup d'autres codes inutiles.  Ce code est lent car il appelle Python pour chaque op√©ration. <br><br><h3>  Est-il possible de r√©soudre tous les probl√®mes √† la fois </h3><br>  C'est dr√¥le que lorsque nous pensons √† quelque chose, nous essayons de supprimer du Python pur.  Il existe deux options pour ce faire. <br><br><ul><li>  Utilisation de <strong>Cython</strong> ou d'autres outils.  Il existe de nombreuses fa√ßons d'optimiser votre code Cython afin de vous retrouver avec presque aucun appel Python.  Mais ce n'est pas l'activit√© la plus agr√©able: tout n'est pas si √©vident en Cython, et seulement un peu moins de temps est pass√© que si vous √©crivez tout en C. Le module r√©sultant peut √™tre utilis√© en Python, mais cela prend encore beaucoup de temps, des erreurs se produisent, le code n'est pas toujours √©vident et on ne sait pas toujours comment l‚Äôoptimiser. </li><li>  Utiliser Numba, qui fait une <strong>compilation JIT</strong> . </li></ul><br>  Mais peut-√™tre qu'il y a une meilleure fa√ßon, et je pense que c'est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Julia</a> . <br><br><h2>  Julia </h2><br>  Les cr√©ateurs affirment qu'il s'agit d'un langage <strong>rapide</strong> , de <strong>haut niveau</strong> et <strong>flexible</strong> , comparable √† Python en termes de facilit√© d'√©criture de code.  √Ä mon avis, Julia est comme un <strong>langage de script:</strong> vous n'avez pas besoin de faire ce que vous avez √† faire en C, o√π tout est de tr√®s bas niveau, y compris les structures de donn√©es.  Dans le m√™me temps, vous pouvez travailler dans une console standard, comme avec Python et d'autres langages. <br><br>  Julia utilise <strong>la compilation Just-In-Time</strong> - c'est l'un des √©l√©ments qui donne de la vitesse.  Mais le langage est bon avec les calculs, car il a √©t√© d√©velopp√© pour eux.  Julia est utilis√©e pour des t√¢ches scientifiques et obtient des performances d√©centes. <br><blockquote>  Bien que Julia essaie de ressembler √† un langage polyvalent, Julia est bonne pour l'informatique et pas tr√®s bonne pour les services Web.  Utiliser Julia au lieu de Django, par exemple, n'est pas le meilleur choix. </blockquote>  Regardons les caract√©ristiques du langage comme exemple d'une fonction primitive. <br><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> f(x) Œ± = <span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>x <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> julia&gt; methods(f) <span class="hljs-comment"><span class="hljs-comment"># 1 method for generic function "f": [1] f(x) in Main at mpconf.jl:2</span></span></code> </pre> <br>  Quatre caract√©ristiques sont visibles dans ce code. <br><br><ul><li>  <strong>Il n'y a pratiquement aucune restriction sur l'utilisation d'Unicode</strong> .  Vous pouvez prendre des formules d'un article sur l'apprentissage en profondeur ou la mod√©lisation num√©rique, r√©√©crire avec les m√™mes caract√®res, et tout fonctionnera - Unicode est cousu presque partout. </li><li>  <strong>Il n'y a pas de signe de multiplication.</strong>  Cependant, il n'est pas toujours possible de s'en passer, par exemple, par 2.x (un nombre √† virgule flottante fois x) Julia jurera. </li><li>  <strong>Pas de <code>return</code></strong> .  En g√©n√©ral, il est recommand√© d'√©crire <code>return</code> pour voir ce qui se passe, mais l'exemple retournera <code>Œ±</code> , car l'affectation est une expression. </li><li>  <strong>Pas de types</strong> .  Il semblerait que s'il y a de la vitesse, √† un moment donn√©, les types devraient appara√Ætre?  Oui, ils appara√Ætront, mais plus tard. </li></ul><br>  Julia a trois fonctionnalit√©s qui offrent flexibilit√© et rapidit√©: <strong>r√©partition multiple, m√©taprogrammation et parall√©lisme</strong> .  Nous parlerons des deux premiers, et laisserons la parall√©lisation √† l'√©tude ind√©pendante pour les utilisateurs avanc√©s. <br><br><h3>  Planification multiple </h3><br>  L'appel aux <code>methods(f)</code> dans l'exemple ci-dessus semble inattendu - quel type de m√©thodes poss√®de la fonction?  Nous sommes habitu√©s au fait que nous avons des objets de classe, les classes ont des m√©thodes.  Mais chez Julia tout est retourn√©: les fonctions ont des m√©thodes, car le langage utilise plusieurs r√©partitions. <br><blockquote>  L'ordonnancement multiple signifie que la variante d'une fonction particuli√®re qui sera ex√©cut√©e est d√©termin√©e par l'ensemble des types de param√®tres de cette fonction. </blockquote>  Je vais d√©crire bri√®vement comment cela fonctionne sur un exemple d√©j√† familier. <br><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> f(x) Œ± = <span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>x <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> f(x::<span class="hljs-built_in"><span class="hljs-built_in">AbstractFloat</span></span>) Œ± = <span class="hljs-number"><span class="hljs-number">1</span></span> + sin(x) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> julia&gt; methods(f) <span class="hljs-comment"><span class="hljs-comment"># 2 methods for generic function "f": [1] f(x::AbstractFloat) in Main at mpconf.jl:6 [2] f(x) in Main at mpconf.jl:2</span></span></code> </pre> <br>  Les variantes de la m√™me fonction pour diff√©rents ensembles de types sont appel√©es m√©thodes.  Il y en a deux dans le code: le premier pour tous les nombres √† virgule flottante et le second pour tout le reste.  Lorsque nous appelons la fonction pour la premi√®re fois, Julia d√©cidera de la m√©thode √† utiliser et de la compilation.  S'il a d√©j√† √©t√© appel√© et compil√©, il prendra celui qui l'est. <br><br>  √âtant donn√© que dans Julia, tout n'est pas la fa√ßon dont nous sommes habitu√©s, ici vous pouvez ajouter des fonctions aux types d√©finis par l'utilisateur, mais ce ne seront pas des m√©thodes de type au sens de la POO.  Ce sera simplement le champ dans lequel la fonction est √©crite, car la <strong>fonction est le m√™me objet √† part enti√®re</strong> que tout le reste. <br><br>  Pour savoir exactement ce qui sera d√©clench√©, il existe des macros sp√©ciales.  Ils commencent par <code>@</code> .  Dans l'exemple, la macro <code>@which</code> permet de savoir quelle m√©thode a √©t√© appel√©e pour un cas sp√©cifique. <br><br><img src="https://habrastorage.org/webt/nu/ix/ih/nuixiha2x9r2b148gdqyo81fkri.png"><br><br>  Dans le premier cas, Julia a d√©cid√© que puisque 2 est un entier, il ne correspond pas √† <code>AbstractFloat</code> et a appel√© la premi√®re option.  Dans le deuxi√®me cas, elle a d√©cid√© qu'il s'agissait de <code>Float</code> et avait d√©j√† demand√© une version sp√©cialis√©e.  Cela fonctionnera approximativement si vous ajoutez d'autres m√©thodes pour certains types sp√©cifiques. <br><br><h3>  LLVM et JIT </h3><br>  Julia utilise le framework LLVM pour compiler.  La biblioth√®que de compilation JIT est fournie dans un pack de langue.  La premi√®re fois que la fonction est appel√©e, Julia cherche √† voir si la fonction a √©t√© utilis√©e avec cet ensemble de types et la compile si n√©cessaire.  Le premier lancement prendra un certain temps, puis tout fonctionnera rapidement. <br><blockquote>  La fonction sera compil√©e lors du premier appel pour cet ensemble de param√®tres. </blockquote>  Caract√©ristiques du compilateur <br><br><ul><li>  <strong>Le compilateur est raisonnablement raisonnable</strong> car LLVM est un bon produit. </li><li>  La plupart des d√©veloppeurs avanc√©s peuvent <strong>examiner le processus de compilation</strong> et voir ce qu'il g√©n√®re. </li><li>  <strong>La compilation de Julia et Numba est similaire</strong> .  Dans Numba, vous cr√©ez √©galement un d√©corateur JIT, mais dans Numba, vous ne pouvez pas "entrer" autant et d√©cider quoi optimiser ou changer. </li></ul><br>  Pour illustrer le travail du compilateur, je vais donner un exemple de fonction simple: <br><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> f(x) Œ± = <span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-number"><span class="hljs-number">3</span></span>x <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> julia&gt; <span class="hljs-meta"><span class="hljs-meta">@code_llvm</span></span> f(<span class="hljs-number"><span class="hljs-number">2</span></span>) define i64 <span class="hljs-meta"><span class="hljs-meta">@julia_f_35897</span></span>(i64) { top: %<span class="hljs-number"><span class="hljs-number">1</span></span> = mul i64 %<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span> %<span class="hljs-number"><span class="hljs-number">2</span></span> = add i64 %<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span> ret i64 %<span class="hljs-number"><span class="hljs-number">2</span></span> }</code> </pre><br>  La macro <code>@code_llvm</code> vous permet de voir le r√©sultat de la g√©n√©ration.  Ce <strong>LLVM IR</strong> est <strong>une repr√©sentation interm√©diaire</strong> , une sorte d'assembleur. <br><br>  Dans le code, l'argument de la fonction est multipli√© par 3, 1 est ajout√© au r√©sultat, le r√©sultat est renvoy√©.  Tout est aussi simple que possible.  Si vous d√©finissez la fonction un peu diff√©remment, par exemple, remplacez 3 par 2, alors tout changera. <br><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> f(x) Œ± = <span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>x <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> julia&gt; <span class="hljs-meta"><span class="hljs-meta">@code_llvm</span></span> f(<span class="hljs-number"><span class="hljs-number">2</span></span>) define i64 <span class="hljs-meta"><span class="hljs-meta">@julia_f_35894</span></span>(i64) { top: %<span class="hljs-number"><span class="hljs-number">1</span></span> = shl i64 %<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span> %<span class="hljs-number"><span class="hljs-number">2</span></span> = or i64 %<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span> ret i64 %<span class="hljs-number"><span class="hljs-number">2</span></span> }</code> </pre> <br>  Il semblerait, quelle est la diff√©rence: 2, 3, 10?  Mais Julia et LLVM voient que lorsque vous appelez une fonction pour un entier, vous pouvez faire un peu plus intelligemment.  La multiplication par deux d'un entier est un d√©calage vers la gauche d'un bit - c'est plus rapide que le produit.  Mais, bien s√ªr, cela ne fonctionne que pour les entiers, cela ne fonctionnera pas pour d√©caler <code>Float</code> gauche de 1 bit et obtenir le r√©sultat de la multiplication par 2. <br><br><h3>  Types personnalis√©s </h3><br>  Les types personnalis√©s dans Julia sont aussi rapides que les types int√©gr√©s.  La planification multiple est effectu√©e sur eux, et ce sera aussi rapide que pour les types int√©gr√©s.  En ce sens, le m√©canisme de r√©partition multiple est profond√©ment ancr√© dans le langage. <br><br>  Il est logique de s'attendre √† ce que les variables n'aient pas de types, seules les valeurs en ont.  Les variables sans type ne sont qu'un marqueur, une √©tiquette sur un conteneur. <br><br>  <strong>Le syst√®me de type est hi√©rarchique.</strong>  Nous ne pouvons pas cr√©er des descendants de types concrets; les types abstraits ne peuvent les avoir que.  Cependant, les types abstraits ne peuvent pas √™tre instanci√©s.  Cette nuance ne plaira pas √† tout le monde. <br><br>  Comme les auteurs de la langue l'ont expliqu√© lorsqu'ils ont d√©velopp√© Julia, ils voulaient obtenir le r√©sultat, et si quelque chose √©tait difficile √† faire, ils l'ont refus√©.  Un tel syst√®me de type hi√©rarchique √©tait plus facile √† d√©velopper.  Ce n'est pas un probl√®me catastrophique, mais si vous ne tournez pas la t√™te au d√©but, ce ne sera pas pratique. <br><br>  <strong>Les types peuvent √™tre param√©tr√©s</strong> , ce qui est un peu comme C / C ++.  Par exemple, nous pouvons avoir une structure dans laquelle il y a des champs, mais les types de ces champs ne sont pas sp√©cifi√©s - ce sont des param√®tres.  Nous sp√©cifions un type sp√©cifique √† l'instanciation. <br><br>  <strong>Dans la plupart des cas, les types peuvent √™tre ignor√©s</strong> .  Habituellement, ils sont n√©cessaires lorsque le type aide le compilateur √† deviner la meilleure fa√ßon de compiler.  Dans ce cas, les types sont mieux √† sp√©cifier.  Vous devez √©galement sp√©cifier des types si vous souhaitez obtenir de meilleures performances. <br><br>  Voyons ce qui est possible et ce qui ne peut pas √™tre instanci√©. <br><br><img src="https://habrastorage.org/webt/0r/xr/bl/0rxrbllszhjk9okl1-3irj1zdns.png"><br><br>  Le premier type de <code>AbstractPoint</code> ne peut pas √™tre instanci√©.  Ceci est juste un parent commun pour tout le monde que nous pouvons sp√©cifier dans les m√©thodes, par exemple.  La deuxi√®me ligne indique que <code>PlanarPoint{T}</code> est un descendant de ce point abstrait.  Sous les champs commencent - ici vous pouvez voir le param√©trage.  Vous pouvez mettre ici un <code>float</code> , <code>int</code> ou un autre type. <br><br>  Le premier type ne peut pas √™tre instanci√©, et pour tout le reste, il est impossible de cr√©er des descendants.  De plus, par d√©faut, ils sont <strong>immuables</strong> .  Pour pouvoir modifier les champs, cela doit √™tre sp√©cifi√© explicitement. <br><br>  Lorsque tout est pr√™t, vous pouvez par exemple continuer √† calculer la distance pour diff√©rents types de points.  Dans l'exemple, le premier point sur le plan est <code>PlanarPoint</code> , puis sur la sph√®re et sur le cylindre.  Selon les deux points dont nous calculons la distance, nous devons utiliser diff√©rentes m√©thodes.  En g√©n√©ral, la fonction ressemblera √† ceci: <br><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> describe(p::AbstractPoint) println(<span class="hljs-string"><span class="hljs-string">"Point instance: </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$p</span></span></span><span class="hljs-string">"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  Pour <code>Float64</code> , <code>Float32</code> , <code>Float16</code> ce sera: <br><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> distance(pf::PlanarPoint{T}, ps::PlanarPoint{T}) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T&lt;:<span class="hljs-built_in"><span class="hljs-built_in">AbstractFloat</span></span> sqrt((pf.x-ps.x)^<span class="hljs-number"><span class="hljs-number">2</span></span> + (pf.y-ps.y)^<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  Et pour les entiers, la m√©thode de calcul de la distance ressemblera √† ceci: <br><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> distance(pf::PlanarPoint{T}, ps::PlanarPoint{T}) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T&lt;:<span class="hljs-built_in"><span class="hljs-built_in">Integer</span></span> abs(pf.x-ps.x) + abs(pf.y-ps.y) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  Pour les points de chaque type, diff√©rentes m√©thodes seront appel√©es. <br><br><img src="https://habrastorage.org/webt/ya/8n/_d/ya8n_dvihkdqpsmqfkmdl5wm_ro.png"><br><br>  Si vous trichez et appliquez par exemple la <code>distance(f1, i2)</code> , Julia jurera: ¬´Je ne connais pas cette m√©thode!  Vous m'avez demand√© de telles m√©thodes et avez dit qu'elles sont toutes les deux du m√™me type.  Vous ne m'avez pas dit comment compter cela quand un param√®tre est <code>float</code> et l'autre est <code>int</code> . " <br><br><h3>  La vitesse </h3><br>  Vous avez peut-√™tre d√©j√† √©t√© ravi: ¬´Il y a une compilation JIT: l'√©criture est facile, elle fonctionnera rapidement.  Jetez Python et commencez √† √©crire en Julia! ¬ª <br><br>  Mais pas si simple.  Toutes les fonctionnalit√©s de Julia ne seront pas rapides.  Cela d√©pend de deux facteurs. <br><br><ul><li>  <strong>Du d√©veloppeur</strong> .  Il n'y a pas de langues dans lesquelles une fonction sera rapide.  Un d√©veloppeur inexp√©riment√© √©crira m√™me du code en C qui fonctionnera beaucoup plus lentement que le code Python d'un d√©veloppeur exp√©riment√©.  Chaque langue a ses propres astuces et nuances dont d√©pendent les performances.  Le compilateur, qu'il soit statique ou JIT, ne peut pas fournir toutes les options imaginables et tout optimiser du tout. </li><li>  <strong>De la stabilit√© du type</strong> .  Dans une version plus rapide, les fonctions stables par type seront compil√©es. </li></ul><br><h3>  Stabilit√© du type </h3><br>  Qu'est-ce que la stabilit√© de type?  Lorsque le compilateur ne peut pas deviner de mani√®re suffisamment fiable ce qui se passe avec les types, il doit g√©n√©rer beaucoup de code wrapper pour que tout ce qui arrive √† l'entr√©e fonctionne. <br><br>  Un exemple simple pour comprendre la stabilit√© du type. <br><br><img src="https://habrastorage.org/webt/ye/83/jv/ye83jvzws3gkfjvobwf6xvtlpaq.png"><br><br>  Les sp√©cialistes du machine learning diront qu'il s'agit d'une activation relu normale: si x&gt; 0, retournez-la telle quelle, sinon retournez z√©ro.  Un probl√®me est le z√©ro apr√®s l'entier du point d'interrogation.  Cela signifie que si nous appelons cette fonction pour un nombre √† virgule flottante, alors dans un cas, un nombre √† virgule flottante sera retourn√©, et dans l'autre, un entier. <br><br>  Le compilateur ne peut pas deviner le type de r√©sultat uniquement par le type d'argument de fonction.  Il a √©galement besoin d'en conna√Ætre le sens.  Par cons√©quent, il g√©n√®re beaucoup de code. <br><br>  Ensuite, nous cr√©ons un tableau de 100 pour 100 nombres al√©atoires de 0 √† 1, le d√©calons de 0,5 pour r√©partir uniform√©ment les nombres positifs et n√©gatifs et mesurons le r√©sultat.  Il y a deux points int√©ressants: le point et la fonction.  Le point apr√®s <code>rand(100,100)</code> signifie "appliquer √† chaque √©l√©ment".  Si vous avez une sorte de collection et de fonction scalaire, vous y mettez un terme, et Julia fera le reste.  Nous pouvons supposer que c'est aussi efficace qu'une boucle normale dans un langage compil√© normal.  Pas besoin d'√©crire <code>for</code> - tout sera fait pour vous. <br><br>  Il n'y a aucun probl√®me √† ce stade - le <strong>probl√®me est √† l'int√©rieur de la fonction elle-m√™me</strong> .  Le temps d'ex√©cution estim√© d'une telle option sur un ordinateur d√©cent pour une telle matrice est de microsecondes.  Mais en r√©alit√© - millisecondes, ce qui est trop pour une si petite matrice. <br><br>  Modifiez une seule ligne. <br><br><img src="https://habrastorage.org/webt/bt/3g/4t/bt3g4t3kgng3thzuyb75mi_bmzw.png"><br><br>  La fonction <code>zero(x)</code> s'ex√©cute g√©n√®re un z√©ro du m√™me type que l'argument <code>(x)</code> .  Cela signifie que quelle que soit la valeur de <code>x</code> , le type de r√©sultat sera toujours connu par le type de <code>x</code> lui-m√™me. <br><blockquote>  Lorsque nous examinons uniquement le type d'arguments et connaissons d√©j√† le type de r√©sultat, ce sont des fonctions dont le type est stable. </blockquote>  Si nous devons examiner la signification des arguments, ce ne sont pas des fonctions stables. <br><br>  Lorsque le compilateur peut optimiser le code, la diff√©rence de temps d'ex√©cution est obtenue de deux ordres de grandeur.  Dans le deuxi√®me exemple, il n'a √©t√© allou√© exactement qu'√† un nouveau tableau, quelques dizaines d'octets de plus et rien de plus.  Cette option est beaucoup plus efficace que la pr√©c√©dente. <br><br>  C'est la principale chose √† surveiller lorsque nous √©crivons du code dans Julia.  Si vous √©crivez comme en Python, cela fonctionnera comme en Python.  Si vous effectuez les m√™mes op√©rations sur NumPy, z√©ro avec ou sans point ne joue pas de r√¥le.  Mais dans Julia, cela peut consid√©rablement compromettre les performances. <br><br>  Heureusement, il existe une m√©thode pour savoir s'il existe un probl√®me.  Il s'agit de la macro <code>@code_warntype</code> , qui vous permet de savoir si le compilateur peut deviner o√π se trouvent les types et optimiser si tout va bien. <br><br><img src="https://habrastorage.org/webt/bg/jp/xf/bgjpxfne2jxskxqaloz2omljbda.png"><br><br>  Dans la premi√®re option (√† gauche), le compilateur n'est pas s√ªr du type et l'affiche en rouge.  Dans le second cas, il y aura toujours <code>Float64</code> pour un tel argument, vous pouvez donc g√©n√©rer du code beaucoup plus court. <br><br>  Ce n'est pas encore LLVM, mais le code Julia √©tiquet√©, <code>return 0</code> ou <code>return 0.0</code> donne une diff√©rence de performance de deux ordres de grandeur. <br><br><h3>  M√©taprogrammation </h3><blockquote>  La m√©taprogrammation consiste √† cr√©er des programmes dans un programme et √† les ex√©cuter en d√©placement. </blockquote>  Il s'agit d'une m√©thode puissante qui vous permet de faire de nombreuses choses int√©ressantes.  Un exemple classique est Django ORM, qui cr√©e des champs √† l'aide de m√©taclasses. <br><br>  Beaucoup de gens connaissent l'avertissement de <strong>Tim Peters</strong> , auteur de Zen of Python: <i>¬´Les m√©taclasses sont une magie plus profonde dont 99% des utilisateurs ne devraient jamais s'inqui√©ter.</i>  <i>Si vous vous demandez si des m√©taclasses sont n√©cessaires en Python, vous n'en avez pas besoin.</i>  <i>Si vous en avez besoin, vous savez exactement pourquoi et comment les utiliser. ¬ª</i> <i><br></i> <br>  Avec la m√©taprogrammation, la situation est similaire, mais chez Julia, elle est cousue beaucoup plus profond√©ment, c'est une caract√©ristique importante de toute la langue.  Le code Julia est la m√™me structure de donn√©es que n'importe quel autre, vous pouvez manipuler, combiner, cr√©er des expressions, et tout cela fonctionnera. <br><br><pre> <code class="julia hljs">julia&gt; x = <span class="hljs-number"><span class="hljs-number">4</span></span>; julia&gt; typeof(:(x+<span class="hljs-number"><span class="hljs-number">1</span></span>)) <span class="hljs-built_in"><span class="hljs-built_in">Expr</span></span> julia&gt; expr = :(x+<span class="hljs-number"><span class="hljs-number">1</span></span>) :(x + <span class="hljs-number"><span class="hljs-number">1</span></span>) julia&gt; expr.head :call julia&gt; expr.args <span class="hljs-number"><span class="hljs-number">3</span></span>-element <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">Any</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>}: :+ :x <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  <strong>Les macros sont l'un des outils de m√©taprogrammation de Julia</strong> : nous leur donnons quelque chose, elles regardent, ajoutent le bon, suppriment l'inutile et donnent le r√©sultat.  Dans tous les exemples pr√©c√©dents, nous avons pass√© l'appel de fonction et la macro √† l'int√©rieur a analys√© l'appel.  Tout cela se passe au niveau du travail avec l'arbre de syntaxe. <br><br>  Vous pouvez analyser des expressions tr√®s simples: si c'est par exemple <code>(x+1)</code> , alors c'est un appel √† la fonction <code>+</code> (l'addition n'est pas un op√©rateur, comme dans beaucoup d'autres langues, mais une fonction) et deux arguments: un caract√®re (un deux-points signifie qu'il s'agit d'un caract√®re ), et le second n'est qu'une constante. <br><br>  Un autre exemple de macro simple: <br><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">macro</span></span> named(name, expr) println(<span class="hljs-string"><span class="hljs-string">"Starting </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$name</span></span></span><span class="hljs-string">"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">quote</span></span> $(esc(expr)) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> julia&gt; <span class="hljs-meta"><span class="hljs-meta">@named</span></span> <span class="hljs-string"><span class="hljs-string">"some process"</span></span> x=<span class="hljs-number"><span class="hljs-number">5</span></span>; Starting some process julia&gt; x <span class="hljs-number"><span class="hljs-number">5</span></span></code> </pre> <br>  √Ä l'aide de macros, par exemple, des indicateurs de progression ou des filtres pour les trames de donn√©es sont cr√©√©s - c'est un m√©canisme courant dans Julia. <br><blockquote>  Les macros ne sont pas ex√©cut√©es au moment de l'appel, mais lors de l'analyse du code. </blockquote>  Il s'agit de la principale fonction macro de Julia.  -    ,       .   ,   ,       . <br><br><h3> ,      </h3><br> Julia ‚Äî     .      . <br><br><ul><li> Julia  <strong> </strong> .       . </li><li> <strong> </strong> ,    .    ,   ,  C    . </li><li>  Julia <strong>JIT-  </strong> .   ,  , ,   ,    . </li><li>     ‚Äî <strong> </strong> .      . </li><li> <strong>    </strong>     ( ).       ,         .    ,    ,    . </li><li> Julia  <strong></strong> ‚Äî      . </li></ul><br><h2>  √âcosyst√®me </h2><br>  ,    ,   Julia   .    ,     , data science   ,    ,  ,     Python. ,  Python  Pandas,      ,    ,    ,   Julia      . <br><br>  Julia  ,       Python 2008 .        Python,        ,    Julia.    ,     .    ,    Julia. <br><br><h3>   ( ) Python  Julia </h3><br> <strong> </strong> .    Julia:  , ,    .‚Ä¶ <br><br> <strong></strong> .   . <br><br><ul><li> <strong>DataFrames.jl</strong> . </li><li>   <strong>JuliaDB</strong>     ,       . </li><li>        <strong>Query.jl</strong> .     Pandas ‚Äî    - ,   .. </li></ul><br> <strong>Plotting</strong> .     <strong>Matplotlib</strong> ,         Julia.     :  <strong>VegaLite.jl</strong> ,   <strong>Plots.jl</strong> ,     ,  <strong>Gadfly.jl</strong> . <br><br> <strong> </strong> .    <strong>TensorFlow</strong> ,     Flux.jl.    Flux    , ,     ,   Keras  TensorFlow,   .      . <br><br> <strong>Scikit-learn</strong> .   ,  ,     sklearn,    ,  . <br><br> <strong>XGBoost</strong> .  ,  Julia   . <br><br><h3>     ? </h3><br>     <strong>Jupyter</strong> . IDE ‚Äî  Juno,    Visual Studio,         . <br><br> <strong></strong> .  GPU/TPU  .  CUDAnative.jl    Julia     .    Julia-,    -     ,        .    ,      ,      , , . <br><br> <strong> :</strong>   C, Fortran, Python   . <br><br> <strong> </strong>   ,    . <br><br> <strong>Packaging</strong> :      Julia:      , ,   .. <br><br><h3>   </h3><br>      ,      ,   .  ,   ,    .   ,   <strong>PyTorch</strong>       ,  TensorFlow,     ,        . <br><br>      ,        , ,      .      Julia,   , ,      .   ,   <strong> </strong> ,  <strong>Zygote.jl</strong> .     Flux.jl. <br><br><pre> <code class="julia hljs">julia&gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Zygote julia&gt; <span class="hljs-literal"><span class="hljs-literal">œÜ</span></span>(x) = x*sin(x) julia&gt; Zygote.gradient(<span class="hljs-literal"><span class="hljs-literal">œÜ</span></span>, <span class="hljs-literal"><span class="hljs-literal">œÄ</span></span>/<span class="hljs-number"><span class="hljs-number">2.</span></span>) (<span class="hljs-number"><span class="hljs-number">1.0</span></span>,) julia&gt; model = Chain(Dense(<span class="hljs-number"><span class="hljs-number">768</span></span>, <span class="hljs-number"><span class="hljs-number">128</span></span>, relu), Dense(<span class="hljs-number"><span class="hljs-number">128</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>), softmax) julia&gt; loss(x, y) = crossentropy(model(x), y) + sum(norm, params(model)) julia&gt; optimizer = ADAM(<span class="hljs-number"><span class="hljs-number">0.001</span></span>) julia&gt; Flux.train!(loss, params(model), data, optimizer) julia&gt; model = Chain(x -&gt; sqrt(x), x-&gt;x-<span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br>     <code>œÜ</code>  , , ,       . <br><br>  Zygote   ¬´source-to-source¬ª:         ,    ,   .   <strong>differentiable programming ‚Äî  </strong> ‚Äî       backpropagation     ,    . <br><br>     Julia     : ¬´source-to-source¬ª          ,      . ,     . <br><br><h2>  Julia  ? </h2><br>     ,         ‚Äî  .        . <br><br>   - , , ,       ‚Äî . <br><br>    ,   ,  . <br><br>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Julia</a> ,   . <br><br><ul><li>     ,  ,    . Julia   ¬´¬ª . </li><li>    ,     API,     ,    . </li></ul><br><blockquote>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Moscow Python Conf++</a>    ,  27   ,          Python  Julia.   ,     ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">telegram-</a>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a>  MoscowPython. </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr476114/">https://habr.com/ru/post/fr476114/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr476104/index.html">N'utilisez pas MTProxy gratuit et d'autres types de proxy gratuits ...</a></li>
<li><a href="../fr476106/index.html">¬´Protocoles de cryptosyst√®mes¬ª: Diffie - Hellman, El-Gamal, MTI / A (0), STS</a></li>
<li><a href="../fr476108/index.html">Cerveau mutable</a></li>
<li><a href="../fr476110/index.html">Pourquoi l'informatique a-t-elle besoin d'une marque personnelle</a></li>
<li><a href="../fr476112/index.html">Elixir comme objectif de d√©veloppement pour Python async</a></li>
<li><a href="../fr476118/index.html">Conception d'interface pour le jeu, dessinez une bague Havel de Dark Souls 3</a></li>
<li><a href="../fr476122/index.html">¬´√âcoutez¬ª le cosmos: de la mati√®re noire √† la com√®te Churyumov - Gerasimenko</a></li>
<li><a href="../fr476126/index.html">Comment tester les performances du serveur: une s√©lection de plusieurs benchmarks open source</a></li>
<li><a href="../fr476128/index.html">Ivan Osipov et Yuri Artamonov √† propos de Kotlin et des plugins pour IntelliJ IDEA lors de la r√©union jug.msk.ru</a></li>
<li><a href="../fr476134/index.html">MONQ - surveillance et AIOps originaires de Russie</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>