<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¯ ğŸ‘¨ğŸ¿â€ğŸ¤â€ğŸ‘¨ğŸ¾ ğŸ‡ğŸ» Indeks dalam PostgreSQL - 1 ğŸ’´ ğŸ¥  ğŸš’</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pendahuluan 
 Seri artikel ini sebagian besar berkaitan dengan indeks di PostgreSQL. 

 Subjek apa saja dapat dipertimbangkan dari perspektif yang ber...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Indeks dalam PostgreSQL - 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/441962/"><h1>  Pendahuluan </h1><br>  Seri artikel ini sebagian besar berkaitan dengan indeks di PostgreSQL. <br><br>  Subjek apa saja dapat dipertimbangkan dari perspektif yang berbeda.  Kami akan membahas hal-hal yang harus menarik minat pengembang aplikasi yang menggunakan DBMS: indeks apa yang tersedia, mengapa ada begitu banyak jenis yang berbeda, dan bagaimana menggunakannya untuk mempercepat permintaan.  Topiknya mungkin dapat dicakup dalam lebih sedikit kata, tetapi dalam kerahasiaan kami berharap untuk pengembang yang ingin tahu, yang juga tertarik pada detail internal, terutama karena memahami detail tersebut memungkinkan Anda untuk tidak hanya menunda penilaian orang lain, tetapi juga membuat kesimpulan milikmu sendiri <br><br>  Pengembangan jenis indeks baru berada di luar ruang lingkup.  Ini membutuhkan pengetahuan tentang bahasa pemrograman C dan berkaitan dengan keahlian pemrogram sistem daripada pengembang aplikasi.  Untuk alasan yang sama kita hampir tidak akan membahas antarmuka pemrograman, tetapi hanya akan fokus pada hal-hal yang penting untuk bekerja dengan indeks siap pakai. <br><br>  Pada artikel ini kita akan membahas distribusi tanggung jawab antara <strong>mesin pengindeksan umum yang</strong> terkait dengan inti DBMS dan metode akses indeks individual, yang memungkinkan PostgreSQL untuk ditambahkan sebagai ekstensi.  Pada artikel selanjutnya kita akan membahas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">antarmuka metode akses</a> dan konsep kritis seperti kelas dan keluarga operator.  Setelah pengantar yang panjang tapi perlu, kami akan mempertimbangkan rincian struktur dan penerapan berbagai jenis indeks: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Hash</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">B-tree</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GiST</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SP-GiST</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GIN</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RUM</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">BRIN</a> , dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bloom</a> . <br><br><blockquote>  Sebelum kita mulai, saya ingin mengucapkan terima kasih kepada Elena Indrupskaya karena telah menerjemahkan artikel-artikel itu ke dalam bahasa Inggris. <br>  Banyak hal telah berubah sedikit sejak publikasi aslinya.  Komentar saya tentang keadaan saat ini ditunjukkan seperti ini. </blockquote><a name="habracut"></a><br><h2>  Indeks </h2><br>  Dalam PostgreSQL, indeks adalah objek basis data khusus yang terutama dirancang untuk mempercepat akses data.  Mereka adalah struktur tambahan: setiap indeks dapat dihapus dan diciptakan kembali dari informasi dalam tabel.  Terkadang Anda mungkin mendengar bahwa DBMS dapat bekerja tanpa indeks meskipun lambat.  Namun, ini bukan masalahnya, karena indeks juga berfungsi untuk menegakkan beberapa kendala integritas. <br><br>  Saat ini, enam jenis indeks dibangun ke dalam PostgreSQL 9.6, dan satu indeks lagi tersedia sebagai ekstensi - berkat perubahan signifikan dalam versi 9.6.  Jadi, harapkan jenis indeks baru dalam waktu dekat. <br><br>  Terlepas dari semua perbedaan antara jenis indeks (juga disebut metode akses), masing-masing dari mereka akhirnya mengaitkan kunci (misalnya, nilai kolom yang diindeks) dengan baris tabel yang berisi kunci ini.  Setiap baris diidentifikasi oleh TID (tuple id), yang terdiri dari jumlah blok dalam file dan posisi baris di dalam blok.  Yang mengatakan, dengan kunci yang diketahui atau beberapa informasi tentang itu kita dapat dengan cepat membaca baris-baris yang mungkin berisi informasi yang menarik kita tanpa memindai seluruh tabel. <br><br>  Penting untuk dipahami bahwa indeks mempercepat akses data dengan biaya pemeliharaan tertentu.  Untuk setiap operasi pada data yang diindeks, apakah itu penyisipan, penghapusan, atau pembaruan baris tabel, indeks untuk tabel itu perlu diperbarui juga, dan dalam transaksi yang sama.  Perhatikan bahwa pembaruan bidang tabel yang indeksnya belum dibangun tidak menghasilkan pembaruan indeks;  teknik ini disebut HOT (Heap-Only Tuples). <br><br>  Perluasan memerlukan beberapa implikasi.  Untuk memudahkan penambahan metode akses baru ke sistem, antarmuka mesin pengindeksan umum telah diterapkan.  Tugas utamanya adalah untuk mendapatkan TUT dari metode akses dan bekerja dengannya: <br><br><ul><li>  Baca data dari versi baris tabel yang sesuai. </li><li>  Ambil versi baris TID oleh TID atau dalam batch menggunakan bitmap prebuilt. </li><li>  Periksa visibilitas versi baris untuk transaksi saat ini dengan mempertimbangkan tingkat isolasinya. </li></ul><br>  Mesin pengindeksan terlibat dalam melakukan kueri.  Itu disebut sesuai dengan rencana yang dibuat pada tahap optimisasi.  Pengoptimal, memilah dan mengevaluasi berbagai cara untuk melakukan kueri, harus memahami kemampuan semua metode akses yang berpotensi berlaku.  Apakah metode ini dapat mengembalikan data dalam urutan yang diperlukan atau haruskah kami mengantisipasi penyortiran?  Bisakah kita menggunakan metode ini untuk mencari NULL?  Ini adalah masalah yang diselesaikan oleh optimizer secara teratur. <br><br>  Tidak hanya pengoptimal membutuhkan informasi tentang metode akses.  Ketika membangun indeks, sistem harus memutuskan apakah indeks dapat dibangun di atas beberapa kolom dan apakah indeks ini memastikan keunikan. <br><br>  Jadi, setiap metode akses harus menyediakan semua informasi yang diperlukan tentang dirinya sendiri.  Versi yang lebih rendah dari 9,6 menggunakan tabel "pg_am" untuk ini, sementara mulai dengan versi 9.6 data dipindahkan ke tingkat yang lebih dalam, di dalam fungsi-fungsi khusus.  Kami akan berkenalan dengan antarmuka ini sedikit lebih jauh. <br><br>  Semua yang lain adalah tugas dari metode akses: <br><br><ul><li>  Menerapkan algoritma untuk membangun indeks dan memetakan data ke halaman (untuk buffer cache manager untuk memproses setiap indeks secara seragam). </li><li>  Cari informasi dalam indeks dengan predikat dalam bentuk " <em>ekspresi operator bidang-bidang</em> ". </li><li>  Mengevaluasi biaya penggunaan indeks. </li><li>  Memanipulasi kunci yang diperlukan untuk pemrosesan paralel yang benar. </li><li> Buat catatan write-ahead log (WAL). </li></ul><br>  Kami pertama-tama akan mempertimbangkan kemampuan mesin pengindeksan umum dan kemudian melanjutkan untuk mempertimbangkan metode akses yang berbeda. <br><br><h2>  Mesin pengindeksan </h2><br>  Mesin pengindeksan memungkinkan PostgreSQL untuk bekerja dengan berbagai metode akses secara seragam, tetapi dengan mempertimbangkan fitur-fiturnya. <br><br><h3>  Teknik pemindaian utama </h3><br><h4>  Pemindaian indeks </h4><br>  Kita dapat bekerja secara berbeda dengan TIDs yang disediakan oleh indeks.  Mari kita pertimbangkan sebuah contoh: <br><br><pre><code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> t(a <span class="hljs-type"><span class="hljs-type">integer</span></span>, b <span class="hljs-type"><span class="hljs-type">text</span></span>, c <span class="hljs-type"><span class="hljs-type">boolean</span></span>); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> t(a,b,c) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> s.id, chr((<span class="hljs-number"><span class="hljs-number">32</span></span>+random()*<span class="hljs-number"><span class="hljs-number">94</span></span>)::<span class="hljs-type"><span class="hljs-type">integer</span></span>), random() &lt; <span class="hljs-number"><span class="hljs-number">0.01</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">100000</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> s(id) <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> random(); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> t(a); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span> t;</code> </pre> <br>  Kami membuat tabel tiga bidang.  Bidang pertama berisi angka dari 1 hingga 100.000, dan indeks (apa pun jenisnya) dibuat di bidang ini.  Kolom kedua berisi berbagai karakter ASCII kecuali yang tidak dapat dicetak.  Akhirnya, bidang ketiga berisi nilai logis yang benar untuk sekitar 1% dari baris dan salah untuk sisanya.  Baris dimasukkan ke dalam tabel dalam urutan acak. <br><br>  Mari kita coba memilih nilai dengan syarat "a = 1".  Perhatikan bahwa kondisinya seperti " <em>ekspresi operator bidang berindeks</em> ", di mana <em>operator</em> "sama" dan <em>ekspresi</em> (kunci pencarian) adalah "1".  Dalam kebanyakan kasus, kondisi harus terlihat seperti ini agar indeks dapat digunakan. <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> a = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------------- Index Scan using t_a_idx on t Index Cond: (a = 1) (2 rows)</code> </pre><br>  Dalam hal ini, pengoptimal memutuskan untuk menggunakan <em>pemindaian indeks</em> .  Dengan pemindaian indeks, metode akses mengembalikan nilai TID satu per satu hingga baris pencocokan terakhir tercapai.  Mesin pengindeksan mengakses baris tabel yang ditunjukkan oleh TIDs pada gilirannya, mendapatkan versi baris, memeriksa visibilitasnya terhadap aturan konkurensi multiversion, dan mengembalikan data yang diperoleh. <br><br><h4>  Pemindaian bitmap </h4><br>  Pemindaian indeks berfungsi dengan baik ketika kita hanya berurusan dengan beberapa nilai.  Namun, karena jumlah baris yang diambil meningkat, lebih mungkin untuk kembali ke halaman tabel yang sama beberapa kali.  Oleh karena itu, pengoptimal beralih ke <em>pemindaian bitmap</em> . <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> a &lt;= <span class="hljs-number"><span class="hljs-number">100</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------------------ Bitmap Heap Scan on t Recheck Cond: (a &lt;= 100) -&gt; Bitmap Index Scan on t_a_idx Index Cond: (a &lt;= 100) (4 rows)</code> </pre><br>  Metode akses pertama mengembalikan semua TIDs yang cocok dengan kondisi (Bitmap Index Scan node), dan bitmap versi baris dibangun dari TIDs ini.  Versi baris kemudian dibaca dari tabel (Bitmap Heap Scan), setiap halaman hanya dibaca sekali. <br><br>  Perhatikan bahwa pada langkah kedua, kondisi dapat diperiksa ulang (Periksa ulang Cond).  Jumlah baris yang diambil bisa terlalu besar untuk bitmap versi baris agar sepenuhnya sesuai dengan RAM (dibatasi oleh parameter "work_mem").  Dalam kasus ini, bitmap hanya dibuat untuk halaman yang berisi setidaknya satu versi baris yang cocok.  Bitmap "lossy" ini membutuhkan lebih sedikit ruang, tetapi ketika membaca halaman, kita perlu memeriksa kembali kondisi untuk setiap baris yang ada di sana.  Perhatikan bahwa bahkan untuk sejumlah kecil baris yang diambil dan oleh karena itu bitmap "tepat" (seperti dalam contoh kami), langkah "Periksa Ulang Cond" diwakili dalam rencana, walaupun sebenarnya tidak dilakukan. <br><br>  Jika ketentuan diberlakukan pada beberapa bidang tabel dan bidang ini diindeks, pemindaian bitmap memungkinkan penggunaan beberapa indeks secara bersamaan (jika pengoptimal menganggap ini efisien).  Untuk setiap indeks, bitmap versi baris dibangun, yang mana penggandaan boolean bitwise (jika ekspresi digabungkan dengan AND) atau penambahan boolean (jika ekspresi digabungkan oleh OR) kemudian dilakukan.  Sebagai contoh: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> t(b); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span> t; postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> a &lt;= <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> b = <span class="hljs-string"><span class="hljs-string">'a'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN -------------------------------------------------- Bitmap Heap Scan on t Recheck Cond: ((a &lt;= 100) AND (b = 'a'::text)) -&gt; BitmapAnd -&gt; Bitmap Index Scan on t_a_idx Index Cond: (a &lt;= 100) -&gt; Bitmap Index Scan on t_b_idx Index Cond: (b = 'a'::text) (7 rows)</code> </pre><br>  Di sini simpul BitmapAnd menggabungkan dua bitmap dengan operasi bitwise "dan". <br><br>  Pemindaian bitmap memungkinkan kita untuk menghindari akses berulang ke halaman data yang sama.  Tetapi bagaimana jika data dalam halaman tabel dipesan secara fisik persis dengan cara yang sama seperti catatan indeks?  Tidak diragukan lagi bahwa kita tidak dapat sepenuhnya bergantung pada urutan fisik data di halaman.  Jika data yang diurutkan diperlukan, kita harus secara eksplisit menentukan klausa ORDER BY dalam kueri.  Tetapi situasi mungkin di mana sebenarnya "hampir semua" data dipesan: misalnya, jika baris ditambahkan dalam urutan yang diperlukan dan tidak berubah setelah itu atau setelah melakukan perintah CLUSTER.  Dalam kasus seperti ini, membangun bitmap adalah langkah yang berlebihan, dan pemindaian indeks biasa akan sama baiknya (kecuali jika kita memperhitungkan kemungkinan untuk bergabung dengan beberapa indeks).  Oleh karena itu, ketika memilih metode akses, perencana melihat statistik khusus yang menunjukkan korelasi antara urutan baris fisik dan urutan logis dari nilai kolom: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> attname, correlation <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_stats <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tablename = <span class="hljs-string"><span class="hljs-string">'t'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> attname | correlation ---------+------------- b | 0.533512 c | 0.942365 a | -0.00768816 (3 rows)</code> </pre><br>  Nilai absolut mendekati satu menunjukkan korelasi tinggi (seperti untuk kolom "c"), sedangkan nilai mendekati nol, sebaliknya, menunjukkan distribusi kacau (kolom "a"). <br><br><h4>  Pemindaian berurutan </h4><br>  Untuk melengkapi gambar, kita harus perhatikan bahwa dengan kondisi non-selektif, pengoptimal akan lebih memilih pemindaian berurutan dari seluruh tabel daripada penggunaan indeks: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> a &lt;= <span class="hljs-number"><span class="hljs-number">40000</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------ Seq Scan on t Filter: (a &lt;= 40000) (2 rows)</code> </pre><br>  Masalahnya adalah bahwa indeks berfungsi semakin baik semakin tinggi selektivitas kondisi, yaitu, semakin sedikit baris yang cocok.  Pertumbuhan jumlah baris yang diambil meningkatkan biaya overhead untuk membaca halaman indeks. <br><br>  Pemindaian berurutan menjadi lebih cepat sehingga pemindaian acak menambah situasi.  Ini terutama berlaku untuk hard disk, di mana operasi mekanis membawa kepala magnetik ke trek membutuhkan waktu lebih banyak daripada membaca data itu sendiri.  Efek ini kurang terlihat untuk SSD.  Dua parameter tersedia untuk memperhitungkan perbedaan dalam biaya akses, "seq_page_cost" dan "random_page_cost", yang dapat kita atur tidak hanya secara global, tetapi pada tingkat tablespace, dengan cara ini menyesuaikan dengan karakteristik berbagai subsistem disk. <br><br><h3>  Meliputi indeks </h3><br>  Sebagai aturan, tugas utama metode akses adalah mengembalikan pengidentifikasi baris tabel yang cocok untuk mesin pengindeksan untuk membaca data yang diperlukan dari baris ini.  Tetapi bagaimana jika indeks sudah berisi semua data yang dibutuhkan untuk kueri?  Indeks semacam itu disebut <em>penutup</em> , dan dalam hal ini, pengoptimal dapat menerapkan <em>pemindaian hanya indeks</em> : <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">vacuum</span></span> t; postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> a &lt; <span class="hljs-number"><span class="hljs-number">100</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------------------ Index Only Scan using t_a_idx on t Index Cond: (a &lt; 100) (2 rows)</code> </pre><br>  Nama ini dapat memberikan gagasan bahwa mesin pengindeksan tidak mengakses tabel sama sekali dan mendapatkan semua informasi yang diperlukan dari metode akses saja.  Tetapi ini tidak persis seperti itu karena indeks di PostgreSQL tidak menyimpan informasi yang memungkinkan kita menilai visibilitas baris.  Oleh karena itu, metode akses mengembalikan versi baris yang cocok dengan kondisi pencarian terlepas dari visibilitasnya dalam transaksi saat ini. <br><br>  Namun, jika mesin pengindeksan perlu melihat ke dalam tabel untuk visibilitas setiap kali, metode pemindaian ini tidak akan berbeda dari pemindaian indeks biasa. <br><br>  Untuk mengatasi masalah tersebut, untuk tabel PostgreSQL mempertahankan apa yang disebut <em>peta visibilitas</em> di mana menyedot debu menandai halaman di mana data tidak berubah cukup lama agar data ini dapat dilihat oleh semua transaksi terlepas dari waktu mulai dan tingkat isolasi.  Jika pengidentifikasi baris yang dikembalikan oleh indeks terkait dengan halaman tersebut, pemeriksaan visibilitas dapat dihindari. <br><br>  Oleh karena itu, penyedotan debu secara teratur meningkatkan efisiensi penutupan indeks.  Selain itu, pengoptimal memperhitungkan jumlah tupel mati dan dapat memutuskan untuk tidak menggunakan pemindaian hanya-indeks jika ia memperkirakan biaya overhead yang tinggi untuk pemeriksaan visibilitas. <br><br>  Kita bisa mempelajari jumlah akses paksa ke tabel menggunakan perintah EXPLAIN ANALYZE: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> a &lt; <span class="hljs-number"><span class="hljs-number">100</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------------------------------------------------------------- Index Only Scan using t_a_idx on t (actual time=0.025..0.036 rows=99 loops=1) Index Cond: (a &lt; 100) Heap Fetches: 0 Planning time: 0.092 ms Execution time: 0.059 ms (5 rows)</code> </pre><br>  Dalam hal ini, tidak perlu mengakses tabel (Heap Fetches: 0), karena menyedot debu baru saja dilakukan.  Secara umum, semakin dekat angka ini ke nol semakin baik. <br><br>  Tidak semua indeks menyimpan nilai yang diindeks bersama dengan pengidentifikasi baris.  Jika metode akses tidak dapat mengembalikan data, itu tidak dapat digunakan untuk hanya pindaian indeks. <br><br><blockquote>  PostgreSQL 11 telah memperkenalkan fitur baru: INCLUDE-indexes.  Bagaimana jika ada indeks unik yang tidak memiliki beberapa kolom untuk digunakan sebagai indeks penutup untuk beberapa permintaan?  Anda tidak bisa begitu saja menambahkan kolom ke indeks karena akan merusak keunikannya.  Fitur ini memungkinkan untuk memasukkan kolom <em>non-kunci</em> yang tidak memengaruhi keunikan dan tidak dapat digunakan dalam predikat pencarian, tetapi masih dapat melayani pemindaian hanya indeks.  Tambalan dikembangkan oleh rekan saya Anastasia Lubennikova. <br></blockquote><br><h3>  Tidak </h3><br>  NULLs memainkan peran penting dalam database relasional sebagai cara mudah untuk mewakili nilai yang tidak ada atau tidak diketahui. <br><br>  Tetapi nilai khusus itu istimewa untuk dihadapi.  Aljabar boolean reguler menjadi ternary;  tidak jelas apakah NULL harus lebih kecil atau lebih besar dari nilai reguler (ini memerlukan konstruksi khusus untuk menyortir, NULLS FIRST dan NULLS LAST);  tidak jelas apakah fungsi agregat harus mempertimbangkan NULL atau tidak;  diperlukan statistik khusus untuk perencana ... <br><br>  Dari perspektif dukungan indeks, juga tidak jelas apakah kita perlu mengindeks nilai-nilai ini atau tidak.  Jika NULLs tidak diindeks, indeks mungkin lebih kompak.  Tetapi jika NULL diindeks, kita akan dapat menggunakan indeks untuk kondisi seperti " <em>bidang yang diindeks</em> [TIDAK] NULL" dan juga sebagai indeks penutup ketika tidak ada kondisi sama sekali yang ditentukan untuk tabel (karena dalam kasus ini, index harus mengembalikan data semua baris tabel, termasuk yang dengan NULLs). <br><br>  Untuk setiap metode akses, pengembang membuat keputusan sendiri apakah akan mengindeks NULL atau tidak.  Tapi sebagai aturan, mereka diindeks. <br><br><h3>  Indeks pada beberapa bidang </h3><br>  Untuk mendukung kondisi untuk beberapa bidang, <em>indeks multikolom</em> dapat digunakan.  Misalnya, kami dapat membuat indeks di dua bidang tabel kami: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> t(a,b); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span> t;</code> </pre><br>  Pengoptimal kemungkinan besar lebih suka indeks ini untuk bergabung dengan bitmap karena di sini kita siap mendapatkan TIDs yang diperlukan tanpa operasi tambahan: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> a &lt;= <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> b = <span class="hljs-string"><span class="hljs-string">'a'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------------------------------ Index Scan using t_a_b_idx on t Index Cond: ((a &lt;= 100) AND (b = 'a'::text)) (2 rows)</code> </pre><br>  Indeks multikolom juga dapat digunakan untuk mempercepat pengambilan data dengan suatu kondisi untuk beberapa bidang, dimulai dengan yang pertama: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> a &lt;= <span class="hljs-number"><span class="hljs-number">100</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN -------------------------------------- Bitmap Heap Scan on t Recheck Cond: (a &lt;= 100) -&gt; Bitmap Index Scan on t_a_b_idx Index Cond: (a &lt;= 100) (4 rows)</code> </pre><br>  Secara umum, jika kondisi tidak dikenakan pada bidang pertama, indeks tidak akan digunakan.  Tetapi terkadang optimizer menganggap penggunaan indeks lebih efisien daripada pemindaian berurutan.  Kami akan memperluas topik ini ketika mempertimbangkan indeks "btree". <br><br>  Tidak semua metode akses mendukung indeks pembangunan pada beberapa kolom. <br><br><h3>  Indeks pada ekspresi </h3><br>  Kami telah menyebutkan bahwa kondisi pencarian harus seperti " <em>ekspresi operator bidang berindeks</em> ".  Dalam contoh di bawah ini, indeks tidak akan digunakan karena ekspresi yang mengandung nama bidang digunakan alih-alih nama bidang itu sendiri: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> lower(b) = <span class="hljs-string"><span class="hljs-string">'a'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------------------------ Seq Scan on t Filter: (lower((b)::text) = 'a'::text) (2 rows)</code> </pre><br>  Tidak perlu banyak menulis ulang kueri khusus ini sehingga hanya nama bidang yang ditulis di sebelah kiri operator.  Tetapi jika ini tidak memungkinkan, indeks pada ekspresi (indeks fungsional) akan membantu: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> t(lower(b)); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span> t; postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> lower(b) = <span class="hljs-string"><span class="hljs-string">'a'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ---------------------------------------------------- Bitmap Heap Scan on t Recheck Cond: (lower((b)::text) = 'a'::text) -&gt; Bitmap Index Scan on t_lower_idx Index Cond: (lower((b)::text) = 'a'::text) (4 rows)</code> </pre><br>  Indeks fungsional dibangun bukan pada bidang tabel, tetapi pada ekspresi sewenang-wenang.  Pengoptimal akan mempertimbangkan indeks ini untuk kondisi seperti " <em>ekspresi operator ekspresi-ekspresi</em> ".  Jika perhitungan ekspresi yang akan diindeks adalah operasi yang mahal, pembaruan indeks juga akan memerlukan sumber daya perhitungan yang signifikan. <br><br>  Harap juga diingat bahwa statistik individu dikumpulkan untuk ekspresi yang diindeks.  Kita bisa mengetahui statistik ini dalam tampilan "pg_stats" dengan nama indeks: <br><br><pre> <code class="pgsql hljs">postgres=# \dt</code> </pre><pre> <code class="plaintext hljs"> Table "public.t" Column | Type | Modifiers --------+---------+----------- a | integer | b | text | c | boolean | Indexes: "t_a_b_idx" btree (a, b) "t_a_idx" btree (a) "t_b_idx" btree (b) "t_lower_idx" btree (lower(b))</code> </pre><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_stats <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tablename = <span class="hljs-string"><span class="hljs-string">'t_lower_idx'</span></span>;</code> </pre><br>  Adalah mungkin, jika perlu, untuk mengontrol jumlah keranjang histogram dengan cara yang sama seperti untuk bidang data biasa (mencatat bahwa nama kolom dapat berbeda tergantung pada ekspresi yang diindeks): <br><br><pre> <code class="pgsql hljs">postgres=# \d t_lower_idx</code> </pre><pre> <code class="plaintext hljs"> Index "public.t_lower_idx" Column | Type | Definition --------+------+------------ lower | text | lower(b) btree, for table "public.t"</code> </pre><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> t_lower_idx <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">column</span></span> "lower" <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> <span class="hljs-keyword"><span class="hljs-keyword">statistics</span></span> <span class="hljs-number"><span class="hljs-number">69</span></span>;</code> </pre><br><blockquote>  PostgreSQL 11 telah memperkenalkan cara yang lebih bersih untuk mengontrol target statistik untuk indeks dengan menentukan <em>nomor</em> kolom dalam ALTER INDEX ... SET perintah STATISTIK.  Tambalan dikembangkan oleh rekan saya Alexander Korotkov, dan Adrien Nayrat. </blockquote><br><h3>  Indeks sebagian </h3><br>  Terkadang muncul kebutuhan untuk mengindeks hanya sebagian dari baris tabel.  Ini biasanya terkait dengan distribusi yang sangat tidak seragam: masuk akal untuk mencari nilai yang jarang dengan indeks, tetapi lebih mudah untuk menemukan nilai yang sering dengan pemindaian penuh tabel. <br><br>  Kita tentu dapat membangun indeks reguler pada kolom "c", yang akan bekerja seperti yang kita harapkan: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> t(c); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span> t; postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> c;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------------- Index Scan using t_c_idx on t Index Cond: (c = true) Filter: c (3 rows)</code> </pre><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> c;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------- Seq Scan on t Filter: (NOT c) (2 rows)</code> </pre><br>  Dan ukuran indeksnya adalah 276 halaman: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> relpages <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> relname=<span class="hljs-string"><span class="hljs-string">'t_c_idx'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> relpages ---------- 276 (1 row)</code> </pre><br>  Tetapi karena kolom "c" memiliki nilai true hanya untuk 1% dari baris, 99% dari indeks sebenarnya tidak pernah digunakan.  Dalam hal ini, kita dapat membuat indeks parsial: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> t(c) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> c; postgres=# <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span> t;</code> </pre><br>  Ukuran indeks dikurangi menjadi 5 halaman: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> relpages <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> relname=<span class="hljs-string"><span class="hljs-string">'t_c_idx1'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> relpages ---------- 5 (1 row)</code> </pre><br>  Terkadang perbedaan dalam ukuran dan kinerja mungkin cukup signifikan. <br><br><h3>  Menyortir </h3><br>  Jika metode akses mengembalikan pengidentifikasi baris dalam beberapa urutan tertentu, ini memberikan pengoptimal dengan opsi tambahan untuk melakukan kueri. <br><br>  Kita bisa memindai tabel dan kemudian mengurutkan data: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> enable_indexscan=<span class="hljs-keyword"><span class="hljs-keyword">off</span></span>; postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> a;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN --------------------- Sort Sort Key: a -&gt; Seq Scan on t (3 rows)</code> </pre><br>  Tetapi kita dapat membaca data menggunakan indeks dengan mudah dalam urutan yang diinginkan: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> enable_indexscan=<span class="hljs-keyword"><span class="hljs-keyword">on</span></span>; postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> a;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------------- Index Scan using t_a_idx on t (1 row)</code> </pre><br>  Hanya "btree" dari semua metode akses yang dapat mengembalikan data yang diurutkan, jadi mari kita menunda diskusi yang lebih terperinci sampai mempertimbangkan jenis indeks ini. <br><br><h3>  Bangunan serentak </h3><br>  Biasanya membangun indeks mendapatkan kunci SHARE untuk tabel.  Kunci ini memungkinkan membaca data dari tabel, tetapi melarang perubahan apa pun saat indeks sedang dibuat. <br><br>  Kami dapat memastikan hal ini jika, katakanlah, saat membuat indeks pada tabel "t", kami melakukan kueri di bawah ini di sesi lain: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> mode, granted <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_locks <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> relation = <span class="hljs-string"><span class="hljs-string">'t'</span></span>::<span class="hljs-type"><span class="hljs-type">regclass</span></span>;</code> </pre><pre> <code class="plaintext hljs"> mode | granted -----------+--------- ShareLock | t (1 row)</code> </pre><br>  Jika tabel cukup besar dan banyak digunakan untuk penyisipan, pembaruan, atau penghapusan, ini mungkin tampaknya tidak dapat diterima karena proses modifikasi akan menunggu rilis kunci untuk waktu yang lama. <br><br>  Dalam hal ini, kita bisa menggunakan bangunan bersamaan dari indeks. <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">concurrently</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> t(a);</code> </pre><br>  Perintah ini mengunci tabel dalam mode EXCLUSIVE SHARE UPDATE, yang memungkinkan membaca dan memperbarui (hanya mengubah struktur tabel yang dilarang, serta menyedot debu, analisis, atau membuat indeks lain pada tabel ini bersamaan). <br><br>  Namun, ada juga sisi lain.  Pertama, indeks akan dibangun lebih lambat dari biasanya karena dua lintasan melintasi tabel dilakukan alih-alih satu, dan juga perlu menunggu penyelesaian transaksi paralel yang memodifikasi data. <br><br>  Kedua, dengan pembangunan bersamaan indeks, kebuntuan dapat terjadi atau kendala unik dapat dilanggar.  Namun, indeks akan dibangun, meskipun tidak beroperasi.  Indeks seperti itu harus dihapus dan dibangun kembali.  Indeks yang tidak beroperasi ditandai dengan kata INVALID di output dari perintah psql \ d, dan kueri di bawah ini mengembalikan daftar lengkapnya: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> indexrelid::<span class="hljs-type"><span class="hljs-type">regclass</span></span> index_name, indrelid::<span class="hljs-type"><span class="hljs-type">regclass</span></span> <span class="hljs-built_in"><span class="hljs-built_in">table_name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_index <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> indisvalid;</code> </pre><pre> <code class="plaintext hljs"> index_name | table_name ------------+------------ t_a_idx | t (1 row)</code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Baca terus</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id441962/">https://habr.com/ru/post/id441962/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id441946/index.html">REST API pada Laravel dalam 100 baris kode</a></li>
<li><a href="../id441950/index.html">Eclipse Che 7 sudah ada di sini</a></li>
<li><a href="../id441952/index.html">Memilih sistem penyimpanan file untuk kerja tim</a></li>
<li><a href="../id441954/index.html">Hadiah pengguna untuk penulis Habr</a></li>
<li><a href="../id441956/index.html">Penanganan kesalahan terpadu (opsi C ++ untuk mikrokontroler)</a></li>
<li><a href="../id441964/index.html">Kiat & trik Kubernetes: memindahkan sumber daya kluster ke Helm 2</a></li>
<li><a href="../id441966/index.html">Kit Pemula Pengujian Keamanan Web</a></li>
<li><a href="../id441968/index.html">Pengembangan cabang produk baru: cara menyingkirkan tidak praktis dan tetap bermanfaat</a></li>
<li><a href="../id441970/index.html">Analisis FinFisher Butkit</a></li>
<li><a href="../id441972/index.html">Invidious - frontend YouTube alternatif</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>