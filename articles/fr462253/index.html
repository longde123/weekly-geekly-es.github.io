<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üö∫ üíÉüèΩ ü§∑üèª Les premi√®res exp√©riences utilisant le protocole de streaming sur l'exemple de communication CPU et processeur dans le FPGA Redd üòÉ ü§òüèº üë©üèº‚Äçüî¨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans les articles pr√©c√©dents, nous avons d√©j√† rencontr√© le bus Avalon-MM , o√π MM signifie Memory Mapped, c'est-√†-dire projet√© sur la m√©moire. Ce pneu ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Les premi√®res exp√©riences utilisant le protocole de streaming sur l'exemple de communication CPU et processeur dans le FPGA Redd</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/462253/"><img src="https://habrastorage.org/webt/hx/9r/u0/hx9ru01kpi9-x1z8jztv7uaemjm.jpeg"><br><br>  Dans les articles pr√©c√©dents, nous avons d√©j√† rencontr√© le bus <b>Avalon-MM</b> , o√π MM signifie Memory Mapped, c'est-√†-dire projet√© sur la m√©moire.  Ce pneu est assez polyvalent.  Plusieurs appareils ma√Ætre (ma√Ætre) et plusieurs appareils esclaves peuvent y √™tre connect√©s.  Nous avons d√©j√† connect√© deux principaux appareils √† la fois (Instruction Master et Data Master), car le processeur NIOS II a une architecture Harvard, donc les bus de commande et de donn√©es sont diff√©rents, mais de nombreux auteurs les connectent au m√™me commun pour simplifier le d√©veloppement logiciel de l'ext√©rieur au bus. <br><br>  Si un bloc sur le bus a une fonctionnalit√© d'acc√®s direct √† la m√©moire (DMA), il contiendra √©galement un ma√Ætre pour le bus. <br><br>  En fait, le principal inconv√©nient de ce pneu est bas√© sur ce fait (de nombreux leaders, de nombreux adeptes).  Lorsque nous avons con√ßu notre esclave, nous avons d√ª d√©coder l'adresse.  Quand il m'est arriv√© de faire mon chef, il y avait beaucoup plus de bruit avec l'arbitrage.  Mais un fil rouge √† travers toute la s√©rie d'articles est l'affirmation selon laquelle le d√©veloppement sous Redd est une partie auxiliaire du projet, il ne devrait pas n√©cessiter trop de travail.  Et si nous pouvons nous lib√©rer de la routine, nous devons nous en lib√©rer. <br><a name="habracut"></a><br><img src="https://habrastorage.org/webt/ns/cc/m1/nsccm1g4bldwl-4okgx-puukhyk.png"><br><br>  Tous les articles du cycle: <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">D√©veloppement du ¬´firmware¬ª le plus simple pour les FPGA install√©s dans Redd, et d√©bogage en utilisant le test de m√©moire comme exemple</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">D√©veloppement du ¬´firmware¬ª le plus simple pour les FPGA install√©s dans Redd.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 2. Code de programme</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">D√©veloppement de son propre noyau pour l'int√©gration dans un syst√®me de processeur bas√© sur FPGA</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">D√©veloppement de programmes pour le processeur central Redd sur l'exemple d'acc√®s au FPGA</a> </li></ol><br>  Le document <b>Avalon Interface Specifications que</b> nous connaissons d√©j√† (en g√©n√©ral, je ne donne pas de liens directs, car ils changent toujours, de sorte que l'ensemble du r√©seau est jonch√© d'articles avec des liens morts, il est plus facile de trouver la position actuelle en ins√©rant le nom dans le moteur de recherche) signale qu'en plus du bus <b>Avalon-MM</b> , il y a aussi un bus <b>Avalon-ST</b> , o√π ST signifie Stream, c'est-√†-dire le streaming.  Le fait est que tr√®s souvent les donn√©es transmises ont une structure de flux.  Oui, m√™me le secteur classique du disque dur.  Il a une taille fixe.  Il doit √™tre transmis du d√©but √† la fin.  M√™me si nous le consid√©rons dans la zone adressable, les adresses augmenteront lin√©airement.  Et si vous utilisez le bloc FIFO pour le stockage, les adresses qu'il contient nous sont compl√®tement cach√©es.  Ils le sont, mais travailler avec eux n'est pas notre pr√©occupation. <br><br>  La m√™me chose s'applique √† de nombreuses autres donn√©es de streaming: elles vont toujours du d√©but √† la fin, √©tant plac√©es dans des r√©f√©rentiels de mani√®re s√©quentielle.  C'est exactement ce que les protocoles de streaming sont utilis√©s pour transf√©rer ces donn√©es.  Outre le manque d'adressage explicite, le bus <b>Avalon-ST</b> est int√©ressant en ce qu'il relie toujours deux appareils: une source et un r√©cepteur.  Il y en a toujours deux.  Un appareil est toujours la source, le second est toujours le r√©cepteur.  Par cons√©quent, les probl√®mes d'arbitrage de ce bus ne concernent pas.  Voici √† quoi ressemblent des paires typiques d'appareils connect√©s √† ce bus: <br><br><img src="https://habrastorage.org/webt/z_/ix/tz/z_ixtzpnxmb0fhhyoxgsqnydhvc.png"><br><br>  Et voici les signaux typiques de ce bus: <br><br><img src="https://habrastorage.org/webt/ua/bh/ku/uabhkulgiofulvfomh0mw-mdz7g.png"><br><br>  De plus, les lignes d' <b>erreur</b> sont optionnelles, elles transmettent des codes d'erreur binaires attribu√©s par nous, et on peut dire qu'il n'y a pas de code d'erreur.  Et les lignes de num√©ro de canal, comme nous l'avons vu ci-dessus, ne sont n√©cessaires que si le d√©multiplexage est effectu√© plus loin.  Sinon, le num√©ro de cha√Æne n'est pas n√©cessaire.  Nous allons nous en passer pour l'instant.  Il reste trois lignes: en fait, des donn√©es, un signal pr√™t et un signal de confirmation de donn√©es (stroboscope).  Eh bien, un autre signal d'horloge, car le bus est synchrone. <br><br>  De la documentation, il r√©sulte √©galement que trois signaux suppl√©mentaires sont possibles, ajoutant au bus les propri√©t√©s de transmission de paquets clairement d√©finis: <br><br><img src="https://habrastorage.org/webt/ix/wa/rc/ixwarc27-jx3cqndio3gzxaim_g.png"><br><br>  En g√©n√©ral, le pneu est tr√®s int√©ressant, et aujourd'hui nous allons commencer des exp√©riences avec lui.  Comme nous le savons d√©j√†, le FPGA est connect√© au bus USB du complexe Redd via le pont <b>FT2232H</b> fonctionnant en mode <b>FT245-SYNC</b> .  √Ä strictement parler, les donn√©es qui transitent par cette interface sont assez des donn√©es en continu.  Aujourd'hui, nous apprendrons comment transf√©rer ces donn√©es vers notre syst√®me de processeur bas√© sur NIOS II.  Il est dommage que le protocole <b>FT245-SYNC</b> , bien qu'en streaming, ne soit pas totalement conforme au bus <b>Avalon-ST</b> .  Pour √©conomiser les circuits int√©gr√©s, il dispose d'un bus de donn√©es bidirectionnel et le bus <b>Avalon-ST</b> est unidirectionnel.  Donc, nous devons faire un bloc qui coordonne des protocoles proches mais ne correspondant pas. <br><br>  Nous avons d√©j√† fait la connaissance du protocole <b>FT245-SYNC</b> dans l'un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">des articles pr√©c√©dents</a> .  Permettez-moi de vous rappeler que sa description se trouve dans le document <b>AN_130 FT2232H utilis√© dans un mode FIFO synchrone de style FT245</b> .  Voici un chronogramme typique de transmission d'un pont √† un FPGA <br><br><img src="https://habrastorage.org/webt/ea/-y/ly/ea-ylyf7hie2zal-gfjzyp_ehwy.png"><br><br>  En g√©n√©ral, en tant que programmeur, je suis tr√®s int√©ress√© par le fait que le paquet transmis aurait clairement marqu√© d√©but et fin.  Eh bien, pour le rendre plus logique dans la logique du protocole UDP, car si la transmission est dans le style TCP, vous devrez ajouter des donn√©es de r√©f√©rence sp√©ciales au flux, qui seront d√©pens√©es pour ma programmation, mes efforts et mes cycles de processeur ... Cela ressemble √† la ligne RXF peut nous aider.  On v√©rifie ... On remplit le "firmware" du FPGA pour mesurer les performances, fait dans l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article pr√©c√©dent</a> , et on connecte la sonde de l'oscilloscope √† la ligne RXF.  En tant que programme de test pour le processeur central Redd, nous utilisons la base de donn√©es, √©galement utilis√©e pour mesurer les performances, juste au lieu d'envoyer de grandes quantit√©s de donn√©es, nous envoyons un bloc monolithique de 0x400 octets. <br><br><pre><code class="plaintext hljs">uint8_t temp [maxBlockSize]; memset (temp,0,sizeof (temp)); uint32_t dwWritten; FT_Write(ftHandle0, temp, 0x400, &amp;dwWritten);</code> </pre> <br>  Nous obtenons l'image suivante sur la ligne RXF: <br><br><img src="https://habrastorage.org/webt/0-/yc/ic/0-ycici6rpo4urdmg8nlvyuem3w.png"><br><br>  Il est clair que le microcircuit re√ßoit 0x200 octets de tampon (c'est-√†-dire combien il peut venir dans un paquet HS USB2.0), puis il les envoie au canal.  En g√©n√©ral, cela est √©trange, car la documentation indique que deux tampons sont utilis√©s dans chaque direction.  Pendant la transmission, le deuxi√®me tampon aurait d√ª avoir le temps de se remplir.  H√©las.  La fin de son remplissage est clairement en retard.  En fait, cela montre pourquoi les performances n'atteignent pas les 52 m√©gaoctets th√©oriques par seconde: un grand pourcentage du temps (mais pas 50%) n'est tout simplement pas transmis. <br><br>  Mais d'une mani√®re ou d'une autre, nous avons d√©couvert qu'il est possible de d√©tecter le d√©but d'un paquet sur un front RXF n√©gatif uniquement si la taille du paquet ne d√©passe pas 0x200 octets.  Si nous envoyons uniquement des commandes avec une petite quantit√© de donn√©es √† l'appareil, cela est tout √† fait r√©alisable.  Mais si nous envoyons de grands flux de donn√©es, nous devrons utiliser un canal continu, similaire dans sa logique √† UART (ou, disons, au canal TCP), mettant en √©vidence les limites des paquets uniquement par programme. <br><br>  En g√©n√©ral, pour la simplicit√© de la pr√©sentation, nous prenons la version en streaming comme base.  Nous ne consid√©rerons pas les packages aujourd'hui.  Eh bien, la version du bus <b>Avalon-ST que</b> nous prenons comme base est claire.  Nous commen√ßons √† concevoir notre bloc.  Comme indiqu√© ci-dessus, nous devons faire non seulement un pont, mais un commutateur, car le bus <b>FT245FIFO est</b> bidirectionnel et le bus <b>Avalon-ST</b> est unidirectionnel.  Autrement dit, il est n√©cessaire de cr√©er deux bus <b>Avalon-ST</b> √† la fois: sortie et entr√©e. <br><br><img src="https://habrastorage.org/webt/hr/hl/fm/hrhlfm67sw8-xemukkwo47lg3va.png"><br><br>  Nous commen√ßons √† d√©velopper lentement un automate qui mettra en ≈ìuvre la logique dont nous avons besoin.  Bien s√ªr, dans l'article, cette logique sera simplifi√©e au maximum.  Commen√ßons par transf√©rer des donn√©es du FPGA vers le PC, car ce processus est un peu plus simple (vous n'avez pas besoin de changer l'√©tat de la ligne OE, dont nous avons parl√© dans le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dernier article</a> ).  Autrement dit, nous impl√©mentons le port Sink. <br><br>  Du c√¥t√© du bus <b>Avalon-ST</b> , j'ai choisi le mode de fonctionnement suivant (il y en a beaucoup dans le document, mais pour l'interface avec le <b>FT245-SYNC celui-ci est le</b> plus proche): <br><br><img src="https://habrastorage.org/webt/f_/rh/nm/f_rhnmctxwtl01xdlaiioun81jk.png"><br><br>  Permettez-moi de vous rappeler la direction des signaux: <br><br><img src="https://habrastorage.org/webt/sd/cc/r-/sdccr--rw2vsk1xitskseckafiq.png"><br><br>  Autrement dit, nous attendons simplement la confirmation sur le bus ( <b>valide</b> ), cliquez sur les donn√©es et transmettez ce fait avec la ligne <b>pr√™te</b> . <br><br>  Du c√¥t√© <b>FT245_FIFO, le</b> protocole ressemble √† ceci: <br><br><img src="https://habrastorage.org/webt/d-/nf/ki/d-nfkirvzei94d3kvkhntyea7pi.png"><br><br>  Il s'av√®re que nous devons attendre le signal TXE et gate les donn√©es avec le signal WR # (la polarit√© est inverse pour ces deux signaux). <br><br>  TXE # a une fonctionnalit√© tr√®s similaire √† <b>ready</b> , et WR # est <b>valide</b> .  Les d√©tails sont un peu diff√©rents, mais la logique est similaire. <br><br>  Il s'av√®re que nous pouvons isoler un seul √©tat vers PC, dans lequel les commutations les plus simples de certaines lignes seront effectu√©es.  La condition pour entrer dans cet √©tat sera la disponibilit√© des deux parties pour la transmission, c'est-√†-dire (TXE # == 0) ET (valide == 1).  D√®s qu'une partie de l'√©tat de pr√©paration a disparu, nous retournons au ralenti. <br><br>  Le graphe de transition de l'automate est toujours simple: <br><br><img src="https://habrastorage.org/webt/ci/gb/j9/cigbj9hrioumzbnck6pyeevv1ia.png"><br><br>  Et la table de commutation est comme ceci (o√π les noms des signaux sont ambigus, des indices leur sont ajout√©s, o√π les noms sont uniques - il n'y a pas d'indices): <br><br><div class="scrollable-table"><table><tbody><tr><th>  Signal </th><th>  Statut ToPC </th><th>  Autres conditions </th></tr><tr><td>  WR # </td><td>  NON (validSink) </td><td>  1 </td></tr><tr><td>  readySink </td><td>  NON (TXE #) </td><td>  0 </td></tr><tr><td>  DATAFT245_FIFO </td><td>  DataSink </td><td>  Z </td></tr></tbody></table></div><br><br>  Passage √† un transfert un peu plus complexe de Source vers FT245_FIFO.  Comme nous l'avons vu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dans l'article pr√©c√©dent</a> , la complication est de changer de direction avec le signal OE #: <br><br><img src="https://habrastorage.org/webt/al/xu/1-/alxu1-uqzen0dpj4n8bbgcruyck.png"><br><br>  Pour le bus <b>Avalon_ST,</b> tout est le m√™me qu'auparavant, donc les images ne sont pas affich√©es une deuxi√®me fois, mais maintenant nous sommes √† la position Source. <br><br>  Ici, la ligne RXF # correspond √† la ligne <b>valide</b> et la ligne RD # correspond √† la ligne <b>pr√™te</b> .  Eh bien, tr√®s bien, ajoutez quelques √©tats √† la machine: <br><br><img src="https://habrastorage.org/webt/pu/gs/fm/pugsfmp11c6b79fi8cwfud-wm-q.png"><br><br>  et la logique suivante pour les signaux actifs dans cet √©tat: <br><br><div class="scrollable-table"><table><tbody><tr><th>  Signal </th><th>  dropOE </th><th>  fromPC </th><th>  Autres conditions </th></tr><tr><td>  OE # </td><td>  0 </td><td>  0 </td><td>  1 </td></tr><tr><td>  RD # </td><td>  1 </td><td>  PAS (readySource) </td><td>  1 </td></tr><tr><td>  dataSource </td><td>  N'importe quelle valeur </td><td>  DATAFT245_FIFO </td><td>  N'importe quelle valeur </td></tr><tr><td>  source valide </td><td>  0 </td><td>  NON (RXF #) </td><td>  0 </td></tr></tbody></table></div><br>  Il est clair que le sch√©ma n'√©tait pas le plus id√©al.  Il existe diverses nuances associ√©es aux d√©passements ou sous-d√©passements de tampon.  Mais il ne devrait pas y avoir de perte de donn√©es, mais en ce qui concerne l'optimalit√©, vous devez commencer quelque part! <br><br>  Nous commen√ßons √† transf√©rer la th√©orie d√©velopp√©e au code SystemVerilog.  Certes, nous ne pouvons pas utiliser toutes les fonctionnalit√©s de SystemVerilog.  Ce fut le cas, j'ai √©crit un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">gros article</a> o√π j'ai test√© la synth√©tisabilit√© pratique des belles fonctionnalit√©s de ce langage avec un v√©ritable environnement de d√©veloppement.  Ici, nous demandons simplement l'utilisation d'interfaces, car le syst√®me aura deux instances de <b>type Avalon-ST</b> .  H√©las et ah.  Voici le code de test: <br><pre> <code class="plaintext hljs">interface AvalonST #(parameter width=8)(input clk); logic [width-1:0] data; logic ready; logic valid; modport source (input clk, ready, output data,valid); modport sink (input clk, data, valid, output ready); endinterface module FT245toAvalonST ( AvalonST.source source, AvalonST.sink sink ); //assign source.ready = sink.valid; assign sink.ready = source.valid; endmodule</code> </pre><br>  Il est parfaitement synth√©tis√© dans le compilateur principal (une ligne comment√©e lors de la suppression d'un commentaire provoque une erreur pour s'assurer que le synth√©tiseur interpr√®te tout correctement), mais lors de la v√©rification du bouton <b>Analyser les fichiers de synth√®se</b> pour un composant de ce code, une erreur est <b>g√©n√©r√©e</b> que le type <b>AvalonST est</b> inconnu.  Autrement dit, l'analyse n'est pas sur SystemVerilog, mais sur Verilog pur.  Quel dommage. <br><br><img src="https://habrastorage.org/webt/4x/ju/ma/4xjumaitxzkw5tig_pdponziq38.png"><br><br>  De plus, la langue est d√©termin√©e correctement, seul l'analyseur ne comprend pas les interfaces entre les ports. <br><br><img src="https://habrastorage.org/webt/tp/vm/gn/tpvmgnmidvtcb1e5ngfteokprpi.png"><br><br>  En g√©n√©ral, vous devez utiliser la vieille syntaxe laide. <br><br><div class="spoiler">  <b class="spoiler_title">Avec cette syntaxe, nous obtenons l'interface de module suivante:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">module FT245toAvalonST ( input clk, input reset, inout [7:0] ft245_data, input logic ft245_rxf, input logic ft245_txe, output logic ft245_rd, output logic ft245_wr, output logic ft245_oe, output logic ft245_siwu, input logic source_ready, output logic source_valid, output logic[7:0] source_data, output logic sink_ready, input logic sink_valid, input logic[7:0] sink_data );</code> </pre><br></div></div><br>  Rude, vintage, mais que pouvez-vous faire. <br><br><div class="spoiler">  <b class="spoiler_title">Nous r√©alisons le graphe de transition de l'automate sans fioritures:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">//    enum {idle, toPC, dropOE, fromPC} state = idle; //     always_ff @(posedge clk,posedge reset) begin if (reset == 1) begin state &lt;= idle; end else begin case (state) idle: begin if ((ft245_txe == 0) &amp;&amp; (sink_valid == 1)) state &lt;= toPC; else if ((ft245_rxf == 0)&amp;&amp;(source_ready == 1)) state &lt;= dropOE; end toPC: begin if (!((ft245_txe == 0) &amp;&amp; (sink_valid == 1))) state &lt;= idle; end dropOE: begin state &lt;= fromPC; end fromPC: begin if (!((ft245_rxf == 0)&amp;&amp;(source_ready == 1))) state &lt;= idle; end endcase end end</code> </pre><br></div></div><br>  Le contr√¥le des sorties n√©cessite cependant quelques explications. <br><br><div class="spoiler">  <b class="spoiler_title">Une partie des installations se fait ¬´sur le front¬ª:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">//    //   ,        , //  -    . always_comb begin ft245_oe &lt;= 1; ft245_rd &lt;= 1; ft245_wr &lt;= 1; source_valid &lt;= 0; sink_ready &lt;= 0; //     , //     assign- case (state) idle: begin end toPC: begin ft245_wr &lt;= !(sink_valid); sink_ready &lt;= !(ft245_txe); end dropOE: begin ft245_oe &lt;= 0; end fromPC: begin ft245_oe &lt;= 0; ft245_rd &lt;= !(source_ready); source_valid &lt;= !(ft245_rxf); end endcase end</code> </pre><br></div></div><br>  Mais, disons, pour un bus de donn√©es bidirectionnel, une solution typique devrait √™tre appliqu√©e.  Comme nous nous en souvenons, il est d√©clar√© dans la partie interface comme suit: <br><br><pre> <code class="plaintext hljs"> inout [7:0] ft245_data,</code> </pre><br>  et sa lecture peut se faire de la mani√®re habituelle.  Pour notre cas, nous emballons simplement toutes les donn√©es sur les donn√©es du bus <b>Avalon-ST</b> sortant: <br><br><pre> <code class="plaintext hljs">//          assign source_data = ft245_data;</code> </pre><br>  Mais en g√©n√©ral, vous pouvez toujours lire dans le bus et comme vous le souhaitez.  Mais vous devriez y √©crire en utilisant le multiplexeur.  Lorsque nous √©crivons des donn√©es sur le bus, ces donn√©es doivent provenir de tout autre bus pr√©-pr√©par√©.  Habituellement, dans un module, une variable de type <b>reg</b> (ou <b>logique</b> newfangled) est d√©marr√©e.  Dans notre cas, un tel bus existe d√©j√†.  Il s'agit du bus <b>sink_data</b> .  Dans d'autres cas, l'√©tat Z est √©mis. Si vous connaissez les circuits, vous connaissez bien un tampon de sortie typique.  Il saute toutes les donn√©es d'entr√©e ou passe √† l'√©tat Z.  Dans notre code, ce multiplexeur ressemble √† ceci: <br><br><pre> <code class="plaintext hljs">//      inout- assign ft245_data = (state == toPC) ? sink_data : 8'hzz;</code> </pre><br>  Et un autre signal ft245_siwu.  Nous ne l'utilisons jamais, donc selon la documentation sur FT2232H, tirez-le √† l'unit√©: <br><br><pre> <code class="plaintext hljs">//   FTDI : // Tie this pin to VCCIO if not used. assign ft245_siwu = 1;</code> </pre><br>  En fait, c'est tout. <br><br><div class="spoiler">  <b class="spoiler_title">L'ensemble du module ressemble √† ceci:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">module FT245toAvalonST ( input clk, input reset, inout [7:0] ft245_data, input logic ft245_rxf, input logic ft245_txe, output logic ft245_rd, output logic ft245_wr, output logic ft245_oe, output logic ft245_siwu, input logic source_ready, output logic source_valid, output logic[7:0] source_data, output logic sink_ready, input logic sink_valid, input logic[7:0] sink_data ); //    enum {idle, toPC, dropOE, fromPC} state = idle; //     always_ff @(posedge clk,posedge reset) begin if (reset == 1) begin state &lt;= idle; end else begin case (state) idle: begin if ((ft245_txe == 0) &amp;&amp; (sink_valid == 1)) state &lt;= toPC; else if ((ft245_rxf == 0)&amp;&amp;(source_ready == 1)) state &lt;= dropOE; end toPC: begin if (!((ft245_txe == 0) &amp;&amp; (sink_valid == 1))) state &lt;= idle; end dropOE: begin state &lt;= fromPC; end fromPC: begin if (!((ft245_rxf == 0)&amp;&amp;(source_ready == 1))) state &lt;= idle; end endcase end end //    //   ,        , //  -    . always_comb begin ft245_oe &lt;= 1; ft245_rd &lt;= 1; ft245_wr &lt;= 1; source_valid &lt;= 0; sink_ready &lt;= 0; //     , //     assign- case (state) idle: begin end toPC: begin ft245_wr &lt;= !(sink_valid); sink_ready &lt;= !(ft245_txe); end dropOE: begin ft245_oe &lt;= 0; end fromPC: begin ft245_oe &lt;= 0; ft245_rd &lt;= !(source_ready); source_valid &lt;= !(ft245_rxf); end endcase end // -  c  ,   ... //   FTDI : // Tie this pin to VCCIO if not used. assign ft245_siwu = 1; //      inout- assign ft245_data = (state == toPC) ? sink_data : 8'hzz; //          assign source_data = ft245_data; endmodule</code> </pre><br></div></div><br>  Comment inclure le module dans la liste des disponibles pour une utilisation dans le syst√®me de processeur, nous avons examin√© en d√©tail dans l'un des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">articles pr√©c√©dents</a> , donc je montre simplement le r√©sultat dans la figure.  Je me souviens que pour y parvenir, j'ai d√ª ajouter deux bus <b>AVALON-ST</b> , un bus <b>Conduit</b> , extraire les signaux d'un bus <b>AVALON-MM</b> d√©fini de mani√®re erron√©e, et lorsqu'il n'y a plus un seul signal dans ce bus, il suffit de le supprimer.  En cours de route, la figure montre les param√®tres que j'ai s√©lectionn√©s pour les bus <b>AVALON-ST</b> (8 bits par symbole, pas d'erreur, le canal maximum est nul, la latence est nulle). <br><br><img src="https://habrastorage.org/webt/-v/9t/ml/-v9tmldj2eyv4rsv8lb3reokzoa.png"><br><br>  Avec le d√©veloppement d'un module d'amarrage des pneus - c'est tout.  Mais h√©las, ah.  D√©velopper n'est que le d√©but du travail.  La mise en ≈ìuvre est beaucoup plus difficile.  Comme le montre la position de la molette sur l'√©cran, la fin de l'article est encore loin.  Nous commen√ßons donc √† cr√©er un projet simple qui utilise le bus <b>FT245-SYNC</b> avec les bus <b>AVALON-ST</b> .  C'est le plus simple.  Un projet s√©rieux ne rentre pas dans le cadre d'un seul article de taille raisonnable.  Je vais maintenant faire la simplification apr√®s la simplification simplement pour que l'attention des lecteurs soit suffisante pour le reste du texte afin qu'ils ne quittent pas la lecture en un mot.  La premi√®re simplification est que les <b>horloges</b> √† 60 MHz pour le <b>FT245_SYNC sont</b> g√©n√©r√©es par la puce <b>FT2232H elle-m√™me</b> .  Je pourrais ajouter deux lignes d'horloge au syst√®me, mais d√®s que tout le monde le verra, nous aurons de telles toiles d'araign√©es que ma m√®re ne pleurera pas.  Si je fais toujours attention aux diff√©rentes lignes d'horloge, nous serons tous confus.  Par cons√©quent, <b>j'annonce</b> simplement qu'aujourd'hui notre syst√®me de processeur horloge √† partir de la puce <b>FT2232H</b> , et non √† partir d'un g√©n√©rateur r√©gulier. <br><br>  Pourquoi ne pouvez-vous pas toujours faire √ßa?  Tr√®s simple: tant que le <b>FT2232H n'est</b> pas en mode 245_SYNC, il n'a pas ces impulsions en sortie.  Autrement dit, vous devez d'abord ex√©cuter le programme pour le processeur central, puis seulement tout charger dans le FPGA.  Si nous devions cr√©er un syst√®me pour un client externe, une telle solution cr√©erait beaucoup de probl√®mes.  Je sais par exp√©rience qu'ils nous t√©l√©phonaient r√©guli√®rement pour nous dire que rien ne fonctionnait, nous rappellerions les bars, mais cela aiderait pendant un certain temps.  Mais nous faisons une chose interne, et nous ne l'utiliserons que dans des conditions de laboratoire.  Autrement dit, dans le cadre de cette t√¢che, cela est permis. <br><br>  Mais cela pose de nouveaux d√©fis.  Nous avons une fr√©quence de 60 MHz et le bloc d'horloge SDRAM que nous utilisons actuellement est √©troitement li√© √† une fr√©quence de 50 MHz.  Oui, j'ai v√©rifi√©, 60 peuvent √™tre soumis, mais supposons que nous essayons de ne pas aller au-del√† des modes autoris√©s.  Dans les articles suivants, j'essaierai de montrer comment remplacer ce bloc dur, mais aujourd'hui, nous disons simplement que puisque notre unit√© d'horloge de SDRAM ne peut pas fonctionner sur la fr√©quence utilis√©e, nous l'excluons du syst√®me de processeur SDRAM.  Le programme et ses donn√©es seront enti√®rement situ√©s dans la m√©moire interne du FPGA.  Il a √©t√© constat√© exp√©rimentalement que dans la configuration actuelle, les FPGA peuvent prendre au maximum 28 kilo-octets de RAM pour cette activit√©.  Il s'av√®re que vous pouvez prendre des volumes et non plusieurs pouvoirs de deux ... <br><br>  De plus, nous utiliserons l'horloge standard et l'unit√© de r√©initialisation.  Il est r√©initialis√© un peu diff√©remment de celui que nous avons utilis√© pour la SDRAM.  Afin de ne pas compliquer l'article, je vais profiter du fait que le syst√®me d√©velopp√© fonctionnera toujours sous le contr√¥le du d√©bogueur, donc je vais commencer une r√©initialisation √† partir du sous-syst√®me JTAG pour le d√©bogage. <br><br>  Au total, nous obtenons une telle esquisse du syst√®me de processeur de base (la ligne de r√©initialisation la plus difficile est actuellement mise en √©vidence, le marqueur bleu est sur la source du signal): <br><br><img src="https://habrastorage.org/webt/zx/ug/nk/zxugnk3v9rhownqtdorprzuvqc8.png"><br><br>  o√π la fr√©quence a √©t√© ajust√©e pour l'horloge et le bloc de r√©initialisation: <br><br><img src="https://habrastorage.org/webt/dj/hq/ap/djhqapk0jpgumyp0qrp34ucszhw.png"><br><br>  et pour la RAM - le volume: <br><br><img src="https://habrastorage.org/webt/pm/k2/vn/pmk2vngq6jhbl3yhydiarxcsm2i.png"><br><br>  Aujourd'hui, nous devons afficher le texte dans le terminal.  Par cons√©quent, nous allons ajouter un bloc int√©ressant au syst√®me: <br><br><img src="https://habrastorage.org/webt/9q/nx/r-/9qnxr-5owicrjxhlqmkeckfxxn8.png"><br><br>  Avec ce bloc, nous pourrons appeler des fonctions similaires √† printf.  En plus du bus AVALON_MM, il doit √©galement connecter la sortie de demande d'interruption. <br><br><img src="https://habrastorage.org/webt/gp/h6/rg/gph6rg59lvarzmtdeaq9wvsiohu.png"><br><br>  Voil√†, l'approvisionnement pour le syst√®me de processeur est termin√©.  Il est temps d'int√©grer notre unit√©.  O√π enverra-t-il les donn√©es?  Parmi les blocs dont nous disposons, il existe une m√©moire FIFO √† deux ports tr√®s int√©ressante.  Son charme r√©side dans le fait qu'un port peut √™tre configur√© en mode <b>AVALON-ST</b> et le connecter √† notre unit√©, et le second en mode <b>AVALON_MM</b> et travailler avec lui en utilisant le processeur NIOS II.  Ce magnifique bloc se trouve ici: <br><br><img src="https://habrastorage.org/webt/fe/9o/ur/fe9ourutodpbj31wm9av_-pkfc4.png"><br><br>  Nous avons deux <b>bus Avalon-ST</b> (un pour la lecture, l'autre pour l'√©criture), nous avons donc √©galement besoin de deux blocs FIFO.  Maintenant, je vais passer en revue l'un d'eux en d√©tail, nous enroulons quelques kilom√®tres de web (et un tas d'√©crans de texte avec des images), et vers la seconde nous disons "cela peut √™tre fait par analogie", indiquant seulement des diff√©rences.  Par cons√©quent, pour l'instant, nous ajoutons un seul bloc au syst√®me et examinons ses param√®tres.  Il y a beaucoup de param√®tres.  On pourrait simplement indiquer les valeurs requises pour que tout le monde se r√©f√®re √† l'article comme r√©f√©rence, mais soudain, quelqu'un se retrouve dans une situation qui doit √™tre configur√©e, mais il n'y a pas d'acc√®s au r√©seau (et donc √† l'article).  Par cons√©quent, je vais ajouter des param√®tres de mani√®re it√©rative.  D'abord √©vident, alors - comme le syst√®me l'exige, parcourez le dialogue encore et encore.  Ainsi, tout le monde ressentira le processus et pourra le r√©p√©ter √† tout moment.  Alors.  Par d√©faut, nous avons re√ßu les param√®tres suivants: <br><br><img src="https://habrastorage.org/webt/yl/bt/14/ylbt14u32cw8xeqherwazdx8nx4.png"><br><br>  Je vais maintenant faire FIFO, qui collecte les donn√©es d' <b>Avalon-ST</b> et les t√©l√©charge sur <b>Avalon-MM</b> .  Il s'av√®re que le premier montage sera comme ceci: <br><br><img src="https://habrastorage.org/webt/1w/m0/xx/1wm0xx_bdp9gjk9nqmb6sooxop0.png"><br><br>  J'ai re√ßu cet avertissement int√©ressant: <br><br><img src="https://habrastorage.org/webt/1u/a8/qs/1ua8qsawychkqv0nxjg_l5u3f4q.png"><br><br>  Il s'av√®re que lorsqu'au moins un des ports est projet√© sur la m√©moire, la largeur du bus <b>Avalon-ST</b> doit √™tre strictement 32 bits.  Et nous avons un bus 8 bits.  Comment convenir des profondeurs de bits, je vais vous dire un peu plus bas, mais pour l'instant nous faisons ici un bus 32 bits avec un caract√®re huit bits.  Eh bien, d√©sactivez le mode batch, comme cela a √©t√© d√©cid√© dans la partie th√©orique. <br><br><img src="https://habrastorage.org/webt/oi/jh/k0/oijhk02tjofxdavtznc1m1es8w4.png"><br><br>  Vient ensuite la capacit√©.  Supposons que j'attende 256 mots (c'est-√†-dire 1024 octets): <br><br><img src="https://habrastorage.org/webt/s4/ca/vl/s4cavlmtxomzl0gsc2dfwn2ovmg.png"><br><br>  Maintenant, le statut.  Au d√©but, je n'y attachais aucune importance, et je me suis fig√© le programme.  Alors maintenant, je sais que ce statut est n√©cessaire.  √âtant donn√© que nous travaillerons avec le port de sortie par programmation, nous ajoutons le statut correspondant. <br><br><img src="https://habrastorage.org/webt/0_/hc/hp/0_hchpmkhfrlg8pg3tjaqg3vpsi.png"><br><br>  et attraper l'erreur: <br><br><img src="https://habrastorage.org/webt/xk/e7/lg/xke7lgan6dpoohxssnvglenuhog.png"><br><br>  Eh bien.  Ajoutez une double synchronisation.  Connectez simplement les deux entr√©es √† la m√™me ligne d'horloge, car nous en avons une. <br>  Uhhhh  Au total, nous avons: <br><br><img src="https://habrastorage.org/webt/iv/nv/pv/ivnvpvdfov3zeo6owfevsdhrq6k.png"><br><br>  Mais il est trop t√¥t pour connecter cette entreprise au syst√®me commun.  Comme nous l'avons d√©couvert, le bus <b>Avalon-ST</b> 8 bits quitte le bloc que nous avons d√©velopp√©, et cela devrait inclure celui de 32 bits.  Comment on va?  Remodeler votre bloc?  Non!  Tout a √©t√© fait avant nous.  Voici ce qui va nous aider: <br><br><img src="https://habrastorage.org/webt/3g/2j/q7/3g2jq74qwjbcgmnvhdchryqi9xm.png"><br><br>  Ajoutez-le au syst√®me.  De plus, comme c'est une couche, purement pour la beaut√©, nous la pla√ßons entre notre bloc et FIFO, en utilisant la fl√®che correspondante: <br><br><img src="https://habrastorage.org/webt/lt/pd/9q/ltpd9qytvl60ez2znbxu1qsudyq.png"><br><br>  Nous faisons les r√©glages suivants: sur l'entr√©e, nous avons un bus 8 bits, sur la sortie 32 bits.  Les signaux de paquets ne sont pas utilis√©s, des signaux <b>pr√™ts</b> et <b>valides</b> sont utilis√©s. <br><br><img src="https://habrastorage.org/webt/bo/-e/h1/bo-eh154mbqqyr0owj9vn96his8.png"><br><br>  Il est temps de tisser une toile.  Tout d'abord, je vais poser les lignes de streaming (dans la figure, elles sont toutes les deux mises en √©vidence, les marqueurs sont sur les r√©cepteurs de donn√©es): <br><br><img src="https://habrastorage.org/webt/br/xu/uj/brxuujnbnsiazm3pxfnnr3tb-cc.png"><br><br>  Autrement dit, le signal provenant de la source de notre bloc va √† l'entr√©e de l'adaptateur.  Et de la sortie de l'adaptateur √† l'entr√©e FIFO.  Comme je l'ai dit, toutes les connexions dans le protocole de streaming se font point √† point. <br>  Eh bien, maintenant nous suspendons les lignes de r√©initialisation, les lignes d'horloge, et nous connectons √©galement tout au bus syst√®me et aux interruptions ... <br><br><img src="https://habrastorage.org/webt/dc/tj/1g/dctj1gqgwbbs7-pcdf4urfbhvsy.png"><br><br>  Eh bien ... Et maintenant, selon le m√™me principe, nous ajoutons FIFO pour √©mettre des donn√©es vers le <b>FT245SYNC</b> .  Seulement l√†, les donn√©es entrent dans le FIFO d' <b>Avalon-MM</b> sous forme 32 bits.  Ils passent par un adaptateur 32-en-8 et arrivent ensuite √† l'entr√©e SINK de notre bloc, qui n'est pas connect√©e dans le circuit actuel ... Nous obtenons le fragment suivant du circuit final (la m√©moire s'est av√©r√©e avec une seule horloge): <br><br><img src="https://habrastorage.org/webt/eg/e5/kc/ege5kckjc4x5vwtsfaxmlp32rqo.png"><br><br>  Autres formalit√©s que nous avons d√©j√† bien travaill√©es dans les exp√©riences d√©crites dans les articles pr√©c√©dents ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pour la plupart - dans celui-ci</a> ).  Nous assignons des vecteurs au processeur.  Pour le syst√®me, nous appelons l'attribution automatique des num√©ros d'interruption et des adresses.  Nous sauvons le syst√®me ... Tout le monde se souvient que le nom du syst√®me enregistr√© doit correspondre au nom du projet pour que le syst√®me soit au niveau sup√©rieur de la hi√©rarchie?  Ajoutez le syst√®me au projet, faites un brouillon du projet, attribuez des √©tapes.  Personnellement, j'ai trich√©: j'ai copi√© les affectations du fichier * .qsf du projet de projet vers celui en cours de finition (et vous pouvez prendre mon projet et copier les lignes * .qsf correspondantes dans le v√¥tre, mais vous pouvez simplement assigner toutes les √©tapes via l'interface graphique).  Je porte une attention particuli√®re au fait que le signal clk est connect√© √† la jambe 23, pas 25, comme dans les projets pr√©c√©dents.  Je vous rappelle qu'ici nous cochons √† partir de la sortie FT2232. <br><br><img src="https://habrastorage.org/webt/9z/bx/sb/9zbxsbgsn4m_9wewmjestkse0fi.png"><br><br>  Super!  Le mat√©riel est pr√™t.  Nous passons au logiciel.  Par o√π commencer?  Aujourd'hui, cette question n'en vaut pas la peine.  Si nous commen√ßons avec un programme qui s'ex√©cute sur le processeur NIOS II, rien ne fonctionnera pour nous.  Tout d'abord, nous devons mettre le FT2232 en mode 245-SYNC, seulement alors notre syst√®me de processeur recevra des impulsions d'horloge.  Par cons√©quent, nous commen√ßons avec le code du processeur central. <br><br><div class="spoiler">  <b class="spoiler_title">Nous obtenons quelque chose comme √ßa:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#include &lt;cstdio&gt; #include &lt;sys/time.h&gt; #include &lt;unistd.h&gt; #include "ftd2xx.h" FT_HANDLE OpenFT2232H() { FT_HANDLE ftHandle0; static FT_DEVICE ftDevice; //      int nDevice = 0; while (true) { //     if (FT_Open(nDevice, &amp;ftHandle0) != FT_OK) { printf("No FT2232 found\n"); //  ,      return 0; } //     ? if (FT_GetDeviceInfo(ftHandle0, &amp;ftDevice, NULL, NULL, NULL, NULL) == FT_OK) { // ,    if (ftDevice == FT_DEVICE_2232H) { // ,     AN130 FT_SetBitMode(ftHandle0, 0xff, 0x00); usleep(1000000); //Sync FIFO mode FT_SetBitMode(ftHandle0, 0xff, 0x40); FT_SetLatencyTimer(ftHandle0, 2); FT_SetUSBParameters(ftHandle0, 0x10000, 0x10000); return ftHandle0; } } //    FT_Close(ftHandle0); //    nDevice += 1; } printf("No FT2232 found\n"); } int main() { FT_HANDLE ftHandle0 = OpenFT2232H(); if (ftHandle0 == 0) { printf("Cannot open device\n"); return -1; } int item; bool bWork = true; while (bWork) { printf("1 - Send 16 bytes\n"); printf("2 - Send 256 bytes\n"); printf("3 - Receive loop\n"); printf("0 - Exit\n"); scanf("%d", &amp;item); switch (item) { case 0: bWork = false; break; case 1: { static const unsigned char data[0x10] = { 0x00,0x01,0x02,0x03, 0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f }; DWORD dwWritten; FT_Write(ftHandle0, (void*)data, sizeof(data), &amp;dwWritten); } break; case 2: { unsigned char data[0x100]; for (size_t i = 0; i &lt; sizeof(data); i++) { data[i] = (unsigned char)i; } DWORD dwWritten; FT_Write(ftHandle0, (void*)data, sizeof(data), &amp;dwWritten); } break; case 3: { DWORD dwRxBytes; DWORD dwRead; DWORD buf[0x100]; while (true) { FT_GetQueueStatus(ftHandle0, &amp;dwRxBytes); if (dwRxBytes != 0) { printf("Received %d bytes (%d DWORDs)\n", dwRxBytes, dwRxBytes / sizeof(buf[0])); if (dwRxBytes &gt; sizeof(buf)) { dwRxBytes = sizeof(buf); } FT_Read(ftHandle0, buf, dwRxBytes, &amp;dwRead); for (DWORD i = 0; i &lt; dwRxBytes / sizeof(buf[0]);i++) { printf("0x%X, ",buf[i]); } printf("\n"); } } } break; } } // ,    FT_Close(ftHandle0); return 0; }</code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La fonction </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenFT2232H () nous est</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> famili√®re depuis le </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dernier article</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . C'est elle qui ouvre l'appareil FT2232 et le met dans le mode dont nous avons besoin. Imm√©diatement apr√®s le lancement r√©ussi du programme, nous obtenons des impulsions d'horloge et, avec elles, la possibilit√© de d√©boguer le programme pour NIOS II. Eh bien, la fonctionnalit√© de la fonction principale est aussi simple qu'un tabouret. Envoyer des donn√©es (1), envoyer beaucoup de donn√©es (2), recevoir des donn√©es (3). Veuillez noter que toutes les donn√©es sont envoy√©es par blocs qui sont des multiples de quatre octets. Tout cela parce que nous avons un adaptateur 8 en 32. A la sortie de celui-ci, les donn√©es doivent aller en double mots. Sinon, tout est √©vident.</font></font><br><br>     NIOS II      BSP. ,        Hello World Small.    BSP       (        BSP,       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a> ). ,     ,  ,  Settings,       . <br><br><img src="https://habrastorage.org/webt/lc/mg/jh/lcmgjhu3udg8njitretcj5wp4vm.png"><br><br>  Generate BSP ,    ,     <b>hello_world_small.c</b>  <b>hello_world_small.cpp</b> ,     ,         . <br><br>        (         ,   FIFO,    ‚Äî   ,    ,        ).         .   ‚Äî        NIOS II.      : <br><br><pre> <code class="plaintext hljs">extern "C" { #include "sys/alt_stdio.h" #include &lt;system.h&gt; #include &lt;altera_avalon_fifo_util.h&gt; } #include &lt;stdint.h&gt; int main() { while (1) { int level = IORD_ALTERA_AVALON_FIFO_LEVEL(FIFO_0_OUT_CSR_BASE); if (level != 0) { alt_printf("0x%x words received:\n",level); for (int i=0;i&lt;level;i++) { alt_printf("0x%x,",IORD_ALTERA_AVALON_FIFO_DATA (FIFO_0_OUT_BASE)); } alt_printf("\n"); } } /* Event loop never exits. */ while (1); return 0; }</code> </pre><br>       FIFO.    ,  . <br>   .    ,    .    Redd   ¬´¬ª ,        NIOS II.   : <br><br><img src="https://habrastorage.org/webt/88/1c/xk/881cxkj95xirw_0rdrrhyaf0ffm.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si vous avez le m√™me, cela signifie que vous avez vraiment oubli√© de commencer √† cadencer le syst√®me de processeur. Mais maintenant, vous savez l'identifier rapidement. Et pour √©liminer, il est n√©cessaire et suffisant d'ex√©cuter le programme que nous avons √©crit pour le processeur central. D√®s qu'il d√©marre et initialise le pont FT2232, les impulsions d'horloge iront √† notre processeur, et il sera possible de r√©p√©ter le processus de d√©marrage du d√©bogage. De plus, le programme pour le processeur central √† ce moment-l√† peut √™tre termin√©. Les impulsions d'horloge n'iront nulle part: le pont est d√©j√† configur√© pour le mode </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FT245-SYNC</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans le programme du processeur central, appuyez sur 1. Selon la situation, l'un ou l'autre appara√Æt dans le terminal: </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0x2 mots re√ßus: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0x3020100,0x7060504, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0x2 mots re√ßus:</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0xb0a0908,0xf0e0d0c,</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ou: </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0x3 mots re√ßus: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0x3020100,0x7060504,0xb0a0908, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0x1 mots re√ßus: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0xf0e0d0c,</font></font></b> <br><br>  ,    1,  3  ,      .    ,      ,      .     ,          ,      JTAG ‚Äî   .       ,          .   ,   (  ,   ?    ),    (FIFO ‚Äî   ,         ,         ). <br><br>         Little Endian. ,    : <br><br><pre> <code class="plaintext hljs">static const unsigned char data[0x10] = { 0x00,0x01,0x02,0x03, 0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f };</code> </pre><br>  C'est vrai.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Si vous s√©lectionnez l'√©l√©ment 2 dans le programme du processeur central, un message appara√Æt (pour faciliter la lecture, les lignes sont format√©es lors de la pr√©paration de l'article): </font></font><br><br><pre> <code class="plaintext hljs">0x3 words received: 0x3020100,0x7060504,0xb0a0908, 0x3d words received: 0xf0e0d0c, 0x13121110,0x17161514,0x1b1a1918,0x1f1e1d1c, 0x23222120,0x27262524,0x2b2a2928,0x2f2e2d2c, 0x33323130,0x37363534,0x3b3a3938,0x3f3e3d3c, 0x43424140,0x47464544,0x4b4a4948,0x4f4e4d4c, 0x53525150,0x57565554,0x5b5a5958,0x5f5e5d5c, 0x63626160,0x67666564,0x6b6a6968,0x6f6e6d6c, 0x73727170,0x77767574,0x7b7a7978,0x7f7e7d7c, 0x83828180,0x87868584,0x8b8a8988,0x8f8e8d8c, 0x93929190,0x97969594,0x9b9a9998,0x9f9e9d9c, 0xa3a2a1a0,0xa7a6a5a4,0xabaaa9a8,0xafaeadac, 0xb3b2b1b0,0xb7b6b5b4,0xbbbab9b8,0xbfbebdbc, 0xc3c2c1c0,0xc7c6c5c4,0xcbcac9c8,0xcfcecdcc, 0xd3d2d1d0,0xd7d6d5d4,0xdbdad9d8,0xdfdedddc, 0xe3e2e1e0,0xe7e6e5e4,0xebeae9e8,0xefeeedec, 0xf3f2f1f0,0xf7f6f5f4,0xfbfaf9f8,0xfffefdfc,</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tout est √©galement vrai. </font><font style="vertical-align: inherit;">Nous proc√©dons √† la v√©rification de la marche arri√®re. </font><font style="vertical-align: inherit;">Nous rempla√ßons le programme pour NIOS II par ceci:</font></font><br><br><pre> <code class="plaintext hljs"> /*  -  2 */ uint32_t buf[] = {0x11223344,0x55667788,0x99aabbcc,0xddeeff00}; for (uint32_t i=0;i&lt;sizeof(buf)/sizeof(buf[0]);i++) { IOWR_ALTERA_AVALON_FIFO_DATA (FIFO_1_IN_BASE,buf[i]); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous s√©lectionnons le point 3 dans le programme pour le processeur central et ex√©cutons cette version du programme pour NIOS II. </font><font style="vertical-align: inherit;">Nous </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">obtenons</font></font><br><br><font style="vertical-align: inherit;"></font></b> <font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font><b><font style="vertical-align: inherit;">16 octets re√ßus (4 DWORD) </font></b><b><font style="vertical-align: inherit;">0x11223344, 0x55667788, 0x99AABBCC, 0xDDEEFF00, les</font></b></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> deux canaux fonctionnent approximativement. </font><font style="vertical-align: inherit;">Et nous allons le v√©rifier une autre fois d'une mani√®re ou d'une autre.</font></font><br><br><h3>  Conclusion </h3><br>        <b>Avalon-ST</b> .        Redd   ,   .           .        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> . <br><br>           .     ,          ,    Redd. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr462253/">https://habr.com/ru/post/fr462253/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr462221/index.html">Quelle d√©ception je suis sur Google Play</a></li>
<li><a href="../fr462227/index.html">Moscou, 9 ao√ªt - Backend Stories 4.0</a></li>
<li><a href="../fr462243/index.html">Am√©lioration des performances frontales de Magento avec ReactJS</a></li>
<li><a href="../fr462245/index.html">auto git bisect comme exemple du noyau Linux</a></li>
<li><a href="../fr462251/index.html">Le mode navigation priv√©e dans le navigateur est-il une fiction?</a></li>
<li><a href="../fr462257/index.html">Kafka sur Kubernetes - est-ce bien?</a></li>
<li><a href="../fr462259/index.html">Faire un contr√¥leur pour une maison intelligente</a></li>
<li><a href="../fr462263/index.html">P√©dalez jusqu'au sol: cr√©ez un autre manipulateur de pied pour PC</a></li>
<li><a href="../fr462265/index.html">Python et cubes</a></li>
<li><a href="../fr462267/index.html">Apprenez √† conna√Ætre l'analyseur statique PVS-Studio pour Java</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>