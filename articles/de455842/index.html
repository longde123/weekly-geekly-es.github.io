<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌌 🎂 🌃 Verbreiten Sie eine einfach verknüpfte Liste. Schnelle Ausgabe 🧝 ⛔️ 📷</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Es ist kein Geheimnis, dass eine der Lieblingsbeschäftigungen eines Softwareentwicklers darin besteht, Arbeitgeber zu befragen. Wir alle tun dies von ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Verbreiten Sie eine einfach verknüpfte Liste. Schnelle Ausgabe</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455842/"> Es ist kein Geheimnis, dass eine der Lieblingsbeschäftigungen eines Softwareentwicklers darin besteht, Arbeitgeber zu befragen.  Wir alle tun dies von Zeit zu Zeit und aus ganz anderen Gründen.  Und die offensichtlichste davon - die Arbeitssuche - ist meiner Meinung nach nicht die häufigste.  Die Teilnahme an einem Interview ist eine gute Möglichkeit, um fit zu bleiben, vergessene Grundlagen zu wiederholen und etwas Neues zu lernen.  Und wenn Sie erfolgreich sind, steigern Sie auch das Selbstvertrauen.  Wir langweilen uns, setzen uns in einem sozialen Netzwerk wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"LinkedIn"</a> den Status "offen für Angebote" - und die Armee der Personalmanager greift bereits unsere Posteingänge für eingehende Nachrichten an. <br><a name="habracut"></a><br><img src="https://habrastorage.org/webt/bw/9r/mc/bw9rmcigk0k9beg-50tdq74sadw.jpeg" alt="Bild"><br><br>  Während all dieses Chaos vor sich geht, stehen wir vor vielen Fragen, die, wie sie auf der anderen Seite des implizit zusammengebrochenen Vorhangs sagen, „eine Glocke läuten“ und deren Details sich hinter dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nebel des Krieges</a> verbergen.  Sie werden meistens nur bei Tests mit Algorithmen und Datenstrukturen (persönlich hatte ich solche Daten überhaupt nicht) und bei Interviews abgerufen. <br><br>  Eine der häufigsten Fragen in einem Interview für einen Programmierer jeder Spezialisierung sind Listen.  Zum Beispiel einfach verknüpfte Listen.  Und verwandte grundlegende Algorithmen.  Zum Beispiel eine Kehrtwende.  Und normalerweise passiert das irgendwie so: "Gut, aber wie würden Sie eine einfach verknüpfte Liste erweitern?"  Die Hauptsache ist, den Antragsteller mit dieser Frage zu überraschen. <br><br>  All dies veranlasste mich, diese kurze Rezension zur ständigen Erinnerung und Erbauung zu schreiben.  Also, Witze beiseite, siehe da! <br><br><h2>  Einfach verknüpfte Liste </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Eine verknüpfte Liste</a> ist eine der grundlegenden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Datenstrukturen</a> .  Jedes Element (oder jeder Knoten) davon besteht tatsächlich aus gespeicherten Daten und Verknüpfungen zu benachbarten Elementen.  Eine einfach verknüpfte Liste speichert nur einen Link zum nächsten Element in der Struktur, und eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">doppelt verknüpfte</a> Liste enthält einen Link zum nächsten und vorherigen.  Eine solche Organisation von Daten ermöglicht es ihnen, sich in einem beliebigen Speicherbereich zu befinden (im Gegensatz beispielsweise zu einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Array</a> , dessen Elemente sich alle nacheinander im Speicher befinden sollten). <br><br>  Zu Listen gibt es natürlich noch viel mehr zu sagen: Sie können kreisförmig sein (d. H. Das letzte Element speichert eine Verknüpfung zum ersten) oder nicht (d. H. Es gibt keine Verknüpfung zum letzten Element).  Listen können eingegeben werden, d.h.  Daten des gleichen Typs enthalten oder nicht.  Und so weiter und so fort. <br><br>  Versuchen Sie besser, Code zu schreiben.  Zum Beispiel können Sie sich einen Listenknoten vorstellen: <br><br><pre><code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Node</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> payload: <span class="hljs-type"><span class="hljs-type">T</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> nextNode: <span class="hljs-type"><span class="hljs-type">Node?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(payload: <span class="hljs-type"><span class="hljs-type">T</span></span>, nextNode: <span class="hljs-type"><span class="hljs-type">Node?</span></span> = <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.payload = payload <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.nextNode = nextNode } }</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Allgemein" ist ein</a> Typ, der Nutzdaten eines beliebigen Typs im Feld " <code>payload</code> speichern kann. <br><br>  Die Liste selbst wird durch ihren ersten Knoten erschöpfend identifiziert: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SinglyLinkedList</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> firstNode: <span class="hljs-type"><span class="hljs-type">Node</span></span>&lt;<span class="hljs-type"><span class="hljs-type">T</span></span>&gt;? <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(firstNode: <span class="hljs-type"><span class="hljs-type">Node</span></span>&lt;<span class="hljs-type"><span class="hljs-type">T</span></span>&gt;? = <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.firstNode = firstNode } }</code> </pre><br>  Der erste Knoten wird als optional deklariert, da die Liste möglicherweise leer ist. <br><br>  <i>Theoretisch müssen Sie in der Klasse natürlich alle erforderlichen Methoden implementieren - Einfügen, Löschen, Zugriff auf Knoten usw., aber wir werden es ein anderes Mal tun.</i>  <i>Gleichzeitig werden wir prüfen, ob die Verwendung von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>struct</code></a> (mit der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Apple</a> uns durch unser Beispiel aktiv ermutigt) eine bessere Wahl ist, und möglicherweise an den Ansatz <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">„Copy-on-Write“</a> erinnern.</i> <br><br><h2>  Single-Linked-List-Spread </h2><br><h3>  Der erste Weg.  Zyklus </h3><br>  Es ist Zeit, zur Sache zu kommen, für die wir heute hier sind!  Und der effektivste Weg, damit umzugehen, sind zwei Wege.  Die erste ist eine einfache Schleife vom ersten bis zum letzten Knoten. <br><br>  Der Zyklus arbeitet mit drei Variablen, denen vor Beginn der Wert des vorherigen, aktuellen und nächsten Knotens zugewiesen wird.  (In diesem Moment ist der Wert des vorherigen Knotens natürlich leer.) Der Zyklus beginnt mit der Überprüfung, ob der nächste Knoten nicht leer ist. In diesem Fall wird der Hauptteil des Zyklus ausgeführt.  In der Schleife geschieht keine Magie: Am aktuellen Knoten wird dem Feld, das sich auf das nächste Element bezieht, eine Verknüpfung mit dem vorherigen Element zugewiesen (bei der ersten Iteration wird der Wert der Verknüpfung zurückgesetzt, was dem Stand der Dinge im letzten Knoten entspricht).  Nun und weiter werden den Variablen, die dem vorherigen, aktuellen und nächsten Knoten entsprechen, neue Werte zugewiesen.  Nach dem Verlassen der Schleife wird dem aktuellen (d. H. Dem letzten im Allgemeinen iterierbaren) Knoten dem nächsten Knoten ein neuer Verbindungswert zugewiesen, weil  Das Verlassen der Schleife erfolgt genau in dem Moment, in dem der letzte Knoten in der Liste aktuell wird. <br><br>  In Worten klingt das alles natürlich seltsam und unverständlich, daher ist es besser, sich den Code anzusehen: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SinglyLinkedList</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reverse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> previousNode: <span class="hljs-type"><span class="hljs-type">Node</span></span>&lt;<span class="hljs-type"><span class="hljs-type">T</span></span>&gt;? = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> currentNode = firstNode <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> nextNode = firstNode?.nextNode <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> nextNode != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { currentNode?.nextNode = previousNode previousNode = currentNode currentNode = nextNode nextNode = currentNode?.nextNode } currentNode?.nextNode = previousNode firstNode = currentNode } }</code> </pre><br>  Zur Überprüfung verwenden wir eine Liste von Knoten, deren Nutzdaten einfache <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ganzzahlkennungen</a> sind.  Erstellen Sie eine Liste mit zehn Elementen: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> node = <span class="hljs-type"><span class="hljs-type">Node</span></span>(payload: <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment">// T == Int let list = SinglyLinkedList(firstNode: node) var currentNode = node var nextNode: Node&lt;Int&gt; for id in 1..&lt;10 { nextNode = Node(payload: id) currentNode.nextNode = nextNode currentNode = nextNode }</span></span></code> </pre><br>  Alles scheint in Ordnung zu sein, aber wir sind Menschen, keine Computer, und es wäre schön, wenn wir einen visuellen Beweis für die Richtigkeit der erstellten Liste und des oben beschriebenen Algorithmus erhalten würden.  Vielleicht reicht ein einfacher Druck.  Um die Ausgabe lesbar zu machen, fügen wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>CustomStringConvertible</code></a> Knoten die Implementierung des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>CustomStringConvertible</code></a> Protokolls mit einer Ganzzahl- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>CustomStringConvertible</code></a> : <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Node</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CustomStringConvertible</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">where</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> == </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Int</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> description: <span class="hljs-type"><span class="hljs-type">String</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> firstPart = <span class="hljs-string"><span class="hljs-string">""" Node \(Unmanaged.passUnretained(self).toOpaque()) has id \(payload) and """</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> nextNode = nextNode { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> firstPart + <span class="hljs-string"><span class="hljs-string">" next node \(nextNode.payload)."</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> firstPart + <span class="hljs-string"><span class="hljs-string">" no next node."</span></span> } } }</code> </pre><br>  ... und die entsprechende Liste, um alle Knoten der Reihe nach anzuzeigen: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SinglyLinkedList</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CustomStringConvertible</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">where</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> == </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Int</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> description: <span class="hljs-type"><span class="hljs-type">String</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> description = <span class="hljs-string"><span class="hljs-string">""" List \(Unmanaged.passUnretained(self).toOpaque()) """</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> firstNode != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { description += <span class="hljs-string"><span class="hljs-string">" has nodes:\n"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> node = firstNode <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> node != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { description += (node!.description + <span class="hljs-string"><span class="hljs-string">"\n"</span></span>) node = node!.nextNode } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> description } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> description + <span class="hljs-string"><span class="hljs-string">" has no nodes."</span></span> } } }</code> </pre><br>  Die Zeichenfolgendarstellung unserer Typen enthält eine Adresse im Speicher und eine Ganzzahlkennung.  Mit ihnen organisieren wir den Druck der generierten Liste von zehn Knoten: <br><br><pre> <code class="swift hljs"><span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-type"><span class="hljs-type">String</span></span>(describing: list)) <span class="hljs-comment"><span class="hljs-comment">/* List 0x00006000012e1a60 has nodes: Node 0x00006000012e2380 has id 0 and next node 1. Node 0x00006000012e8d40 has id 1 and next node 2. Node 0x00006000012e8d20 has id 2 and next node 3. Node 0x00006000012e8ce0 has id 3 and next node 4. Node 0x00006000012e8ae0 has id 4 and next node 5. Node 0x00006000012e89a0 has id 5 and next node 6. Node 0x00006000012e8900 has id 6 and next node 7. Node 0x00006000012e8a40 has id 7 and next node 8. Node 0x00006000012e8a60 has id 8 and next node 9. Node 0x00006000012e8820 has id 9 and no next node. */</span></span></code> </pre><br>  Erweitern Sie diese Liste und drucken Sie sie erneut aus: <br><br><pre> <code class="swift hljs">list.<span class="hljs-built_in"><span class="hljs-built_in">reverse</span></span>() <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-type"><span class="hljs-type">String</span></span>(describing: list)) <span class="hljs-comment"><span class="hljs-comment">/* List 0x00006000012e1a60 has nodes: Node 0x00006000012e8820 has id 9 and next node 8. Node 0x00006000012e8a60 has id 8 and next node 7. Node 0x00006000012e8a40 has id 7 and next node 6. Node 0x00006000012e8900 has id 6 and next node 5. Node 0x00006000012e89a0 has id 5 and next node 4. Node 0x00006000012e8ae0 has id 4 and next node 3. Node 0x00006000012e8ce0 has id 3 and next node 2. Node 0x00006000012e8d20 has id 2 and next node 1. Node 0x00006000012e8d40 has id 1 and next node 0. Node 0x00006000012e2380 has id 0 and no next node. */</span></span></code> </pre><br>  Möglicherweise stellen Sie fest, dass sich die Adressen im Speicher der Liste und der Knoten nicht geändert haben und die Knoten der Liste in umgekehrter Reihenfolge gedruckt werden.  Verweise auf das nächste Element des Knotens verweisen jetzt auf das vorherige (das heißt, das nächste Element des Knotens "5" ist jetzt nicht "6", sondern "4").  Und das heißt, wir haben es geschafft! <br><br><h3>  Der zweite Weg.  Rekursion </h3><br>  Der zweite bekannte Weg, dieselbe Kehrtwende <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">durchzuführen,</a> basiert auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rekursion</a> .  Um es zu implementieren, deklarieren wir eine Funktion, die den ersten Knoten der Liste übernimmt und den „neuen“ ersten Knoten zurückgibt (der der letzte war). <br><br>  Der Parameter und der Rückgabewert sind optional, da er innerhalb dieser Funktion auf jedem nachfolgenden Knoten immer wieder aufgerufen wird, bis er leer ist (d. H. Bis das Ende der Liste erreicht ist).  Dementsprechend muss im Hauptteil der Funktion geprüft werden, ob der Knoten, auf dem die Funktion aufgerufen wird, leer ist und ob dieser Knoten Folgendes aufweist.  Wenn nicht, gibt die Funktion zurück, was an das Argument übergeben wurde. <br><br>  Eigentlich habe ich ehrlich versucht, den vollständigen Algorithmus in Worten zu beschreiben, aber am Ende habe ich fast alles gelöscht, weil das Ergebnis unmöglich zu verstehen wäre.  Flussdiagramme zu zeichnen und die Schritte des Algorithmus formal zu beschreiben - auch in diesem Fall halte ich es nicht für sinnvoll, da es für Sie und mich bequemer ist, den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Swift-</a> Code einfach zu lesen und zu verstehen: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SinglyLinkedList</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reverseRecursively</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reverse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> node: Node&lt;T&gt;?)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Node</span></span>&lt;<span class="hljs-type"><span class="hljs-type">T</span></span>&gt;? { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> head = node <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> node } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> head.nextNode == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> head } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> reversedHead = <span class="hljs-built_in"><span class="hljs-built_in">reverse</span></span>(head.nextNode) head.nextNode?.nextNode = head head.nextNode = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> reversedHead } firstNode = <span class="hljs-built_in"><span class="hljs-built_in">reverse</span></span>(firstNode) } }</code> </pre><br>  Der Algorithmus selbst wird zur Vereinfachung des Aufrufs von einer Methode des Typs der tatsächlichen Liste "umbrochen". <br><br>  Es sieht kürzer aus, ist aber meiner Meinung nach schwerer zu verstehen. <br><br>  Wir rufen diese Methode für das Ergebnis des vorherigen Spread auf und drucken ein neues Ergebnis: <br><br><pre> <code class="swift hljs">list.reverseRecursively() <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-type"><span class="hljs-type">String</span></span>(describing: list)) <span class="hljs-comment"><span class="hljs-comment">/* List 0x00006000012e1a60 has nodes: Node 0x00006000012e2380 has id 0 and next node 1. Node 0x00006000012e8d40 has id 1 and next node 2. Node 0x00006000012e8d20 has id 2 and next node 3. Node 0x00006000012e8ce0 has id 3 and next node 4. Node 0x00006000012e8ae0 has id 4 and next node 5. Node 0x00006000012e89a0 has id 5 and next node 6. Node 0x00006000012e8900 has id 6 and next node 7. Node 0x00006000012e8a40 has id 7 and next node 8. Node 0x00006000012e8a60 has id 8 and next node 9. Node 0x00006000012e8820 has id 9 and no next node. */</span></span></code> </pre><br>  Aus der Ausgabe ist ersichtlich, dass sich nicht alle Adressen im Speicher erneut geändert haben und die Knoten nun in der ursprünglichen Reihenfolge folgen (dh sie werden erneut "bereitgestellt").  Und das heißt, wir haben es wieder richtig gemacht! <br><br><h3>  Schlussfolgerungen </h3><br>  Wenn Sie sich die Umkehrmethoden genau ansehen (oder ein Experiment mit Anrufzählung durchführen), werden Sie feststellen, dass die Schleife im ersten Fall und der interne (rekursive) Methodenaufruf im zweiten Fall einmal weniger auftreten als die Anzahl der Knoten in der Liste (in unserem Fall neun) mal).  Sie können auch darauf achten, was im ersten Fall um die Schleife herum geschieht - dieselbe Reihenfolge von Zuweisungen - und im zweiten Fall auf den ersten, nicht rekursiven Methodenaufruf.  Es stellt sich heraus, dass in beiden Fällen der „Kreis“ für eine Liste von zehn Knoten genau zehnmal wiederholt wird.  Wir haben also eine lineare <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Komplexität</a> für beide Algorithmen - <i>O (n)</i> . <br><br>  Im Allgemeinen werden die beiden beschriebenen Algorithmen als die effektivsten zur Lösung dieses Problems angesehen.  In Bezug auf die Komplexität der Berechnungen ist es nicht möglich, einen Algorithmus mit einem niedrigeren Wert zu entwickeln: Auf die eine oder andere Weise müssen Sie jeden Knoten "besuchen", um dem in der Verbindung gespeicherten einen neuen Wert zuzuweisen. <br><br>  Ein weiteres erwähnenswertes Merkmal ist die „zugewiesene Speicherkomplexität“.  Beide vorgeschlagenen Algorithmen erzeugen eine feste Anzahl neuer Variablen (drei im ersten Fall und eine im zweiten).  Dies bedeutet, dass die Menge des zugewiesenen Speichers nicht von den quantitativen Eigenschaften der Eingabedaten abhängt und durch eine konstante Funktion - O (1) beschrieben wird. <br><br>  Im zweiten Fall ist dies jedoch nicht der Fall.  Die Gefahr einer Rekursion besteht darin, dass jedem rekursiven Aufruf auf dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Stapel</a> zusätzlicher Speicher zugewiesen wird.  In unserem Fall entspricht die Rekursionstiefe der Menge der Eingabedaten. <br><br>  Und schließlich habe ich beschlossen, ein wenig mehr zu experimentieren: Auf einfache und primitive Weise habe ich die absolute Ausführungszeit von zwei Methoden für eine unterschiedliche Menge von Eingabedaten gemessen.  So: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> startDate = <span class="hljs-type"><span class="hljs-type">Date</span></span>().timeIntervalSince1970 <span class="hljs-comment"><span class="hljs-comment">// list.reverse() / list.reverseRecursively() let finishDate = Date().timeIntervalSince1970 let runningTime = finishDate – startDate // Seconds</span></span></code> </pre><br>  Und das habe ich bekommen (das sind die Rohdaten vom <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Spielplatz</a> ): <br><br><img src="https://habrastorage.org/webt/kf/at/bf/kfatbfsxar9clyyokzu6beu3ios.png" alt="Bild"><br><br>  (Leider hat mein Computer die größeren Werte nicht gemeistert.) <br><br>  Was kann man vom Tisch sehen?  Noch nichts Besonderes.  Es fällt zwar bereits auf, dass sich die rekursive Methode bei einer relativ geringen Anzahl von Knoten etwas schlechter verhält, aber irgendwo zwischen 100 und 1000 zeigt sie sich besser. <br><br>  Ich habe den gleichen einfachen Test auch in einem vollwertigen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">„Xcode“</a> -Projekt versucht.  Die Ergebnisse sind wie folgt: <br><br><img src="https://habrastorage.org/webt/sr/vj/0d/srvj0dqmtgtse2wfuqq6llutte4.png" alt="Bild"><br><br>  Zunächst ist zu erwähnen, dass die Ergebnisse nach Aktivierung des „aggressiven“ Optimierungsmodus erzielt wurden, der auf die Ausführungsgeschwindigkeit ( <code>-Ofast</code> ) <code>-Ofast</code> , weshalb die Zahlen teilweise so klein sind.  Interessant ist auch, dass sich in diesem Fall die rekursive Methode etwas besser zeigte, im Gegenteil, nur bei sehr kleinen Eingabedatengrößen und bereits bei einer Liste von 100 Knoten verliert die Methode.  Von 100.000 hat er das Programm abnormal beendet. <br><br><h2>  Fazit </h2><br>  Ich habe versucht, ein eher klassisches Thema aus der Sicht meiner bevorzugten Programmiersprache zu behandeln, und ich hoffe, Sie waren neugierig, den Fortschritt ebenso wie mich selbst zu verfolgen.  Ich bin auch sehr froh, wenn Sie auch etwas Neues gelernt haben - dann habe ich definitiv meine Zeit in diesem Artikel verschwendet (anstatt zu sitzen und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fernsehsendungen anzusehen</a> ). <br><br>  <i>Wenn jemand den Wunsch hat, meine sozialen Aktivitäten zu verfolgen, finden Sie hier einen Link zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">meinem „Twitter“</a> , wo zunächst Links zu meinen neuen Posts und ein wenig mehr vorhanden sind.</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de455842/">https://habr.com/ru/post/de455842/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de455828/index.html">Wissenschaftler haben neue exotische Formen der Synchronisation entdeckt</a></li>
<li><a href="../de455830/index.html">Ein Blick auf Go durch die Augen eines .NET-Entwicklers. Woche # 1</a></li>
<li><a href="../de455832/index.html">Verlauf einer einzelnen SQL-Untersuchung</a></li>
<li><a href="../de455834/index.html">Benchmarks für Linux-Server: 5 offene Tools</a></li>
<li><a href="../de455840/index.html">So arbeiten Sie mit mehreren Abfragen. Zusammensetzung, Reduzierer, FP</a></li>
<li><a href="../de455844/index.html">Erstellen eines Roslyn-Analysators am Beispiel eines Kapselungstests</a></li>
<li><a href="../de455846/index.html">Distributed Computing in Julia</a></li>
<li><a href="../de455848/index.html">Technik zum Vermeiden von undefiniertem Verhalten beim Zugriff auf einen Singleton</a></li>
<li><a href="../de455850/index.html">Toolbox für Forscher - Dritte Ausgabe: Finden und Arbeiten mit Quellen</a></li>
<li><a href="../de455852/index.html">Sinuslifting und gleichzeitige Implantation</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>