<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üìé üë¥üèª üòØ "Quando o rel√≥gio bate doze horas." Ou uma guirlanda no navegador üçå üë©üèæ‚Äçü§ù‚Äçüë®üèº üë®üèæ‚Äçü§ù‚Äçüë®üèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Suponha que tenhamos v√°rios monitores. E quer√≠amos usar esses monitores como uma guirlanda. Por exemplo, fa√ßa-os piscar ao mesmo tempo. Ou talvez alte...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>"Quando o rel√≥gio bate doze horas." Ou uma guirlanda no navegador</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/482168/">  Suponha que tenhamos v√°rios monitores.  E quer√≠amos usar esses monitores como uma guirlanda.  Por exemplo, fa√ßa-os piscar ao mesmo tempo.  Ou talvez altere de forma s√≠ncrona a cor de acordo com algum tipo de algoritmo inteligente.  E se voc√™ fizer isso em um navegador - poder√° conectar smartphones e tablets a isso.  Tudo o que est√° √† m√£o. <br><br><img src="https://habrastorage.org/webt/yo/1c/a8/yo1ca85ahnnxg_5crc1hh84n9ng.jpeg"><br><br>  E, como estamos usando um navegador, voc√™ tamb√©m pode adicionar um design de som.  Afinal, se for preciso o suficiente para sincronizar os dispositivos a tempo, voc√™ poder√° reproduzir sons em cada um deles, como se um sistema multicanal soasse. <br><br><hr>  <i>O que pode ser encontrado ao sincronizar o Web Audio e os rel√≥gios de jogo dentro de um aplicativo javascript;</i>  <i>quantas ‚Äúhoras‚Äù diferentes existem no javasctipt (tr√™s!) e por que todas elas s√£o necess√°rias, al√©m de um <a href="http://habr.snowtime.fun/" rel="nofollow">aplicativo pronto</a> para o node.js sob o gato.</i> <a name="habracut"></a><hr><br><h2>  Verifique o rel√≥gio </h2><br>  Para qualquer guirlanda on-line condicional, √© necess√°ria uma sincroniza√ß√£o precisa do rel√≥gio.  Afinal, voc√™ pode ignorar qualquer atraso de rede (mesmo intermitente).  √â suficiente fornecer aos comandos de controle um carimbo de data e hora e gerar esses comandos um pouco "no futuro".  Nos clientes, eles ser√£o armazenados em buffer e, em seguida, executados de maneira s√≠ncrona e pontual. <br><br>  Ou voc√™ pode ir ainda mais longe - pegue o bom e velho algoritmo aleat√≥rio determin√≠stico e use uma semente comum (emitida pelo servidor uma vez, quando conectada) em todos os dispositivos.  Se voc√™ usar essa semente <i>juntamente</i> com o tempo exato, poder√° predeterminar completamente o comportamento do algoritmo em todos os dispositivos.  Imagine: de fato, voc√™ n√£o precisa de uma rede ou servidor para alterar o estado de forma √∫nica e s√≠ncrona.  A semente j√° cont√©m a "grava√ß√£o de v√≠deo" inteira (condicionalmente infinita) de a√ß√µes com anteced√™ncia.  A principal coisa √© a hora exata. <br><br><img src="https://habrastorage.org/webt/kd/tx/tt/kdtxttvwqoqkb69jvoov077o8vs.gif"><br><hr>  <i>Cada m√©todo tem seus limites de aplicabilidade.</i>  <i>Com a entrada instant√¢nea do usu√°rio, √© claro, n√£o h√° nada a ser feito, resta transmiti-la "como est√°".</i>  <i>Mas tudo o que pode ser calculado deve ser calculado.</i>  <i>Na minha implementa√ß√£o, uso as tr√™s abordagens, dependendo da situa√ß√£o.</i> <hr><br><h2>  Subjetivo "ao mesmo tempo" </h2><br>  Idealmente, tudo deve soar "ao mesmo tempo" - n√£o s√£o necess√°rios mais de ¬± 10 ms de discrep√¢ncia para o pior par entre os dispositivos combinados.  Voc√™ n√£o pode contar com essa precis√£o desde o hor√°rio do sistema, e os m√©todos padr√£o para sincronizar o hor√°rio usando o protocolo NTP n√£o est√£o dispon√≠veis no navegador.  Portanto, dirigiremos nosso servidor de sincroniza√ß√£o.  O princ√≠pio √© simples: o capacete "pings" e aceita "pongs" com o carimbo de data / hora do servidor.  Se voc√™ fizer isso v√°rias vezes seguidas, poder√° nivelar estatisticamente o erro e obter o tempo m√©dio de atraso. <br><br><div class="spoiler">  <b class="spoiler_title">C√≥digo: calculando o tempo do servidor no cliente</b> <div class="spoiler_text"><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> pingClientTime = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">// performace.now() time when ping started let pongClientTime = 3; // performace.now() time when pong received let pongServerTime = 20; // server timstamp in pong answer let clientServerRawOffset = pongServerTime - pongClientTime; let pingPongOffset = pongClientTime - pingClientTime; // roundtrip let estimatedPingOffset = pingPongOffset / 2; // one-way let offset = clientServerRawOffset + estimatedPingOffset; console.log(estimatedPingOffset) // 1 console.log(offset); // 18 let sharedServerTime = performace.now() + offset;</span></span></code> </pre> <br></div></div><br><br>  Os Websockets e as solu√ß√µes baseadas nele s√£o mais adequados porque n√£o precisam de tempo para criar uma conex√£o TCP, e voc√™ pode "se comunicar" com eles nas duas dire√ß√µes.  N√£o UDP ou ICMP, √© claro, mas incomparavelmente mais r√°pido que uma conex√£o fria comum usando a API HTTP.  Portanto, socket.io.  Tudo √© muito f√°cil l√°: <br><br><div class="spoiler">  <b class="spoiler_title">C√≥digo: implementa√ß√£o socket.io</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// server socket.on('ping', (pongCallback) =&gt; { let pongServerTime = performace.now(); pongCallback(pongServerTime); }); //client const binSize = 100; let clientServerCalculatedOffset; function ping() { socket.emit('ping', pongCallback); const pingClientTime = performace.now(); function pongCallback(pongServerTime) { const pongClientTime = performace.now(); const clientServerRawOffset = pongServerTime - pongClientTime; const pingPongOffset = pongClientTime - pingClientTime; // roundtrip const estimatedPingOffset = pingPongOffset / 2; // one-way const offset = clientServerRawOffset + estimatedPingOffset; offsets.unshift(offset); offsets.splice(binSize); let offsetSum = 0; offsets.forEach((offset) =&gt; { offsetSum += offset; }); clientServerCalculatedOffset = offsetSum / offset.length(); } }</span></span></code> </pre> <br>  <i>Seria bom, em vez de calcular a m√©dia, calcular a mediana - isso aumentar√° a precis√£o com uma conex√£o inst√°vel.</i>  <i>A escolha dos m√©todos de filtragem √© com o leitor.</i>  <i>Eu simplifico deliberadamente o c√≥digo aqui em favor dos esquemas.</i>  <i>Minha solu√ß√£o completa pode ser encontrada no reposit√≥rio.</i> <br></div></div><br><br><h2>  performance.now () </h2><br>  Deixe-me lembr√°-lo de que o objeto de <code>performance</code> √© uma API que fornece acesso a um cron√¥metro de alta resolu√ß√£o.  Compare: <br><br><ul><li>  <b><code>Date.now()</code></b> retorna o n√∫mero de milissegundos desde 1¬∫ de janeiro de 1970 e o faz em formato <b>inteiro</b> .  Ou seja, o erro apenas do arredondamento √© de 0,5 ms em m√©dia.  Por exemplo, em uma opera√ß√£o de subtra√ß√£o <code>ab</code> voc√™ pode "perder" sem √™xito at√© 2 ms.  Al√©m disso, hist√≥rica e conceitualmente, o medidor de tempo em si n√£o garante alta precis√£o e √© aprimorado para trabalhos com uma escala de tempo maior. </li><li>  <b><code>performance.now()</code></b> retorna o n√∫mero de milissegundos <a href="https://developer.mozilla.org/en-US/docs/Web/API/DOMHighResTimeStamp" rel="nofollow">desde que a p√°gina da web foi aberta</a> . <br>  Esta √© uma API relativamente recente, "aprimorada" especificamente para medi√ß√£o precisa de intervalos de tempo.  Retorna <b>um valor de ponto flutuante</b> , teoricamente, fornecendo um n√≠vel de precis√£o pr√≥ximo aos recursos do pr√≥prio sistema operacional. <br></li></ul><br><br>  Eu acho que essa informa√ß√£o √© conhecida por quase todos os desenvolvedores de javascript.  Mas nem todo mundo sabe disso ... <br><br><h2>  Espectro </h2><br>  Devido ao sensacional ataque de tempo de Spectre em 2018, tudo chega ao ponto de o temporizador de alta resolu√ß√£o ser artificialmente aumentado se n√£o houver outra solu√ß√£o para o problema de vulnerabilidade.  O Firefox, come√ßando na vers√£o 60, arredonda o valor desse timer para um milissegundo e o Edge, ainda pior. <br><br>  Aqui est√° o que o <a href="https://developer.mozilla.org/en-US/docs/Web/API/Performance/now" rel="nofollow">MDN</a> diz: <br><br><blockquote>  O registro de data e hora n√£o √© de alta resolu√ß√£o.  Para atenuar amea√ßas √† seguran√ßa, como o Spectre, os navegadores atualmente arredondam os resultados em v√°rios graus.  (O Firefox come√ßou a arredondar para 1 milissegundo no Firefox 60.) Alguns navegadores tamb√©m podem randomizar levemente o carimbo de data e hora.  A precis√£o pode melhorar novamente em vers√µes futuras;  os desenvolvedores de navegadores ainda est√£o investigando esses ataques de tempo e a melhor forma de mitig√°-los. </blockquote><br>  Vamos executar o teste e dar uma olhada nos gr√°ficos.  Este √© o resultado do teste no intervalo de 10 ms: <br><br><div class="spoiler">  <b class="spoiler_title">C√≥digo do teste: medi√ß√£o do tempo em um ciclo</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">measureTimesLoop</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">length</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> d = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(length); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> p = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(length); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; length; i++) { d[i] = <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now(); p[i] = performance.now(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { d, p } }</code> </pre> <br></div></div><br><img src="https://habrastorage.org/webt/lt/rr/xo/ltrrxo5m-cfdsf7kpwy_vm0d4nu.png" align="left"> <code>Date.now()</code> <br> <img src="https://habrastorage.org/webt/hp/h-/w3/hph-w3yafyxorpopqiksdnd6j5g.png" align="left"> <code>performance.now()</code> <br> <br><h3>  Edge </h3><br><img src="https://habrastorage.org/webt/g2/t2/bs/g2t2bssr-dhq8cbyb95-pwjxclw.png"><br><div class="spoiler">  <b class="spoiler_title">estat√≠sticas</b> <div class="spoiler_text">  Vers√£o do navegador: 44.17763.771.0 <br><br><h3>  Date.now () </h3>  intervalo m√©dio: 1,0538336052202284 ms <br>  desvio do intervalo m√©dio, RMS: 0,7547819181245603 ms <br>  mediana do intervalo: 1 ms <br><br><h3>  performance.now () </h3>  intervalo m√©dio: 1,567100970873786 ms <br>  desvio do intervalo m√©dio, RMS: 0,6748006785171455 ms <br>  mediana do intervalo: 1,5015000000003056 ms <br></div></div><br><br><h3>  Firefox </h3><br><img src="https://habrastorage.org/webt/7y/6b/a_/7y6ba_0b_lgehjq2yko_60ip4am.png"><br><div class="spoiler">  <b class="spoiler_title">estat√≠sticas</b> <div class="spoiler_text">  Vers√£o do navegador: 71.0 <br><br><h3>  Date.now () </h3>  intervalo m√©dio: 1,0168350168350169 ms <br>  desvio do intervalo m√©dio, RMS: 0,21645930182417966 ms <br>  mediana do intervalo: 1 ms <br><br><h3>  performance.now () </h3>  intervalo m√©dio: 1,0134453781512605 ms <br>  desvio do intervalo m√©dio, RMS: 0,1734108492762375 ms <br>  mediana do intervalo: 1 ms <br></div></div><br><br><h3>  Chrome </h3><br><img src="https://habrastorage.org/webt/zv/_y/pp/zv_yppcegrbidigvmp6npdcwzf0.png"><br><div class="spoiler">  <b class="spoiler_title">estat√≠sticas</b> <div class="spoiler_text">  Vers√£o do navegador: 79.0.3945.88 <br><br><h3>  Date.now () </h3>  intervalo m√©dio: 1,02442996742671 ms <br>  desvio do intervalo m√©dio, RMS: 0,49858684744444 ms <br>  mediana do intervalo: 1 ms <br><br><h3>  performance.now () </h3>  intervalo m√©dio: 0,005555847229948915 ms <br>  desvio do intervalo m√©dio, RMS: 0,027497846727194235 ms <br>  mediana do intervalo: 0.0050000089686363935 ms <br></div></div><br><br>  Ok, Chrome, zoom para 1 ms. <br><br><img src="https://habrastorage.org/webt/2o/9m/ik/2o9mikwf_owbi8mn1saodrmd_e8.png"><br><br>  Portanto, o Chrome ainda est√° aguentando, e sua implementa√ß√£o de <code>performance.now()</code> ainda n√£o foi estrangulada e a etapa √© linda 0,005 ms.  No Edge, o timer <code>performance.now()</code> √© mais √°spero que o <code>Date.now()</code> !  No Firefox, os dois timers t√™m a mesma precis√£o de milissegundos. <br><br>  Nesta fase, algumas conclus√µes j√° podem ser tiradas.  Mas h√° outro temporizador em javascript (sem o qual n√£o podemos prescindir). <br><br><h2>  Temporizador da API do WebAudio </h2><br>  Este √© um animal ligeiramente diferente.  √â usado para filas de √°udio atrasadas.  O fato √© que os eventos de √°udio (tocando notas, gerenciando efeitos) n√£o podem confiar nas ferramentas javascript ass√≠ncronas padr√£o: <code>setInterval</code> e <code>setTimeout</code> - por causa de seu erro muito grande.  E este n√£o √© apenas o erro <i>dos valores do</i> timer (com os quais lidamos anteriormente), mas √© o erro com o qual a m√°quina de eventos executa eventos.  E j√° √© algo em torno de 5 a 25 ms, mesmo em condi√ß√µes de estufa. <br><br><div class="spoiler">  <b class="spoiler_title">Gr√°ficos para o caso ass√≠ncrono sob o spoiler</b> <div class="spoiler_text">  O resultado do teste em um intervalo de 100 ms: <br><br><div class="spoiler">  <b class="spoiler_title">C√≥digo de teste: medi√ß√£o do tempo em um ciclo ass√≠ncrono</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pause</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">duration</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function">) =&gt;</span></span> { setInterval(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { resolve(); }, duration); }); } <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">measureTimesInAsyncLoop</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">length</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> d = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(length); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> p = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(length); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; length; i++) { d[i] = <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now(); p[i] = performance.now(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> pause(<span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { d, p } }</code> </pre> <br></div></div><br><img src="https://habrastorage.org/webt/lt/rr/xo/ltrrxo5m-cfdsf7kpwy_vm0d4nu.png" align="left"> <code>Date.now()</code> <br> <img src="https://habrastorage.org/webt/hp/h-/w3/hph-w3yafyxorpopqiksdnd6j5g.png" align="left"> <code>performance.now()</code> <br> <br><h3>  Edge </h3><br><img src="https://habrastorage.org/webt/_z/im/h2/_zimh2thj4w5t2o_ounushbk94m.png"><br><div class="spoiler">  <b class="spoiler_title">estat√≠sticas</b> <div class="spoiler_text">  Vers√£o do navegador: 44.17763.771.0 <br><br><h3>  Date.now () </h3>  intervalo m√©dio: 25,595959595959595 ms <br>  desvio do intervalo m√©dio, RMS: 10.12639235162126 ms <br>  mediana do intervalo: 28 ms <br><br><h3>  performance.now () </h3>  intervalo m√©dio: 25,862596938775525 ms <br>  desvio do intervalo m√©dio, RMS: 10.123711255512573 ms <br>  mediana do intervalo: 27.027099999999336 ms <br></div></div><br><br><h3>  Firefox </h3><br><img src="https://habrastorage.org/webt/bm/pn/bs/bmpnbsvv3esgusduj0djwdvazg4.png"><br><div class="spoiler">  <b class="spoiler_title">estat√≠sticas</b> <div class="spoiler_text">  Vers√£o do navegador: 71.0 <br><br><h3>  Date.now () </h3>  intervalo m√©dio: 1,6914893617021276 ms <br>  desvio do intervalo m√©dio, RMS: 0,6018870280772611 ms <br>  mediana do intervalo: 2 ms <br><br><h3>  performance.now () </h3>  intervalo m√©dio: 1,7865168539325842 ms <br>  desvio do intervalo m√©dio, RMS: 0,6442818510935484 ms <br>  mediana do intervalo: 2 ms <br></div></div><br><br><h3>  Chrome </h3><br><img src="https://habrastorage.org/webt/ig/my/wf/igmywf_jvwphlqdqm9qac2evy64.png"><br><div class="spoiler">  <b class="spoiler_title">estat√≠sticas</b> <div class="spoiler_text">  Vers√£o do navegador: 79.0.3945.88 <br><br><h3>  Date.now () </h3>  intervalo m√©dio: 4.787878787878788888, ms <br>  desvio do intervalo m√©dio, RMS: 0,7557553886872682 ms <br>  mediana do intervalo: 5 ms <br><br><h3>  performance.now () </h3>  intervalo m√©dio: 4.783989898979516 ms <br>  desvio do intervalo m√©dio, RMS: 0,6483716900974945 ms <br>  intervalo m√©dio: 4,750000000058208 ms <br></div></div><br></div></div><br><br>  Talvez algu√©m se lembre das primeiras aplica√ß√µes experimentais de √°udio HTML.  Antes que o WebAudio completo chegasse aos navegadores - todos pareciam um pouco b√™bados e desleixados.  S√≥ porque eles usaram <code>setTimeout</code> como um seq√ºenciador. <br><br>  A moderna API WebAudio, em contraste, fornece uma resolu√ß√£o garantida de at√© 0,02 ms (especula√ß√£o com base na frequ√™ncia de amostragem de 44100Hz).  Isso se deve ao fato de um mecanismo diferente ser usado para reprodu√ß√£o de som atrasada que <code>setTimeout</code> : <br><br><pre> <code class="javascript hljs">source.start(when);</code> </pre> <br>  De fato, qualquer reprodu√ß√£o de uma amostra de √°udio √© "atrasada".  S√≥ para perd√™-lo "n√£o √© adiado", voc√™ precisa adi√°-lo "at√© agora". <br><br><pre> <code class="javascript hljs">source.start(audioCtx.currentTime);</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Sobre m√∫sica gerada por software em tempo real</b> <div class="spoiler_text">  Se voc√™ tocar uma melodia sintetizada por programa a partir de notas, essas notas dever√£o ser adicionadas √† fila de reprodu√ß√£o um pouco antes.  Ent√£o, apesar de todas as restri√ß√µes e irregularidades n√£o fundamentais dos timers, a melodia tocar√° perfeitamente. <br><br>  Em outras palavras, a melodia sintetizada em tempo real n√£o deve ser "inventada" em tempo real, mas com um pouco de anteced√™ncia. <br></div></div><br><br><h2>  Um temporizador para governar todos eles </h2><br>  Como <code>audioCtx.currentTime</code> t√£o est√°vel e preciso, talvez dev√™ssemos us√°-lo como a principal fonte de tempo relativo?  Vamos executar o teste novamente. <br><br><div class="spoiler">  <b class="spoiler_title">C√≥digo de teste: medindo a medi√ß√£o s√≠ncrona do tempo em um ciclo</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">measureTimesInLoop</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">length</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> d = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(length); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> p = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(length); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(length); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; length; i++) { d[i] = <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now(); p[i] = performance.now(); a[i] = audioCtx.currentTime * <span class="hljs-number"><span class="hljs-number">1000</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { d, p, a } }</code> </pre> <br></div></div><br><img src="https://habrastorage.org/webt/lt/rr/xo/ltrrxo5m-cfdsf7kpwy_vm0d4nu.png" align="left"> <code>Date.now()</code> <br> <img src="https://habrastorage.org/webt/hp/h-/w3/hph-w3yafyxorpopqiksdnd6j5g.png" align="left"> <code>performance.now()</code> <br> <img src="https://habrastorage.org/webt/xo/or/r9/xoorr9ldh_oivoxxvbxj8yozwqc.png" align="left"> <code>audioCtx.currentTime</code> <br> <br><h3>  Edge </h3><br><img src="https://habrastorage.org/webt/rt/xx/u0/rtxxu0ckburybooxuw93uiya7-s.png"><br><div class="spoiler">  <b class="spoiler_title">estat√≠sticas</b> <div class="spoiler_text">  Vers√£o do navegador: 44.17763.771.0 <br><br><h3>  Date.now () </h3>  intervalo m√©dio: 1,037037037037037 ms <br>  desvio do intervalo m√©dio, RMS: 0,6166609846299806 ms <br>  mediana do intervalo: 1 ms <br><br><h3>  performance.now () </h3>  intervalo m√©dio: 1,5447103117505993 ms <br>  desvio do intervalo m√©dio, RMS: 0,4390514285320851 ms <br>  mediana do intervalo: 1,5015000000000782 ms <br><br><h3>  audioCtx.currentTime </h3>  intervalo m√©dio: 2,955751134714949 ms <br>  desvio do intervalo m√©dio, RMS: 0,6193645611529503 ms <br>  mediana do intervalo: 2,902507781982422 ms <br><br></div></div><br><br><h3>  Firefox </h3><br><img src="https://habrastorage.org/webt/rr/v6/ws/rrv6wsi1tmnpdb8yf7y6wmfvyo8.png"><br><div class="spoiler">  <b class="spoiler_title">estat√≠sticas</b> <div class="spoiler_text">  Vers√£o do navegador: 71.0 <br><br><h3>  Date.now () </h3>  intervalo m√©dio: 1,005128205128205 ms <br>  desvio do intervalo m√©dio, RMS: 0,12392867665225249 ms <br>  mediana do intervalo: 1 ms <br><br><h3>  performance.now () </h3>  intervalo m√©dio: 1,00513698630137 ms <br>  desvio do intervalo m√©dio, RMS: 0,07148844433269844 ms <br>  mediana do intervalo: 1 ms <br><br><h3>  audioCtx.currentTime </h3>  O Firefox n√£o atualiza o valor do timer de √°udio no loop de sincroniza√ß√£o <br><br></div></div><br><br><h3>  Chrome </h3><br><img src="https://habrastorage.org/webt/yx/wx/rk/yxwxrkmxhv3yzxzpzckvfhouz6y.png"><br><div class="spoiler">  <b class="spoiler_title">estat√≠sticas</b> <div class="spoiler_text">  Vers√£o do navegador: 79.0.3945.88 <br><br><h3>  Date.now () </h3>  intervalo m√©dio: 1,0207612456747406 ms <br>  desvio do intervalo m√©dio, RMS: 0,49870223457982504 ms <br>  mediana do intervalo: 1 ms <br><br><h3>  performance.now () </h3>  intervalo m√©dio: 0,005414502034674972 ms <br>  desvio do intervalo m√©dio, RMS: 0,027441293974958335 ms <br>  intervalo m√©dio: 0,004999999873689376 ms <br><br><h3>  audioCtx.currentTime </h3>  intervalo m√©dio: 3,0877599266656963 ms <br>  desvio do intervalo m√©dio, RMS: 1,1445555956407658 ms <br>  mediana do intervalo: 2,9024943310650997 ms <br><br></div></div><br><br><div class="spoiler">  <b class="spoiler_title">Gr√°ficos para o caso ass√≠ncrono sob o spoiler</b> <div class="spoiler_text"><div class="spoiler">  <b class="spoiler_title">C√≥digo de teste: medi√ß√£o do tempo em um ciclo ass√≠ncrono</b> <div class="spoiler_text">  O resultado do teste em um intervalo de 100 ms: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pause</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">duration</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function">) =&gt;</span></span> { setInterval(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { resolve(); }, duration); }); } <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">measureTimesInAsyncLoop</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">length</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> d = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(length); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> p = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(length); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(length); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; length; i++) { d[i] = <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now(); p[i] = performance.now(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> pause(<span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { d, p } }</code> </pre> <br></div></div><br><br><img src="https://habrastorage.org/webt/lt/rr/xo/ltrrxo5m-cfdsf7kpwy_vm0d4nu.png" align="left"> <code>Date.now()</code> <br> <img src="https://habrastorage.org/webt/hp/h-/w3/hph-w3yafyxorpopqiksdnd6j5g.png" align="left"> <code>performance.now()</code> <br> <img src="https://habrastorage.org/webt/xo/or/r9/xoorr9ldh_oivoxxvbxj8yozwqc.png" align="left"> <code>audioCtx.currentTime</code> <br> <br><h3>  Edge </h3><br><img src="https://habrastorage.org/webt/3o/sz/az/3oszazaq71kxfdaftgn6v3z23xe.png"><br><div class="spoiler">  <b class="spoiler_title">estat√≠sticas</b> <div class="spoiler_text">  Vers√£o do navegador: 44.17763.771.0 <br><br><h3>  Date.now (): </h3>  intervalo m√©dio: 24,505050505050505 ms <br>  desvio do intervalo m√©dio: 11,513166584195204 ms <br>  mediana do intervalo: 26 ms <br><br><h3>  performance.now (): </h3>  intervalo m√©dio: 24,50935757575754 ms <br>  desvio do intervalo m√©dio: 11,679091435527388 ms <br>  mediana do intervalo: 25,525499999999738 ms <br><br><h3>  audioCtx.currentTime: </h3>  intervalo m√©dio: 24,76005164944396 ms <br>  desvio do intervalo m√©dio: 11.311571546205316 ms <br>  mediana do intervalo: 26.121139526367187 ms <br><br></div></div><br><h3>  Firefox </h3><br><img src="https://habrastorage.org/webt/wf/4n/jn/wf4njn3z7u9uoxluprufhlbctai.png"><br><div class="spoiler">  <b class="spoiler_title">estat√≠sticas</b> <div class="spoiler_text">  Vers√£o do navegador: 71.0 <br><br><h3>  Date.now (): </h3>  intervalo m√©dio: 1,6875 ms <br>  desvio do intervalo m√©dio: 0,6663410663216448 ms <br>  mediana do intervalo: 2 ms <br><br><h3>  performance.now (): </h3>  intervalo m√©dio: 1.7234042553191489 ms <br>  desvio do intervalo m√©dio: 0,6588877688171075 ms <br>  mediana do intervalo: 2 ms <br><br><h3>  audioCtx.currentTime: </h3>  intervalo m√©dio: 10,158730158730123 ms <br>  desvio do intervalo m√©dio: 1,4512471655330046 ms <br>  intervalo m√©dio: 8,707482993195299 ms <br><br></div></div><br><h3>  Chrome </h3><br><img src="https://habrastorage.org/webt/_s/hd/uh/_shduhzpetwube_gn6kxmwyobiu.png"><br><div class="spoiler">  <b class="spoiler_title">estat√≠sticas</b> <div class="spoiler_text">  Vers√£o do navegador: 79.0.3945.88 <br><br><h3>  Date.now (): </h3>  intervalo m√©dio: 4,585858585858586 ms <br>  desvio do intervalo m√©dio: 0,9102125516015199 ms <br>  mediana do intervalo: 5 ms <br><br><h3>  performance.now (): </h3>  intervalo m√©dio: 4,592424242424955 ms <br>  desvio do intervalo m√©dio: 0,719936993603155 ms <br>  mediana do intervalo: 4,605000001902226 ms <br><br><h3>  audioCtx.currentTime: </h3>  intervalo m√©dio: 10.12648022171832 ms <br>  desvio do intervalo m√©dio: 1.4508887886499262 ms <br>  mediana do intervalo: 8.707482993197118 ms <br><br></div></div><br></div></div><br>  Bem, n√£o vai dar certo.  "Fora", este temporizador √© o mais impreciso.  O Firefox n√£o atualiza o valor do timer dentro do loop.  Mas, em geral: a resolu√ß√£o √© de 3 ms e o jitter √© pior e mais vis√≠vel.  Talvez o valor de <code>audioCtx.currentTime</code> reflita a posi√ß√£o no buffer de anel do driver da placa de √°udio.  Em outras palavras, mostra o tempo m√≠nimo em que ainda √© poss√≠vel atrasar a reprodu√ß√£o com seguran√ßa. <br><br>  E o que fazer?  Afinal, precisamos de um cron√¥metro preciso para sincronizar com o servidor e iniciar eventos javascript na tela e um cron√¥metro de √°udio para eventos sonoros! <br><br>  Acontece que voc√™ precisa sincronizar todos os cron√¥metros entre si: <br><br><ul><li>  Cliente <code>audioCtx.currentTime</code> com o cliente <code>performance.now()</code> no cliente. </li><li>  E cliente <code>performance.now()</code> com <code>performance.now()</code> do lado do servidor. </li></ul><br><h2>  Sincronizado, sincronizado </h2><br><img src="https://habrastorage.org/webt/f1/ph/o9/f1pho9gss4d40786nszfeicwrog.png" align="right">  Em geral, isso √© bem engra√ßado se voc√™ pensar a respeito: voc√™ pode ter duas boas fontes de tempo A e B, cada uma das quais √© muito grossa e barulhenta na sa√≠da (A '= A + erro <sub>A</sub> ; B' = B + erro <sub>B</sub> ) para que possa at√© ser inutiliz√°vel por si s√≥.  Mas a diferen√ßa d entre as fontes n√£o barulhentas originais pode ser restaurada com muita precis√£o. <br><br>  Como a dist√¢ncia real entre os rel√≥gios ideais √© uma constante, fazendo medi√ß√µes n vezes, reduziremos o erro de medi√ß√£o err n vezes, respectivamente.  A menos, √© claro, que o rel√≥gio funcione na mesma velocidade. <br><br><h2>  Sim n√£o sincronizado </h2><br>  A m√° not√≠cia √© que n√£o, eles n√£o v√£o na mesma velocidade.  E n√£o estou falando da diverg√™ncia de horas no servidor e no cliente - isso √© compreens√≠vel e esperado.  O que √© mais inesperado: <code>audioCtx.currentTime</code> gradualmente divergindo de <code>performance.now()</code> .  Est√° dentro do cliente.  Podemos n√£o perceber, mas, √†s vezes, sob carga, o sistema de √°udio pode n√£o engolir um pequeno peda√ßo de dados e (ao contr√°rio da natureza do buffer de toque), o tempo do √°udio muda em rela√ß√£o ao tempo do sistema.  Isso acontece n√£o t√£o raramente, apenas n√£o preocupa muitas pessoas: mas, por exemplo, se voc√™ lan√ßa dois v√≠deos do YouTube ao mesmo tempo simultaneamente em computadores diferentes, n√£o √© fato que eles parem de reproduzir simultaneamente.  E o ponto, √© claro, n√£o est√° na publicidade. <br><br>  Assim, para opera√ß√£o est√°vel e s√≠ncrona.  Precisamos verificar novamente <i>regularmente</i> todos os rel√≥gios, usando o tempo do servidor - como refer√™ncia.  E, em seguida, o trade-off aparece em quantas medidas usar para calcular a m√©dia: quanto mais - mais precisa, mas maior a chance de um salto acentuado no <code>audioCtx.currentTime</code> cair na janela de tempo em que filtramos os valores.  Ent√£o, se, por exemplo, usarmos a janela de minutos, todos os minutos ter√£o o tempo decorrido.  A escolha dos filtros √© ampla: <a href="https://ru.wikipedia.org/wiki/%25D0%25AD%25D0%25BA%25D1%2581%25D0%25BF%25D0%25BE%25D0%25BD%25D0%25B5%25D0%25BD%25D1%2586%25D0%25B8%25D0%25B0%25D0%25BB%25D1%258C%25D0%25BD%25D0%25BE%25D0%25B5_%25D1%2581%25D0%25B3%25D0%25BB%25D0%25B0%25D0%25B6%25D0%25B8%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5" rel="nofollow">exponencial</a> , <a href="https://ru.wikipedia.org/wiki/%25D0%259C%25D0%25B5%25D0%25B4%25D0%25B8%25D0%25B0%25D0%25BD%25D0%25B0_(%25D1%2581%25D1%2582%25D0%25B0%25D1%2582%25D0%25B8%25D1%2581%25D1%2582%25D0%25B8%25D0%25BA%25D0%25B0)" rel="nofollow">mediana</a> , <a href="https://ru.wikipedia.org/wiki/%25D0%25A4%25D0%25B8%25D0%25BB%25D1%258C%25D1%2582%25D1%2580_%25D0%259A%25D0%25B0%25D0%25BB%25D0%25BC%25D0%25B0%25D0%25BD%25D0%25B0" rel="nofollow">filtro Kalman</a> , etc.  Mas essa troca √©, de qualquer forma. <br><br><h2>  Janela de tempo </h2><br>  No caso de sincronizar <code>audioCtx.currentTime</code> com <code>performance.now()</code> , em um loop ass√≠ncrono, para n√£o interferir com a interface do usu√°rio, podemos fazer uma medi√ß√£o, digamos, 100 ms. <br>  Suponha que o erro de medi√ß√£o err = errA + errB = 1 + 3 = 4 ms <br>  Assim, em 1 segundo, podemos reduzi-lo para 0,4 ms e em 10 segundos para 0,04 ms.  Melhorias adicionais no resultado n√£o fazem sentido e uma boa janela para filtragem ser√°: 1 a 10 segundos. <br><br>  No caso da sincroniza√ß√£o da rede, atrasos e erros j√° s√£o muito mais significativos, mas n√£o h√° um salto acentuado no tempo, como no caso do <code>audioCtx.currentTime</code> .  E voc√™ pode se permitir acumular √≥timas estat√≠sticas.  Afinal, o erro no ping pode ser de at√© 500 ms.  E as medidas em si n√£o podemos fazer com tanta frequ√™ncia. <br><br>  Neste ponto, proponho parar.  Se algu√©m estiver interessado, ficarei feliz em lhe dizer como "desenhar o resto da coruja".  Mas, como parte da hist√≥ria sobre temporizadores, acho que minha hist√≥ria acabou. <br><br>  E quero compartilhar o que recebi.  Mesmo assim, o ano novo. <br><br><h2>  O que aconteceu </h2><br>  Isen√ß√£o de responsabilidade: tecnicamente, este √© um site de rela√ß√µes p√∫blicas em Habr√©, mas este √© um projeto de c√≥digo aberto totalmente sem fins lucrativos, no qual prometo nunca: colocar an√∫ncios ou ganhar dinheiro de qualquer outra maneira.  Pelo contr√°rio, levantei mais inst√¢ncias do meu dinheiro agora para sobreviver a um poss√≠vel efeito habitual.  Portanto, por favor, gente boa, n√£o me quebre nem me alcance.  Tudo isso √© puramente divertido. <br><br>  Feliz Ano Novo, Habr! <br><br><hr><br><h3>  <a href="http://habr.snowtime.fun/" rel="nofollow">snowtime.fun</a> </h3>  Voc√™ pode girar os bot√µes e controlar os efeitos de visualiza√ß√£o, m√∫sica e √°udio.  Se voc√™ possui uma placa de v√≠deo normal, v√° para as configura√ß√µes e defina o n√∫mero de part√≠culas para 100%. <br><br>  Requer WebAudio e WebGL. <br><br><hr><br><br>  <b>UPD:</b> n√£o funciona no Safari no macOS Mojave.  Infelizmente, n√£o h√° como descobrir rapidamente o que est√° acontecendo, devido √† aus√™ncia do pr√≥prio Safari.  O iOS parece estar funcionando. <br><br>  <b>UPD2:</b> Se <a href="http://snowtime.fun/" rel="nofollow">snowtime.fun</a> e <a href="http://web.snowtime.fun/" rel="nofollow">web.snowtime.fun</a> n√£o <a href="http://web.snowtime.fun/" rel="nofollow">estiverem</a> respondendo, tente o novo subdom√≠nio <a href="http://habr.snowtime.fun/" rel="nofollow"><b>habr</b> .snowtime.fun</a> .  Ele mudou o servidor para outro datacenter e o IP antigo foi armazenado em cache no DNS, <code>expire=1w</code> .  :( <br><br>  Reposit√≥rio: <a href="https://bitbucket.org/barkalov/snowtime.fun/src" rel="nofollow">bitbucket</a> <br>  Ao escrever este artigo, foram utilizadas ilustra√ß√µes de <a href="http://www.freepik.com/" rel="nofollow">macrovetor / Freepik</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt482168/">https://habr.com/ru/post/pt482168/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt482152/index.html">Vulnerabilidades em sistemas operacionais em tempo real</a></li>
<li><a href="../pt482154/index.html">Por que limitar a heran√ßa com final?</a></li>
<li><a href="../pt482156/index.html">Entrevista com Will Kurt sobre seu novo livro, Bayesian Statistics - It's Great</a></li>
<li><a href="../pt482162/index.html">Os matem√°ticos encontraram um padr√£o, entendendo como evitar sua apar√™ncia</a></li>
<li><a href="../pt482166/index.html">Servi√ßo de treinamento de c√£es no aeroporto: voc√™ j√° est√° cheirando</a></li>
<li><a href="../pt482170/index.html">Guerras de processadores. A hist√≥ria da lebre azul e da tartaruga vermelha</a></li>
<li><a href="../pt482176/index.html">Como foi a confer√™ncia @Kubernetes em 29 de novembro: v√≠deo e resultados</a></li>
<li><a href="../pt482178/index.html">A hist√≥ria de um estudante coreano que recebeu um pr√™mio do minist√©rio por um sistema de monitoramento de filas</a></li>
<li><a href="../pt482182/index.html">Que problemas eu teria se lutasse pelo equil√≠brio de g√™nero em TI?</a></li>
<li><a href="../pt482186/index.html">Vida e TI ou no ano em que larguei meu √∫ltimo emprego</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>