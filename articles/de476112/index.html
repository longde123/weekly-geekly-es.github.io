<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü¶ç üî£ üßùüèΩ Elixier als Entwicklungsziel f√ºr Python Async üêï üôåüèΩ üë®üèª‚Äç‚öñÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In dem Buch ‚ÄûPython. Zu den H√∂hen der Exzellenz ‚ÄúLuciano Ramallo beschreibt eine Geschichte. Im Jahr 2000 nahm Luciano an Kursen teil, und einmal sah ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Elixier als Entwicklungsziel f√ºr Python Async</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/476112/">  In dem Buch ‚ÄûPython.  Zu den H√∂hen der Exzellenz ‚ÄúLuciano Ramallo beschreibt eine Geschichte.  Im Jahr 2000 nahm Luciano an Kursen teil, und einmal sah Guido van Rossum das Publikum an.  Sobald ein solches Ereignis auftauchte, begannen alle, ihm Fragen zu stellen.  Auf die Frage, welche Funktionen Python von anderen Sprachen ausgeliehen hat, antwortete Guido: "Alles, was in Python gut ist, wird von anderen Sprachen gestohlen." <br><br>  Das ist tats√§chlich so.  Python hat lange im Kontext anderer Programmiersprachen gelebt und nimmt Konzepte aus seiner Umgebung auf: Asyncio wird entlehnt, dank Lisp erschienen Lambda-Ausdr√ºcke, und Tornado wurde aus libevent kopiert.  Aber wenn jemand Ideen ausleihen sollte, dann ist es Erlang.  Es wurde vor 30 Jahren erstellt, und alle Konzepte in Python, die derzeit implementiert werden oder nur skizziert sind, funktionieren seit langem in Erlang: Multi-Core-Nachrichten als Grundlage f√ºr Kommunikation, Methodenaufrufe und Selbstbeobachtung in einem Live-Produktionssystem.  Diese Ideen finden in der einen oder anderen Form ihren Ausdruck in Systemen wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Seastar.io</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fb/0x/mf/fb0xmfg8afpsrhs7js423v4bvjy.jpeg" width="500"></div><br>  Wenn Sie Data Science nicht ber√ºcksichtigen, bei dem Python nun au√üer Konkurrenz ist, ist alles andere bereits in Erlang implementiert: Arbeiten mit einem Netzwerk, Umgang mit HTTP- und Web-Sockets, Arbeiten mit Datenbanken.  Daher ist es f√ºr Python-Entwickler wichtig zu verstehen, wo sich die Sprache bewegen wird: auf einer Stra√üe, die bereits vor 30 Jahren vergangen ist. <br><br>  Um die Geschichte der Entwicklung anderer Sprachen zu verstehen und den Fortschritt zu verstehen, haben wir <strong>Maxim Lapshin</strong> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">erlyvideo</a> ), den Autor des Projekts Erlyvideo.ru, zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Moscow Python Conf ++</a> eingeladen. <br><br>  Unter dem K√ºrzel steht die Textversion dieses Berichts, n√§mlich: In welche Richtung muss sich das System entwickeln, das weiterhin vom einfachen linearen Code zu libevent und dar√ºber hinaus migriert, was h√§ufig vorkommt und was die Unterschiede zwischen Elixir und Python sind.  Besonderes Augenmerk legen wir auf die Verwaltung von Sockets, Threads und Daten in verschiedenen Programmiersprachen und Plattformen. <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/RAZ0sHpPrZE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Erlyvideo.ru verf√ºgt √ºber ein Video√ºberwachungssystem, bei dem die Zugriffskontrolle f√ºr Kameras in Python geschrieben ist.  Dies ist eine klassische Aufgabe f√ºr diese Sprache.  Es gibt Benutzer und Kameras, Videos, von denen sie sich ansehen k√∂nnen: Einer sieht einige Kameras, w√§hrend andere eine regul√§re Site sehen. <br><br>  Python wurde gew√§hlt, weil es praktisch ist, einen solchen Dienst darauf zu schreiben: Es gibt schlie√ülich Frameworks, ORMs und Programmierer.  Die entwickelte Software wird verpackt und an Benutzer verkauft.  Erlyvideo.ru ist ein Unternehmen, das Software verkauft und nicht nur Dienstleistungen anbietet. <br><br>  Welche Probleme mit Python m√∂chte ich l√∂sen. <br><br>  <strong>Warum gibt es solche Probleme mit Multicore?</strong>  Wir lie√üen Flussonic auf Stadiencomputern laufen, noch bevor Intel dies tat.  Aber Python hat Schwierigkeiten damit: Warum werden immer noch nicht alle 80 Kerne unserer Server verwendet, um zu funktionieren? <br><br>  <strong>Wie kann man nicht unter offenen Steckdosen leiden?</strong>  Die √úberwachung der Anzahl offener Steckdosen ist ein gro√ües Problem.  Wenn es den Grenzwert erreicht, schlie√üen und verhindern Sie auch Leckagen. <br><br>  <strong>Haben vergessene globale Variablen eine L√∂sung?</strong>  Das Durchsickern globaler Variablen ist die H√∂lle f√ºr jede Garbage Collection-Sprache wie Java oder C #. <br><br>  <strong>Wie kann man Eisen verwenden, ohne Ressourcen zu verschwenden?</strong>  Wie kann man ohne 40 Jung-Arbeiter und 64 GB RAM auskommen, wenn man Server effizient nutzen und nicht hunderttausende Dollar im Monat auf unn√∂tige Hardware werfen will? <br><br><h3>  Warum Multicore ben√∂tigt wird </h3><br>  <strong>Damit alle Kerne voll ausgelastet sind, werden</strong> viel mehr Arbeitskr√§fte ben√∂tigt als Kerne.  Zum Beispiel werden f√ºr 40 Prozessorkerne 100 Arbeiter ben√∂tigt: Ein Arbeiter ging zur Datenbank, der andere ist mit etwas anderem besch√§ftigt. <br><br>  <strong>Ein Arbeiter kann 300-400 MB verbrauchen</strong> .  Wir schreiben dies immer noch in Python und nicht in Ruby on Rails, das ein Vielfaches an RAM verbrauchen kann, und 40 GB werden schnell und einfach verschwendet.  Es ist nicht sehr teuer, aber warum Speicher kaufen, wo Sie nicht kaufen k√∂nnen. <br><br>  <strong>Multi-Core hilft dabei, gemeinsam genutzte Daten zu fummeln und den Speicherverbrauch zu reduzieren</strong> . So k√∂nnen viele unabh√§ngige Prozesse bequem und sicher ausgef√ºhrt werden.  Es ist viel einfacher zu programmieren, aber teurer aus dem Speicher. <br><br><h3>  Socket-Verwaltung </h3><br>  Auf dem Web Socket werden die Laufzeitdaten der Kameras aus dem Backend abgefragt.  Die Python-Software verbindet sich mit Flussonic und fragt die Statusdaten der Kameras ab: Ob sie funktionieren oder nicht, gibt es neue Ereignisse. <br><br>  Auf der anderen Seite stellt der Client eine Verbindung her und wir senden diese Daten √ºber den Web-Socket an den Browser.  Wir m√∂chten Kundendaten in Echtzeit √ºbertragen: Die Kamera wurde ein- und ausgeschaltet, die Katze a√ü, schlief, riss ein Sofa auf, dr√ºckte den Knopf und vertrieb die Katze. <br><br>  Aber zum Beispiel ist ein Problem aufgetreten: Die Datenbank hat nicht auf die Anfrage geantwortet, der gesamte Code ist ausgefallen, es waren zwei Sockets offen.  Wir haben angefangen nachzuladen, haben etwas gemacht, wieder dieses Problem - es gab zwei Steckdosen.  Der DB-Fehler wurde falsch verarbeitet und zwei offene Verbindungen hingen.  Dies f√ºhrt im Laufe der Zeit zu Steckdosenlecks. <br><br><h3>  Vergessene globale Variablen </h3><br>  Erstellte ein globales Diktat f√ºr die Liste der Browser, die √ºber den Web-Socket verbunden sind.  Eine Person meldet sich bei der Site an, wir √∂ffnen f√ºr sie einen Web-Socket.  Dann setzen wir den Web-Socket mit seiner Kennung in eine Art globales Diktat und es stellt sich heraus, dass eine Art Fehler auftritt. <br><br>  Zum Beispiel haben sie eine Verbindungsverkn√ºpfung in dikt aufgezeichnet, um Daten zu senden.  <strong>Eine Ausnahme funktionierte, ich verga√ü den Link zu l√∂schen und die Daten hingen</strong> .  Nach einiger Zeit werden also allm√§hlich 64 GB vermisst, und ich m√∂chte den Arbeitsspeicher auf dem Server verdoppeln.  Dies ist keine L√∂sung, da die Daten ohnehin verloren gehen. <br><blockquote>  Wir machen immer Fehler - wir sind Menschen und k√∂nnen nicht alles im Auge behalten. </blockquote>  Die Frage ist, dass einige Fehler auftreten, auch solche, die wir nicht erwartet hatten. <br><br><h2>  Historischer Ausflug </h2><br>  Um zum Hauptthema zu gelangen, wollen wir uns mit der Geschichte befassen.  √úber alles, wor√ºber wir jetzt √ºber Python, Go und Erlang sprechen, sind andere Leute vor ungef√§hr 30 Jahren diesen ganzen Weg gegangen.  Wir in Python gehen einen langen Weg und f√ºllen die Unebenheiten auf, die bereits vor Jahrzehnten passiert sind.  Der Weg wiederholt sich auf erstaunliche Weise. <br><br><h3>  Dos </h3><br>  Wenden wir uns zun√§chst DOS zu, es ist am n√§chsten.  Vor ihm gab es ganz andere Dinge und nicht jeder ist am Leben, der sich an Computer vor DOS erinnert. <br><br>  <strong>Das DOS-Programm besetzte (fast) ausschlie√ülich den Computer</strong> .  W√§hrend beispielsweise ein Spiel l√§uft, wird nichts anderes ausgef√ºhrt.  Sie werden nicht ins Internet gehen - es ist noch nicht da und Sie werden nicht einmal weiterkommen.  Es war traurig, aber die Erinnerungen daran sind warm, weil es mit der Jugend verbunden ist. <br><br><h3>  Kooperatives Multitasking </h3><br>  Da DOS sehr schmerzhaft war, tauchten neue Herausforderungen auf und Computer wurden leistungsf√§higer.  <strong>Vor Jahrzehnten entwickelten sie das Konzept des kooperativen Multitasking</strong> , noch vor Windows 3.11. <br><br>  <strong>Daten werden durch Prozesse getrennt und jeder Prozess wird separat ausgef√ºhrt:</strong> Sie sind irgendwie voneinander gesch√ºtzt.  Fehlerhafter Code in einem Prozess kann den Code im Browser nicht verderben (dann sind die ersten Browser bereits erschienen). <br><br>  Die n√§chste Frage lautet: Wie wird die Rechenzeit auf verschiedene Prozesse verteilt?  Dann war es nicht so, dass es nicht mehr als einen Kern gab, ein Dual-Prozessor-System war eine Seltenheit.  Das Schema lautete wie folgt: W√§hrend ein Prozess beispielsweise auf eine Festplatte f√ºr Daten ging, erh√§lt der zweite Prozess die Steuerung vom Betriebssystem.  Der erste wird in der Lage sein, die Kontrolle zu erlangen, wenn der zweite freiwillig selbst gibt.  Ich vereinfache die Situation sehr, aber der <strong>Prozess erlaubte es irgendwie freiwillig, ihn vom Prozessor zu entfernen</strong> . <br><br><h3>  Pr√§ventives Multitasking </h3><br>  Kooperatives Multitasking f√ºhrte zu folgendem Problem: Der Prozess konnte einfach h√§ngen bleiben, weil er schlecht geschrieben war.  <strong>Wenn die Verarbeitung des Prozessors lange dauert, blockiert er den Rest</strong> .  In diesem Fall st√ºrzte der Computer ab und es konnte nichts getan werden, zum Beispiel das Fenster zu wechseln. <br><br>  In Reaktion auf dieses Problem wurde pr√§emptives Multitasking erfunden.  Das Betriebssystem selbst steuert jetzt streng: Entfernt Prozesse aus der Ausf√ºhrung, trennt ihre Daten vollst√§ndig, sch√ºtzt den Prozessspeicher voneinander und gibt jedem eine gewisse Rechenzeit.  <strong>Das Betriebssystem weist jedem Prozess die gleichen Zeitintervalle zu</strong> . <br><br>  Das Thema Zeitplanung ist noch offen.  Noch heute √ºberlegen sich die OS-Entwickler, was in welcher Reihenfolge, an wen und wie viel Zeit sie f√ºr das Management geben sollen.  Heute sehen wir die Entwicklung dieser Ideen. <br><br><h3>  Streams </h3><br>  Das war aber nicht genug.  Prozesse m√ºssen Daten austauschen: √úber das Netzwerk ist teuer, irgendwie immer noch kompliziert.  Daher wurde das <strong>Konzept der Str√∂mungen</strong> erfunden. <br><blockquote>  Threads sind einfache Prozesse, die einen gemeinsamen Speicher haben. <br></blockquote>  Streams wurden mit der Hoffnung erstellt, dass alles leicht, einfach und unterhaltsam sein wird.  Jetzt wird <strong>Multithread-Programmierung als Antipattern betrachtet</strong> .  Wenn die Gesch√§ftslogik in Threads geschrieben ist, sollte dieser Code h√∂chstwahrscheinlich weggeworfen werden, da er wahrscheinlich Fehler enth√§lt.  Wenn Sie den Eindruck haben, dass keine Fehler vorliegen, haben Sie sie einfach noch nicht gefunden. <br><br>  Multithread-Programmierung ist eine √§u√üerst komplexe Sache.  Es gibt nur wenige Leute, die sich wirklich der F√§higkeit verschrieben haben, √ºber Themen zu schreiben, und die etwas wirklich zum Laufen bringen. <br><br>  In der Zwischenzeit erschienen <strong>Mehrkerncomputer</strong> .  Sie brachten schreckliche Dinge mit.  Die Herangehensweise an die Daten war v√∂llig anders. Es stellten sich Fragen nach der Lokalit√§t der Daten. Jetzt m√ºssen Sie verstehen, von welchem ‚Äã‚ÄãKernel aus Sie zu welchen Daten wechseln. <br><br>  Ein Kern muss die Daten hier und der andere dort ablegen und diese Dinge auf keinen Fall verwirren, da Cluster tats√§chlich im Computer vorhanden sind.  In einem modernen Computer befindet sich ein Cluster, wenn ein Teil des Speichers mit einem Kern und der andere mit einem anderen Kern verl√∂tet ist.  Die Laufzeit zwischen diesen Daten kann um Gr√∂√üenordnungen variieren. <br><br><h2>  Python-Beispiele </h2><br>  Betrachten Sie ein einfaches Beispiel f√ºr ‚ÄûService, der dem K√§ufer hilft.  Er w√§hlt auf mehreren Plattformen den besten Preis f√ºr die Ware aus: Wir fahren im Namen der Ware und suchen Handelspl√§tze mit einem Mindestpreis. <br><br>  Dies ist der Code im alten Django, Python 2. Heute ist er nicht sehr beliebt, nur wenige Leute starten Projekte darauf. <br><br><pre><code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@api_view(['GET']) def best_price(request): name = request.GET['name'] price1 = http_fetch_price('market.yandex.ru', name) price2 = http_fetch_price('ebay.com', name) price3 = http_fetch_price('taobao.com', name) return Response(min([price1,price2,price3]))</span></span></code> </pre> <br>  Wenn eine Anfrage eingeht, gehen wir zu einem Backend und dann zu einem anderen.  An Stellen, an denen <code>http_fetch_price</code> , werden Threads blockiert.  In diesem Moment begibt sich der ganze Arbeiter auf eine Reise zu Yandex.Market, dann zu eBay, dann bis zu einem Timeout auf Taobao und gibt am Ende eine Antwort.  <strong>Die ganze Zeit steht der ganze Arbeiter</strong> . <br><br>  Es ist sehr schwierig, mehrere Backends gleichzeitig abzufragen.  Dies ist eine schlimme Situation: Es wird Speicher verbraucht, eine gro√üe Anzahl von Mitarbeitern muss gestartet und der gesamte Dienst √ºberwacht werden.  Es ist notwendig zu pr√ºfen, wie h√§ufig solche Anfragen sind, m√ºssen Sie noch Mitarbeiter entlassen oder gibt es noch zus√§tzliche.  Das sind genau die Probleme, von denen ich gesprochen habe.  <strong>Es m√ºssen nacheinander mehrere Backends abgefragt werden</strong> . <br><br>  Was sehen wir in Python?  <strong>Ein Prozess pro Task,</strong> in Python gibt es noch keinen Multicore.  Die Situation ist klar: In Sprachen dieser Klasse ist es schwierig, ein sicheres einfaches Multicore zu erstellen, da es <strong>die Leistung beeintr√§chtigt</strong> . <br><br>  Wenn Sie von verschiedenen Threads zum Diktat wechseln, kann der Zugriff auf die Daten folgenderma√üen geschrieben werden: Kleben Sie zwei Python-Instanzen in den Speicher, damit sie die Daten durchsuchen - sie brechen sie einfach.  Um zum Beispiel zu diktieren und nichts zu zerbrechen, m√ºssen Sie Mutexe davor setzen.  Wenn es vor jedem Diktat einen Mutex gibt, wird das System ungef√§hr 1000-mal langsamer - es ist einfach unpraktisch.  Es ist schwierig, es in einen Multicore zu ziehen. <br><br>  Wir haben <strong>nur einen Thread der Ausf√ºhrung</strong> und <strong>nur Prozesse k√∂nnen skalieren</strong> .  Tats√§chlich haben wir DOS innerhalb des Prozesses neu erfunden - die Skriptsprache von 2010.  Innerhalb des Prozesses gibt es etwas, das DOS √§hnelt: W√§hrend wir etwas tun, funktionieren alle anderen Prozesse nicht.  Niemand mochte die enormen Kosten√ºberschreitungen und die langsame Reaktion. <br><br>  <b>Sockelreaktoren sind</b> vor einiger Zeit in Python erschienen, obwohl das Konzept selbst schon vor langer Zeit geboren wurde.  Jetzt k√∂nnen Sie die Bereitschaft mehrerer Steckdosen gleichzeitig erwarten. <br><br>  Zun√§chst wurde der Reaktor auf Servern wie Nginx gefragt.  Auch durch den richtigen Einsatz dieser Technologie ist sie popul√§r geworden.  Dann kroch das Konzept in Skriptsprachen wie Python und Ruby. <br><blockquote>  Die Idee des Reaktors ist, dass wir zur ereignisorientierten Programmierung √ºbergegangen sind. </blockquote><br><h2>  Ereignisorientierte Programmierung </h2><br>  Ein Ausf√ºhrungskontext erzeugt eine Anfrage.  W√§hrend auf eine Antwort gewartet wird, wird ein anderer Kontext ausgef√ºhrt.  Es ist bemerkenswert, dass wir fast dieselbe Entwicklungsstufe durchlaufen haben wie der √úbergang von DOS zu Windows 3.11.  Nur Menschen taten dies vor 20 Jahren und in Python und Ruby erschien es vor 10 Jahren. <br><br><h3>  Verdreht </h3><br>  Dies ist ein ereignisgesteuertes Netzwerk-Framework.  Es erschien im Jahr 2002 und ist in Python geschrieben.  Ich nahm das obige Beispiel und schrieb es auf Twisted um. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">render_GET</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, request)</span></span></span><span class="hljs-function">:</span></span> price1 = deferred_fetch_price(<span class="hljs-string"><span class="hljs-string">'market.yandex.ru'</span></span>, name) price2 = deferred_fetch_price(<span class="hljs-string"><span class="hljs-string">'ebay.com'</span></span>, name) price3 = deferred_fetch_price(<span class="hljs-string"><span class="hljs-string">'taobao.com'</span></span>, name) dl = defer.DeferredList([price1,price2,price3]) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(prices)</span></span></span><span class="hljs-function">:</span></span> request.write(<span class="hljs-string"><span class="hljs-string">'%d'</span></span>.format(min(prices))) request.finish() dl.addCallback(reply) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> server.NOT_DONE_YET</code> </pre> <br>  Es kann zu Fehlern und Ungenauigkeiten kommen, und die notorische Fehlerbehandlung reicht nicht aus.  Das ungef√§hre Schema lautet jedoch wie folgt: Wir stellen keine Anfrage, bitten Sie jedoch, diese Anfrage zu einem sp√§teren Zeitpunkt zu bearbeiten, wenn noch Zeit ist.  In der Zeile mit <code>defer.DeferredList</code> wollen wir die Antworten aus mehreren Abfragen zusammenfassen. <br><br>  Tats√§chlich besteht der Code aus zwei Teilen.  Im ersten Teil, was vor der Anfrage passiert ist, und im zweiten, was danach war. <br><blockquote>  Die gesamte Geschichte der ereignisorientierten Programmierung ist ges√§ttigt von dem Schmerz, den linearen Code ‚Äûvor der Anforderung‚Äú und ‚Äûnach der Anforderung‚Äú zu brechen. </blockquote>  Dies tut weh, weil die Codeteile gemischt sind: Die letzten Zeilen werden noch in der urspr√ºnglichen Anforderung ausgef√ºhrt, und die <code>reply</code> wird aufgerufen. <br><br>  Es ist nicht leicht, genau zu bedenken, weil wir den linearen Code gebrochen haben, aber es musste getan werden.  Ohne ins Detail zu gehen, wird der Code, der von Django zu Twisted umgeschrieben wurde <strong>, eine unglaubliche Pseudobeschleunigung erzeugen</strong> . <br><br><h3>  Idee verdreht </h3><blockquote>  Ein Objekt kann aktiviert werden, wenn der Socket bereit ist. </blockquote>  Wir nehmen Objekte, in denen wir die notwendigen Daten sammeln, aus dem Kontext und binden deren Aktivierung an den Socket.  Die Verf√ºgbarkeit von Sockets ist jetzt eine der wichtigsten Kontrollen f√ºr das gesamte System.  Objekte werden unsere Kontexte sein. <br><br>  Gleichzeitig trennt die Sprache immer noch den Begriff des Ausf√ºhrungskontexts, in dem Ausnahmen leben.  <strong>Der Ausf√ºhrungskontext lebt getrennt von Objekten und ist lose mit diesen verbunden</strong> .  Hier ergibt sich das Problem, dass wir versuchen, Daten in Objekten zu sammeln: Es gibt keinen Weg ohne sie, aber die Sprache unterst√ºtzt sie nicht. <br><br>  All dies f√ºhrt zu einer klassischen Callback-H√∂lle.  Wof√ºr sie beispielsweise Node.js lieben - bis vor kurzem gab es √ºberhaupt keine anderen Methoden, aber es erschien immer noch in Python.  Das Problem besteht darin, dass <strong>an den Punkten der externen E / A Code-Unterbrechungen auftreten</strong> , die zu einem R√ºckruf f√ºhren. <br><br>  Es gibt viele Fragen.  Ist es m√∂glich, die Kanten der L√ºcke im Code zu "kleben"?  Ist es m√∂glich, zum normalen menschlichen Code zur√ºckzukehren?  Was tun, wenn ein logisches Objekt mit zwei Sockets arbeitet und einer davon geschlossen ist?  Wie man nicht vergisst, die Sekunde zu schlie√üen?  Kann man irgendwie alle Kerne nutzen? <br><br><h3>  Async io </h3><br>  Eine gute Antwort auf diese Fragen ist Async IO.  Dies ist ein steiler, wenn auch kein einfacher Schritt nach vorne.  Async IO ist eine komplizierte Sache, unter deren Haube es viele schmerzhafte Nuancen gibt. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">best_price</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(request)</span></span></span><span class="hljs-function">:</span></span> name = request.GET[<span class="hljs-string"><span class="hljs-string">'name'</span></span>] price1 = async_http_fetch_price(<span class="hljs-string"><span class="hljs-string">'market.yandex.ru'</span></span>, name) price2 = async_http_fetch_price(<span class="hljs-string"><span class="hljs-string">'ebay.com'</span></span>, name) price3 = async_http_fetch_price(<span class="hljs-string"><span class="hljs-string">'taobao.com'</span></span>, name) prices = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.wait([price1,price2,price3]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> min(prices)</code> </pre> <br>  Die Codel√ºcke wird unter der Syntax <code>async/await</code> ausgeblendet.  Wir haben alles genommen, was vorher war, sind aber in diesem Code nicht zum Netzwerk gegangen.  Wir haben <code>Callback(reply)</code> aus dem vorherigen Beispiel entfernt und es hinter <code>await</code> versteckt - der Stelle, an der der Code mit einer Schere abgeschnitten wird.  Es wird in zwei Teile unterteilt: den aufrufenden Teil und den R√ºckrufteil, der die Ergebnisse verarbeitet. <br><br>  Dies ist ein <strong>gro√üartiger syntaktischer Zucker</strong> .  Es gibt Methoden, um mehrere Erwartungen in eine zu bringen.  Das ist cool, aber es gibt eine Nuance: <strong>Alles kann durch eine "klassische" Steckdose zerbrochen werden</strong> .  In Python gibt es immer noch eine gro√üe Anzahl von Bibliotheken, die synchron zum Socket gehen, eine <code>timer library</code> und alles f√ºr Sie ruinieren.  Wie das zu debuggen ist, wei√ü ich nicht. <br><br>  Aber <strong>Asyncio hilft nicht bei Lecks und Multicore</strong> .  Daher gibt es keine grundlegenden √Ñnderungen, obwohl es besser geworden ist. <br><br>  Wir haben immer noch alle Probleme, √ºber die wir am Anfang gesprochen haben: <br><br><ul><li>  leicht mit Steckdosen zu lecken; </li><li>  leicht zu belassende Links in globalen Variablen; </li><li>  sehr sorgf√§ltige Fehlerbehandlung; </li><li>  Es ist immer noch schwer, Multi-Core zu machen. </li></ul><br><h3>  Was zu tun ist </h3><br>  Ob sich dies alles entwickeln wird, wei√ü ich nicht, aber ich werde die Implementierung in anderen Sprachen und Plattformen zeigen. <br><br>  <strong>Isolierte Ausf√ºhrungskontexte.</strong>  In Ausf√ºhrungskontexten werden Ergebnisse akkumuliert, Sockets gespeichert: logische Objekte, in denen normalerweise alle Daten zu R√ºckrufen und Sockets gespeichert werden.  Ein Konzept: Nehmen Sie Ausf√ºhrungskontexte, kleben Sie sie an Ausf√ºhrungsf√§den und isolieren Sie sie vollst√§ndig voneinander. <br><br>  <strong>Paradigmenwechsel von Objekten.</strong>  Verbinden wir den Kontext mit dem Thread der Ausf√ºhrung.  Es gibt Analoga, das ist nichts Neues.  Wenn jemand versucht hat, den Apache-Quellcode zu bearbeiten und Module darauf zu schreiben, wei√ü er, dass es einen Apache-Pool gibt.  <strong>Keine Links</strong> zwischen Apache-Pools <strong>erlaubt</strong> .  Daten aus einem Apache-Pool - der mit Anforderungen verkn√ºpfte Pool befindet sich darin, und Sie k√∂nnen nichts daraus abrufen. <br><br>  Theoretisch ist es m√∂glich, aber wenn Sie dies tun, wird entweder jemand schimpfen, oder er wird den Patch nicht akzeptieren, oder er wird ein langes und schmerzhaftes Debugging in der Produktion durchf√ºhren.  Danach wird niemand mehr das tun und es anderen erlauben, solche Dinge zu tun.  Es ist einfach nicht mehr m√∂glich, auf Daten zwischen Kontexten zu verweisen, eine vollst√§ndige Isolierung ist erforderlich. <br><br>  Wie tausche ich meine Aktivit√§ten aus?  Was ben√∂tigt wird, sind keine kleinen Monaden, die in sich geschlossen sind und nicht miteinander kommunizieren.  Wir brauchen sie, um zu kommunizieren.  Ein Ansatz ist das Versenden von Nachrichten.  Dies ist ungef√§hr der Weg, den Windows beim Austausch von Nachrichten zwischen Prozessen eingeschlagen hat.  Unter normalen Betriebssystemen k√∂nnen Sie keine Verkn√ºpfung zum Speicher eines anderen Prozesses herstellen, aber Sie k√∂nnen wie unter UNIX √ºber das Netzwerk oder wie unter Windows √ºber Nachrichten signalisieren. <br><br>  <strong>Alle Ressourcen innerhalb des Prozesses und des Kontexts werden zu einem Thread der Ausf√ºhrung</strong> .  Wir haben zusammengeklebt: <br><br><ul><li>  Laufzeitdaten in einer virtuellen Maschine, in der Ausnahmen auftreten; </li><li>  der Thread der Ausf√ºhrung, wie das, was auf dem Prozessor ausgef√ºhrt wird; </li><li>  Ein Objekt, in dem alle Daten logisch gesammelt werden. </li></ul><br>  Herzlichen Gl√ºckwunsch - wir haben UNIX in einer Programmiersprache erfunden!  Diese Idee wurde um 1969 erfunden.  Bisher ist es noch nicht in Python, aber Python wird wahrscheinlich dazu kommen.  Und vielleicht kommt sie nicht - ich wei√ü es nicht. <br><br><h3>  Was gibt es </h3><br>  Zuallererst die <strong>automatische Kontrolle √ºber Ressourcen</strong> .  Bei Moscow Python Conf ++ 2019 wurde <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gesagt,</a> dass Sie ein Programm auf Go schreiben und alle Fehler verarbeiten k√∂nnen.  Das Programm wird wie angegossen aussehen und monatelang funktionieren.  Dies ist wahr, aber wir behandeln nicht alle Fehler. <br><br>  Wir sind lebendige Menschen, wir haben immer Fristen, den Wunsch, etwas N√ºtzliches zu tun und den 535. Fehler f√ºr heute nicht zu bew√§ltigen.  Code, der mit Fehlerbehandlung √ºbers√§t ist, ruft bei niemandem ein warmes Gef√ºhl hervor. <br><br>  Deshalb schreiben wir alle ‚Äûhappy path‚Äú, und dann werden wir es bei der Produktion herausfinden.  Seien wir ehrlich: Nur wenn Sie etwas verarbeiten m√ºssen, beginnen wir mit der Verarbeitung.  Defensive Programmierung ist etwas anders und keine kommerzielle Entwicklung. <br><br>  <strong>Wenn wir also eine automatische Fehler√ºberwachung haben, ist dies in Ordnung</strong> .  Aber die Betriebssysteme haben es vor 50 Jahren erfunden: Wenn ein Prozess abstirbt, wird alles, was er √∂ffnet, automatisch geschlossen.  Heutzutage muss niemand mehr Code schreiben, der die Dateien hinter dem get√∂teten Prozess bereinigt.  Dies gibt es in keinem Betriebssystem seit 50 Jahren, aber in Python m√ºssen Sie dies immer noch sorgf√§ltig und sorgf√§ltig mit Ihren H√§nden verfolgen.  Es ist seltsam. <br><br>  <strong>Sie k√∂nnen Heavy Computing in einen anderen Kontext bringen</strong> , aber es kann bereits zu einem anderen Kern gehen.  Wir haben die Daten geteilt, wir brauchen keine Mutexe mehr.  Sie k√∂nnen die Daten in einem anderen Kontext senden und sagen: "Sie werden es irgendwo tun und mich dann dar√ºber informieren, dass Sie fertig sind und etwas getan haben." <br><br>  <strong>Eine asynchrone Implementierung ohne die Worte "async / await"</strong> .  Weiter eine kleine Hilfe von der virtuellen Maschine, von der Laufzeit.  Dies ist, wor√ºber wir mit <code>async/await</code> : Sie k√∂nnen auch in Nachrichten konvertieren, <code>async/await</code> entfernen und auf der Ebene der virtuellen Maschine abrufen. <br><br><h2>  Erlang-Prozesse </h2><br>  Erlang wurde vor 30 Jahren erfunden.  Die b√§rtigen Jungs, die damals nicht sehr b√§rtig waren, sahen sich UNIX an und √ºbertrugen alle Konzepte in die Programmiersprache.  Sie beschlossen, dass sie jetzt ihr eigenes Ding haben w√ºrden, um nachts zu schlafen und leise ohne Computer fischen zu gehen.  Damals gab es noch keine Laptops, aber die B√§rtigen wussten bereits, dass dies im Voraus √ºberlegt werden sollte. <br><br>  <strong>Wir haben Erlang (Elixier) - aktive Kontexte, die sich selbst ausf√ºhren</strong> .  Weiter mein Beispiel zu Erlang.  Auf Elixir sieht es mit einigen Variationen ungef√§hr gleich aus. <br><br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">best_price</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Name)</span></span></span><span class="hljs-function"> -&gt;</span></span> Price1 = spawn_price_fetcher('market.yandex.ru', Name), Price2 = spawn_price_fetcher('ebay.com', Name), Price3 = spawn_price_fetcher('taobao.com', Name), lists:min(wait4([Price1,Price2,Price3])).</code> </pre> <br>  Wir starten mehrere Abholer - dies sind verschiedene neue Kontexte, auf die wir warten.  Sie warteten, sammelten die Daten und gaben das Ergebnis als Mindestpreis zur√ºck.  All dies ist √§hnlich wie <code>async/await</code> , jedoch ohne die Worte "async / await". <br><br><h3>  Eigenschaften von Elixir </h3><br>  Elixir befindet sich an der Basis von Erlang und alle Sprachkonzepte sind leise auf Elixir portiert.  Was sind seine Merkmale? <br><br>  <strong>Verbot von prozessor√ºbergreifenden Links.</strong>  Mit Prozess meine ich einen einfachen Prozess innerhalb einer virtuellen Maschine - Kontext.  Vereinfacht gesagt, sind Datenverkn√ºpfungen innerhalb eines anderen Objekts in Erlang verboten, wenn sie nach Python portiert wurden.  Sie k√∂nnen eine Verkn√ºpfung zum gesamten Objekt als geschlossenes Feld haben, aber Sie k√∂nnen nicht auf die darin enthaltenen Daten verweisen.  Sie k√∂nnen nicht einmal syntaktisch einen Zeiger auf Daten abrufen, die sich in einem anderen Objekt befinden.  Sie k√∂nnen nur √ºber das Objekt selbst wissen. <br><br>  <strong>Innerhalb von Prozessen (Objekten) gibt es keine Mutexe.</strong>  Das ist wichtig - ich pers√∂nlich m√∂chte nie in meinem Leben mit der Geschichte des Debuggens von Multithread-Fl√ºgen zur Produktion in Ber√ºhrung kommen.  Das w√ºnsche ich niemandem. <br><br>  <strong>Prozesse k√∂nnen sich um die Kerne bewegen, es ist sicher.</strong>  Wir m√ºssen nicht mehr wie in Java eine Reihe anderer <code>pointer</code> umgehen und neu schreiben, wenn wir Daten von einem Ort an einen anderen verschieben: Wir haben keine gemeinsamen Daten und internen Links.  Woher kommt beispielsweise das Problem der H√ºftschw√§che?  Aufgrund der Tatsache, dass jemand auf diese Daten verweist. <br><br>  Wenn wir Daten innerhalb des Heaps zur Komprimierung an einen anderen Speicherort √ºbertragen, m√ºssen wir das gesamte System durchlaufen.  Es kann Dutzende von Gigabyte belegen und alle Zeiger aktualisieren - das ist verr√ºckt. <br><br>  <strong>Volle Thread-Sicherheit</strong> , da die gesamte Kommunikation √ºber Nachrichten erfolgt.  Nach alledem kam es zu einem <strong>Verdr√§ngungsprozess</strong> .  Er hat es einfach und billig. <br><br>  <strong>Nachrichten als Basis der Kommunikation.</strong>  Innerhalb von Objekten, normalen Funktionsaufrufen und zwischen Nachrichtenobjekten.  Das Eintreffen von Daten aus dem Netzwerk ist eine Nachricht, die Antwort eines anderen Objekts ist eine Nachricht, etwas anderes au√üerhalb ist ebenfalls eine Nachricht in einer eingehenden Warteschlange.  Dies ist unter UNIX nicht m√∂glich, da es keine Wurzel hat. <br><br>  <strong>Methodenaufrufe.</strong>  Wir haben Objekte, die wir Prozesse nennen.  Methoden zu Prozessen werden √ºber Nachrichten aufgerufen. <br><br>  <strong>Beim Aufrufen von Methoden wird auch eine Nachricht gesendet.</strong>  Es ist toll, dass es jetzt mit einer Auszeit getan werden kann.  Wenn uns etwas langsam antwortet, rufen wir die Methode f√ºr ein anderes Objekt auf.  Gleichzeitig sagen wir aber, dass wir bereit sind, nicht l√§nger als 60 Sekunden zu warten, weil ich einen Kunden mit einem Timeout von 70 Sekunden habe.  Ich muss ihm "503" sagen - komm morgen, jetzt warten sie nicht auf dich. <br><br>  Dar√ºber hinaus kann die <strong>Beantwortung des Anrufs verschoben werden</strong> .  Innerhalb des Objekts k√∂nnen Sie die Aufforderung zum Aufrufen der Methode annehmen und sagen: "Ja, ja, ich werde Sie jetzt entlassen, kommen Sie in einer halben Stunde zur√ºck, ich werde Ihnen antworten."  Sie k√∂nnen nicht sprechen, aber still beiseite legen.  Wir benutzen es manchmal. <br><br><h3>  Wie arbeite ich mit einem Netzwerk? </h3><br>  Sie k√∂nnen linearen Code, R√ºckrufe oder im Stil von <code>asyncio.gather</code> .  Ein Beispiel, wie das aussehen wird. <br><br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wait4</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([ ])</span></span></span><span class="hljs-function"> -&gt;</span></span> [ ]; wait4(List) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">receive</span></span> {reply, Pid, Price} -&gt; [Price] ++ wait4(List -- [Pid]) <span class="hljs-keyword"><span class="hljs-keyword">after</span></span> <span class="hljs-number"><span class="hljs-number">60000</span></span> -&gt; [] <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>.</code> </pre> <br>  In der Funktion <code>wait4</code> aus dem vorherigen Beispiel <code>wait4</code> wir die Liste der Personen, von denen wir noch auf Antworten warten.  Wenn wir mit der <code>receive</code> eine Nachricht von diesem Prozess erhalten, schreiben wir sie in die Liste.  Wenn die Liste vorbei ist, geben wir alles zur√ºck, was war, und akkumulieren die Liste.  Wir haben gleichzeitig drei Objekte gebeten, uns die Daten zu fahren.  Wenn sie es nicht in 60 Sekunden zusammen geschafft haben und mindestens einer von ihnen nicht mit OK geantwortet hat, haben wir eine leere Liste.  Es ist jedoch wichtig, dass wir eine allgemeine Zeit√ºberschreitung f√ºr eine sofortige Anfrage an eine ganze Reihe von Objekten festlegen. <br><br>  Jemand k√∂nnte sagen: "Denken Sie, libcurl hat das gleiche."  Hierbei ist es jedoch wichtig, dass es nicht nur eine HTTP-Ausl√∂sung, sondern auch eine DB-Ausl√∂sung sowie einige Berechnungen geben kann, beispielsweise die Berechnung einer optimalen Anzahl f√ºr den Client. <br><br><h3>  Fehlerbehandlung </h3><br>  <strong>Vom Stream sind Fehler an das Objekt √ºbergeben worden, die jetzt ein und dasselbe sind</strong> .  Jetzt wird der Fehler selbst nicht an den Thread, sondern an das Objekt angeh√§ngt, an dem er ausgef√ºhrt wurde. <br><br>  Das ist viel logischer.  Wenn wir alle m√∂glichen kleinen Quadrate und Kreise an die Tafel zeichnen, in der Hoffnung, dass sie zum Leben erweckt werden und uns Ergebnisse und Geld bringen, zeichnen wir normalerweise Objekte, nicht die Fl√ºsse, in denen diese Objekte ausgef√ºhrt werden.  Beispielsweise k√∂nnen wir bei Lieferung eine automatische <strong>Nachricht √ºber den Tod eines anderen Objekts erhalten</strong> . <br><br><h3>  Introspection oder Debugging in der Produktion </h3><br>  Was gibt es Sch√∂neres, als zur Kasse zu gehen und zu belasten, besonders wenn der Fehler nur unter Last w√§hrend der Sto√üzeiten auftritt.  Zur Hauptverkehrszeit sagen wir: <br><br>  <em>- Komm schon, ich werde jetzt neu starten!</em> <br>  <em>- Gehen Sie aus der T√ºr und es gibt einen Neustart bei jemand anderem!</em> <br><br>  Hier k√∂nnen wir ein lebendes System betreten, das gerade l√§uft und nicht speziell darauf vorbereitet ist.  Dazu m√ºssen Sie es nicht mit dem Profiler neu starten, mit dem Debugger neu erstellen. <br><br>  <strong>Ohne Performance-Einbu√üen in einem Live-Produktionssystem k√∂nnen</strong> wir uns eine Liste von Prozessen ansehen: Was ist in ihnen, wie funktioniert das alles?  All dies ist kostenlos aus der Box. <br><br><h3>  Boni </h3><br>  <strong>Der Code ist super zuverl√§ssig.</strong>  Zum Beispiel ist Python anf√§llig f√ºr <code>old vs async</code> und wird es nicht weniger als f√ºnf Jahre lang bleiben.  Angesichts der Geschwindigkeit, mit der Python 3 implementiert wurde, sollten Sie nicht hoffen, dass es schnell sein wird. <br><br>  <strong>Das Lesen und Verfolgen von Nachrichten ist einfacher als das Debuggen von R√ºckrufen</strong> .  Es ist wichtig.  Es scheint, als h√§tten wir immer noch R√ºckrufe f√ºr die Verarbeitung von Nachrichten, die wir sehen k√∂nnen. Was ist dann besser?  Durch die Tatsache, dass Nachrichten ein St√ºck Daten im Speicher sind.  Sie k√∂nnen es mit Augen sehen und verstehen, was hierher gekommen ist.  Es kann zum Tracer hinzugef√ºgt werden, um eine Liste der Nachrichten in einer Textdatei abzurufen.  Dies ist bequemer als R√ºckrufe. <br><br>  <strong>Wundersch√∂nes Multi-Core-</strong> Speichermanagement und <strong>Introspection in einem Live-</strong> Produktionssystem. <br><br><h3>  Die Probleme </h3><br>  Nat√ºrlich hat Erlang auch Probleme. <br><br>  <strong>Verlust der maximalen Leistung</strong> durch die Tatsache, dass wir uns nicht mehr auf Daten in einem anderen Prozess oder Objekt beziehen k√∂nnen.  Wir m√ºssen sie bewegen, aber das ist nicht kostenlos. <br><br>  <strong>Der Aufwand f√ºr das Kopieren von Daten zwischen Prozessen.</strong>  Wir k√∂nnen ein Programm in C schreiben, das auf allen 80 Kernen l√§uft und ein Datenarray verarbeitet, und wir gehen davon aus, dass es es korrekt und korrekt ausf√ºhrt.  In Erlang ist dies nicht m√∂glich: Sie m√ºssen die Daten sorgf√§ltig ausschneiden, auf eine Reihe von Prozessen verteilen und alles im Auge behalten.  Diese Kommunikation kostet Ressourcen - Prozessorzyklen. <br><br>  <strong>Wie schnell oder langsam ist es?</strong>  Wir schreiben seit 10 Jahren Erlang-Code.  Der einzige Konkurrent, der diese 10 Jahre √ºberlebt hat, ist in Java geschrieben.  Mit ihm haben wir fast vollst√§ndige Leistungsgleichheit: Jemand sagt, dass wir schlechter sind, jemand, der sie sind.  Aber sie haben Java mit all seinen Problemen, angefangen mit JIT. <br><br>  Wir schreiben ein Programm, das Zehntausende von Sockets bedient und Dutzende von GB Daten durch sich selbst pumpt.  Pl√∂tzlich stellt sich heraus, dass in diesem Fall die <strong>Richtigkeit der Algorithmen und die F√§higkeit, all dies in der Produktion zu debuggen, wichtiger ist als potenzielle Java-Buns</strong> .  Milliarden von Dollar wurden investiert, aber dies bringt dem Java JIT keine magischen Vorteile. <br><br>  Aber wenn wir dumme und sinnlose Benchmarks messen wollen, wie "Fibonacci-Zahlen berechnen", dann wird Erlang hier wahrscheinlich noch schlechter sein als Python oder vergleichbar. <br><br>  <strong>Der Overhead der Nachrichtenzuordnung.</strong>  Manchmal tut es weh.  Zum Beispiel haben wir einige Teile in C im Code, und an diesen Stellen funktionierte es √ºberhaupt nicht mit Erlang.     ,      ,   . <br><br>    Erlang <strong>     </strong> ,   ,     .  ,    ,   <code>receive</code>  <code>send receive</code> .     ‚Äî   ,   .   <strong> ,   ,    </strong> . <br><br><h2>      Python </h2><br> <strong>   </strong> .        .       ,       Python  -     . <br><br> ,  <strong>   </strong> .  -     Python,      ,    20 ,   40. <br><br> , <strong>   </strong>  . - , ,     Elixir,   ,      . <br><br><blockquote>       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Moscow Python Conf++</a> . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a>  ,         6      4   .  ,   ,  )     ) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a>  . Call for Papers   13 ,     27 . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de476112/">https://habr.com/ru/post/de476112/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de476102/index.html">Schreiben Sie sicheres Arbeiten mit PHP-Arrays</a></li>
<li><a href="../de476104/index.html">Verwenden Sie kein freies MTProxy und keine anderen Arten von freien Proxys ...</a></li>
<li><a href="../de476106/index.html">"Cryptosystems Protocols": Diffie - Hellman, El-Gamal, MTI / A (0), STS</a></li>
<li><a href="../de476108/index.html">Ver√§nderliches Gehirn</a></li>
<li><a href="../de476110/index.html">Warum braucht die IT eine pers√∂nliche Marke?</a></li>
<li><a href="../de476114/index.html">Was w√§re wenn ohne Python? Julia f√ºr maschinelles Lernen und allgemein</a></li>
<li><a href="../de476118/index.html">Zeichne einen Havel-Ring aus Dark Souls 3</a></li>
<li><a href="../de476122/index.html">"H√∂re" den Kosmos: von der dunklen Materie zum Kometen Churyumov - Gerasimenko</a></li>
<li><a href="../de476126/index.html">So testen Sie die Serverleistung: Eine Auswahl verschiedener Open Source-Benchmarks</a></li>
<li><a href="../de476128/index.html">Ivan Osipov und Yuri Artamonov √ºber Kotlin und Plugins f√ºr IntelliJ IDEA beim Treffen von jug.msk.ru</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>