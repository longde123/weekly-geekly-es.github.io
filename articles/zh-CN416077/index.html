<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧑🏽‍🤝‍🧑🏻 👩‍👩‍👧 🚴🏽 PlantUML-业务分析师在软件文档中创建图表所需的一切 👿 😓 👴</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="引言 


 我是系统分析师，我的工作是设计自动化信息系统。 但是，不是，它是写文档。 我第三次不再重复“写”这个词，毕竟不是“伊利亚特”。 但是无聊的形式肯定使项目文档与古希腊诗紧密相关，尤其是在与国家客户打交道时。 


 在这片文字的海洋中，图表是一种创造力。 图表将在本文中讨论。 从我的角度...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>PlantUML-业务分析师在软件文档中创建图表所需的一切</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/416077/"><img src="https://habrastorage.org/webt/nz/gb/ud/nzgbudu_22o0w9-ls4ylmkvp1f0.png"><br><h2 id="vvedenie"> 引言 </h2><br><p> 我是系统分析师，我的工作是设计自动化信息系统。 但是，不是，它是写文档。 我第三次不再重复“写”这个词，毕竟不是“伊利亚特”。 但是无聊的形式肯定使项目文档与古希腊诗紧密相关，尤其是在与国家客户打交道时。 </p><br><p> 在这片文字的海洋中，图表是一种创造力。 图表将在本文中讨论。 从我的角度来看，更确切地说，关于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PlantUML</a> ，这是目前创建它们的最合适的工具。 </p><a name="habracut"></a><br><p> 我敢肯定，至少有很多人听说过PlantUML，至少在GitHub上有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">超过1000颗星</a> 。 该工具的含义非常简单，它仅允许您以描述元素和元素之间关系的文本形式指定图表（大部分使用UML表示法）。 图形视图将自动创建。 以下是活动图表示例。 </p><br><pre><code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">start</span></span> :   ; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (?) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> () :  ; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (?) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> () <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> () :  ; endif :  ////; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> () stop endif stop</code> </pre> <br><img src="https://habrastorage.org/webt/3c/hl/qx/3chlqxczkrvds4uohev8c5etxqa.png"><br><p> 尽管很受欢迎，但是关于Habré的文章很少涉及该工具的实际应用。 在我看来，PlantUML不应该受到如此关注。 </p><br><p> 首先，我将告诉您为什么选择它作为可视化建模的主要工具，最后，我将给出许多建议，当我开始使用此工具时，我本人会很想听听他们的建议。 </p><br><h2 id="pochemu-plantuml"> 为什么选择PlantUML </h2><br><p> 从我的角度来看，在创建图表时，应将重点放在以下标准上：（1）图表应该变小或更少；（2）图表应该使用或多或少的标准符号；（3）从管理项目文档的角度来看，图表应该或多或少地方便。 </p><br><p> 在这三种情况下，均使用“较少”一词，因为在不影响本案的情况下，可以违反特定情况下的所有这些条件。 有许多以自制符号创建并完善的大型图表（同一张<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">地铁地图</a> ）。 另一个问题是，此类图的创建是花费大量资源的项目。 此类资源远非总是（读取，从不）分配给创建自动化信息系统。 客户需要完美的系统，而不是完美的系统图。 </p><br><p> 不过，对我而言，这些标准是您开始绘制图表的起点。 接下来...怎么回事。 </p><br><p> 长期以来，我一直以为自己将Microsoft Visio的使用视为一个黄金分割，并在其中绘制了图表，力图尽可能接近UML。 在这种情况下，使用了一组标准的组件，因为它提供了比用于UML的专用模板更大的自由度。 此外，在Microsoft PowerPoint中绘制了一些用于在投影仪上显示的图表。 </p><br><p> 是的，您无法管理此类图表。 如果实体的名称已更改，请打开每个图并进行更改。 事实证明，它几乎很漂亮。 在表达思想上有一定的灵活性。 </p><br><p> 我还尝试了专门的业务建模工具：Rational Rose，Aris，Enterpise Architect（Sparx Systems），最重要的是Rational Rose。 问题是我工作的最终结果是文件。 从这个意义上说，如果需求发生了重大变化，您仍然需要手动浏览整个项目，然后将图重新插入到文本的正确位置。 在我看来，想一想，也许要自动化这部分似乎太复杂了，不值得付出努力。 </p><br><p> 随着PlantUML的到来，情况发生了根本变化。 </p><br><ol><li><p> 一旦以文本形式创建了图表，这意味着在任何文本编辑器（我喜欢Atom和Notepad ++）中，您都可以在一组文件中找到所需的文本，甚至可以替换它们。 项目重构非常方便。 而且，文本格式使组织小组工作和跟踪版本控制系统中的更改变得容易。 </p><br></li><li><p> 在PlantUML中，创建图表的速度比任何可视化编辑器都要快（至少对我而言）。 关于此主题还有其他意见，例如， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">它</a>说在PlantUML中创建图表比在Enterpise Architect（Sparx Systems）中创建图表更长。 我认为这更多是关于品味和习惯的问题。 </p><br><p> 当我使用PlantUML代替木板（附近没有木板）时，甚至在与信息技术距离很远的人们那里，我什至都有相当成功的经验。 </p><br></li><li><p>  PlantUML足够灵活，可以使用UML表示法。 支持其所有基本元素，它为用户提供了许多在图表中自由使用的机会。 例如，在元素的内容中支持使用Wiki标记非常方便。 </p><br><p> 而且，显然，PlantUML的开发人员认为打破这种表示法并没有错。 这是此工具的一大优势。 最终，客户端不需要知道UML是否为UML-它需要了解图的含义。 导致意义感知改善的一切都是好的。 </p><br><p> 不过，PlantUML是UML，即 普遍接受的符号，标准，因此对于文档尤其是政府项目中的文档非常适用。 </p><br></li><li><p>  PlantUML不允许您创建大图表。 他自己分配元素，并且自然而然地使用大量元素，结果开始令人怀疑。 但这不是一个限制。 通常，当PlantUML开始产生不充分的结果时，您会意识到不是PlantUML不好，而是图表不好，因此最好将其分开或减少不相关细节的数量。 </p><br></li><li><p>  PlantUML图可以自动生成。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处</a>提供了此类用法的示例。 </p><br><p> 我们使用PlantUML自动生成数据库模式。 这种生成的功能内置在我们使用的数据库结构管理工具<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">-2bass中</a> 。 因此，在组装文档时，具有数据库结构的类图始终是最新的。 下图显示了一段数据库结构描述和一个自动生成的图表。 </p><br><img src="https://habrastorage.org/webt/al/ho/0u/alho0u6p0i4uk6-kbwjjo-5a-t0.png"><br></li></ol><br><h2 id="sovety-po-ispolzovaniyu-plantuml">  PlantUML提示 </h2><br><p> 在我看来，许多人没有使用PlantUML，因为它们在初始阶段会遇到某些困难，他们认为这是根本无法克服的。 许多人都对文本的使用感到害怕，因为每个人都习惯了图形编辑器。 我希望这篇文章的建议能使您快速开始在战斗任务中使用PlantUML。 </p><br><h3 id="gde-sozdavat-diagrammy"> 在哪里创建图表？ </h3><br><p> 首先，我想提到<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PlantUML Web Server</a> ，它是PlantUML项目的一部分，您可以在其中在线创建图表并与同事共享。 这是一个非常方便的功能，但是，当为项目文档创建图表时，当然不是。 </p><br><p>  PlantUML通常在Wiki引擎中使用。 在这里，编辑以标准方式进行：写入，保存文本，然后在页面上获得图片。 但是，尽管如此，在大多数情况下，将结果立即显示在图上还是很方便的：例如，图的规格写在左侧窗口中，而外观则显示在右侧窗口中。 完成的文本已经可以插入Wiki中。 </p><br><p>  PlantUML网站上有许多编辑器。 我怀疑其中一半以上不适合工作。 我最喜欢使用Atom编辑器中的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PlantUML Preview</a>插件来创建PlantUML图。 实际上，有几个这样的插件。 我喜欢PlantUML预览版，因为它不仅可以显示结果，而且可以立即（或在保存时-取决于设置）创建一个图形文件，其名称与具有图表说明的文件相对应。 </p><br><img src="https://habrastorage.org/webt/tx/uz/qj/txuzqjjh7auobrxlq6d-gyiu2kk.png"><br><br> 即 每个图始终对应于两个文件，一个文本文件（带有图的文本说明），另一个图形（带有图的图片）。 <br><p> 由于我们很长时间以来一直在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Asciidoctor</a>的帮助下<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">完成</a>所有文档的工作（令人惊讶的是，拒绝Microsoft Word可以使它变得更容易，但这是另一篇文章的主题），因此我们通过链接插入了图片。 要使用此技术更改图片，只需打开文字说明，然后对其进行更改并保存。 您不需要通过剪贴板进行导出或复制操作。 </p><br><p> 请注意，PlantUML Preview插件在其设置中需要指定planuml.jar文件的位置，如果未安装<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GraphViz，则</a> PlantUML本身将无法工作，可以从相应的站点下载这两个应用程序。 在最新版本的PlantUML中，将逐步淘汰Graphviz，因此在不久的将来，该产品将变得更加自主。 这将简化其在自动汇编程序文档的系统中的使用。 </p><br><h3 id="podgotovka-diagramm-dlya-pechati"> 准备图表进行打印 </h3><br><p> 为了在激光打印机上进行高质量打印，必须指定参数<em>skinparam dpi 300</em> 。  300 dpi分辨率可提供高质量的图像，以便在激光打印机上进行打印。 否则，将以屏幕分辨率创建图片并使其看起来栅格化。  PlantUML还具有使用svg（矢量格式）的能力。 但是，与png相比，该格式受支持的要少得多，并且存在更多的问题。 如果有必要使用矢量编辑器（例如，使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Inkscape</a> ）使图片更加清晰，我使用了svg。 但这当然是PlantUML极为罕见的用例。 </p><br><p> 要消除通常也会破坏打印外观的<em>阴影，</em>可以使用<em>skinparam shadowing false</em>参数。 </p><br><p> 另外，为了在黑白打印机上打印图表，希望它没有半色调。 使用棕色和黄色的配色方案通常不适合打印。 幸运的是，PlantUML允许您指定使用的颜色。 例如，以下选项以黑白调色板显示组件图。 单色图生成有一个特殊的参数（ <em>skinparam单色true</em> ），但是它只删除颜色，保留半色调。 </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">skinparam</span></span> component { <span class="hljs-attribute"><span class="hljs-attribute">borderColor</span></span> black backgroundColor white ArrowColor black }</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这里</a>给出了大多数参数的列表。 如果要研究所有参数，可以使用<em>java -jar plantuml.jar -language命令</em> 。 </p><br><h3 id="otnositelnoe-raspolozhenie-elementov"> 元素的相对排列 </h3><br><ol><li><p>  <em>从左到右的方向</em>参数导致从左到右绘制图表元素。 不是很明显，但是，例如，对于组件图，这意味着组件将在左侧组装，而接口在右侧组装。 </p><br><pre> <code class="hljs pgsql">component " 1" <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> c1 component " 2" <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> c2 interface " 1" <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> i1 c1 <span class="hljs-comment"><span class="hljs-comment">--() i1 c2 --( i1</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/ck/co/kd/ckcokd-rojc0znagkfhcsuvcnsc.png"><br></li><li><p> 与更高级别的元素分组。 </p><br><p> 在下图中，PlantUML已分配了组件，因此线交叉点较少。 如果我们希望按顺序显示组件，则组件的这种顺序可能是不希望的。 </p><br><pre> <code class="hljs swift">component <span class="hljs-string"><span class="hljs-string">" 1"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> c1 component <span class="hljs-string"><span class="hljs-string">" 2"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> c2 component <span class="hljs-string"><span class="hljs-string">" 3"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> c3 interface <span class="hljs-string"><span class="hljs-string">" 1"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> i1 c1 --() i1 c2 --( i1 interface <span class="hljs-string"><span class="hljs-string">" 2"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> i2 c1 --() i2 c3 --( i2</code> </pre> <br><img src="https://habrastorage.org/webt/qs/y-/5u/qsy-5uck-nhs6z-ztfpnqwebbdy.png"><br><p> 如果我们将第二个和第三个组件分组，那么我们将实现这些组件按顺序排列。 </p><br><pre> <code class="hljs swift">component <span class="hljs-string"><span class="hljs-string">" 1"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> c1 component <span class="hljs-string"><span class="hljs-string">" 1"</span></span> { component <span class="hljs-string"><span class="hljs-string">" 2"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> c2 component <span class="hljs-string"><span class="hljs-string">" 3"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> c3 } interface <span class="hljs-string"><span class="hljs-string">" 1"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> i1 c1 --() i1 c2 --( i1 interface <span class="hljs-string"><span class="hljs-string">" 2"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> i2 c1 --() i2 c3 --( i2</code> </pre> <br><img src="https://habrastorage.org/webt/jl/kf/pi/jlkfpi3kpkcq3cu--iet_6cthb4.png"><br></li><li><p> 组件的顺序。 一种颇具争议的方法，但它可以工作。 在以下示例中，首先显示组件2，如下所示： 在规范中它是第一位列出的。 </p><br><pre> <code class="hljs pgsql">component " 2" <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> c2 component " 1" <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> c1 interface " 1" <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> i1 c1 <span class="hljs-comment"><span class="hljs-comment">--() i1 c2 --( i1</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/f0/wg/en/f0wgenwj52gpvtlga1kzwhrzqwa.png"><br></li></ol><br><p>  PlantUML还具有指示箭头方向的功能。 例如，要指示箭头从组件1（c1）到接口1（i1）从左到右，您需要在箭头的规格中指定字母“ r”： <em>c1-</em> r- <em>（）i1</em> 。 下面的示例清楚地表明，从组件1到界面1的箭头从左到右，从组件2到同一界面的箭头从右到左。 </p><br><pre> <code class="hljs swift">component <span class="hljs-string"><span class="hljs-string">" 1"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> c1 component <span class="hljs-string"><span class="hljs-string">" 2"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> c2 interface <span class="hljs-string"><span class="hljs-string">" 1"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> i1 c1 -r-() i1 c2 -l-( i1</code> </pre> <br><img src="https://habrastorage.org/webt/3t/wt/m8/3twtm802viavo35lqhqsk69ah1o.png"><br><p> 我认为这是一个有害的机会。 它使图的规格混乱，并且PlantUML对方向的解释可能非常奇怪。 另外，当指定从左到右的方向参数时，字母“ r”从上到下开始表示（由于顺时针位移），这完全使该方案感到困惑。 </p><br><h3 id="nadpisi-v-elementah-diagrammy"> 标签元素 </h3><br><h4 id="mnogostrochnyy-tekst-i-wiki-razmetka"> 多行文字和Wik​​i标记 </h4><br><p>  PlantUML提供了一些很好的工具来格式化元素中的文本。 </p><br><p> 生成图表元素时，PlantUML基于文本的大小。 即 不是文本根据元素的大小而流动，而是元素的大小适合文本。 </p><br><p> 创建大文本的最简单方法是使用\ n字符。 在这种情况下，您还可以使用文本格式字符（粗体，斜体等）。 </p><br><pre> <code class="hljs tex">component "** 1** <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">n</span></span></span></span>       <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">n</span></span></span></span> //****// <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">n*</span></span></span></span> //// 1 <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">n*</span></span></span></span> // 2//" as c1</code> </pre> <br><img src="https://habrastorage.org/webt/pe/mq/8k/pemq8kvqnapxskgnor-0xvxouf0.png"><br><p> 有时没有其他选择。 但是在大多数情况下，都支持语法，使您可以指定多行文本。 例如，在前面的示例中，您可以使用此语法。 </p><br><pre> <code class="hljs ruby">component c1 [ ** <span class="hljs-number"><span class="hljs-number">1</span></span>** ====       ../<span class="hljs-regexp"><span class="hljs-regexp">/****/</span></span><span class="hljs-regexp"><span class="hljs-regexp">/.. * /</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 1 * /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 2/</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ] note left      .... ** 1** ====       ../</span></span><span class="hljs-regexp"><span class="hljs-regexp">/****/</span></span><span class="hljs-regexp"><span class="hljs-regexp">/.. * /</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 1 * /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 2/</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ end note</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/dp/cn/_g/dpcn_gtv35rzjj4gcjkvi0xtths.png"><br><p> 如我们所见，使用此语法可以添加分隔线。 请注意，此处添加了一条注释，该注释显示与组件相同的文本。 同时，在注释中，列表显示为列表，在组件中，显示为通过“ *”符号显示的文本。 不幸的是，列表和表格在组件中不起作用。 尽管它们例如在表示活动的元素中工作（在活动图中）。 </p><br><h4 id="ispolzovanie-ikonok"> 使用图标 </h4><br><p>  PlantUML支持多种使用图标的方式。 它们都有一定的局限性。 </p><br><p> 在我看来，最受欢迎的技术已经成为使用所谓的Sprite的技术。 子画面是使用文本设置的位图。 该技术的最大优点是PlantUML允许您创建外部精灵库。 有几个这样的库。 我最喜欢的是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PlantUML Icon-Font Sprites</a>库，因为 它包含来自<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Font Awesome的</a>图形图像。 </p><br><p> 请注意，PlantUML中的子画面是位图，即 它们在缩放方面有限制。 在此特定的库中，图标的分辨率为48 x 48像素。 当使用这种图像进行打印时，不希望将其缩放到大于5毫米的尺寸（大致对应于250 dpi的分辨率）。 在许多描述Sprite用法的Internet资源上，没有考虑到这一点，示例中的图表元素带有大图标。 在屏幕上，这些图看起来不错，但是在打印时，它们看起来已经光栅化了。 </p><br><p> 在签名内部方便使用4-5毫米的图标大小。 例如，在下图中，使用图标显示了用户角色，其成员将流程从一种状态转移到另一种状态。 </p><br><pre> <code class="hljs tex">'       !define ICONURL https://raw.githubusercontent.com/tupadr3/plantuml-icon-font-sprites/v2.0.0 !includeurl ICONURL/common.puml !includeurl ICONURL/font-awesome-5/user_cog.puml !includeurl ICONURL/font-awesome-5/user_check.puml !define _CS scale=0.4 !define _user_cog &lt;<span class="hljs-formula"><span class="hljs-formula">$user_cog{_CS}&gt; !define _user_check &lt;$</span></span>user_check{_CS}&gt; ' legend ..** **.. _user_cog —  _user_check —  endlegend '   state " " as prepare_doc [*] --&gt; prepare_doc state "  " as check_doc prepare_doc --&gt; check_doc : _user_cog <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">n</span></span></span></span>  <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">n</span></span></span></span>  check_doc --&gt; prepare_doc : _user_check <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">n</span></span></span></span>  <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">n</span></span></span></span>  state " " as ready_doc check_doc --&gt; ready_doc: _user_check <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">n</span></span></span></span>   <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">n</span></span></span></span>&lt;U+00AB&gt;&lt;U+00BB&gt;</code> </pre> <br><img src="https://habrastorage.org/webt/3c/or/o8/3coro8gvu8_7grt9gpxywdff1fq.png"><br><p> 有些图标直接内置在PlantUML中，但是我更喜欢使用外部库。 特别是，此示例中的图标包含在Awesome v5库中，并且在撰写本文时（版本1.2018.08），PlantUML中仅内置了Awesome v4库。 </p><br><h4 id="ispolzovanie-kavychek"> 使用引号 </h4><br><p> 事实证明，这个看似简单的问题几乎使我无法使用PlantUML。 缺少引号看起来不专业且有趣。 </p><br><p>  PlantUML支持多种使用引号的方式。 但是，由于搜索的结果，我发现只有一个总是可以使用的旧废纸：用于打开俄语报价-&lt;U + 00AB&gt;，用于结束报价-&lt;U + 00BB&gt;，用于通用报价-&lt;U + 0022&gt;。 </p><br><h3 id="kak-ne-zaputatsya-v-diagramme"> 如何在图表中不迷路 </h3><br><p> 活动图中的语法非常方便，很难混淆，因为 它比图的描述更像是算法的描述。 但是在其他图中：状态，组件，部署，用例，类和其他图，很容易混淆。 </p><br><p> 有两个简单的规则可以帮助我避免混淆。 </p><br><ol><li><p> 通过关键字输入所有元素（不要使用简化语法）。 如果元素允许，请为其设置别名。 </p><br></li><li><p> 在元素之后立即指示关系（当然，如果关联的元素已经存在于图表中）。 事实是，在文本中总是容易找到元素。 只能通过别名找到连接。 如果使用此规则，则也可以在文本中快速找到连接。 </p><br></li></ol><br><h2 id="zaklyuchenie"> 结论 </h2><br><ol><li><p>  PlantUML不是玩具。 这是一种高质量的通用工具，您可以使用它解决与业务流程描述和所设计系统的体系结构功能相关的几乎所有问题。 </p><br></li><li><p>  PlantUML在进入方面存在心理障碍：我们已经习惯了可视化编辑器，因此使用文本似乎向后退。 但是，如果由于这一退步而提高了工作效率，为什么不这样做呢？ </p><br></li><li><p>  PlantUML的实现存在漏洞：某些功能仅适用于部分图或图形基元。 但是，实际上，总是可以绕开这种限制。  PlantUML是一种成熟且稳定的工作产品，您可以完全依靠它来工作，而不必担心它将破坏图表或使字体变形或引发其他问题，这些问题将导致在进入下一阶段之前无法入眠。 </p><br></li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN416077/">https://habr.com/ru/post/zh-CN416077/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN416067/index.html">Mikrotik Winbox漏洞概述。 或大文件</a></li>
<li><a href="../zh-CN416069/index.html">无损ElasticSearch数据迁移</a></li>
<li><a href="../zh-CN416071/index.html">神经网络，基本操作原理，多样性和拓扑</a></li>
<li><a href="../zh-CN416073/index.html">一个简单的加密货币交易机器人</a></li>
<li><a href="../zh-CN416075/index.html">FSB希望对智能手机中的录音机和摄像头的隐藏使用承担责任（不仅限于此）</a></li>
<li><a href="../zh-CN416079/index.html">适用于Android的Corona Native-在用Corona编写的游戏中使用自定义Java代码</a></li>
<li><a href="../zh-CN416081/index.html">重返哈勃（Habr）仍然有些问题</a></li>
<li><a href="../zh-CN416083/index.html">我的效率规则：处理任务，项目，书籍和笔记</a></li>
<li><a href="../zh-CN416087/index.html">MTProto代理统计信息收集</a></li>
<li><a href="../zh-CN416089/index.html">我们如何为柴油动力不间断电源提供服务</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>