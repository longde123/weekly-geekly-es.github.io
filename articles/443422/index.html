<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👀 🤾🏼 🤔 Almacenamiento flexible de datos en MySQL (JSON) 👩🏼 🏴 🤟🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Alexander Rubin trabaja en Percona y ha actuado en HighLoad ++ más de una vez, familiar para los participantes como experto en MySQL. Es lógico supone...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Almacenamiento flexible de datos en MySQL (JSON)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/443422/">  Alexander Rubin trabaja en Percona y ha actuado en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">HighLoad ++ más</a> de una vez, familiar para los participantes como experto en MySQL.  Es lógico suponer que hoy hablaremos de algo relacionado con MySQL.  Esto es así, pero solo en parte, porque también hablaremos sobre <strong>Internet de las cosas</strong> .  La historia será medio entretenida, especialmente su primera parte, en la que miramos el dispositivo que Alexander creó para cosechar albaricoques.  Tal es la naturaleza de un verdadero ingeniero: si quieres fruta, compras una tarifa. <br><br><img src="https://habrastorage.org/webt/71/jf/vp/71jfvpzudizjhoc1ikzgfuakds8.jpeg"><br><br><h2>  Antecedentes <br></h2><br>  Todo comenzó con un simple deseo de plantar un árbol frutal en su área.  Parecería muy simple hacer esto: vienes a la tienda y compras una plántula.  Pero en Estados Unidos, la primera pregunta que hacen los vendedores es cuánta luz solar recibirá el árbol.  Para Alexander, esto resultó ser un misterio gigante: es completamente desconocido la cantidad de luz solar que hay en el sitio. <br><br>  Para averiguarlo, un estudiante podría salir al patio todos los días, ver la cantidad de luz solar y escribirlo en un cuaderno.  Pero este no es el caso: debe equipar todo y automatizarlo. <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/X5iLzmyZcto" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <em>Durante la presentación, se ejecutaron muchos ejemplos y se tocaron en vivo.</em>  <em>Si desea una imagen más completa que en el texto, cambie a ver el video.</em> <br><br>  Entonces, para no registrar las observaciones climáticas en una computadora portátil, hay una gran cantidad de dispositivos para cosas de Internet: Raspberry Pi, la nueva Raspberry Pi, Arduino, miles de plataformas diferentes.  Pero elegí un dispositivo llamado <b>Particle Photon</b> para este proyecto.  Es muy fácil de usar, cuesta $ 19 en el sitio web oficial. <br><br>  Lo bueno de Particle Photon es: <br><br><ol><li>  Solución 100% en la nube; </li><li>  Cualquier sensor es adecuado, por ejemplo, para Arduino.  Todos cuestan menos de un dólar. </li></ol><br>  Hice un dispositivo así y lo puse en la hierba en el sitio.  Tiene una nube de dispositivos de partículas y una consola.  Este dispositivo se conecta a través de un punto de acceso Wi-Fi y envía datos: luz, temperatura y humedad.  El probador duró 24 horas con una batería pequeña, lo cual es bastante bueno. <br><br>  Además, no solo necesito medir la iluminación, etc., y transferirlos al teléfono (lo cual es realmente bueno, puedo ver en tiempo real qué tipo de iluminación tengo), sino también <strong>almacenar datos</strong> .  Para esto, naturalmente, como un veterano de MySQL, elegí MySQL. <br><br><h2>  ¿Cómo escribimos datos en MySQL? <br></h2><br>  Elegí un esquema bastante complicado: <br><br><ul><li>  Obtengo datos de la consola Particle; <br></li><li>  Yo uso Node.js para escribirlos en MySQL. <br></li></ul><br>  Estoy usando la API de Particle JS, que se puede descargar desde el sitio web de Particle.  Establezco una conexión con MySQL y escribo, es decir, solo hago los valores INSERT INTO.  Tal tubería. <br><br>  Por lo tanto, el dispositivo se encuentra en el patio, se conecta a través de Wi-Fi al enrutador doméstico y utiliza el protocolo MQTT para transferir datos a Particle.  Luego, el esquema: el programa en Node.js se ejecuta en la máquina virtual, que recibe datos de Particle y los escribe en MySQL. <br><br>  Para comenzar, construí los gráficos a partir de los datos en bruto en R. Los gráficos muestran que la temperatura y la iluminación aumentan durante el día, caen de noche y aumenta la humedad; esto es natural.  Pero también hay ruido en el gráfico, que es típico de los dispositivos de Internet de las cosas.  Por ejemplo, cuando un error se arrastra sobre un dispositivo y lo cierra, el sensor puede transmitir datos completamente irrelevantes.  Esto será importante para una mayor consideración. <br><br>  Ahora hablemos de MySQL y JSON, lo que ha cambiado al trabajar con JSON de MySQL 5.7 a MySQL 8. Luego mostraré una demostración para la que uso MySQL 8 (en el momento del informe, esta versión aún no estaba lista para la producción, ya se ha lanzado una versión estable). <br><br><h2>  Almacenamiento de datos MySQL <br></h2><br>  Cuando intentamos almacenar los datos recibidos de los sensores, nuestro primer pensamiento es <strong>crear una tabla en MySQL</strong> : <br><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> <span class="hljs-string"><span class="hljs-string">'sensor_wide'</span></span> ( <span class="hljs-string"><span class="hljs-string">'id'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> (<span class="hljs-number"><span class="hljs-number">11</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> AUTO_INCREMENT, <span class="hljs-string"><span class="hljs-string">'light'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> (<span class="hljs-number"><span class="hljs-number">11</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">DEFAULT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-string"><span class="hljs-string">'temp'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DEFAULT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-string"><span class="hljs-string">'humidity'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DEFAULT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, PRIMARY <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span> (<span class="hljs-string"><span class="hljs-string">'id'</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">ENGINE</span></span>=<span class="hljs-keyword"><span class="hljs-keyword">InnoDB</span></span></code> </pre> <br>  Aquí para cada sensor y para cada tipo de datos hay una columna: luz, temperatura, humedad. <br><br>  Esto es lo suficientemente lógico, pero <strong>hay un problema: no es flexible</strong> .  Supongamos que queremos agregar otro sensor y medir otra cosa.  Por ejemplo, algunas personas miden la cerveza restante en un barril.  ¿Qué hacer en este caso? <br><br><pre> <code class="plaintext hljs">alter table sensor_wide add water level double ...;</code> </pre><br>  ¿Cómo pervertir para agregar algo a la tabla?  Necesitas hacer una tabla alternativa, pero si hiciste una tabla alternativa en MySQL, entonces sabes de lo que estoy hablando, esto es completamente difícil.  Alterar la tabla en MySQL 8 y MariaDB es mucho más simple, pero históricamente este es un gran problema.  Entonces, si necesitamos agregar una columna, por ejemplo, con el nombre de la cerveza, entonces no será tan simple. <br><br>  Una vez más, los sensores aparecen, desaparecen, ¿qué debemos hacer con los datos antiguos?  Por ejemplo, dejamos de recibir información sobre iluminación.  ¿O estamos creando una nueva columna: cómo almacenar lo que no estaba allí antes?  El enfoque estándar es nulo, pero para el análisis no será muy conveniente. <br><br>  Otra opción es un almacén de clave / valor. <br><br><h3>  Almacenamiento de datos MySQL: clave / valor <br></h3><br>  Esto será <strong>más flexible</strong> : en clave / valor habrá un nombre, por ejemplo, temperatura y, en consecuencia, datos. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> <span class="hljs-string"><span class="hljs-string">'cloud_data'</span></span> ( <span class="hljs-string"><span class="hljs-string">'id'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> (<span class="hljs-number"><span class="hljs-number">11</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> AUTO_INCREMENT, <span class="hljs-string"><span class="hljs-string">'name'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">varchar</span></span>(<span class="hljs-number"><span class="hljs-number">255</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">DEFAULT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-string"><span class="hljs-string">'data'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">text</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DEFAULT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-string"><span class="hljs-string">'updated_at'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">timestamp</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DEFAULT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CURRENT_TIMESTAMP</span></span> PRIMARY <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span> (<span class="hljs-string"><span class="hljs-string">'id'</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">ENGINE</span></span>=<span class="hljs-keyword"><span class="hljs-keyword">InnoDB</span></span></code> </pre><br>  En este caso, aparece <strong>otro problema: no hay tipos</strong> .  No sabemos lo que estamos almacenando en el campo 'datos'.  Tendremos que declararlo como un campo de texto.  Cuando creo mi dispositivo de Internet de las cosas, sé qué tipo de sensor hay y, en consecuencia, el tipo, pero si necesita almacenar los datos de otra persona en la misma tabla, no sabré qué datos se recopilan. <br><br>  Puede almacenar muchas tablas, pero crear una tabla completamente nueva para cada sensor no es muy bueno. <br><br>  Que se puede hacer  - Usa JSON. <br><br><h3>  Almacenamiento de datos MySQL: JSON <br></h3><br>  La buena noticia es que en MySQL 5.7 puede almacenar JSON como un campo. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> <span class="hljs-string"><span class="hljs-string">'cloud_data_json'</span></span> ( <span class="hljs-string"><span class="hljs-string">'id'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> (<span class="hljs-number"><span class="hljs-number">11</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> AUTO_INCREMENT, <span class="hljs-string"><span class="hljs-string">'name'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">varchar</span></span>(<span class="hljs-number"><span class="hljs-number">255</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">DEFAULT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-string"><span class="hljs-string">'data'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JSON</span></span>, <span class="hljs-string"><span class="hljs-string">'updated_at'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">timestamp</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DEFAULT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CURRENT_TIMESTAMP</span></span> PRIMARY <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span> (<span class="hljs-string"><span class="hljs-string">'id'</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">ENGINE</span></span>=<span class="hljs-keyword"><span class="hljs-keyword">InnoDB</span></span>;</code> </pre><br>  Antes de que apareciera MySQL 5.7, la gente también almacenaba JSON, pero como un campo de texto.  El campo JSON en MySQL le permite almacenar JSON de la manera más eficiente.  Además, según JSON, puede crear columnas virtuales e índices basados ​​en ellos. <br><br>  El único problema menor es <strong>que la tabla crecerá en tamaño durante el almacenamiento</strong> .  Pero luego tenemos mucha más flexibilidad. <br><br>  El campo JSON es mejor para almacenar JSON que el campo de texto porque: <br><br><ul><li>  Proporciona <strong>validación automática de documentos</strong> .  Es decir, si intentamos escribir algo que no es válido allí, se producirá un error. <br></li><li>  Este es un <strong>formato de almacenamiento optimizado</strong> .  JSON se almacena en formato binario, lo que le permite cambiar de un documento JSON a otro, lo que se llama omitir. <br></li></ul><br>  Para almacenar datos en JSON, simplemente podemos usar SQL: hacer un INSERT, poner 'datos' allí y obtener datos del dispositivo. <br><br><pre> <code class="sql hljs">… stream.on('event', function(data) { var query = connection.query( '<span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> cloud_data_json (client_name, <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (?, ?)<span class="hljs-string"><span class="hljs-string">', ['</span></span>particle<span class="hljs-string"><span class="hljs-string">', JSON.stringify(data)] ) … (demo)</span></span></code> </pre><br><h3>  Demo <br></h3><br>  Para demostrar ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> comienza en el video), el ejemplo utiliza una máquina virtual en la que hay SQL. <br><br><img src="https://habrastorage.org/webt/r1/mb/po/r1mbpoyh-czzxtsbz2f_umippjc.jpeg"><br><br>  A continuación se muestra un fragmento del programa. <br><br><img src="https://habrastorage.org/webt/ap/fm/pq/apfmpqvjrdx5k8f9z6thallawri.jpeg"><br><br>  <code>INSERT INTO cloud_data (name, data)</code> , obtengo los datos ya en formato JSON, y puedo escribirlos directamente en MySQL tal como están, sin pensar en lo que hay dentro. <br><br>  Resultó que, utilizando esta nube, puede acceder no solo a los datos de mi dispositivo, sino a <strong>todos los datos</strong> que utiliza esta Partícula.  Parece funcionar hasta ahora.  Las personas que usan Particle Photon en todo el mundo están enviando algunos datos: la puerta del garaje está abierta, o el resto de la cerveza es tal o cual, o algo más.  No se sabe dónde se encuentran estos dispositivos, pero se pueden obtener dichos datos.  La única diferencia es que cuando obtengo mis datos, escribo algo como: <code>deviceId: 'mine'</code> . <br><br>  Cuando ejecutamos el código, obtenemos una secuencia de algunos datos de los dispositivos de otra persona que están haciendo algo. <br><br><img src="https://habrastorage.org/webt/sw/wk/c5/swwkc5xibzuqncd-kuuo_figddg.jpeg"><br><br>  Absolutamente no sabemos cuáles son estos datos: TTL, publicado en, coreid, estado de la puerta (puerta abierta), relé activado. <br><br>  Este es un gran ejemplo.  Supongamos que trato de poner esto en MySQL en una estructura de datos normal.  Debería saber cuál es la puerta, por qué está abierta y qué parámetros generales puede tomar.  Si tengo JSON, entonces lo escribo directamente en MySQL como un campo JSON. <br><br><img src="https://habrastorage.org/webt/9o/pi/k4/9opik4nqfqiand6n4fhae0zi31u.jpeg"><br><br>  Por favor, todo ha sido grabado. <br><br><img src="https://habrastorage.org/webt/wz/n0/ph/wzn0phesbal_lwsjutyiy3569jq.jpeg"><br><br><h3>  Tienda de documentos <br></h3><br>  Document store es un intento en MySQL para hacer almacenamiento para JSON.  Realmente amo SQL, lo conozco bien, puedo hacer cualquier consulta SQL, etc.  Pero a muchas personas no les gusta SQL por varias razones, y el almacén de documentos puede ser una solución para ellos, porque con él puedes abstraer de SQL, conectarte a MySQL y escribir JSON directamente allí. <br><img src="https://habrastorage.org/webt/w5/9z/5y/w59z5ykdgg9nqfnuuzjdhgrfcmu.jpeg"><br><br>  Existe otra posibilidad que apareció en MySQL 5.7: usar un protocolo diferente, un puerto diferente y también se necesita otro controlador.  Para Node.js (de hecho, para cualquier lenguaje de programación: PHP, Java, etc.), nos conectamos a MySQL usando un protocolo diferente y podemos transferir datos en formato JSON.  Una vez más, no sé lo que tengo en este JSON: información sobre puertas u otra cosa, simplemente descargo los datos en MySQL y luego lo resolveremos. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mysqlx = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'@mysql/xdevapi*); // MySQL Connection var mySession = mysqlx.gctSession({ host: '</span></span>localhost<span class="hljs-string"><span class="hljs-string">', port: 33060, dbUser: '</span></span>photon* }); … session.getSchema(<span class="hljs-string"><span class="hljs-string">"particle"</span></span>).getCollection(<span class="hljs-string"><span class="hljs-string">"cloud_data_docstore"</span></span>) .add( data ) .execute(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">row</span></span></span><span class="hljs-function">) </span></span>{ }).catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(err); }) .then( -<span class="hljs-built_in"><span class="hljs-built_in">Function</span></span> (notices) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"Wrote to MySQL"</span></span>) }); ...https:<span class="hljs-comment"><span class="hljs-comment">//dev.mysql.com/doc/dev/connector-nodejs/</span></span></code> </pre><br>  Si desea experimentar con esto, puede configurar MySQL 5.7 para que comprenda y escuche en el puerto apropiado Document store o X DevAPI.  Usé connector-nodejs. <br><br>  Este es un ejemplo de lo que escribo allí: cerveza, etc. No sé absolutamente qué hay allí.  Ahora solo lo escribimos y lo analizamos más tarde. <br><br><img src="https://habrastorage.org/webt/vo/cw/jn/vocwjnriy8x0mgrsepta-nrcpcm.jpeg"><br><br>  El siguiente punto de nuestro programa es cómo ver qué hay allí. <br><br><h3>  Almacenamiento de datos MySQL: índices JSON + <br></h3><br>  Hay una gran característica en JSON y MySQL 5.7 que puede extraer campos de JSON.  Este es el azúcar sintáctico en la función JSON_EXTRACT.  Creo que esto es muy conveniente. <br><br>  Los datos en nuestro caso son el nombre de la columna en la que se almacena JSON, y el nombre es nuestro campo.  Nombre, datos, publicado en: esto es todo lo que podemos sacar de esta manera. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>-&gt;&gt;<span class="hljs-string"><span class="hljs-string">'$.name'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> data_name, <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>-&gt;&gt;<span class="hljs-string"><span class="hljs-string">'$.data'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>-&gt;&gt;<span class="hljs-string"><span class="hljs-string">'$.published_at'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> published <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> cloud_data_json <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>-&gt;<span class="hljs-string"><span class="hljs-string">'$.published_at'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">desc</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>;</code> </pre><br>  En este ejemplo, quiero ver lo que he escrito en la tabla MySQL y los últimos 10 registros.  Hago una solicitud de este tipo e intento ejecutarla.  Lamentablemente, <strong>esto funcionará durante mucho tiempo</strong> . <br><br>  De manera lógica, MySQL no utilizará ningún índice en este caso.  Extraemos los datos de JSON e intentamos aplicar algún tipo de filtro y clasificación.  En este caso, obtenemos el uso de ordenar archivos. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>-&gt;&gt;<span class="hljs-string"><span class="hljs-string">'$.name'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> data_name ... <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>-&gt;&gt;<span class="hljs-string"><span class="hljs-string">'$.published_at'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">desc</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> select_type: SIMPLE <span class="hljs-keyword"><span class="hljs-keyword">table</span></span>: cloud_data_json possible_keys: <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">key</span></span>: <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> … <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>: <span class="hljs-number"><span class="hljs-number">101589</span></span> filtered: <span class="hljs-number"><span class="hljs-number">100.00</span></span> Extra: <span class="hljs-keyword"><span class="hljs-keyword">Using</span></span> filesort</code> </pre><br>  Usar filesort es muy malo, es un tipo externo. <br><br>  La buena noticia es que puedes tomar 2 pasos para acelerarlo. <br><br><h4>  Paso 1. Crear una columna virtual <br></h4><br><pre> <code class="sql hljs">mysql&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> cloud_data_json -&gt; <span class="hljs-keyword"><span class="hljs-keyword">ADD</span></span> published_at DATETIME(<span class="hljs-number"><span class="hljs-number">6</span></span>) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">GENERATED</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ALWAYS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">STR_TO_DATE</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>-&gt;&gt;<span class="hljs-string"><span class="hljs-string">'$.published_at'</span></span>,<span class="hljs-string"><span class="hljs-string">"%Y-%m-%dT%T.%fZ"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">VIRTUAL</span></span>; Query OK, 0 rows affected (0.01 sec) Records: 0 Duplicates: 0 Warnings: 0</code> </pre><br>  Extraigo, es decir, extraigo datos de JSON y, en base a ellos, creo una columna virtual.  La columna virtual no se almacena en MySQL 5.7 y MySQL 8: es solo la capacidad de crear una columna separada. <br><br>  Si preguntas cómo es, dijiste que ALTER TABLE es una operación tan larga.  Pero aquí no está tan mal.  <strong>Crear una columna virtual es rápido</strong> .  Hay lok allí, pero en realidad en MySQL hay un bloqueo en todas las operaciones DDL.  ALTER TABLE es una operación bastante rápida y no reconstruye toda la tabla. <br><br>  Hemos creado una columna virtual aquí.  Tuve que convertir la fecha, porque en JSON se almacena en formato iso, pero aquí MySQL usa un formato completamente diferente.  Para crear una columna, lo nombré, le di un tipo y dije que grabaría allí. <br><br>  Para optimizar la consulta original, debe extraer updated_at y name.  Publicado_en ya existe, el nombre es más fácil, solo haga una columna virtual. <br><br><pre> <code class="sql hljs">mysql&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> cloud_data_json -&gt; <span class="hljs-keyword"><span class="hljs-keyword">ADD</span></span> data_name <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">255</span></span>) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">GENERATED</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ALWAYS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>-&gt;&gt;<span class="hljs-string"><span class="hljs-string">'$.name'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">VIRTUAL</span></span>; Query OK, 0 rows affected (0.01 sec) Records: 0 Duplicates: 0 Warnings: 0</code> </pre><br><h4>  Paso 2. Crear un índice <br></h4><br>  En el siguiente código, creo un índice en updated_at y ejecuto la consulta: <br><br><pre> <code class="sql hljs">mysql&gt; <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> cloud_data_json <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> <span class="hljs-keyword"><span class="hljs-keyword">key</span></span> (published_at); Query OK, 0 rows affected (0.31 sec) Records: 0 Duplicates: 0 Warnings: 0 mysql&gt; <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> data_name, published_at, <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>-&gt;&gt;<span class="hljs-string"><span class="hljs-string">'$.data'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> cloud_data_json <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> published_at <span class="hljs-keyword"><span class="hljs-keyword">desc</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>\G <span class="hljs-keyword"><span class="hljs-keyword">table</span></span>: cloud_data_json <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> possible_keys: <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">key</span></span>: published_at key_len: <span class="hljs-number"><span class="hljs-number">9</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>: <span class="hljs-number"><span class="hljs-number">10</span></span> filtered: <span class="hljs-number"><span class="hljs-number">100.00</span></span> Extra: Backward <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">scan</span></span></code> </pre><br>  Puede ver que MySQL realmente usa el índice.  Esta es una optimización por pedido.  En este ejemplo, los datos y el nombre no están indexados.  MySQL usa el orden por datos, y dado que tenemos un índice en updated_at, lo usa. <br><br>  Además, podría usar la misma sintaxis azúcar <code>STR_TO_DATE(data-&gt;&gt;'$.published_at',"%Y-%m-%dT%T.%fZ")</code> lugar de publicada_at en orden.  MySQL aún entendería que hay un índice en esta columna y comenzaría a usarlo. <br><br>  En realidad hay un pequeño problema con esto.  Supongamos que quiero ordenar los datos no solo por updated_at, sino también por nombre. <br><br><pre> <code class="sql hljs">mysql&gt; <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> data_name, published_at, <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>-&gt;&gt;<span class="hljs-string"><span class="hljs-string">'$.data'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> cloud_data_json <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> published_at <span class="hljs-keyword"><span class="hljs-keyword">desc</span></span>, data_name <span class="hljs-keyword"><span class="hljs-keyword">asc</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>\G select_type: SIMPLE <span class="hljs-keyword"><span class="hljs-keyword">table</span></span>: cloud_data_json <span class="hljs-keyword"><span class="hljs-keyword">partitions</span></span>: <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: ALL possible_keys: <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">key</span></span>: <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> key_len: <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span>: <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>: <span class="hljs-number"><span class="hljs-number">101589</span></span> filtered: <span class="hljs-number"><span class="hljs-number">100.00</span></span> Extra: <span class="hljs-keyword"><span class="hljs-keyword">Using</span></span> filesort</code> </pre><br>  Si su dispositivo procesa decenas de miles de eventos por segundo, updated_at no dará una buena clasificación, ya que habrá duplicados.  Por lo tanto, agregamos otra clasificación por data_name.  Esta es una consulta típica no solo para Internet de las cosas: déme los últimos 10 eventos, sino que los clasifique por fecha y luego, por ejemplo, por el apellido de la persona en orden ascendente.  Para hacer esto, en el ejemplo anterior, hay dos campos y se especifican dos claves de clasificación: descendente y ascendente. <br><br>  En primer lugar, en este caso, MySQL no usará índices.  En este caso particular, MySQL decide que un escaneo completo de la tabla será más rentable que usar un índice, y nuevamente se utiliza la operación de clasificación de archivos muy lenta. <br><br><h2>  Nuevo en MySQL 8.0 <br></h2><br><h3>  <strong>descendente / ascendente</strong> <br></h3><br>  En MySQL 5.7, dicha consulta no puede optimizarse, aunque solo sea a expensas de otras cosas.  En MySQL 8, había una oportunidad real para especificar la ordenación de cada campo. <br><br><pre> <code class="sql hljs">mysql&gt; <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> cloud_data_json <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> <span class="hljs-keyword"><span class="hljs-keyword">key</span></span> published_at_data_name (published_at <span class="hljs-keyword"><span class="hljs-keyword">desc</span></span>, data_name <span class="hljs-keyword"><span class="hljs-keyword">asc</span></span>); Query OK, 0 rows affected (0.44 sec) Records: 0 Duplicates: 0 Warnings: 0</code> </pre><br>  Lo más interesante es que la clave descendente / ascendente después del nombre del índice ha estado durante mucho tiempo en SQL.  Incluso en la primera versión de MySQL 3.23, puede especificar updated_at descennding o shown_at ascending.  MySQL aceptó esto, <strong>pero no hizo nada</strong> , es decir, siempre se ordenó en una dirección. <br><br>  En MySQL 8, esto se solucionó y ahora existe tal característica.  Puede crear un campo en orden descendente y con clasificación predeterminada. <br><br>  Volvamos un segundo y miremos el ejemplo del paso 2 nuevamente. <br><br>  ¿Por qué funciona, de lo contrario no funciona?  Esto funciona porque en los índices MySQL es un árbol B, y los índices del árbol B se pueden leer tanto desde el principio como desde el final.  En este caso, MySQL lee el índice desde el final y todo está bien.  Pero si hacemos descender y ascender, entonces no puedes leer.  Puede leer en el mismo orden, pero <strong>no puede combinar dos tipos</strong> : debe volver a ordenarlos. <br><br>  Como estamos optimizando un caso muy específico, podemos crear un índice para él y especificar un tipo específico: aquí updated_at es descendente, data_name es ascendente.  MySQL usa este índice, y todo estará bien y rápido. <br><br><pre> <code class="sql hljs">mysql&gt; <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> data_name, published_at, <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>-&gt;&gt;<span class="hljs-string"><span class="hljs-string">'$.data'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> cloud_data_json <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> published_at <span class="hljs-keyword"><span class="hljs-keyword">desc</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>\G select_type: SIMPLE <span class="hljs-keyword"><span class="hljs-keyword">table</span></span>: cloud_data_json <span class="hljs-keyword"><span class="hljs-keyword">partitions</span></span>: <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> possible_keys: <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">key</span></span>: published_at_data_name key_len: <span class="hljs-number"><span class="hljs-number">267</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span>: <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>: <span class="hljs-number"><span class="hljs-number">10</span></span> filtered: <span class="hljs-number"><span class="hljs-number">100.00</span></span> Extra: <span class="hljs-literal"><span class="hljs-literal">NULL</span></span></code> </pre><br>  Esta es una característica de MySQL 8, que ahora, en el momento de la publicación, ya está disponible y lista para usar en producción. <br><br><h3>  Resultados de salida <br></h3><br>  Hay dos cosas más interesantes que quiero mostrar: <br><br>  1. Impresión bonita, es decir, una hermosa salida de datos a la pantalla.  Con SELECT normal, JSON no se formateará. <br><br><pre> <code class="sql hljs">mysql&gt; <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> json_pretty(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> cloud_data_json <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>-&gt;&gt;<span class="hljs-string"><span class="hljs-string">'$.data'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">like</span></span> <span class="hljs-string"><span class="hljs-string">'%beer%'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>\G … json_pretty(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>): { <span class="hljs-string"><span class="hljs-string">"ttl"</span></span>: <span class="hljs-number"><span class="hljs-number">60</span></span>, <span class="hljs-string"><span class="hljs-string">"data"</span></span>: <span class="hljs-string"><span class="hljs-string">"FvGav,tagkey=beer-store spFridge=7.00,pvFridge=7.44"</span></span>, <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"LOG_DATA_DEBUG"</span></span>, <span class="hljs-string"><span class="hljs-string">"coreid"</span></span>: <span class="hljs-string"><span class="hljs-string">"3600...."</span></span>, <span class="hljs-string"><span class="hljs-string">"published_at"</span></span>: <span class="hljs-string"><span class="hljs-string">"2017-09-28T18:21:16.517Z"</span></span> }</code> </pre><br>  2. Podemos decir que MySQL generará el resultado en forma de una matriz JSON o un objeto JSON, especificará los campos y luego la salida se formateará como JSON. <br><br><h2>  Búsqueda de texto completo dentro de documentos JSON <br></h2><br>  Si utilizamos un sistema de almacenamiento flexible y no sabemos qué hay dentro de nuestro JSON, sería lógico utilizar la búsqueda de texto completo. <br><br>  Desafortunadamente, <strong>la búsqueda de texto completo tiene sus limitaciones</strong> .  Lo primero que intenté fue crear una clave de texto completo.  Traté de hacer tal cosa: <br><br><pre> <code class="sql hljs">mysql&gt; <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> cloud_data_json_indexes <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> fulltext <span class="hljs-keyword"><span class="hljs-keyword">key</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>); ERROR 3152 (42000): JSON column 'data' supports indexing only via generated columns on a specified ISON path.</code> </pre><br>  Lamentablemente esto no funciona.  Incluso en MySQL 8, desafortunadamente es imposible crear un índice de texto completo simplemente por el campo JSON.  Por supuesto, me gustaría tener esa función: la capacidad de buscar al menos por teclas JSON sería muy útil. <br><br>  Pero si esto aún no es posible, creemos una columna virtual.  En nuestro caso, hay un campo de datos, y sería interesante para nosotros ver qué hay dentro. <br><br><pre> <code class="sql hljs">mysql&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> cloud_data_json_indexes -&gt; <span class="hljs-keyword"><span class="hljs-keyword">ADD</span></span> data_data <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">255</span></span>) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">GENERATED</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ALWAYS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>-&gt;&gt;<span class="hljs-string"><span class="hljs-string">'$.data'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">VIRTUAL</span></span>; Query OK, 0 rows affected (0.01 sec) Records: 0 Duplicates: 0 Warnings: 0 mysql&gt; <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> cloud_data_json_indexes <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> fulltext <span class="hljs-keyword"><span class="hljs-keyword">key</span></span> ft_json(data_name, data_data); ERROR 3106 (HY000): 'Fulltext index on virtual generated column' is not supported for generated columns.</code> </pre><br>  Desafortunadamente, esto tampoco funciona: <strong>no puede crear un índice de texto completo en una columna virtual</strong> . <br><br>  Si es así, creemos una columna almacenada.  MySQL 5.7 le permite declarar una columna como un campo almacenado. <br><pre> <code class="sql hljs">mysql&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> cloud_data_json_indexes -&gt; <span class="hljs-keyword"><span class="hljs-keyword">ADD</span></span> data_name <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">255</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">CHARACTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> UTF8MB4 -&gt; <span class="hljs-keyword"><span class="hljs-keyword">GENERATED</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ALWAYS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>-&gt;&gt;<span class="hljs-string"><span class="hljs-string">'$.name'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">STORED</span></span>; Query OK, 123518 rows affected (1.75 sec) Records: 123518 Duplicates: 0 Warnings: 0 mysql&gt; <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> cloud_data_json_indexes <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> fulltext <span class="hljs-keyword"><span class="hljs-keyword">key</span></span> ft_json(data_name); Query OK, 0 rows affected, 1 warning (3.78 sec) Records: 0 Duplicates: 0 Warnings: 1 mysql&gt; <span class="hljs-keyword"><span class="hljs-keyword">show</span></span> <span class="hljs-keyword"><span class="hljs-keyword">warnings</span></span>; +<span class="hljs-comment"><span class="hljs-comment">------------+--------+---------------------------------------------------+ | Level | Code | Message | +------------+--------+---------------------------------------------------+ | Warning | 124 | InnoDB rebuilding table to add column FTS_DOC_ID | +------------+--------+---------------------------------------------------+</span></span></code> </pre><br>  En los ejemplos anteriores, creamos columnas virtuales que no se almacenan, pero se crean y almacenan índices.  En este caso, tuve que decirle a MySQL que se trata de una columna ALMACENADA, es decir, se creará y se copiarán los datos.  Después de eso, MySQL creó un índice de texto completo, para esto tuvimos que recrear la tabla.  Pero esta limitación es en realidad la búsqueda de texto completo de InnoDB e InnoDB: debe volver a crear la tabla para agregar un identificador de búsqueda de texto completo especial. <br><br>  Curiosamente, en MySQL 8 había una <strong>nueva codificación</strong> <strong>UTF8</strong> <strong>MB4 para emoticones</strong> .  Por supuesto, no del todo para ellos, pero porque en UTF8MB3 hay algunos problemas con el ruso, chino, japonés y otros idiomas. <br><br><pre> <code class="sql hljs">mysql&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> cloud_data_json_indexes -&gt; <span class="hljs-keyword"><span class="hljs-keyword">ADD</span></span> data_data <span class="hljs-built_in"><span class="hljs-built_in">TEXT</span></span> <span class="hljs-built_in"><span class="hljs-built_in">CHARACTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> UTF8MB4 -&gt; <span class="hljs-keyword"><span class="hljs-keyword">GENERATED</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ALWAYS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">CONVERT</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>-&gt;&gt;<span class="hljs-string"><span class="hljs-string">'$.data'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">USING</span></span> UTF8MB4) ) <span class="hljs-keyword"><span class="hljs-keyword">STORED</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Query</span></span> OK, <span class="hljs-number"><span class="hljs-number">123518</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span> affected (<span class="hljs-number"><span class="hljs-number">3.14</span></span> sec) <span class="hljs-keyword"><span class="hljs-keyword">Records</span></span>: <span class="hljs-number"><span class="hljs-number">123518</span></span> Duplicates: <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Warnings</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre><br>  En consecuencia, MySQL 8 debería almacenar datos JSON en UTF8MB4.  Pero ya sea por el hecho de que Node.js se conecta a Device Cloud, y algo está escrito allí incorrectamente, o es un error de versión beta, esto no sucedió.  Por lo tanto, tuve que convertir los datos antes de escribirlos en una columna almacenada. <br><br><pre> <code class="sql hljs">mysql&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> cloud_data_json_indexes <span class="hljs-keyword"><span class="hljs-keyword">DROP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span> ft_json, <span class="hljs-keyword"><span class="hljs-keyword">ADD</span></span> FULLTEXT <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span> ft_json(data_name, data_data); Query OK, 0 rows affected (1.85 sec) Records: 0 Duplicates: 0 Warnings: 0</code> </pre><br>  Después de eso, pude crear una búsqueda de texto completo en dos campos: en el nombre JSON y en los datos JSON. <br><br><h2>  No solo IoT <br></h2><br>  JSON no es solo el Internet de las cosas.  Se puede usar para otras cosas interesantes: <br><br><ul><li>  Campos personalizados (CMS); </li><li>  Estructuras complejas, etc. </li></ul><br>  Algunas cosas pueden implementarse de manera mucho más conveniente utilizando un esquema de almacenamiento de datos flexible.  Oracle OpenWorld proporcionó un excelente ejemplo: reservas de cine.  Es muy difícil implementar esto en el modelo relacional: obtienes muchas tablas dependientes, uniones, etc.  Por otro lado, podemos almacenar toda la sala como una estructura JSON, respectivamente, escribirla en MySQL en otras tablas y usarla de la manera habitual: crear índices basados ​​en JSON, etc.  <b>Las estructuras complejas se almacenan convenientemente en formato JSON.</b> <br><br><img src="https://habrastorage.org/webt/9m/i3/th/9mi3thcaas9caominanputmpaua.jpeg"><br><br>  Este es un árbol que se ha plantado con éxito.  Desafortunadamente, unos años más tarde, los ciervos se lo comieron, pero esta es una historia completamente diferente. <br><br><blockquote>  Este informe es un excelente ejemplo de cómo una sección completa se desarrolla a partir de un tema en una conferencia grande, y luego un evento separado por separado.  En el caso de Internet de las cosas, obtuvimos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">InoThings ++</a> , una conferencia para profesionales en el mercado de Internet de las cosas, que se realizará por segunda vez el 4 de abril. <br><br>  Parece que el evento central de la conferencia será la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">mesa redonda</a> "¿Necesitamos estándares nacionales en Internet de las cosas?", Que orgánicamente se complementará con <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">informes</a> completos aplicados.  Ven si tus sistemas con mucha carga se están moviendo correctamente a IIoT. <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/443422/">https://habr.com/ru/post/443422/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../443408/index.html">Fotones, cuantos y estado de Fock: manipulaciones a nivel cuántico con un resonador de radiofrecuencia</a></li>
<li><a href="../443412/index.html">Por qué los programadores continúan usando Java detallado, aunque hay Python conciso</a></li>
<li><a href="../443414/index.html">Poste indicador: cuando los puntos de interrupción no son suficientes</a></li>
<li><a href="../443416/index.html">Winnti: un ataque a las cadenas de suministro: los desarrolladores de juegos asiáticos están a la vanguardia</a></li>
<li><a href="../443418/index.html">Métodos de prueba de software</a></li>
<li><a href="../443424/index.html">Reescribiendo el caso de prueba para frontend junior a TypeScript y react-hooks</a></li>
<li><a href="../443426/index.html">Marca negra: cómo OpenShift protege contra las vulnerabilidades del contenedor con SELinux</a></li>
<li><a href="../443428/index.html">Palmer Lucky, el "padre" de Oculus Rift, está desarrollando un sistema virtual de campo de batalla para el Pentágono</a></li>
<li><a href="../443430/index.html">¿Por qué es malo cuando Internet sabe todo sobre ti?</a></li>
<li><a href="../443432/index.html">Blazor 0.9.0 lanzado</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>