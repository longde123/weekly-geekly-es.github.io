<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòÖ üëò üßê Dagaz: Ein neuer Anfang ü§õüèº üëä üê£</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Es l√§uft nach S√ºden und kreist nach Norden, kreist, um mit dem Wind zu rennen 
 Und nach seinen Kreisl√§ufen kehrt der Wind zur√ºck; 
 Alle Fl√ºsse m√ºnde...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Dagaz: Ein neuer Anfang</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/481868/"><img align="left" src="https://habrastorage.org/webt/4i/sc/k4/4isck4toxbws20hsk3nrqghdkoy.png">  <b><i>Es l√§uft nach S√ºden und kreist nach Norden, kreist, um mit dem Wind zu rennen</i></b> <b><i><br></i></b>  <b><i>Und nach seinen Kreisl√§ufen kehrt der Wind zur√ºck;</i></b> <b><i><br></i></b>  <b><i>Alle Fl√ºsse m√ºnden ins Meer - und das Meer flie√üt nicht √ºber,</i></b> <b><i><br></i></b>  <b><i>Zu dem Ort, wo die Fl√ºsse flie√üen, - Dort flie√üen sie weiter;</i></b> <b><i><br><br></i></b>  <b><i><a href="https://www.biblegateway.com/passage/%3Fsearch%3DEcclesiastes%2B1" rel="nofollow">Das Buch der Prediger</a></i></b> <br><br>  1998 wurde eine f√ºr diese Zeit v√∂llig einzigartige Anwendung entwickelt, mit der Sie den Prozess der Entwicklung eines abstrakten Brettspiels (oder Puzzles) auf eine kleine Textbeschreibungssprache reduzieren k√∂nnen, die vage an <a href="https://en.wikipedia.org/wiki/Lisp_(programming_language)" rel="nofollow">Lisp</a> erinnert.  Dieses Projekt hie√ü <a href="http://www.zillions-of-games.com/" rel="nofollow">Zillions of Games</a> .  Es sorgte bei Fans von Brettspielen f√ºr Furore.  Derzeit wurden mit dieser Technologie √ºber 2.000 Anwendungen erstellt. <br><a name="habracut"></a><br>  Es wurde schnell klar, dass ZoG viele Nachteile hat.  Ich habe bereits in Habr dar√ºber geschrieben und werde mich nicht wiederholen.  Lassen Sie mich nur sagen, dass die Entwickler die Funktionen einer gro√üen Anzahl vorhandener Spiele nicht ber√ºcksichtigt haben und einige wichtige Optionen fest programmiert wurden, so dass ihre √Ñnderung √§u√üerst problematisch wurde.  Greg Schmidt versuchte 2007, die Situation durch die Ver√∂ffentlichung des <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi%3Fdo%3Dshow%3Bid%3D1452" rel="nofollow">Axiom Development Kit</a> zu korrigieren, aber seine enge Integration in ZoG erlaubt nicht, alle Probleme zu l√∂sen. <br><br>  Projekt <a href="http://cambolbro.com/cv/publications/ciaig-browne-maire-19.pdf" rel="nofollow">Ludi</a> wies auf neue Grenzen hin und verwendete die universelle Spiel-Engine und <a href="https://en.wikipedia.org/wiki/Genetic_algorithm" rel="nofollow">genetische Algorithmen,</a> um den Entwicklungsprozess neuer Brettspiele zu automatisieren.  Leider wurde dieser Ansatz urspr√ºnglich als bewusste Vereinfachung der Spielmechanik und des Niveaus der eingesetzten KI ins Auge gefasst.  Die Diskussion der Ziele dieses Projekts w√ºrde den Rahmen dieses Artikels sprengen, aber einige seiner technischen L√∂sungen dienten zweifellos als Ausgangspunkt f√ºr meine eigene Entwicklung. <br><br>  Mein Ziel ist die Entwicklung einer vielseitigeren und benutzerfreundlicheren "Engine" f√ºr die Erstellung abstrakter Brettspiele.  Ich habe fast ein Jahr lang die M√∂glichkeiten von ZoG und Axiom studiert und viel √ºber deren Grenzen gelernt.  Ich denke, ich kann ihre Probleme l√∂sen, indem ich eine universellere und plattform√ºbergreifendere L√∂sung schaffe.  √úber den Fortgang der Arbeiten an diesem Projekt werde ich berichten. <br><br><h2>  Offenheit und Modularit√§t </h2><br>  M√∂glicherweise ist der Hauptnachteil von ZoG seine Schlie√üung.  Das Produkt wurde "einmal und f√ºr immer" unter einer einzigen Plattform - Windows - zusammengestellt.  W√§re es Open-Source-Code, k√∂nnte man versuchen, ihn unter Linux, Android, iOS ... zu portieren. Ein weiteres Problem ist seine Monolithizit√§t. <br><br>  In ZoG gibt es die Anf√§nge der Modularit√§t, die die Verbindung zur Spiele-DLL erm√∂glicht, einschlie√ülich benutzerdefinierter Implementierungen der KI.  Axiom geht noch einen Schritt weiter und erm√∂glicht es Ihnen, Anwendungen im Modus Autoplay auszuf√ºhren, ohne den ZoG-Kernel zu verwenden.  Ungeachtet der schwerwiegenden Einschr√§nkung dieser L√∂sung (Unterst√ºtzung von Anwendungen nur f√ºr zwei Spieler) zeigt dieses Beispiel, wie hilfreich Modularit√§t w√§re!  Die M√∂glichkeit, ein Spiel mit zwei Bots (mit unterschiedlichen KI-Einstellungen) zu organisieren und Statistiken √ºber eine gro√üe Anzahl von Spielen zu sammeln, kann nicht √ºbersch√§tzt werden.  Aber wie viel besser w√§re es, wenn das Produkt vollst√§ndig modular w√§re! <br><br><ul><li>  Generierungsmodul verschieben </li><li>  Ausf√ºhrungsmodul verschieben </li><li>  Steuermodul </li><li>  AI-Modul </li><li>  Visualisierungsmodul </li></ul><br>  Alle Arbeiten, die die Spiele beschreiben, m√ºssen vom Modul zur Erstellung von Z√ºgen ausgef√ºhrt werden.  Dies ist das ‚ÄûHerz‚Äú des Projekts.  Durch die √úbertragung aller mit dieser Funktion nicht verbundenen Aufgaben auf andere Module wird dies so einfach wie m√∂glich.  Sie k√∂nnen dieses Modul verbessern, ohne auf AI-Probleme und Benutzerinteraktion zu achten.  Sie k√∂nnen das Format der Beschreibung von Spielen vollst√§ndig √§ndern oder die Beschreibungen im Format von ZoG, Axiom und Ludi unterst√ºtzen.  Modularit√§t ist die Basis der Flexibilit√§t der L√∂sung! <br><br>  Das Bewegungsausf√ºhrungsmodul ist der Verwalter des Spielzustands.  Informationen zum aktuellen Spielstand werden bei Bedarf an alle anderen Module √ºbertragen.  Aus Gr√ºnden, die ich im Folgenden erl√§utern werde, muss der Ausf√ºhrungsfortschritt das Generierungsmodul durchlaufen, dessen Aufgabe die Bildung eines Befehls im Hinblick auf die Modulausf√ºhrung ist.  Die Aufgabe des Bewegungsgenerierungsmoduls ist auch die prim√§re Konfiguration des Spielraums basierend auf der Beschreibung des Spiels. <br><br>  Das Steuermodul ist in der Tat die Anwendung selbst.  Es fragt das Zugerzeugungsmodul nach einer Liste m√∂glicher Z√ºge und √§ndert den Spielstatus, wobei der ausgew√§hlte Zug an das Zugausf√ºhrungsmodul √ºbergeben wird.  Das Steuermodul kann angeschlossen werden, um einen oder mehrere KI-Bots zu spielen.  So viele wie Sie brauchen (und m√∂glicherweise anders)!  Die Art der Steuerung richtet sich nach der Aufgabenteilung.  Dies kann eine automatische Wiedergabe zum Sammeln von Spielstatistiken, ein Spieleserver (der mehrere Statusspeicher steuern kann und eine gro√üe Anzahl von Spielsitzungen leitet) oder einzelne Anwendungen zum Offline-Spielen sein. <br><br>  Die M√∂glichkeit, verschiedene AI-Implementierungen miteinander zu verbinden, verbessert die Qualit√§t des Spiels.  Es versteht sich, dass die Module f√ºr das Schach- und Go-Spiel unterschiedliche Ans√§tze verwenden sollten.  Spiele mit unvollst√§ndigen Informationen und Spiele mit zuf√§lligen Daten erfordern ebenfalls eine individuelle Herangehensweise.  Die universelle Implementierung von KI wird in allen Spielen gleich schlecht sein!  Die modulare Verbindungs-KI erm√∂glicht den Vergleich der ‚ÄûSt√§rke‚Äú der Algorithmen, einschlie√ülich eines Spielemodus ‚Äûmiteinander‚Äú. Da die KI-Architektur vom Speicherstatus des Spiels getrennt ist, kann eine Instanz des Spielebots eine unbegrenzte Anzahl unterst√ºtzen von Spielsitzungen gleichzeitig. <br><br>  Die Visualisierung des Spielprozesses kann ebenfalls variiert werden.  Das erste, was mir in den Sinn kommt, sind 2D- und 3D-Implementierungen.  Die Plattform, f√ºr die die Anwendung entwickelt wird, ist ebenfalls wichtig.  Weniger offensichtlich ist, dass Visualisierung ein wichtiger Teil des Spiels sein kann!  Zum Beispiel ist es im Spiel <a href="https://glukkazan.github.io/elimination/surakarta.htm" rel="nofollow">Surakarta</a> v√∂llig un√ºbersehbar, Teile zu nehmen, wenn die Bewegungen nicht richtig animiert sind. <br><br><div style="text-align:center;"> <a href="https://glukkazan.github.io/elimination/surakarta.htm" rel="nofollow"><img src="https://habrastorage.org/files/9ad/1cd/c7c/9ad1cdc7c76041dc8776c5f4cb1a086a.jpg"></a> </div><br>  Im Allgemeinen scheint Modularit√§t eine gute Idee f√ºr ein solches Projekt zu sein, und Open Source Code erm√∂glicht es jedem, der sich an dem Projekt beteiligen m√∂chte.  Gegenw√§rtig setze ich mich nicht zu kommerziellen Zwecken, denke aber, dass ich auf Wunsch einen Weg finden werde, Geld zu verdienen, ohne den Quellcode zu schlie√üen. <br><br><h2>  Der Spielraum </h2><br>  Bevor Sie mit der Show beginnen, m√ºssen Sie die B√ºhne einrichten.  Das Brett ist nicht nur ein Ort, an dem die Teile angeordnet sind.  Daneben kann die Bewegungsrichtung der Spielsteine ‚Äã‚Äãbestimmt werden (in der Tat die Verbindungen zwischen den Brettpositionen), Spielfelder (z. B. Bereiche zur Umwandlung von Spielsteinen), verbotene Felder usw.  So sieht die Definition des Schachbretts in der ZoG-Implementierung aus: <br><br><div class="spoiler">  <b class="spoiler_title">Das Board in ZoG definieren</b> <div class="spoiler_text"><pre><code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">define</span></span> Board-Definitions (<span class="hljs-name"><span class="hljs-name">image</span></span> <span class="hljs-string"><span class="hljs-string">"images\Chess\SHaag\Chess8x8.bmp"</span></span> <span class="hljs-string"><span class="hljs-string">"images\Chess\Chess8x8.bmp"</span></span>) (<span class="hljs-name"><span class="hljs-name">grid</span></span> (<span class="hljs-name"><span class="hljs-name">start-rectangle</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">53</span></span> <span class="hljs-number"><span class="hljs-number">53</span></span>) (<span class="hljs-name"><span class="hljs-name">dimensions</span></span> (<span class="hljs-string"><span class="hljs-string">"a/b/c/d/e/f/g/h"</span></span> (<span class="hljs-number"><span class="hljs-number">49</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>)) <span class="hljs-comment"><span class="hljs-comment">; files ("8/7/6/5/4/3/2/1" (0 49)) ; ranks ) (directions (n 0 -1) (e 1 0) (s 0 1) (w -1 0) (ne 1 -1) (nw -1 -1) (se 1 1) (sw -1 1) ) ) (symmetry Black (ns)(sn) (nw sw)(sw nw) (ne se)(se ne)) (zone (name promotion-zone) (players White) (positions a8 b8 c8 d8 e8 f8 g8 h8) ) (zone (name promotion-zone) (players Black) (positions a1 b1 c1 d1 e1 f1 g1 h1) ) (zone (name third-rank) (players White) (positions a3 b3 c3 d3 e3 f3 g3 h3) ) (zone (name third-rank) (players Black) (positions a6 b6 c6 d6 e6 f6 g6 h6) ) )</span></span></code> </pre> </div></div><br>  M√∂glicherweise stellen Sie fest, dass neben den Spieleinstellungen auch die mit der Visualisierung verbundenen Einstellungen vorhanden sind.  Ich bin fest davon √ºberzeugt, dass diese Einstellungen nicht hierher geh√∂ren.  Bei der Implementierung eines Visualisierungsmoduls k√∂nnen mehrere Einstellungen verwendet werden, und m√∂glicherweise sind unterschiedliche Einstellungen erforderlich.  Dar√ºber hinaus k√∂nnen Simulationsspiele ohne Visualisierungsmodul ausgef√ºhrt werden (wie Autoplay in Axiom).  Da Axiom zur Visualisierung von ZoG verwendet wird, enth√§lt die Definition nichts √úberfl√ºssiges: <br><br><div class="spoiler">  <b class="spoiler_title">Das Board in Axiom definieren</b> <div class="spoiler_text"><pre> <code class="perl hljs">{board <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-string"><span class="hljs-string">{grid}</span></span> board} {directions -<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-string"><span class="hljs-string">{direction}</span></span> n <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-string"><span class="hljs-string">{direction}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">s</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-string"><span class="hljs-string">{direction}</span></span> e <span class="hljs-number"><span class="hljs-number">0</span></span> -<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-string"><span class="hljs-string">{direction}</span></span> w -<span class="hljs-number"><span class="hljs-number">1</span></span> -<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-string"><span class="hljs-string">{direction}</span></span> nw <span class="hljs-number"><span class="hljs-number">1</span></span> -<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-string"><span class="hljs-string">{direction}</span></span> sw -<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-string"><span class="hljs-string">{direction}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ne</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-string"><span class="hljs-string">{direction}</span></span> se directions} {symmetries Black <span class="hljs-string"><span class="hljs-string">{symmetry}</span></span> ns Black <span class="hljs-string"><span class="hljs-string">{symmetry}</span></span> nw sw Black <span class="hljs-string"><span class="hljs-string">{symmetry}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ne</span></span> se symmetries}</code> </pre></div></div><br>  Leider hat Axiom auch keine M√∂glichkeit, Spielzonen zu bestimmen (die Position der Spielzonen muss manuell im Code festgelegt werden).  Dies ist nicht die einzige Vereinfachung von Axiom.  Die Definition der Platine in diesem Projekt darf nicht mehr als ein Raster enthalten, und dieses Raster muss zweidimensional sein.  Die so definierte Karte ist ein eindimensionales Array, aber zur Vereinfachung des Programmierers werden Synonyme f√ºr jeden der R√§ume wie folgt definiert: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/4d2/76d/a04/4d276da04e6542a385c3c30deeb6872f.PNG"></div><br>  Verglichen mit dem flexibleren Schema der Rasterdefinition in ZoG sind diese Einschr√§nkungen ziemlich unangenehm (insbesondere angesichts der Tatsache, dass das auferlegte Benennungsschema diese Felder zum Zwecke der Visualisierung verwendet hat).  Gl√ºcklicherweise ist es m√∂glich, eine Tafel beliebiger Form zu definieren.  Sowohl Axiom als auch ZoG bieten die M√∂glichkeit, jede Position auf dem Board elementweise zu identifizieren und die Verkn√ºpfungen zwischen beliebigen Positionspaaren zu bestimmen.  Mit diesem Ansatz k√∂nnen wir eine Karte mit einer beliebigen Topologie definieren.  Der einzige Nachteil ist die extreme Ausf√ºhrlichkeit und Komplexit√§t der Beschreibung. <br><br>  Zus√§tzlich zur Position der Spielsteine ‚Äã‚Äãauf der Tafel und in der Reserve sollte das System die M√∂glichkeit haben, Attribute f√ºr einzelne Spielsteine ‚Äã‚Äãund f√ºr die Felder auf der Tafel zu speichern.  Ein gutes Beispiel f√ºr die Notwendigkeit, die Attribute einer Regel des ‚Äû <a href="https://en.wikipedia.org/wiki/Castling" rel="nofollow">Rochierens</a> ‚Äú im <a href="https://en.wikipedia.org/wiki/Chess" rel="nofollow">Schach zu verwenden</a> .  Dies ist ein schwieriger Zug, der die gleichzeitige Bewegung von K√∂nig und Turm beinhaltet, vorausgesetzt, dass sich keine dieser Figuren bewegt hat, bevor dieser Zug ausgef√ºhrt wurde.  Ein Attribut k√∂nnte verwendet werden, um ein Boolesches Tag zu speichern, das anzeigt, ob sich das Teil jemals bewegt hat.  Feldattribute k√∂nnen auch einige interessante Anwendungen finden. <br><br>  Es sollte beachtet werden, dass Attribute nicht nur Variablen sind, sondern Teil des Spielstatus.  Ein Attributwert kann durch die Ausf√ºhrung einer Runde (einschlie√ülich des AI-Moduls) ge√§ndert werden und sollte f√ºr alle nachfolgenden Runden verf√ºgbar sein, jedoch nicht f√ºr Runden, die in einem anderen Zweig des Spiels ausgef√ºhrt werden.  Derzeit unterst√ºtzt ZoG das Speichern von Booleschen Attributen von Teilen.  Axiom-Speicherattribute werden nicht unterst√ºtzt, aber Sie k√∂nnen der Definition der Karte eine Beschreibung der Variablen und Arrays hinzuf√ºgen.  Diese Variablen k√∂nnen verwendet werden, z. B. Z√§hler f√ºr die Anzahl der erfassten Teile: <br><br><pre> <code class="perl hljs">{board <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">18</span></span> <span class="hljs-string"><span class="hljs-string">{grid}</span></span> <span class="hljs-string"><span class="hljs-string">{variable}</span></span> WhitePieces <span class="hljs-string"><span class="hljs-string">{variable}</span></span> BlackPieces board}</code> </pre> <br>  Eine weitere Einschr√§nkung von ZoG und Axiom ist die Regel, dass jede Position der Tafel nicht mehr als ein St√ºck enthalten darf.  Wenn ein Teil einen Zug zu einer Position vollendet, die von einem anderen Teil besetzt ist, wird das Teil, das zuvor die Position besetzt hatte, automatisch als "gegessen" betrachtet.  Diese Regel passt gut zum Schachprinzip und dient der Vereinfachung der Beschreibung dieses Spiels, erschwert jedoch die Implementierung von Spielen wie " <a href="http://www.iggamecenter.com/info/en/bashni.html" rel="nofollow">bashni checkers</a> " und " <a href="http://www.iggamecenter.com/info/en/tavreli.html" rel="nofollow">tavreli</a> ". <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/455/804/146/45580414699f406281745176b1d91d9b.JPG"></div><br><br>  In diesen Spielen k√∂nnen St√ºcke in "Spalten" angeordnet werden.  Eine solche ‚ÄûS√§ule‚Äú kann zusammen als ein St√ºck bewegt werden.  Nach einiger √úberlegung entschied ich, dass es besser ist, die automatische Implementierung der Schach-Erfassung nicht aufzugeben, sondern die Mechanismen zum Verschieben von Gruppen von St√ºcken zu verbessern.  In der Tat k√∂nnen Sie f√ºr die Implementierung der ‚ÄûS√§ulen‚Äú immer eine andere Dimension hinzuf√ºgen (dies ist besonders einfach, solange das Visualisierungsmodul vom Bewegungserzeugungsmodul und von der KI getrennt ist und Sie eine beliebige Logik verwenden k√∂nnen zum Rendern der dreidimensionalen Tafel in ihre zweidimensionale Visualisierung).  Ein weiteres Argument f√ºr diese Entscheidung war, dass die ‚Äûhoch gestapelte‚Äú Bewegung von Teilen nicht die einzige Art der Gruppenreise ist.  Beispielsweise k√∂nnen in ‚Äû <a href="https://s3-eu-west-1.amazonaws.com/mosigra.product.other/522/067/pentago.pdf" rel="nofollow">Pentago</a> ‚Äú <a href="https://s3-eu-west-1.amazonaws.com/mosigra.product.other/522/067/pentago.pdf" rel="nofollow">Brettfragmente</a> zusammen mit den darauf montierten St√ºcken gedreht werden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/3f9/8db/7ba/3f98db7ba32042ec8dff2eb42878fa2e.jpg"></div><br>  Zusammenfassend kann ich sagen, dass ich f√ºr mein Spiel-Framework alles Gute aus ZoG, Axiom und Ludi herausgesucht habe und alles hinzuf√ºge, was meiner Meinung nach fehlt. <br><br><h2>  Generation bewegen </h2><br>  Die Generierung von Verschiebungen √§hnelt der <a href="https://en.wikipedia.org/wiki/Nondeterministic_programming" rel="nofollow">nicht deterministischen Programmierung</a> .  Die Aufgabe des Bewegungsgenerators besteht darin, auf Anfrage eine Liste aller m√∂glichen Bewegungen von der aktuellen Position aus bereitzustellen.  Welcher Zug aus dieser Liste von einem Spieler oder einer KI ausgew√§hlt wird, ist nicht ihre Funktion.  Mal sehen, wie die Erzeugung von Z√ºgen in ZoG erfolgt.  Als Beispiel nehmen wir das Makro zur Erzeugung von Z√ºgen f√ºr ein St√ºck mit gro√üer Reichweite (eine K√∂nigin oder ein Bischof).  So wird es bei der Bestimmung der Z√ºge f√ºr diese Teile verwendet: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">piece</span></span> (<span class="hljs-name"><span class="hljs-name">name</span></span> Bishop) (<span class="hljs-name"><span class="hljs-name">image</span></span> White <span class="hljs-string"><span class="hljs-string">"images\Chess\SHaag\wbishop.bmp"</span></span> <span class="hljs-string"><span class="hljs-string">"images\Chess\wbishop.bmp"</span></span> Black <span class="hljs-string"><span class="hljs-string">"images\Chess\SHaag\bbishop.bmp"</span></span> <span class="hljs-string"><span class="hljs-string">"images\Chess\bbishop.bmp"</span></span>) (<span class="hljs-name"><span class="hljs-name">moves</span></span> (<span class="hljs-name"><span class="hljs-name">slide</span></span> ne) (<span class="hljs-name"><span class="hljs-name">slide</span></span> nw) (<span class="hljs-name"><span class="hljs-name">slide</span></span> se) (<span class="hljs-name"><span class="hljs-name">slide</span></span> sw) ) )</code> </pre> <br>  Als Parameter wird einem Makro die Bewegungsrichtung auf der Platine √ºbergeben.  Wenn Sie nicht die M√∂glichkeit in Betracht ziehen, neue Figuren auf dem Brett zu installieren, sieht die Erzeugung eines Zuges einfach aus.  F√ºr jede Figur auf dem Brett werden alle m√∂glichen Z√ºge nach den Regeln berechnet.  Dann beginnt die Magie ... <br><br>  Jede der Definitionen kann der Liste eine Reihe von m√∂glichen Z√ºgen hinzuf√ºgen!  Das Hinzuf√ºgen eines Zuges zur Liste erfolgt mit dem Befehl add (wobei gleichzeitig jedes bewegliche Teil auf dem Brett positioniert wird).  Ich habe bereits dar√ºber geschrieben, wie schlecht diese architektonische L√∂sung ist.  Der Befehl zur Bildung des Zuges sollte von den Befehlen zur Manipulation von St√ºcken (wie in Axiom) getrennt werden.  Mal sehen, wie das Makro funktioniert: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">define</span></span> slide ( $<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">while</span></span> empty? add $<span class="hljs-number"><span class="hljs-number">1</span></span> ) (<span class="hljs-name"><span class="hljs-name">verify</span></span> not-friend?) add ))</code> </pre> <br><br>  Zuerst wird die Verschiebung von einer Zelle in der gegebenen Richtung ausgef√ºhrt, dann wird in einem Zyklus der erreichte Raum auf das Fehlen der darauf befindlichen Teile √ºberpr√ºft, eine Bewegung wird gebildet und die Anordnung schreitet in der gleichen Richtung zu einer anderen Zelle fort.  Wenn Sie hier anhalten, kann das Teil durch leere Zellen "gleiten", aber wie k√∂nnen Sie feindliche Teile nehmen? <br><br>  Sehr einfach!  Nachdem wir den Befehl verify ausgef√ºhrt haben und √ºberpr√ºft haben, dass das Feld nicht von einem befreundeten Teil belegt ist, bilden wir einen weiteren Befehl add, der den Verschiebevorgang abschlie√üt.  Wenn sich in dieser Zelle eine gegnerische Figur befunden hat, wird sie automatisch genommen (wie auf einem Feld des Spielbretts kann man zu einem Zeitpunkt nicht mehr als eine Figur haben).  Wenn das Teil befreundet war, wird die Berechnung des Zuges mit dem Befehl verify abgebrochen (ein Versto√ü gegen die in diesem Befehl angegebenen Bedingungen beendet sofort die Berechnung des aktuellen Zuges). <br><br>  Sowohl in ZoG als auch in Axiom kann man nur die eigenen Figuren bewegen (oder besser gesagt, es ist m√∂glich, die gegnerischen Figuren zu bewegen, aber nur, wenn dies in der Berechnungsmethode f√ºr einen Zug einer eigenen Figur angegeben ist).  Ich finde dies eine √§u√üerst unbequeme Einschr√§nkung, da es viele Spiele gibt, in denen Sie die gegnerische Figur direkt bewegen k√∂nnen (zum Beispiel in ‚Äû <a href="https://glukkazan.github.io/checkers/stavropol-checkers.htm" rel="nofollow">Stavropol Checkers</a> ‚Äú).  Es w√§re konsistenter, die Bewegungsberechnung f√ºr alle Teile durchzuf√ºhren, unabh√§ngig von ihrer Zugeh√∂rigkeit.  In dem Makro, das den Zug bestimmt, m√ºsste nur ein H√§kchen hinzugef√ºgt werden, damit nur die eigenen Figuren bewegt werden k√∂nnen: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">define</span></span> slide ( (<span class="hljs-name"><span class="hljs-name">verify</span></span> friend?) $<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">while</span></span> empty? add $<span class="hljs-number"><span class="hljs-number">1</span></span> ) (<span class="hljs-name"><span class="hljs-name">verify</span></span> not-friend?) add ))</code> </pre> <br><br>  Wichtig ist die F√§higkeit, einen Zug auszuf√ºhren, der aus mehreren ‚ÄûTeilz√ºgen‚Äú besteht.  Bei der Implementierung von Entw√ºrfen wird diese F√§higkeit verwendet, um "Ketten" -Erfassungen durchzuf√ºhren: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">define</span></span> checker-jump ($<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">verify</span></span> enemy?) capture $<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">verify</span></span> empty?) (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">not-in-zone</span></span>? promotion-zone) (<span class="hljs-name"><span class="hljs-name">add-partial</span></span> jumptype) else (<span class="hljs-name"><span class="hljs-name">add-partial</span></span> King jumptype) ) ) )</code> </pre> <br><br>  Der Teilbewegungsbefehl wird mit add-partial gebildet (f√ºr diesen Befehl sowie f√ºr den Befehl add gibt es eine Variation der Bewegung mit ‚ÄûTransformation‚Äú der Teile).  Ein solcher Zug ist immer Teil eines gr√∂√üeren, zusammengesetzten Zuges.  In der Regel wird f√ºr nachfolgende Z√ºge ein "Modus" eingestellt, den die Fortsetzung implementieren soll.  In Checkern kann eine Erfassung nur mit den folgenden Erfassungen fortgesetzt werden, jedoch nicht mit einer ‚Äûweichen‚Äú (nicht erfassenden) Bewegung. <br><br><div class="spoiler">  <b class="spoiler_title">Hinweis</b> <div class="spoiler_text">  In ZoG ist die Umsetzung von Teilbewegungen schlecht.  Der Versuch, den Befehl add-partial in einem Zyklus auszuf√ºhren, f√ºhrt zu einem Fehler.  Infolgedessen kann die von einem Damek√∂nig durchgef√ºhrte Erfassung nur auf folgende sehr umst√§ndliche Weise realisiert werden: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">define</span></span> king-jump-1 ($<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">while</span></span> empty? $<span class="hljs-number"><span class="hljs-number">1</span></span> ) (<span class="hljs-name"><span class="hljs-name">verify</span></span> enemy?) capture $<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">verify</span></span> empty?) (<span class="hljs-name"><span class="hljs-name">add-partial</span></span> jumptype) ) ) (<span class="hljs-name"><span class="hljs-name">define</span></span> king-jump-2 ($<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">while</span></span> empty? $<span class="hljs-number"><span class="hljs-number">1</span></span> ) (<span class="hljs-name"><span class="hljs-name">verify</span></span> enemy?) capture $<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">verify</span></span> empty?) $<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">verify</span></span> empty?) (<span class="hljs-name"><span class="hljs-name">add-partial</span></span> jumptype) ) )</code> </pre> <br>  Und so weiter, bis King-Jump-7!  Lassen Sie mich daran erinnern, dass der K√∂nig bei den meisten Dame-Varianten mit einem ‚Äûweitreichenden‚Äú K√∂nig nach jeder Erfassung auf einem beliebigen Feld einer fortlaufenden Kette von leeren Feldern anhalten kann, die dem erfassten Feld folgt.  Es gibt √ºbrigens eine Variante dieses Spiels, bei der die "Chain" -Erfassungsregel anders formuliert ist.  Das ist genau das, was ich an Dame mag - jeder kann eine Variante finden, die seinem Geschmack entspricht. <br></div></div><br>  Ein solches System zur Beschreibung der Regeln ist sehr flexibel, aber manchmal ist eine komplexere Logik erforderlich.  Wenn das Teil beispielsweise w√§hrend des "teilweisen" Fortschritts nicht erneut durch ein zuvor durchquertes Feld laufen soll, ist es logisch, die mit Positionen auf der Tafel verbundenen Flags zu verwenden.  Nachdem wir einen Raum besucht haben, setzen wir eine Flagge, um anschlie√üend nicht wieder in diesen Raum zu gehen: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">verify</span></span> (<span class="hljs-name"><span class="hljs-name">not-position-flag</span></span>? my-flag)) (<span class="hljs-name"><span class="hljs-name">set-position-flag</span></span> my-flag true)</code> </pre> <br>  Zus√§tzlich zu Positionsflags k√∂nnen Sie in ZoG globale Flags verwenden.  Diese Funktionen d√ºrfen nicht mit den Attributen von Teilen verwechselt werden.  Im Gegensatz zu letzteren sind diese nicht Teil des Spielstatus.  Leider k√∂nnen sowohl Attribute von Teilen als auch Flags in ZoG nur boolesch sein (in Axiom werden Attribute nicht einmal unterst√ºtzt).  Diese Einschr√§nkung erschwert die Durchf√ºhrung von Operationen, die mit den verschiedenen Z√§hlarten verbunden sind.  Zum Beispiel musste ich in <a href="http://zillions-of-games.com/cgi-bin/zilligames/submissions.cgi%3Fdo%3Dshow%3Bid%3D2233" rel="nofollow">diesem</a> kleinen Puzzle ein Paar boolescher Flaggen (die genaue Zahl, die ich nicht brauchte, solange die Teile mehr als eine waren) verwenden, um Teile zu z√§hlen, die in einer Gabel gefangen waren. <br><br>  Eine andere Sache, die behoben werden muss, ist das Fehlen eines klaren ‚ÄûLebenszyklus‚Äú bei der Ausf√ºhrung des Umzugs.  Alle Flags werden automatisch zur√ºckgesetzt, bevor der Umzug gestartet wird. Es ist jedoch einfacher, die Initialisierungsphase eindeutig zu identifizieren.  Meiner Meinung nach sollten bei der Berechnung des Umzugs die folgenden Phasen auftreten: <br><br><ol><li>  Initialisierung von Variablen und √úberpr√ºfung der Voraussetzungen f√ºr den Composite Move </li><li>  Initialisierung von Variablen und √úberpr√ºfung der Voraussetzungen f√ºr die Teilverschiebung </li><li>  Erzeugung des Teilzugs </li><li>  √úberpr√ºfung der Nachbedingungen des Teilzuges </li><li>  Generieren, Abschlie√üen und √úberpr√ºfen der Nachbedingungen des zusammengesetzten Verschiebens </li><li>  √úberpr√ºfung der Abbruchbedingungen des Spiels </li></ol><br>  Die Gruppe von Schritten vom zweiten bis zum vierten Schritt in der vollst√§ndigen zusammengesetzten Bewegung kann viele Male wiederholt werden.  Die Idee der Vor- und Nachbedingungen, die ich Invarianten nenne, habe ich aus dem Projekt Ludi √ºbernommen.  Ich erz√§hle Ihnen sp√§ter mehr √ºber die Verwendung von Invarianten. <br><br><h2>  √úber die Bedeutung der Notation </h2><br>  Die Generierung aller m√∂glichen Bewegungen von der Position aus ist nur die halbe Wahrheit.  Um den Spielstatus zu steuern, ist eine kompakte Darstellung der generierten Moves erforderlich.  In ZoG wird zu diesem Zweck die ZSG-Notation verwendet.  Hier ist ein Bericht √ºber einen m√∂glichen Beginn eines Schachspiels in dieser Form: <br><br><pre> <code class="perl hljs"><span class="hljs-number"><span class="hljs-number">1</span></span>. Pawn e2 - e4 <span class="hljs-number"><span class="hljs-number">1</span></span>. Pawn e7 - e5 <span class="hljs-number"><span class="hljs-number">2</span></span>. Knight g1 - f3 <span class="hljs-number"><span class="hljs-number">2</span></span>. Knight b8 - c6 <span class="hljs-number"><span class="hljs-number">3</span></span>. Bishop f1 - c4 <span class="hljs-number"><span class="hljs-number">3</span></span>. Knight g8 - f6 <span class="hljs-number"><span class="hljs-number">4</span></span>. King e1 - g1 Rook h1 - f1 @ f1 <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> @ g1 <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>. Pawn d7 - d5 <span class="hljs-number"><span class="hljs-number">5</span></span>. Pawn e4 <span class="hljs-keyword"><span class="hljs-keyword">x</span></span> d5 <span class="hljs-number"><span class="hljs-number">5</span></span>. Knight f6 <span class="hljs-keyword"><span class="hljs-keyword">x</span></span> d5</code> </pre> <br>  Dieses Skript entspricht in etwa der √ºblichen <a href="https://en.wikipedia.org/wiki/Chess_notation" rel="nofollow">Schachnotation</a> und ist allgemein benutzerfreundlich.  Nur der vierte Zug von Wei√ü kann Verwirrung stiften.  In der ZSG sieht es also nach <a href="https://en.wikipedia.org/wiki/Castling" rel="nofollow">Rochade aus</a> .  Der Teil der Beschreibung der Bewegung vor dem Zeichen '@' ist ziemlich klar.  es ist die gleichzeitige Bewegung von Turm und K√∂nig, aber was folgt?  In ZSG scheint daher ein Zur√ºcksetzen der Attribute der St√ºcke erforderlich zu sein, um die M√∂glichkeit einer wiederholten Rochade zu verhindern. <br><br><div class="spoiler">  <b class="spoiler_title">Hinweis</b> <div class="spoiler_text">  ZoG verwendet seine ZSG-Notation insbesondere, um den Spielverlauf in einer f√ºr den Spieler verst√§ndlichen Form darzustellen.  Auf der rechten Seite des Boards ist m√∂glicherweise ein Unterfenster "Moves List" ge√∂ffnet.  Diese Liste kann verwendet werden, um durch das aufgezeichnete Spiel zu navigieren.  Diese Liste ist nicht sehr praktisch, da eine verzweigte Baumansicht alternativer Spiele nicht unterst√ºtzt wird.  Der Teil der aufgezeichneten Umdrehungen, der mit √Ñnderungen der Attribute von Teilen verbunden ist, wird dem Benutzer nicht angezeigt. <br></div></div><br>  Die Aufzeichnung eines Zuges in ZSG-Notation sollte vollst√§ndige Informationen enthalten, die ausreichen, um den Spielstatus korrekt zu √§ndern.  Wenn Informationen √ºber eine √Ñnderung von Attributen verloren gehen, k√∂nnte in einem Spiel gem√§√ü einer solchen Aufzeichnung ein Zug f√§lschlicherweise wiederholt werden (zum Beispiel h√§tte der Spieler die M√∂glichkeit, die Rochade erneut auszuf√ºhren).  Leider k√∂nnen in DLL-Erweiterungen (wie Axiom) erweiterte Informationen nicht √ºbertragen werden. <br><br>  Bei der Arbeit mit DLL-Erweiterungen ist ZoG gezwungen, beim Positionieren auf eine ausgew√§hlte Bewegung (z. B. beim Zur√ºcksetzen einer Bewegung) eine recht raffinierte Manipulation vorzunehmen.  Aus [jeder] vorherigen Position [ab Spielbeginn] werden alle m√∂glichen Z√ºge generiert, und dann muss in dieser Liste mit der [entsprechenden] ZSG-Darstellung nach einem Zug gesucht werden.  Die [Nebenwirkungen von jedem] generierten Zug werden auf [jeden nachfolgenden] Spielzustand angewendet, da es m√∂glich ist, Nebenwirkungen auszuf√ºhren, die sich nicht in der ZSG-Darstellung des Zugs widerspiegeln. <br><br>  Die Situation wird durch die Tatsache erschwert, dass der einzige Weg, zum Zeitpunkt eines Spielzugs in der Vergangenheit in den Spielzustand zu gelangen, die konsequente Anwendung aller Spielz√ºge vom Beginn des Spiels bis zum Anfangszustand des Spielbretts ist.  In wirklich <a href="https://habr.com/ru/post/234587/">komplexen F√§llen</a> erfolgt diese Art der Navigation nicht schnell.  Ein weiterer Nachteil der ZSG-Notation ist die Aufzeichnung des folgenden Zuges im <a href="https://en.wikipedia.org/wiki/Go_(game)" rel="nofollow">Go-</a> Spiel: <br><br><pre> <code class="perl hljs"><span class="hljs-number"><span class="hljs-number">1</span></span>. White Stone G19 <span class="hljs-keyword"><span class="hljs-keyword">x</span></span> A19 <span class="hljs-keyword"><span class="hljs-keyword">x</span></span> B19 <span class="hljs-keyword"><span class="hljs-keyword">x</span></span> C19 <span class="hljs-keyword"><span class="hljs-keyword">x</span></span> D19 <span class="hljs-keyword"><span class="hljs-keyword">x</span></span> E19 <span class="hljs-keyword"><span class="hljs-keyword">x</span></span> F19</code> </pre> <br>  Hier wird in der Position G19 ein wei√üer Stein platziert, der eine Gruppe schwarzer Steine ‚Äã‚Äãerfasst.  Da alle an der Durchf√ºhrung der Platzierung beteiligten Teile in der ZSG-Auff√ºhrung erw√§hnt werden m√ºssen, kann die Aufzeichnung der Runde sehr lang erscheinen (in Go kann ein Tropfen bis zu 360 Steine ‚Äã‚Äãeinfangen).  Zu was das f√ºhren mag, habe ich <a href="https://habr.com/ru/post/235483/">fr√ºher geschrieben</a> .  Die f√ºr die Aufzeichnung der ZoG-Bewegung zugewiesene Puffergr√∂√üe reicht m√∂glicherweise nicht aus.  Wenn sich aus irgendeinem Grund die Reihenfolge der Entfernung von Steinen √§ndert (im Verlauf der Entwicklung des Spiels geschieht dies), schl√§gt der Versuch, einen Zug aus einer alten Reihenfolge von Eroberungen anzuwenden, fehl. <br><br>  Gl√ºcklicherweise gibt es eine einfache M√∂glichkeit, mit all diesen Problemen umzugehen.  Schauen wir uns an, wie Bewegungen von Teilen in ZRF definiert werden: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">piece</span></span> (<span class="hljs-name"><span class="hljs-name">name</span></span> Pawn) (<span class="hljs-name"><span class="hljs-name">image</span></span> White <span class="hljs-string"><span class="hljs-string">"images\Chess\SHaag\wpawn.bmp"</span></span> <span class="hljs-string"><span class="hljs-string">"images\Chess\wpawn.bmp"</span></span> Black <span class="hljs-string"><span class="hljs-string">"images\Chess\SHaag\bpawn.bmp"</span></span> <span class="hljs-string"><span class="hljs-string">"images\Chess\bpawn.bmp"</span></span>) (<span class="hljs-name"><span class="hljs-name">moves</span></span> (<span class="hljs-name"><span class="hljs-name">Pawn-capture</span></span> nw) (<span class="hljs-name"><span class="hljs-name">Pawn-capture</span></span> ne) (<span class="hljs-name"><span class="hljs-name">Pawn-move</span></span>) (<span class="hljs-name"><span class="hljs-name">En-Passant</span></span> e) (<span class="hljs-name"><span class="hljs-name">En-Passant</span></span> w) ) )</code> </pre> <br>  In ZoG-Makros definierte Zugnamen sind als Generatoren von Z√ºgen nicht zug√§nglich.  Aber was hindert uns daran, Makros aufzugeben und die Bewegungen mit ihren Namen zu beschreiben?  So w√ºrde die Platte f√ºr ein Schachspiel aussehen: <br><br><pre> <code class="perl hljs"><span class="hljs-number"><span class="hljs-number">1</span></span>. e2 - e4 Pawn-move <span class="hljs-number"><span class="hljs-number">1</span></span>. e7 - e5 Pawn-move <span class="hljs-number"><span class="hljs-number">2</span></span>. g1 - f3 leap2 n nw <span class="hljs-number"><span class="hljs-number">2</span></span>. b8 - c6 leap2 n <span class="hljs-keyword"><span class="hljs-keyword">ne</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>. f1 - c4 slide nw <span class="hljs-number"><span class="hljs-number">3</span></span>. g8 - f6 leap2 n nw <span class="hljs-number"><span class="hljs-number">4</span></span>. e1 - g1 OO <span class="hljs-number"><span class="hljs-number">4</span></span>. d7 - d5 Pawn-move <span class="hljs-number"><span class="hljs-number">5</span></span>. e4 <span class="hljs-keyword"><span class="hljs-keyword">x</span></span> d5 Pawn-capture nw <span class="hljs-number"><span class="hljs-number">5</span></span>. f6 <span class="hljs-keyword"><span class="hljs-keyword">x</span></span> d5 leap2 w nw</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Hinweis</b> <div class="spoiler_text">  Kluge Leser bemerken m√∂glicherweise, dass ich in den Z√ºgen f√ºr ‚ÄûSchwarz‚Äú Anweisungen verwendet habe, die nicht den tats√§chlichen Anweisungen auf dem Schachbrett entsprechen.  Dies h√§ngt damit zusammen, dass f√ºr Schwarz ‚ÄûSymmetrien‚Äú definiert sind: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">symmetry</span></span> Black (<span class="hljs-name"><span class="hljs-name">ns</span></span>)(<span class="hljs-name"><span class="hljs-name">sn</span></span>) (<span class="hljs-name"><span class="hljs-name">nw</span></span> sw)(<span class="hljs-name"><span class="hljs-name">sw</span></span> nw) (<span class="hljs-name"><span class="hljs-name">ne</span></span> se)(<span class="hljs-name"><span class="hljs-name">se</span></span> ne))</code> </pre> <br>  Grob gesagt ist also f√ºr Wei√ü ‚ÄûNorden‚Äú, f√ºr Schwarz ‚ÄûS√ºden‚Äú und umgekehrt. <br></div></div><br>  Die Vorteile einer solchen Aufzeichnung liegen nicht auf der Hand, haben jedoch einen wichtigen Vorteil.  Alle Z√ºge sind einheitlich beschrieben, und diese Beschreibungen enthalten keine zus√§tzlichen Informationen (die Namen der Zugbeschreibungen k√∂nnten nat√ºrlich ‚Äûbeschreibender‚Äú sein).  In der Beschreibung der Rochade ist es gelungen, sowohl die √Ñnderungen der Attribute als auch die Beschreibung des Turmzugs zu beseitigen (diese Beschreibung h√§ngt nicht mehr von den Implementierungsdetails des Zugs ab).  Eine noch klarere N√ºtzlichkeit solcher Aufzeichnungen besteht im Fall des Spiels Go: <br><br><pre> <code class="perl hljs"><span class="hljs-number"><span class="hljs-number">1</span></span>. G19 drop-to-empty White Stone</code> </pre> <br>  Und das war's auch schon!  Wenn die Steine ‚Äã‚Äãdes Gegners gem√§√ü den Spielregeln genommen werden, m√ºssen sie nicht alle in der Zugbeschreibung aufgef√ºhrt werden.  Es reicht aus, den Anfangs- und Endbereich der Verschiebung (m√∂glicherweise mit einem Vorzeichen), den Namen der ausgef√ºhrten Verschiebung und die ihm √ºbergebene Parameterzeile anzugeben.  Um einen Zug gem√§√ü dieser Beschreibung auszuf√ºhren, ist es nat√ºrlich erforderlich, zum Decodieren auf das Bewegungserzeugungsmodul zuzugreifen, aber ZoG tut dies! <br><br>  Eine andere M√∂glichkeit, die man unterst√ºtzen sollte, taucht in der Funktionalit√§t von "Teilz√ºgen" auf.  Hier ist ein Beispiel von " <a href="https://glukkazan.github.io/checkers/russian-checkers.htm" rel="nofollow">russischen Dame</a> ": <br><br><pre> <code class="perl hljs"><span class="hljs-number"><span class="hljs-number">1</span></span>. Checker g3 - f4 <span class="hljs-number"><span class="hljs-number">1</span></span>. Checker f6 - g5 <span class="hljs-number"><span class="hljs-number">2</span></span>. Checker e3 - d4 <span class="hljs-number"><span class="hljs-number">2</span></span>. partial <span class="hljs-number"><span class="hljs-number">2</span></span> Checker g5 - e3 = XChecker on f4 <span class="hljs-number"><span class="hljs-number">2</span></span>. Checker e3 - c5 = XChecker on d4 <span class="hljs-keyword"><span class="hljs-keyword">x</span></span> d4 <span class="hljs-keyword"><span class="hljs-keyword">x</span></span> f4</code> </pre><br>  Hier nehmen die Schwarzen im zweiten Zug zwei Figuren auf d4 und f4.  Eine vorl√§ufige ‚ÄûTransformation‚Äú dieser Teile zu XChecker ist ein Merkmal dieser Implementierung und dient dazu, die Wiederaufnahme von ‚Äûbesiegten‚Äú Teilen im selben Zug zu verhindern.  Der Ausdruck "Teil 2" beschreibt den Beginn des "Composite" -Kurses, der aus zwei "Teilz√ºgen" besteht.  Diese Form der Beschreibung ist unpraktisch, da zum Zeitpunkt der Erzeugung des ersten Zuges die L√§nge der Folge von "Teilz√ºgen" m√∂glicherweise nicht bekannt ist.  So sieht diese Beschreibung in einem neuen Format aus: <br><br><pre> <code class="perl hljs"><span class="hljs-number"><span class="hljs-number">1</span></span>. g3 - f4 checker-<span class="hljs-keyword"><span class="hljs-keyword">shift</span></span> nw <span class="hljs-number"><span class="hljs-number">1</span></span>. f6 - g5 checker-<span class="hljs-keyword"><span class="hljs-keyword">shift</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ne</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>. e3 - d4 checker-<span class="hljs-keyword"><span class="hljs-keyword">shift</span></span> nw <span class="hljs-number"><span class="hljs-number">2</span></span>. + g5 - e3 checker-jump nw <span class="hljs-number"><span class="hljs-number">2</span></span>. + e3 - c5 checker-jump sw <span class="hljs-number"><span class="hljs-number">2</span></span>. +</code> </pre><br>  Implementierungsdetails im Zusammenhang mit der ‚ÄûTransformation‚Äú von St√ºcken sind irrelevant.  Die Erfassung von St√ºcken ist ebenfalls nicht festgelegt, da die Erfassung bei Dame als ‚ÄûNebeneffekt‚Äú des Spielzugs und nicht nach dem ‚ÄûSchachprinzip‚Äú erfolgt. Der Teilfortschritt wird am Anfang mit dem Symbol ‚Äû+‚Äú codiert der Linie.  Ein einsames "+" zeigt den Abschluss eines "zusammengesetzten Zuges" an (in der Tat ist dies der √ºbliche "partielle" Zug, der einen fehlenden Zug und eine leere Zeichenfolge enth√§lt). <br><br>  Auf diese Weise ist es gelungen, unter Verwendung von benannten Regeln f√ºr die Implementierung von Z√ºgen eine universelle Notation zu erstellen, die unsere Anforderungen vollst√§ndig erf√ºllt.  Nat√ºrlich hat es weder mit dem Standardschach noch mit irgendeiner anderen Notation zu tun, aber es kommt auch vor, dass die konventionelle Notation f√ºr Schach, Dame und andere Spiele nichts miteinander zu tun hat.  Das Visualisierungsmodul kann den Bewegungsdatensatz immer in eine vertraute Form konvertieren, die f√ºr ein bestimmtes Spiel akzeptiert wird.  Die Konvertierung kann auch in eine universelle Form erfolgen, z. B. in <a href="https://en.wikipedia.org/wiki/Smart_Game_Format" rel="nofollow">SGF (Smart Game Format)</a> . <br><br><h2>  Der Lebenszyklus des Spiels </h2><br>  Zus√§tzlich zu den Informationen zum Platzieren von Steinen auf dem Brett ist die Abfolge der Runden ein wesentlicher Bestandteil des Spielzustands, eine Variable im Spielprozess.  Im einfachsten (und gebr√§uchlichsten) Fall reicht ein Bit aus, um diese Informationen zu speichern, ZoG bietet jedoch einige weitere M√∂glichkeiten, komplexere F√§lle zu implementieren.  So k√∂nnte eine Beschreibung einer Abfolge von Z√ºgen f√ºr das Spiel <a href="http://www.iggamecenter.com/info/en/splut.html" rel="nofollow">Splut aussehen!</a>  : <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">players</span></span> South West North East) (<span class="hljs-name"><span class="hljs-name">turn-order</span></span> South West West repeat North North North East East East South South South West West West )</code> </pre> <br>  In diesem Spiel macht jeder Spieler drei Z√ºge gleichzeitig, aber wenn Sie dem ersten Spieler die M√∂glichkeit geben, drei Z√ºge von der Anfangsposition aus zu machen, kann er eine der gegnerischen Figuren zerst√∂ren, wodurch er eine erh√§lt wesentlicher Vorteil.  Aus diesem Grund sollte der erste Spieler nur einen Zug machen (dies gibt die Gelegenheit, sich darauf vorzubereiten, einen gegnerischen Spieler anzugreifen, ihn aber nicht anzugreifen), der zweite - zwei Z√ºge (dies reicht auch nicht aus, um einen gegnerischen Spieler anzugreifen) was jeder Spieler immer drei Z√ºge macht. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/f78/6b5/862/f786b5862708474184d805653c2fe9fc.jpg"></div><br>  Die Etikettenwiederholung zeigt den Beginn einer sich zyklisch wiederholenden Folge von Z√ºgen an.  Wenn es nicht erscheint, wird die gesamte Beschreibung zyklisch wiederholt.  ZoG erlaubt es nicht, das Etikett mehrmals zu verwenden.  Ein weiteres wichtiges Merkmal ist die Angabe der Turnreihenfolge.  So k√∂nnte eine Beschreibung der Abfolge der Z√ºge f√ºr ein Spiel aussehen, in dem jeder Spieler zwei Z√ºge ausf√ºhrt (der erste Zug - Spielsteine ‚Äã‚Äãbewegen, der zweite - Spielsteine ‚Äã‚Äãdes Gegners erfassen): <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">players</span></span> White Black) (<span class="hljs-name"><span class="hljs-name">turn-order</span></span> (<span class="hljs-name"><span class="hljs-name">White</span></span> normal-move) (<span class="hljs-name"><span class="hljs-name">White</span></span> capture-move) (<span class="hljs-name"><span class="hljs-name">Black</span></span> normal-move) (<span class="hljs-name"><span class="hljs-name">Black</span></span> capture-move) )</code> </pre> <br>  Mit der Beschreibung des Verschiebens von Teilen anderer Personen ist eine weitere Funktion verbunden, deren Verwendung jedoch sehr unbequem ist.  Das Problem ist, dass eine solche Beschreibung keine Alternative hat.  Wenn die Beschreibung besagt, dass der Zug von einer gegnerischen Figur ausgef√ºhrt werden soll, muss der Spieler diesen Zug ausf√ºhren!  In ZoG ist es unm√∂glich zu beschreiben, ob man sein eigenes St√ºck oder das eines anderen bewegt.  Wenn eine solche F√§higkeit in einem Spiel ben√∂tigt wird (wie in " <a href="https://glukkazan.github.io/checkers/stavropol-checkers.htm" rel="nofollow">Stavropol Checkers</a> "), ist es notwendig, alle Teile neutral zu machen (zu diesem Zweck einen Spieler zu schaffen, der nicht am Spiel teilnimmt) und f√ºr alle Spieler die M√∂glichkeit zu bestimmen ein neutrales St√ºck bewegen.  Ich habe oben erw√§hnt, dass es standardm√§√üig viel einfacher ist, allen Spielern die M√∂glichkeit zu geben, beliebige Figuren (sowohl ihre eigenen als auch die des Gegners) zu bewegen, indem die notwendigen Checks in den Algorithmen zur Generierung von Z√ºgen hinzugef√ºgt werden. <br><br>  Wie Sie sehen, ist die Auswahl an Optionen, die ZoG f√ºr die Beschreibung der Abfolge von Abbiegungen bietet, √§u√üerst begrenzt.  Axiom kann auch keine neuen Funktionen hinzuf√ºgen, da es (normalerweise) √ºber ZoG l√§uft.  Ludi ist in dieser Hinsicht noch √§rmer.  Um die Vereinheitlichung der Spielregeln (die f√ºr die Verwendung generischer Algorithmen erforderlich sind) zu maximieren, wurden in diesem Projekt alle Beschreibungsfunktionen bewusst vereinfacht, wodurch ganze Spielebenen eliminiert wurden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/52b/c1e/8a3/52bc1e8a3f374c8386884241a1571a18.jpg"></div><br>  " <a href="https://en.wikipedia.org/wiki/Bao_(game)" rel="nofollow">Bao Swahili</a> " ist ein gutes Beispiel f√ºr ein Spiel mit einem komplexen Lebenszyklus. In diesem Spiel gibt es zwei Phasen mit Regeln f√ºr die Bewegungsausf√ºhrung, die sich erheblich unterscheiden. Zu Beginn des Spiels befindet sich ein Teil der Steine ‚Äã‚Äã"in der Hand" "Von jedem Spieler. W√§hrend noch Steine" in der Hand "sind, werden Steine ‚Äã‚ÄãStein f√ºr Stein in die Vertiefungen gelegt. Wenn die Steine" in der Hand "ausgehen, beginnt die zweite Phase des Spiels mit der Verteilung der eingeworfenen Steine Man kann nicht sagen, dass dieses Spiel nicht in ZRF (der Beschreibungssprache von ZoG) beschrieben werden kann, aber aufgrund der Einschr√§nkungen von ZoG w√§re diese Implementierung √§u√üerst verwirrend (was sicherlich nicht f√ºr die Qualit√§t der KI-Arbeit am besten ist). Mal sehen, wie die Beschreibung eines solchen Spiels in einer ‚Äûidealen Welt‚Äú aussehen w√ºrde: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">players</span></span> South North) (<span class="hljs-name"><span class="hljs-name">turn-order</span></span> (<span class="hljs-name"><span class="hljs-name">turn-order</span></span> (<span class="hljs-name"><span class="hljs-name">South</span></span> pi-move) (<span class="hljs-name"><span class="hljs-name">North</span></span> pi-move) ) (<span class="hljs-name"><span class="hljs-name">label</span></span> phase-ii) (<span class="hljs-name"><span class="hljs-name">turn-order</span></span> (<span class="hljs-name"><span class="hljs-name">South</span></span> p-ii-move) (<span class="hljs-name"><span class="hljs-name">North</span></span> p-ii-move) ) )</code> </pre> <br>  Hier bestimmt jede Zugreihenfolge ihre sich wiederholende Zugfolge (die sich durch die Art der Zugausf√ºhrung unterscheidet).  Das Schl√ºsselwort label definiert ein Label, zu dem w√§hrend der Generierung des letzten Schrittes ein √úbergang erfolgen kann.  Sie werden vielleicht bemerken, dass wir hier von der impliziten Annahme ausgehen, dass ein solcher √úbergang immer nach dem Zug des zweiten Spielers erfolgt (andernfalls w√ºrde er die Zugfolge verletzen).  Wie kann der √úbergang zur n√§chsten Phase zu einem beliebigen Zeitpunkt erfolgen? <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">players</span></span> South North) (<span class="hljs-name"><span class="hljs-name">turn-order</span></span> (<span class="hljs-name"><span class="hljs-name">turn-order</span></span> (<span class="hljs-name"><span class="hljs-name">South</span></span> pi-move) (<span class="hljs-name"><span class="hljs-name">North</span></span> pi-move) ) (<span class="hljs-name"><span class="hljs-name">turn-order</span></span> (<span class="hljs-name"><span class="hljs-name">labels</span></span> - phase-ii) (<span class="hljs-name"><span class="hljs-name">South</span></span> p-ii-move) (<span class="hljs-name"><span class="hljs-name">labels</span></span> phase-ii -) (<span class="hljs-name"><span class="hljs-name">North</span></span> p-ii-move) ) )</code> </pre> <br>  Hier werden Etiketten im Schleifenk√∂rper getragen und bestehen aus zwei Namen.  Markennamen in den Etikettenlisten werden in der Reihenfolge der √úbertragung von Spielern in der Liste der Spieler angezeigt.  Der f√ºr den √úbergang verwendete Name wird von dem Spieler bestimmt, der den letzten Zug gemacht hat.  Wenn dies der Norden war, wird zum ersten Etikett √ºbergegangen, andernfalls zum zweiten.  Wenn einer der Namen in den Beschriftungen nicht verwendet wird, kann die entsprechende Position mit einem Bindestrich gef√ºllt werden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/060/833/75d/06083375de8a4b97b7cffb138b3d5b9f.jpg"></div><br>  Ein wichtiger Aspekt bei der Verwaltung abwechselnder Z√ºge ist die F√§higkeit, einen wiederholten Zug auszuf√ºhren.  In Spielen der <a href="https://en.wikipedia.org/wiki/Tables_(board_game)" rel="nofollow">Tischfamilie</a> , wie beispielsweise <a href="https://en.wikipedia.org/wiki/Tables_(board_game)" rel="nofollow">Nard</a> , <a href="https://glukkazan.github.io/races/backgammon.htm" rel="nofollow">Backgammon</a> oder <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi%3Fdo%3Dshow%3Bid%3D2262" rel="nofollow">Ur</a> , ist die F√§higkeit, wiederholte Z√ºge auszuf√ºhren, ein wichtiges Element der Spieltaktik.  In ZoG kann man eine Spielrunde verwenden, um diese Funktion zu emulieren, aber dieser Ansatz erschwert die Beschreibung des Spiels erheblich (insbesondere bei mehr Spielern).  Es w√§re viel logischer, ein Etikett f√ºr die Wiederholung einer Runde zu verwenden: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">players</span></span> South North) (<span class="hljs-name"><span class="hljs-name">turn-order</span></span> (<span class="hljs-name"><span class="hljs-name">label</span></span> repeat) South (<span class="hljs-name"><span class="hljs-name">label</span></span> repeat) North )</code> </pre> <br>  Nachdem das Spiel zur Wiederholung des Etiketts gesprungen ist, spielt der Spieler erneut seinen Zug (der der aktuellen Position in der Liste der Z√ºge am n√§chsten liegende Zug wird wirksam).  Mir gef√§llt der Ansatz von <a href="https://en.wikipedia.org/wiki/Perl" rel="nofollow">Perl</a> in seinen impliziten Definitionen.  Die implizite Erzeugung von Kontrollstrukturen kann die Spielbeschreibung erheblich vereinfachen.  Da wiederholte Z√ºge in vielen Spielen verwendet werden k√∂nnen, wiederholen sich die Bezeichnungen, und das Vorwegnehmen einer m√∂glichen Wiederholung jeder Runde kann implizit sein: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">players</span></span> South North) (<span class="hljs-name"><span class="hljs-name">turn-order</span></span> South North )</code> </pre> <br>  Da au√üerdem die Reihenfolge der Z√ºge vollst√§ndig mit der schriftlichen Reihenfolge der Spieler im Spielerkonstrukt √ºbereinstimmt, k√∂nnen Sie die gesamte Reihenfolge der Z√ºge automatisch generieren: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">players</span></span> South North)</code> </pre> <br>  Je einfacher die Beschreibung zu schreiben ist, desto besser. <br><br><h2>  Zerbrechliche Invariante </h2><br>  Die Hauptsache, die ich in ZoG nicht mag, kann mit einem Wort ausgedr√ºckt werden - schachmatt.  Auf den ersten Blick ist es nur eine Bedingung (sehr h√§ufig in Spielen der <a href="https://en.wikipedia.org/wiki/Checkmate" rel="nofollow">Schachfamilie</a> ), die das Ende des Spiels mit der Situation des Verb√ºndeten verbindet.  Leider zeigt sich bei n√§herer Betrachtung die Einfachheit als tr√ºgerisch.  Die Verwendung dieses Schl√ºsselworts bedeutet nicht nur, dass nach jedem Zug eine Pr√ºfung auf den Abschluss des Spiels durchgef√ºhrt wird, sondern dass dem Spieler auch ein bestimmtes ‚ÄûVerhalten‚Äú auferlegt wird. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/OR74gUlfQNY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Dieses Spiel unterscheidet sich vom √ºblichen <a href="https://en.wikipedia.org/wiki/Shogi" rel="nofollow">Shogi</a> nur in der Anzahl der Spieler.  Leider reicht dieser Unterschied aus, um die Aufgabe, Schachmatt (und alles, was mit diesem ‚Äûmagischen‚Äú Wort zusammenh√§ngt) zu bestimmen, falsch zu machen.  Die √úberpr√ºfung der Kontrolle wird nur in Bezug auf einen der Spieler durchgef√ºhrt.  Infolgedessen kann der K√∂nig angegriffen werden und gefressen werden [durch eine Kombination von gegnerischen Spielz√ºgen, auch wenn nicht "checken" gelassen wird]!  Dass dies nicht optimal ist, spiegelt sich in der Arbeit der KI wider. <br><br>  Wenn dieses Problem unbedeutend erscheint, sollten Sie nicht vergessen, dass Koalitionen normalerweise in Viererspielen ‚ÄûPaar gegen Paar‚Äú gebildet werden.  Bei der Bildung von Koalitionen m√ºssen wir ber√ºcksichtigen, dass k√∂nigswillige Figuren ihn nicht bedrohen!  So k√∂nnen sich beispielsweise zwei befreundete K√∂nige auf benachbarten Feldern der Tafel aufhalten. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/b00/77d/949/b0077d949f2d472da9e12d64099d924d.jpg"></div><br>  Es wird komplizierter als je zuvor, wenn ein Spieler mehrere K√∂nige hat.  Im ‚Äû <a href="http://history.chess.free.fr/tamerlane-full.htm" rel="nofollow">Tamerlane-Schach</a> ‚Äú verwandelt sich der k√∂nigliche Bauer in einen Prinzen (eigentlich einen zweiten K√∂nig).  In diesem Fall k√∂nnen Sie nur gewinnen, indem Sie den ersten K√∂nig (einen der beiden) erobern und den zweiten verbinden.  In diesem Spiel k√∂nnen Sie sogar einen dritten K√∂nig gewinnen, der doppelt so viel Geld f√ºr die Umwandlung des ‚ÄûBauern der Bauern‚Äú ausgibt!  Die Ausdrucksf√§higkeit von ‚Äûcheckmated‚Äú reicht nicht aus, um diese Situation angemessen zu beschreiben. <br><br>  Eine andere Schwierigkeit kann der Prozess des Gebens des Gef√§hrten sein.  Im mongolischen Schach ( <a href="https://en.wikipedia.org/wiki/Shatar" rel="nofollow">Shatar</a> ) h√§ngt das Ergebnis des versuchten Partners von der Reihenfolge ab, in der die Figuren nacheinander ‚Äûchecken‚Äú.  Das Ergebnis kann entweder ein Sieg oder ein Unentschieden sein (z. B. ein Mitspieler) oder sogar eine Niederlage (ein Mitspieler ist verboten, aber Sie k√∂nnen einen Scheck abgeben).  Etwas weniger exotisch ist in dieser Hinsicht der japanische Shogi.  In diesem Spiel ist es verboten, einen Partner mit einem fallengelassenen Bauern zu geben, aber Sie k√∂nnen einen Scheck mit einem fallengelassenen Bauern und einen Scheckpartner mit einem bewegten Bauern geben. <br><br><div class="spoiler">  <b class="spoiler_title">Hinweis</b> <div class="spoiler_text">  Es gibt noch einen wichtigen Punkt, der erw√§hnenswert ist.  In einigen Spielen wie Rhythmomagic gibt es verschiedene M√∂glichkeiten, das Spiel zu beenden.  Die naheliegendste Art zu gewinnen, bei der die gegnerischen Figuren zerst√∂rt werden, ist auch die am wenigsten bevorzugte.  F√ºr einen gr√∂√üeren Sieg muss man seine Figuren in einem bestimmten Muster auf feindlichem Territorium anordnen. <br><br>  Man sollte auf der Ebene der Spielbeschreibung zwischen den Arten von Siegen (und Niederlagen und Unentschieden) unterscheiden, da die Art des Spielendes f√ºr den Spieler von Bedeutung sein kann.  Au√üerdem sollte es m√∂glich sein, den verschiedenen Spielenden numerische Priorit√§ten zuzuweisen.  Bei gleichzeitiger Erf√ºllung mehrerer Abschlussbedingungen sollte diejenige mit der h√∂chsten Priorit√§t z√§hlen. <br></div></div><br>  Offensichtlich muss man die Logik der √úberpr√ºfung des Spielendes von der Pr√ºfung f√ºr den in Schach geratenen K√∂nig trennen. Dies ist eine <a href="https://en.wikipedia.org/wiki/Invariant_(mathematics)" rel="nofollow">unver√§nderliche Regel</a> , die nach jeder Runde √ºberpr√ºft wird.  Ein Versto√ü gegen die Regel macht es unm√∂glich, den Zug auszuf√ºhren (der Zug wird aus der Liste der verf√ºgbaren Z√ºge entfernt).  So k√∂nnte ein (vereinfachter) Test f√ºr die Kontrolle eines K√∂nigs f√ºr "Tamerlane-Schach" aussehen: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">verify</span></span> (<span class="hljs-name"><span class="hljs-name">or</span></span> (<span class="hljs-name"><span class="hljs-name">&gt;</span></span> (<span class="hljs-name"><span class="hljs-name">count</span></span> (<span class="hljs-name"><span class="hljs-name">pieces</span></span> my? (<span class="hljs-name"><span class="hljs-name">is-piece</span></span>? King))) <span class="hljs-number"><span class="hljs-number">1</span></span>) (<span class="hljs-name"><span class="hljs-name">=</span></span> (<span class="hljs-name"><span class="hljs-name">count</span></span> (<span class="hljs-name"><span class="hljs-name">pieces</span></span> my? (<span class="hljs-name"><span class="hljs-name">is-piece</span></span>? King) is-attacked?)) <span class="hljs-number"><span class="hljs-number">0</span></span>) ) )</code> </pre> <br>  Es ist wichtig zu verstehen, dass dieser Test nur f√ºr die eigenen K√∂nige durchgef√ºhrt werden sollte (ich habe das Pr√§dikat my verwendet, weil der Pr√§dikat friend mit Unterst√ºtzung f√ºr Koalitionen nicht nur f√ºr die eigenen St√ºcke zufrieden sein wird, sondern auch f√ºr die St√ºcke aller befreundeten Spieler).  Akzeptabel (und w√ºnschenswert, wenn es mehrere befreundete K√∂nige gibt) ist die Situation, in der der feindliche K√∂nig nach einem Zug, aber durch den eigenen K√∂nig, unter Kontrolle ger√§t.  Diese Situation sollte unm√∂glich sein [es sei denn, es gibt mehrere befreundete K√∂nige]!  Die √úberpr√ºfung solcher Regeln auf den Abschluss des Spiels durch Schachmatt wird zu einer trivialen Angelegenheit.  Wenn es keine m√∂glichen Z√ºge gibt und der [einzige] K√∂nig in Schach ist, ist das Spiel vorbei [wenn dieser K√∂nig dem letzten √ºberlebenden Spieler der vorletzten √ºberlebenden Koalition geh√∂rt]: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">loss-condition</span></span> (<span class="hljs-name"><span class="hljs-name">and</span></span> (<span class="hljs-name"><span class="hljs-name">=</span></span> (<span class="hljs-name"><span class="hljs-name">count</span></span> moves) <span class="hljs-number"><span class="hljs-number">0</span></span>) (<span class="hljs-name"><span class="hljs-name">=</span></span> (<span class="hljs-name"><span class="hljs-name">count</span></span> (<span class="hljs-name"><span class="hljs-name">pieces</span></span> my? (<span class="hljs-name"><span class="hljs-name">is-piece</span></span>? King)) <span class="hljs-number"><span class="hljs-number">1</span></span>) (<span class="hljs-name"><span class="hljs-name">&gt;</span></span> (<span class="hljs-name"><span class="hljs-name">count</span></span> (<span class="hljs-name"><span class="hljs-name">pieces</span></span> my? (<span class="hljs-name"><span class="hljs-name">is-piece</span></span>? King) is-attacked?)) <span class="hljs-number"><span class="hljs-number">0</span></span>) ) )</code> </pre> <br>  Die F√§higkeit, Invarianten zu bestimmen, ist in anderen Spielen n√ºtzlich, z. B. in <a href="https://glukkazan.github.io/checkers/international-checkers.htm" rel="nofollow">Dame</a> .  Die gr√∂√üte Schwierigkeit bei der Umsetzung von Spielen dieser Familie h√§ngt mit der Umsetzung der ‚ÄûMehrheitsregel‚Äú zusammen.  In fast allen Entwurfsspielen ist das Erfassen obligatorisch.  Au√üerdem gibt es in den meisten Spielen dieser Familie eine charakteristische Vollendung von "Ketteneroberungen" in einer einzigen Runde.  Wenn m√∂glich, nimmt der Kontrolleur, nachdem er gefangen genommen hat, weiterhin andere Teile.  In den meisten Spielen muss der Spieler Kettenerfassungen bis zum Ende durchf√ºhren, es gibt jedoch Ausnahmen von dieser Regel, z. B. <a href="https://glukkazan.github.io/checkers-like/fanorona-normal.htm" rel="nofollow">Fanorona</a> . <br><br><div style="text-align:center;"> <a href="https://glukkazan.github.io/checkers-like/fanorona-normal.htm" rel="nofollow"><img src="https://habrastorage.org/files/a4a/f83/3d8/a4af833d85d445b5ba17aca59056b741.jpg"></a> </div><br>  Mit dem Mechanismus der Teilbewegungen ist die Implementierung einer "Kettenerfassung" recht einfach.  Schwierigkeiten ergeben sich, wenn man zus√§tzlich eine Bedingung auferlegt, unter der man von allen m√∂glichen Optionen eine Kette ausw√§hlen muss, in der eine maximale Anzahl von St√ºcken erfasst wird.  In ZoG muss diese Logik auf der Ebene der ‚ÄûHardcodierung‚Äú von Grund auf implementiert werden: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">option</span></span> <span class="hljs-string"><span class="hljs-string">"maximal captures"</span></span> true)</code> </pre> <br>  Diese Einstellung eignet sich f√ºr ‚Äû <a href="https://glukkazan.github.io/checkers/international-checkers.htm" rel="nofollow">Internationale Pr√ºfer</a> ‚Äú, bei den ‚Äû <a href="https://glukkazan.github.io/checkers/italian-checkers.htm" rel="nofollow">Italienischen Pr√ºfern</a> ‚Äú ist die Mehrheitsregel jedoch anders formuliert.  Wenn es in dieser Version des Spiels mehrere Optionen f√ºr die gleiche Anzahl von Eroberungen gibt, m√ºssen Sie eine Option ausw√§hlen, die die gr√∂√üere Anzahl transformierter Steine ‚Äã‚Äã(K√∂nige) erfasst.  Die Entwickler von ZoG haben dies zur Verf√ºgung gestellt. You enter the following setting: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">option</span></span> <span class="hljs-string"><span class="hljs-string">"maximal captures"</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>)</code> </pre> <br> In this setting, one counts not only the number of pieces captured, but also their type. Unfortunately, not everything can be foreseen. Here's how the ‚Äúmajority rule‚Äù is formulated in ‚Äúold French checkers‚Äù: <br><br><blockquote> <i>If by a series of captures it is possible to capture the same number of checkers with a simple man or with a king, the player must use the king. However, if the number of checkers is the same in both cases, but in one there is an enemy king (or there are more), the player must choose this option, even if the capturing is then done using the simple checker, and not using the king.</i> </blockquote><br> Of course, at the present time, almost no one plays this version of checkers, but its very existence clearly demonstrates the shortcomings of ‚Äúhardcoded‚Äù implementation. Using the mechanism of invariants allows for all possible options for the ‚Äúmajority rule‚Äù in a universal manner. For the ‚Äú <a href="http://www.checkerschest.com/checkers-games/french-checkers.htm" rel="nofollow">old French checkers</a> ‚Äù implementation would be as follows: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">verify</span></span> (<span class="hljs-name"><span class="hljs-name">&gt;=</span></span> capturing-count max-capturing-count) ) (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">&gt;</span></span> capturing-count max-capturing-count) (<span class="hljs-name"><span class="hljs-name">let</span></span> max-capturing-count capturing-count) (<span class="hljs-name"><span class="hljs-name">let</span></span> max-capturing-sum capturing-sum) (<span class="hljs-name"><span class="hljs-name">let</span></span> max-attacking-value attacking-value) ) (<span class="hljs-name"><span class="hljs-name">verify</span></span> (<span class="hljs-name"><span class="hljs-name">&gt;=</span></span> capturing-sum max-capturing-sum) ) (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">&gt;</span></span> capturing-sum max-capturing-sum) (<span class="hljs-name"><span class="hljs-name">let</span></span> max-capturing-sum capturing-sum) (<span class="hljs-name"><span class="hljs-name">let</span></span> max-attacking-value attacking-value) ) (<span class="hljs-name"><span class="hljs-name">verify</span></span> (<span class="hljs-name"><span class="hljs-name">&gt;=</span></span> attacking-value max-attacking-value) ) (<span class="hljs-name"><span class="hljs-name">let</span></span> max-attacking-value attacking-value)</code> </pre><br> Here, we assume that the rules for capture generation correctly fill [the following] local variables: <br><br><ul><li> <b>capturing-count</b> ‚Äî total pieces captured </li><li> <b>capturing-sum</b> ‚Äî number of kings captured </li><li> <b>attacking-value</b> ‚Äî value of piece capturing </li></ul><br> Associated with each of these variables is a value-accumulator, stored in a variable with the prefix max. The three checks are executed serially. Violation of any of the verify conditions immediately interrupts the generation of the next turn option (the capture is not stored in the list of possible turns). Since the checks performed are associated with variable values, it is not sufficient [to test only the current new capture option]. Each test generates a ‚Äúbendable rule‚Äù associated with the generated capture [which may revise the accumulated maximum value]. After each change in any accumulator, all associated rules must be checked again [for every option in the list]. If any of the conditions are breached for a previously generated option, that option must be removed from the list of possible turn options. <br><br><h2>  Fazit </h2><br> This is translation of my article of 2014 year. Since then, I have rethought a lot and the <a href="https://glukkazan.github.io/" rel="nofollow">Dagaz project</a> has become a reality, but I did not change almost anything in the text. This article was translated by my friend <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi%3Fsearchauthor%3D505" rel="nofollow">Howard McCay</a> and I am grateful to him for the work done. <br></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de481868/">https://habr.com/ru/post/de481868/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de481854/index.html">Testen von Ideen durch Dashboard-Prototyping</a></li>
<li><a href="../de481858/index.html">Geburtstage in Google Kalender mit dem Alter</a></li>
<li><a href="../de481860/index.html">Was soll die IT im Jahr 2020 tun?</a></li>
<li><a href="../de481862/index.html">Nvidia Jetson Embedded-Systeme f√ºr maschinelles Lernen</a></li>
<li><a href="../de481866/index.html">DBA: Wenn VACUUM vorbei ist, reinigen wir den Tisch manuell</a></li>
<li><a href="../de481874/index.html">Metriken - Indikatoren f√ºr den Projektzustand</a></li>
<li><a href="../de481880/index.html">Physik f√ºr einen mobilen PvP-Shooter und wie wir uns mit ECS angefreundet haben</a></li>
<li><a href="../de481882/index.html">4. Fortinet Getting Started v6.0. Firewall-Richtlinien</a></li>
<li><a href="../de481884/index.html">Seniorenkreuzung: Wohin als n√§chstes?</a></li>
<li><a href="../de481886/index.html">So erstellen Sie schnell ein Anwesenheitsjournal</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>