<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçµ üßëüèø‚Äçü§ù‚Äçüßëüèª üë®üèΩ‚Äçüé® Reflexiones c√°usticas realistas ‚è≠Ô∏è ‚ùå üì¢</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La mayor√≠a de los artistas t√©cnicos en alg√∫n momento de sus carreras intentan crear reflejos plausibles de c√°usticos. Si eres un desarrollador de jueg...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Reflexiones c√°usticas realistas</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467887/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/hd/an/yo/hdanyowyfitt8zvoj7vaeu3drdi.gif"></div><br>  La mayor√≠a de los artistas t√©cnicos en alg√∫n momento de sus carreras intentan crear reflejos plausibles de c√°usticos.  Si eres un desarrollador de juegos, entonces una de las principales razones para leer Twitter es el flujo interminable de inspiraci√≥n que puedes obtener de √©l.  Hace unos d√≠as, Florian Gelzenlichter ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="noopener noreferrer">kolyaTQ</a> en Twitter) public√≥ un GIF del efecto c√°ustico creado en Unity usando sombreadores.  La publicaci√≥n (presentada a continuaci√≥n) gan√≥ r√°pidamente 1,5 mil me gusta, lo que muestra un sincero inter√©s en este tipo de contenido. <br><br><div class="oembed"><twitter-widget class="twitter-tweet twitter-tweet-rendered" id="twitter-widget-0" style="position: static; visibility: visible; display: block; transform: rotate(0deg); max-width: 100%; width: 500px; min-width: 220px; margin-top: 10px; margin-bottom: 10px;" data-tweet-id="1165251296720576512"></twitter-widget><script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></div><br>  Aunque generalmente me atraen m√°s las series de art√≠culos m√°s largas y t√©cnicamente complejas (por ejemplo, sobre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="noopener noreferrer">la dispersi√≥n volum√©trica de la luz atmosf√©rica</a> [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">traducci√≥n</a> en Habr√©] y la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="noopener noreferrer">cinem√°tica inversa</a> [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">primera</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">segunda</a> parte de la traducci√≥n en Habr√©], no pude resistir la tentaci√≥n de escribir un tutorial corto y lindo sobre los efectos de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="noopener noreferrer">Florian</a> . <br><br>  Al final de este art√≠culo hay un enlace para descargar el paquete de Unity y todos los recursos necesarios. <br><a name="habracut"></a><br><h2>  ¬øQu√© es c√°ustico? </h2><br>  Es posible que no <em>conozca el</em> concepto de <em>c√°usticos</em> , aunque encuentre este efecto a diario.  Los c√°usticos son reflejos de luz causados ‚Äã‚Äãpor superficies curvas.  En el caso general, cualquier superficie curva puede comportarse como una lente, enfocando la luz en algunos puntos y dispers√°ndola en otros.  Los medios m√°s comunes que proporcionan tal efecto son el vidrio y el agua, que genera las llamadas <strong>ondas c√°usticas</strong> (ver m√°s abajo). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2cf/dcc/0c7/2cfdcc0c727f1637ffc5c360fd816a8f.jpg"></div><br>  Los c√°usticos pueden tomar otras formas.  Un arco iris, por ejemplo, es un fen√≥meno √≥ptico que ocurre cuando la luz se refracta en las gotas de lluvia.  Por lo tanto, estrictamente hablando, es c√°ustico. <br><br><h2>  Anatom√≠a del efecto </h2><br>  Una caracter√≠stica reconocible de las ondas c√°usticas es la forma en que se mueve;  lo m√°s probable es que lo hayas visto si alguna vez miraste el fondo de la piscina.  La recreaci√≥n de un c√°ustico real es muy costosa porque requiere la simulaci√≥n de muchos rayos de luz. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="noopener noreferrer">Florian</a> logr√≥ crear un efecto plausible, comenzando con una textura c√°ustica √∫nica.  Para crear mi tutorial, utilic√© la textura que se muestra a continuaci√≥n, tomada de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="noopener noreferrer">OpenGameArt</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c3a/418/def/c3a418defd9ff05890f63c4c35e728ad.gif" width="250" height="250"></div><br>  Una propiedad importante que permite realizar este efecto es que el patr√≥n c√°ustico que se muestra arriba es <strong>perfecto</strong> .  Esto significa que puede colocar dos im√°genes una al lado de la otra y no habr√° una costura notable entre ellas.  Como queremos usar este efecto en grandes superficies, es importante que tengamos la oportunidad de estirar esta textura sin rasgaduras que puedan destruir la ilusi√≥n. <br><br>  Habiendo recibido la textura, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="noopener noreferrer">Florian</a> sugiere seguir tres pasos: <br><br><ul><li>  Aplique un patr√≥n c√°ustico dos veces a la superficie del modelo, cada vez con diferentes tama√±os y velocidades. </li><li> Mezcle dos patrones con el operador <code>min</code> </li><li>  Canales RGB separados al muestrear. </li></ul><br>  Veamos c√≥mo puede implementar cada uno de los pasos en Unity. <br><br><h2>  Creaci√≥n de sombreadores </h2><br>  El primer paso es crear un nuevo sombreador.  Dado que es probable que este efecto se use en un juego 3D que tambi√©n tiene iluminaci√≥n real, es mejor comenzar con un <strong>sombreador de superficie</strong> .  Los sombreadores de superficie son uno de los muchos tipos de sombreadores compatibles con Unity (como <strong>sombreadores de v√©rtices y fragmentos</strong> para materiales no iluminados, <strong>sombreadores de pantalla</strong> para efectos de procesamiento posterior y <strong>sombreadores computacionales</strong> para simulaciones fuera de pantalla). <br><br>  El nuevo sombreador de superficie tiene solo algunas caracter√≠sticas.  Para crear este efecto, necesitamos transferir informaci√≥n al sombreador.  El primero es la textura c√°ustica.  En segundo lugar, este es el par√°metro utilizado para escalarlo y compensarlo. <br><br>  <em>Creemos</em> dos <em>propiedades de sombreador</em> : <br><br><pre> <code class="cpp hljs">Properties { ... [Header(Caustics)] _CausticsTex(<span class="hljs-string"><span class="hljs-string">"Caustics (RGB)"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>D) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} <span class="hljs-comment"><span class="hljs-comment">// Tiling X, Tiling Y, Offset X, Offset Y _Caustics_ST("Caustics ST", Vector) = (1,1,0,0) }</span></span></code> </pre> <br>  y las correspondientes <em>variables de Cg</em> : <br><br><pre> <code class="cpp hljs">sampler2D _CausticsTex; float4 _Caustics_ST;</code> </pre> <br>  <em>Las propiedades del sombreador</em> corresponden a los campos que se muestran en el Inspector de materiales de Unity.  Las <em>variables Cg</em> correspondientes son los valores mismos, que se pueden usar en el c√≥digo del sombreador. <br><br>  Como puede ver en el c√≥digo anterior, <code>_Caustics_ST</code> es <code>float4</code> , es decir, contiene cuatro valores.  Los utilizaremos para controlar el muestreo de la textura c√°ustica.  A saber: <br><br><ul><li>  <code>_Caustics_ST.x</code> : escala de la textura c√°ustica a lo largo del eje X; </li><li>  <code>_Caustics_ST.y</code> : escala de la textura c√°ustica a lo largo del eje Y; </li><li>  <code>_Caustics_ST.z</code> : desplazamiento de la textura c√°ustica a lo largo del eje X; </li><li>  <code>_Caustics_ST.w</code> : desplazamiento de la textura c√°ustica a lo largo del eje Y; </li></ul><br><div class="spoiler">  <b class="spoiler_title">¬øPor qu√© la variable se llama _Caustics_ST?</b> <div class="spoiler_text">  Si ya tiene un poco de experiencia trabajando con sombreadores, ya ha visto otras propiedades que terminan con el sufijo <code>_ST</code> .  En Unity, <code>_ST</code> puede usarse para agregar informaci√≥n adicional sobre c√≥mo se muestrea la textura. <br><br>  Por ejemplo, si crea la variable Cg <code>_MainTex_ST</code> , puede usarla para establecer el tama√±o y el desplazamiento al aplicar textura al modelo. <br><br>  Por <code>_ST</code> general, <code>_ST</code> variables <code>_ST</code> no necesitan propiedades porque se muestran autom√°ticamente en el inspector.  Sin embargo, en este caso particular, no podemos confiar en esto porque necesitamos muestrear la textura dos veces, cada vez con una escala y un desplazamiento diferentes.  En el futuro, necesitamos duplicar esta variable en dos variables diferentes. </div></div><br><h2>  Textura de muestreo </h2><br>  Cada <em>sombreador de superficie</em> contiene una funci√≥n, com√∫nmente llamada <code>surf</code> , que se utiliza para determinar el color de cada p√≠xel renderizado.  La funci√≥n de <code>surf</code> "est√°ndar" se ve as√≠: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">surf</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Input IN, inout SurfaceOutputStandard o)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Albedo comes from a texture tinted by color fixed4 c = tex2D (_MainTex, IN.uv_MainTex) * _Color; o.Albedo = c.rgb; // Metallic and smoothness come from slider variables o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; }</span></span></code> </pre> <br>  El color final est√° determinado por la cantidad de campos que el sombreador debe inicializar y devolver en una estructura llamada <code>SurfaceOutputStandard</code> .  Necesitamos cambiar <code>Albedo</code> , que coincide aproximadamente con el color del objeto iluminado por la luz blanca. <br><br>  En el sombreador de superficie reci√©n creado, el albedo se toma de una textura llamada <code>_MainTex</code> .  Dado que el efecto c√°ustico se superpone sobre la textura existente, tendremos que realizar un muestreo adicional de la textura en <code>_CausticsTex</code> . <br><br>  Una t√©cnica llamada <strong>superposici√≥n UV le</strong> permite comprender qu√© parte de la textura necesita ser muestreada dependiendo de qu√© parte de la geometr√≠a necesita ser renderizada.  Esto se hace usando <code>uv_MainTex</code> , la variable <code>float2</code> , almacenada en cada v√©rtice del modelo 3D e indicando la coordenada de la textura. <br><br>  Nuestra idea es usar <code>_Caustics_ST</code> para escalar y compensar <code>uv_MainTex</code> para estirar y mover la textura c√°ustica a trav√©s del modelo. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">surf</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Input IN, inout SurfaceOutputStandard o)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Albedo comes from a texture tinted by color fixed4 c = tex2D (_MainTex, IN.uv_MainTex) * _Color; o.Albedo = c.rgb; // Caustics sampling fixed2 uv = IN.uv_MainTex * _Caustics_ST.xy + _Caustics_ST.zw; fixed3 caustics = tex2D(_CausticsTex, uv).rgb; // Add o.Albedo.rgb += caustics; // Metallic and smoothness come from slider variables o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; }</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">¬øQu√© pasa si Albedo excede 1?</b> <div class="spoiler_text">  En el c√≥digo anterior, agregamos dos texturas.  El color suele estar entre <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>0</mn></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.162ex" height="2.074ex" viewBox="0 -772.3 500.5 892.8" role="img" focusable="false" aria-hidden="true" style="vertical-align: -0.28ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/467887/&amp;usg=ALkJrhgvwa6XO3h-2PQRNW3XQfXzdLoVIQ#MJMAIN-30" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>0</mn></math></span></span><script type="math/tex" id="MathJax-Element-1"> 0 </script>  antes <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>1</mn></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.162ex" height="2.074ex" viewBox="0 -772.3 500.5 892.8" role="img" focusable="false" aria-hidden="true" style="vertical-align: -0.28ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/467887/&amp;usg=ALkJrhgvwa6XO3h-2PQRNW3XQfXzdLoVIQ#MJMAIN-31" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>1</mn></math></span></span><script type="math/tex" id="MathJax-Element-2"> 1 </script>  Sin embargo, no hay garant√≠a de que, como resultado, algunos valores no excedan este intervalo. <br><br>  En sombreadores m√°s antiguos, esto podr√≠a causar un problema.  Aqu√≠ es en realidad una <em>caracter√≠stica</em> .  Si el valor del color del p√≠xel excede la unidad, esto significa que su influencia deber√≠a "extenderse" m√°s all√° de sus bordes y afectar a los p√≠xeles vecinos. <br><br>  Esto es exactamente lo que sucede cuando se obtienen reflejos especulares muy brillantes.  Sin embargo, este efecto no debe ser creado solo por un sombreador de superficie.  Para que el efecto funcione, la c√°mara debe tener <strong>HDR</strong> activado.  Esta propiedad significa <strong>alto rango din√°mico</strong> ;  permite que los valores de color excedan <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-3-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>1</mn></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.162ex" height="2.074ex" viewBox="0 -772.3 500.5 892.8" role="img" focusable="false" aria-hidden="true" style="vertical-align: -0.28ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/467887/&amp;usg=ALkJrhgvwa6XO3h-2PQRNW3XQfXzdLoVIQ#MJMAIN-31" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>1</mn></math></span></span><script type="math/tex" id="MathJax-Element-3"> 1 </script>  .  Adem√°s, para desenfocar una cantidad excesiva de colores en p√≠xeles vecinos, se requiere un efecto de procesamiento posterior. <br><br>  Unity tiene su propia pila de procesamiento posterior, que tiene un filtro de floraci√≥n que hace exactamente eso.  Puede leer m√°s sobre esto en el blog de Unity: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="noopener noreferrer">PostFX v2 - Im√°genes incre√≠bles, actualizadas</a> . </div></div><br>  Los resultados preliminares se muestran a continuaci√≥n: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9d5/16f/1de/9d516f1de5a00d84b60e95674cf35650.png" width="843" height="406"></div><br><h2>  C√°usticos animados </h2><br>  Una de las caracter√≠sticas m√°s importantes de los c√°usticos es c√≥mo se mueve.  Por el momento, simplemente se proyectan est√°ticamente en la superficie del modelo como una segunda textura. <br><br>  La animaci√≥n de materiales en sombreadores se puede implementar utilizando la propiedad Unity <code>_Time</code> .  Se puede usar para acceder al tiempo de juego actual, es decir, agregar tiempo a las ecuaciones. <br><br>  La forma m√°s f√°cil es simplemente compensar la textura en funci√≥n de la hora actual. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Caustics UV fixed2 uv = IN.uv_MainTex * _Caustics_ST.xy + _Caustics_ST.zw; uv += _CausticsSpeed * _Time.y; // Sampling fixed3 caustics = tex2D(_CausticsTex, uv).rgb; // Add o.Albedo.rgb += caustics;</span></span></code> </pre> <br>  El campo <code>_Time.y</code> contiene el tiempo de reproducci√≥n actual en <em>segundos</em> .  Si el reflejo se mueve demasiado r√°pido, puede multiplicarlo por un factor.  Para esto, la variable <code>_CausticsSpeed</code> de tipo <code>float2</code> usa en el c√≥digo presentado anteriormente. <br><br>  Es posible que necesite hacer vibrar la textura c√°ustica en una sinusoide para sus prop√≥sitos.  Es importante entender aqu√≠ que no hay una forma est√°ndar de realizar el efecto.  Dependiendo de sus necesidades, puede hacer que los reflejos c√°usticos se muevan de manera completamente diferente. <br><br>  Los resultados que se muestran a continuaci√≥n siguen siendo bastante mediocres.  Esto es normal: todav√≠a tenemos mucho por hacer para que los reflejos se vean hermosos. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b6e/37d/d6b/b6e37dd6b3d6e172c342c7902845f60d.gif"></div><br><h2>  Muestreo m√∫ltiple </h2><br>  El efecto cobra vida si muestras la textura c√°ustica no una, sino dos veces.  Si los coloca uno encima del otro y los mueve a diferentes velocidades, el resultado ser√° completamente diferente. <br><br>  Primero, <code>_CausticsSpeed</code> propiedades <code>_Caustics_ST</code> y <code>_CausticsSpeed</code> para que las muestras de las dos texturas tengan diferentes escalas, desplazamientos y velocidades: <br><br><pre> <code class="cpp hljs">[Header(Caustics)] _CausticsTex(<span class="hljs-string"><span class="hljs-string">"Caustics (RGB)"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>D) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} <span class="hljs-comment"><span class="hljs-comment">// Tiling X, Tiling Y, Offset X, Offset Y _Caustics1_ST("Caustics 1 ST", Vector) = (1,1,0,0) _Caustics2_ST("Caustics 1 ST", Vector) = (1,1,0,0) // Speed X, Speed Y _Caustics1_Speed("Caustics 1 Speed", Vector) = (1, 1, 0 ,0) _Caustics2_Speed("Caustics 2 Speed", Vector) = (1, 1, 0 ,0)</span></span></code> </pre> <br>  Ahora que tenemos dos muestras c√°usticas, se pueden mezclar usando el operador <code>min</code> .  Si solo toma el valor promedio, el resultado no ser√° muy bueno. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Caustics samplings fixed3 caustics1 = ... fixed3 caustics2 = ... // Blend o.Albedo.rgb += min(caustics1, caustics2);</span></span></code> </pre> <br>  Un cambio tan peque√±o hace una gran diferencia: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3ea/c9d/444/3eac9d4448485555980e10424e3f4ad5.gif"></div><br>  Para mantener el c√≥digo hermoso, tambi√©n puede ajustar el c√≥digo de muestreo c√°ustico en su propia funci√≥n: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Caustics fixed3 c1 = causticsSample(_CausticsTex, IN.uv_MainTex, _Caustics1_ST, _Caustics1_Speed); fixed3 c2 = causticsSample(_CausticsTex, IN.uv_MainTex, _Caustics2_ST, _Caustics2_Speed); o.Albedo.rgb += min(c1, c2);</span></span></code> </pre> <br><h2>  Separaci√≥n RGB </h2><br>  Para que los reflejos c√°usticos se vean bien, debes hacer el √∫ltimo truco.  Al pasar a trav√©s de un corte, la luz de diferentes longitudes de onda se refracta de manera diferente.  Esto significa que cuando se mueve a trav√©s del agua, la luz puede "dividirse" en diferentes colores. <br><br>  Para simular este efecto, podemos dividir cada muestra c√°ustica en tres, una para cada canal de color.  Al muestrear los canales rojo, verde y azul con un ligero sesgo, obtenemos una falta de coincidencia de color. <br><br>  Comencemos agregando la propiedad <code>_SplitRGB</code> , que indica la fuerza del efecto de <code>_SplitRGB</code> - <code>_SplitRGB</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Caustics UV fixed2 uv = IN.uv_MainTex * _Caustics_ST.xy + _Caustics_ST.zw; uv += _CausticsSpeed * _Time.y; // RGB split fixed s = _SplitRGB; fixed r = tex2D(tex, uv + fixed2(+s, +s)).r; fixed g = tex2D(tex, uv + fixed2(+s, -s)).g; fixed b = tex2D(tex, uv + fixed2(-s, -s)).b; fixed3 caustics = fixed3(r, g, b);</span></span></code> </pre> <br>  La cantidad de desplazamiento de los canales RGB se puede seleccionar arbitrariamente, pero incluso con este desplazamiento simple, se obtiene una imagen muy convincente: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a96/ccc/bd8/a96cccbd861252130d289d9362ef0ec0.gif"></div><br><h2>  Conclusi√≥n y descargas </h2><br>  Si est√° interesado en aprender c√≥mo crear texturas c√°usticas sin costura, entonces deber√≠a leer el interesante art√≠culo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="noopener noreferrer">Texturas c√°usticas peri√≥dicas</a> . <br><br>  Mientras tanto, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="noopener noreferrer">Florian</a> contin√∫a trabajando en su sombreador c√°ustico y ha realizado algunas mejoras bastante interesantes que se pueden ver. <br><br><div class="oembed"><twitter-widget class="twitter-tweet twitter-tweet-rendered" id="twitter-widget-1" style="position: static; visibility: visible; display: block; transform: rotate(0deg); max-width: 100%; width: 500px; min-width: 220px; margin-top: 10px; margin-bottom: 10px;" data-tweet-id="1167866285369131008"></twitter-widget><script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></div><br>  Un paquete completo para este tutorial est√° disponible en Patreon, incluye todos los recursos necesarios para recrear esta t√©cnica.  El paquete se export√≥ desde Unity 2019.2 y requiere la pila de posprocesamiento v2. <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Activo est√°ndar</a> : solo archivo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">sombreador</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Activos pagados</a> : escena completa, incluyendo textura y materiales c√°usticos. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/467887/">https://habr.com/ru/post/467887/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../467875/index.html">No seas t√≠mido, menos</a></li>
<li><a href="../467877/index.html">Android para el ingeniero de radio (y no solo)</a></li>
<li><a href="../467881/index.html">Tutu.ru reuni√≥n de fondo</a></li>
<li><a href="../467883/index.html">Kubernetes 1.16: c√≥mo actualizar y no romper nada</a></li>
<li><a href="../467885/index.html">Producto y minas segmentadas</a></li>
<li><a href="../467891/index.html">Preguntas frecuentes sobre la firma en la nube [electr√≥nica]</a></li>
<li><a href="../467893/index.html">Solo otro contenedor Qt para gRPC y protobuf</a></li>
<li><a href="../467895/index.html">¬øQu√© patrones encuentran las redes neuronales?</a></li>
<li><a href="../467897/index.html">Herramientas de prueba autom√°tica, integraci√≥n Yandex Mapkit 3, dise√±o atractivo y enfoque de interfaz de usuario impulsada por el servidor: anuncio de mitap de Android</a></li>
<li><a href="../467903/index.html">Las 20 mejores funciones de navegaci√≥n en IntelliJ IDEA. Parte 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>