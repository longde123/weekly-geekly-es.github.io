<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§≤ üë®üèª‚Äç‚úàÔ∏è üêù Uma vis√£o geral dos m√©todos de vincula√ß√£o de texto üßëüèΩ‚Äçü§ù‚Äçüßëüèª üé® üöï</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="1. Introdu√ß√£o 


 H√° algum tempo, participei de um projeto para desenvolver um produto de software projetado para analisar registros e dados de pacien...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Uma vis√£o geral dos m√©todos de vincula√ß√£o de texto</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/417465/"><h2 id="vvedenie">  1. Introdu√ß√£o </h2><br><p>  H√° algum tempo, participei de um projeto para desenvolver um produto de software projetado para analisar registros e dados de pacientes sobre seu estado de sa√∫de provenientes de organiza√ß√µes m√©dicas, a fim de criar um registro m√©dico unificado.  Por um longo tempo, a equipe n√£o p√¥de desenvolver uma abordagem para combinar dados do paciente.  O ponto de partida foi o estudo dos c√≥digos-fonte da solu√ß√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Open EMPI</a> (Open Enterprise Master Patient Index), que nos levou a criar algoritmos de an√°lise de similaridade.  A partir desse momento, iniciou-se um estudo mais aprofundado dos materiais, o que possibilitou a cria√ß√£o de um layout primeiro e, depois, de uma solu√ß√£o funcional. </p><br><p>  At√© agora, em v√°rios tipos de apresenta√ß√µes, √© preciso ouvir muitas perguntas sobre a l√≥gica do trabalho de tais produtos, das quais concluo que uma revis√£o dos m√©todos de vincula√ß√£o de texto ser√° de interesse de um amplo c√≠rculo de leitores. </p><br><p>  O material √© uma tradu√ß√£o do artigo da Wikip√©dia " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Record linkage</a> " com direitos autorais e adi√ß√µes. </p><a name="habracut"></a><br><h2 id="chto-takoe-svyazyvanie-tekstovyh-zapisey">  O que √© vincula√ß√£o de texto? </h2><br><p>  O termo <em>"</em> liga√ß√£o de registro" descreve o processo de anexar registros de texto de uma fonte de dados a registros de outra, desde que descrevam o mesmo objeto.  Na ci√™ncia da computa√ß√£o, isso √© chamado de <em>"mapeamento de dados"</em> ou <em>"problema de identidade de objeto"</em> .  √Äs vezes, defini√ß√µes alternativas s√£o usadas, como <em>"identifica√ß√£o"</em> , <em>"liga√ß√£o"</em> , <em>detec√ß√£o de duplicados "</em> , <em>" desduplica√ß√£o "</em> , <em>" registros correspondentes "</em> , <em>" identifica√ß√£o de objetos "</em> , que descrevem o mesmo conceito.  Essa abund√¢ncia terminol√≥gica levou a uma separa√ß√£o das abordagens de processamento e estrutura√ß√£o de informa√ß√µes - <em>liga√ß√£o de</em> <em>registros</em> e <em>liga√ß√£o de dados</em> .  Embora ambos determinem a identifica√ß√£o de objetos correspondentes por diferentes conjuntos de par√¢metros, o termo "vinculando registros de texto" √© comumente usado quando se refere √† <em>"ess√™ncia" de uma</em> pessoa, enquanto "vincula√ß√£o de dados" significa a possibilidade de vincular qualquer recurso da Web entre conjuntos de dados, usando, respectivamente, o conceito mais amplo de um identificador, ou seja, um URI. </p><br><h2 id="zachem-eto-nuzhno">  Por que isso √© necess√°rio? </h2><br><p>  Ao desenvolver produtos de software para a constru√ß√£o de sistemas automatizados usados ‚Äã‚Äãem v√°rios campos relacionados ao processamento de dados pessoais de uma pessoa (assist√™ncia m√©dica, hist√≥rico, estat√≠sticas, educa√ß√£o etc.), surge a tarefa de identificar dados sobre assuntos cont√°beis provenientes de v√°rias fontes. </p><br><p>  No entanto, ao coletar descri√ß√µes de um grande n√∫mero de fontes, surgem problemas que dificultam sua identifica√ß√£o inequ√≠voca.  Esses problemas incluem: </p><br><ul><li>  erros de digita√ß√£o; </li><li>  permuta√ß√µes de campo (por exemplo, no primeiro nome); </li><li>  o uso de abrevia√ß√µes e abrevia√ß√µes; </li><li>  o uso de um formato diferente de identificadores (datas, n√∫meros de documentos etc.). </li><li>  distor√ß√£o fon√©tica; </li><li>  etc. </li></ul><br><p>  A qualidade dos dados brutos afeta diretamente o resultado do processo de liga√ß√£o.  Devido a esses problemas, os conjuntos de dados s√£o frequentemente transferidos para o processamento, que, embora descrevam o mesmo objeto, parece que esses registros parecem diferentes.  Portanto, por um lado, todos os identificadores de registro transmitidos s√£o avaliados quanto √† aplicabilidade para uso no processo de identifica√ß√£o e, por outro lado, os pr√≥prios registros s√£o normalizados ou padronizados para traz√™-los para um √∫nico formato. </p><br><h2 id="ekskurs-v-istoriyu">  Tour hist√≥rico </h2><br><p>  A id√©ia original de vincular notas foi apresentada por Halbert L. Dunn, que publicou um artigo intitulado "Record Linkage" no American Journal of Public Health em 1946. </p><br><p>  Mais tarde, em 1959, em um artigo na Vincula√ß√£o autom√°tica de registros vitais na revista Science, Howard B. Newcombe lan√ßou os fundamentos probabil√≠sticos da moderna teoria das cordas, que foram desenvolvidas e refor√ßadas em 1969 por Ivan Fellegi e Alan. Santer (Alan Sunter).  Seu trabalho "Uma teoria para a liga√ß√£o de registros" ainda √© a base matem√°tica de muitos algoritmos de liga√ß√£o. </p><br><p>  O principal desenvolvimento dos algoritmos foi nos anos 90 do s√©culo passado.  Ent√£o, de v√°rias √°reas (estat√≠stica, arquivamento, epidemiologia, hist√≥ria e outras), chegaram-nos algoritmos frequentemente usados ‚Äã‚Äãem produtos de software, como a <em>similaridade (dist√¢ncia) da dist√¢ncia de</em> Jaro-Winkler e a dist√¢ncia de <em>Levenshtein</em> , no entanto, algumas solu√ß√µes, por exemplo, o algoritmo fon√©tico Soundex, apareceram muito antes - nos anos 20 do s√©culo passado. </p><br><h2 id="algoritmy-sravneniya-tekstovyh-zapisey">  Algoritmos de compara√ß√£o de entrada de texto </h2><br><p>  Distinga entre algoritmos <em>determin√≠sticos</em> e <em>probabil√≠sticos</em> para comparar registros de texto.  Os algoritmos determin√≠sticos s√£o baseados na coincid√™ncia completa dos atributos do registro.  Os algoritmos probabil√≠sticos permitem calcular o grau de correspond√™ncia dos atributos do registro e, com base nisso, decidir a possibilidade de seu relacionamento. </p><br><h3 id="determinirovannye-algoritmy">  Algoritmos determin√≠sticos </h3><br><p>  A maneira mais f√°cil de comparar seq√º√™ncias de caracteres √© baseada em regras claras quando links entre objetos s√£o gerados com base no n√∫mero de correspond√™ncias dos atributos dos conjuntos de dados.  Ou seja, dois registros correspondem um ao outro atrav√©s de um algoritmo determin√≠stico se todos ou alguns de seus atributos forem id√™nticos.  Os algoritmos determin√≠sticos s√£o adequados para comparar assuntos descritos por um conjunto de dados que s√£o identificados por um identificador comum (por exemplo, o n√∫mero de seguro de uma conta pessoal individual no Fundo de Pens√µes - SNILS) ou t√™m v√°rios identificadores representativos (data de nascimento, sexo etc.) confi√°veis. </p><br><p>  Algoritmos determin√≠sticos podem ser aplicados quando conjuntos de dados claramente estruturados (padronizados) s√£o transferidos para o processamento. </p><br><p>  Por exemplo, ele tem o seguinte conjunto de entradas de texto: </p><br><table><thead><tr><th>  N√£o. </th><th>  SNILS </th><th>  Primeiro nome </th><th>  Data de nascimento </th><th>  Sexo </th></tr></thead><tbody><tr><td>  A1 </td><td>  163-648-564 96 </td><td>  Zhvanetsky Mikhail </td><td>  03/06/1934 </td><td>  M </td></tr><tr><td>  A2 </td><td>  163-648-564 96 </td><td>  Zhvanetsky Mikhail </td><td>  03/06/1934 </td><td>  M </td></tr><tr><td>  A3 </td><td>  126-029-036 24 </td><td>  Ilchenko Victor </td><td>  01/02/1937 </td><td>  M </td></tr><tr><td>  A4 </td><td></td><td>  Novikova Klara </td><td>  26.12.1946 </td><td>  F </td></tr></tbody></table><br><table><thead><tr><th>  N√£o. </th><th>  SNILS </th><th>  Primeiro nome </th><th>  Data de nascimento </th><th>  Sexo </th></tr></thead><tbody><tr><td>  B1 </td><td>  126-029-036 24 </td><td>  Ilyichenko Victor </td><td>  01/02/1937 </td><td>  M </td></tr><tr><td>  B2 </td><td></td><td>  Zhivanetsky Mikhail </td><td>  03/06/1934 </td><td>  M </td></tr><tr><td>  B3 </td><td></td><td>  Zerchaninova Klara </td><td>  26.12.1946 </td><td>  2 </td></tr></tbody></table><br><p>  Foi dito anteriormente que o algoritmo determin√≠stico mais simples √© o uso de um identificador √∫nico, que deveria identificar uma pessoa de forma exclusiva.  Por exemplo, supomos que todos os registros que possuem o mesmo valor identificador (SNILS) descrevam o mesmo assunto, caso contr√°rio, s√£o assuntos diferentes.  A conex√£o determin√≠stica neste caso ir√° gerar os seguintes pares: A1 e A2, A3 e B1.  B2 n√£o ser√° associado a A1 e A2, pois o identificador n√£o importa, embora coincida no conte√∫do com os registros especificados. </p><br><p>  Essas exce√ß√µes levam √† necessidade de suplementar o algoritmo determin√≠stico com novas regras.  Por exemplo, se n√£o houver um identificador exclusivo, voc√™ poder√° usar outros atributos, como nome, data de nascimento e sexo.  No exemplo dado, essa regra adicional novamente n√£o dar√° correspond√™ncia B2 e A1 / A2, porque agora os nomes s√£o diferentes - h√° uma distor√ß√£o fon√©tica do sobrenome. </p><br><p>  Esse problema pode ser resolvido usando os m√©todos de an√°lise fon√©tica, mas se voc√™ alterar o sobrenome (por exemplo, no caso de casamento), ser√° necess√°rio recorrer √† aplica√ß√£o de uma nova regra, por exemplo, comparar a data de nascimento ou permitir diferen√ßas nos atributos existentes do registro (por exemplo, sexo). </p><br><p>  O exemplo ilustra claramente que o algoritmo determin√≠stico √© muito sens√≠vel √† qualidade dos dados, e um aumento no n√∫mero de atributos de registro pode levar a um aumento substancial no n√∫mero de regras aplicadas, o que complica bastante o uso de algoritmos determin√≠sticos. </p><br><p>  Al√©m disso, o uso de algoritmos determin√≠sticos √© poss√≠vel se houver um conjunto de dados verificado (refer√™ncia principal) com o qual as informa√ß√µes recebidas s√£o comparadas.  No entanto, no caso de reabastecimento constante do pr√≥prio diret√≥rio mestre, pode ser necess√°ria uma revis√£o completa dos relacionamentos existentes, o que torna o uso de algoritmos determin√≠sticos demorado ou simplesmente imposs√≠vel. </p><br><h3 id="veroyatnostnye-algoritmy">  Algoritmos Probabil√≠sticos </h3><br><p>  Os algoritmos probabil√≠sticos para vincular registros de cadeia de caracteres usam um conjunto mais amplo de atributos que os determin√≠sticos, e para cada atributo √© calculado um coeficiente de peso que determina a capacidade de influenciar a conex√£o na avalia√ß√£o final da probabilidade de conformidade dos registros estimados.  Os registros que acumularam o peso total acima de um determinado limite s√£o considerados relacionados, os registros que acumularam o peso total abaixo de um limite s√£o considerados n√£o relacionados.  Os pares que obtiveram o valor do peso total no meio da faixa s√£o considerados candidatos √† vincula√ß√£o e podem ser considerados mais tarde (por exemplo, pelo operador), que decidir√£o sobre sua uni√£o (link) ou os deixar√£o separados.  Assim, diferentemente dos algoritmos determin√≠sticos, que s√£o um conjunto de um grande n√∫mero de regras claras (programadas), os algoritmos probabil√≠sticos podem ser adaptados √† qualidade dos dados selecionando valores de limiar e n√£o requerem reprograma√ß√£o. </p><br><p>  Assim, algoritmos probabil√≠sticos atribuem coeficientes de peso ( <em>u</em> e <em>m</em> ) aos atributos do registro, com a ajuda da qual ser√° determinada sua correspond√™ncia ou inconsist√™ncia entre si. </p><br><p>  O coeficiente u determina a probabilidade de que os identificadores de dois registros independentes coincidam aleatoriamente.  Por exemplo, a probabilidade de u do m√™s de nascimento (quando existem doze valores uniformemente distribu√≠dos) √© 1 \ 12 = 0,083.  Identificadores com valores que n√£o s√£o distribu√≠dos uniformemente ter√£o probabilidades diferentes para valores diferentes (√†s vezes, incluindo valores ausentes). </p><br><p>  O coeficiente m √© a probabilidade de que os identificadores nos pares comparados correspondam entre si ou sejam bastante semelhantes - por exemplo, no caso de uma alta probabilidade pelo algoritmo de Jaro-Winkler ou baixa pelo algoritmo de Levenshtein.  Se os atributos dos registros forem totalmente consistentes, esse valor dever√° ter um valor de 1,0, mas, dada a baixa probabilidade disso, o coeficiente dever√° ser avaliado de forma diferente.  Essa avalia√ß√£o pode ser feita com base na an√°lise preliminar do conjunto de dados, por exemplo, <em>"aprendendo"</em> manualmente <em>o</em> algoritmo probabil√≠stico para identificar um grande n√∫mero de pares correspondentes e incompat√≠veis ou iniciando iterativamente o algoritmo para selecionar o valor do coeficiente m mais adequado. </p><br><p>  Se a probabilidade m for definida como 0,95, os coeficientes de conformidade / n√£o conformidade para o m√™s de nascimento ter√£o a seguinte apar√™ncia: </p><br><table><thead><tr><th>  M√©trica </th><th>  Partilha de links </th><th>  Compartilhamento de valores, n√£o refer√™ncias </th><th>  Frequ√™ncia </th><th>  Peso </th></tr></thead><tbody><tr><td>  Conformidade </td><td>  m = 0,95 </td><td>  u = 0,083 </td><td>  m \ u = 11,4 </td><td>  ln (m / u) / ln (2) ‚âà 3,51 </td></tr><tr><td>  Incompatibilidade </td><td>  1-m = 0,05 </td><td>  1-u = 0,917 </td><td>  (1 m) / (1 u) ‚âà 0,0545 </td><td>  ln ((1-m) / (1-u)) / ln (2) ‚âà -4,20 </td></tr></tbody></table><br><p>  C√°lculos semelhantes devem ser feitos para outros identificadores de registro, a fim de determinar seus coeficientes de conformidade e n√£o conformidade.  Em seguida, cada identificador de um registro √© comparado com o identificador correspondente de outro registro para determinar o peso total do par: o peso do par correspondente √© adicionado ao resultado total com um total cumulativo, enquanto o peso do par inadequado √© subtra√≠do do resultado total.  A quantidade resultante √© comparada com os valores limite identificados para determinar se deve ou n√£o emparelhar o par analisado automaticamente ou transferi-lo para o operador para considera√ß√£o. </p><br><h4 id="blokirovanie">  Bloqueio </h4><br><p>  A determina√ß√£o dos limites de conformidade / n√£o conformidade √© um equil√≠brio entre a obten√ß√£o de sensibilidade aceit√°vel (a parcela de registros relacionados detectados pelo algoritmo) e o valor preditivo do resultado (ou seja, precis√£o, como uma medida de registros realmente correspondentes vinculados pelo algoritmo).  Como definir limites pode ser uma tarefa muito dif√≠cil, especialmente para grandes conjuntos de dados, um m√©todo conhecido como <em>bloqueio</em> √© frequentemente usado para aumentar a efici√™ncia computacional.  S√£o feitas tentativas para realizar uma compara√ß√£o entre registros para os quais √© revelada uma discrep√¢ncia significativa ( <em>discrimina√ß√£o</em> ) nos valores dos atributos b√°sicos.  Isso leva a um aumento na precis√£o devido a uma diminui√ß√£o na sensibilidade. </p><br><p>  Por exemplo, o bloqueio com base na codifica√ß√£o fon√©tica de um sobrenome reduz o n√∫mero total de compara√ß√µes necess√°rias e aumenta a probabilidade de que os relacionamentos entre os registros estejam corretos, pois os dois atributos j√° s√£o consistentes, mas podem ignorar registros relacionados √† mesma pessoa cujo sobrenome alterado (por exemplo, como resultado do casamento).  O bloqueio por m√™s de nascimento √© um indicador mais est√°vel que s√≥ pode ser ajustado se houver um erro nos dados de origem, mas oferece um benef√≠cio mais modesto em valor preditivo positivo e perda de sensibilidade, pois cria doze grupos diferentes de conjuntos de dados extremamente grandes e n√£o leva a um aumento na velocidade computa√ß√£o. </p><br><p>  Assim, os sistemas de liga√ß√£o de entrada de texto mais eficientes costumam usar v√°rios passes de bloqueio para agrupar dados de v√°rias maneiras, a fim de preparar grupos de registros que devem ser submetidos posteriormente para an√°lise. </p><br><h4 id="mashinnoe-obuchenie">  Aprendizado de m√°quina </h4><br><p>  Recentemente, v√°rios m√©todos de aprendizado de m√°quina foram usados ‚Äã‚Äãpara vincular registros de texto.  Em um artigo de 2011, Randall Wilson mostrou que o algoritmo cl√°ssico de vincula√ß√£o probabil√≠stica para registros de texto √© equivalente ao ing√™nuo algoritmo de Bayes e sofre os mesmos problemas com a suposi√ß√£o de que os recursos de classifica√ß√£o s√£o independentes.  Para aumentar a precis√£o da an√°lise, o autor prop√µe usar um modelo b√°sico de uma rede neural chamada perceptron de camada √∫nica, cuja utiliza√ß√£o permite exceder significativamente os resultados obtidos usando algoritmos probabil√≠sticos tradicionais. </p><br><h2 id="foneticheskoe-kodirovanie">  Codifica√ß√£o fon√©tica </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Os algoritmos fon√©ticos</a> combinam duas palavras pronunciadas da mesma forma com os mesmos c√≥digos, o que permite comparar essas palavras com base em sua similaridade fon√©tica. </p><br><p>  A maioria dos algoritmos fon√©ticos √© projetada para analisar palavras em ingl√™s, embora recentemente alguns algoritmos tenham sido modificados para uso em outros idiomas ou tenham sido originalmente criados como solu√ß√µes nacionais (por exemplo, Caverphone). </p><br><h3 id="soundex">  Soundex </h3><br><p>  O algoritmo cl√°ssico para comparar duas cordas pelo som √© o Soundex (abrevia√ß√£o de √çndice de som).  Ele define o mesmo c√≥digo para strings que possuem um som semelhante em ingl√™s.  O Soundex foi originalmente usado pela Administra√ß√£o de Arquivos Nacionais dos EUA na d√©cada de 1930 para analisar retrospectivamente os censos de 1890 a 1920. </p><br><p>  Os autores dos algoritmos s√£o Robert C. Russel e Margaret King Odell, que o patentearam nos anos 20 do s√©culo passado.  O pr√≥prio algoritmo ganhou popularidade na segunda metade do s√©culo passado, quando se tornou objeto de v√°rios artigos em revistas cient√≠ficas populares nos EUA e foi publicado na monografia de D. Knut, ‚ÄúThe Art of Programming‚Äù. </p><br><h3 id="daitch-mokotoff-soundex">  Daitch-Mokotoff Soundex </h3><br><p>  Como o Soundex √© adequado apenas para o ingl√™s, alguns pesquisadores tentaram modific√°-lo.  Em 1985, Gary Mokotoff e Randy Daitch propuseram uma variante do algoritmo Soundex, projetada para comparar sobrenomes do Leste Europeu (incluindo russo) com uma qualidade bastante alta. </p><br><h3 id="metaphone">  Metaphone </h3><br><p>  Nos anos 90, Lawrence Philips (Lawrence Philips) prop√¥s uma vers√£o alternativa do algoritmo Soundex, chamado Metaphone.  O novo algoritmo usou um conjunto maior de regras para a pron√∫ncia em ingl√™s, devido √† qual era mais preciso.  Posteriormente, o algoritmo foi modificado para ser utilizado em outras l√≠nguas, com base na transcri√ß√£o, utilizando letras do alfabeto latino. </p><br><h3 id="russkiy-metaphone">  Metaphone russo </h3><br><p>  Em 2002, a 8¬™ edi√ß√£o da revista Programmer publicou um artigo de Peter Kankowski falando sobre sua adapta√ß√£o da vers√£o em ingl√™s do algoritmo Metaphone.  Esta vers√£o do algoritmo converte as palavras-fonte de acordo com as regras e normas da l√≠ngua russa, levando em considera√ß√£o o som fon√©tico das vogais n√£o estressadas e a poss√≠vel "fus√£o" de consoantes na pron√∫ncia. </p><br><h2 id="vmesto-zaklyucheniya">  Em vez de uma conclus√£o </h2><br><p>  Como resultado de v√°rias itera√ß√µes, a equipe de projeto do projeto de desenvolvimento de produto de software, mencionada na introdu√ß√£o, desenvolveu uma solu√ß√£o de arquitetura, cujo esquema √© mostrado na figura. <br><img src="https://habrastorage.org/webt/fr/yx/dg/fryxdgd4sf1lcf1iachctg_rvqc.png"></p><br><p>  As descri√ß√µes textuais dos pacientes s√£o aceitas pelo servi√ßo REST e armazenadas no reposit√≥rio (banco de dados do cart√£o) sem nenhuma altera√ß√£o.  Como nosso sistema trabalha com dados m√©dicos, o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">padr√£o FHIR</a> (Fast Healthcare Interoperability Resources) foi escolhido para troca de informa√ß√µes.  As informa√ß√µes sobre o cart√£o do paciente recebido s√£o transferidas para a fila de mensagens para posterior an√°lise e tomada de decis√£o sobre o estabelecimento da comunica√ß√£o. </p><br><p>  O primeiro cart√£o a ser processado √© o <em>‚ÄúQuick Analyzer‚Äù</em> operando em um algoritmo determin√≠stico.  Se todas as regras do algoritmo determin√≠stico tiverem funcionado, ele cria um registro com um link para o cart√£o processado em um armazenamento separado (banco de dados de links).  O registro cont√©m, al√©m do identificador do cart√£o analisado, a data do estabelecimento da comunica√ß√£o e um identificador condicional que identifica o paciente globalmente identificado.  Cart√µes adicionais s√£o ainda referidos ao identificador global especificado, formando assim uma matriz que descreve um indiv√≠duo espec√≠fico. </p><br><p>  Se o algoritmo determin√≠stico n√£o encontrar uma correspond√™ncia, as informa√ß√µes do cart√£o s√£o transmitidas atrav√©s da fila de mensagens para o ‚ÄúAnalisador Completo‚Äù. </p><br><p>       (  ).       .       : </p><br><p><img src="https://habrastorage.org/webt/i8/_7/-k/i8_7-km0ifcsu6llsqhmsruperg.png"></p><br><p> <strong> 1.  -</strong> <br>            ,       .          2. </p><br><p> <strong> 2.  </strong> <br>    -       ,         (). </p><br><p> <strong> 3.  </strong> <br>        ,    ,   (  )  ,      . </p><br><p> <strong> 4.   </strong> <br>     ,        .         .       ,      ,     .       ,   ,    ,         . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt417465/">https://habr.com/ru/post/pt417465/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt417453/index.html">Organiza√ß√£o de est√°gios para estudantes: truques e truques</a></li>
<li><a href="../pt417457/index.html">Frontend Conf Moscow - entrada e sa√≠da do cliente</a></li>
<li><a href="../pt417459/index.html">Conhe√ßa o seu JIT: mais perto do carro</a></li>
<li><a href="../pt417461/index.html">Ivan Tulup: ass√≠ncrono em JS sob o cap√¥</a></li>
<li><a href="../pt417463/index.html">Uma reuni√£o inesperada. Cap√≠tulo 17</a></li>
<li><a href="../pt417469/index.html">Cinco raz√µes ego√≠stas para trabalhar de forma reproduz√≠vel</a></li>
<li><a href="../pt417471/index.html">Solda simples MK936 SMD. Esta√ß√£o de solda DIY para componentes SMD</a></li>
<li><a href="../pt417473/index.html">Armazenamento confi√°vel com DRBD9 e Proxmox (parte 1: NFS)</a></li>
<li><a href="../pt417475/index.html">Codifica√ß√£o Glusterfs + apagamento: quando voc√™ precisar de muito, barato e confi√°vel</a></li>
<li><a href="../pt417477/index.html">Secret√°ria quente</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>