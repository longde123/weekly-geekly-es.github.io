<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßñüèΩ üßòüèø üï¥üèø Sketch + Node.js: Generieren Sie Symbole f√ºr viele Plattformen und Marken. Teil 2 üöô üë©‚Äç‚ù§Ô∏è‚Äçüë® üôáüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dies ist der zweite Teil des Artikels √ºber das Erstellen eines Tools, mit dem alle in einer Skizzendatei platzierten Symbole exportiert werden k√∂nnen:...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sketch + Node.js: Generieren Sie Symbole f√ºr viele Plattformen und Marken. Teil 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/442886/"><img src="https://habrastorage.org/webt/na/kj/v5/nakjv5srowi99bsjteoqabwtoz8.png"><br><br>  Dies ist der zweite Teil des Artikels √ºber das Erstellen eines Tools, mit dem alle in einer Skizzendatei platzierten Symbole exportiert werden k√∂nnen: in verschiedenen Formaten f√ºr verschiedene Plattformen mit der M√∂glichkeit, jedes Symbol A / B zu testen. <br><br>  Sie k√∂nnen den ersten Teil <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√ºber den Link</a> lesen. <br><br><img src="https://habrastorage.org/webt/s6/lt/2d/s6lt2dttycpvlqbolmyeyacaeas.png"><br><br>  Beim letzten Mal haben wir Skizzendateien vorbereitet, die alle Symbole in den richtigen Stilen und mit den richtigen Namen enthalten.  Es ist an der Zeit, Code zu schreiben. <br><br>  Es gen√ºgt zu sagen, dass wir Versuch und Irrtum durchlaufen haben.  Nachdem unser Teamleiter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nihil Verma</a> , der den Grundstein f√ºr das Skript gelegt hatte, den wichtigsten Quellcode entwickelt hatte, startete ich einen Prozess, der mindestens drei Phasen des Refactorings und viele √Ñnderungen erforderte.  Aus diesem Grund werde ich nicht auf die Details der Erstellung des Skripts eingehen und mich darauf konzentrieren, wie es heute in seiner endg√ºltigen Form funktioniert. <br><a name="habracut"></a><br><h2>  Skript erstellen </h2><br>  Das auf Node.js geschriebene Build-Skript ist in seiner Arbeit ziemlich einfach: Durch Importieren von Abh√§ngigkeiten, Deklarieren einer Liste von Sketch-Dateien zur Verarbeitung (es ist eine Liste von Marken, von denen jede eine Liste von Dateien enth√§lt) und Sicherstellen, dass Sketch auf dem Client installiert ist Das Skript verarbeitet die Marken nacheinander und f√ºhrt mit jeder eine Reihe von Aktionen aus. <br><br><ol><li>  Nimmt Design-Token, die f√ºr Marken geeignet sind (wir ben√∂tigen Farbwerte). <br></li><li>  Klont markenassoziierte Skizzendateien, entpackt sie, extrahiert interne JSON-Dateien und verarbeitet einige ihrer internen Werte (dazu sp√§ter mehr). <br></li><li>  Liest die erforderlichen Metadaten aus diesen JSON-Dateien ( <i>document.json</i> , <i>meta.json</i> und <i>pages / pageUniqueID.json</i> ).  Wir sind an Listen g√§ngiger Stile und Ressourcen / Symbole interessiert, die in Dateien enthalten sind. <br></li><li>  Nach einigen weiteren Manipulationen mit JSON-Dateien wird das Archiv neu erstellt und mithilfe von Skizzendateien (geklont und aktualisiert) die endg√ºltigen Ausgabedateien f√ºr drei Plattformen (iOS, Android, Mobile Web) exportiert und erstellt. <br></li></ol><br>  Die relevanten Teile des Build-Skripts finden Sie hier: <br><br><pre><code class="plaintext hljs">// ... modules imports here const SKETCH_FILES = { badoo: ['icons_common'], blendr: ['icons_common', 'icons_blendr'], fiesta: ['icons_common', 'icons_fiesta'], hotornot: ['icons_common', 'icons_hotornot'], }; const SKETCH_FOLDER_PATH = path.resolve(__dirname, '../src/'); const SKETCH_TEMP_PATH = path.resolve(SKETCH_FOLDER_PATH, 'tmp'); const DESTINATION_PATH = path.resolve(__dirname, '../dist'); console.log('Build started...'); if (sketchtool.check()) { console.log(`Processing Sketch file via ${sketchtool.version()}`); build(); } else { console.info('You need Sketch installed to run this script'); process.exit(1); } // ---------------------------------------- function build() { // be sure to start with a blank slate del.sync([SKETCH_TEMP_PATH, DESTINATION_PATH]); // process all the brands declared in the list of Sketch files Object.keys(SKETCH_FILES).forEach(async (brand) =&gt; {   // get the design tokens for the brand   const brandTokens = getDesignTokens(brand);    // prepare the Sketch files (unzipped) and get a list of them   const sketchUnzipFolders = await prepareSketchFiles({     brand,     sketchFileNames: SKETCH_FILES[brand],     sketchFolder: SKETCH_FOLDER_PATH,     sketchTempFolder: SKETCH_TEMP_PATH   });   // get the Sketch metadata   const sketchMetadata = getSketchMetadata(sketchUnzipFolders);   const sketchDataSharedStyles = sketchMetadata.sharedStyles;   const sketchDataAssets = sketchMetadata.assetsMetadata;   generateAssetsPDF({     platform: 'ios',     brand,     brandTokens,     sketchDataSharedStyles,     sketchDataAssets   });   generateAssetsSVGDynamicMobileWeb({     platform: 'mw',     brand,     brandTokens,     sketchDataSharedStyles,     sketchDataAssets   });   generateAssetsVectorDrawableDynamicAndroid({     platform: 'android',     brand,     brandTokens,     sketchDataSharedStyles,     sketchDataAssets   }); }); }</code> </pre> <br>  Tats√§chlich ist der Pipeline-Code viel komplizierter.  Der Grund f√ºr diese Komplexit√§t liegt in den Funktionen <code>prepareSketchFiles</code> , <code>getSketchMetadata</code> und <code>generateAssets[format][platform]</code> .  Im Folgenden werde ich versuchen, sie genauer zu beschreiben. <br><br><h2>  Skizzendateien vorbereiten </h2><br>  Der erste Schritt im Assemblierungsprozess ist die Erstellung von Skizzendateien, die sp√§ter zum Exportieren von Ressourcen f√ºr verschiedene Plattformen verwendet werden. <br><br>  Dateien, die einer bestimmten Marke zugeordnet sind (im Fall von Blendr sind dies beispielsweise <i>icons_common.sketch-</i> und <i>icons_blendr.sketch-Dateien</i> ), werden in einen tempor√§ren Ordner (genauer gesagt in einen Unterordner, der nach der verarbeiteten Marke benannt ist) geklont und entpackt. <br><br>  Dann werden die JSON-Dateien verarbeitet.  Dem Namen der Ressourcen, die A / B-Tests unterzogen werden, wird ein Pr√§fix hinzugef√ºgt. Beim Exportieren werden sie daher in einem Unterordner mit einem vordefinierten Namen (entsprechend dem eindeutigen Namen des Experiments) gespeichert.  <i>Anhand</i> des Namens der Seite, auf der sie gespeichert ist, k√∂nnen Sie nachvollziehen, ob eine Ressource einem A / B-Test unterzogen wird. Wenn dies der <i>Fall</i> ist, enth√§lt der Name das Pr√§fix " <i>XP_</i> ". <br><br><img src="https://habrastorage.org/webt/k7/qo/df/k7qodfiyytkacnk1uknx_6gxhzw.png"><br><br>  Im obigen Beispiel werden die exportierten Ressourcen in einem Unterordner von " <i>this__is_an_experiment</i> " mit einem Dateinamen der Form " <i>icon-name [variantenname] .ext</i> " <i>gespeichert</i> . <br><br><h2>  Skizzenmetadaten lesen </h2><br>  Der zweite wichtige Schritt besteht darin, alle erforderlichen Metadaten aus Skizzendateien bzw. internen JSON-Dateien zu extrahieren.  Wie wir oben gesehen haben, sind dies zwei Hauptdateien ( <i>document.json</i> und <i>meta.json</i> ) und <i>Auslagerungsdateien</i> ( <i>pages / pageUniqueId.json</i> ). <br><br>  Die Datei <i>document.json</i> wird verwendet, um die Liste der allgemeinen Stile <i>abzurufen</i> , die unter der Eigenschaft des <i>layerStyles-</i> Objekts <i>angezeigt</i> werden: <br><br><pre> <code class="plaintext hljs">{ "_class": "document", "do_objectID": "45D2DA82-B3F4-49D1-A886-9530678D71DC", "colorSpace": 1, ... "layerStyles": {  "_class": "sharedStyleContainer",  "objects": [    {      "_class": "sharedStyle",      "do_objectID": "9BC39AAD-CDE6-4698-8EA5-689C3C942DB4",      "name": "features/feature-like",      "value": {        "_class": "style",        "fills": [          {            "_class": "fill",            "isEnabled": true,            "color": {              "_class": "color",              "alpha": 1,              "blue": 0.10588235408067703,              "green": 0.4000000059604645,              "red": 1            },            "fillType": 0,            "noiseIndex": 0,            "noiseIntensity": 0,            "patternFillType": 1,            "patternTileScale": 1          }        ],        "blur": {...},        "startMarkerType": 0,        "endMarkerType": 0,        "miterLimit": 10,        "windingRule": 1      }    },    ...</code> </pre> <br>  Wir speichern grundlegende Informationen zu jedem Stil in einem Objekt im Schl√ºsselwertformat.  Es wird sp√§ter verwendet, wenn wir den Namen des Stils basierend auf einer eindeutigen ID <code>do_objectID</code> (Eigenschaft <code>do_objectID</code> in Sketch): <br><br><pre> <code class="plaintext hljs">const parsedSharedStyles = {}; parsedDocument.layerStyles.objects.forEach((object) =&gt; { parsedSharedStyles[object.do_objectID] = {  name: object.name,  isFill: _.get(object, 'value.fills[0].color') !== undefined,  isBorder: _.get(object, 'value.borders[0].color') !== undefined, }; });</code> </pre> <br>  Jetzt gehen wir zur Datei <i>meta.json</i> und erhalten eine Liste der Seiten.  Wir interessieren uns f√ºr ihre <code>unique-id</code> und ihren <code>name</code> : <br><br><pre> <code class="plaintext hljs">{ "commit": "623a23f2c4848acdbb1a38c2689e571eb73eb823", "pagesAndArtboards": {  "EE6BE8D9-9FAD-4976-B0D8-AB33D2B5DBB7": {    "name": "Icons",    "artboards": {      "3275987C-CE1B-4369-B789-06366EDA4C98": {        "name": "badge-feature-like"      },      "C6992142-8439-45E7-A346-FC35FA01440F": {        "name": "badge-feature-crush"      },      ...      "7F58A1C4-D624-40E3-A8C6-6AF15FD0C32D": {        "name": "tabbar-livestream"      }      ...    }  },  "ACF82F4E-4B92-4BE1-A31C-DDEB2E54D761": {    "name": "XP_this__is_an_experiment",    "artboards": {      "31A812E8-D960-499F-A10F-C2006DDAEB65": {        "name": "this__is_an_experiment/tabbar-livestream[variant1]"      },      "20F03053-ED77-486B-9770-32E6BA73A0B8": {        "name": "this__is_an_experiment/tabbar-livestream[variant2]"      },      "801E65A4-3CC6-411B-B097-B1DBD33EC6CC": {        "name": "this__is_an_experiment/tabbar-livestream[control]"      }    }  },</code> </pre> <br>  Dann lesen wir die JSON-Dateien, die jeder Seite im <i>Seitenordner</i> entsprechen (ich wiederhole, dass die Dateinamen die Form <i>[pageUniqueId] .json haben</i> ) und untersuchen die auf dieser Seite gespeicherten Ressourcen (sie sehen aus wie Ebenen).  Auf diese Weise erhalten wir den <b>Namen</b> , die <b>Breite / H√∂he</b> jedes Symbols, Skizzenmetadaten f√ºr das Symbol dieser Ebene und, wenn es sich um eine Expertenseite handelt, den Namen des <b>A / B-Tests</b> und eine <b>Variante</b> dieses Symbols. <br><br>  <i>Hinweis</i> : Das page.json-Objekt verf√ºgt √ºber ein sehr komplexes Ger√§t, daher werde ich nicht weiter darauf eingehen.  Wenn Sie daran interessiert sind, was sich darin befindet, empfehle ich Ihnen, eine neue leere Skizzendatei zu erstellen, Inhalte hinzuzuf√ºgen und zu speichern.  Benennen Sie dann die Erweiterung in ZIP um, entpacken Sie sie und √ºberpr√ºfen Sie eine der Dateien im Seitenordner. <br><br>  W√§hrend der Verarbeitung von Zeichenfl√§chen erstellen wir auch eine <b>Liste von Experimenten</b> (und zugeh√∂rigen Ressourcen).  Wir werden es ben√∂tigen, um zu bestimmen, welche Variationen des Symbols in welchem ‚Äã‚ÄãExperiment verwendet werden - die Namen der Variationen des Symbols werden an das Basisobjekt angeh√§ngt. <br><br>  F√ºr jede markenspezifische Skizzendatei, die verarbeitet wird, erstellen wir ein <code>assetsMetadata</code> Objekt, das folgenderma√üen aussieht: <br><br><pre> <code class="plaintext hljs">{ "navigation-bar-edit": {  "do_objectID": "86321895-37CE-4B3B-9AA6-6838BEDB0977",  ...sketch_artboard_properties,  "name": "navigation-bar-edit",  "assetname": "navigation-bar-edit",  "source": "icons_common",  "width": 48,  "height": 48  "layers": [    {      "do_objectID": "A15FA03C-DEA6-4732-9F85-CA0412A57DF4",      "name": "Path",      ...sketch_layer_properties,      "sharedStyleID": "6A3C0FEE-C8A3-4629-AC48-4FC6005796F5",      "style": {        ...        "fills": [          {            "_class": "fill",            "isEnabled": true,            "color": {              "_class": "color",              "alpha": 1,              "blue": 0.8784313725490196,              "green": 0.8784313725490196,              "red": 0.8784313725490196            },          }        ],        "miterLimit": 10,        "startMarkerType": 0,        "windingRule": 1      },    },  ],  ... }, "experiment-name/navigation-bar-edit[variant]": {  "do_objectID": "00C0A829-D8ED-4E62-8346-E7EFBC04A7C7",  ...sketch_artboard_properties,  "name": "experiment-name/navigation-bar-edit[variant]",  "assetname": "navigation-bar-edit",  "source": "icons_common",  "width": 48,  "height": 48  ...</code> </pre> <br>  Wie Sie sehen k√∂nnen, kann im Experiment ein einzelnes Symbol (in diesem Fall die <i>Bearbeitung der Navigationsleiste</i> ) vielen Ressourcen entsprechen.  Gleichzeitig wird m√∂glicherweise dasselbe Symbol unter demselben Namen in einer anderen mit der Marke verkn√ºpften Skizzendatei angezeigt.  <b>Dies ist sehr n√ºtzlich</b> : Wir verwenden diesen Trick, um einen gemeinsamen Satz von Symbolen zu kompilieren und dann bestimmte Optionen entsprechend der Marke zu identifizieren.  Aus diesem Grund haben wir die einer bestimmten Marke zugeordneten Skizzendateien als Array deklariert: <br><br><pre> <code class="plaintext hljs">const SKETCH_FILES = { badoo: ['icons_common'], blendr: ['icons_common', 'icons_blendr'], fiesta: ['icons_common', 'icons_fiesta'], hotornot: ['icons_common', 'icons_hotornot'], };</code> </pre> <br>  In diesem Fall ist die Ordnung von grundlegender Bedeutung.  Tats√§chlich geben wir in der vom Skript <code>getSketchMetadata</code> Funktion <code>getSketchMetadata</code> keine <code>assetsMetadata</code> Objekte <code>assetsMetadata</code> als <code>assetsMetadata</code> .  Stattdessen f√ºhren wir eine tiefe Zusammenf√ºhrung von Objekten durch - wir kombinieren sie und geben ein einzelnes <code>assetsMetadata</code> Objekt zur√ºck. <br><br>  Im Allgemeinen ist dies nichts anderes als eine ‚Äûlogische‚Äú Zusammenf√ºhrung von Skizzendateien und ihren Ressourcen zu einer einzigen Datei.  Die Logik ist jedoch nicht so einfach, wie es scheint.  Hier ist ein Diagramm, das wir erstellt haben, um herauszufinden, was passiert, wenn Symbole mit demselben Namen (und m√∂glicherweise A / B-Tests) in verschiedenen Dateien derselben Marke zugeordnet sind: <br><br><img src="https://habrastorage.org/webt/yg/ug/-6/ygug-6xnds3cvysntithaenmbfw.png"><br><br><h2>  Erstellung von vorgefertigten Dateien in verschiedenen Formaten f√ºr verschiedene Plattformen </h2><br>  In der letzten Phase unseres Prozesses werden direkt Symboldateien in verschiedenen Formaten f√ºr verschiedene Plattformen erstellt (PDF f√ºr iOS, SVG / JSX f√ºr Web und VectorDrawable f√ºr Android). <br><br>  Wie Sie an der Anzahl der Parameter erkennen k√∂nnen, die an die Funktionen <code>generateAssets[format][platform]</code> werden, ist dieser Teil der Pipeline der komplexeste.  Hier beginnt der Prozess, sich je nach Plattform aufzul√∂sen und zu √§ndern.  Im Folgenden sehen Sie den logischen Verlauf des Skripts als Ganzes und wie der Teil, der sich auf die Ressourcengenerierung bezieht, in drei √§hnliche, aber unterschiedliche Prozesse unterteilt ist: <br><br> <a href=""><img src="https://habrastorage.org/webt/jv/83/xy/jv83xyzcpvzmn4snh0xakkrfu8k.png"></a> <br><br>  Um vorgefertigte Ressourcen mit den richtigen Farben zu erstellen, die der zu verarbeitenden Marke entsprechen, m√ºssen wir einige weitere Manipulationen mit JSON-Dateien durchf√ºhren.  Wir gehen alle Ebenen durch, auf die der allgemeine Stil angewendet wird, und ersetzen die Farbwerte durch die Farben aus dem Design-Token der Marke. <br><br>  Um Dateien f√ºr Android zu generieren, m√ºssen Sie eine zus√§tzliche Aktion ausf√ºhren (etwas sp√§ter): Wir √§ndern die <code>windingRule</code> jeder Ebene von <code>even-odd</code> auf <code>non-zero</code> (dies wird durch die <code>windingRule</code> Eigenschaft des JSON-Objekts gesteuert, wobei 1 "ungerade / gerade" bedeutet. und 0 ist "ungleich Null"). <br><br>  Nach diesen Manipulationen packen wir die JSON-Dateien wieder in eine Standard-Skizzendatei, um Ressourcen mit aktualisierten Eigenschaften zu verarbeiten und zu exportieren (geklonte und aktualisierte Dateien sind normale Skizzendateien, die ge√∂ffnet, angezeigt, bearbeitet, gespeichert usw. werden k√∂nnen). ) <br><br>  Danach verwenden wir SketchTool ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">unter Knoten eingeschlossen</a> ), um alle Ressourcen automatisch in f√ºr Plattformen geeigneten Formaten zu exportieren.  F√ºr jede der mit der Marke verkn√ºpften Dateien (oder vielmehr deren geklonten und aktualisierten Versionen) f√ºhren wir den folgenden Befehl aus: <br><br><pre> <code class="plaintext hljs">sketchtool.run(`export slices ${cloneSketchFile} --formats=svg --scales=1 --output=${destinationFolder} --overwriting`);</code> </pre> <br>  Wie Sie vielleicht erraten haben, exportiert dieser Befehl Ressourcen in einem bestimmten Format in den Zielordner, optional mithilfe der Skalierung (wir behalten die urspr√ºngliche Skalierung vorerst bei).  Der Schl√ºssel hier ist die Option <code>-overwriting</code> : Genau wie wir eine <code>assetsMetadata</code> Zusammenf√ºhrung von <code>assetsMetadata</code> Objekten (entsprechend den ‚Äûlogischen‚Äú <code>assetsMetadata</code> ) durchf√ºhren, f√ºhren wir beim Exportieren viele Dateien in einem Verzeichnis zusammen (bezogen auf die Marke / Plattform).  Dies bedeutet, dass die Ressource - identifiziert durch den Namen des Layers - bereits in der vorherigen Skizzendatei vorhanden war und beim n√§chsten Export √ºberschrieben wird.  Auch dies ist nichts weiter als ein normaler Zusammenf√ºhrungsvorgang. <br><br>  In diesem Beispiel k√∂nnen sich einige Ressourcen jedoch als "Geister" herausstellen.  Dies geschieht, wenn das Symbol in der Datei einem A / B-Test unterzogen wird, in der nachfolgenden Datei jedoch √ºberschrieben wird.  Anschlie√üend werden die Variantendateien in den <code>assetsMetadata</code> exportiert, haben einen Link, der der Ressource im <code>assetsMetadata</code> Objekt entspricht (mit ihrem Schl√ºssel und ihren Eigenschaften), sind jedoch keiner <code>assetsMetadata</code> (aufgrund der tiefen Zusammenf√ºhrung von <code>assetsMetadata</code> Objekten).  Solche Dateien werden sp√§ter gel√∂scht, bevor der Vorgang abgeschlossen wird. <br><br><hr><br>  Wie bereits erw√§hnt, erfordern unterschiedliche Plattformen unterschiedliche Ausgabeformate.  iOS-Dateien passen zu PDFs, und wir k√∂nnen sie direkt mit dem Befehl SketchTool exportieren.  JSX-Dateien sind f√ºr Mobile Web und VectorDrawable f√ºr Android erforderlich.  Aus diesem Grund exportieren wir Ressourcen im SVG-Format in einen tempor√§ren Ordner und verarbeiten sie anschlie√üend. <br><br><h2>  PDFs f√ºr iOS </h2><br>  Seltsamerweise ist PDF das einzige (?) Format, das Xcode und OS / iOS zum Importieren und Rendern von Vektorressourcen unterst√ºtzen ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier eine kurze Erkl√§rung der</a> Wahl <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">von</a> Apple). <br><br>  Da wir √ºber SketchTool direkt in PDF exportieren k√∂nnen, sind keine zus√§tzlichen Schritte erforderlich: Speichern Sie die Dateien einfach direkt im Zielordner, und fertig. <br><br><h2>  Reagieren / JSX-Webdateien </h2><br>  Im Web verwenden wir den SVGR-Bibliotheksknoten, mit dem Sie SVG in React-Komponenten konvertieren k√∂nnen.  Wir m√∂chten jedoch etwas abruptes tun: Das Symbol zur Laufzeit ‚Äûdynamisch einf√§rben‚Äú (Farben werden von Token √ºbernommen).  Zu diesem Zweck √§ndern wir vor dem Konvertieren die <code>fill</code> f√ºr Vektoren, auf die der allgemeine Stil zuvor auf Werte von Token angewendet wurde, die diesem Stil entsprechen. <br><br>  Wenn also die aus Sketch exportierte Datei <i>badge-feature-like.svg folgenderma√üen</i> aussieht: <br><br><pre> <code class="plaintext hljs">&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;svg width="128px" height="128px" viewBox="0 0 128 128" version="1.1" xmlns="&lt;a href="http://www.w3.org/2000/svg"&gt;http://www.w3.org/2000/svg&lt;/a&gt;" xmlns:xlink="&lt;a href="http://www.w3.org/1999/xlink"&gt;http://www.w3.org/1999/xlink&lt;/a&gt;"&gt; &lt;!-- Generator: sketchtool 52.2 (67145) -&lt;a href="http://www.bohemiancoding.com/sketch"&gt; http://www.bohemiancoding.com/sketch&lt;/a&gt; --&gt; &lt;title&gt;badge-feature-like&lt;/title&gt; &lt;desc&gt;Created with sketchtool.&lt;/desc&gt; &lt;g id="Icons" fill="none" fill-rule="evenodd"&gt;  &lt;g id="badge-feature-like"&gt;    &lt;circle id="circle" fill="#E71032" cx="64" cy="64" r="64"&gt;    &lt;path id="Shape" fill="#FFFFFF" d="M80.4061668,..."&gt;&lt;/path&gt;  &lt;/g&gt; &lt;/g&gt; &lt;/svg&gt;</code> </pre> <br>  dann <i>sieht</i> das endg√ºltige <i>Symbol</i> resource / <i>badge-feature-like.js folgenderma√üen</i> aus: <br><br><pre> <code class="plaintext hljs">/* This file is generated automatically - DO NOT EDIT */ /* eslint-disable max-lines,max-len,camelcase */ const React = require('react'); module.exports = function badge_feature_like({ tokens }) { return (  &lt;svg data-origin="pipeline" viewBox="0 0 128 128"&gt;    &lt;g fill="none" fillRule="evenodd"&gt;      &lt;circle fill={tokens.TOKEN_COLOR_FEATURE_LIKED_YOU} cx={64} cy={64} r={64} /&gt;      &lt;path fill="#FFF" d="M80.4061668,..." /&gt;    &lt;/g&gt;  &lt;/svg&gt; ); };</code> </pre> <br>  Wie Sie sehen k√∂nnen, haben wir die statische <code>fill</code> durch eine dynamische Farbe ersetzt, die Werte von Token √ºbernimmt (sie k√∂nnen f√ºr die Komponente React <code>&lt;Icon/&gt;</code> √ºber die Kontext-API verf√ºgbar gemacht werden, dies ist jedoch eine andere Geschichte). <br><br>  Diese Ersetzung ist dank der Sketch-Metadaten f√ºr die Assets des <code>assetsMetadata</code> Objekts m√∂glich: <code>assetsMetadata</code> Sie die Ebenen rekursiv durchlaufen, k√∂nnen Sie einen DOM-Selektor (f√ºr das obige Beispiel <code>#Icons</code> <code>#badge-feature-like #circle</code> ) <code>#badge-feature-like #circle</code> und damit nach einem Knoten im SVG-Baum suchen und dessen Wert ersetzen <code>fill</code> (daf√ºr ben√∂tigen wir die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Cheerio-</a> Bibliothek). <br><br><h2>  VectorDrawable-Dateien f√ºr Android </h2><br>  Android unterst√ºtzt Vektorgrafiken im benutzerdefinierten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">VectorDrawable-</a> Vektorformat.  Normalerweise erfolgt die Konvertierung von SVG nach VectorDrawable <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">direkt in Android Studio</a> .  Wir wollten den Prozess jedoch vollst√§ndig automatisieren und suchten nach einer M√∂glichkeit, mithilfe von Code zu konvertieren. <br><br>  Nachdem wir verschiedene Tools und Bibliotheken studiert hatten, entschieden wir uns f√ºr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">svg2vectordrawable</a> .  Es wird nicht nur aktiv unterst√ºtzt (auf jeden Fall aktiver als alle anderen), sondern auch funktionaler als die anderen. <br><br>  Die Realit√§t ist, dass VectorDrawable und SVG in ihrer Funktionalit√§t nicht identisch sind: Einige SVG-Funktionen (z. B. radiale Verl√§ufe und komplexe Hervorhebungen) werden von VectorDrawable nicht unterst√ºtzt, w√§hrend andere erst seit kurzem unterst√ºtzt werden (beginnend mit Android API 24).  Eines der daraus resultierenden Probleme besteht darin, dass √§ltere Versionen (bis zu 24) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">den geraden und ungeraden Wert des F√ºllregelattributs nicht unterst√ºtzen</a> .  Wir bei Badoo ben√∂tigen jedoch Unterst√ºtzung f√ºr Android 5 und h√∂her.  Aus diesem Grund haben wir in einer der fr√ºheren Phasen die <code>fill</code> jedes Vektors in den Skizzendateien auf einen Wert <code>non-zero</code> . <br><br>  Im Prinzip k√∂nnen Designer diese Aktion manuell ausf√ºhren: <br><br><img src="https://habrastorage.org/webt/oj/ec/bp/ojecbp2no3lxsas5uwxcqmobcji.png"><br><br>  Aber das ist leicht zu vergessen und einen Fehler zu machen.  Aus diesem Grund haben wir beschlossen, dem Prozess f√ºr Android einen zus√§tzlichen Schritt hinzuzuf√ºgen, bei dem alle Vektoren in JSON automatisch in einen Wert <code>non-zero</code> konvertiert werden.  Dies geschieht, damit Symbole beim Exportieren in SVG bereits im erforderlichen Format vorliegen und jedes erstellte VectorDrawable-Objekt von Ger√§ten unter Android 5 unterst√ºtzt wird. <br><br>  Die fertige Datei <i>badge-feature-like.xml</i> sieht folgenderma√üen aus: <br><br><pre> <code class="plaintext hljs">&lt;!-- This file is generated automatically - DO NOT EDIT --&gt; &lt;vector xmlns:android="&lt;a href="http://schemas.android.com/apk/res/android"&gt;http://schemas.android.com/apk/res/android&lt;/a&gt;" android:width="128dp" android:height="128dp" android:viewportWidth="128" android:viewportHeight="128"&gt; &lt;path  android:fillColor="?color_feature_liked_you"  android:pathData="M64 1a63 63 0 1 0 0 126A63 63 0 1 0 64 1z" /&gt; &lt;path  android:fillColor="#FFFFFF"  android:pathData="M80.406 ..." /&gt; &lt;/vector&gt;</code> </pre> <br>  In VectorDrawable-Dateien f√ºgen wir Variablennamen f√ºr <code>fill</code> , die Design-Token √ºber g√§ngige Stile in Android-Anwendungen zugeordnet sind. <br><br> <a href=""><img src="https://habrastorage.org/webt/zu/n4/8q/zun48q0knfv8k9xy4amb6eqrxxa.png"></a> <br><br>  Es ist erw√§hnenswert, dass Android Studio strenge Anforderungen an die Organisation von Ressourcen stellt: Keine Unterordner und Gro√übuchstaben in den Namen!  Wir mussten uns also ein neues Format f√ºr die <code>ic_icon-name__experiment-name__variant-name</code> : <code>ic_icon-name__experiment-name__variant-name</code> zu testenden Ressourcen sehen sie <code>ic_icon-name__experiment-name__variant-name</code> so aus: <code>ic_icon-name__experiment-name__variant-name</code> . <br><br><h2>  JSON-W√∂rterbuch als Ressourcenbibliothek </h2><br>  Nachdem die Ressourcendateien im endg√ºltigen Format gespeichert wurden, m√ºssen nur noch alle w√§hrend der Assembly erhaltenen Metainformationen gesammelt und in einem ‚ÄûW√∂rterbuch‚Äú gespeichert werden, das beim Importieren und Verwenden der Ressourcen durch die Codebasis verschiedener Plattformen verwendet werden soll. <br><br>  Nachdem wir eine flache Liste von <code>assetsMetadata</code> aus dem <code>assetsMetadata</code> Objekt <code>assetsMetadata</code> gehen wir sie durch und √ºberpr√ºfen sie jeweils: <br><br><ul><li>  Ist dies eine regul√§re Ressource (z. B. <code>tabbar-livestream</code> ) <code>tabbar-livestream</code>  wenn ja, dann lass es einfach; <br></li><li>  Wenn dies eine Option f√ºr einen A / B-Test ist (z. B. <i>Experiment / Tabbar-Livestream [Variante]</i> ), <i>ordnen</i> wir den Namen, den Pfad, die Namen des A / B-Tests und die Variante der Eigenschaft <code>abtests</code> <br>  die <i>Basisressource</i> (in unserem Fall <i>Tabbar-Livestream</i> ), wonach wir den Datensatz √ºber die Variante aus der Liste / dem Objekt l√∂schen (nur das Basiselement z√§hlt); <br></li><li>  Wenn es sich um einen ‚ÄûGeist‚Äú handelt, l√∂schen Sie die Datei und entfernen Sie den Eintrag aus der Liste / dem Objekt. <br></li></ul><br>  Nach Abschluss dieses Vorgangs enth√§lt das W√∂rterbuch eine Liste aller grundlegenden Symbole (und ihrer A / B-Tests, falls vorhanden) und nur dieser.  Zu den Informationen zu den einzelnen Optionen geh√∂ren Name, Gr√∂√üe, Pfad und, falls das Symbol einem A / B-Test unterzogen wird, Informationen zu den verschiedenen Optionen. <br><br>  Das W√∂rterbuch wird im JSON-Format im Zielordner f√ºr die <i>Marke</i> und die <i>Plattform</i> gespeichert.  Hier ist beispielsweise die Datei <i>resources.json</i> , die f√ºr die Blendr-Anwendung f√ºr Mobile Web generiert wurde: <br><br><pre> <code class="plaintext hljs">{ "platform": "mw", "brand": "blendr", "assets": {    "badge-feature-like": {    "assetname": "badge-feature-like",    "path": "assets/badge-feature-like.jsx",    "width": 64,    "height": 64,    "source": "icons_common"  },  "navigation-bar-edit": {    "assetname": "navigation-bar-edit",    "path": "assets/navigation-bar-edit.jsx",    "width": 48,    "height": 48,    "source": "icons_common"  },  "tabbar-livestream": {    "assetname": "tabbar-livestream",    "path": "assets/tabbar-livestream.jsx",    "width": 128,    "height": 128,    "source": "icons_blendr",    "abtest": {      "this__is_an_experiment": {        "control": "assets/this__is_an_experiment/tabbar-livestream__control.jsx",        "variant1": "assets/this__is_an_experiment/tabbar-livestream__variant1.jsx",        "variant2": "assets/this__is_an_experiment/tabbar-livestream__variant2.jsx"      },      "a_second-experiment": {        "control": "assets/a_second-experiment/tabbar-livestream__control.jsx",        "variantA": "assets/a_second-experiment/tabbar-livestream__variantA.jsx"      }    }  },  ... } }</code> </pre> <br>  Jetzt m√ºssen nur noch alle <i>Assets-</i> Ordner in ZIP-Archive gepackt werden, um das Herunterladen zu vereinfachen. <br><br><h2>  Zusammenfassung </h2><br>  Der im Artikel beschriebene Prozess, vom Klonen und Bearbeiten von Skizzendateien √ºber das Exportieren und Konvertieren von Ressourcen in von Plattformen unterst√ºtzte Formate bis hin zum Speichern gesammelter Metainformationen in der Ressourcenbibliothek, wird mit jeder im Build-Skript angek√ºndigten Marke wiederholt. <br><br>  Hier ist ein Screenshot, der das Erscheinungsbild der Ordner <i>src</i> und <i>dist</i> nach Abschluss des Vorgangs zeigt: <br><br><img src="https://habrastorage.org/webt/yg/nc/d9/ygncd9uupdngcnav-rmkrsq1dsg.png"><br><br>  In dieser Phase k√∂nnen Sie mit einem einfachen Befehl alle Ressourcen (JSON-, ZIP- und Ressourcendateien) auf den Remotespeicher hochladen und f√ºr alle Plattformen zum Herunterladen und Verwenden in der Codebasis verf√ºgbar machen. <br><br>  Wie genau Plattformen Ressourcen empfangen und verarbeiten (unter Verwendung von speziell f√ºr diesen Zweck erstellten benutzerdefinierten Skripten), geht nicht √ºber den Rahmen dieses Artikels hinaus.  Und diese Frage wird wahrscheinlich in einem der folgenden Beitr√§ge eines meiner Kollegen behandelt. <br><br><h2>  Schlussfolgerung (und gewonnene Erkenntnisse) </h2><br>  Ich habe Sketch immer geliebt.  Seit vielen Jahren ist das Programm das Standardwerkzeug f√ºr Entwickler und Designer.  Daher war ich sehr neugierig auf Integrationstools wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">HTML-Sketchapp</a> und andere √§hnliche Tools, die wir im Workflow und in unseren Pipelines verwenden k√∂nnen. <br><br>  Ich habe mich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wie viele andere</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">immer</a> um einen solchen (idealen) Prozess <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bem√ºht</a> : <br><br><img src="https://habrastorage.org/webt/kq/7l/n4/kq7ln4kr6txurb-mvh6brqbhnqe.png"><br><br>  Ich muss jedoch zugeben, dass ich anfing zu bezweifeln, dass Sketch ein geeignetes Werkzeug ist, insbesondere angesichts des Designsystems.  Aus diesem Grund habe ich mich mit anderen Diensten befasst, z. B. Figma mit seinen offenen APIs und Framer X mit praktischer Integration in React, da ich keine Ahnung hatte, wie sich Sketch in Richtung Integration mit dem Code bewegt (was auch immer es war). <br><br>  Dieses Projekt hat mich also √ºberzeugt.  Nicht vollst√§ndig, aber in vielerlei Hinsicht. <br><br>  Obwohl Sketch seine APIs nicht √∂ffnet, dient das Ger√§t der internen Struktur seiner Dateien als eine Art "inoffizielle" API.  Ersteller k√∂nnen verschl√ºsselte Namen verwenden oder Schl√ºssel in JSON-Objekten ausblenden. Stattdessen halten sie sich an eine klare, lesbare und konzeptionelle Namenskonvention.  Ich denke nicht, dass dies ein Unfall ist. <br><br>  Die Tatsache, dass Skizzendateien auf diese Weise verwaltet werden k√∂nnen, hat mir den Weg f√ºr viele zuk√ºnftige Entwicklungen und Verbesserungen ge√∂ffnet: von Plugins zur √úberpr√ºfung des Namens, des Stils und der Struktur von Ebenen f√ºr Symbole bis zur Integration in unser Wiki und zur Dokumentation unseres Design-Systems (gegenseitig).  Durch das Erstellen von Knotenanwendungen auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Electron</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Carlo</a> k√∂nnen wir Designern das Ausf√ºhren vieler Routineaufgaben erleichtern. <br><br>    (  ,  )   ,  Sketch-   Cosmos  ¬´ ¬ª ‚Äî      - Cosmos.   ,        (   ;    ,    ‚Äî ).    ,      ‚Äî  ,   ,  . <br><br>      ,  Sketch-  , ,    MVP-,       .    ,     ,     . , , -,  ‚Äî    ,             .  ,         . <br><br>  :       <i></i> ,      <i></i> .   ,       <i></i> . <br><br> ,    , ‚Äî   .  ,  ,       ,    (,         A/B-),            Node.js  Sketch. <br><br>   !     . <br><br><h2>  </h2><br>        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> (Mobile Web),     , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> (Android)  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> (iOS),           . <br><br>  Danke Jungs!             . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de442886/">https://habr.com/ru/post/de442886/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de442872/index.html">Wie ich das Osterei im Android-Schutz gefunden habe und keinen Job bei Google bekommen habe</a></li>
<li><a href="../de442876/index.html">Noise Mapping mit KSQL, Raspberry Pi und Radio</a></li>
<li><a href="../de442880/index.html">Virtuelle Pr√ºfpunkte: Checkliste einrichten</a></li>
<li><a href="../de442882/index.html">[Video] "Piems werden nicht ben√∂tigt" und drei weitere Projektmanagement-Ideen</a></li>
<li><a href="../de442884/index.html">Dank der Technologie k√∂nnen Sie bereits als Person mit dem Auto sprechen</a></li>
<li><a href="../de442888/index.html">Passen Sie die Auswahl auf reinem CSS an</a></li>
<li><a href="../de442890/index.html">CYOD? COPE? BYOD?</a></li>
<li><a href="../de442892/index.html">Debug-orientierte Programmierung oder Traurigkeit in den Augen des Integrators</a></li>
<li><a href="../de442896/index.html">Die additive Vollzyklusproduktion in einem Luftfahrtunternehmen ist eine Frage der nahen Zukunft</a></li>
<li><a href="../de442898/index.html">L√∂sungen f√ºr das Problem von Spam-Bots, die Telegrammgruppen hinzugef√ºgt wurden</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>