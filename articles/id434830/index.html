<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ““ ğŸ‘©ğŸ»â€ğŸ”§ ğŸ Komponen Bereaksi Akhir ğŸ‘¨ğŸ½â€ğŸš’ âš•ï¸ âŒ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Apa yang saya sukai dari ekosistem Bereaksi adalah bahwa banyak IDEAS berada di belakang banyak keputusan. Berbagai penulis menulis berbagai artikel u...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Komponen Bereaksi Akhir</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/434830/"><p>  Apa yang saya sukai dari ekosistem Bereaksi adalah bahwa banyak IDEAS berada di belakang banyak keputusan.  Berbagai penulis menulis berbagai artikel untuk mendukung tatanan yang ada dan menjelaskan mengapa semuanya "benar", sehingga semua orang mengerti bahwa partai berada di jalur yang benar. </p><br><p>  Setelah beberapa waktu, IDEA berubah sedikit, dan semuanya dimulai dari awal. </p><br><p>  Dan awal cerita ini adalah pemisahan komponen menjadi Kontainer dan non-Kontainer (populer disebut Komponen Bodoh, maaf untuk bahasa Prancis saya). </p><br><p><img src="https://habrastorage.org/webt/p3/cl/nl/p3clnlwh5eus18t7l4xkoxgc09a.jpeg"></p><a name="habracut"></a><br><h3 id="problema">  Masalah </h3><br><p>  Masalahnya sangat sederhana - unit test.  Baru-baru ini, ada beberapa gerakan menuju tes integrasi - yah, Anda tahu <em>"Tulis tes. Tidak terlalu banyak. Sebagian besar integrasi."</em>  .  Ini bukan ide yang buruk, dan jika waktunya singkat (dan tes tidak terlalu dibutuhkan) - inilah yang perlu Anda lakukan.  Anggap saja ini tes asap - untuk memverifikasi bahwa <em>sepertinya</em> tidak ada yang meledak. </p><br><p> Jika ada banyak waktu, dan tes diperlukan, lebih baik tidak pergi dengan cara ini, karena menulis tes integrasi yang baik sangat, sangat lama.  Hanya karena mereka akan tumbuh dan berkembang, dan untuk menguji tombol ketiga di sebelah kanan, Anda harus terlebih dahulu mengklik 3 tombol di menu, dan jangan lupa untuk login.  Secara umum - inilah <u>ledakan kombinatorial</u> pada plat perak. </p><br><p>  Solusi di sini adalah satu dan sederhana (menurut definisi) - tes unit.  Kemampuan untuk memulai tes dengan beberapa keadaan sudah siap dari beberapa bagian aplikasi.  Lebih tepatnya, untuk mengurangi (mempersempit) area pengujian dari Aplikasi atau <em>Blok Besar</em> menjadi sesuatu yang kecil - sebuah unit, tidak peduli apa itu.  Tidak perlu menggunakan enzim - Anda dapat menjalankan tes browser, jika jiwa bertanya.  Yang paling penting di sini adalah untuk dapat menguji sesuatu secara <em>terpisah</em> .  Dan tanpa terlalu banyak kesulitan. </p><br><p>  Isolasi adalah salah satu poin kunci dalam pengujian unit, dan itulah sebabnya unit test tidak suka.  Mereka tidak menyukainya karena berbagai alasan: </p><br><ul><li>  misalnya, "unit" Anda terlepas dari aplikasi, dan tidak berfungsi dalam komposisinya bahkan ketika tesnya sendiri berwarna hijau. </li><li>  atau misalnya karena isolasi adalah kuda bulat dalam kekosongan yang belum pernah dilihat siapa pun.  Bagaimana cara mencapainya, dan bagaimana mengukurnya? </li></ul><br><p>  Secara pribadi, saya tidak melihat masalah di sini.  Di paragraf pertama, <em>tentu saja,</em> Anda dapat merekomendasikan tes integrasi, mereka telah diciptakan untuk itu - untuk memeriksa bagaimana komponen pra-diuji dipasang dengan benar.  Anda mempercayai paket npm yang menguji, tentu saja, hanya diri mereka sendiri, dan bukan diri mereka sendiri sebagai bagian dari aplikasi Anda.  Apa perbedaan â€œkomponenâ€ Anda dengan paket â€œbukan Andaâ€? </p><br><p>  Dengan paragraf kedua, semuanya sedikit lebih rumit.  Dan artikel ini akan persis tentang hal ini (dan semuanya sebelum itu - pengantar) - tentang bagaimana membuat unit " <em>unit</em> " <em>dapat diuji</em> . </p><br><h3 id="razdelyay-i-vlastvuy">  Bagilah dan Taklukkan </h3><br><p>  Gagasan memisahkan komponen Bereaksi menjadi "Wadah" dan "Presentasi" bukanlah hal baru, dijelaskan dengan baik, dan telah berhasil menjadi sedikit ketinggalan jaman.  Jika kita mengambil sebagai dasar (apa yang dilakukan 99% pengembang) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sebuah artikel oleh Dan Abramov</a> , maka Komponen Presentasi: </p><br><ul><li>  Khawatir dengan bagaimana hal-hal terlihat </li><li> Dapat mengandung komponen presentasi dan wadah <code>**</code> di dalam, dan biasanya memiliki beberapa markup DOM dan gaya mereka sendiri) </li><li>  Slot dukungan (Sering memungkinkan penahanan melalui this.props.children) </li><li>  Aplikasi independen (Tidak memiliki ketergantungan pada sisa aplikasi, seperti tindakan Flux atau toko) </li><li>  Jangan bergantung pada data (Jangan tentukan bagaimana data dimuat atau dimutasi) </li><li>  Antarmuka didasarkan pada alat peraga (Menerima data dan panggilan balik secara eksklusif melalui alat peraga) </li><li>  Seringkali tanpa kewarganegaraan (Jarang memiliki status mereka sendiri (ketika mereka melakukannya, ini adalah keadaan UI daripada data)) </li><li>  Seringkali SFC (Ditulis sebagai komponen fungsional kecuali mereka membutuhkan status, pengait siklus hidup, atau optimalisasi kinerja) </li></ul><br><p>  Nah, Wadah semuanya adalah logika, semua akses ke data, dan seluruh aplikasi pada prinsipnya. </p><br><blockquote>  Dalam dunia yang ideal, wadah adalah bagasi, dan komponen presentasi adalah dedaunan. </blockquote><p>  Ada dua poin utama dalam definisi Dan: <em>"Aplikasi independen"</em> , yang hampir merupakan definisi akademis tentang "unit", dan * "Dapat berisi komponen presentasi dan wadah <code>**</code> " *, di mana bintang-bintang ini sangat menarik. </p><br><blockquote>  (terjemahan gratis) ** Dalam versi awal artikel saya, saya (Dan) mengatakan bahwa komponen presentasi hanya boleh mengandung komponen presentasi lainnya.  Saya tidak berpikir begitu lagi.  Jenis komponen adalah perincian dan dapat berubah seiring waktu.  Secara umum, jangan bagikan dan semuanya akan baik-baik saja. </blockquote><p>  Mari kita ingat apa yang terjadi setelah ini: </p><br><ul><li>  Dalam buku cerita, semuanya jatuh, karena semacam wadah, di tombol ketiga di sebelah kiri, merangkak ke sisi yang tidak ada.  Salam khusus untuk graphql, react-router dan lainnya react-intl. </li><li>  Kemampuan untuk menggunakan mount dalam tes hilang, karena itu membuat semuanya dari A ke Z, dan sekali lagi, di suatu tempat di kedalaman pohon render, seseorang melakukan sesuatu, dan tes jatuh. </li><li>  Kemampuan untuk mengontrol status aplikasi hilang, karena (secara kiasan), kemampuan untuk membasahi pemilih / penyelesai (terutama dengan proxyquire) hilang, dan seluruh sisi harus basah.  Dan ini keren untuk unit test. </li></ul><br><blockquote>  Jika Anda berpikir bahwa masalahnya sedikit dibikin - coba bekerja dalam tim ketika wadah ini, yang akan digunakan dalam non-wadah Anda, berubah di departemen lain, dan sebagai hasilnya, Anda dan mereka melihat tes dan Anda tidak dapat memahami mengapa kemarin semuanya itu berhasil, dan sekarang lagi. </blockquote><p>  Akibatnya, Anda harus menggunakan dangkal, yang <em>dengan desain</em> menghilangkan semua efek samping yang berbahaya (dan tidak terduga).  Berikut adalah contoh sederhana dari artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Mengapa saya selalu menggunakan dangkal"</a> </p><br><p>  Bayangkan Tooltip itu merender "?", Ketika diklik, tipe itu sendiri akan ditampilkan. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Tooltip <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react-cool-tooltip'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MyComponent = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { &lt;Tooltip&gt; hint: {veryImportantTextYouHaveToTest} &lt;<span class="hljs-regexp"><span class="hljs-regexp">/Tooltip&gt; }</span></span></code> </pre> <br><p>  Bagaimana cara mengujinya?  Pasang + klik + periksa apa yang terlihat.  Ini adalah tes integrasi, bukan unit, dan pertanyaannya adalah bagaimana mengklik komponen "asing" untuk Anda.  Tidak ada masalah dengan dangkal, karena tidak ada <em>otak</em> dan "komponen alien" itu sendiri.  Tetapi ada otak di sini, karena Tooltip adalah wadah, sementara MyComponent <em>praktis</em> presentasi. </p><br><pre> <code class="javascript hljs">jest.mock(<span class="hljs-string"><span class="hljs-string">'react-cool-tooltip'</span></span>, {<span class="hljs-attr"><span class="hljs-attr">default</span></span>: <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{children}</span></span></span><span class="hljs-function">) =&gt;</span></span> childlren});</code> </pre> <br><p>  Tetapi jika Anda bereaksi-cool-tooltip, maka tidak akan ada masalah dengan pengujian.  "Komponen" telah menjadi sangat banyak, lebih pendek, lebih <em>terbatas</em> . </p><br><p>  <strong>Komponen terakhir</strong> </p><br><ul><li>  komponen dengan ukuran terkenal, yang mungkin termasuk komponen final lainnya yang diketahui sebelumnya, atau tidak mengandungnya sama sekali. </li><li>  tidak mengandung wadah lain, karena mengandung keadaan yang tidak terkendali dan ukuran "naik", mis.  membuat komponen saat ini tidak <em>terbatas</em> . </li><li>  kalau tidak itu adalah komponen presentasi biasa.  Bahkan, persis seperti yang dijelaskan dalam versi <em>pertama</em> artikel Dan. </li></ul><br><p>  Komponen terakhir hanyalah gear yang diambil dari mekanisme besar. </p><br><p>  Seluruh pertanyaannya adalah bagaimana cara mengeluarkannya. </p><br><h3 id="reshenie-1---di">  Solusi 1 - DI </h3><br><p>  Favorit saya adalah Injeksi Ketergantungan.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dan juga mencintainya</a> .  Secara umum, ini bukan DI, tetapi "slot".  Singkatnya - tidak perlu menggunakan Kontainer di dalam Presentasi - mereka harus <em>disuntikkan di</em> sana.  Dan dalam tes akan mungkin untuk menyuntikkan sesuatu yang lain. </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    mount     const PageChrome = ({children, aside}) =&gt; ( &lt;section&gt; &lt;aside&gt;{aside}&lt;/aside&gt; {children} &lt;/section&gt; ); //     shallow,       //     mount ? , ,   wiring? const PageChromeContainer = () =&gt; ( &lt;PageChrome aside={&lt;ASideContainer /&gt;}&gt; &lt;Page /&gt; &lt;/PageChrome&gt; );</span></span></code> </pre> <br><p>  Ini persis seperti ketika <em>"kontainer adalah bagasi, dan komponen presentasi adalah daun"</em> </p><br><h3 id="reshenie-2---granicy">  Solusi 2 - Batas </h3><br><p>  DI sering kali bisa keren.  Mungkin sekarang% nama pengguna% berpikir bagaimana ini dapat diterapkan pada basis kode saat ini, dan solusinya tidak ditemukan ... </p><br><p>  Dalam kasus seperti itu, <strong>Perbatasan</strong> akan menyelamatkan Anda. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Boundary = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{children}</span></span></span><span class="hljs-function">) =&gt;</span></span> ( process.env.NODE_ENV === <span class="hljs-string"><span class="hljs-string">'test'</span></span> ? <span class="hljs-literal"><span class="hljs-literal">null</span></span> : children <span class="hljs-comment"><span class="hljs-comment">// //  jest.mock ); const PageChrome = () =&gt; ( &lt;section&gt; &lt;aside&gt;&lt;Boundary&gt;&lt;ASideContainer /&gt;&lt;/Boundary&gt;&lt;/aside&gt; &lt;Boundary&gt;&lt;Page /&gt;&lt;/Boundary&gt; &lt;/section&gt; );</span></span></code> </pre> <br><p>  Di sini, alih-alih "slot," semua "titik transisi" hanya berubah menjadi Batas, yang akan membuat <em>apa pun</em> selama pengujian.  Cukup <em>deklaratif</em> , dan persis apa yang Anda butuhkan untuk "mengambil gigi." </p><br><h3 id="reshenie-3---tier">  Solusi 3 - Tingkat </h3><br><p>  Perbatasan bisa sedikit kasar, dan mungkin lebih mudah untuk membuatnya sedikit lebih pintar dengan menambahkan sedikit pengetahuan tentang Layer. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> checkTier = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">tier</span></span></span><span class="hljs-function"> =&gt;</span></span> tier === currentTier; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> withTier = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">tier</span></span></span><span class="hljs-function"> =&gt;</span></span> WrapperComponent =&gt; <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function">) =&gt;</span></span> ( <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">process.env.NODE_ENV !== </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'test'</span></span></span></span><span class="hljs-function"><span class="hljs-params"> || checkTier(tier</span></span></span><span class="hljs-function">)) &amp;&amp; &lt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">WrapperComponent</span></span></span><span class="hljs-function">{...</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function">} /&gt; ); </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">const</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">PageChrome</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">section</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">aside</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">ASideContainer</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">aside</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Page</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">section</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ASideContainer = withTier(<span class="hljs-string"><span class="hljs-string">'UI'</span></span>)(...) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Page = withTier(<span class="hljs-string"><span class="hljs-string">'Page'</span></span>)(...) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> PageChromeContainer = withTier(<span class="hljs-string"><span class="hljs-string">'UI'</span></span>)(PageChrome);</code> </pre> <br><p>  Di bawah nama Tier / Layer, bisa ada hal yang berbeda - fitur, bebek, modul, atau hanya layer / tier itu.  Intinya tidak penting, yang utama adalah Anda dapat menarik persneling, mungkin bukan satu, tetapi angka terakhir, <em>entah bagaimana</em> menarik garis antara apa yang Anda butuhkan dan apa yang tidak Anda butuhkan (untuk tes yang berbeda ini adalah perbatasan yang berbeda). </p><br><p>  Dan tidak ada yang mencegah menandai batas-batas ini dengan cara yang berbeda. </p><br><h3 id="reshenie-4separate-concerns">  Solusi 4 - Kekhawatiran Terpisah </h3><br><p>  Jika solusinya (menurut definisi) terletak pada pemisahan entitas - apa yang akan terjadi jika kita mengambil dan memisahkannya? </p><br><p>  "Wadah," yang sangat tidak kita sukai, biasanya disebut <em>wadah</em> .  Dan jika tidak - tidak ada yang mencegah sekarang mulai memberi nama Components entah bagaimana lebih nyaring.  Atau mereka memiliki pola tertentu dalam namanya - Connect (WrappedComonent), atau GraphQL / Query. </p><br><p>  Bagaimana jika hak dalam runtime menarik garis antara entitas berdasarkan nama? </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> PageChrome = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">section</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">aside</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">ASideContainer</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">aside</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Page</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">section</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ); <span class="hljs-comment"><span class="hljs-comment">// remove all components matching react-redux pattern reactRemock.mock(/Connect\(\w\)/) // all any other container reactRemock.mock(/Container/)</span></span></code> </pre> <br><p>  Ditambah satu baris dalam pengujian, dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">reaksi ulang akan</a> menghapus semua wadah yang dapat mengganggu tes. </p><br><p>  Pada prinsipnya, pendekatan ini dapat digunakan untuk menguji wadah itu sendiri - Anda hanya perlu <em>menghapus</em> semuanya kecuali wadah pertama. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {createElement, remock} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react-remock'</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  "" const ContainerCondition = React.createContext(true); reactRemock.mock(/Connect\(\w\)/, (type, props, children) =&gt; ( &lt;ContainerCondition.Consumer&gt; { opened =&gt; ( opened ? ( // ""     &lt;ContainerCondition.Provider value={false}&gt; {createElement(type, props, ...children)} &lt;ContainerCondition.Provider&gt; ) // "" : null )} &lt;/ContainerCondition.Consumer&gt; )</span></span></code> </pre> <br><p>  Sekali lagi - beberapa garis dan gigi dilepas. </p><br><h2 id="itogo">  Total </h2><br><p>  Selama setahun terakhir, pengujian komponen Bereaksi menjadi lebih rumit, terutama untuk pemasangan - Anda perlu menimpa semua 10 Penyedia, Konteks, dan semakin sulit untuk menguji komponen yang tepat dalam gaya yang tepat - ada terlalu banyak tali untuk ditarik. <br>  Seseorang meludah dan pergi ke dunia yang dangkal.  Seseorang melambaikan tangan pada unit test dan memindahkan semuanya ke Cypress (berjalan seperti berjalan!). </p><br><p>  Seseorang menusuk jari di reaksi, mengatakan bahwa ini adalah <em>efek aljabar</em> dan Anda dapat melakukan apa pun yang Anda inginkan.  Semua contoh di atas pada dasarnya adalah penggunaan <em>efek</em> dan ejekan <em>aljabar</em> ini.  Bagi saya dan DI ini adalah moki. </p><br><blockquote>  PS: Posting ini ditulis sebagai tanggapan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">terhadap komentar dalam React / RFC tentang fakta bahwa tim React memecahkan segalanya, dan semua polimer di sana juga</a> <br>  PPS: Posting ini sebenarnya adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">terjemahan lain yang sangat gratis</a> <br>  PPPS: Secara umum, untuk isolasi nyata, lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">rewiremock</a> </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id434830/">https://habr.com/ru/post/id434830/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id434818/index.html">Kecelakaan di CenturyLink Data Center menyebabkan 911 gangguan layanan</a></li>
<li><a href="../id434822/index.html">Program RRT "Mobil dengan sumber energi baru." Apa yang diharapkan pada 2019</a></li>
<li><a href="../id434824/index.html">Polit-Teknik Elektro. Pemodelan proses sosial-politik oleh sirkuit listrik</a></li>
<li><a href="../id434826/index.html">Tempat tidur tepat waktu, atau 5 tanda masalah tersembunyi di tim</a></li>
<li><a href="../id434828/index.html">Menjadi seorang profesional. Kebiasaan yang berguna dari desainer UX</a></li>
<li><a href="../id434836/index.html">Anotasi Versi Hebat di JPA</a></li>
<li><a href="../id434838/index.html">Membuat bot untuk berpartisipasi dalam Piala AI Rusia 2018 CodeBall</a></li>
<li><a href="../id434840/index.html">Bagaimana saya melakukan "Buku Harian Anda" - atau situasi di pasar buku harian elektronik</a></li>
<li><a href="../id434842/index.html">Peternakan kota bisa sangat efektif, tetapi tidak sekarang</a></li>
<li><a href="../id434844/index.html">Pemulihan kemampuan kognitif 100 pasien (terjemahan artikel oleh Dale Bredesen)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>