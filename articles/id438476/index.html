<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏸 😳 🚦 Untuk pertanyaan tentang buffer (dering) 🏡 👵 📐</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content=""Jika Anda menemukan biaya pengembangan arsitektur berlebihan, pertimbangkan berapa banyak arsitektur yang salah dapat dikenakan biaya" 
 - Saya tidak...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Untuk pertanyaan tentang buffer (dering)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438476/"><h3>  "Jika Anda menemukan biaya pengembangan arsitektur berlebihan, pertimbangkan berapa banyak arsitektur yang salah dapat dikenakan biaya" </h3><br>  - Saya tidak ingat persis sumbernya <br><br>  Suatu kali, "dahulu sekali, di satu galaksi yang jauh," saya membeli buku indah Charles Weatherly "Etudes for Programmers", dalam pengantar yang penulis memperkuat kebutuhan untuk mempelajari contoh dan tugas pendidikan sebelum memulai pemrograman independen.  Saya sangat menyarankan agar Anda menemukan buku ini, membaca kata pengantar (dan tanpa berhenti, membaca sisanya dan menyelesaikan masalah yang diberikan di dalamnya), karena saya tidak bisa lebih baik membuktikan perlunya praktik semacam itu.  Bahkan jika Anda mengikuti rekomendasi saya, dan mendapatkan banyak pengetahuan dan keterampilan praktis saat membaca buku, Anda dapat kembali dan membaca posting ini, karena ini dikhususkan untuk beberapa masalah lain.  Dan jika Anda tidak mengikuti rekomendasi saya, maka semakin Anda harus pergi di bawah kucing. <br><a name="habracut"></a><br>  Belum lama berselang di sebuah pos di mana saya memarahi saya menyatakan pendapat saya tentang satu RTOS domestik, saya menyebutkan bahwa implementasi buffer cincin di perpustakaan mcucpp yang terkenal (dan dalam aspek-aspek tertentu, benar-benar luar biasa) tidak dapat dianggap ideal.  Saya akan mencoba menjelaskan sudut pandang saya dan membayangkan implementasi ideal (sejauh mungkin di dunia nyata).  Catatan - teks yang ditawarkan kepada Anda terletak pada "belum selesai" untuk beberapa waktu, dan kemudian kasus yang nyaman muncul. <br><br>  Kami terus mengembangkan perpustakaan untuk bekerja dengan perangkat periferal, dan kami berada di baris berikutnya untuk manajemen memori dan buffering (ya, kami masih melanjutkan operasi persiapan, tetapi tanpa mereka dengan cara apa pun).  Dari mana datangnya kebutuhan untuk mengatur buffer dan hewan seperti apa itu?  Faktanya adalah bahwa bagian penting dari pinggiran memiliki kecepatan terbatas dan proses transmisi, dimulai dengan satu atau lain cara, memerlukan waktu tertentu, dan kadang-kadang sangat signifikan dibandingkan dengan membuat bagian lain dari informasi untuk transmisi.  Tentu saja, sebelum waktu ini berlalu, transmisi berikutnya tidak dapat dilakukan dan, karenanya, tidak dapat dimulai. <br><br>  Kami memiliki casing klasik pasangan penulis-pembaca dengan kecepatan berbeda.  Sangat tidak mungkin untuk menyelesaikan masalah ini secara umum, karena "dengan kelebihan kecil, tetapi tidak nol, dari aliran permintaan di atas aliran layanan, ukuran antrian cenderung tak terhingga," dan tak terhingga secara fundamental mustahil.  Tetapi kasus khusus masalah, ketika kita memiliki semburan permintaan lokal, tetapi rata-rata aliran layanan mampu mengatasi beban, memori buffer kapasitas yang cukup dapat dipecahkan.  Mari kita perhatikan frasa “kapasitas yang memadai”, kita nanti akan belajar bagaimana menghitungnya, selama fakta bahwa ini pada dasarnya memungkinkan sudah cukup bagi kita. <br><br>  Apakah memori penyangga merupakan persyaratan mutlak, tentu saja tidak.  Untuk informasi yang ditransmisikan, Anda dapat menggunakan catatan pemblokiran, tetapi dengan informasi yang diterima itu agak buruk, itu harus ditambahkan di suatu tempat sebelum diproses, jika Anda tidak mengambil langkah-langkah yang sesuai dalam protokol tingkat atas (ekspresi ajaib xon / xoff tidak dilahirkan dari awal), yang tidak selalu memungkinkan dan, dalam hal apa pun, biasanya mengarah pada batasan signifikan dari laju transmisi.  Ada juga implementasi perangkat keras buffer internal di perangkat periferal (setidaknya untuk satu elemen), tetapi ini tidak selalu dilakukan dan ukuran buffer sangat terbatas dari atas. <br><br>  Oleh karena itu, kami masih akan mengimplementasikan buffer program, yang wajar jika menggunakan metode FIFO (yaitu, antrian) untuk mengatur buffer tersebut, dan antrian tersebut, paling baik diimplementasikan pada buffer cincin dengan dua pointer.  Ketika saya menulis "terbaik", ini tidak berarti sama sekali bahwa implementasi lain (misalnya, antrian referensi) tidak mungkin, atau memiliki kelemahan fatal selain fatal.  Ungkapan ini hanya berarti bahwa implementasinya tidak akan terlalu rumit dan cukup efektif, walaupun yang lain mungkin memiliki kelebihan yang tidak dapat disangkal darinya, yang mana mereka harus membayar untuk sesuatu, karena DarZaNeBy. <br><br>  Karena sangat tidak mungkin bahwa model MK Anda akan memiliki implementasi perangkat keras dari perangkat serba guna (modul periferal individu dapat memiliki buffer cincinnya sendiri, tetapi tidak ada hubungannya dengan topik tulisan ini), kami harus membuat buffer cincin dalam memori linier (diterapkan pada vektor, ini, secara umum, satu-satunya objek alami dalam memori yang dapat dialamatkan), dan untuk ini, indeks buffer (atau mungkin bahkan dua indeks, tetapi lebih lanjut tentang itu nanti) akan diperlukan.  Menurut pendapat saya, buffer melingkar dengan dua pointer (indeks) adalah satu-satunya cara yang dapat diterima untuk mengimplementasikan antrian pada vektor, tetapi ada sudut pandang yang berbeda tentang masalah ini dan saya melihat dengan mata kepala sendiri sebuah implementasi dalam gaya “x1 = x2;  x2 = x3; ... x8 = simbol baru ", jika Anda mau, saya tidak akan mempertimbangkan eksotis semacam itu.  Fakta bahwa fragmen yang diberikan mungkin memiliki hak untuk eksis dalam situasi tertentu yang sangat terbatas tidak membuatnya diterima secara umum. <br><br>  Kami akan mempertimbangkan implementasi yang benar dari modul program untuk mengatur pointer, dan untuk mulai dengan, perhatikan kata pertama dalam definisi.  Perbedaan antara kode yang benar dan salah bukan hanya karena kode yang benar tidak mengandung kesalahan, meskipun ini merupakan persyaratan mutlak.  Bahkan kode yang sepenuhnya menjalankan fungsinya mungkin salah jika tidak dapat dipahami, atau jika ada opsi yang tidak kurang jelas, tetapi berjalan lebih cepat, atau dieksekusi dengan cepat, tetapi ditulis lebih jelas, sehingga konsep kebenaran agak relatif.  Kami melanjutkan pertimbangan kami terhadap contoh implementasi buffer kami, yang akan memungkinkan kami untuk menunjukkan perbedaan antara berbagai tingkat kebenaran. <br><br>  Sebelum beralih ke esensi, satu poin penting tentang pembahasan lebih lanjut.  Maksud saya, kompiler Anda selalu dihidupkan pada tingkat otpimisasi non-nol (-O2), jadi kami tidak perlu memikirkan perbaikan kecil seperti 1) modifikasi awalan versus postfix, atau 2) menggunakan hasil operasi sebelumnya, atau 3) perbedaan antara kenaikan dan penambahan unit dan seterusnya - kita mengasumsikan bahwa kompiler akan melakukan banyak hal untuk kita.  Tentu saja, ini bukan asumsi yang ketat, tetapi kalau tidak kita harus terjun ke perut assembler, yang pada zaman kita bukanlah arus utama. <br><br>  Biarkan saya mengingatkan Anda bahwa kami diperintahkan untuk menerapkan indeks (pointer) dari buffer cincin, yaitu, kita perlu membuat perilaku variabel yang <b>secara berurutan berjalan melalui serangkaian nilai, dari beberapa awal hingga akhir</b> .  Segera berasumsi bahwa nilai awal akan nol, jika tidak kita akan segera harus menulis kode yang kurang lebih benar, dan ini bertentangan dengan tujuan pendidikan dan kami tidak terburu-buru, dan yang terakhir adalah Max. <br><br>  Perilaku variabel ini dapat diimplementasikan menggunakan konstruksi berikut: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Counter = <span class="hljs-number"><span class="hljs-number">0</span></span>; Counter = (++Counter) % (Max+<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br>  dan justru kode tersebut yang dapat kita lihat dalam banyak kasus (yaitu, sangat sering).  Apa yang salah - yah, pertama, untuk beberapa waktu (dari melakukan operasi kenaikan hingga penetapan hasil) variabel kami akan lebih besar dari nilai maksimum yang diijinkan dan, jika pada saat itu terjadi interupsi yang perlu memperhitungkan nilai variabel ini, maka saya pribadi memprediksi Saya tidak menganggap hasilnya.  Karena itu, kami menulis ulang program: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Counter=<span class="hljs-number"><span class="hljs-number">0</span></span>; Counter = (Counter + <span class="hljs-number"><span class="hljs-number">1</span></span>) % (Max + <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br>  Kami telah menghilangkan satu kesalahan, dan kode tersebut (selanjutnya saya maksudkan kode "executable" berarti kode yang dapat dieksekusi yang dihasilkan oleh kompiler) tidak menjadi lebih lama dan dijalankan tidak lagi (pada kenyataannya, ia mengeksekusi lebih cepat, tetapi hanya karena dalam versi pertama kata volatile digunakan sepenuhnya berlebihan dalam hal ini), dan belum menjadi kurang jelas (lebih tepatnya, bahkan lebih jelas, tetapi ini adalah masalah selera). <br><br>  Catatan yang diperlukan tentang volatile - direktif ini diperlukan jika kita ingin menghindari optimasi kode yang mengarah pada eksekusi yang salah, dan dalam kasus khusus ini (ketika nilai variabel tidak berubah di luar ruang lingkup modul dan tidak ada entri berurutan di dalamnya) itu (direktif ) sepenuhnya berlebihan.  Saya sangat menyarankan Anda melihat kode yang dihasilkan untuk kedua opsi di godbolt.org.  Mengapa Anda tidak boleh menyalahgunakan arahan volatile, tidak seperti kata kunci statis, yang direkomendasikan untuk digunakan sedapat mungkin.  Yah, pertama, kami melarang pengoptimalan, yaitu, kode pasti tidak akan menjadi lebih cepat (kemungkinan besar, itu akan menjadi lebih besar dan lebih lambat, tetapi kami lebih suka formulasi yang ketat).  Dan kedua, dalam kasus khusus ini, kata ini menyesatkan, karena dalam kaitannya dengan program kami, nilai penghitung sama sekali tidak dapat berubah di luar kendali kami.  Dalam sebuah program yang membaca nilainya - yaitu, dalam implementasi buffer cincin itu sendiri, Anda dapat mempertimbangkan penghitung sebagai bisa berubah di luar modul, dan itu dipertanyakan, oleh karena itu atribut ini sama sekali tidak berlaku untuk penghitung.  Jika satu variabel harus ditafsirkan berbeda dalam modul yang berbeda, layanan kami harus digabungkan, jika kita berbicara tentang pengorganisasian bagian kritis, misalnya, ketika menerapkan transaksi atau operasi atom, maka arahan ini tidak memberikan apa-apa sama sekali. <br><br>  Kami kembali ke kode dan melihat bahwa programnya masih salah - ada apa - dan faktanya itu bukan apa yang kita butuhkan (lihat uraian tugas), tetapi sesuatu yang lain (menghitung sisa divisi), hanya hasilnya cocok  Yah, kami pikir begitu (saya tidak berpikir begitu, tetapi penulis kode pasti), bahwa hasilnya bertepatan, pada kenyataannya, dalam kasus umum, mereka tidak bertepatan, kami hanya beruntung dengan kisaran variabel (nilai positif).  Selain itu, proses mengeksekusi kode lebih lama daripada yang bisa dilakukan, karena dalam kasus terbaik kami memiliki operasi divisi integer (jika itu adalah bagian dari perintah arsitektur kami), dan itu dilakukan dengan cara tidak berarti dalam satu siklus prosesor (nilai karakteristik 10 siklus) untuk arsitektur 8-bit), dan dalam kasus terburuk, kita akan melihat panggilan prosedur pembagian dari pustaka standar (dan juga, jika divisi pendek), maka waktu eksekusi akan menjadi puluhan siklus clock. <br><br>  Jadi mengapa pendekatan yang benar-benar salah seperti itu masih mungkin untuk bertemu sangat sering.  Di sini dari audiens mereka mengatakan kepada saya bahwa dengan nilai Max + 1, yang merupakan kekuatan dua, kompiler akan menebak alih-alih operasi pembagian, menempatkan operasi penggandaan bitwise pada topeng yang sesuai (sama dengan Max), yang akan dilakukan dengan sangat cepat dan semuanya akan baik-baik saja. <br><br>  Saya setuju dengan pernyataan ini dan mengambil pendekatan ini, jika bukan karena keadaan berikut: <br><br><ul><li>  ini hanya mungkin untuk Mach yang ditentukan secara statis pada tahap kompilasi, </li><li>  ini hanya terjadi ketika optimasi diaktifkan, </li><li>  ini hanya terjadi ketika Mach memenuhi kondisi ini, </li><li>  ini tidak terjadi untuk semua jenis kardinal. </li></ul><br>  Selain itu, dalam kasus khusus ini (ketika variabel didefinisikan sebagai tanda), di samping perintah mengalikan (logis) dengan mask, perintah perbandingan dengan nol dan cabang untuk nilai negatif akan dihasilkan, dan meskipun cabang ini tidak akan pernah untuk jangkauan kami itu akan dieksekusi, itu akan memakan ruang dalam memori (dan dalam kasus fungsi yang dapat diganti, itu akan memakan waktu beberapa kali) dan itu akan memakan waktu untuk melakukan operasi perbandingan, jika Anda tidak percaya, sekali lagi kita ikuti situs yang ditunjukkan dan lihat sendiri.  Argumen lain yang mendukung para kardinal yang tidak bertanda tangan, yang baru-baru ini saya baktikan seluruh pos. <br><br>  Oleh karena itu, jika kita ingin menggunakan perkalian logis dengan topeng (diperoleh dengan mengoptimalkan perhitungan sisanya), maka kita harus menulis ulang modul sesuai: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> Counter_t; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int8_t</span></span> sCounter_t; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> Counter_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NextCounter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Counter_t Counter)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> IS_POWER2(Max + 1) return (Counter + 1) &amp; Max #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> return (Counter + 1) % (Max + 1); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> };</span></span></code> </pre> <br>  Dalam versi ini, semuanya sangat jelas dan dapat dikontrol dan semuanya benar (meskipun sejumlah kekurangan tetap ada, tetapi sekarang jelas dan tidak tertutup), oleh karena itu benar, meskipun lebih benar dan kami sekarang akan mencari mereka.  Kelemahan utama, menurut pendapat saya, adalah pelanggaran prinsip KISS, karena penggunaan operasi sisanya oleh divisi benar-benar mengabaikan prinsip ini.  Karena itu, kita sekarang akan menghancurkan semua kekurangan dengan satu pukulan (jangan khawatir tentang nasib mereka, mereka akan terlahir kembali 100.500 kali, karena tidak semua programmer untuk Arduino membaca posting saya). <br><br>  Tapi pertama-tama, sedikit penyimpangan ke samping.  Bagaimana kita bisa menerapkan pemeriksaan untuk kekuatan dua (angka biner dapat direpresentasikan sebagai {0} 1 {0}) yang baru saja kita gunakan <br><br><div class="spoiler">  <b class="spoiler_title">jangan memata-matai</b> <div class="spoiler_text">  #define IS_POWER2 (N) (((((N) - 1) &amp; (N)) == 0) <br></div></div><br>  Dan bagaimana kita dapat mengimplementasikan verifikasi bahwa angka adalah urutan unit {0} 1 {1} yang benar dalam notasi biner - satu opsi sudah jelas <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> IsRightSequence(N) IsPower2 ((N) + 1)</span></span></code> </pre> <br>  dan yang kedua sepele <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> IsRightSequence(N) ( (((N) + 1) &amp; (N)) == 0)</span></span></code> </pre> <br>  Catatan: Saya tidak dapat membantu tetapi mengingat teorema yang luar biasa: "Angka transendental dalam tingkat transendental selalu transendental, kecuali jika yang dibicarakan jelas atau sepele." <br><br>  Dan bagaimana kita dapat memverifikasi bahwa angka adalah urutan unit {0} 1 {1} {0} <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> IsSequence(N) IsPower2( (N) ^ ((N) &lt;&lt; 1))</span></span></code> </pre> <br>  Dan akhirnya - cara memilih bit yang paling tidak signifikan (saya tidak tahu mengapa ini mungkin diperlukan, tetapi akan berguna) <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> LowerBit(N) ((((N) - 1) ^ (N)) &amp; (N)).</span></span></code> </pre> <br><br>  Tapi dia datang dengan apa yang bisa berguna <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> IsRightSequence(N) (IsSequence(N) &amp;&amp; (LowerBit(N) == 1))</span></span></code> </pre> <br>  Pengamatan yang aneh - makro ini tidak sepenuhnya benar, ternyata 0 adalah kekuatan dua dan urutan yang benar (tentu saja, urutan yang juga), yang agak aneh.  Tapi 1 adalah semua objek ini dengan benar, jadi nol, sepertinya, hanya perlu dipertimbangkan secara terpisah.  Properti lain yang menarik dari makro ini adalah bahwa kami tidak membuat asumsi tentang panjang argumen, yaitu, mereka bekerja dengan benar dengan semua tipe kardinal. <br><br>  Ada buku yang luar biasa, "Trik untuk Pemrogram," di mana Anda dapat menemukan makro yang disebutkan dan banyak tugas yang sama menyenangkan dan instruktif lainnya, saya sangat merekomendasikan membacanya, terutama karena tidak ada terlalu banyak surat di dalamnya. <br><br>  Tetapi kembali ke indeks buffer cincin kami.  Kami memberikan solusi yang tepat, tetapi berjanji lebih benar lagi, yang berarti bahwa solusi terakhir kami memiliki kekurangan (siapa yang meragukannya).  Salah satunya - panjang buffer harus ditentukan secara statis pada tahap kompilasi, yang kedua - dalam hal panjang yang tidak berhasil, waktu eksekusi sangat panjang dan masih ada sejumlah kesalahan dalam sepotong program yang relatif kecil, yang membuat kita mengingat lelucon tentang 4 kesalahan dalam menulis kata "lebih".  Kami akan menghilangkan semuanya (beberapa akan dibiarkan nanti) dan segera, untuk itu, akhirnya, kami akan menulis solusi untuk masalah awal seperti: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> Counter_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NextCounter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Counter_t Counter)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((Counter + <span class="hljs-number"><span class="hljs-number">1</span></span>) &gt; Max) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Counter + <span class="hljs-number"><span class="hljs-number">1</span></span>; }; };</code> </pre> <br>  (Seperti yang sudah Anda pahami, saya adalah pendukung kurung Mesir dan tidak ada yang bisa dilakukan mengenai hal itu). <br><br>  Mari kita perhatikan fakta bahwa kita hanya menulis ulang kondisi masalah dari bahasa alami dalam bahasa pemrograman yang dipilih, sehingga ternyata menjadi sangat jelas dan dapat dimengerti.  Apakah mungkin untuk memperbaikinya - tidak diragukan lagi, tetapi hanya dari sudut pandang kecepatan kode, karena tidak ada kekurangan lain untuk solusi ini (tidak ada kekurangan yang jelas, sebenarnya ada dan kami akan berhasil menghilangkannya). <br><br>  Mari kita evaluasi kompleksitas komputasi dari solusi ini - penambahan dengan kesatuan (1) dan perbandingan (2) selalu, kemudian menetapkan nol (1) (jarang) atau menambahkan (1) (hampir selalu) - yang memberikan 1 + 2 + 1 + Δ ~ 4 dasar operasi dan memori nol.  Ada kemungkinan bahwa kompiler yang baik dalam mode yang tepat akan membuat optimasi tertentu dan mengurangi waktu eksekusi kode, tetapi lebih baik kita melakukannya secara eksplisit.  Berikut adalah opsi berikut: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> Counter_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NextCouner</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Counter_t Counter)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">register</span></span> sCounter_t Tmp; Tmp = (Counter + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Tmp &gt; Max) { Tmp = <span class="hljs-number"><span class="hljs-number">0</span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Tmp; };</code> </pre> <br>  Kami mengevaluasi kompleksitas - penambahan dan perbandingan selalu, menetapkan nol (jarang) - sekitar 3 operasi dan satu elemen memori.  Bahkan, versi sebelumnya juga memiliki satu elemen memori (implisit), jadi kami memiliki keuntungan bersih dalam satu operasi dasar.  Selain itu, versi sebelumnya memiliki dua kelemahan lagi - 1) melanggar prinsip KERING (menghitung kenaikan satu dua kali) dan 2) memiliki lebih dari satu titik keluar, yang tidak baik.  Kami juga tidak kehilangan pengertian, yaitu, kami berhasil membunuh sekelompok kelinci dengan satu tembakan, dan kami juga tidak menghabiskan kartrid apa pun - itu hanya cerita dalam gaya Baron Munchausen. <br><br>  Perhatikan bahwa saya tidak menggunakan <code>if ( (Tmp = Counter + 1) &gt; Max)</code> , meskipun berisi instruksi eksplisit ke kompiler untuk mencoba tidak melakukan transfer yang berlebihan.  Ini bumbu dalam bentuk yang paling terang-terangan, saya hanya tidak suka nilai yang dikembalikan oleh operator penugasan dan mencoba untuk menghindari menggunakannya.  Saya tidak bisa menjelaskan alasan perasaan kuat ini, menurut Freud, ini kemungkinan besar trauma psikologis di masa kecil.  Kompiler modern cukup mampu melakukan optimasi sederhana sendiri, dan selain itu, saya juga menambahkan kualifikasi register, sehingga kode untuk versi saya dan yang benar (dari sudut pandang bahasa C) akan cocok.  Namun demikian, saya sama sekali tidak membatasi kebebasan Anda untuk menggunakan metode yang tampaknya lebih disukai untuk Anda. <br><br>  Kami terus meningkatkan, karena tidak ada batas untuk kesempurnaan, dan kami belum mencapainya.  Untuk mencapainya, kita sedikit merumuskan kembali masalah asli dan hanya menyisakan persyaratan variabel dalam kisaran nilai, tanpa menunjukkan arah perubahan.  Pendekatan ini memungkinkan Anda untuk menulis ulang program sebagai berikut <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> Counter_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NextCouner</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Counter_t Counter)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">register</span></span> Counter_t Tmp; Tmp = (Counter - <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Tmp &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { Tmp = ; }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Tmp; };</code> </pre> <br>  Pada pandangan pertama, tidak ada yang berubah banyak, tetapi, bagaimanapun, kami mendapat keuntungan dalam waktu.  Tentu saja, bukan karena fakta bahwa operasi penurunan oleh satu bekerja lebih cepat daripada operasi peningkatan olehnya (meskipun saya mendengar versi yang sama), tetapi karena kekhasan perbandingan.  Jika dalam versi sebelumnya saya menganggap perbandingan sebagai 2 operasi dasar (pertama kita kurangi dan kemudian membuat keputusan), maka dalam hal ini hasil dari operasi sebelumnya digunakan untuk membuat keputusan secara langsung dan perbandingan mengambil satu operasi dasar, yang mengarah ke dua operasi selalu dan satu tugas (jarang) dan kami menyelamatkan satu operasi (tanpa kehilangan apa pun), seperti kata pepatah, "agak sepele, tapi bagus."  Apakah solusi yang dihasilkan ideal - sayangnya, tidak.  Ini sedikit lebih rendah daripada solusi dengan masker (yang membutuhkan tepat 2 operasi dasar) dalam hal kecepatan dan ini mungkin satu-satunya kelemahan. <br><br>  Ada solusi yang bahkan lebih cepat - cukup meningkatkan (menurunkan) nilai penghitung dan tidak melakukan hal lain, tetapi hanya mungkin dalam satu-satunya kasus ketika nilai maksimum bertepatan dengan nilai yang paling representatif dalam jenis yang diterima.  Untuk penghitung 8-bit (yaitu, dari tipe uint8_t), itu akan menjadi 255, maka kita cukup menulis Counter = Counter + 1 dan mengambil kata saya untuk itu bahwa menulis Counter + = 1 atau ++ Counter sepenuhnya opsional, walaupun banyak yang dan mereka akan menulis dan akan sepenuhnya benar.  Jika kita tidak serius mempertimbangkan versi tentang perlunya menyimpan karakter (karena opsi pertama adalah yang terpanjang), maka ini tidak masuk akal, setidaknya jika kita menulis program untuk arsitektur ARM atau AVR (untuk yang lain saya tidak periksa, saya menduga hasilnya akan menjadi sama) di bawah kompiler GCC (penulis memahami bahwa mereka sedang menulis program di editor lingkungan pemrograman terintegrasi, ini hanya sebuah revolusi pidato dari masa lalu ketika komputer besar dan memori kecil), dan dengan pengoptimalan dihidupkan di tingkat mana pun, karena  kode yang diberikan akan benar-benar identik. <br><br>  Kompiler modern sangat, sangat maju dalam hal optimasi dan menghasilkan kode yang sangat bagus, tentu saja, jika Anda telah mengaktifkan mode yang sesuai.  Meskipun saya siap untuk setuju bahwa konstruksi bahasa tersebut tidak membahayakan, dan dapat berguna dalam kondisi tertentu, satu-satunya hal yang saya perhatikan adalah bahwa ekspresi Counter ++ (dalam kasus khusus ini, tentu saja) harus dihindari dengan jelas, karena ini dimaksudkan untuk situasi yang sama sekali berbeda dan dapat menimbulkan kode lebih lambat, meskipun opsional. <br><br>  Pertanyaan lain adalah bahwa buffer 256-elemen tidak selalu dapat diterima, tetapi jika Anda memiliki cukup memori, mengapa tidak.  Dengan implementasi ini, jika Anda dapat menyelaraskan buffer ke batas halaman, maka akses ke elemen dapat dilakukan dengan sangat cepat dengan menghilangkan operasi pemindahan dari indeks ke indeks (kata kunci gabungan akan memberi tahu Anda penerapan fitur seperti itu, saya tidak akan membawanya agar tidak belajar buruk), tetapi ini sudah merupakan keputusan yang sangat, sangat spesifik dengan keterikatan yang kuat pada arsitektur, yang sangat dekat dengan trik dalam arti kata yang terburuk, dan ini bukan gaya kita. <br><br>  Tentu saja, tidak ada yang melarang kita untuk menulis pembungkus yang akan memanggil metode ini atau itu tergantung pada nilai maksimum (dan minimum, karena banyak metode tidak bekerja dengan nilai non-nol minimum), saya sudah mengusulkan prinsip dasar dari solusi seperti itu, jadi kami akan menawarkan ini sebagai latihan. <br><br>  Singkatnya, untuk meringkas - kami akan menyatukan berbagai implementasi pekerjaan dengan indeks cincin dan mengevaluasi sifat-sifat mereka. <br><div class="scrollable-table"><table><tbody><tr><th>  Metode </th><th>  Keserbagunaan </th><th>  Lead time </th></tr><tr><td>  ± </td><td>  0 (1) </td><td>  1 </td></tr><tr><td>  ±% </td><td>  1 (7) </td><td>  2 </td></tr><tr><td>  + jika </td><td>  3 (apa saja) </td><td>  3.x </td></tr><tr><td>  - jika </td><td>  3 (apa saja) </td><td>  2.x </td></tr></tbody></table></div><br>  Baris kedua dalam tanda kurung menunjukkan jumlah nilai ukuran buffer (tidak melebihi 256) yang tersedia untuk implementasi ini, tetapi kami berarti bahwa buffer ukuran 0 tidak menarik bagi kami. <br><br>  Seperti yang dapat Anda lihat dari tabel ini, DarZaNeBy (ungkapan favorit saya, seperti yang mungkin telah Anda perhatikan), dan kelebihannya dibeli dengan biaya kerugian, satu-satunya hal yang dapat dinyatakan secara jelas adalah bahwa peningkatan dengan verifikasi memiliki pesaing yang lebih sukses dalam bentuk pengurangan dengan verifikasi dan tidak melanjutkan ke putaran berikutnya. dalam kondisi apa pun. <br><br>  Catatan yang diperlukan - ada bahasa pemrograman di mana kita tidak perlu berpikir tentang implementasi indeks sama sekali, tetapi cukup kita bisa menggunakan tipe interval.  Sayangnya, saya tidak dapat menyebut implementasi konstruk ini dalam kode optimal, karena konstruk ini (dan bahasa ini) tidak dimaksudkan untuk optimisasi saat runtime, tetapi sangat disayangkan. <br><br>  Jadi, kami membuat modul yang tepat (nama yang kuat untuk fungsi inline) untuk bekerja dengan indeks, dan sekarang kami siap untuk mulai menerapkan buffer cincin itu sendiri. <br><br>  Sebagai permulaan, kita harus memutuskan apa yang sebenarnya kita inginkan dari objek program ini.  Sangat penting untuk dapat menempatkan elemen data dalam buffer dan mengekstraknya - dua metode utama, semacam pengambil dan penyetel.  Secara teori dimungkinkan untuk membayangkan penyangga tanpa salah satu dari metode ini, atau bahkan tanpa keduanya (hanya sedikit yang dapat dibayangkan secara teoritis), tetapi nilai praktis dari implementasi semacam itu adalah pertanyaan besar.  Fungsi berikutnya yang diperlukan - memeriksa informasi - dapat diimplementasikan baik sebagai metode terpisah, atau sebagai nilai khusus (atau atribut) yang dikembalikan dengan membaca.  Biasanya mereka lebih suka metode pertama, karena ternyata lebih mudah dimengerti dan tidak terlalu mahal. <br>  Tetapi memeriksa kelengkapan buffer sudah merupakan pertanyaan besar - operasi ini akan membutuhkan waktu tambahan, yang akan selalu dihabiskan untuk merekam, meskipun tidak ada yang memaksa kita untuk menggunakannya - jadi biarkan saja.  Kami tidak membutuhkan hal lain dari buffer, mari kita ingat frase ini untuk masa depan. <br><br>  Kembali ke implementasi.  Kami membutuhkan tempat untuk menyimpan elemen antrian dan dua indeks - satu untuk menulis ke buffer dan satu untuk membaca darinya.  Bagaimana tepatnya kita akan mendapatkan tempat ini (dan petunjuk-petunjuk ini) adalah topik untuk diskusi terpisah, untuk saat ini, mari kita tinggalkan momen ini dalam kurung dan percaya bahwa kita memilikinya.  Beberapa (termasuk penulis buku "Programming for Mathematicians", yang saya hormati, saya sarankan untuk membacanya) juga menggunakan konter tempat yang penuh, tetapi kami tidak akan melakukan ini dan saya akan mencoba menunjukkan mengapa ini jahat. <br><br>  Pertama, tentang indeks - kami segera melihat bahwa ini adalah indeks, bukan petunjuk, meskipun kadang-kadang saya membiarkan diri saya disebut demikian.    (     ),    (       )-   ,  ,   ,      .       (  256    ),     ,       ,       (         ,     8     , ,     4-  ),  ,       ,     ( ,      ). <br><br><div class="spoiler"> <b class="spoiler_title">  </b> <div class="spoiler_text"> ,       51 (   )    2 (    )   3  ( ),   ,             ,      . ,   ,  GCC     x51,       AVR  . <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selain itu, banyak trik yang meningkatkan kecepatan untuk mendapatkan nilai berikutnya akan menjadi tidak tersedia saat menggunakan pointer. Dan jika Anda juga mempertimbangkan pendapat bahwa pointer lebih sulit untuk dipahami (bukan bahwa pendapat ini tampaknya benar bagi saya, tetapi ada), maka pilihannya adalah indeks yang jelas.</font></font><br><br>        —           (   ),        .      : 1)   ,       2)   ,     .          ,   ,  ,        .     ,     ,      .     (  )  ,     —   .     —        ,             . <br><br>     («,      »)             ,      .       —  1)    , 2)       ( ,  ) 3)        ,     , 4)       256            , 5)     ( ),    .    ,     ,   ,   ,     . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kita hanya perlu menghindari situasi di mana indeks mungkin bertepatan setelah catatan berikutnya (fakta bahwa mereka mungkin bertepatan setelah membaca jelas), dan untuk ini kita perlu membatasi jumlah elemen yang mungkin dalam buffer menjadi 1 kurang dari mungkin. </font><font style="vertical-align: inherit;">Berikut implementasinya:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NeedOverflowControl YES typedef uint8_t Data_t; static Data_t BufferData[Max]; static Counter_t BufferWriteCounter=0, BufferReadCounter=BufferWriteCounter; void BufferWrite(const data_t Data) { BufferData[BuffWriteCounter] = Data; register counter_t Tmp = NextCount(BufferWriteCounter); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (NeedOverflowControl == YES) </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (Tmp == BufferReadCounter) {BufferOverflow();} </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> { BufferWriteCounter = Tmp; } };</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ada sedikit kesalahan pada fungsi sebelumnya, saya mengusulkan untuk menemukannya dan memperbaikinya sendiri, meskipun ... masih ada, tapi kami akan melanjutkan: </font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BufferIsEmpty</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( BufferReadCounter == BufferWriteCounter ); }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BufferIsFull</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( BufferReadCounter == NextCounter(BufferWriteCounter) ); }; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DataSizeIsSmaller (sizeof(data_t) &lt; sizeof(counter_t)) data_t BufferRead(void) { #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> DataSizeIsSmaller register data_t Tmp = BufferData[BufferReadCounter]; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> register counter_t Tmp = BufferReadCounter; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> BufferReadCounter = NextCount(BufferReadCounter); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> DataSizeIsSmaller return Tmp; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> return BufferData[Tmp]; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> };</span></span></code> </pre> <br>    ,        (     ) —        ,        , ,      —    ,         .  ,        ,        ,         . <br><br> ,     ,     —  ,         ,         ,       . <br><br>  , (  )   <br><br> 1)            (    —     ,        ,      —      ,  ,        ). <br>   (,  ,    )  <br><br> 2)            —    ,     . <br><br>         : <br><br> 3)  4)      ,    («  »).    —      ,   ,      (  N   N+1 )       ,    ?    <br><br> 3)     ,   <br><br> 4)       . <br><br>      — « »,     -      ,     —    .      3,     (      ),       ,    . <br><br>      —    , (      ,      ),    <br><br> 5)      —       ,    ,       ,      ,       —   ,     . <br><br>   —             ,      ,     . <br><br>    ,  ,     ,    , ,   , ,    , ,   ,      ,     .        ,      4       ,    ,  .        MRSW (Multi-Reader Single-Writer)   «The Art of Mulpiprocessor Programming» (   ,   )        (  )      .      —           ,               ,   . <br><br>       MRMW        ,   «» (, ,      « » ).     ,         , ,       ,      .  , ,     ,           (,   ,      —    ,     ,   ,  ),     . <br><br>  ,    (   )      ,       .     ,     ,         ,     ,  ,         ,      ,        . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data_t</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data_t</span></span> BufferData[Max]; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">counter_t</span></span> BufferWriteCounter=<span class="hljs-number"><span class="hljs-number">0</span></span>, BufferReadCounter=WriteCounter; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int8_t</span></span> BufferHaveData = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BufferWrite</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">data_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Data)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((BufferWriteCounter == BufferReadCounter) &amp;&amp; (BufferHaveDataFlag == <span class="hljs-number"><span class="hljs-number">1</span></span>)) {BufferOverflow();} <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { BufferData[BufferWriteCounter] = Data; BufferHaveDataFlag = <span class="hljs-number"><span class="hljs-number">1</span></span>; BufferWriteCounter = NextCounter(BufferWriteCounter); }; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BufferIsEmpty</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((BufferReadCounter==BufferWriteCounter) &amp;&amp; (BufferHaveDataFlag == <span class="hljs-number"><span class="hljs-number">0</span></span>));}; <span class="hljs-keyword"><span class="hljs-keyword">data_t</span></span> BufferRead(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">register</span></span> <span class="hljs-keyword"><span class="hljs-keyword">counter_t</span></span> Tmp; Tmp = BufferReadCounter; BufferReadCounter = NextCount(BufferReadCounter); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (BufferReadCount == BufferWriteCounter) { BufferHaveDataFlag = <span class="hljs-number"><span class="hljs-number">1</span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> BufferData[Tmp]; };</code> </pre> <br>   ,        ,    ,       ,    ,                   . <br><br>  ,         (    0  1,   ,     ,   ),      ,    ,      ,  ,  ,         (  ),  ,      , <br><br><div class="spoiler"> <b class="spoiler_title"> - </b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> (NoBufferHaveData= <span class="hljs-number"><span class="hljs-number">0</span></span>, BufferHaveData =<span class="hljs-number"><span class="hljs-number">1</span></span>) BufferHave DataFlag_t; BufferHaveData_t BufferYaveDataFlag; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BufferHaveDataFlagSet</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{BufferHaveDataFlag = NoBufferHaveData;}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BufferHaveDataFlagClr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{BufferHaveDataFlag = BufferHaveData;}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BufferHaveDataFlagIsSet</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(BufferHaveDataFlag == BufferHaveData);};</code> </pre> <br></div></div><br>  ,        ,      0  1,             . ,     ,        ,        0  1.   , ,    ,      ,    BufferFullFlag      ,          BufferIsNotEmptyFlag         .   ,  KISS      ,   ,   ,        ,    , «   ». <br><br>   ,       ,                    . <br><br>          ,         ,      . <br><br> PS    ,        ,                 : <br><br><ol><li>     —      (,  ,     ),  —   ,     , ,   ,  . </li><li>               . </li><li>      . </li><li>    2    . </li><li>       </li><li>     ,     (  )   ,       ,       . </li><li>    ,   <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((_writeCount - Atomic::Fetch(&amp;_readCount)) &amp; (size_type)~(_mask)) != <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br>     —    ,    ,     ,         <br><br><pre> <code class="cpp hljs">size_type(~(_mask))</code> </pre> <br>     . </li></ol><br> PPS ,           . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id438476/">https://habr.com/ru/post/id438476/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id438466/index.html">Kruk untuk laser Cina</a></li>
<li><a href="../id438468/index.html">Koloni. Bab 23: Test Drive</a></li>
<li><a href="../id438470/index.html">Penjualan di seluruh dunia pada bulan Desember dan 2018: 2 juta kendaraan listrik plug-in yang terjual</a></li>
<li><a href="../id438472/index.html">Lingkungan arsitektur modular yang canggih di UE4</a></li>
<li><a href="../id438474/index.html">Kurir: Migrasi Dropbox ke gRPC</a></li>
<li><a href="../id438478/index.html">GitLab 11.7 dirilis dengan Rilis, epik bertingkat multi-level dan registri paket NPM</a></li>
<li><a href="../id438480/index.html">Tempatkan dengan benar: 7 tempat ideal untuk menempatkan konten video</a></li>
<li><a href="../id438482/index.html">Reputasi, kerja, dan emigrasi: cara menggunakan alat promosi perusahaan untuk menyelesaikan masalah pribadi</a></li>
<li><a href="../id438486/index.html">Kartu memori yang tak tertembus - tenggelam, membeku, dan membakar High Endurance microSD Kingston</a></li>
<li><a href="../id438490/index.html">Rilis beta Unity 2019.1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>