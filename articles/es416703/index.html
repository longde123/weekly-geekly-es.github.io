<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßòüèΩ ü§¶üèæ ü§öüèæ Creando pistas en la nieve en Unreal Engine 4 ‚ñ∂Ô∏è ‚õπüèæ ü§üüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Si juegas juegos AAA modernos, es posible que hayas notado una tendencia a usar paisajes cubiertos de nieve. Por ejemplo, est√°n en Horizon Zero Dawn ,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Creando pistas en la nieve en Unreal Engine 4</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/416703/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/ox/49/ct/ox49ctzii2nk6gryoeuvbcxf96a.gif"></div><br>  Si juegas juegos AAA modernos, es posible que hayas notado una tendencia a usar paisajes cubiertos de nieve.  Por ejemplo, est√°n en <i>Horizon Zero Dawn</i> , <i>Rise of the Tomb Raider</i> y <i>God of War</i> .  En todos estos juegos, la nieve tiene una caracter√≠stica importante: ¬°puedes dejar rastros en ella! <br><br>  Gracias a esta interacci√≥n con el entorno, se mejora la inmersi√≥n del jugador en el juego.  Hace que el entorno sea m√°s realista, y seamos honestos: es simplemente interesante.  ¬øPor qu√© pasar largas horas creando una mec√°nica curiosa si solo puedes dejar que el jugador caiga al suelo y hacer √°ngeles de nieve? <br><br>  En este tutorial aprender√° lo siguiente: <br><br><ul><li>  Cree huellas usando la captura de escena para enmascarar objetos cerca del suelo </li><li>  Use una m√°scara con material del terreno para crear nieve deformable </li><li>  Para optimizar, muestre huellas en la nieve solo al lado del jugador </li></ul><a name="habracut"></a><br><blockquote>  <em>Nota:</em> se entiende que ya est√° familiarizado con los conceptos b√°sicos de trabajar con Unreal Engine.  Si eres nuevo, echa un vistazo a nuestra serie de tutoriales de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Unreal Engine para principiantes</a> . </blockquote><br><h2>  Llegar al trabajo </h2><br>  Descargue <a href="">materiales</a> para este tutorial.  Descompr√≠malos, vaya a <em>SnowDeformationStarter</em> y abra <em>SnowDeformation.uproject</em> .  En este tutorial crearemos trazas con la ayuda de un personaje y varios cuadros. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a1f/8c7/b72/a1f8c7b7279319c558685c1b09858726.gif"></div><br>  Antes de comenzar, debe saber que el m√©todo de este tutorial solo guardar√° rastros en un √°rea determinada, y no en todo el mundo, porque la velocidad depende de la resoluci√≥n del renderizado objetivo. <br><br>  Por ejemplo, si queremos almacenar rastros para un √°rea grande, tendremos que aumentar la resoluci√≥n.  Pero tambi√©n aumenta el impacto de la captura de escenas en la velocidad del juego y el tama√±o de la memoria para el renderizado objetivo.  Para la optimizaci√≥n, debe limitar el alcance y la resoluci√≥n. <br><br>  Despu√©s de lidiar con esto, descubramos qu√© se necesita para darse cuenta de las huellas en la nieve. <br><br><h2>  Implementaci√≥n de huellas en la nieve. </h2><br>  Lo primero que necesita para crear trazas es el <em>renderizado de destino</em> .  El objetivo de renderizado ser√° una m√°scara en escala de grises, en la que el blanco indica la presencia de un rastro y el negro indica su ausencia.  Luego podemos proyectar el renderizado objetivo en el suelo y usarlo para mezclar las texturas y cambiar los v√©rtices. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ea7/f0c/7f4/ea7f0c7f4eee82e34ebf74afeab25a72.gif"></div><br>  Lo segundo que necesitamos es una forma de enmascarar solo los objetos que afectan la nieve.  Esto se puede implementar renderizando primero los objetos en <em>profundidad personalizada</em> .  A continuaci√≥n, puede utilizar la <em>captura de escena</em> con el <em>material del proceso posterior</em> para enmascarar todos los objetos renderizados en profundidad personalizada.  Luego puede mostrar la m√°scara en el renderizado de destino. <br><br><blockquote>  <em>Nota: la</em> captura de escena es esencialmente una c√°mara con la capacidad de generar un renderizado objetivo. </blockquote><br>  La parte m√°s importante de capturar una escena es su ubicaci√≥n.  El siguiente es un ejemplo de un renderizado objetivo capturado desde una <em>vista superior</em> .  Aqu√≠, un personaje en tercera persona y las cajas est√°n enmascarados. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/886/2e0/4cf/8862e04cfeb3f6ce26918d4ffa8b00a0.jpg"></div><br>  A primera vista, una captura con una vista superior nos conviene.  Los formularios parecen apropiados para las mallas, por lo que no deber√≠a haber ning√∫n problema, ¬øverdad? <br><br>  En realidad no  El problema de capturar desde una vista superior es que no captura nada bajo el punto m√°s amplio.  Aqu√≠ hay un ejemplo: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6ae/952/8b1/6ae9528b111143c408aab2642fe4c781.gif"></div><br>  Imagina que las flechas amarillas van hasta el suelo.  En el caso de un cubo y un cono, la punta de flecha siempre permanecer√° dentro del objeto.  Sin embargo, en el caso de una esfera, el punto emerge de ella cuando se acerca a la tierra.  Pero seg√∫n la c√°mara, la punta siempre est√° dentro de la esfera.  As√≠ se ver√° la esfera de la c√°mara: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/35f/580/cab/35f580cab1df39d4707c344f9e902e9d.jpg"></div><br>  Por lo tanto, la m√°scara de esfera ser√° m√°s grande de lo que deber√≠a, incluso si el √°rea de contacto con la tierra es peque√±a. <br><br>  Adem√°s, este problema se complementa con el hecho de que nos resulta dif√≠cil determinar si el objeto se refiere a la tierra. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9e3/df9/a48/9e3df9a4804b5c317f40f57389fc1a8c.gif"></div><br>  Para hacer frente a estos dos problemas, puede usar la captura <em>desde la parte inferior</em> . <br><br><h3>  Agarre inferior </h3><br>  La captura desde abajo es la siguiente: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c3f/348/aad/c3f348aad117b479acf5fd9505f9c860.gif"></div><br>  Como puede ver, la c√°mara ahora captura el lado inferior, es decir, el que toca el suelo.  Esto elimina el problema del "√°rea m√°s amplia" que aparece cuando se captura desde arriba. <br><br>  Para determinar si un objeto toca el suelo, puede usar material de posprocesamiento para realizar una verificaci√≥n de profundidad.  Comprueba si la profundidad del objeto es mayor que la profundidad de la tierra <i>y</i> si est√° por debajo de un desplazamiento predeterminado.  Si se cumplen ambas condiciones, podemos enmascarar este p√≠xel. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a6b/83f/e87/a6b83fe8713950c52f917314de9d7c88.jpg"></div><br>  A continuaci√≥n se muestra un ejemplo dentro de un motor con una zona de captura de 20 unidades sobre el suelo.  Tenga en cuenta que la m√°scara aparece solo cuando el objeto pasa por un cierto punto.  Tambi√©n tenga en cuenta que la m√°scara se vuelve m√°s blanca a medida que el objeto se acerca al suelo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/949/1bb/d76/9491bbd768781cbca7c07a652172ba2c.gif"></div><br>  Primero, cree un material de procesamiento posterior para realizar una verificaci√≥n de profundidad. <br><br><h2>  Crear material de prueba de profundidad </h2><br>  Para realizar una verificaci√≥n de profundidad, debe usar dos amortiguadores de profundidad: uno para el suelo y otro para los objetos que afectan la nieve.  Como capturar la escena solo ve la tierra, la <em>profundidad de la escena</em> inferir√° profundidad para la tierra.  Para obtener profundidad para los objetos, simplemente los renderizaremos en <em>profundidad personalizada</em> . <br><br><blockquote>  <em>Nota:</em> para ahorrar tiempo, ya he representado el car√°cter y los cuadros en profundidad personalizada.  Si desea agregar otros objetos que afecten a la nieve, debe habilitar el <em>Paso de profundidad personalizado de renderizado</em> para ellos. </blockquote><br>  Primero, necesitas calcular la distancia de cada p√≠xel al suelo.  Abra <em>Materials \ PP_DepthCheck</em> y cree lo siguiente: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f32/7bb/226/f327bb226d1764c3f848d1c43a6304ca.jpg"></div><br>  A continuaci√≥n, debe crear una zona de captura.  Para hacer esto, agregue los nodos resaltados: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/908/37d/0eb/90837d0eb07af42121b2a113b1229230.jpg"></div><br>  Ahora, si el p√≠xel est√° dentro de las <em>25</em> unidades de la Tierra, aparecer√° en la m√°scara.  El brillo de enmascaramiento depende de qu√© tan cerca est√© el p√≠xel del suelo.  Haga clic en <em>Aplicar</em> y regrese al editor principal. <br><br>  A continuaci√≥n, debe crear una captura de escena. <br><br><h2>  Crear captura de escena </h2><br>  Primero, necesitamos un renderizado objetivo en el que capturar una captura de escena.  Vaya a la carpeta <em>RenderTargets</em> y cree un nuevo <em>Render Target</em> llamado <em>RT_Capture</em> . <br><br>  Ahora creemos una captura de escena.  En este tutorial agregaremos la captura de escena al plano, porque m√°s tarde necesitaremos un script para ello.  Abra <em>Blueprints \ BP_Capture</em> y agregue <em>Scene Capture Component 2D</em> .  <em>N√≥mbralo SceneCapture</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3d0/df9/915/3d0df9915e8aa04d9577193a53bcfc05.jpg"></div><br>  Primero necesitamos establecer el turno de captura para que mire al suelo.  Vaya al panel Detalles y configure la <em>rotaci√≥n en</em> <em>(0, 90, 90)</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6e2/c35/407/6e2c354070055e1f427d626b1c0df408.jpg"></div><br>  Luego viene el tipo de proyecci√≥n.  Dado que la m√°scara es una representaci√≥n 2D de la escena, debemos eliminar la distorsi√≥n de la perspectiva.  Para hacer esto, establezca <em>Proyecci√≥n \ Tipo de proyecci√≥n</em> en <em>Ortogr√°fica</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/78b/e54/adf/78be54adf3666b52564582f07153f8df.jpg"></div><br>  A continuaci√≥n, debemos decirle a la captura de escena en qu√© renderizado de destino grabar.  Para hacer esto, seleccione el valor de <em>RT_Capture</em> para <em>Scene Capture \ Texture Target</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5c6/a76/2c5/5c6a762c53867499e5f3ace3de1b1eee.jpg"></div><br>  Finalmente, necesitamos usar material de verificaci√≥n de profundidad.  Agregue PP_DepthCheck a las <em>Caracter√≠sticas de representaci√≥n \ Materiales de proceso posterior</em> .  Para que el postprocesamiento funcione, tambi√©n necesitamos cambiar la <em>captura de escena / origen de captura</em> a <em>color final (LDR) en RGB</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3ec/1f1/26f/3ec1f126fce6ccea0625ae5d33193fdd.jpg"></div><br>  Ahora que la captura de escena est√° configurada, necesitamos especificar el tama√±o del √°rea de captura. <br><br><h3>  Establecer el tama√±o del √°rea de captura </h3><br>  Como es mejor usar resoluciones bajas para el renderizado de destino, necesitamos usar el espacio de manera eficiente.  Es decir, debemos elegir qu√© √°rea cubrir√° un p√≠xel.  Por ejemplo, si las resoluciones del √°rea de captura y el renderizado objetivo son las mismas, entonces obtenemos una relaci√≥n 1: 1.  Cada p√≠xel cubrir√° un √°rea de 1 √ó 1 (en unidades del mundo). <br><br>  Para las pistas en la nieve, no se requiere una relaci√≥n 1: 1, porque lo m√°s probable es que no necesitemos ese detalle.  Recomiendo usar proporciones m√°s grandes porque esto le permitir√° aumentar el tama√±o del √°rea de captura a baja resoluci√≥n.  Pero no haga que la proporci√≥n sea demasiado grande, de lo contrario los detalles comenzar√°n a perderse.  En este tutorial, utilizaremos una relaci√≥n de 8: 1, es decir, el tama√±o de cada p√≠xel ser√° de 8 √ó 8 unidades del mundo. <br><br>  Puede cambiar el tama√±o del √°rea de captura cambiando la propiedad <em>Captura de escena \ Ancho de orto</em> .  Por ejemplo, si desea capturar un √°rea de 1024 √ó 1024, establezca el valor en 1024. Dado que estamos utilizando una relaci√≥n de 8: 1, establezca el valor en <em>2048</em> (la resoluci√≥n predeterminada del renderizado de destino es 256 √ó 256). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/411/c60/994/411c60994d4b52dc80553a375496363b.jpg"></div><br>  Esto significa que la captura de escena capturar√° el √°rea de <em>2048 √ó 2048</em> .  Tiene aproximadamente 20 √ó 20 metros. <br><br>  El material del suelo tambi√©n necesita acceso al tama√±o de captura para proyectar correctamente el renderizado objetivo.  La forma m√°s f√°cil de hacer esto es guardar el tama√±o de captura en la <em>Colecci√≥n de par√°metros de material</em> .  Esto es esencialmente una colecci√≥n de variables a las que puede acceder <i>cualquier</i> material. <br><br><h3>  Guardar tama√±o de captura </h3><br>  Regrese al editor principal y vaya a la carpeta <em>Materiales</em> .  Cree una <em>colecci√≥n de par√°metros de material</em> que estar√° en <em>Materiales y texturas</em> .  <em>C√°mbiele el</em> nombre a <em>MPC_Capture</em> y √°bralo. <br><br>  Luego cree un nuevo <em>par√°metro escalar</em> y <em>as√≠gnele el</em> nombre <em>CaptureSize</em> .  No se preocupe por establecer su valor, lo haremos sin rodeos. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3bd/e83/fd4/3bde83fd4df9a960ef4ebde57830b749.jpg"></div><br>  Regrese a <em>BP_Capture</em> y agregue los nodos resaltados al <em>Evento BeginPlay</em> .  Establezca <em>Colecci√≥n</em> en <em>MPC_Capture</em> y <em>Nombre de par√°metro</em> en <em>CaptureSize</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eed/843/d3d/eed843d3d5ddc063f9e1c7664b514286.jpg"></div><br>  Ahora cualquier material puede obtener el valor de <em>Ortho Width</em> al leerlo desde el par√°metro <em>CaptureSize</em> .  Hasta ahora con la captura de la escena hemos terminado.  Haga clic en <em>Compilar</em> y vuelva al editor principal.  El siguiente paso es proyectar el renderizado objetivo en el suelo y usarlo para deformar el paisaje. <br><br><h2>  Deformaci√≥n del paisaje </h2><br>  Abra <em>M_Landscape</em> y vaya al panel Detalles.  Luego establezca las siguientes propiedades: <br><br><ul><li>  Para <em>Dos caras,</em> seleccione <em>habilitado</em> .  Dado que la captura de la escena "mirar√°" desde abajo, solo ver√° las caras inversas de la tierra.  Por defecto, el motor no representa las caras posteriores de las mallas.  Esto significa que no almacenar√° la profundidad de la tierra en el b√∫fer de profundidad.  Para solucionar esto, necesitamos decirle al motor que renderice ambos lados de la malla. </li><li>  Para la <em>teselaci√≥n D3D11,</em> seleccione la <em>teselaci√≥n</em> <em>plana</em> (tambi√©n se pueden utilizar tri√°ngulos PN).  La teselaci√≥n dividir√° los tri√°ngulos de malla en peque√±os.  En esencia, esto aumenta la resoluci√≥n de la malla y nos permite obtener detalles m√°s finos al cambiar los v√©rtices.  Sin esto, la densidad de los picos ser√° demasiado baja para crear trazas cre√≠bles. </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dc2/99b/a26/dc299ba26cb64d251af3844faf0f5079.jpg"></div><br>  Una vez que se activan las teselaciones, se activar√° el <em>Desplazamiento mundial</em> y el <em>Multiplicador de</em> teselaciones. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e8d/675/c53/e8d675c535ce64980597cf10a16ffafe.jpg"></div><br>  <em>Tessellation Multipler</em> controla la cantidad de teselaci√≥n.  En este tutorial, no conectaremos este nodo, es decir, usaremos el valor predeterminado ( <em>1</em> ). <br><br>  <em>World Displacement</em> obtiene un valor vectorial que describe en qu√© direcci√≥n y cu√°nto mover el v√©rtice.  Para calcular el valor de este contacto, primero debemos proyectar el renderizado objetivo en el suelo. <br><br><h3>  Proyecto Target Render </h3><br>  Para proyectar el renderizado objetivo, debe calcular sus coordenadas UV.  Para hacer esto, cree el siguiente esquema: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cbb/88f/b59/cbb88fb598e75fc8c9bd9991806d5892.jpg"></div><br>  ¬øQu√© est√° pasando aqu√≠? <br><br><ol><li>  Primero necesitamos obtener la posici√≥n XY del v√©rtice actual.  Como estamos capturando desde abajo, se da la vuelta a la coordenada X, por lo que debe voltearla hacia atr√°s (si tuvi√©ramos que capturar desde arriba, no necesitar√≠amos esto). </li><li>  Esta parte realiza dos tareas.  En primer lugar, centra el renderizado objetivo de tal manera que su centro est√© en las coordenadas <em>(0, 0) del</em> espacio mundial.  Luego convierte las coordenadas del espacio mundial al espacio UV. </li></ol><br>  A continuaci√≥n, cree los nodos seleccionados y combine los c√°lculos anteriores como se muestra a continuaci√≥n.  Para <em>Muestra de textura,</em> seleccione <em>RT_Capture</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e95/38d/398/e9538d398f9ba02da2aea238c45651dd.jpg"></div><br>  Esto proyectar√° el renderizado objetivo en el suelo.  Sin embargo, todos los v√©rtices fuera del √°rea de captura muestrear√°n los bordes del renderizado objetivo.  Esto es realmente un problema porque el renderizado de destino solo debe usarse para v√©rtices dentro del √°rea de captura.  As√≠ es como se ve en un juego: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1a4/e28/a04/1a4e28a04c7b6356bff76d8e1c4f4ce9.gif"></div><br>  Para solucionar esto, necesitamos enmascarar todos los UV que est√°n fuera del rango de 0 a 1 (es decir, el √°rea de captura).  Para esto, cre√© la funci√≥n <em>MF_MaskUV0-1</em> .  Devuelve <em>0</em> si el UV transmitido est√° fuera del rango de 0 a 1 y devuelve <em>1</em> si est√° dentro de √©l.  Multiplicando el resultado por el renderizado objetivo, realizamos el enmascaramiento. <br><br>  Ahora que hemos proyectado el renderizado objetivo, podemos usarlo para mezclar colores y mover v√©rtices. <br><br><h3>  Usar el renderizado de destino </h3><br>  Comencemos mezclando colores.  Para hacer esto, simplemente conectamos <em>1-x</em> a <em>Lerp</em> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bc2/4e2/6fa/bc24e26fab908757ce5a0dded5d9ce21.jpg"></div><br><blockquote>  <em>Nota:</em> si no comprende por qu√© uso <em>1-x</em> , le explicar√©: esto es necesario para invertir el renderizado objetivo, para que los c√°lculos sean un poco m√°s f√°ciles. </blockquote><br>  Ahora que tenemos un rastro, el color de la tierra se est√° volviendo marr√≥n.  Si no hay color, permanece blanco. <br><br>  El siguiente paso es el desplazamiento de los v√©rtices.  Para hacer esto, agregue los nodos seleccionados y conecte todo de la siguiente manera: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4d7/6b2/6bd/4d76b26bddbf7640fae8032449bea285.jpg"></div><br>  Esto har√° que todas las √°reas nevadas suban <em>25</em> unidades.  Las √°reas sin nieve tienen un desplazamiento cero, lo que crear√° un sendero. <br><br><blockquote>  <em>Nota:</em> puede cambiar la <em>altura</em> de <em>desplazamiento</em> para aumentar o disminuir los niveles de nieve.  Tambi√©n tenga en cuenta que DisplacementHeight es el mismo valor que el desplazamiento de captura.  Cuando tienen el mismo significado, nos da la deformaci√≥n exacta.  Pero hay casos en los que necesita cambiarlos individualmente, por lo que los dej√© como par√°metros separados. </blockquote><br>  Haga clic en <em>Aplicar</em> y regrese al editor principal.  Cree una instancia de <em>BP_Capture</em> en el nivel y dele las coordenadas <em>(0, 0, -2000)</em> para colocarla bajo tierra.  Haga clic en <em>Reproducir</em> y deambule con las teclas <em>W</em> , <em>A</em> , <em>S</em> y <em>D</em> para deformar la nieve. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f6d/a1e/47b/f6da1e47b364e53b0245e53919f4a654.gif"></div><br>  La deformaci√≥n funciona, ¬°pero no quedan rastros!  Esto sucedi√≥ porque la captura sobrescribe el renderizado de destino cada vez que se realiza la captura.  Necesitamos alguna forma de hacer que las pistas sean <em>permanentes</em> . <br><br><h2>  Crear rastros permanentes </h2><br>  Para crear persistencia, necesitamos otro renderizado de destino ( <em>b√∫fer constante</em> ), en el que todos los contenidos de captura se guardar√°n antes de sobrescribir.  Luego agregaremos un b√∫fer constante a la captura (despu√©s de sobrescribirlo).  Obtenemos un bucle en el que cada renderizado de destino escribe en otro.  As√≠ es como crearemos rastros de permanencia. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/04e/3bd/a26/04e3bda26fe04e7832163e2e08abdd64.gif"></div><br>  Primero, necesitamos crear un b√∫fer constante. <br><br><h3>  Crear un b√∫fer persistente </h3><br>  Vaya a la carpeta <em>RenderTargets</em> y cree un nuevo <em>Render Target</em> llamado <em>RT_Persistent</em> .  En este tutorial no tenemos que cambiar los par√°metros de textura, pero en su propio proyecto deber√° asegurarse de que ambos renderizadores de destino usen la misma resoluci√≥n. <br><br>  A continuaci√≥n, necesitamos material que copie la captura en un b√∫fer permanente.  Abra <em>Materiales \ M_DrawToPersistent</em> y agregue un nodo <em>Muestra de textura</em> .  Seleccione la textura <em>RT_Capture</em> para <em>ella</em> y con√©ctela de la siguiente manera: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/29e/b31/328/29eb3132825b6b7ee68ddd5c45a73454.jpg"></div><br>  Ahora necesitamos usar el material de dibujo.  Haga clic en <em>Aplicar</em> y luego abra <em>BP_Capture</em> .  Primero, cree una instancia din√°mica del material (m√°s tarde tendremos que pasarle valores).  Agregue los nodos resaltados al <em>Evento BeginPlay</em> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ca2/1d0/6a1/ca21d06a1bfa563eee0df19b4da6e129.jpg"></div><br>  <em>Borrar renderizado Los</em> nodos <em>2D de destino borran</em> cada renderizado de destino antes de su uso. <br><br>  Luego abra la funci√≥n <em>DrawToPersistent</em> y agregue los nodos resaltados: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c21/88c/051/c2188c0511541f5fcaee1773318653ac.jpg"></div><br>  A continuaci√≥n, debemos asegurarnos de que el dibujo en el b√∫fer constante se realice en cada cuadro, porque la captura se produce en cada cuadro.  Para hacer esto, agregue <em>DrawToPersistent</em> a la <em>marca</em> de <em>evento</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a88/47a/e9d/a8847ae9d4bafffbaacf448af86f538d.jpg"></div><br>  Finalmente, necesitamos agregar un b√∫fer persistente al renderizado de captura de destino. <br><br><h3>  Grabar de nuevo para capturar </h3><br>  Haga clic en <em>Compilar</em> y abra <em>PP_DepthCheck</em> .  Luego agregue los nodos resaltados.  Para <em>Muestra de textura,</em> establezca el valor en <em>RT_Persistent</em> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/afb/ff2/a99/afbff2a99105d523fd44acf437787e06.jpg"></div><br>  Ahora que el objetivo se escribe entre s√≠, obtenemos rastros que quedan.  Haga clic en <em>Aplicar</em> y luego cierre el material.  ¬°Haz clic en <em>Jugar</em> y comienza a dejar pistas! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d79/b8a/fd8/d79b8afd898378111e1fc6b62464bf2a.gif"></div><br>  El resultado se ve muy bien, pero el circuito resultante solo funciona para un √°rea del mapa.  Si va m√°s all√° del √°rea de captura, los rastros dejar√°n de aparecer. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/764/641/1a7/7646411a7886c8c1004a34b2d6f3bda9.gif"></div><br>  Puede resolver este problema moviendo el √°rea de captura con el reproductor.  Esto significa que las huellas siempre aparecer√°n alrededor del √°rea en la que se encuentra el jugador. <br><br>  <em>Nota: a</em> medida que se mueve la captura, se elimina toda la informaci√≥n fuera del √°rea de captura.  Esto significa que si regresa al √°rea donde ya hab√≠a rastros, entonces ya desaparecer√°n.  En el siguiente tutorial, le mostrar√© c√≥mo crear pistas parcialmente retenidas. <br><br><h2>  Movimiento de captura </h2><br>  Puedes decidir que es lo suficientemente simple como para vincular la posici√≥n de captura XY a la posici√≥n XY del jugador.  Pero si lo hace, el renderizado objetivo comenzar√° a desdibujarse.  Esto se debe a que estamos moviendo el renderizado de destino con un paso de menos de un p√≠xel.  Cuando esto sucede, la nueva posici√≥n de p√≠xel es <i>entre los</i> p√≠xeles.  Como resultado, un p√≠xel es interpolado por varios p√≠xeles.  As√≠ es como se ve: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d6f/e29/d8e/d6fe29d8ea33db2479e5e897e6d90344.gif"></div><br>  Para solucionar este problema, necesitamos mover la captura en pasos discretos.  Calculamos <em>el tama√±o de p√≠xel en el mundo</em> y luego movemos la captura a pasos iguales a ese tama√±o.  Entonces cada p√≠xel nunca estar√° entre el otro, por lo que el desenfoque no aparecer√°. <br><br>  Para comenzar, creemos un par√°metro en el que se almacenar√° la ubicaci√≥n de captura.  El material de la Tierra lo necesitar√° para realizar c√°lculos de proyecci√≥n.  Abra <em>MPC_Capture</em> y agregue un <em>par√°metro vectorial</em> llamado <em>CaptureLocation</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1e4/0c7/4c3/1e40c74c3c19e6e8a2520d10874b9c13.jpg"></div><br>  A continuaci√≥n, debe actualizar el material de tierra para usar el nuevo par√°metro.  Cierre <em>MPC_Capture</em> y abra <em>M_Landscape</em> .  Modifique la primera parte de los c√°lculos de proyecci√≥n de la siguiente manera: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d22/8e4/411/d228e4411ac885ec3a29878f7b5d930f.jpg"></div><br>  Ahora el renderizado objetivo siempre se proyectar√° en la ubicaci√≥n de captura.  Haga clic en <em>Aplicar</em> y cierre el material. <br><br>  A continuaci√≥n, realizaremos el movimiento de captura con un paso discreto. <br><br><h3>  Movimiento discreto de captura de pasos </h3><br>  Para calcular el tama√±o de p√≠xel en el mundo, puede usar la siguiente ecuaci√≥n: <br><br><pre><code class="cpp hljs">(<span class="hljs-number"><span class="hljs-number">1</span></span> / RenderTargetResolution) * CaptureSize</code> </pre> <br>  Para calcular la nueva posici√≥n, utilizamos la ecuaci√≥n que se muestra a continuaci√≥n para cada componente de la posici√≥n (en nuestro caso, para las coordenadas X e Y). <br><br><pre> <code class="cpp hljs">(<span class="hljs-built_in"><span class="hljs-built_in">floor</span></span>(Position / PixelWorldSize) + <span class="hljs-number"><span class="hljs-number">0.5</span></span>) * PixelWorldSize</code> </pre> <br>  Ahora √∫selos en la captura de planos.  Para ahorrar tiempo, cre√© la macro <em>SnapToPixelWorldSize</em> para la segunda ecuaci√≥n.  Abra <em>BP_Capture</em> y luego abra la funci√≥n <em>MoveCapture</em> .  A continuaci√≥n, cree el siguiente diagrama: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c10/e17/55d/c10e1755df187bb3578d1b496402101f.jpg"></div><br>  Calcular√° la nueva ubicaci√≥n y luego guardar√° la diferencia entre la ubicaci√≥n nueva y la actual en <em>MoveOffset</em> .  Si est√° utilizando una resoluci√≥n diferente a 256 √ó 256, cambie el valor resaltado. <br><br>  A continuaci√≥n, agregue los nodos seleccionados: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1e9/963/879/1e9963879bfe2465f49a71665317db20.jpg"></div><br>  Este circuito mover√° la captura con el desplazamiento calculado.  Luego guardar√° la nueva ubicaci√≥n de captura en <em>MPC_Capture</em> para que pueda ser utilizada por el material del suelo. <br><br>  Finalmente, necesitamos realizar una actualizaci√≥n de posici√≥n en cada cuadro.  Cierre la funci√≥n y agr√©guela a la <em>marca de</em> <em>evento</em> antes de <em>DrawToPersistent</em> <em>MoveCapture</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f15/3c6/d54/f153c6d5438ba54a85f2b3749b179bb9.jpg"></div><br>  Mover una captura es solo la mitad de la soluci√≥n.  Tambi√©n necesitamos mover el b√∫fer constante.  De lo contrario, la captura y el b√∫fer persistente no estar√°n sincronizados y producir√°n resultados extra√±os. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e1f/4fa/008/e1f4fa0086dc9f41412b70856f246149.gif"></div><br><h3>  Movimiento de b√∫fer permanente </h3><br>  Para cambiar un buffer constante, necesitamos pasar el desplazamiento de desplazamiento calculado.  Abra <em>M_DrawToPersistent</em> y agregue los nodos resaltados: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e65/d15/16b/e65d1516bc33002a2e2a3bc7e9c96b00.jpg"></div><br>  Debido a esto, el b√∫fer constante se desplazar√° por el valor del desplazamiento transmitido.  Como en el material de la tierra, necesitamos voltear la coordenada X y realizar el enmascaramiento.  Haga clic en <em>Aplicar</em> y cierre el material. <br><br>  Entonces necesita transferir el desplazamiento.  Abra <em>BP_Capture</em> y luego abra la funci√≥n <em>DrawToPersistent</em> .  A continuaci√≥n, agregue los nodos resaltados: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/666/621/f22/666621f22bde013dd710991d5adfa7e4.jpg"></div><br>  As√≠ es como convertimos <em>MoveOffset</em> en espacio UV y luego lo pasamos al material de dibujo. <br><br>  Haga clic en <em>Compilar</em> y luego cierre el plano.  ¬°Haz clic en <em>Jugar</em> y corre al contenido de tu coraz√≥n!  No importa qu√© tan lejos corras, las huellas siempre permanecer√°n a tu alrededor. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a94/097/5cb/a940975cb157444251cdb31bf195c8f2.gif"></div><br><h2>  ¬øA d√≥nde ir despu√©s? </h2><br>  El proyecto terminado se puede descargar desde aqu√≠. <br><br>  No es necesario utilizar las pistas creadas en este tutorial solo para nieve.  Incluso puede usarlos para cosas como hierba triturada (en el pr√≥ximo tutorial le mostrar√© c√≥mo crear una versi√≥n avanzada del sistema). <br><br>  Si desea trabajar con paisajes y representaciones de objetivos, le recomiendo ver el video de Chris Murphy <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Building High-End Gameplay Effects con Blueprint</a> .  ¬°Este tutorial te mostrar√° c√≥mo crear un enorme l√°ser que quema tierra y hierba! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es416703/">https://habr.com/ru/post/es416703/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es416691/index.html">Seguridad del aprendizaje autom√°tico: ¬øt√©cnicas de defensa eficaces o nuevas amenazas?</a></li>
<li><a href="../es416693/index.html">Certificados de D-Link y Changing Information Technologies utilizados para firmar malware</a></li>
<li><a href="../es416695/index.html">Compatibilidad con vSphere 6.7 y otras funciones de la √∫ltima actualizaci√≥n Veaam Backup & Replication 9.5 3a</a></li>
<li><a href="../es416697/index.html">Fusi√≥n de operadores de telecomunicaciones en 2018</a></li>
<li><a href="../es416699/index.html">Francotirador geek o c√≥mo hacer un "buen ojo"</a></li>
<li><a href="../es416707/index.html">Software de administraci√≥n de escritorio remoto - Aspia</a></li>
<li><a href="../es416709/index.html">IoT y progreso natural: las tecnolog√≠as y dispositivos m√°s controvertidos</a></li>
<li><a href="../es416711/index.html">P√°ginas de la historia de Intel. Fuego de f√°brica de Penang</a></li>
<li><a href="../es416713/index.html">Informe del Club de Roma 2018, Cap√≠tulo 3.14: "Ni un solo PIB ..."</a></li>
<li><a href="../es416719/index.html">Extensi√≥n PHP y Kotlin Native. Segunda parte, consciente</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>