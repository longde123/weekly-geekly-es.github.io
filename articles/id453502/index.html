<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✍🏽 🧚🏻 👨‍💻 Rake saya: dari kain menjadi kekayaan 👨🏾‍🚒 📑 🚜</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Latar belakang 


 Saya telah bekerja sebagai pengembang front-end selama satu tahun sekarang. Proyek pertama saya adalah backend "musuh". Itu terjadi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Rake saya: dari kain menjadi kekayaan</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/453502/"><h2 id="predystoriya">  Latar belakang </h2><br><p>  Saya telah bekerja sebagai pengembang front-end selama satu tahun sekarang.  Proyek pertama saya adalah backend "musuh".  Itu terjadi bahwa ini bukan masalah besar ketika komunikasi dibuat. </p><br><p>  Tetapi dalam kasus kami tidak demikian. </p><a name="habracut"></a><br><p>  Kami mengembangkan kode, yang mengandalkan fakta bahwa backend mengirimi kami data tertentu, struktur tertentu, dan format tertentu.  Sementara backend dianggap normal untuk mengubah isi tanggapan - tanpa peringatan.  Akibatnya, kami butuh berjam-jam untuk menentukan mengapa bagian tertentu dari situs berhenti bekerja. </p><br><p>  Kami menyadari bahwa kami perlu memeriksa apa yang dikembalikan backend sebelum mengandalkan data yang dikirimkan kepada kami.  Kami membuat tugas untuk penelitian tentang masalah validasi data dari ujung depan. </p><br><p>  Penelitian ini ditugaskan kepada saya. </p><br><p>  Saya telah membuat daftar apa yang saya inginkan dalam alat yang ingin saya gunakan untuk validasi data. </p><br><p>  Poin seleksi paling penting adalah poin berikut: </p><br><ul><li>  deskripsi (skema) validasi deklaratif, yang diubah menjadi fungsi validator yang mengembalikan true / false (valid, tidak valid) </li><li>  ambang masuk rendah; </li><li> kesamaan data yang divalidasi dengan deskripsi validasi; </li><li>  kemudahan integrasi validasi khusus; </li><li>  kemudahan integrasi pesan kesalahan khusus. </li></ul><br><p>  Akibatnya, saya menemukan banyak perpustakaan validasi, setelah meninjau TOP-5 (ajv, joi, roi ...).  Mereka semua sangat baik.  Tetapi bagi saya, untuk menyelesaikan 5% kasus rumit - mereka menganggap 95% kasus paling umum adalah bertele-tele dan tebal. </p><br><p>  Jadi saya berpikir: mengapa tidak mengembangkan sesuatu sendiri yang cocok untuk saya. <br>  Empat bulan kemudian, versi ketujuh dari perpustakaan validasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">kuartet</a> saya keluar. <br>  Itu adalah versi stabil, sepenuhnya teruji, unduhan 11k pada npm.  Kami menggunakannya pada tiga proyek dalam kampanye selama tiga bulan. </p><br><p>  Tiga bulan ini telah memainkan peran yang sangat berguna.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">kuartet telah</a> menunjukkan semua kelebihannya.  Tidak ada masalah data dari backend.  Setiap kali mereka mengubah jawaban, kami segera melakukan kesalahan.  Waktu yang dihabiskan untuk menemukan penyebab bug telah menurun secara dramatis.  Praktis tidak ada bug data yang tersisa. </p><br><p>  Tetapi juga kelemahan diidentifikasi. </p><br><p>  Oleh karena itu, saya memutuskan untuk menganalisisnya dan merilis versi baru dengan koreksi semua kesalahan yang dibuat selama pengembangan. <br>  Saya akan berbicara tentang kesalahan arsitektur ini dan solusinya di bawah. </p><br><h2 id="arhitekturnye-grabli">  Rake arsitektur </h2><br><h3 id="stroko-tipizirovannyy-yazyk-shemy">  "Stroko" - bahasa khas skema </h3><br><p>  Saya akan memberikan contoh skema versi lama untuk objek orang tersebut. </p><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> personSchema = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'string'</span></span>, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-string"><span class="hljs-string">'number'</span></span>, <span class="hljs-attr"><span class="hljs-attr">linkedin</span></span>: [<span class="hljs-string"><span class="hljs-string">'string'</span></span>, <span class="hljs-string"><span class="hljs-string">'null'</span></span>] }</code> </pre> <br><p>  Skema ini memvalidasi objek dengan tiga properti: nama - harus berupa string, usia - harus berupa angka, tautan ke akun di LinkedIn - harus berupa nol (jika tidak ada akun) atau string (jika ada akun). </p><br><p>  Skema ini memenuhi persyaratan saya untuk keterbacaan, kesamaan dengan data yang divalidasi, dan saya pikir ambang masuk untuk belajar menulis skema seperti itu tidak tinggi.  Selain itu, skema seperti itu dapat dengan mudah ditulis dengan definisi tipe dalam naskah: </p><br><pre> <code class="javascript hljs">type Person = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: string age: number linkedin: string | <span class="hljs-literal"><span class="hljs-literal">null</span></span> }</code> </pre> <br><p>  (Seperti yang kita lihat, perubahannya lebih cenderung kosmetik) </p><br><p>  Ketika saya membuat keputusan, apa yang harus digunakan untuk opsi validasi yang paling sering (misalnya, yang digunakan di atas).  Saya memilih untuk menggunakan - string, seolah-olah, nama-nama validator. </p><br><p>  Tetapi masalah dengan string adalah bahwa mereka tidak tersedia untuk kompilator atau penganalisa kesalahan.  String 'angka' untuk mereka tidak jauh berbeda dari 'numder'. </p><br><h3 id="reshenie">  Solusi </h3><br><p>  Versi baru dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">kuartet</a> 8.0.0.  Saya memutuskan untuk menghapus dari kuartet - penggunaan string sebagai nama validator di dalam skema. </p><br><p>  Diagram sekarang terlihat seperti ini: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> personSchema = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: v.string age: v.number, <span class="hljs-attr"><span class="hljs-attr">linkedin</span></span>: [v.string, <span class="hljs-literal"><span class="hljs-literal">null</span></span>] }</code> </pre> <br><p>  Perubahan ini memiliki dua keuntungan besar: </p><br><ul><li>  kompiler atau penganalisa kesalahan - akan dapat mendeteksi bahwa nama metode dieja dengan kesalahan. </li><li>  Garis - tidak lagi digunakan sebagai elemen skema.  Ini berarti bagi mereka Anda dapat memilih fungsi baru di perpustakaan, yang akan dijelaskan di bawah ini. </li></ul><br><h3 id="podderzhka-typescript">  Dukungan TypeScript </h3><br><p>  Secara umum, tujuh versi pertama dikembangkan dalam Javascript murni.  Ketika beralih ke proyek dengan Typecript, ada kebutuhan untuk mengadaptasi perpustakaan untuknya.  Oleh karena itu, ketik deklarasi untuk perpustakaan ditulis. </p><br><p>  Tapi ini minus - saat menambahkan fungsionalitas, atau ketika mengubah beberapa elemen perpustakaan, selalu mudah untuk lupa memperbarui deklarasi tipe. </p><br><p>  Ada juga ketidaknyamanan kecil seperti ini: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> checkPerson = v(personSchema) <span class="hljs-comment"><span class="hljs-comment">// (0) // ... const person: any = await axios.get('https://myapi.com/person/42') if (!checkPerson(person)) {// (1) throw new TypeError('Invalid person response') } console.log(person.name) // (2)</span></span></code> </pre> <br><p>  Ketika kami membuat validator objek on line (0).  Kami ingin setelah memeriksa jawaban sebenarnya dari backend on line (1) dan menangani kesalahan.  On line (2) sehingga <code>person</code> bertipe Person.  Tetapi ini tidak terjadi.  Sayangnya, cek semacam itu bukan tipe penjaga. </p><br><h3 id="reshenie-1">  Solusi </h3><br><p>  Saya memutuskan untuk menulis ulang seluruh pustaka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">kuartet</a> ke dalam TypeScript sehingga kompiler terlibat dalam memeriksa korespondensi perpustakaan dengan jenis.  Sepanjang jalan, kami menambahkan ke fungsi yang mengembalikan validator yang dikompilasi, parameter tipe yang akan menentukan tipe penjaga tipe validator ini. </p><br><p>  Contohnya terlihat seperti ini: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> checkPerson = v&lt;Person&gt;(personSchema) <span class="hljs-comment"><span class="hljs-comment">// (0) // ... const person: any = await axios.get('https://myapi.com/person/42') if (!checkPerson(person)) {// (1) throw new TypeError('Invalid person response') } console.log(person.name) // (2)</span></span></code> </pre> <br><p>  Sekarang on line (2) <code>person</code> bertipe <code>Person</code> . </p><br><h3 id="chitaemost">  Keterbacaan </h3><br><p>  Ada juga dua kasus di mana kode itu dibaca dengan buruk: memeriksa kepatuhan dengan set nilai tertentu (memeriksa enum) dan memeriksa properti lain dari objek. </p><br><p>  a) Periksa enum <br>  Awalnya, ada ide, menurut saya bagus.  Kami akan menunjukkannya dengan menambahkan bidang "gender" ke objek kami. <br>  Versi lama sirkuit tampak seperti ini: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> personSchema = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'string'</span></span>, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-string"><span class="hljs-string">'number'</span></span>, <span class="hljs-attr"><span class="hljs-attr">linkedin</span></span>: [<span class="hljs-string"><span class="hljs-string">'null'</span></span>, <span class="hljs-string"><span class="hljs-string">'string'</span></span>], <span class="hljs-attr"><span class="hljs-attr">sex</span></span>: v.enum(<span class="hljs-string"><span class="hljs-string">'male'</span></span>, <span class="hljs-string"><span class="hljs-string">'female'</span></span>) }</code> </pre> <br><p>  Opsi ini sangat mudah dibaca.  Tapi seperti biasa, semuanya berjalan agak tidak sesuai rencana. <br>  Memiliki enum yang dinyatakan dalam program, misalnya, ini: </p><br><pre> <code class="javascript hljs">enum Sex { Male = <span class="hljs-string"><span class="hljs-string">'male'</span></span>, Female = <span class="hljs-string"><span class="hljs-string">'female'</span></span> }</code> </pre> <br><p>  Secara alami saya ingin menggunakannya di dalam sirkuit.  Sehingga ketika mengubah salah satu nilai (misalnya, 'laki-laki' -&gt; 'm', 'perempuan' -&gt; 'f'), skema validasi juga harus berubah. </p><br><p>  Oleh karena itu, hampir selalu validasi enum ditulis seperti ini: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> personSchema = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'string'</span></span>, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-string"><span class="hljs-string">'number'</span></span>, <span class="hljs-attr"><span class="hljs-attr">linkedin</span></span>: [<span class="hljs-string"><span class="hljs-string">'null'</span></span>, <span class="hljs-string"><span class="hljs-string">'string'</span></span>], <span class="hljs-attr"><span class="hljs-attr">sex</span></span>: v.enum(...Object.values(Sex)) }</code> </pre> <br><p>  Yang terlihat cukup besar. </p><br><p>  b) Validasi properti residual dari objek </p><br><p>  Misalkan kita menambahkan karakteristik seperti itu ke objek kita - ia dapat memiliki bidang tambahan, tetapi semuanya harus berupa tautan ke jejaring sosial - itu berarti mereka harus berupa <code>null</code> atau string. </p><br><p>  Skema lama akan terlihat seperti ini: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> personSchema = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'string'</span></span>, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-string"><span class="hljs-string">'number'</span></span>, <span class="hljs-attr"><span class="hljs-attr">linkedin</span></span>: [<span class="hljs-string"><span class="hljs-string">'null'</span></span>, <span class="hljs-string"><span class="hljs-string">'string'</span></span>], <span class="hljs-attr"><span class="hljs-attr">sex</span></span>: v.enum(...Object.values(Sex)), ...v.rest([<span class="hljs-string"><span class="hljs-string">'null'</span></span>, <span class="hljs-string"><span class="hljs-string">'string'</span></span>]) <span class="hljs-comment"><span class="hljs-comment">// Rest props are string | null }</span></span></code> </pre> <br><p>  Entri ini menyoroti properti yang tersisa - dari yang sudah terdaftar.  Penggunaan operator spread cenderung membingungkan orang yang ingin memahami skema ini. </p><br><h3 id="reshenie-2">  Solusi </h3><br><p>  Seperti dijelaskan di atas, string tidak lagi menjadi bagian dari skema validasi.  Hanya tiga jenis nilai Javascript yang tetap menjadi skema validasi.  Objek - untuk menggambarkan skema validasi objek.  Array untuk deskripsi - beberapa opsi untuk validitas.  Fungsi (pustaka yang dibuat atau kustom) - untuk semua opsi validasi lainnya. </p><br><p>  Ketentuan ini diizinkan untuk menambah fungsionalitas, yang memungkinkan untuk meningkatkan keterbacaan rangkaian berkali-kali. </p><br><p>  Padahal, bagaimana jika kita ingin membandingkan nilainya dengan string 'pria'.  Apakah kita benar-benar perlu mengetahui hal lain selain nilai itu sendiri dan string 'laki-laki'. </p><br><p>  Oleh karena itu, diputuskan untuk menambahkan nilai tipe primitif sebagai elemen rangkaian.  Oleh karena itu, di mana Anda memenuhi nilai primitif dalam skema, ini berarti bahwa ini adalah nilai valid yang harus diperiksa oleh validator sesuai dengan skema ini.  Lebih baik saya memberi contoh: </p><br><p>  Jika kita perlu memeriksa nomor untuk kesetaraan 42-pikiran.  Lalu kita tulis seperti ini: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> check42 = v(<span class="hljs-number"><span class="hljs-number">42</span></span>) check42(<span class="hljs-number"><span class="hljs-number">42</span></span>) <span class="hljs-comment"><span class="hljs-comment">// =&gt; true check42(41) // =&gt; false check42(43) // =&gt; false check42('42') // =&gt; false</span></span></code> </pre> <br><p>  Mari kita lihat bagaimana ini memengaruhi skema orang (tanpa memperhitungkan properti tambahan akun): </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> personSchema = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: v.string, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: v.number, <span class="hljs-attr"><span class="hljs-attr">linkedin</span></span>: [<span class="hljs-literal"><span class="hljs-literal">null</span></span>, v.string], <span class="hljs-comment"><span class="hljs-comment">// null is primitive value sex: ['male', 'female'] // 'male', 'female' are primitive values }</span></span></code> </pre> <br><p>  Dengan menggunakan enum yang telah ditentukan, kita dapat menulis ulang seperti ini: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> personSchema = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: v.string, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: v.number, <span class="hljs-attr"><span class="hljs-attr">linkedin</span></span>: [<span class="hljs-literal"><span class="hljs-literal">null</span></span>, v.string], <span class="hljs-attr"><span class="hljs-attr">sex</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.values(Sex) <span class="hljs-comment"><span class="hljs-comment">// same as ['male', 'female'] }</span></span></code> </pre> <br><p>  Dalam hal ini, upacara yang tidak perlu dihapus dalam bentuk menggunakan metode enum dan menggunakan operator spread untuk memasukkan nilai yang valid dari objek sebagai parameter ke dalam metode ini. </p><br><p>  Apa yang dianggap sebagai nilai primitif: angka, string, karakter, <code>true</code> , <code>false</code> , <code>null</code> , dan <code>undefined</code> . </p><br><p>  Artinya, jika kita perlu membandingkan nilainya dengan mereka, kita cukup menggunakan nilai-nilai ini sendiri.  Dan perpustakaan validasi - itu akan membuat validator yang secara ketat membandingkan nilai dengan yang ditentukan dalam skema. </p><br><p>  Untuk memvalidasi properti residual, dipilih untuk menggunakan properti khusus untuk semua bidang objek lainnya: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> personSchema = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: v.string, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: v.number, <span class="hljs-attr"><span class="hljs-attr">linkedin</span></span>: [<span class="hljs-literal"><span class="hljs-literal">null</span></span>, v.string], <span class="hljs-attr"><span class="hljs-attr">sex</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.values(Sex), [v.rest]: [<span class="hljs-literal"><span class="hljs-literal">null</span></span>, v.string] }</code> </pre> <br><p>  Dengan demikian, sirkuit terlihat lebih mudah dibaca.  Dan lebih seperti iklan naskah. </p><br><h3 id="svyazannost-validatora-s-funkciey-kotoraya-sozdala-ego">  Validator terkait dengan fungsi yang membuatnya </h3><br><p>  Dalam versi yang lebih lama, penjelasan kesalahan bukan bagian dari validator.  Mereka ditambahkan ke array di dalam fungsi <code>v</code> . </p><br><p>  Sebelumnya, untuk mendapatkan penjelasan tentang kesalahan validasi, Anda harus memiliki validator bersama Anda (untuk memeriksa) dan v (untuk mendapatkan penjelasan tentang ketidakabsahan).  Semua ini tampak sebagai berikut: <br><br>  a) Kami menambahkan penjelasan pada diagram </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> checkPerson = v({ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: v(<span class="hljs-string"><span class="hljs-string">'string'</span></span>, <span class="hljs-string"><span class="hljs-string">'wrong name'</span></span>) age: v(<span class="hljs-string"><span class="hljs-string">'number'</span></span>, <span class="hljs-string"><span class="hljs-string">'wrong age'</span></span>), <span class="hljs-attr"><span class="hljs-attr">linkedin</span></span>: v([<span class="hljs-string"><span class="hljs-string">'null'</span></span>, <span class="hljs-string"><span class="hljs-string">'string'</span></span>], <span class="hljs-string"><span class="hljs-string">'wrong linkedin'</span></span>), <span class="hljs-attr"><span class="hljs-attr">sex</span></span>: v( v.enum(...Object.values(Sex)), <span class="hljs-string"><span class="hljs-string">'wrong sex value'</span></span> ), ...v.rest( v( [<span class="hljs-string"><span class="hljs-string">'null'</span></span>, <span class="hljs-string"><span class="hljs-string">'string'</span></span>], <span class="hljs-string"><span class="hljs-string">'wrong social networks link'</span></span> ) ) <span class="hljs-comment"><span class="hljs-comment">// Rest props are string | null })</span></span></code> </pre> <br><p>  Ke elemen mana pun dari rangkaian - Anda dapat menambahkan penjelasan tentang kesalahan menggunakan argumen kedua fungsi v compiler. </p><br><p>  b) Kosongkan array penjelasan </p><br><p>  Sebelum validasi, perlu untuk menghapus array global ini di mana semua penjelasan dicatat selama validasi. </p><br><pre> <code class="javascript hljs">v.clearContext() <span class="hljs-comment"><span class="hljs-comment">// same as v.explanations = []</span></span></code> </pre> <br><p>  c) Validasi </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isPersonValid = checkPerson(person)</code> </pre> <br><p>  Selama pemeriksaan ini, jika validitas terdeteksi, dan pada tahap pembuatan sirkuit - penjelasan diberikan padanya, penjelasan ini ditempatkan dalam array global <code>v.explanation</code> . </p><br><p>  d) Penanganan kesalahan </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isPersonValid) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TypeError</span></span>(<span class="hljs-string"><span class="hljs-string">'Invalid person response: '</span></span> + v.explanation.join(<span class="hljs-string"><span class="hljs-string">'; '</span></span>)) } <span class="hljs-comment"><span class="hljs-comment">// ex. Throws 'Invalid person response: wrong name; wrong age'</span></span></code> </pre> <br><p>  Seperti yang Anda lihat di sini, ada masalah besar.  Karena jika kita ingin menggunakan validator bukan di tempat pembuatannya.  Kita harus melewati tidak hanya parameter, tetapi juga fungsi yang membuatnya.  Karena di dalamnya array terletak di mana penjelasan akan ditambahkan. </p><br><h3 id="reshenie-3">  Solusi </h3><br><p>  Masalah ini diselesaikan sebagai berikut: penjelasan menjadi bagian dari fungsi validasi itu sendiri.  Apa yang bisa dipahami dari tipenya: <br>  ketik Validator = (nilai: ada, penjelasan?: ada []) =&gt; boolean </p><br><p>  Sekarang jika Anda membutuhkan penjelasan tentang kesalahan, Anda meneruskan array yang ingin Anda tambahkan penjelasan. </p><br><p>  Dengan demikian, validator menjadi unit independen.  Suatu metode juga telah ditambahkan yang dapat mengubah fungsi validasi menjadi fungsi yang mengembalikan null jika nilainya valid, dan mengembalikan array penjelasan jika nilainya tidak valid. </p><br><p>  Sekarang validasi dengan penjelasannya terlihat seperti ini: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> checkPerson = v&lt;Person&gt;({ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: v(v.string, <span class="hljs-string"><span class="hljs-string">'wrong name'</span></span>), <span class="hljs-attr"><span class="hljs-attr">age</span></span>: v(v.number, <span class="hljs-string"><span class="hljs-string">'wrong age'</span></span>), <span class="hljs-attr"><span class="hljs-attr">linkedin</span></span>: v([<span class="hljs-literal"><span class="hljs-literal">null</span></span>, v.string], <span class="hljs-string"><span class="hljs-string">'wrong linkedin'</span></span>) sex: v(<span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.values(Sex), <span class="hljs-string"><span class="hljs-string">'wrong sex'</span></span>) [v.rest]: v([<span class="hljs-literal"><span class="hljs-literal">null</span></span>, v.string], <span class="hljs-string"><span class="hljs-string">'wrong social network'</span></span>) }) <span class="hljs-comment"><span class="hljs-comment">// ... const explanations = [] if (!checkPerson(person, explanation)) { throw new TypeError('Wrong person: ' + explanations.join('; ')) } // OR const getExplanation = v.explain(checkPerson) const explanations = getExplanation(person) if (explanations) { throw new TypeError('Wrong person: ' + explanations.join('; ')) }</span></span></code> </pre> <br><h2 id="posleslovie">  Kata penutup </h2><br><p>  Saya menyoroti tiga tempat karena itu saya harus menulis ulang semuanya: </p><br><ul><li>  Harapannya agar orang tidak salah ketika menulis kalimat </li><li>  Menggunakan variabel global (dalam hal ini, v.explanation array) </li><li>  Pengujian dengan contoh kecil selama pengembangan - tidak menunjukkan masalah yang muncul ketika digunakan dalam kasus besar nyata. </li></ul><br><p>  Tapi saya senang saya melakukan analisis masalah ini, dan versi yang dirilis sudah digunakan dalam proyek kami.  Dan saya berharap ini akan bermanfaat bagi kita tidak kurang dari yang sebelumnya. </p><br><p>  Terima kasih sudah membaca, semoga pengalaman saya bermanfaat bagi Anda. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id453502/">https://habr.com/ru/post/id453502/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id453484/index.html">Penghitung BCD 4-bit</a></li>
<li><a href="../id453486/index.html">Prinsip Pasar Bebas AS</a></li>
<li><a href="../id453490/index.html">Berita dari dunia OpenStreetMap No. 461 (14/05/2019 - 05/05/2019)</a></li>
<li><a href="../id453492/index.html">Otomatisasi proses bisnis perusahaan Trello menggunakan teknologi pemodelan semantik</a></li>
<li><a href="../id453496/index.html">Selamat ahli kimia, kolega</a></li>
<li><a href="../id453508/index.html">Manusia tanpa smartphone</a></li>
<li><a href="../id453510/index.html">Semua milik Anda: Tutorial cara membuat tindakan baru untuk UiPath RPA</a></li>
<li><a href="../id453512/index.html">Transfer gaya</a></li>
<li><a href="../id453514/index.html">Panduan Pengantar Penawaran di iOS</a></li>
<li><a href="../id453516/index.html">Otomatisasi untuk yang terkecil. Bagian nol. Perencanaan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>