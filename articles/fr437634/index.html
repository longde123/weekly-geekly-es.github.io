<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏾‍🎤 🤶 👨🏼‍✈️ Routeur sans fil bricolage 💶 🕵🏽 🙆🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="1. Sélection des composants 
2. Lancer les interfaces réseau 
3. Configuration d'un point d'accès 802.11ac (5 GHz) 
4. Configuration d'un SSID virtuel...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Routeur sans fil bricolage</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437634/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/967/b65/9d2/967b659d291d3021a9a93f68b4b305b2.jpg"></div><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sélection des composants</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Lancer les interfaces réseau</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Configuration d'un point d'accès 802.11ac (5 GHz)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Configuration d'un SSID virtuel à l'aide de hostapd</a> </li></ol><br>  Au cours des dix dernières années, j'ai acheté un équipement réseau bon marché et y ai installé <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">DD-WRT</a> afin de retourner les «fonctions» pour plus de 500 $ supprimées du noyau Linux, sur lequel est basé le firmware d'origine. <br><br>  Malgré des versions instables, des bugs et des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://web.archive.org/web/20160303173311/">litiges</a> non corrigés, DD-WRT est toujours préférable au stockage du firmware.  Mais maintenant, les composants dignes sont moins chers que jamais, et la communauté de bricolage est complètement passée à Linux (je vous regarde, M. Raspberry), alors pourquoi ne pas construire votre propre routeur sans fil une fois pour toutes? <br><a name="habracut"></a><br><a name="1"></a><h1>  Sélection des composants </h1><br>  Tout d'abord, vous devez décider de la plate-forme: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">x86</a> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ARM</a> ?  Je ne <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">discuterai</a> pas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">en détail des principales différences</a> , mais brièvement: le premier a de meilleures performances, tandis que le second est moins cher et plus économe en énergie.  Les cartes Raspberry Pi (et équivalents) sont extrêmement bon marché et probablement plus puissantes que la plupart des routeurs commerciaux sans fil, mais les plates-formes x86 sont répandues et ont l'avantage de facteurs de forme et de ports d'extension standardisés. <br><br>  Bien sûr, le détail le plus important est le chipset.  Aujourd'hui, les normes de facto sont <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">802.11n</a> (2,4 GHz) et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">802.11ac</a> (5 GHz), mais choisir des pilotes pour Linux <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">reste un défi</a> , en particulier avec la prise en charge du mode AP (point d'accès).  En bref, si vous ne voulez pas de problèmes, choisissez les chipsets <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Atheros</a> .  Les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pilotes</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ath9k</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ath10k sont</a> bien pris en charge, vous pouvez facilement les trouver avec des interfaces USB et / ou mini-PCIe. <br><br>  Au moins un contrôleur d'interface réseau (NIC) est un minimum nécessaire, et choisissez la RAM et le stockage à votre goût. <br><br><h2>  Liste des matériaux </h2><br>  Après avoir sacrifié le prix et la consommation d'énergie, j'ai choisi la plate-forme x86 pour la configuration modulaire et relativement puissante disponible pour la mise à niveau. <br><br>  <i>Si vous n'avez pas besoin d'un ARM, un ventilateur n'est pas nécessaire.</i> <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow noopener">Gigabyte GA-J1900N-D3V</a> (J1900 Quad-core 2 GHz Celeron, deux NIC) </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow noopener">Airetos AEX-QCA9880-NX</a> (double bande 802.11ac, MIMO) </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow noopener">4 Go de RAM</a> (DDR3-LP, 1333 MHz, 1,35 V) </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow noopener">Extension mPCIe</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow noopener">Châssis mini-ITX MX500</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow noopener">Trois antennes double bande 6dBi RP-SMA +</a> câble <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow noopener">RP-SMA</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow noopener">PicoPSU-90</a> </li><li>  Disque dur de rechange 2,5 ” </li></ul><br>  Le boîtier est spacieux, avec deux trous préparés pour la prise AC / DC.  L'installation de la carte mère, de la RAM et du Pico-PSU s'est bien déroulée: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7ad/455/84b/7ad45584b277d11fa3f1a7b119759ebc.jpg"><br>  <i><font color="gray">Iron porn</font></i> <br><br>  La chose la plus difficile a été d'installer le mini-PCIe WiFi, car la carte ne prend en charge que les cartes demi-taille: ici, le câble d'extension mPCIe est venu à la rescousse.  J'ai pris un câble FFC de 20 cm (inclus) pour connecter les deux côtés de l'adaptateur et fixé le mini-PCIe au châssis à l'aide de ruban adhésif double face. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/db1/c7a/8f7/db1c7a8f756c70176d86ce9441d5cf7a.jpg"><img src="https://habrastorage.org/getpro/habr/post_images/5bb/b09/5c7/5bbb095c759ac5cd9be3cf316070ab22.jpg"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/3a4/e91/9b8/3a4e919b817344fdc03d98bb1e9d001f.jpg"><br>  <i><font color="gray">Extenseur mini-PCIe</font></i> <br><br>  Heureusement, le châssis est livré avec trois trous d'antenne prédécoupés.  Voici le résultat final: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/967/b65/9d2/967b659d291d3021a9a93f68b4b305b2.jpg"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/c3d/82d/a98/c3d82da9842de641d8d3a4dec3cfe517.jpg"><br><br><a name="2"></a><h1>  Logiciels </h1><br>  Il est clair que nous avons mis Linux.  Selon le matériel, il peut s'agir d'une distribution optimisée comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Raspbian</a> (pour le Raspberry Pi) ou toute autre distribution Linux que vous aimez.  Depuis que j'utilise Ubuntu depuis de nombreuses années, j'ai choisi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ubuntu Server 18.04 LTS</a> , avec lequel je suis plus habitué à travailler et qui a un support à long terme. <br><br>  <i>Le reste de cet article suppose que vous utilisez une distribution basée sur Debian.</i> <br><br>  Si l'installation s'est bien passée et que vous êtes allé sur la console, définissez les noms d'interface: <br><br><pre><code class="bash hljs">$ ip -br a | awk <span class="hljs-string"><span class="hljs-string">'{print $1}'</span></span> lo enp1s0 enp2s0 wlp5s0</code> </pre> <br>  Il y a deux cartes réseau intégrées sur la carte mère: ce sont <code>enp1s0</code> et <code>enp2s0</code> .  La carte sans fil apparaît comme <code>wlp5s0</code> et prend en charge le mode AP, comme prévu: <br><br><pre> <code class="bash hljs">$ iw list ... Supported interface modes: * managed * AP * AP/VLAN * monitor * mesh point</code> </pre> <br>  Nous pouvons maintenant décrire ce dont nous avons besoin: nous mettons la première carte réseau en tant que port WAN, et la seconde nous nous connectons à l'interface sans fil: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5e6/f00/dd4/5e6f00dd4994b5dc252d70dda1d325ec.png"><br><br><h2>  Réseau </h2><br>  Si vous avez Ubuntu 18.04, débarrassez- <code>netplan</code> immédiatement de <code>netplan</code> pour revenir à la prise en charge de / etc / network / interfaces: <br><br><pre> <code class="bash hljs">$ sudo apt-get install ifupdown bridge-utils $ sudo systemctl stop networkd-dispatcher $ sudo systemctl <span class="hljs-built_in"><span class="hljs-built_in">disable</span></span> networkd-dispatcher $ sudo systemctl mask networkd-dispatcher $ sudo apt-get purge nplan netplan.io</code> </pre> <br>  En tant que serveur DHCP / DNS, sélectionnez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dnsmasq</a> : <br><br><pre> <code class="bash hljs">$ sudo apt-get install dnsmasq</code> </pre> <br>  Puisque nous allons démarrer et configurer le processus <code>dnsmasq</code> via le hook <code>post-up</code> , n'oubliez pas de désactiver le démon au démarrage: <br><br><pre> <code class="bash hljs">$ sudo sed -i <span class="hljs-string"><span class="hljs-string">"s/^ENABLED=1$/ENABLED=0/g"</span></span> /etc/default/dnsmasq</code> </pre> <br>  Nous écrirons la configuration <b>préliminaire</b> des interfaces réseau conformément au schéma, y ​​compris la configuration minimale de <code>dnsmasq</code> : <br><br><pre> <code class="bash hljs">$ cat /etc/network/interfaces <span class="hljs-comment"><span class="hljs-comment"># Loopback auto lo iface lo inet loopback # WAN interface auto enp1s0 iface enp1s0 inet dhcp # Bridge (LAN) auto br0 iface br0 inet static address 192.168.1.1 network 192.168.1.0 netmask 255.255.255.0 broadcast 192.168.1.255 bridge_ports enp2s0 post-up /usr/sbin/dnsmasq \ --pid-file=/var/run/dnsmasq.$IFACE.pid \ --dhcp-leasefile=/var/lib/misc/dnsmasq.$IFACE.leases \ --conf-file=/dev/null \ --interface=$IFACE --except-interface=lo \ --bind-interfaces \ --dhcp-range=192.168.1.10,192.168.1.150,24h pre-down cat /var/run/dnsmasq.$IFACE.pid | xargs kill</span></span></code> </pre> <br>  <i>La documentation <code>/etc/network/interfaces</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a></i> <br><br>  Comme vous pouvez le voir dans la section <code>post-up</code> , dnsmasq démarre dès que le pont se lève.  Sa configuration est effectuée uniquement par des arguments de ligne de commande ( <code>--conf-file=/dev/null</code> ), et le processus s'arrête lorsque l'interface est désactivée. <br><br>  L'interface <code>bridge_ports</code> n'est pas spécifiquement spécifiée dans le <code>wlp5s0</code> , car <code>hostapd</code> l'ajoutera automatiquement au pont (brctl peut refuser de le faire avant que hostapd ne démarre pour changer le mode d'interface). <br><br>  <i>Voir la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation de</a> <code>dnsmasq</code> .</i> <br><br>  Vous pouvez maintenant redémarrer le réseau (redémarrage de la mise en réseau du <code>sudo service networking restart</code> ) ou simplement redémarrer pour vérifier que la configuration réseau est correcte. <br><br>  Veuillez noter: bien que nous puissions actuellement recevoir DHCP de <code>enp2s0</code> , nous n'aurons <b>ni connexion sans fil</b> (plus de détails plus tard), <b>ni accès Internet</b> (voir ci-dessous). <br><br><h2>  Acheminement </h2><br>  À ce stade, vous devez router les paquets entre les <code>enp2s0</code> LAN ( <code>enp2s0</code> ) et WAN ( <code>enp1s0</code> ) et activer la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">traduction des adresses réseau</a> . <br><br>  L'activation du transfert de paquets est simple: <br><br><pre> <code class="bash hljs">$ sudo sysctl -w net.ipv4.ip_forward=1 $ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"net.ipv4.ip_forward=1"</span></span> | sudo tee -a /etc/sysctl.conf</code> </pre> <br>  <i>La dernière commande garantit que la configuration est enregistrée jusqu'au prochain redémarrage.</i> <br><br>  La traduction d'adresses réseau est une autre affaire, vous devez généralement vous occuper (ou plutôt combattre) les <code>iptables</code> .  Heureusement, l'âge de pierre est révolu depuis longtemps, et les gars de FireHol ont mis beaucoup d'efforts pour ajouter le niveau d'abstraction nécessaire: <br><br><pre> <code class="bash hljs">$ sudo apt-get install firehol</code> </pre> <br>  FireHOL est un langage de pare-feu sécurisé de pointe, sa configuration est facile à comprendre et accessible.  Vous n'avez plus besoin d'écrire des instructions <code>iptables</code> : le fichier de configuration lui-même est traduit en instructions <code>iptables</code> et appliqué selon les besoins.  Aucun démon en arrière-plan. <br><br>  L'activation de la traduction des adresses réseau pour les interfaces LAN avec l'ajout de règles de pare-feu minimales se fait de manière élémentaire: <br><br><pre> <code class="bash hljs">$ cat /etc/firehol/firehol.conf version 6 <span class="hljs-comment"><span class="hljs-comment"># Accept all client traffic on WAN interface enp1s0 wan client all accept # Accept all traffic on LAN interface br0 lan server all accept client all accept # Route packets between LAN and WAN router lan2wan inface br0 outface enp1s0 masquerade route all accept</span></span></code> </pre> <br>  <i>FireHOL est écrit par des gens pour des gens, la documentation est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> .</i> <br><br>  Vous pouvez vérifier les paramètres en démarrant manuellement <code>firehol</code> ( <code>sudo firehol start</code> ) et en connectant l'ordinateur portable au port LAN: <b>vous pouvez maintenant vous</b> connecter si le port WAN est connecté. <br><br>  Avant de redémarrer, <b>assurez-vous de</b> modifier <code>/etc/default/firehol</code> pour permettre à FireHol de démarrer au démarrage: <br><br><pre> <code class="bash hljs">$ sudo sed -i -E <span class="hljs-string"><span class="hljs-string">"s/^START_FIREHOL=.+$/START_FIREHOL=YES/g"</span></span> /etc/default/firehol</code> </pre> <br>  <i>Je n'entrerai pas dans les détails de l'ensemble de la syntaxe <code>firehol</code> , le fichier de configuration s'explique, je recommande de se <code>firehol</code> à la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation</a> en cas de configuration plus complexe.</i>  <i>Si vous êtes vraiment intéressé par ce que <code>firehol</code> fait avec <code>iptables</code> , tapez simplement <code>sudo firehol status</code> sur la ligne de commande.</i> <br><br><h2>  Point d'accès sans fil </h2><br>  Évidemment, nous allons gérer le point d'accès en utilisant <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">hostapd</a> : <br><br><pre> <code class="bash hljs">$ sudo apt-get install hostapd</code> </pre> <br>  Vous trouverez ci-dessous un fichier de configuration 802.11 n / 2,4 Ghz / WPA2-AES minimal et presque inexpliqué: <br><br><pre> <code class="bash hljs">$ cat /etc/hostapd/hostapd-simple.conf <span class="hljs-comment"><span class="hljs-comment">#### Interface configuration #### interface=wlp5s0 bridge=br0 driver=nl80211 ##### IEEE 802.11 related configuration ##### ssid=iCanHearYouHavingSex hw_mode=g channel=1 auth_algs=1 wmm_enabled=1 ##### IEEE 802.11n related configuration ##### ieee80211n=1 ##### WPA/IEEE 802.11i configuration ##### wpa=2 wpa_key_mgmt=WPA-PSK rsn_pairwise=CCMP wpa_passphrase=YouCantGuess</span></span></code> </pre> <br>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Voir</a> <code>hostpad.conf</code> documentation sur <code>/usr/share/doc/hostapd/examples/hostapd.conf</code></i> . <br><br>  La configuration décrite peut être testée manuellement: <br><br><pre> <code class="bash hljs">$ sudo hostapd /etc/hostapd/hostapd-simple.conf</code> </pre> <br>  Si tout se passe bien, une <b>connexion sans fil apparaîtra</b> .  Si vous êtes satisfait du résultat, <b>n'oubliez pas</b> de changer la configuration pour démarrer <code>hostapd</code> dès que l'interface se lève (comme illustré ci-dessous). <br><br>  <b>Voici votre <code>/etc/network/interfaces:</code> final <code>/etc/network/interfaces:</code></b> <br><br><pre> <code class="bash hljs">$ cat /etc/network/interfaces <span class="hljs-comment"><span class="hljs-comment"># Loopback auto lo iface lo inet loopback # WAN interface auto enp1s0 iface enp1s0 inet dhcp # Bridge (LAN) auto br0 iface br0 inet static address 192.168.1.1 network 192.168.1.0 netmask 255.255.255.0 broadcast 192.168.1.255 bridge_ports enp2s0 post-up /usr/sbin/hostapd \ -P /var/run/hostapd.$IFACE.pid \ -B /etc/hostapd/hostapd-simple.conf post-up /usr/sbin/dnsmasq \ --pid-file=/var/run/dnsmasq.$IFACE.pid \ --dhcp-leasefile=/var/lib/misc/dnsmasq.$IFACE.leases \ --conf-file=/dev/null \ --interface=$IFACE --except-interface=lo \ --bind-interfaces \ --dhcp-range=192.168.1.10,192.168.1.150,24h pre-down cat /var/run/dnsmasq.$IFACE.pid | xargs kill pre-down cat /var/run/hostapd.$IFACE.pid | xargs kill</span></span></code> </pre> <br><a name="3"></a><h1>  Configuration d'un point d'accès 802.11ac (5 GHz) </h1><br><h2>  Balayage passif </h2><br>  Selon la documentation <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Airetos AEX-QCA9880-NX</a> , le chipset prend en charge 802.11ac, afin que nous puissions laisser les canaux bondés de 2,4 GHz au paradis 5 GHz. <br><br>  Voyons quelles fréquences sont prises en charge: <br><br><pre> <code class="plaintext hljs">$ iw list ... Frequencies: * 2412 MHz [1] (20.0 dBm) * 2417 MHz [2] (20.0 dBm) * 2422 MHz [3] (20.0 dBm) * 2427 MHz [4] (20.0 dBm) * 2432 MHz [5] (20.0 dBm) * 2437 MHz [6] (20.0 dBm) * 2442 MHz [7] (20.0 dBm) * 2447 MHz [8] (20.0 dBm) * 2452 MHz [9] (20.0 dBm) * 2457 MHz [10] (20.0 dBm) * 2462 MHz [11] (20.0 dBm) * 2467 MHz [12] (disabled) * 2472 MHz [13] (disabled) * 2484 MHz [14] (disabled) ... Frequencies: * 5180 MHz [36] (17.0 dBm) (no IR) * 5200 MHz [40] (17.0 dBm) (no IR) * 5220 MHz [44] (17.0 dBm) (no IR) * 5240 MHz [48] (17.0 dBm) (no IR) * 5260 MHz [52] (23.0 dBm) (no IR, radar detection) * 5280 MHz [56] (23.0 dBm) (no IR, radar detection) * 5300 MHz [60] (23.0 dBm) (no IR, radar detection) * 5320 MHz [64] (23.0 dBm) (no IR, radar detection) * 5500 MHz [100] (23.0 dBm) (no IR, radar detection) * 5520 MHz [104] (23.0 dBm) (no IR, radar detection) * 5540 MHz [108] (23.0 dBm) (no IR, radar detection) * 5560 MHz [112] (23.0 dBm) (no IR, radar detection) * 5580 MHz [116] (23.0 dBm) (no IR, radar detection) * 5600 MHz [120] (23.0 dBm) (no IR, radar detection) * 5620 MHz [124] (23.0 dBm) (no IR, radar detection) * 5640 MHz [128] (23.0 dBm) (no IR, radar detection) * 5660 MHz [132] (23.0 dBm) (no IR, radar detection) * 5680 MHz [136] (23.0 dBm) (no IR, radar detection) * 5700 MHz [140] (23.0 dBm) (no IR, radar detection) * 5720 MHz [144] (23.0 dBm) (no IR, radar detection) * 5745 MHz [149] (30.0 dBm) (no IR) * 5765 MHz [153] (30.0 dBm) (no IR) * 5785 MHz [157] (30.0 dBm) (no IR) * 5805 MHz [161] (30.0 dBm) (no IR) * 5825 MHz [165] (30.0 dBm) (no IR) ...</code> </pre> <br>  Dans la liste ci-dessus, nous voyons que le chipset prend en charge les canaux 1-14 (2,4 GHz) et les canaux 36-165 (5 GHz), mais avez-vous remarqué l'indicateur <code>no IR</code> ? <br><br>  Le drapeau <code>no IR</code> indique <i>un rayonnement sans déclenchement</i> (c'est <i>-à-</i> dire <i>un balayage passif</i> ).  Cela signifie que ce mode est interdit dans le cas où l'appareil est le premier à initier un rayonnement (y compris les <b>balises</b> ).  En d'autres termes, <b>vous ne pouvez pas exécuter le point d'accès sur ces canaux</b> ! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/03f/743/e75/03f743e7505714ae9864dcce2b5b4964.gif"></div><br><br><h2>  Exigences réglementaires </h2><br>  La situation ci-dessus s'explique par les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">exigences réglementaires de Linux</a> , qui réglementent l'utilisation du spectre des fréquences radio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">selon les pays</a> . <br><br>  Mais bon! <br><br>  J'habite aux États-Unis, et le lien indique que j'ai le droit d'initier un rayonnement sur les canaux 36-48, alors quel est le problème?  Voyons quel domaine réglementaire est actuellement utilisé: <br><br><pre> <code class="plaintext hljs">$ iw reg get country 00: DFS-UNSET (2402 - 2472 @ 40), (N/A, 20), (N/A) (2457 - 2482 @ 40), (N/A, 20), (N/A), NO-IR (2474 - 2494 @ 20), (N/A, 20), (N/A), NO-OFDM, NO-IR (5170 - 5250 @ 80), (N/A, 20), (N/A), NO-IR (5250 - 5330 @ 80), (N/A, 20), (0 ms), DFS, NO-IR (5490 - 5730 @ 160), (N/A, 20), (0 ms), DFS, NO-IR (5735 - 5835 @ 80), (N/A, 20), (N/A), NO-IR (57240 - 63720 @ 2160), (N/A, 0), (N/A)</code> </pre> <br>  Le problème montre que le domaine <i>mondial</i> est actuellement actif (ou non installé), c'est-à-dire les <b>valeurs minimales autorisées dans chaque pays</b> . <br><br>  Malheureusement, vous ne pouvez pas installer manuellement le domaine <code>sudo iw reg set</code> , car le domaine est protégé dans l'EEPROM: <br><br><pre> <code class="plaintext hljs">$ dmesg | grep EEPROM [ 12.123068] ath: EEPROM regdomain: 0x6c</code> </pre> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5de/5a9/ae2/5de5a9ae216cf2c3f2f9416b4ffa54bc.gif"></div><br><h2>  Patch! </h2><br>  Heureusement, les exigences réglementaires sont traitées au niveau du pilote, elles peuvent donc être facilement modifiées: nous trouvons le correctif dans le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">code source Open-WRT</a> . <br><br>  Tout d'abord, n'oubliez pas de connecter le référentiel de code source depuis <code>/etc/apt/sources.list</code> : <br><br><pre> <code class="bash hljs">$ cat /etc/apt/sources.list ... deb-src http://us.archive.ubuntu.com/ubuntu/ bionic main restricted ...</code> </pre> <br>  Préparez ensuite l'environnement en installant les dépendances nécessaires: <br><br><pre> <code class="bash hljs">$ sudo apt-get install build-essential fakeroot $ sudo apt-get build-dep linux</code> </pre> <br>  Téléchargez vos sources du noyau: <br><br><pre> <code class="bash hljs">$ apt-get <span class="hljs-built_in"><span class="hljs-built_in">source</span></span> linux</code> </pre> <br>  Étant donné que le correctif Open-WRT d'origine ne peut pas être appliqué «tel quel» à l'arborescence du noyau Ubuntu en raison de différences subtiles dans le système de génération, j'ai dû le corriger: <br><br><pre> <code class="bash hljs">$ VERSION=$(uname -r) $ <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> linux-<span class="hljs-variable"><span class="hljs-variable">${VERSION%%-*}</span></span> $ wget -O - https://gist.github.com/renaudcerrato/02de8b2e8dc013bc71326defd2ef062c/raw/a2db325e520e6442c8c12f7599d64ac1b7596a3e/402-ath_regd_optional.patch | patch -p1 -b</code> </pre> <br>  Tout est prêt pour l'assemblage: <br><br><pre> <code class="bash hljs">$ fakeroot debian/rules clean $ fakeroot debian/rules binary-generic</code> </pre> <br>  S'il n'y a pas de problème, vous pouvez maintenant installer le noyau fixe par dessus le précédent: <br><br><pre> <code class="bash hljs">$ <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> .. $ sudo dpkg -i linux*.deb</code> </pre> <br>  Redémarrez et le tour est joué: <br><br><pre> <code class="bash hljs">$ sudo iw reg <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> US $ iw list ... Frequencies: * 5180 MHz [36] (17.0 dBm) * 5200 MHz [40] (17.0 dBm) * 5220 MHz [44] (17.0 dBm) * 5240 MHz [48] (17.0 dBm) * 5260 MHz [52] (23.0 dBm) (radar detection) * 5280 MHz [56] (23.0 dBm) (radar detection) * 5300 MHz [60] (23.0 dBm) (radar detection) * 5320 MHz [64] (23.0 dBm) (radar detection) * 5500 MHz [100] (23.0 dBm) (radar detection) * 5520 MHz [104] (23.0 dBm) (radar detection) * 5540 MHz [108] (23.0 dBm) (radar detection) * 5560 MHz [112] (23.0 dBm) (radar detection) * 5580 MHz [116] (23.0 dBm) (radar detection) * 5600 MHz [120] (23.0 dBm) (radar detection) * 5620 MHz [124] (23.0 dBm) (radar detection) * 5640 MHz [128] (23.0 dBm) (radar detection) * 5660 MHz [132] (23.0 dBm) (radar detection) * 5680 MHz [136] (23.0 dBm) (radar detection) * 5700 MHz [140] (23.0 dBm) (radar detection) * 5720 MHz [144] (23.0 dBm) (radar detection) * 5745 MHz [149] (30.0 dBm) * 5765 MHz [153] (30.0 dBm) * 5785 MHz [157] (30.0 dBm) * 5805 MHz [161] (30.0 dBm) * 5825 MHz [165] (30.0 dBm) ...</code> </pre> <br>  <i>Pour éviter les mises à jour automatiques, vous devrez peut-être <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">corriger la version du noyau Linux</a> .</i> <br><br><h2>  La configuration </h2><br>  Le nouveau <code>hostapd</code> configuration <code>hostapd</code> sera assez simple: <code>hw_mode=a</code> comprend des bandes de 5 GHz et <code>ieee80211ac=1</code> inclut 802.11ac (VHT).  L'option <code>ieee80211d=1</code> avec <code>country_code=US</code> spécifie le domaine réglementaire sous lequel nous opérons. <br><br>  Pour tirer le meilleur parti de la bande passante, <code>ht_capab</code> et <code>vht_capab</code> doivent refléter les capacités de l'équipement: <br><br><pre> <code class="bash hljs">$ iw list ... Band 1: Capabilities: 0x19e3 RX LDPC HT20/HT40 Static SM Power Save RX HT20 SGI RX HT40 SGI TX STBC RX STBC 1-stream Max AMSDU length: 7935 bytes DSSS/CCK HT40 ... Band 2: VHT Capabilities (0x338001b2): Max MPDU length: 11454 Supported Channel Width: neither 160 nor 80+80 RX LDPC short GI (80 MHz) TX STBC RX antenna pattern consistency TX antenna pattern consistency</code> </pre> <br>  Dans cet esprit, <b>voici le</b> <code>hostapd.conf</code> <b>final</b> : <br><br><pre> <code class="bash hljs">$ cat /etc/hostapd/hostapd.conf <span class="hljs-comment"><span class="hljs-comment">#### Interface configuration #### interface=wlp5s0 bridge=br0 driver=nl80211 ##### IEEE 802.11 related configuration ##### ssid=iCanHearYouHavingSex hw_mode=a channel=0 auth_algs=1 wmm_enabled=1 country_code=US ieee80211d=1 ieee80211h=0 ##### IEEE 802.11n related configuration ##### ieee80211n=1 ht_capab=[HT40+][SHORT-GI-20][SHORT-GI-40][TX-STBC][RX-STBC1][DSSS_CK-40][LDPC][MAX-AMSDU-7935] ##### IEEE 802.11ac related configuration ##### ieee80211ac=1 vht_capab=[MAX-MPDU-11454][RXLDPC][SHORT-GI-80][TX-STBC-2BY1][RX-STBC-1][MAX-A-MPDU-LEN-EXP7][TX-ANTENNA-PATTERN][RX-ANTENNA-PATTERN] vht_oper_chwidth=1 ##### WPA/IEEE 802.11i configuration ##### wpa=2 wpa_key_mgmt=WPA-PSK rsn_pairwise=CCMP wpa_passphrase=YouCantGuess</span></span></code> </pre> <br>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Voir</a> <code>hostpad.conf</code> documentation sur <code>/usr/share/doc/hostapd/examples/hostapd.conf</code></i> . <br><br>  À ce stade, le routeur sans fil est pleinement opérationnel, et si vous avez besoin d'une configuration plus complexe, vous pouvez maintenant plonger dans les fichiers de configuration. <br><br><a name="4"></a><h1>  Configuration d'un SSID virtuel à l'aide de hostapd </h1><br>  Que vous souhaitiez configurer un point d'accès invité ou un réseau sans fil dédié pour votre VPN, vous devrez à un moment donné configurer un SSID virtuel. <br><br><h2>  Graphique </h2><br>  Basé sur la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">configuration actuelle</a> , voici un diagramme mis à jour de ce que nous voulons obtenir.  En supposant que <code>wlp5s0</code> est l'interface sans fil physique, le SSID virtuel s'exécutera sur l'interface virtuelle <code>wlan0</code> utilisant son propre sous-réseau <code>192.168.2.0/24</code> : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/096/450/32b/09645032b28e7310ad93b2109efb0860.png"><br><br><h2>  La préparation </h2><br>  Tout d'abord, vérifiez que votre appareil sans fil prend en charge plusieurs SSID: <br><br><pre> <code class="bash hljs">$ iw list ... valid interface combinations: * <span class="hljs-comment"><span class="hljs-comment">#{ AP, mesh point } &lt;= 8, total &lt;= 8, #channels &lt;= 1, STA/AP BI must match ...</span></span></code> </pre> <br>  Comme vous pouvez le voir, le chipset prend en charge jusqu'à huit points d'accès sur un canal.  Cela signifie que vous pouvez configurer jusqu'à sept SSID virtuels, et tous fonctionneront sur un canal. <br><br><h2>  Interface réseau </h2><br>  Selon la documentation dans hostapd.conf, il existe une connexion stricte entre l'adresse MAC de l'interface physique et le BSSID des interfaces virtuelles: <br><br><blockquote>  hostapd générera un masque BSSID basé sur les BSSID configurés.  <b>hostapd vérifiera que dev_addr &amp; MASK == dev_addr</b> .  Si ce n'est pas le cas, l'adresse MAC de la radio doit être modifiée avant de démarrer hostapd.  Si un BSSID est configuré pour chaque BSS secondaire, cette limitation n'est pas appliquée à hostapd et d'autres masques peuvent être utilisés si le pilote les prend en charge (par exemple, permuter le bit administré localement) <br><br>  Les BSSID sont attribués dans l'ordre à chaque BSS, sauf si un BSSID explicite est spécifié à l'aide du paramètre «bssid». <br><br>  Si un BSSID explicite est spécifié, il doit être choisi de telle sorte qu'il: <br>  - résulte en un MASQUE valide qui le couvre et le dev_addr <br>  - n'est pas la même que l'adresse MAC de la radio <br>  - n'est pas le même que tout autre BSSID explicitement spécifié </blockquote><br>  Pour répondre à ces exigences et permettre à <code>hostapd</code> attribuer automatiquement le BSSID de la ou des interfaces virtuelles, nous mettons à jour l'adresse MAC de l'interface sans fil physique en remettant à zéro les quatre bits les moins significatifs.  Cela suffit pour 15 BSSID virtuels - bien plus que nécessaire. <br><br>  Tout d'abord, déterminez l'adresse MAC actuelle: <br><br><pre> <code class="bash hljs">$ ip addr show wlp5s0 | grep link | awk <span class="hljs-string"><span class="hljs-string">'{print $2}'</span></span> 44:c3:06:00:03:eb</code> </pre> <br>  Si vous effacez les quatre derniers bits et définissez le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">bit U / L</a> , vous obtenez l'adresse MAC <code>46:c3:06:00:03:e0</code> . <br><br>  Nous allons maintenant mettre à jour la configuration pour définir la bonne adresse MAC juste avant de charger l'interface, et déclarer également une interface sans fil virtuelle conformément à notre diagramme: <br><br><pre> <code class="bash hljs">$ cat /etc/network/interfaces ... <span class="hljs-comment"><span class="hljs-comment"># Physical Wireless auto wlp5s0 iface wlp5s0 inet manual pre-up ip link set dev wlp5s0 address 46:c3:06:00:03:e0 # Virtual Wireless allow-hotplug wlan0 iface wlan0 inet static address 192.168.2.1 network 192.168.2.0 netmask 255.255.255.0 broadcast 192.168.2.255 post-up /usr/sbin/dnsmasq \ --pid-file=/var/run/dnsmasq-wlan0.pid \ --conf-file=/dev/null \ --interface=wlan0 --except-interface=lo \ --bind-interfaces \ --dhcp-range=192.168.2.10,192.168.2.150,24h post-down cat /var/run/dnsmasq-wlan0.pid | xargs kill ...</span></span></code> </pre> <br>  Super.  J'utilise <code>dnsmasq</code> comme serveur DHCP - n'hésitez pas à le remplacer par ce que vous voulez.  Veuillez noter que pour que l'interface virtuelle fonctionne correctement, <code>allow-hotplug</code> est requis. <br><br><h2>  Configuration du point d'accès </h2><br>  Maintenant, la chose la plus simple: ajoutez un SSID virtuel à la configuration actuelle de <code>hostapd</code> .  Ajoutez simplement ceci <b>à la fin du</b> fichier <code>hostapd.conf</code> existant: <br><br><pre> <code class="bash hljs">$ cat /etc/hostapd/hostapd.conf ... <span class="hljs-comment"><span class="hljs-comment">### Virtual SSID(s) ### bss=wlan0 ssid=MyVirtualSSID wpa=2 wpa_key_mgmt=WPA-PSK rsn_pairwise=CCMP wpa_passphrase=you_cant_guess</span></span></code> </pre> <br>  Dans l'exemple, j'ai utilisé le cryptage WPA2, mais la plupart des options d'interface radio sont disponibles ici (par exemple, <code>channel</code> ).  Vous pouvez ajouter plus de SSID virtuels en ajoutant simplement les lignes dans le fichier de configuration en fonction des interfaces virtuelles déclarées et correctement configurées. <br><br>  Redémarrez maintenant - et voyez votre nouveau SSID avec la nouvelle interface sans fil (faites attention à l'adresse MAC): <br><br><pre> <code class="bash hljs">$ ip addr show wlan0 | grep link | awk <span class="hljs-string"><span class="hljs-string">'{print $2}'</span></span> 46:c3:06:00:03:e1</code> </pre> <br>  <b>C'est ça les gars!</b> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr437634/">https://habr.com/ru/post/fr437634/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr437622/index.html">Prise en main du service Azure Machine Learning</a></li>
<li><a href="../fr437624/index.html">OpenSceneGraph: principes de base des textures</a></li>
<li><a href="../fr437626/index.html">Performances de la plateforme de trading avec un exemple simple</a></li>
<li><a href="../fr437630/index.html">Les principales annonces de Microsoft de la conférence BETT</a></li>
<li><a href="../fr437632/index.html">Mash, les bases de la langue</a></li>
<li><a href="../fr437636/index.html">Publication de l'application sur le Microsoft Store: quelques changements pour l'année</a></li>
<li><a href="../fr437638/index.html">"Quel est le point de réponse?" Non-réviseur Atmotube et soudure</a></li>
<li><a href="../fr437640/index.html">Comment les marques peuvent franchir la bulle des médias technologiques</a></li>
<li><a href="../fr437642/index.html">Si les fenêtres s'ouvrent, alors quelqu'un en a besoin</a></li>
<li><a href="../fr437646/index.html">Choses utiles et non évidentes pour une imprimante 3D: petites choses pour une imprimante 3D</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>