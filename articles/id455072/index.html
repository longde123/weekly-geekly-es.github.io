<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üõ∞Ô∏è üö© üßïüèª Seluruh kebenaran tentang RTOS. Artikel # 28. Pengatur waktu perangkat lunak ‚ò¢Ô∏è üåÑ ‚öúÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ide pengatur waktu perangkat lunak diperkenalkan pada artikel sebelumnya . Mereka adalah objek kernel yang menyediakan tugas dengan cara sederhana unt...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Seluruh kebenaran tentang RTOS. Artikel # 28. Pengatur waktu perangkat lunak</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455072/">  Ide pengatur waktu perangkat lunak diperkenalkan pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel sebelumnya</a> .  Mereka adalah objek kernel yang menyediakan tugas dengan cara sederhana untuk memicu peristiwa tepat waktu, atau, paling sering, cara untuk melakukan tindakan secara teratur.  Semua detail fungsionalitas terkait waktu (presisi, penanganan interupsi, dll.) Di Nucleus SE dibahas dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel sebelumnya</a> . <br><br><img src="https://habrastorage.org/webt/xu/5v/_s/xu5v_sdm50mq9i1ywof_lgsvqkw.jpeg"><br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Artikel sebelumnya dalam seri:</b> <div class="spoiler_text"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 27.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Waktu sistem</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 26.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Saluran: layanan tambahan dan struktur data</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 25.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Saluran Data: Pengantar dan Layanan Dasar</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 24.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Antrian: layanan tambahan dan struktur data</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 23.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Antrian: pengantar dan layanan dasar</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 22.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kotak Surat: Layanan Tambahan dan Struktur Data</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 21.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kotak Surat: Pengantar dan Layanan Dasar</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 20.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Semaphores: Layanan Tambahan dan Struktur Data</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 19.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Semaphores: pengantar dan layanan dasar</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 18.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Grup Bendera Acara: Layanan Pembantu dan Struktur Data</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 17.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Grup Bendera Acara: Pengantar dan Layanan Dasar</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 16.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sinyal</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 15.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Partisi Memori: Layanan dan Struktur Data</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 14.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian memori: pengantar dan layanan dasar</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 13.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Struktur data tugas dan panggilan API yang tidak didukung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 12.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Layanan untuk bekerja dengan tugas</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 11.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tugas: konfigurasi dan pengantar API</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 10.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Penjadwal: fitur canggih dan pelestarian konteks</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 9.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Penjadwal: implementasi</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 8.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Nucleus SE: Desain dan Penyebaran Internal</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 7.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Nucleus SE: Pendahuluan</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Layanan RTOS lainnya</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Interaksi tugas dan sinkronisasi</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tugas, pengalihan konteks, dan interupsi</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tugas dan Perencanaan</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RTOS: Struktur dan mode waktu-nyata</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><br></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RTOS: pengantar.</a> <br></div></div><br><h2>  Menggunakan pengatur waktu </h2><br>  Timer program dapat dikonfigurasi untuk memicu sekali, yaitu, mereka mulai, dan kemudian, setelah periode waktu tertentu, cukup mengakhiri siklus.  Atau penghitung waktu dapat dikonfigurasi untuk memulai kembali: setelah penghitungan selesai, penghitung waktu akan dimulai kembali secara otomatis.  Waktu pengoperasian setelah restart mungkin berbeda dari waktu pengoperasian awal.  Selain itu, timer dapat secara opsional dikonfigurasi untuk melakukan fungsi terminasi khusus, yang dijalankan ketika (atau setiap kali) timer menyelesaikan siklus kerja. <br><br><h2>  Pengaturan Timer </h2><br><h3>  Jumlah pengatur waktu </h3><br>  Seperti kebanyakan aspek Nucleus SE, pengaturan pengatur waktu dikontrol oleh arahan <b>#define</b> di <b>nuse_config.h</b> .  Parameter utama adalah <b>NUSE_TIMER_NUMBER</b> , yang menentukan timer yang dikonfigurasi dalam aplikasi.  Secara default, nilai ini adalah nol (yaitu, timer tidak digunakan dalam aplikasi), dan dapat mengambil nilai hingga 16. Nilai yang salah akan menyebabkan kesalahan kompilasi, yang akan dihasilkan dengan memeriksa file <b>nuse_config_check.h</b> (file ini termasuk dalam <b>nuse_config.c</b> dan kompilasi bersama dengan itu), yang akan memicu arahan <b>#error</b> . <br><br>  Memilih nilai bukan nol adalah aktivator timer utama.  Parameter ini digunakan ketika mendefinisikan struktur data, dan ukurannya tergantung pada nilainya.  Selain itu, nilai bukan nol mengaktifkan pengaturan API. <br><br><h3>  Aktivasi fungsi penyelesaian </h3><br>  Di Nucleus SE, saya mencoba mencari peluang untuk membuat fungsionalitas opsional, di mana itu akan menghemat memori.  Contoh yang baik adalah dukungan untuk fungsi penyelesaian waktu.  Selain fakta bahwa fitur ini adalah opsional untuk setiap timer, mekanisme dapat diaktifkan (atau tidak) untuk seluruh aplikasi menggunakan <b>NUSE_TIMER_EXPIRATION_ROUTINE_SUPPORT</b> parameter di <b>nuse_config.h</b> .  Mengatur parameter ini ke <b>FALSE</b> memblokir definisi dua struktur data dalam ROM, yang akan dijelaskan secara rinci dalam artikel ini. <br><br><h3>  Aktivasi API </h3><br>  Setiap fungsi API (panggilan utilitas) di Nucleus SE memiliki #define directive directive di nuse_config.h.  Untuk penghitung waktu, simbol-simbol ini termasuk: <br>  <b>NUSE_TIMER_CONTROL</b> <b><br></b>  <b>NUSE_TIMER_GET_REMAINING</b> <b><br></b>  <b>NUSE_TIMER_RESET</b> <b><br></b>  <b>NUSE_TIMER_INFORMATION</b> <b><br></b>  <b>NUSE_TIMER_COUNT</b> <br><br>  Secara default, semua aktivator diatur ke <b>FALSE</b> , sehingga semua panggilan layanan dinonaktifkan, memblokir masuknya kode yang mengimplementasikannya.  Untuk mengatur penghitung waktu dalam aplikasi, Anda harus memilih panggilan layanan API yang diperlukan dan mengaturnya ke <b>TRUE</b> . <br><br>  Berikut ini adalah potongan kode dari file <b>nuse_config.h</b> default. <br><br><pre><code class="plaintext hljs">#define NUSE_TIMER_NUMBER 0/*      0-16 */ /*    */ #define NUSE_TIMER_CONTROL FALSE #define NUSE_TIMER_GET_REMAINING FALSE #define NUSE_TIMER_RESET FALSE #define NUSE_TIMER_INFORMATION FALSE #define NUSE_TIMER_COUNT FALSE</code> </pre> <br>  Jika fungsi API yang terkait dengan waktu diaktifkan dan tidak ada timer yang dikonfigurasi dalam aplikasi (kecuali untuk fungsi <b>NUSE_Timer_Count ()</b> , yang selalu diaktifkan), kesalahan kompilasi akan terjadi.  Jika kode Anda menggunakan panggilan API yang belum diaktifkan, kesalahan tata letak akan terjadi karena kode implementasi tidak termasuk dalam aplikasi. <br><br><h2>  Panggilan Layanan Timer </h2><br>  Nucleus RTOS mendukung delapan panggilan utilitas terkait timer yang menyediakan fungsionalitas berikut: <br><br><ul><li>  Timer manajemen (mulai / berhenti).  Nucleus SE diimplementasikan dalam fungsi <b>NUSE_Timer_Control ()</b> . </li><li>  Mengambil sisa waktu penghitung waktu.  Di Nucleus SE, diterapkan di <b>NUSE_Timer_Get_Remaining ()</b> . </li><li>  Mengembalikan timer ke keadaan semula (reset).  Nucleus SE diimplementasikan di <b>NUSE_Timer_Reset ()</b> . </li><li>  Memberikan informasi tentang penghitung waktu tertentu.  Nucleus SE diimplementasikan dalam <b>NUSE_Timer_Information ()</b> . </li><li>  Mengembalikan jumlah pengatur waktu yang dikonfigurasikan (saat ini) dalam aplikasi.  Nucleus SE diimplementasikan di <b>NUSE_Timer_Count ()</b> . </li><li>  Menambahkan timer baru ke aplikasi (pembuatan).  Nucleus SE tidak diimplementasikan. </li><li>  Menghapus timer dari aplikasi.  Nucleus SE tidak diimplementasikan. </li><li>  Mengembalikan pointer ke semua penghitung waktu dalam aplikasi.  Nucleus SE tidak diimplementasikan. </li></ul><br>  Implementasi setiap panggilan layanan akan dibahas secara rinci di bawah ini. <br><br><h2>  Layanan Timer </h2><br>  Operasi mendasar yang dapat dilakukan dengan timer adalah kontrol (mulai dan berhenti) dan pembacaan nilai saat ini.  Nucleus RTOS dan Nucleus SE menyediakan dua panggilan utilitas API dasar untuk operasi ini. <br><br><h3>  Kontrol pengatur waktu </h3><br>  Panggilan utilitas ke Nucleus RTOS API untuk mengontrol timer memungkinkan Anda untuk mengaktifkan dan menonaktifkan timer (memulai dan menghentikan).  Nucleus SE menyediakan fungsi serupa. <br><br>  <b><i>Timer Control Challenge di Nucleus RTOS</i></b> <br>  Prototipe panggilan layanan: <br><br>  <b>STATUS NU_Control_Timer (NU_TIMER * timer, OPTION aktifkan);</b> <br><br>  Parameter: <br>  <b>timer</b> - penunjuk ke blok kontrol timer yang disediakan oleh pengguna; <br>  <b>aktifkan</b> adalah fungsi yang diperlukan; bisa mengambil nilai <b>NU_ENABLE_TIMER</b> atau <b>NU_DISABLE_TIMER</b> . <br><br>  Nilai pengembalian: <br>  <b>NU_SUCCESS</b> - panggilan berhasil diselesaikan; <br>  <b>NU_INAVLID_TIMER</b> - penunjuk waktu tidak valid; <br>  <b>NU_INAVLID_ENABLE</b> - fungsi tidak valid. <br><br>  <b><i>Timer Control Challenge di Nucleus SE</i></b> <br>  Panggilan API ini mendukung fungsionalitas penuh dari Nucleus RTOS API. <br><br>  Prototipe panggilan layanan: <br>  <b>STATUS NUSE_Timer_Control (timer NUSE_TIMER, OPTION aktifkan);</b> <br><br>  Parameter: <br>  <b>timer</b> - index (ID) dari timer yang digunakan; <br>  <b>aktifkan</b> adalah fungsi yang diperlukan; bisa mengambil nilai <b>NUSE_ENABLE_TIMER</b> atau <b>NUSE_DISABLE_TIMER</b> . <br><br>  Nilai pengembalian: <br>  <b>NUSE_SUCCESS</b> - panggilan berhasil diselesaikan; <br>  <b>NUSE_INCALID_TIMER</b> - indeks timer tidak valid; <br>  <b>NUSE_INVALID_ENABLE</b> adalah fungsi yang tidak valid. <br><br>  <b><i>Menerapkan Manajemen Timer di Nucleus SE</i></b> <br>  Kode fungsi API <b>NUSE_Timer_Control ()</b> (setelah memeriksa parameter) cukup sederhana: <br><br><pre> <code class="plaintext hljs">NUSE_CS_Enter(); if (enable == NUSE_ENABLE_TIMER) { NUSE_Timer_Status[timer] = TRUE; if (NUSE_Timer_Expirations_Counter[timer] == 0) { NUSE_Timer_Value[timer] = NUSE_Timer_Initial_Time[timer]; } else { NUSE_Timer_Value[timer] = NUSE_Timer_Reschedule_Time[timer]; } } else /* enable == NUSE_DISABLE_TIMER */ { NUSE_Timer_Status[timer] = FALSE; } NUSE_CS_Exit();</code> </pre><br>  Jika fungsi <b>NUSE_DISABLE_TIMER</b> ditentukan, status timer ( <b>NUSE_Timer_Status []</b> parameter) diatur ke <b>FALSE</b> , yang mengabaikan timer oleh pengendali interrupt. <br><br>  Saat memilih fungsi <b>NUSE_ENABLE_TIMER,</b> penghitung waktu ( <b>NUSE_Timer_Value []</b> ) diatur ke <b>NUSE_Timer_initial_Time []</b> , dengan ketentuan bahwa penghitung waktu tidak pernah berhenti sejak reset terakhir.  Kalau tidak, itu akan diberi nilai <b>NUSE_Timer_Reschedule_Time []</b> .  Kemudian status timer (parameter <b>NUSE_Timer_Status []</b> ) diatur ke <b>TRUE</b> , yang menyebabkan timer diproses oleh interrupt handler. <br><br><h3>  Pembacaan waktu </h3><br>  Untuk mendapatkan sisa waktu, panggilan layanan Nucleus RTOS API mengembalikan jumlah tindakan hingga kedaluwarsa.  Nucleus SE menyediakan fungsi serupa. <br><br>  <b><i>Panggil untuk mendapatkan waktu yang tersisa di Nucleus RTOS</i></b> <br><br>  Prototipe panggilan layanan: <br>  <b>STATUS NU_Get_Remaining_Time (NU_TIMER * penghitung waktu, TIDAK DITANDATANGANKAN * sisa_waktu);</b> <br><br>  Parameter: <br>  <b>timer</b> - penunjuk ke blok kontrol timer yang disediakan oleh pengguna; <br>  <b>Sisa_time</b> - pointer ke penyimpanan nilai waktu yang tersisa, yang merupakan variabel dari tipe <b>TANDA TANGAN</b> . <br><br>  Nilai pengembalian <br>  <b>NU_SUCCESS</b> - panggilan berhasil diselesaikan; <br>  <b>NU_INVALID_TIMER</b> - penunjuk waktu tidak valid. <br><br>  <b><i>Panggil untuk mendapatkan sisa waktu di Nucleus SE</i></b> <br>  Panggilan API ini mendukung fungsionalitas penuh dari Nucleus RTOS API. <br><br>  Prototipe panggilan layanan: <br>  <b>STATUS NUSE_Timer_Get_Remaining (timer NUSE_TIMER, U16 * tersisa_waktu);</b> <br><br>  Parameter: <br>  <b>timer</b> - index (ID) dari timer yang digunakan; <br>  <b>Sisa_time</b> - pointer ke penyimpanan nilai waktu yang tersisa, yang merupakan variabel tipe <b>U16</b> . <br><br>  Nilai pengembalian: <br>  <b>NUSE_SUCCESS</b> - panggilan berhasil diselesaikan; <br>  <b>NUSE_INVALID_TIMER</b> - indeks timer tidak valid; <br>  <b>NUSE_INVALID_POINTER</b> - null pointer ke sisa waktu ( <b>NULL</b> ). <br><br>  <b><i>Menerapkan Pembaca Waktu dalam Nucleus SE</i></b> <br>  Varian kode fungsi API <b>NUSE_Timer_Get_Remaining ()</b> (setelah memeriksa parameter) sepele.  Nilai <b>NUSE_Timer_Value []</b> diperoleh dan kemudian dikembalikan di bagian kritis. <br><br><h2>  Layanan Pengatur Waktu Tambahan </h2><br>  Nucleus RTOS memiliki empat panggilan API yang menyediakan fungsi tambahan yang terkait dengan penghitung waktu: mengatur ulang penghitung waktu, mendapatkan informasi penghitung waktu, mendapatkan jumlah penghitung waktu dalam suatu aplikasi, dan mendapatkan petunjuk ke semua penghitung waktu dalam suatu aplikasi.  Tiga fungsi pertama diimplementasikan dalam Nucleus SE. <br><br><h3>  Atur ulang timer </h3><br>  Panggilan API ini mengatur ulang timer ke kondisi aslinya, yang tidak digunakan.  Penghitung waktu dapat diaktifkan atau dinonaktifkan setelah panggilan berakhir.  Ini hanya dapat digunakan setelah timer dinonaktifkan (menggunakan <b>NUSE_Timer_Control ()</b> ).  Kali berikutnya penghitung waktu diaktifkan, akan diinisialisasi dengan parameter <b>NUSE_Timer_Initial_Time []</b> .  Nucleus RTOS memungkinkan Anda memberikan keadaan awal dan menjadwal ulang waktu baru, serta menentukan fungsi penyelesaian saat timer diatur ulang.  Dalam Nucleus SE, nilai-nilai ini diatur selama pengaturan dan tidak dapat diubah karena disimpan dalam ROM. <br><br>  <b><i>Panggilan untuk mengatur ulang timer di Nucleus RTOS</i></b> <br><br>  Prototipe panggilan layanan: <br>  <b>STATUS NU_Reset_Timer (NU_TIMER * penghitung waktu, VOID (* expiration_routine) (TIDAK DITANDATANGANI), inisialisasi TANDA, waktu tunda dijadwalkan, TANDA aktifkan ulang jadwal, aktifkan OPSI);</b> <br><br>  Parameter: <br>  <b>timer</b> - pointer ke timer yang dapat direset; <br>  <b>expiration_routine</b> - menunjukkan fungsi yang akan dieksekusi ketika loop berakhir; <br>  <b>initial_time</b> - jumlah awal pengingat waktu sampai loop berakhir; <br>  <b>reschedule_time</b> - jumlah penghitung waktu <b>berdetak</b> hingga siklus kedua dan selanjutnya selesai; <br>  <b>aktifkan</b> - kondisi waktu yang diperlukan setelah reset, dapat mengambil nilai <b>NU_ENABLE_TIMER</b> atau <b>NU_DISABLE_TIMER</b> . <br><br>  Nilai pengembalian: <br>  <b>NU_SUCCESS</b> - panggilan berhasil diselesaikan; <br>  <b>NU_INVALID_TIMER</b> - pointer tidak valid ke unit kontrol timer; <br>  <b>NU_INVALID_FUNCTION</b> - null pointer ke fungsi penyelesaian ( <b>NULL</b> ); <br>  <b>NU_INVALID_ENABLE</b> - negara yang ditentukan salah; <br>  <b>NU_NOT_DISABLED</b> - timer sudah berjalan (harus dihentikan sebelum memanggil fungsi ini). <br><br>  <b><i>Panggil untuk mengatur ulang timer di Nucleus SE</i></b> <br>  Panggilan layanan API ini mendukung versi sederhana dari fungsionalitas inti API Nucleus RTOS. <br><br>  Prototipe panggilan layanan: <br>  <b>STATUS NUSE_Timer_Reset (timer NUSE_TIMER, OPTION aktifkan);</b> <br><br>  Parameter: <br>  <b>timer</b> - index (ID) dari timer reset; <br>  <b>aktifkan</b> - kondisi yang diperlukan setelah diatur ulang, dapat mengambil nilai <b>NUSE_ENABLE_TIMER</b> atau <b>NUSE_DISABLE_TIMER</b> . <br><br>  Nilai pengembalian: <br>  <b>NUSE_SUCCESS</b> - panggilan berhasil diselesaikan; <br>  <b>NUSE_INVALID_TIMER</b> - indeks timer tidak valid; <br>  <b>NUSE_INVALID_ENABLE</b> - negara yang ditentukan salah; <br>  <b>NUSE_NOT_DISABLED</b> - timer sudah berjalan (harus dihentikan sebelum memanggil fungsi ini). <br><br>  <b><i>Menerapkan pengaturan ulang timer pada Nucleus SE</i></b> <br>  Versi kode fungsi API <b>NUSE_Timer_Reset ()</b> (setelah memeriksa parameter dan status saat ini) cukup sederhana: <br><br><pre> <code class="plaintext hljs">NUSE_CS_Enter(); NUSE_Init_Timer(timer); if (enable == NUSE_ENABLE_TIMER) { NUSE_Timer_Status[timer] = TRUE; } /*  enable == NUSE_DISABLE_TIMER    FALSE */ NUSE_CS_Exit();</code> </pre><br>  Panggilan ke <b>NUSE_Init_Timer ()</b> menginisialisasi nilai waktu dan menghapus penghitung penyelesaian.  Setelah itu, jika perlu, nilai status yang diperlukan diperiksa dan apakah timer menyala. <br><br><h3>  Informasi Pengatur Waktu </h3><br>  Panggilan layanan ini memungkinkan Anda untuk mendapatkan satu set informasi pengatur waktu.  Implementasi Nucleus SE berbeda dari Nucleus RTOS dalam hal ia mengembalikan lebih sedikit informasi karena penamaan objek tidak didukung. <br><br>  <b><i>Panggil untuk informasi pengatur waktu di Nucleus RTOS</i></b> <br><br>  Prototipe panggilan layanan: <br>  <b>STATUS NU_Timer_Information (NU_TIMER * timer, CHAR * nama, OPTION * aktifkan, tidak kedaluwarsa * expirations, UNSIGNED * id, UNSIGNED * initial_time, UNSIGNED * reschedule_time);</b> <br><br>  Parameter: <br>  <b>timer</b> - pointer ke timer tentang informasi mana yang diminta; <br>  <b>name</b> - pointer ke wilayah 8 karakter untuk nama timer; <br>  <b>aktifkan</b> - arahkan ke variabel yang mengambil status aktifator pengatur waktu: <b>NU_ENABLE_TIMER</b> atau <b>NU_DISABLE_TIMER</b> ; <br>  <b>kedaluwarsa</b> - pointer ke variabel yang menghitung jumlah penyelesaian siklus waktu sejak reset terakhir; <br>  pointer - <b>id</b> ke variabel yang mengambil nilai parameter yang diteruskan ke fungsi akhir siklus timer; <br>  <b>initial_time</b> - sebuah pointer ke variabel yang mengambil nilai di mana timer akan diinisialisasi setelah reset; <br>  <b>reschedule_time</b> - sebuah pointer ke variabel yang mengambil nilai di mana timer akan diinisialisasi setelah selesai. <br><br>  Nilai pengembalian: <br>  <b>NU_SUCCESS</b> - panggilan berhasil diselesaikan; <br>  <b>NU_INVALID_TIMER</b> - penunjuk waktu tidak valid. <br><br>  <b><i>Panggil untuk informasi timer di Nucleus SE</i></b> <br>  Panggilan API ini mendukung fungsionalitas inti API Nucleus RTOS. <br><br>  Prototipe panggilan layanan: <br>  <b>STATUS NUSE_Timer_Information (timer NUSE_TIMER, OPTION * aktifkan, U8 * kedaluwarsa, U8 * id, U16 * initial_time, U16 * reschedule_time);</b> <br><br>  Parameter: <br>  <b>timer</b> - indeks timer tentang informasi yang diminta; <br>  <b>aktifkan</b> - pointer ke variabel yang mengambil nilai <b>TRUE</b> atau <b>FALSE</b> , tergantung pada apakah timer diaktifkan atau tidak; <br>  <b>expirations</b> - pointer ke variabel tipe <b>U8</b> yang mengambil nilai jumlah penyelesaian timer sejak reset terakhir; <br>  pointer - <b>id</b> ke variabel tipe <b>U8</b> yang mengambil nilai parameter yang diteruskan ke fungsi penyelesaian waktu (akan mengembalikan nilai kosong jika fungsi penyelesaian dinonaktifkan); <br>  <b>initial_time</b> - pointer ke variabel tipe <b>U16</b> yang mengambil nilai dengan mana timer akan diinisialisasi setelah reset; <br>  <b>reschedule_time</b> - pointer ke variabel tipe <b>U16</b> , yang mengambil nilai dengan mana timer akan diinisialisasi setelah selesai. <br><br>  Nilai pengembalian: <br>  <b>NUSE_SUCCESS</b> - panggilan berhasil diselesaikan; <br>  <b>NUSE_INVALID_TIMER</b> - indeks timer tidak valid; <br>  <b>NUSE_INVALID_POINTER</b> - satu atau beberapa parameter pointer salah. <br><br>  <b><i>Menerapkan informasi pengatur waktu di Nucleus SE</i></b> <br>  Menerapkan panggilan API ini cukup sederhana: <br><br><pre> <code class="plaintext hljs">NUSE_CS_Enter(); if (NUSE_Timer_Status[timer]) { *enable = NUSE_ENABLE_TIMER; } else { *enable = NUSE_DISABLE_TIMER; } *expirations = NUSE_Timer_Expirations_Counter[timer]; #if NUSE_TIMER_EXPIRATION_ROUTINE_SUPPORT *id = NUSE_Timer_Expiration_Routine_Parameter[timer]; #endif *initial_time = NUSE_Timer_Initial_Time[timer]; *reschedule_time = NUSE_Timer_Reschedule_Time[timer]; NUSE_CS_Exit();</code> </pre><br>  Fungsi mengembalikan status timer.  Nilai parameter dari fungsi terminasi dikembalikan hanya jika dukungannya telah diaktifkan dalam aplikasi. <br><br><h3>  Mendapatkan jumlah timer </h3><br>  Panggilan utilitas ini mengembalikan jumlah pengatur waktu yang dikonfigurasi dalam aplikasi.  Dalam Nucleus RTOS, nilai ini dapat berubah seiring waktu, dan nilai kembali akan menampilkan jumlah pengatur waktu saat ini.  Dalam Nucleus SE, nilai kembali diatur selama fase perakitan dan tidak dapat diubah. <br><br>  <b><i>Panggil penghitung waktu di Nucleus RTOS</i></b> <br><br>  Prototipe panggilan layanan: <br>  <b>NU_Established_Timers (VOID) TIDAK DITANDATANGANI;</b> <br><br>  Parameter: tidak ada <br><br>  Nilai kembali: jumlah penghitung waktu yang dibuat dalam sistem. <br><br>  <b><i>Memanggil Penghitung Waktu di Nucleus SE</i></b> <br>  Panggilan API ini mendukung fungsionalitas inti API Nucleus RTOS. <br><br>  Prototipe panggilan layanan: <br>  <b>U8 NUSE_Timer_Count (batal);</b> <br><br>  Parameter: tidak ada <br><br>  Nilai pengembalian: <br>  jumlah penghitung waktu yang dikonfigurasi dalam aplikasi <br><br><h3>  Implementasi Penghitung Waktu </h3><br>  Implementasi panggilan API ini cukup sederhana: nilai simbol #define <b>NUSE_TIMER_NUMBER dikembalikan</b> . <br><br><h2>  Struktur data </h2><br>  Pengatur waktu menggunakan lima atau tujuh struktur data (terletak di RAM atau ROM) yang (seperti objek Nucleus SE lainnya) adalah seperangkat tabel yang ukuran dan jumlahnya sesuai dengan jumlah pengatur waktu yang dikonfigurasi dan parameter yang dipilih. <br><br>  Saya sangat merekomendasikan bahwa kode aplikasi tidak menggunakan akses langsung ke struktur data ini, tetapi merujuknya melalui fungsi API yang disediakan.  Ini akan menghindari ketidakcocokan dengan versi Nucleus SE dan efek samping yang tidak diinginkan di masa depan, serta menyederhanakan aplikasi porting ke Nucleus RTOS.  Berikut ini adalah ikhtisar terperinci dari struktur untuk menyederhanakan pemahaman panggilan layanan dan kode debugging. <br><br><h3>  Data RAM </h3><br>  Data ini memiliki struktur sebagai berikut: <br>  <b>NUSE_Timer_Status []</b> adalah larik tipe <b>U8</b> yang memiliki satu entri untuk setiap timer yang dikonfigurasi dan menyimpan status timer (berjalan atau berhenti: <b>BENAR</b> atau <b>SALAH</b> ). <br>  <b>NUSE_Timer_Value []</b> adalah larik tipe <b>U16</b> yang memiliki satu entri untuk setiap penghitung waktu yang dikonfigurasi dan menyimpan nilai penghitung waktu penghitung saat ini. <br>  <b>NUSE_Timer_Expirations_Counter []</b> - larik tipe <b>U8</b> , berisi penghitung jumlah kasus ketika penghitung waktu mencapai akhir siklus sejak reset terakhir mereka. <br><br>  Semua struktur data ini diinisialisasi oleh fungsi <b>NUSE_Init_Timer ()</b> ketika Nucleus SE dimulai.  Salah satu artikel berikut akan berisi deskripsi lengkap tentang prosedur startup untuk Nucleus SE. <br><br>  Berikut ini adalah definisi dari struktur data ini dalam file <b>nuse_init.c</b> : <br>  <b>RAM U8 Timer_Status [NUSE_TIMER_NUMBER];</b> <b><br></b>  <b>RAM U16 NUSE_Timer_Value [NUSE_TIMER_NUMBER];</b> <b><br></b>  <b>RAM U8 NUSE_Timer_Expirations_Counter [NUSE_TIMER_NUMBER];</b> <br><br><h3>  Data ROM </h3><br>  Struktur data ini: <br>  <b>NUSE_Timer_Initial_Time []</b> adalah larik tipe <b>U16</b> yang memiliki satu entri untuk setiap timer yang dikonfigurasi dan menyimpan nilai setiap timer. <br>  <b>NUSE_Timer_Reschedule_Time []</b> - larik tipe <b>U16</b> yang memiliki satu entri untuk setiap timer yang dikonfigurasi dan menyimpan nilai di mana timer akan ditetapkan setelah selesai.  Nilai nol menunjukkan bahwa timer adalah "satu kali" dan tidak boleh dimulai ulang secara otomatis. <br>  <b>NUSE_Timer_Expiration_Routine_Address []</b> - larik jenis <b>ADDR yang</b> berisi alamat prosedur kedaluwarsa timer.  Array ini hanya ada jika dukungan untuk prosedur kedaluwarsa timer telah diaktifkan. <br>  <b>NUSE_Timer_Expiration_Routine_Parameter []</b> - larik tipe <b>U8 yang</b> berisi nilai parameter yang diteruskan ke fungsi penyelesaian waktu.  Array ini hanya ada jika dukungan untuk fungsi penyelesaian telah diaktifkan. <br><br>  Struktur data ini dideklarasikan dan diinisialisasi (secara statis) dalam file <b>nuse_config.c</b> , dengan demikian: <br><br><pre> <code class="plaintext hljs">ROM U16 NUSE_Timer_Initial_Time[NUSE_TIMER_NUMBER] = { /*   ------ */ }; ROM U16 NUSE_Timer_Reschedule_Time[NUSE_TIMER_NUMBER] = { /*      ------ */ }; #if NUSE_TIMER_EXPIRATION_ROUTINE_SUPPORT || NUSE_INCLUDE_EVERYTHING /*    */ ROM ADDR NUSE_Timer_Expiration_Routine_Address[NUSE_TIMER_NUMBER] = { /*     ------ */ /*   NULL */ }; ROM U8 NUSE_Timer_Expiration_Routine_Parameter[NUSE_TIMER_NUMBER] = { /*     ------ */ }; #endif</code> </pre><br><h3>  Jumlah memori untuk penghitung waktu </h3><br>  Seperti semua objek Nucleus SE lainnya, jumlah data yang diperlukan untuk penghitung waktu dapat diprediksi. <br><br>  Jumlah data dalam RAM (dalam byte) untuk semua penghitung waktu dalam aplikasi dapat dihitung sebagai berikut: <br>  <b>NUSE_TIMER_NUMBER * 4</b> <br><br>  Jumlah data dalam ROM (dalam byte) untuk semua penghitung waktu dalam aplikasi, jika dukungan untuk fungsi penyelesaian dinonaktifkan, dapat dihitung sebagai berikut: <br>  <b>NUSE_TIMER_NUMBER * 4</b> <br><br>  Kalau tidak, itu sama dengan: <br>  <b>NUSE_TIMER_NUMBER * (sizeof (ADDR) + 5)</b> <br><br><h2>  Panggilan API yang belum direalisasi </h2><br>  Nucleus SE tidak mengimplementasikan tiga panggilan API yang dapat ditemukan di RTOS. <br><br><h3>  Pembuatan timer </h3><br>  Panggilan API ini menciptakan timer.  Nucleus SE tidak membutuhkannya, karena penghitung waktu dibuat secara statis. <br><br>  Prototipe panggilan layanan: <br>  <b>STATUS NU_Create_Timer (NU_TIMER * penghitung waktu, CHAR * nama, VOID (* expiration_routine) (TANDA TANGAN), id TANDA TANGAN, awal_TANDANGAN tANDA, ttg penjadwalan ulang yang TANDA TANGAN, OPTION aktifkan);</b> <br><br>  Parameter: <br>  <b>timer</b> - penunjuk ke blok kontrol timer yang disediakan oleh pengguna;  itu akan digunakan untuk mengontrol timer di panggilan API lainnya; <br>  <b>name</b> - pointer ke nama 7-karakter timer dengan nol penghentian; <br>  <b>expiration_routine</b> - menunjukkan fungsi yang harus dijalankan setelah penghitung waktu berakhir; <br>  <b>id</b> - elemen data tipe <b>UNSIGNED yang</b> diteruskan ke fungsi terminasi: parameter ini dapat digunakan untuk mengidentifikasi timer dengan fungsi terminasi yang sama; <br>  <b>initial_time</b> - menunjukkan jumlah awal kutu sebelum timer berakhir; <br>  <b>reschedule_time</b> - menunjukkan jumlah <b>kutu</b> waktu sampai siklus kedua dan selanjutnya selesai;  jika parameter ini sama dengan nol, penghitung waktu berhenti hanya sekali; <br>  <b>aktifkan</b> - parameter ini dapat mengambil nilai <b>NU_ENABLE_TIMER</b> dan <b>NU_DISABLE_TIMER</b> ;  <b>NU_ENABLE_TIMER</b> mengaktifkan timer setelah itu dibuat;  <b>NU_DISABLE_TIMER</b> membiarkan timer dinonaktifkan;  pengatur waktu yang dibuat dengan parameter <b>NU_DISABLE_TIMER</b> harus diaktifkan dengan memanggil <b>NU_Control_Timer</b> . <br><br>  Nilai pengembalian: <br>  <b>NU_SUCCESS</b> - panggilan berhasil diselesaikan; <br>  <b>NU_INVALID_TIMER</b> - penunjuk nol ke unit kontrol penghitung waktu ( <b>NULL</b> ), atau unit kontrol sudah digunakan; <br>  <b>NU_INVALID_FUNCTION</b> - null pointer ke program penyelesaian ( <b>NULL</b> ); <br>  <b>NU_INVALID_ENABLE</b> - parameter <b>aktifkan</b> tidak valid; <br>  <b>NU_INVALID_OPERATION</b> - parameter <b>initial_time</b> adalah nol. <br><br><h3>  Hapus timer </h3><br>  Panggilan API ini menghapus timer yang dibuat sebelumnya.  Nucleus SE tidak membutuhkannya, karena penghitung waktu dibuat secara statis dan tidak dapat dihapus. <br><br>  Prototipe panggilan layanan: <br>  <b>STATUS NU_Delete_Timer (NU_TIMER * timer);</b> <br><br>  Parameter: <br>  <b>timer</b> - penunjuk ke blok kontrol timer. <br><br>  Nilai pengembalian: <br>  <b>NU_SUCCESS</b> - panggilan berhasil diselesaikan; <br>  <b>NU_INVALID_TIMER</b> - penunjuk waktu tidak valid; <br>  <b>NU_NOT_DISABLED</b> - Timer yang ditentukan tidak dinonaktifkan. <br><br><h3>  Timer Pointer </h3><br>  Panggilan API ini membentuk daftar petunjuk berurutan untuk semua penghitung waktu dalam sistem.  Nucleus SE tidak membutuhkannya, karena penghitung waktu ditentukan oleh indeks sederhana, bukan penunjuk. <br><br>  Prototipe panggilan layanan: <br>  <b>NU_Timer_Pointers TIDAK DITANDATANGANI (NU_TIMER ** pointer_list, maksimum_pointers UNSIGNED);</b> <br><br>  Parameter: <br>  <b>pointer_list</b> - pointer ke array pointer <b>NU_TIMER</b> ;  itu akan diisi dengan pointer ke timer yang dikonfigurasi dalam sistem; <br>  <b>maximum_pointers</b> - jumlah maksimum pointer dalam array. <br><br>  Nilai pengembalian: <br>  Jumlah pointer <b>NU_TIMER</b> ditempatkan di dalam array. <br><br><h2>  Kompatibel dengan RTOS Inti </h2><br>  Seperti semua objek Nucleus SE lainnya, tujuan saya adalah untuk memaksimalkan kompatibilitas kode aplikasi dengan Nucleus RTOS.  Pengatur waktu tidak terkecuali dan, dari sudut pandang pengguna, mereka diimplementasikan dengan cara yang sama seperti pada Nucleus RTOS.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ada juga ketidakcocokan tertentu, yang saya anggap dapat diterima, mengingat bahwa sebagai hasilnya, kode akan menjadi lebih mudah dimengerti dan lebih efisien dalam hal jumlah memori yang diperlukan. </font><font style="vertical-align: inherit;">Jika tidak, panggilan Nucleus RTOS API dapat langsung diangkut ke Nucleus SE.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pengidentifikasi Objek </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam Nucleus RTOS, semua objek dijelaskan oleh struktur data - blok kontrol yang memiliki tipe data tertentu. Penunjuk ke unit kontrol ini adalah pengidentifikasi waktu. Saya memutuskan bahwa dalam Nucleus SE, diperlukan pendekatan yang berbeda untuk penggunaan memori yang efisien: semua objek kernel dijelaskan oleh seperangkat tabel dalam RAM dan / atau ROM. Ukuran tabel ini ditentukan oleh jumlah objek yang dikonfigurasi dari setiap jenis. Pengidentifikasi objek tertentu adalah indeks dalam tabel ini. Jadi saya mendefinisikan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NUSE_TIMER</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sebagai setara dengan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">U8</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, variabel (bukan pointer) dari tipe ini berfungsi sebagai pengidentifikasi timer. </font><font style="vertical-align: inherit;">Ketidakcocokan sedikit ini mudah ditangani jika kode porting dari Nucleus SE ke Nucleus RTOS dan sebaliknya. </font><font style="vertical-align: inherit;">Biasanya, tidak ada operasi yang dilakukan pada pengidentifikasi objek selain memindahkan dan menyimpan. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nucleus RTOS juga mendukung timer penamaan. </font><font style="vertical-align: inherit;">Nama-nama ini hanya digunakan untuk debugging. </font><font style="vertical-align: inherit;">Saya mengecualikan mereka dari Nucleus SE untuk menghemat memori.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ukuran pengatur waktu </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam Nucleus RTOS, timer diimplementasikan menggunakan penghitung 32-bit. </font><font style="vertical-align: inherit;">Saya memutuskan untuk mengurangi nilai ini menjadi 16 bit di Nucleus SE. </font><font style="vertical-align: inherit;">Ini telah menyebabkan peningkatan yang signifikan dalam efisiensi dan runtime memori. </font><font style="vertical-align: inherit;">Nucleus SE dapat dimodifikasi jika aplikasi membutuhkan waktu yang lebih lama.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fungsi penyelesaian </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nucleus SE mengimplementasikan fungsi terminasi dengan cara yang mirip dengan Nucleus RTOS, hanya saja mereka dapat dimatikan sepenuhnya (yang memungkinkan Anda menghemat memori), dan mereka juga ditentukan secara statis. </font><font style="vertical-align: inherit;">Fungsi akhir tidak dapat diubah ketika timer diatur ulang.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Panggilan API yang belum direalisasi </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nucleus RTOS mendukung delapan panggilan layanan pewaktu. </font><font style="vertical-align: inherit;">Dari jumlah tersebut, tiga tidak diimplementasikan dalam Nucleus SE. </font><font style="vertical-align: inherit;">Penjelasan terperinci tentang panggilan ini, serta alasan keputusan ini, dapat ditemukan sebelumnya dalam artikel ini, di bagian "Panggilan API yang Tidak Direalisasi". </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Artikel berikut akan memeriksa interupsi.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id455072/">https://habr.com/ru/post/id455072/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id455060/index.html">Homer atau opensource pertama. bagian 1</a></li>
<li><a href="../id455062/index.html">Kasus percobaan yang sukses (dan tidak demikian) dari Yandex.Navigator</a></li>
<li><a href="../id455064/index.html">Bakat vs. Keberuntungan: Peran Kesempatan dalam Kesuksesan dan Kegagalan</a></li>
<li><a href="../id455066/index.html">Analisis Sistem MeetUp UPD2 Siaran dan Presentasi</a></li>
<li><a href="../id455068/index.html">Kebijakan Nol Bug. Tidak ada bug - tidak ada masalah?</a></li>
<li><a href="../id455076/index.html">GameDev TDD atau Kelinci Neraka</a></li>
<li><a href="../id455078/index.html">Tempat berbicara tentang Apache Ignite dan sistem terdistribusi di musim panas</a></li>
<li><a href="../id455082/index.html">Kami mempelajari MITER ATT & CK. Matriks Seluler: Akses Perangkat. Bagian 4</a></li>
<li><a href="../id455088/index.html">Apa wawancara dan tes item tes</a></li>
<li><a href="../id455094/index.html">Cara melindungi 5G di kota pintar: terapkan arsitektur keamanan baru</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>