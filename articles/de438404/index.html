<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêô üõÄ ‚èπÔ∏è Kompositionspreis in der Javascript-Welt üöø üíÖüèΩ üé¥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die Idee, dass bei der Entwicklung einer mehr oder weniger komplexen Gesch√§ftslogik der Zusammensetzung von Objekten Vorrang vor der Vererbung einger√§...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kompositionspreis in der Javascript-Welt</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438404/"> Die Idee, dass bei der Entwicklung einer mehr oder weniger komplexen Gesch√§ftslogik der Zusammensetzung von Objekten Vorrang vor der Vererbung einger√§umt werden sollte, ist bei Softwareentwicklern verschiedener Typen beliebt.  Bei der n√§chsten Welle der Popularit√§t des funktionalen Programmierparadigmas, das durch den Erfolg von ReactJS ausgel√∂st wurde, wurde das Gespr√§ch √ºber die Vorteile kompositorischer L√∂sungen in den Vordergrund ger√ºckt.  In diesem Beitrag gibt es ein kleines Layout in den Regalen der Theorie der Komposition von Objekten in Javascript, ein spezifisches Beispiel, seine Analyse und die Antwort auf die Frage, wie viel semantische Eleganz den Benutzer kostet (Spoiler: viel). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f30/874/502/f308745025666d09822337569aad1b1c.jpg" alt="V. Kandinsky - Zusammensetzung X."><br>  <i>Vasily Kandinsky - "Zusammensetzung X"</i> <br><a name="habracut"></a><br>  Die jahrelange erfolgreiche Entwicklung eines objektorientierten Entwicklungsansatzes, haupts√§chlich im akademischen Bereich, hat zu einem sp√ºrbaren Ungleichgewicht im Kopf eines durchschnittlichen Entwicklers gef√ºhrt.  In den meisten F√§llen besteht der erste Gedanke, falls erforderlich, um ein Verhalten f√ºr eine Reihe verschiedener Entit√§ten zu verallgemeinern, darin, eine √ºbergeordnete Klasse zu erstellen und dieses Verhalten zu erben.  Dieser Missbrauchsansatz f√ºhrt zu mehreren Problemen, die das Design erschweren und die Entwicklung behindern. <br><br>  Erstens wird die mit Logik √ºberladene Basisklasse <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zerbrechlich</a> - eine kleine √Ñnderung ihrer Methoden kann abgeleitete Klassen t√∂dlich beeinflussen.  Eine M√∂glichkeit, diese Situation zu umgehen, besteht darin, die Logik auf mehrere Klassen zu verteilen und eine komplexere Vererbungshierarchie zu erstellen.  In diesem Fall tritt beim Entwickler ein weiteres Problem auf: Die Logik der √ºbergeordneten Klassen wird bei Bedarf in den Erben dupliziert, wenn sich die Funktionalit√§t der √ºbergeordneten Klassen √ºberschneidet, aber vor allem nicht vollst√§ndig ist. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/fc2/3fa/4ac/fc23fa4ac64d720585bded474be46303.png" alt="Bild"></a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">mail.mozilla.org/pipermail/es-discuss/2013-June/031614.html</a> <br><br>  Um eine ziemlich tiefe Hierarchie zu erstellen, muss der Benutzer bei Verwendung einer Entit√§t alle seine Vorfahren zusammen mit all ihren Abh√§ngigkeiten ziehen, unabh√§ngig davon, ob er ihre Funktionalit√§t verwenden wird oder nicht.  Dieses Problem der √ºberm√§√üigen Abh√§ngigkeit von der Umwelt mit einer leichten Hand von Joe Armstrong, dem Sch√∂pfer von Erlang, wurde das Problem des Gorillas und der Banane genannt: <br><br><blockquote>  Ich denke, der Mangel an Wiederverwendbarkeit liegt in objektorientierten Sprachen, nicht in funktionalen Sprachen.  Weil das Problem mit objektorientierten Sprachen darin besteht, dass sie all diese implizite Umgebung haben, die sie mit sich herumtragen.  Sie wollten eine Banane, aber Sie bekamen einen Gorilla, der die Banane und den gesamten Dschungel hielt. </blockquote><br>  Die Zusammensetzung von Objekten ist erforderlich, um all diese Probleme als Alternative zur Klassenvererbung zu l√∂sen.  Die Idee ist √ºberhaupt nicht neu, findet aber unter Entwicklern kein vollst√§ndiges Verst√§ndnis.  Die Situation in der Front-End-Welt ist etwas besser, wo die Struktur von Softwareprojekten oft recht einfach ist und nicht zur Schaffung eines komplexen objektorientierten Beziehungsschemas f√ºhrt.  Das blinde Befolgen der B√ºndnisse der Viererbande, die Empfehlung, die Komposition der Vererbung vorzuziehen, kann jedoch auch der inspirierenden Weisheit der gro√üen Entwickler einen Streich spielen. <br><br>  Durch die √úbertragung von Definitionen aus ‚ÄûEntwurfsmustern‚Äú in die dynamische Welt von Javascript k√∂nnen drei Arten der Objektzusammensetzung zusammengefasst werden: <b>Aggregation</b> , <b>Verkettung</b> und <b>Delegierung</b> .  Es ist anzumerken, dass diese Trennung und das Konzept der Objektzusammensetzung im Allgemeinen rein technischer Natur sind, w√§hrend die Bedeutung dieser Begriffe √úberschneidungen aufweist, was zu Verwirrung f√ºhrt.  So wird beispielsweise die Klassenvererbung in Javascript auf der Basis der Delegierung implementiert (Prototypvererbung).  Daher ist es in jedem Fall besser, mit Live-Codebeispielen zu sichern. <br><br>  <b>Die Aggregation</b> ist eine aufz√§hlbare Vereinigung von Objekten, von denen jedes unter Verwendung einer eindeutigen Zugriffskennung erhalten werden kann.  Beispiele sind Arrays, B√§ume, Diagramme.  Ein gutes Beispiel aus der Welt der Webentwicklung ist der DOM-Baum.  Die Hauptqualit√§t dieser Art von Komposition und der Grund f√ºr ihre Erstellung ist die F√§higkeit, jedem Kind der Komposition bequem einen Handler zuzuweisen. <br><br>  Ein synthetisches Beispiel ist ein Array von Objekten, die abwechselnd einen Stil f√ºr ein beliebiges visuelles Element festlegen. <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> styles = [  { <span class="hljs-attr"><span class="hljs-attr">fontSize</span></span>: <span class="hljs-string"><span class="hljs-string">'12px'</span></span>, <span class="hljs-attr"><span class="hljs-attr">fontFamily</span></span>: <span class="hljs-string"><span class="hljs-string">'Arial'</span></span> },  { <span class="hljs-attr"><span class="hljs-attr">fontFamily</span></span>: <span class="hljs-string"><span class="hljs-string">'Verdana'</span></span>, <span class="hljs-attr"><span class="hljs-attr">fontStyle</span></span>: <span class="hljs-string"><span class="hljs-string">'italic'</span></span>, <span class="hljs-attr"><span class="hljs-attr">fontWeight</span></span>: <span class="hljs-string"><span class="hljs-string">'bold'</span></span> },  { <span class="hljs-attr"><span class="hljs-attr">fontFamily</span></span>: <span class="hljs-string"><span class="hljs-string">'Tahoma'</span></span>, <span class="hljs-attr"><span class="hljs-attr">fontStyle</span></span>: <span class="hljs-string"><span class="hljs-string">'normal'</span></span>} ];</code> </pre> <br>  Jedes der Stilobjekte kann ohne Informationsverlust durch seinen Index extrahiert werden.  Dar√ºber hinaus k√∂nnen Sie mit Array.prototype.map () alle gespeicherten Werte auf eine bestimmte Weise verarbeiten. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getFontFamily = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">s</span></span></span><span class="hljs-function"> =&gt;</span></span> s.fontFamily; styles.map(getFontFamily) <span class="hljs-comment"><span class="hljs-comment">//["Arial","Verdana","Tahoma"]</span></span></code> </pre> <br>  <b>Bei der Verkettung wird</b> die Funktionalit√§t eines vorhandenen Objekts durch Hinzuf√ºgen neuer Eigenschaften erweitert.  So arbeiten beispielsweise Zustandsreduzierer in Redux.  Die zur Aktualisierung empfangenen Daten werden in das Statusobjekt geschrieben und erweitert.  Im Gegensatz zur Aggregation gehen Daten zum aktuellen Status des Objekts verloren, wenn sie nicht gespeichert werden. <br><br>  Wenn Sie zum Beispiel zur√ºckkehren und die obigen Einstellungen abwechselnd auf das visuelle Element anwenden, k√∂nnen Sie das Endergebnis generieren, indem Sie die Parameter der Objekte verketten. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> concatenate = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, s</span></span></span><span class="hljs-function">) =&gt;</span></span> ({‚Ä¶a, ‚Ä¶s}); styles.reduce(concatenate, {}) <span class="hljs-comment"><span class="hljs-comment">//{fontSize:"12px",fontFamily:"Tahoma",fontStyle:"normal",fontWeight:"bold"}</span></span></code> </pre> <br>  Werte eines spezifischeren Stils √ºberschreiben m√∂glicherweise fr√ºhere Zust√§nde. <br><br>  Wie Sie sich vorstellen k√∂nnen, wird beim Delegieren ein Objekt an ein anderes delegiert.  Delegierte sind beispielsweise Prototypen in Javascript.  Instanzen abgeleiteter Objekte leiten Aufrufe an √ºbergeordnete Methoden um.  Wenn in der Array-Instanz keine erforderliche Eigenschaft oder Methode erforderlich ist, wird dieser Aufruf an Array.prototype und gegebenenfalls weiter an Object.prototype umgeleitet.  Daher basiert der Vererbungsmechanismus in Javascript auf der Prototyp-Delegierungskette, die technisch eine (√úberraschungs-) Version der Komposition ist. <br><br>  Das Kombinieren eines Arrays von Stilobjekten durch Delegierung kann wie folgt erfolgen. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> delegate = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.assign(<span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.create(a), b); styles.reduceRight(delegate, {}) <span class="hljs-comment"><span class="hljs-comment">//{"fontSize":"12px","fontFamily":"Arial"} styles.reduceRight(delegate, {}).fontWeight //bold</span></span></code> </pre> <br>  Wie Sie sehen, kann auf die Delegateigenschaften nicht durch Aufz√§hlung zugegriffen werden (z. B. mit Object.keys ()), sondern nur durch expliziten Zugriff.  Die Tatsache, dass dies uns gibt, ist am Ende des Beitrags. <br><br>  Nun zu den Einzelheiten.  Ein gutes Beispiel f√ºr einen Fall, der einen Entwickler dazu ermutigt, Komposition anstelle von Vererbung zu verwenden, ist Michael Rises <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Objektkomposition in Javascript</a> .  Hier betrachtet der Autor den Prozess der Erstellung einer Hierarchie von Rollenspielcharakteren.  Zun√§chst sind zwei Arten von Charakteren erforderlich - ein Krieger und ein Zauberer, von denen jeder eine bestimmte Gesundheitsreserve und einen Namen hat.  Diese Eigenschaften sind h√§ufig und k√∂nnen in die √ºbergeordnete Klasse Character verschoben werden. <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Character</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(name) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.health = <span class="hljs-number"><span class="hljs-number">100</span></span>; } }</code> </pre> <br>  Der Krieger zeichnet sich dadurch aus, dass er wei√ü, wie man schl√§gt, w√§hrend er seine Ausdauer verbraucht, und der Zauberer - die F√§higkeit, Zauber zu wirken und die Menge an Mana zu reduzieren. <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Fighter</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Character</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(name) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(name); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.stamina = <span class="hljs-number"><span class="hljs-number">100</span></span>; } fight() { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.name}</span></span></span><span class="hljs-string"> takes a mighty swing!`</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.stamina -  ; } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Mage</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Character</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(name) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(name); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.mana = <span class="hljs-number"><span class="hljs-number">100</span></span>; } cast() { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.name}</span></span></span><span class="hljs-string"> casts a fireball!`</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.mana -  ; } }</code> </pre> <br>  Nachdem der Entwickler die Klassen Fighter und Mage, die Nachkommen von Character, erstellt hat, steht er vor einem unerwarteten Problem, wenn die Paladin-Klasse erstellt werden muss.  Der neue Charakter zeichnet sich durch die beneidenswerte F√§higkeit aus, sowohl zu k√§mpfen als auch zu zaubern.  Auf Anhieb k√∂nnen Sie einige L√∂sungen sehen, die sich im gleichen Mangel an Anmut unterscheiden. <br><br><ol><li>  Sie k√∂nnen Paladin zu einem Nachkommen des Charakters machen und sowohl den Kampf () als auch den Zauber () von Grund auf neu implementieren.  In diesem Fall wird das DRY-Prinzip grob verletzt, da jede der Methoden w√§hrend der Erstellung dupliziert wird und anschlie√üend eine st√§ndige Synchronisation mit den Methoden der Klassen Mage und Fighter erforderlich ist, um √Ñnderungen zu verfolgen. </li><li>  Die Methoden Fight () und Cast () k√∂nnen auf der Ebene der Charater-Klasse implementiert werden, sodass alle drei Arten von Charakteren sie besitzen.  Dies ist eine etwas angenehmere L√∂sung. In diesem Fall muss der Entwickler jedoch die Fight () - Methode f√ºr den Magier und die Cast () - Methode f√ºr den Krieger neu definieren und durch leere Stubs ersetzen. </li></ol><br>  Bei jeder der Optionen muss man sich fr√ºher oder sp√§ter mit den Problemen der Vererbung auseinandersetzen, die zu Beginn des Beitrags ge√§u√üert wurden.  Sie k√∂nnen mit einem funktionalen Ansatz zur Implementierung von Zeichen gel√∂st werden.  Es reicht aus, sich nicht von ihren Typen, sondern von ihren Funktionen abzuwenden.  Unter dem Strich haben wir zwei Hauptmerkmale, die die F√§higkeit von Charakteren bestimmen - die F√§higkeit zu k√§mpfen und die F√§higkeit zu zaubern.  Diese Funktionen k√∂nnen mithilfe von Factory-Funktionen festgelegt werden, die den Status erweitern, der das Zeichen definiert (ein Beispiel f√ºr die Komposition ist die Verkettung). <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> canCast = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state</span></span></span><span class="hljs-function">) =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">cast</span></span>: <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">spell</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${state.name}</span></span></span><span class="hljs-string"> casts </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${spell}</span></span></span><span class="hljs-string">!`</span></span>); state.mana -  ; } }) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> canFight = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state</span></span></span><span class="hljs-function">) =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">fight</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${state.name}</span></span></span><span class="hljs-string"> slashes at the foe!`</span></span>); state.stamina -  ; } })</code> </pre> <br>  Somit wird der Charakter durch die Menge dieser Merkmale und die anf√§nglichen Eigenschaften bestimmt, sowohl allgemein (Name und Gesundheit) als auch privat (Ausdauer und Mana). <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fighter = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> state = { name, <span class="hljs-attr"><span class="hljs-attr">health</span></span>: <span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-attr"><span class="hljs-attr">stamina</span></span>: <span class="hljs-number"><span class="hljs-number">100</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.assign(state, canFight(state)); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mage = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> state = { name, <span class="hljs-attr"><span class="hljs-attr">health</span></span>: <span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-attr"><span class="hljs-attr">mana</span></span>: <span class="hljs-number"><span class="hljs-number">100</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.assign(state, canCast(state)); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> paladin = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> state = { name, <span class="hljs-attr"><span class="hljs-attr">health</span></span>: <span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-attr"><span class="hljs-attr">mana</span></span>: <span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-attr"><span class="hljs-attr">stamina</span></span>: <span class="hljs-number"><span class="hljs-number">100</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.assign(state, canCast(state), canFight(state)); }</code> </pre> <br>  Alles ist sch√∂n - der Aktionscode wird wiederverwendet, Sie k√∂nnen problemlos jeden neuen Charakter hinzuf√ºgen, ohne die vorherigen zu ber√ºhren und ohne die Funktionalit√§t eines Objekts zu erh√∂hen.  Um eine Fliege in der Salbe in der vorgeschlagenen L√∂sung zu finden, reicht es aus, die Leistung der L√∂sung basierend auf der Vererbung (Lesedelegation) und die L√∂sung basierend auf der Verkettung zu vergleichen.  Erstellen Sie eine millionste Armee von Instanzen der erstellten Charaktere. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> inheritanceArmy = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">1000000</span></span>; i++) { inheritanceArmy.push(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Fighter(<span class="hljs-string"><span class="hljs-string">'Fighter'</span></span> + i)); inheritanceArmy.push(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mage(<span class="hljs-string"><span class="hljs-string">'Mage'</span></span> + i)); } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> compositionArmy = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">1000000</span></span>; i++) { compositionArmy.push(fighter(<span class="hljs-string"><span class="hljs-string">'Fighter'</span></span> + i)); compositionArmy.push(mage(<span class="hljs-string"><span class="hljs-string">'Mage'</span></span> + i)); }</code> </pre> <br>  Vergleichen Sie die Speicher- und Rechenkosten zwischen Vererbung und Komposition, die zum Erstellen von Objekten erforderlich sind. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/158/509/b8f/158509b8fb1d5dc214b2728f72145565.png" alt="Bild"><br><br>  Im Durchschnitt erfordert eine L√∂sung, die eine Komposition durch Verkettung verwendet, 100‚Äì150% mehr Ressourcen.  Die dargestellten Ergebnisse wurden in einer NodeJS-Umgebung erhalten. Sie k√∂nnen die Ergebnisse f√ºr die Browser-Engine anzeigen, indem Sie diesen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://medium.com/r/%3Furl%3D">Test</a> ausf√ºhren. <br><br>  Der Vorteil der auf Vererbungsdelegierung basierenden L√∂sung kann durch Speichern von Speicher aufgrund des fehlenden impliziten Zugriffs auf die Delegateigenschaften sowie durch Deaktivieren einiger Engine-Optimierungen f√ºr dynamische Delegaten erkl√§rt werden.  Die verkettungsbasierte L√∂sung verwendet wiederum die sehr teure Object.assign () -Methode, die sich stark auf die Leistung auswirkt.  Interessanterweise zeigt Firefox Quantum diametral entgegengesetzte Chrom-Ergebnisse - die zweite L√∂sung arbeitet in Gecko viel schneller. <br><br>  Nat√ºrlich lohnt es sich, sich nur dann auf die Ergebnisse von Leistungstests zu verlassen, wenn Sie m√ºhsame Aufgaben im Zusammenhang mit der Erstellung einer gro√üen Anzahl von Objekten mit komplexer Infrastruktur l√∂sen - beispielsweise wenn Sie mit einem virtuellen Elementbaum arbeiten oder eine Grafikbibliothek entwickeln.  In den meisten F√§llen erweisen sich die strukturelle Sch√∂nheit einer L√∂sung, ihre Zuverl√§ssigkeit und Einfachheit als wichtiger, und ein kleiner Leistungsunterschied spielt keine gro√üe Rolle (Operationen mit DOM-Elementen beanspruchen viel mehr Ressourcen). <br><br>  Zusammenfassend ist anzumerken, dass die betrachteten Arten der Komposition nicht eindeutig sind und sich gegenseitig ausschlie√üen.  Die Delegierung kann mithilfe der Aggregation und die Klassenvererbung mithilfe der Delegierung implementiert werden (wie in JavaScript).  Im Kern wird jede Kombination von Objekten die eine oder andere Form der Zusammensetzung sein, und letztendlich ist nur die Einfachheit und Flexibilit√§t der resultierenden L√∂sung von Bedeutung. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de438404/">https://habr.com/ru/post/de438404/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de438394/index.html">Yii 2.0.16</a></li>
<li><a href="../de438396/index.html">Warum sollten Sie √ºber funktionale Programmierung nachdenken?</a></li>
<li><a href="../de438398/index.html">Wie ich Keras in C ++ gestartet habe</a></li>
<li><a href="../de438400/index.html">Israelische Wissenschaftler haben eine universelle Behandlung gegen Krebs entwickelt</a></li>
<li><a href="../de438402/index.html">Neutralinojs - was bist du? Oder UNIX Weg, wo Sie nicht gewartet haben</a></li>
<li><a href="../de438406/index.html">ReactJS + MobX - DI Erfahrung</a></li>
<li><a href="../de438408/index.html">Wolken und L√§nder: nationale Merkmale des Cloud-Marktes</a></li>
<li><a href="../de438412/index.html">Analyse von 112654 Testaufgaben und Trends auf dem Arbeitsmarkt von Programmierern im Jahr 2019</a></li>
<li><a href="../de438414/index.html">Fr√ºhlingszivilisation, 3/5</a></li>
<li><a href="../de438416/index.html">√úber Hormone</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>