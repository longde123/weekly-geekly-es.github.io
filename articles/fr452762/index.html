<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíÉüèΩ ü§£ üë©üèº‚Äçüè´ MVCC-7. Nettoyage auto üëäüèº ‚úãüèΩ üîô</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Permettez-moi de vous rappeler que nous avons commenc√© par des probl√®mes li√©s √† l' isolement , fait une digression sur l' organisation des donn√©es √† u...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MVCC-7. Nettoyage auto</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/452762/">  Permettez-moi de vous rappeler que nous avons commenc√© par des probl√®mes li√©s √† l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">isolement</a> , fait une digression sur l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">organisation des donn√©es √† un bas niveau</a> , parl√© en d√©tail des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">versions de ligne</a> et comment les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">instantan√©s</a> sont obtenus √† partir des versions. <br><br>  Ensuite, nous avons examin√© le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">nettoyage sur la page</a> (et les mises √† jour HOT), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le nettoyage r√©gulier</a> , mais aujourd'hui, nous examinons le nettoyage automatique. <br><br><h1>  Nettoyage automatique (autovacuum) </h1><br>  Nous avons d√©j√† dit que le nettoyage ordinaire dans des conditions normales (lorsque personne ne tient l'horizon de transaction pendant longtemps) doit faire face √† son travail.  La question est de savoir √† quelle fr√©quence l'appeler. <br><br>  Si vous nettoyez trop rarement une table √† langer, elle grossira plus que vous ne le souhaiteriez.  De plus, pour le prochain nettoyage, il peut falloir plusieurs passages dans les indices si trop de changements se sont accumul√©s. <br><br>  Si vous nettoyez la table trop souvent, au lieu d'un travail utile, le serveur effectuera constamment des op√©rations de maintenance, ce qui n'est pas bon non plus. <br><br>  Notez que le d√©marrage d'un nettoyage planifi√© r√©gulier ne r√©sout pas le probl√®me, car la charge peut changer avec le temps.  Si la table a commenc√© √† √™tre mise √† jour plus activement, elle doit √™tre nettoy√©e plus souvent. <br><br>  Le nettoyage automatique n'est que le m√©canisme qui vous permet de commencer le nettoyage, en fonction de l'activit√© des changements dans les tables. <br><a name="habracut"></a><br>  Lorsque <em>l'autonettoyage est</em> activ√© (param√®tre de configuration <em>autovacuum</em> ), le processus de lancement autovacuum est toujours pr√©sent dans le syst√®me, qui pr√©voit de fonctionner, et les flux de travail des travailleurs autovacuum sont impliqu√©s dans le nettoyage r√©el, dont plusieurs instances peuvent fonctionner en parall√®le. <br><br>  Le processus de lancement autovacuum compile une liste de bases de donn√©es dans lesquelles il existe une activit√©.  L'activit√© est d√©termin√©e par des statistiques et, pour √™tre collect√©e, le param√®tre <em>track_counts</em> doit √™tre d√©fini.  Ne d√©sactivez jamais le <em>vide automatique</em> et les <em>track_counts</em> , sinon <em>le</em> <em>nettoyage</em> <em>automatique</em> ne fonctionnera pas. <br><br>  Une fois dans <em>autovacuum_naptime,</em> le processus du lanceur autovacuum d√©marre (√† l'aide du processus postmaster) un flux de travail pour chaque base de donn√©es de la liste.  En d'autres termes, s'il existe une activit√© dans la base de donn√©es, les workflows y entreront avec l'intervalle <em>autovacuum_naptime</em> .  Pour ce faire, s'il existe plusieurs bases de donn√©es actives (N pi√®ces), les processus de travail sont lanc√©s N fois plus souvent que <em>autovacuum_naptime</em> .  Mais en m√™me temps, le nombre total de workflows fonctionnant simultan√©ment est limit√© par le param√®tre <em>autovacuum_max_workers</em> . <br><br>  Apr√®s avoir d√©marr√©, le workflow se connecte √† la base de donn√©es sp√©cifi√©e par lui et commence par construire la liste: <br><br><ul><li>  toutes les tables, vues mat√©rialis√©es et toasts qui doivent √™tre effac√©es, </li><li>  toutes les tables et repr√©sentations mat√©rialis√©es qui n√©cessitent une analyse (les tables de toasts ne sont pas analys√©es, car elles sont toujours accessibles par index). </li></ul><br>  En outre, le flux de travail nettoie et / ou analyse √† son tour les objets s√©lectionn√©s et se termine lorsque le nettoyage est termin√©. <br><br>  Si le processus n'a pas termin√© tout le travail pr√©vu pour <em>autovacuum_naptime</em> , le processus de lancement autovacuum enverra un autre flux de travail √† la m√™me base de donn√©es et ils travailleront ensemble.  ¬´Ensemble¬ª signifie simplement que le deuxi√®me processus construira sa liste de tableaux et la suivra.  Ainsi, diff√©rentes tables seront trait√©es en parall√®le, mais au niveau d'une table il n'y a pas de parall√©lisme - si l'un des processus de travail travaille d√©j√† sur la table, l'autre la sautera et continuera. <br><br><blockquote>  Il y a eu une discussion sur la n√©cessit√© d'un traitement parall√®le depuis longtemps, mais le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">patch</a> n'a pas encore √©t√© adopt√©. <br></blockquote><br>  Examinons maintenant de plus pr√®s ce qui "n√©cessite un nettoyage" et "n√©cessite une analyse". <br><br><h1>  Quelles tables doivent √™tre nettoy√©es </h1><br>  On pense qu'un nettoyage est n√©cessaire si le nombre de versions "mortes", c'est-√†-dire non pertinentes, de cha√Ænes d√©passe une valeur de seuil d√©finie.  Le nombre de versions mortes est constamment collect√© par le collecteur de statistiques et stock√© dans la table pg_stat_all_tables.  Et le seuil est fix√© par deux param√®tres: <br><br><ul><li>  <em>autovacuum_vacuum_threshold</em> d√©finit la valeur absolue (en morceaux), </li><li>  <em>autovacuum_vacuum_scale_factor</em> d√©termine la proportion de lignes dans une table. </li></ul><br>  La formule finale est: le nettoyage est requis si pg_stat_all_tables.n_dead_tup&gt; = <em>autovacuum_vacuum_threshold</em> + <em>autovacuum_vacuum_scale_factor</em> * pg_class.reltupes. <br><br>  Les param√®tres par d√©faut d√©finissent <em>autovacuum_vacuum_threshold</em> = 50 et <br>  <em>autovacuum_vacuum_scale_factor</em> = 0.2.  Le param√®tre principal ici, bien s√ªr, est <em>autovacuum_vacuum_scale_factor</em> - c'est lui qui est important pour les grandes tables (√† savoir, les probl√®mes possibles leur sont associ√©s).  La valeur de 20% semble √™tre largement surestim√©e, elle devra probablement √™tre consid√©rablement r√©duite. <br><br>  Les valeurs optimales des param√®tres peuvent varier pour diff√©rentes tables en fonction de leur taille et de la nature des modifications.  Il est logique d'√©tablir, dans l'ensemble, des valeurs ad√©quates et - si n√©cessaire - de configurer sp√©cialement les param√®tres au niveau de certaines tables en utilisant les param√®tres de stockage: <br><br><ul><li>  <em>autovacuum_vacuum_threshold</em> et <em>toast.autovacuum_vacuum_threshold</em> , </li><li>  <em>autovacuum_vacuum_scale_factor</em> et <em>toast.autovacuum_vacuum_scale_factor</em> . </li></ul><br>  Afin de ne pas √™tre confus, cela ne devrait √™tre fait que pour un petit nombre de tableaux qui se distinguent entre autres par le volume ou l'intensit√© des changements, et uniquement si les valeurs d√©finies globalement ne conviennent pas. <br><br>  De plus, l'autonettoyage peut √™tre d√©sactiv√© au niveau de la table (bien qu'il soit difficile de penser √† une raison pour laquelle cela serait n√©cessaire): <br><br><ul><li>  <em>autovacuum_enabled</em> et <em>toast.autovacuum_enabled</em> . </li></ul><br>  Par exemple, la derni√®re fois que nous avons cr√©√© une table d'aspirateur avec le nettoyage automatique d√©sactiv√©, pour - √† des fins de d√©monstration - g√©rer le nettoyage manuel.  Le param√®tre de stockage peut √™tre modifi√© comme suit: <br><br><pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> vac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> (autovacuum_enabled = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>);</code> </pre> <br>  Pour formaliser tout ce qui pr√©c√®de, nous allons cr√©er une vue montrant quelles tables doivent actuellement √™tre nettoy√©es.  Il utilisera une fonction qui renvoie la valeur actuelle du param√®tre, √©tant donn√© qu'elle peut √™tre remplac√©e au niveau de la table: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> get_value(param <span class="hljs-type"><span class="hljs-type">text</span></span>, reloptions <span class="hljs-type"><span class="hljs-type">text</span></span>[], relkind "char") <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-type"><span class="hljs-type">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $$<span class="ruby"><span class="ruby"> SELECT coalesce( --    ,    (SELECT option_value FROM pg_options_to_table(reloptions) WHERE option_name = CASE --  toast-    WHEN relkind = </span><span class="hljs-string"><span class="ruby"><span class="hljs-string">'t'</span></span></span><span class="ruby"> THEN </span><span class="hljs-string"><span class="ruby"><span class="hljs-string">'toast.'</span></span></span><span class="ruby"> ELSE </span><span class="hljs-string"><span class="ruby"><span class="hljs-string">''</span></span></span><span class="ruby"> </span><span class="hljs-keyword"><span class="ruby"><span class="hljs-keyword">END</span></span></span><span class="ruby"> </span><span class="hljs-params"><span class="ruby"><span class="hljs-params">||</span></span></span><span class="ruby"> param ), --      current_setting(param) )</span><span class="hljs-symbol"><span class="ruby"><span class="hljs-symbol">:</span></span></span><span class="hljs-symbol"><span class="ruby"><span class="hljs-symbol">:float</span></span></span><span class="ruby">; $$</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LANGUAGE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>;</code> </pre><br>  Et voici la vue: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VIEW</span></span> need_vacuum <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> st.schemaname || <span class="hljs-string"><span class="hljs-string">'.'</span></span> || st.relname tablename, st.n_dead_tup dead_tup, get_value(<span class="hljs-string"><span class="hljs-string">'autovacuum_vacuum_threshold'</span></span>, c.reloptions, c.relkind) + get_value(<span class="hljs-string"><span class="hljs-string">'autovacuum_vacuum_scale_factor'</span></span>, c.reloptions, c.relkind) * c.reltuples max_dead_tup, st.last_autovacuum <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_all_tables st, pg_class c <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> c.oid = st.relid <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> c.relkind <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> (<span class="hljs-string"><span class="hljs-string">'r'</span></span>,<span class="hljs-string"><span class="hljs-string">'m'</span></span>,<span class="hljs-string"><span class="hljs-string">'t'</span></span>);</code> </pre><br><h1>  Quels tableaux doivent √™tre analys√©s </h1><br>  Avec l'auto-analyse, la situation est √† peu pr√®s la m√™me.  On pense qu'une analyse est requise pour les tables pour lesquelles le nombre de versions modifi√©es (depuis la derni√®re analyse) des lignes d√©passe la valeur seuil sp√©cifi√©e par deux param√®tres similaires: pg_stat_all_tables.n_mod_since_analyze&gt; = <em>autovacuum_analyze_threshold</em> + <em>autovacuum_analyze_scale_factor</em> * pg_class.reltupes. <br><br>  Les param√®tres d'auto-analyse par d√©faut sont l√©g√®rement diff√©rents: <em>autovacuum_analyze_threshold</em> = 50 et <em>autovacuum_analyze_scale_factor</em> = 0,1.  Ils peuvent √©galement √™tre d√©finis au niveau des param√®tres de stockage pour les tables individuelles: <br><br><ul><li>  <em>autovacuum_analyze_threshold</em> , </li><li>  <em>autovacuum_analyze_scale_factor</em> </li></ul><br>  √âtant donn√© que les tableaux de toasts ne sont pas analys√©s, il n'y a pas de param√®tres correspondants pour eux. <br><br>  Cr√©ons une vue pour l'analyse: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VIEW</span></span> need_analyze <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> st.schemaname || <span class="hljs-string"><span class="hljs-string">'.'</span></span> || st.relname tablename, st.n_mod_since_analyze mod_tup, get_value(<span class="hljs-string"><span class="hljs-string">'autovacuum_analyze_threshold'</span></span>, c.reloptions, c.relkind) + get_value(<span class="hljs-string"><span class="hljs-string">'autovacuum_analyze_scale_factor'</span></span>, c.reloptions, c.relkind) * c.reltuples max_mod_tup, st.last_autoanalyze <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_all_tables st, pg_class c <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> c.oid = st.relid <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> c.relkind <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> (<span class="hljs-string"><span class="hljs-string">'r'</span></span>,<span class="hljs-string"><span class="hljs-string">'m'</span></span>);</code> </pre><br><h1>  Exemple </h1><br>  Pour les exp√©riences, nous d√©finissons les valeurs de param√®tres suivantes: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> autovacuum_naptime = <span class="hljs-string"><span class="hljs-string">'1s'</span></span>; <span class="hljs-comment"><span class="hljs-comment">--     =&gt; ALTER SYSTEM SET autovacuum_vacuum_scale_factor = 0.03; -- 3% =&gt; ALTER SYSTEM SET autovacuum_vacuum_threshold = 0; =&gt; ALTER SYSTEM SET autovacuum_analyze_scale_factor = 0.02; -- 2% =&gt; ALTER SYSTEM SET autovacuum_analyze_threshold = 0;</span></span></code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_reload_conf();</code> </pre><pre> <code class="plaintext hljs"> pg_reload_conf ---------------- t (1 row)</code> </pre><br>  Cr√©ez maintenant un tableau similaire √† celui que nous avons utilis√© la derni√®re fois et ins√©rez-y mille lignes.  Le nettoyage automatique est d√©sactiv√© au niveau de la table et nous allons l'activer nous-m√™mes.  Si cela n'est pas fait, les exemples ne seront pas reproductibles, car l'autonettoyage peut fonctionner au mauvais moment. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> autovac( id <span class="hljs-type"><span class="hljs-type">serial</span></span>, s <span class="hljs-type"><span class="hljs-type">char</span></span>(<span class="hljs-number"><span class="hljs-number">100</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> (autovacuum_enabled = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> autovac <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> g.id,<span class="hljs-string"><span class="hljs-string">'A'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1000</span></span>) g(id);</code> </pre><br>  Voici ce que notre vue de nettoyage va montrer: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> need_vacuum <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> tablename = <span class="hljs-string"><span class="hljs-string">'public.autovac'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> tablename | dead_tup | max_dead_tup | last_autovacuum ----------------+----------+--------------+----------------- public.autovac | 0 | 0 | (1 row)</code> </pre><br>  Il y a deux points auxquels vous devez faire attention.  Premi√®rement, max_dead_tup = 0, bien que 3% de 1000 lignes soit 30 lignes.  Le fait est que nous n'avons pas encore de statistiques sur la table, car INSERT lui-m√™me ne le met pas √† jour.  Jusqu'√† ce que notre table soit analys√©e, les z√©ros resteront, puisque pg_class.reltuples = 0. Cependant, jetons un ≈ìil √† la deuxi√®me vue pour l'analyse: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> need_analyze <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> tablename = <span class="hljs-string"><span class="hljs-string">'public.autovac'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> tablename | mod_tup | max_mod_tup | last_autoanalyze ----------------+---------+-------------+------------------ public.autovac | 1000 | 0 | (1 row)</code> </pre><br>  √âtant donn√© que le tableau a modifi√© (ajout√©) 1 000 lignes, et c'est plus que z√©ro, l'auto-analyse devrait fonctionner.  V√©rifiez ceci: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> autovac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> (autovacuum_enabled = <span class="hljs-keyword"><span class="hljs-keyword">on</span></span>);</code> </pre><br>  Apr√®s une courte pause, nous voyons que la table est analys√©e et au lieu de z√©ros dans max_mod_tup, nous voyons les 20 lignes correctes: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> need_analyze <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> tablename = <span class="hljs-string"><span class="hljs-string">'public.autovac'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> tablename | mod_tup | max_mod_tup | last_autoanalyze ----------------+---------+-------------+------------------------------- public.autovac | 0 | 20 | 2019-05-21 11:59:48.465987+03 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> reltuples, relpages <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relname = <span class="hljs-string"><span class="hljs-string">'autovac'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> reltuples | relpages -----------+---------- 1000 | 17 (1 row)</code> </pre><br>  Revenons au nettoyage automatique: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> need_vacuum <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> tablename = <span class="hljs-string"><span class="hljs-string">'public.autovac'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> tablename | dead_tup | max_dead_tup | last_autovacuum ----------------+----------+--------------+----------------- public.autovac | 0 | 30 | (1 row)</code> </pre><br>  Max_dead_tup, comme nous le voyons, a d√©j√† √©t√© corrig√©.  Le deuxi√®me point √† prendre en compte est dead_tup = 0. Les statistiques montrent qu'il n'y a pas de versions mortes de lignes dans le tableau ... et c'est vrai.  Il n'y a encore rien √† nettoyer dans notre table.  Ainsi, toute table utilis√©e uniquement en mode ajout uniquement ne sera pas effac√©e et, par cons√©quent, la carte de visibilit√© ne sera pas mise √† jour pour elle.  Et cela rend impossible l'utilisation exclusive de l'analyse d'index (analyse d'index uniquement). <br><br>  (La prochaine fois, nous verrons que le nettoyage arrivera t√¥t ou tard √† la table en annexe uniquement, mais cela se produira tr√®s rarement.) <br><br>  Conclusion pratique: s'il est important d'utiliser uniquement la num√©risation d'index, vous devrez peut-√™tre appeler pour un nettoyage manuel. <br><br>  D√©sactivez maintenant le nettoyage automatique et mettez √† jour la ligne 31 - une de plus que la valeur seuil. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> autovac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> (autovacuum_enabled = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> autovac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'B'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id &lt;= <span class="hljs-number"><span class="hljs-number">31</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> need_vacuum <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> tablename = <span class="hljs-string"><span class="hljs-string">'public.autovac'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> tablename | dead_tup | max_dead_tup | last_autovacuum ----------------+----------+--------------+----------------- public.autovac | 31 | 30 | (1 row)</code> </pre><br>  La condition de d√©clenchement de l'auto-nettoyage est maintenant remplie.  Activez le nettoyage automatique et apr√®s une courte pause, nous verrons que le tableau a √©t√© trait√©: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> autovac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> (autovacuum_enabled = <span class="hljs-keyword"><span class="hljs-keyword">on</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> need_vacuum <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> tablename = <span class="hljs-string"><span class="hljs-string">'public.autovac'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> tablename | dead_tup | max_dead_tup | last_autovacuum ----------------+----------+--------------+------------------------------- public.autovac | 0 | 30 | 2019-05-21 11:59:52.554571+03 (1 row)</code> </pre><br><h1>  R√©gulation de charge </h1><br>  Le nettoyage ne bloque pas les autres processus, car il fonctionne page par page, mais cr√©e n√©anmoins une charge sur le syst√®me et peut avoir un effet notable sur les performances. <br><br><h2>  R√®glement pour le nettoyage r√©gulier </h2><br>  Afin de pouvoir contr√¥ler l'intensit√© du nettoyage et, par cons√©quent, son effet sur le syst√®me, le processus alterne entre travail et attente.  Le nettoyage effectue approximativement les unit√©s de travail conventionnelles de <em>vacuum_cost_limit</em> , puis s'endort sur <em>vacuum_cost_delay</em> ms. <br><br>  Les param√®tres par d√©faut d√©finissent <em>vacuum_cost_limit</em> = 200, <em>vacuum_cost_delay</em> = 0. Le dernier z√©ro signifie en fait que le nettoyage (normal) ne s'endort pas, de sorte que la valeur sp√©cifique de <em>vacuum_cost_limit</em> ne joue aucun r√¥le.  Cela est d√ª au fait que si l'administrateur doit d√©marrer VACUUM manuellement, il souhaite probablement effectuer le nettoyage le plus rapidement possible. <br><br>  N√©anmoins, si vous d√©finissez toujours le temps de veille, la quantit√© de travail sp√©cifi√©e dans <em>vacuum_cost_limit correspondra</em> au co√ªt de travail avec les pages dans le cache de tampon.  Chaque acc√®s √† une page est √©valu√© comme suit: <br><br><ul><li>  si la page a √©t√© trouv√©e dans le cache de tampon, alors <em>vacuum_cost_page_hit</em> = 1; </li><li>  s'il n'est pas trouv√©, <em>vacuum_cost_page_miss</em> = 10; </li><li>  si vous ne le trouviez pas et que vous deviez pousser la page sale hors du tampon, alors <em>vacuum_cost_page_dirty</em> = 20. </li></ul><br>  Autrement dit, avec les param√®tres <em>vacuum_cost_limit</em> par d√©faut, 200 pages du cache, ou 20 pages du disque, ou 10 pages avec extrusion peuvent √™tre trait√©es en une seule s√©ance.  Il est clair que ce sont des nombres plut√¥t arbitraires, mais cela n'a aucun sens de les s√©lectionner plus pr√©cis√©ment. <br><br><h2>  R√®glement pour le nettoyage automatique </h2><br>  Le contr√¥le de la charge pendant le nettoyage automatique fonctionne de la m√™me mani√®re que pour le nettoyage r√©gulier.  Mais pour que le <em>nettoyage</em> manuel et l' <em>auto-</em> nettoyage puissent fonctionner avec des intensit√©s diff√©rentes, les processus automatiques ont leurs propres param√®tres: <em>autovacuum_vacuum_cost_limit</em> et <em>autovacuum_vacuum_cost_delay</em> .  Si ces param√®tres prennent la valeur -1, alors la valeur de <em>vacuum_cost_limit</em> et / ou <em>vacuum_cost_delay est utilis√©e</em> . <br><br>  Par d√©faut, <em>autovacuum_vacuum_cost_limit</em> = -1 (c'est-√†-dire que la valeur <em>vacuum_cost_limit</em> = 200 est utilis√©e) et <em>autovacuum_vacuum_cost_delay</em> = 20ms.  Sur les √©quipements modernes avec ces num√©ros, l'auto-nettoyage fonctionnera tr√®s, tr√®s lentement. <br><br>  Dans la version 12, la valeur de <em>autovacuum_vacuum_cost_delay</em> sera r√©duite √† 2 ms, ce qui peut √™tre consid√©r√© comme une premi√®re approximation plus appropri√©e. <br><br>  De plus, il convient de noter que la limite fix√©e par ces param√®tres est commune √† tous les processus de travail.  En d'autres termes, √† mesure que le nombre de processus de travail simultan√©s change, la charge totale restera constante.  Par cons√©quent, si la t√¢che consiste √† augmenter les performances du <em>nettoyage automatique</em> , alors lors de l'ajout de workflows, il vaut la peine d'augmenter <em>autovacuum_vacuum_cost_limit</em> . <br><br><h2>  Utilisation et surveillance de la m√©moire </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">La derni√®re fois,</a> nous avons examin√© comment le nettoyage utilise la m√©moire RAM de la taille <em>maintenance_work_mem</em> pour stocker les identificateurs de version des lignes √† nettoyer. <br><br>  Le nettoyage automatique fait exactement la m√™me chose.  Mais il peut y avoir de nombreux processus simultan√©s si vous d√©finissez <em>autovacuum_max_workers</em> sur une grande valeur.  De plus, toute la m√©moire est allou√©e imm√©diatement et compl√®tement, et non par n√©cessit√©.  Par cons√©quent, pour le workflow de <em>nettoyage automatique</em> , vous pouvez d√©finir votre propre restriction √† l'aide du param√®tre <em>autovacuum_work_mem</em> .  Par d√©faut, ce param√®tre est -1, c'est-√†-dire qu'il n'est pas utilis√©. <br><br>  Comme d√©j√† mentionn√©, le nettoyage peut fonctionner avec un minimum de m√©moire.  Mais si des index sont cr√©√©s sur la table, une petite valeur <em>maintenance_work_mem</em> peut conduire √† des analyses d'index r√©p√©t√©es.  Il en va de m√™me pour l'auto-nettoyage.  Id√©alement, vous devez s√©lectionner une valeur minimale de <em>autovacuum_work_mem</em> √† laquelle les analyses r√©p√©t√©es ne se produisent pas. <br><br>  Nous avons vu que pour surveiller le nettoyage, vous pouvez utiliser le param√®tre VERBOSE (mais il ne peut pas √™tre sp√©cifi√© pour le nettoyage automatique) ou la vue pg_stat_progress_vacuum (mais il n'affiche que les informations actuelles).  Par cons√©quent, le principal moyen de surveiller <em>le nettoyage automatique</em> est le param√®tre <em>log_autovacuum_min_duration</em> , qui affiche des informations dans le journal des messages du serveur.  Par d√©faut, il est d√©sactiv√© (d√©fini sur -1).  Il y a une raison pour activer ce param√®tre (√† une valeur de 0, des informations sur tous les d√©marrages d'autonettoyage seront affich√©es) et observer les chiffres. <br><br>  Voici √† quoi ressemble la sortie: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> log_autovacuum_min_duration = <span class="hljs-number"><span class="hljs-number">0</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_reload_conf();</code> </pre><pre> <code class="plaintext hljs"> pg_reload_conf ---------------- t (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> autovac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'C'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id &lt;= <span class="hljs-number"><span class="hljs-number">31</span></span>;</code> </pre><br><pre> <code class="plaintext hljs">student$ tail -n 7 /var/log/postgresql/postgresql-11-main.log</code> </pre><pre> <code class="plaintext hljs">2019-05-21 11:59:55.675 MSK [9737] LOG: automatic vacuum of table "test.public.autovac": index scans: 0 pages: 0 removed, 18 remain, 0 skipped due to pins, 0 skipped frozen tuples: 31 removed, 1000 remain, 0 are dead but not yet removable, oldest xmin: 4040 buffer usage: 78 hits, 0 misses, 0 dirtied avg read rate: 0.000 MB/s, avg write rate: 0.000 MB/s system usage: CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s 2019-05-21 11:59:55.676 MSK [9737] LOG: automatic analyze of table "test.public.autovac" system usage: CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s</code> </pre><br>  Toutes les informations n√©cessaires sont pr√©sentes ici. <br><br>  Rappelez-vous que, souvent, vous ne devez pas augmenter la taille de la m√©moire, mais diminuer le seuil de nettoyage afin que moins de donn√©es soient trait√©es √† la fois. <br><br>  Il peut √©galement √™tre judicieux de surveiller la longueur de la liste des tables qui doivent √™tre nettoy√©es √† l'aide des vues ci-dessus.  Une augmentation de la longueur de la liste indiquera que l'autonettoyage n'a pas le temps de faire son travail et que les param√®tres doivent √™tre modifi√©s. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">√Ä suivre</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr452762/">https://habr.com/ru/post/fr452762/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr452750/index.html">Nextcloud √† l'int√©rieur et √† l'ext√©rieur d'OpenLiteSpeed: configurer le proxy inverse</a></li>
<li><a href="../fr452752/index.html">BigData fait maison. Partie 1. Pratique Spark Streaming sur un cluster AWS</a></li>
<li><a href="../fr452754/index.html">19% des images Docker les plus populaires n'ont pas de mot de passe root</a></li>
<li><a href="../fr452756/index.html">Cr√©ation de Tower Defense dans Unity: Enemies</a></li>
<li><a href="../fr452760/index.html">Vitamine D. Boire ou ne pas boire, telle est la question. (Ou une histoire sur la fa√ßon dont j'ai r√©ussi une analyse qui ne m'a pas √©t√© prescrite)</a></li>
<li><a href="../fr452764/index.html">[Peter] Rencontre JUG.ru avec Sergei Melnikov - Profilage √† la vitesse supraluminique: th√©orie et pratique</a></li>
<li><a href="../fr452766/index.html">La technologie de streaming progressif, ou comment regarder des vid√©os 4k sur le r√©seau, sans frises</a></li>
<li><a href="../fr452768/index.html">Comment concevoir un produit si vous d√©cidez d'entrer sur le march√© √©tranger</a></li>
<li><a href="../fr452772/index.html">5 techniques avanc√©es de test Go</a></li>
<li><a href="../fr452774/index.html">Dell XPS 13 9380: un ordinateur portable fiable et tr√®s compact pour les affaires s√©rieuses</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>