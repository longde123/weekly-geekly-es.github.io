<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💃🏽 🤣 👩🏼‍🏫 MVCC-7. Nettoyage auto 👊🏼 ✋🏽 🔙</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Permettez-moi de vous rappeler que nous avons commencé par des problèmes liés à l' isolement , fait une digression sur l' organisation des données à u...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MVCC-7. Nettoyage auto</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/452762/">  Permettez-moi de vous rappeler que nous avons commencé par des problèmes liés à l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">isolement</a> , fait une digression sur l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">organisation des données à un bas niveau</a> , parlé en détail des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">versions de ligne</a> et comment les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">instantanés</a> sont obtenus à partir des versions. <br><br>  Ensuite, nous avons examiné le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">nettoyage sur la page</a> (et les mises à jour HOT), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le nettoyage régulier</a> , mais aujourd'hui, nous examinons le nettoyage automatique. <br><br><h1>  Nettoyage automatique (autovacuum) </h1><br>  Nous avons déjà dit que le nettoyage ordinaire dans des conditions normales (lorsque personne ne tient l'horizon de transaction pendant longtemps) doit faire face à son travail.  La question est de savoir à quelle fréquence l'appeler. <br><br>  Si vous nettoyez trop rarement une table à langer, elle grossira plus que vous ne le souhaiteriez.  De plus, pour le prochain nettoyage, il peut falloir plusieurs passages dans les indices si trop de changements se sont accumulés. <br><br>  Si vous nettoyez la table trop souvent, au lieu d'un travail utile, le serveur effectuera constamment des opérations de maintenance, ce qui n'est pas bon non plus. <br><br>  Notez que le démarrage d'un nettoyage planifié régulier ne résout pas le problème, car la charge peut changer avec le temps.  Si la table a commencé à être mise à jour plus activement, elle doit être nettoyée plus souvent. <br><br>  Le nettoyage automatique n'est que le mécanisme qui vous permet de commencer le nettoyage, en fonction de l'activité des changements dans les tables. <br><a name="habracut"></a><br>  Lorsque <em>l'autonettoyage est</em> activé (paramètre de configuration <em>autovacuum</em> ), le processus de lancement autovacuum est toujours présent dans le système, qui prévoit de fonctionner, et les flux de travail des travailleurs autovacuum sont impliqués dans le nettoyage réel, dont plusieurs instances peuvent fonctionner en parallèle. <br><br>  Le processus de lancement autovacuum compile une liste de bases de données dans lesquelles il existe une activité.  L'activité est déterminée par des statistiques et, pour être collectée, le paramètre <em>track_counts</em> doit être défini.  Ne désactivez jamais le <em>vide automatique</em> et les <em>track_counts</em> , sinon <em>le</em> <em>nettoyage</em> <em>automatique</em> ne fonctionnera pas. <br><br>  Une fois dans <em>autovacuum_naptime,</em> le processus du lanceur autovacuum démarre (à l'aide du processus postmaster) un flux de travail pour chaque base de données de la liste.  En d'autres termes, s'il existe une activité dans la base de données, les workflows y entreront avec l'intervalle <em>autovacuum_naptime</em> .  Pour ce faire, s'il existe plusieurs bases de données actives (N pièces), les processus de travail sont lancés N fois plus souvent que <em>autovacuum_naptime</em> .  Mais en même temps, le nombre total de workflows fonctionnant simultanément est limité par le paramètre <em>autovacuum_max_workers</em> . <br><br>  Après avoir démarré, le workflow se connecte à la base de données spécifiée par lui et commence par construire la liste: <br><br><ul><li>  toutes les tables, vues matérialisées et toasts qui doivent être effacées, </li><li>  toutes les tables et représentations matérialisées qui nécessitent une analyse (les tables de toasts ne sont pas analysées, car elles sont toujours accessibles par index). </li></ul><br>  En outre, le flux de travail nettoie et / ou analyse à son tour les objets sélectionnés et se termine lorsque le nettoyage est terminé. <br><br>  Si le processus n'a pas terminé tout le travail prévu pour <em>autovacuum_naptime</em> , le processus de lancement autovacuum enverra un autre flux de travail à la même base de données et ils travailleront ensemble.  «Ensemble» signifie simplement que le deuxième processus construira sa liste de tableaux et la suivra.  Ainsi, différentes tables seront traitées en parallèle, mais au niveau d'une table il n'y a pas de parallélisme - si l'un des processus de travail travaille déjà sur la table, l'autre la sautera et continuera. <br><br><blockquote>  Il y a eu une discussion sur la nécessité d'un traitement parallèle depuis longtemps, mais le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">patch</a> n'a pas encore été adopté. <br></blockquote><br>  Examinons maintenant de plus près ce qui "nécessite un nettoyage" et "nécessite une analyse". <br><br><h1>  Quelles tables doivent être nettoyées </h1><br>  On pense qu'un nettoyage est nécessaire si le nombre de versions "mortes", c'est-à-dire non pertinentes, de chaînes dépasse une valeur de seuil définie.  Le nombre de versions mortes est constamment collecté par le collecteur de statistiques et stocké dans la table pg_stat_all_tables.  Et le seuil est fixé par deux paramètres: <br><br><ul><li>  <em>autovacuum_vacuum_threshold</em> définit la valeur absolue (en morceaux), </li><li>  <em>autovacuum_vacuum_scale_factor</em> détermine la proportion de lignes dans une table. </li></ul><br>  La formule finale est: le nettoyage est requis si pg_stat_all_tables.n_dead_tup&gt; = <em>autovacuum_vacuum_threshold</em> + <em>autovacuum_vacuum_scale_factor</em> * pg_class.reltupes. <br><br>  Les paramètres par défaut définissent <em>autovacuum_vacuum_threshold</em> = 50 et <br>  <em>autovacuum_vacuum_scale_factor</em> = 0.2.  Le paramètre principal ici, bien sûr, est <em>autovacuum_vacuum_scale_factor</em> - c'est lui qui est important pour les grandes tables (à savoir, les problèmes possibles leur sont associés).  La valeur de 20% semble être largement surestimée, elle devra probablement être considérablement réduite. <br><br>  Les valeurs optimales des paramètres peuvent varier pour différentes tables en fonction de leur taille et de la nature des modifications.  Il est logique d'établir, dans l'ensemble, des valeurs adéquates et - si nécessaire - de configurer spécialement les paramètres au niveau de certaines tables en utilisant les paramètres de stockage: <br><br><ul><li>  <em>autovacuum_vacuum_threshold</em> et <em>toast.autovacuum_vacuum_threshold</em> , </li><li>  <em>autovacuum_vacuum_scale_factor</em> et <em>toast.autovacuum_vacuum_scale_factor</em> . </li></ul><br>  Afin de ne pas être confus, cela ne devrait être fait que pour un petit nombre de tableaux qui se distinguent entre autres par le volume ou l'intensité des changements, et uniquement si les valeurs définies globalement ne conviennent pas. <br><br>  De plus, l'autonettoyage peut être désactivé au niveau de la table (bien qu'il soit difficile de penser à une raison pour laquelle cela serait nécessaire): <br><br><ul><li>  <em>autovacuum_enabled</em> et <em>toast.autovacuum_enabled</em> . </li></ul><br>  Par exemple, la dernière fois que nous avons créé une table d'aspirateur avec le nettoyage automatique désactivé, pour - à des fins de démonstration - gérer le nettoyage manuel.  Le paramètre de stockage peut être modifié comme suit: <br><br><pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> vac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> (autovacuum_enabled = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>);</code> </pre> <br>  Pour formaliser tout ce qui précède, nous allons créer une vue montrant quelles tables doivent actuellement être nettoyées.  Il utilisera une fonction qui renvoie la valeur actuelle du paramètre, étant donné qu'elle peut être remplacée au niveau de la table: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> get_value(param <span class="hljs-type"><span class="hljs-type">text</span></span>, reloptions <span class="hljs-type"><span class="hljs-type">text</span></span>[], relkind "char") <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-type"><span class="hljs-type">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $$<span class="ruby"><span class="ruby"> SELECT coalesce( --    ,    (SELECT option_value FROM pg_options_to_table(reloptions) WHERE option_name = CASE --  toast-    WHEN relkind = </span><span class="hljs-string"><span class="ruby"><span class="hljs-string">'t'</span></span></span><span class="ruby"> THEN </span><span class="hljs-string"><span class="ruby"><span class="hljs-string">'toast.'</span></span></span><span class="ruby"> ELSE </span><span class="hljs-string"><span class="ruby"><span class="hljs-string">''</span></span></span><span class="ruby"> </span><span class="hljs-keyword"><span class="ruby"><span class="hljs-keyword">END</span></span></span><span class="ruby"> </span><span class="hljs-params"><span class="ruby"><span class="hljs-params">||</span></span></span><span class="ruby"> param ), --      current_setting(param) )</span><span class="hljs-symbol"><span class="ruby"><span class="hljs-symbol">:</span></span></span><span class="hljs-symbol"><span class="ruby"><span class="hljs-symbol">:float</span></span></span><span class="ruby">; $$</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LANGUAGE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>;</code> </pre><br>  Et voici la vue: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VIEW</span></span> need_vacuum <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> st.schemaname || <span class="hljs-string"><span class="hljs-string">'.'</span></span> || st.relname tablename, st.n_dead_tup dead_tup, get_value(<span class="hljs-string"><span class="hljs-string">'autovacuum_vacuum_threshold'</span></span>, c.reloptions, c.relkind) + get_value(<span class="hljs-string"><span class="hljs-string">'autovacuum_vacuum_scale_factor'</span></span>, c.reloptions, c.relkind) * c.reltuples max_dead_tup, st.last_autovacuum <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_all_tables st, pg_class c <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> c.oid = st.relid <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> c.relkind <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> (<span class="hljs-string"><span class="hljs-string">'r'</span></span>,<span class="hljs-string"><span class="hljs-string">'m'</span></span>,<span class="hljs-string"><span class="hljs-string">'t'</span></span>);</code> </pre><br><h1>  Quels tableaux doivent être analysés </h1><br>  Avec l'auto-analyse, la situation est à peu près la même.  On pense qu'une analyse est requise pour les tables pour lesquelles le nombre de versions modifiées (depuis la dernière analyse) des lignes dépasse la valeur seuil spécifiée par deux paramètres similaires: pg_stat_all_tables.n_mod_since_analyze&gt; = <em>autovacuum_analyze_threshold</em> + <em>autovacuum_analyze_scale_factor</em> * pg_class.reltupes. <br><br>  Les paramètres d'auto-analyse par défaut sont légèrement différents: <em>autovacuum_analyze_threshold</em> = 50 et <em>autovacuum_analyze_scale_factor</em> = 0,1.  Ils peuvent également être définis au niveau des paramètres de stockage pour les tables individuelles: <br><br><ul><li>  <em>autovacuum_analyze_threshold</em> , </li><li>  <em>autovacuum_analyze_scale_factor</em> </li></ul><br>  Étant donné que les tableaux de toasts ne sont pas analysés, il n'y a pas de paramètres correspondants pour eux. <br><br>  Créons une vue pour l'analyse: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VIEW</span></span> need_analyze <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> st.schemaname || <span class="hljs-string"><span class="hljs-string">'.'</span></span> || st.relname tablename, st.n_mod_since_analyze mod_tup, get_value(<span class="hljs-string"><span class="hljs-string">'autovacuum_analyze_threshold'</span></span>, c.reloptions, c.relkind) + get_value(<span class="hljs-string"><span class="hljs-string">'autovacuum_analyze_scale_factor'</span></span>, c.reloptions, c.relkind) * c.reltuples max_mod_tup, st.last_autoanalyze <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_all_tables st, pg_class c <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> c.oid = st.relid <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> c.relkind <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> (<span class="hljs-string"><span class="hljs-string">'r'</span></span>,<span class="hljs-string"><span class="hljs-string">'m'</span></span>);</code> </pre><br><h1>  Exemple </h1><br>  Pour les expériences, nous définissons les valeurs de paramètres suivantes: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> autovacuum_naptime = <span class="hljs-string"><span class="hljs-string">'1s'</span></span>; <span class="hljs-comment"><span class="hljs-comment">--     =&gt; ALTER SYSTEM SET autovacuum_vacuum_scale_factor = 0.03; -- 3% =&gt; ALTER SYSTEM SET autovacuum_vacuum_threshold = 0; =&gt; ALTER SYSTEM SET autovacuum_analyze_scale_factor = 0.02; -- 2% =&gt; ALTER SYSTEM SET autovacuum_analyze_threshold = 0;</span></span></code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_reload_conf();</code> </pre><pre> <code class="plaintext hljs"> pg_reload_conf ---------------- t (1 row)</code> </pre><br>  Créez maintenant un tableau similaire à celui que nous avons utilisé la dernière fois et insérez-y mille lignes.  Le nettoyage automatique est désactivé au niveau de la table et nous allons l'activer nous-mêmes.  Si cela n'est pas fait, les exemples ne seront pas reproductibles, car l'autonettoyage peut fonctionner au mauvais moment. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> autovac( id <span class="hljs-type"><span class="hljs-type">serial</span></span>, s <span class="hljs-type"><span class="hljs-type">char</span></span>(<span class="hljs-number"><span class="hljs-number">100</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> (autovacuum_enabled = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> autovac <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> g.id,<span class="hljs-string"><span class="hljs-string">'A'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1000</span></span>) g(id);</code> </pre><br>  Voici ce que notre vue de nettoyage va montrer: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> need_vacuum <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> tablename = <span class="hljs-string"><span class="hljs-string">'public.autovac'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> tablename | dead_tup | max_dead_tup | last_autovacuum ----------------+----------+--------------+----------------- public.autovac | 0 | 0 | (1 row)</code> </pre><br>  Il y a deux points auxquels vous devez faire attention.  Premièrement, max_dead_tup = 0, bien que 3% de 1000 lignes soit 30 lignes.  Le fait est que nous n'avons pas encore de statistiques sur la table, car INSERT lui-même ne le met pas à jour.  Jusqu'à ce que notre table soit analysée, les zéros resteront, puisque pg_class.reltuples = 0. Cependant, jetons un œil à la deuxième vue pour l'analyse: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> need_analyze <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> tablename = <span class="hljs-string"><span class="hljs-string">'public.autovac'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> tablename | mod_tup | max_mod_tup | last_autoanalyze ----------------+---------+-------------+------------------ public.autovac | 1000 | 0 | (1 row)</code> </pre><br>  Étant donné que le tableau a modifié (ajouté) 1 000 lignes, et c'est plus que zéro, l'auto-analyse devrait fonctionner.  Vérifiez ceci: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> autovac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> (autovacuum_enabled = <span class="hljs-keyword"><span class="hljs-keyword">on</span></span>);</code> </pre><br>  Après une courte pause, nous voyons que la table est analysée et au lieu de zéros dans max_mod_tup, nous voyons les 20 lignes correctes: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> need_analyze <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> tablename = <span class="hljs-string"><span class="hljs-string">'public.autovac'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> tablename | mod_tup | max_mod_tup | last_autoanalyze ----------------+---------+-------------+------------------------------- public.autovac | 0 | 20 | 2019-05-21 11:59:48.465987+03 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> reltuples, relpages <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relname = <span class="hljs-string"><span class="hljs-string">'autovac'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> reltuples | relpages -----------+---------- 1000 | 17 (1 row)</code> </pre><br>  Revenons au nettoyage automatique: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> need_vacuum <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> tablename = <span class="hljs-string"><span class="hljs-string">'public.autovac'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> tablename | dead_tup | max_dead_tup | last_autovacuum ----------------+----------+--------------+----------------- public.autovac | 0 | 30 | (1 row)</code> </pre><br>  Max_dead_tup, comme nous le voyons, a déjà été corrigé.  Le deuxième point à prendre en compte est dead_tup = 0. Les statistiques montrent qu'il n'y a pas de versions mortes de lignes dans le tableau ... et c'est vrai.  Il n'y a encore rien à nettoyer dans notre table.  Ainsi, toute table utilisée uniquement en mode ajout uniquement ne sera pas effacée et, par conséquent, la carte de visibilité ne sera pas mise à jour pour elle.  Et cela rend impossible l'utilisation exclusive de l'analyse d'index (analyse d'index uniquement). <br><br>  (La prochaine fois, nous verrons que le nettoyage arrivera tôt ou tard à la table en annexe uniquement, mais cela se produira très rarement.) <br><br>  Conclusion pratique: s'il est important d'utiliser uniquement la numérisation d'index, vous devrez peut-être appeler pour un nettoyage manuel. <br><br>  Désactivez maintenant le nettoyage automatique et mettez à jour la ligne 31 - une de plus que la valeur seuil. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> autovac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> (autovacuum_enabled = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> autovac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'B'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id &lt;= <span class="hljs-number"><span class="hljs-number">31</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> need_vacuum <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> tablename = <span class="hljs-string"><span class="hljs-string">'public.autovac'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> tablename | dead_tup | max_dead_tup | last_autovacuum ----------------+----------+--------------+----------------- public.autovac | 31 | 30 | (1 row)</code> </pre><br>  La condition de déclenchement de l'auto-nettoyage est maintenant remplie.  Activez le nettoyage automatique et après une courte pause, nous verrons que le tableau a été traité: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> autovac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> (autovacuum_enabled = <span class="hljs-keyword"><span class="hljs-keyword">on</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> need_vacuum <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> tablename = <span class="hljs-string"><span class="hljs-string">'public.autovac'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> tablename | dead_tup | max_dead_tup | last_autovacuum ----------------+----------+--------------+------------------------------- public.autovac | 0 | 30 | 2019-05-21 11:59:52.554571+03 (1 row)</code> </pre><br><h1>  Régulation de charge </h1><br>  Le nettoyage ne bloque pas les autres processus, car il fonctionne page par page, mais crée néanmoins une charge sur le système et peut avoir un effet notable sur les performances. <br><br><h2>  Règlement pour le nettoyage régulier </h2><br>  Afin de pouvoir contrôler l'intensité du nettoyage et, par conséquent, son effet sur le système, le processus alterne entre travail et attente.  Le nettoyage effectue approximativement les unités de travail conventionnelles de <em>vacuum_cost_limit</em> , puis s'endort sur <em>vacuum_cost_delay</em> ms. <br><br>  Les paramètres par défaut définissent <em>vacuum_cost_limit</em> = 200, <em>vacuum_cost_delay</em> = 0. Le dernier zéro signifie en fait que le nettoyage (normal) ne s'endort pas, de sorte que la valeur spécifique de <em>vacuum_cost_limit</em> ne joue aucun rôle.  Cela est dû au fait que si l'administrateur doit démarrer VACUUM manuellement, il souhaite probablement effectuer le nettoyage le plus rapidement possible. <br><br>  Néanmoins, si vous définissez toujours le temps de veille, la quantité de travail spécifiée dans <em>vacuum_cost_limit correspondra</em> au coût de travail avec les pages dans le cache de tampon.  Chaque accès à une page est évalué comme suit: <br><br><ul><li>  si la page a été trouvée dans le cache de tampon, alors <em>vacuum_cost_page_hit</em> = 1; </li><li>  s'il n'est pas trouvé, <em>vacuum_cost_page_miss</em> = 10; </li><li>  si vous ne le trouviez pas et que vous deviez pousser la page sale hors du tampon, alors <em>vacuum_cost_page_dirty</em> = 20. </li></ul><br>  Autrement dit, avec les paramètres <em>vacuum_cost_limit</em> par défaut, 200 pages du cache, ou 20 pages du disque, ou 10 pages avec extrusion peuvent être traitées en une seule séance.  Il est clair que ce sont des nombres plutôt arbitraires, mais cela n'a aucun sens de les sélectionner plus précisément. <br><br><h2>  Règlement pour le nettoyage automatique </h2><br>  Le contrôle de la charge pendant le nettoyage automatique fonctionne de la même manière que pour le nettoyage régulier.  Mais pour que le <em>nettoyage</em> manuel et l' <em>auto-</em> nettoyage puissent fonctionner avec des intensités différentes, les processus automatiques ont leurs propres paramètres: <em>autovacuum_vacuum_cost_limit</em> et <em>autovacuum_vacuum_cost_delay</em> .  Si ces paramètres prennent la valeur -1, alors la valeur de <em>vacuum_cost_limit</em> et / ou <em>vacuum_cost_delay est utilisée</em> . <br><br>  Par défaut, <em>autovacuum_vacuum_cost_limit</em> = -1 (c'est-à-dire que la valeur <em>vacuum_cost_limit</em> = 200 est utilisée) et <em>autovacuum_vacuum_cost_delay</em> = 20ms.  Sur les équipements modernes avec ces numéros, l'auto-nettoyage fonctionnera très, très lentement. <br><br>  Dans la version 12, la valeur de <em>autovacuum_vacuum_cost_delay</em> sera réduite à 2 ms, ce qui peut être considéré comme une première approximation plus appropriée. <br><br>  De plus, il convient de noter que la limite fixée par ces paramètres est commune à tous les processus de travail.  En d'autres termes, à mesure que le nombre de processus de travail simultanés change, la charge totale restera constante.  Par conséquent, si la tâche consiste à augmenter les performances du <em>nettoyage automatique</em> , alors lors de l'ajout de workflows, il vaut la peine d'augmenter <em>autovacuum_vacuum_cost_limit</em> . <br><br><h2>  Utilisation et surveillance de la mémoire </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">La dernière fois,</a> nous avons examiné comment le nettoyage utilise la mémoire RAM de la taille <em>maintenance_work_mem</em> pour stocker les identificateurs de version des lignes à nettoyer. <br><br>  Le nettoyage automatique fait exactement la même chose.  Mais il peut y avoir de nombreux processus simultanés si vous définissez <em>autovacuum_max_workers</em> sur une grande valeur.  De plus, toute la mémoire est allouée immédiatement et complètement, et non par nécessité.  Par conséquent, pour le workflow de <em>nettoyage automatique</em> , vous pouvez définir votre propre restriction à l'aide du paramètre <em>autovacuum_work_mem</em> .  Par défaut, ce paramètre est -1, c'est-à-dire qu'il n'est pas utilisé. <br><br>  Comme déjà mentionné, le nettoyage peut fonctionner avec un minimum de mémoire.  Mais si des index sont créés sur la table, une petite valeur <em>maintenance_work_mem</em> peut conduire à des analyses d'index répétées.  Il en va de même pour l'auto-nettoyage.  Idéalement, vous devez sélectionner une valeur minimale de <em>autovacuum_work_mem</em> à laquelle les analyses répétées ne se produisent pas. <br><br>  Nous avons vu que pour surveiller le nettoyage, vous pouvez utiliser le paramètre VERBOSE (mais il ne peut pas être spécifié pour le nettoyage automatique) ou la vue pg_stat_progress_vacuum (mais il n'affiche que les informations actuelles).  Par conséquent, le principal moyen de surveiller <em>le nettoyage automatique</em> est le paramètre <em>log_autovacuum_min_duration</em> , qui affiche des informations dans le journal des messages du serveur.  Par défaut, il est désactivé (défini sur -1).  Il y a une raison pour activer ce paramètre (à une valeur de 0, des informations sur tous les démarrages d'autonettoyage seront affichées) et observer les chiffres. <br><br>  Voici à quoi ressemble la sortie: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> log_autovacuum_min_duration = <span class="hljs-number"><span class="hljs-number">0</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_reload_conf();</code> </pre><pre> <code class="plaintext hljs"> pg_reload_conf ---------------- t (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> autovac <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'C'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id &lt;= <span class="hljs-number"><span class="hljs-number">31</span></span>;</code> </pre><br><pre> <code class="plaintext hljs">student$ tail -n 7 /var/log/postgresql/postgresql-11-main.log</code> </pre><pre> <code class="plaintext hljs">2019-05-21 11:59:55.675 MSK [9737] LOG: automatic vacuum of table "test.public.autovac": index scans: 0 pages: 0 removed, 18 remain, 0 skipped due to pins, 0 skipped frozen tuples: 31 removed, 1000 remain, 0 are dead but not yet removable, oldest xmin: 4040 buffer usage: 78 hits, 0 misses, 0 dirtied avg read rate: 0.000 MB/s, avg write rate: 0.000 MB/s system usage: CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s 2019-05-21 11:59:55.676 MSK [9737] LOG: automatic analyze of table "test.public.autovac" system usage: CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s</code> </pre><br>  Toutes les informations nécessaires sont présentes ici. <br><br>  Rappelez-vous que, souvent, vous ne devez pas augmenter la taille de la mémoire, mais diminuer le seuil de nettoyage afin que moins de données soient traitées à la fois. <br><br>  Il peut également être judicieux de surveiller la longueur de la liste des tables qui doivent être nettoyées à l'aide des vues ci-dessus.  Une augmentation de la longueur de la liste indiquera que l'autonettoyage n'a pas le temps de faire son travail et que les paramètres doivent être modifiés. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">À suivre</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr452762/">https://habr.com/ru/post/fr452762/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr452750/index.html">Nextcloud à l'intérieur et à l'extérieur d'OpenLiteSpeed: configurer le proxy inverse</a></li>
<li><a href="../fr452752/index.html">BigData fait maison. Partie 1. Pratique Spark Streaming sur un cluster AWS</a></li>
<li><a href="../fr452754/index.html">19% des images Docker les plus populaires n'ont pas de mot de passe root</a></li>
<li><a href="../fr452756/index.html">Création de Tower Defense dans Unity: Enemies</a></li>
<li><a href="../fr452760/index.html">Vitamine D. Boire ou ne pas boire, telle est la question. (Ou une histoire sur la façon dont j'ai réussi une analyse qui ne m'a pas été prescrite)</a></li>
<li><a href="../fr452764/index.html">[Peter] Rencontre JUG.ru avec Sergei Melnikov - Profilage à la vitesse supraluminique: théorie et pratique</a></li>
<li><a href="../fr452766/index.html">La technologie de streaming progressif, ou comment regarder des vidéos 4k sur le réseau, sans frises</a></li>
<li><a href="../fr452768/index.html">Comment concevoir un produit si vous décidez d'entrer sur le marché étranger</a></li>
<li><a href="../fr452772/index.html">5 techniques avancées de test Go</a></li>
<li><a href="../fr452774/index.html">Dell XPS 13 9380: un ordinateur portable fiable et très compact pour les affaires sérieuses</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>