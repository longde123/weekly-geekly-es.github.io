<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚓 🤘 🦗 Los 10 mejores informes de la conferencia C ++ Rusia 2018: videos completos, diapositivas, comentarios 👆🏾 🗿 📴</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En este artículo encontrará los diez mejores informes de Andrei Alexandrescu, David Vandervoord, John Kalb y muchos otros. 


 Características del com...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Los 10 mejores informes de la conferencia C ++ Rusia 2018: videos completos, diapositivas, comentarios</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/442498/"><p>  En este artículo encontrará los diez mejores informes de Andrei Alexandrescu, David Vandervoord, John Kalb y muchos otros. </p><br><p>  Características del compilador de C ++, asincronía, subprocesamiento múltiple, concurrencia, modelo de memoria, algoritmos y STL, metaprogramación y reflexión, muchos temas. </p><br><p><img src="https://habrastorage.org/webt/dd/1j/qg/dd1jqg0p95lbo0z3vxcd8tldp68.png"></p><br><p>  Todas estas son las grabaciones de la conferencia C ++ Rusia, la más grande de la historia.  Ochocientos participantes, una sala bastante grande, oradores de fama mundial.  Ha pasado un año, pero la mayoría de los informes no han perdido su relevancia.  Sin embargo, no es sorprendente, solo esos informes llegan a la cima según los participantes. </p><br><p>  El formato es el siguiente: </p><br><ul><li>  Video obligatorio de YouTube </li><li>  Diapositivas, si hay alguna </li><li>  Una descripción detallada del informe en ruso. </li><li>  Breve biografía del orador. </li></ul><br><p>  Además, tienes los comentarios de Habr para discutir lo que viste.  La publicidad en YouTube está desactivada, nadie interferirá.  Hay todo para comenzar a mirar ahora mismo. </p><a name="habracut"></a><br><h1 id="10-memory-management-tips--tricks">  10. Consejos y trucos para la gestión de la memoria </h1><br><p>  <em>Alexey Salmin</em> </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/dFquxC6qTSA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p> En 2017, la cuestión de elegir un asignador en C ++ no pierde relevancia.  <code>std::pmr</code> una nueva forma al estándar para elegir un asignador local para contenedores ( <code>std::pmr</code> ), <code>tcmalloc</code> global y <code>jemalloc</code> continúan evolucionando, así como las interfaces del núcleo en las que confían.  Este informe está dedicado al "piso inferior" del diseño: las características de <code>mmap</code> y <code>madvise</code> en el kernel de Linux y el impacto de estas características en el rendimiento de los asignadores. </p><br><p>  <strong>Sobre el orador</strong> </p><br><p><img width="200" align="left" src="https://habrastorage.org/webt/af/tc/jo/aftcjoxcd7i-evyuqchtxepwcgs.jpeg">  Alexey Salmin se graduó de la MMU NSU, se dedicó a la computación simbólica y al análisis estático, trabajó en Intel en Novosibirsk.  Desde 2016, ha estado trabajando en la oficina de Yandex Moscú, desarrollando búsquedas backend en tiempo real. <br clear="all"></p><br><hr><br><h1 id="9-best-practices-for-concurrency-in-modern-c">  9. Mejores prácticas para la concurrencia en C ++ moderno </h1><br><p>  <em>Rainer grimm</em> </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/oHA1W2OJgXA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Diapositivas</a> </p><br><p>  La estandarización de C ++ 11 nos dio un modelo de memoria y multihilo.  Hay cosas estándar en la biblioteca como atómicas, hilos, tareas, bloqueos, variables condicionales.  El modelo de memoria proporciona garantías para el uso de subprocesos múltiples de estas unidades base. </p><br><p>  Han pasado siete años, la práctica del uso seguro de modelos de subprocesamiento múltiple y memoria.  En este informe, aprendemos en detalle sobre estas prácticas: sobre las reglas generales de multihilo y las reglas especiales para las primitivas de la biblioteca y el modelo de memoria.  Los temas tratados abarcan temas más amplios que solo el lenguaje C ++. </p><br><p>  <strong>Sobre el orador</strong> </p><br><p><img width="200" align="left" src="https://habrastorage.org/webt/bh/7d/ox/bh7dox26upueje-gqfd4ofadglo.jpeg">  Rainer Grimm trabajó como arquitecto, líder de equipo e instructor durante más de 20 años.  En su tiempo libre, le gusta escribir artículos sobre C ++, Python y Haskell y hablar en conferencias.  Dirige un blog llamado Modern C ++.  Actualmente es un orador sobre los temas de C ++ y Python modernos.  O'Reilly y Leanpub publican varios de sus libros: "C ++ 11 für Programmierer", "C ++", "C ++ - Standardbiliothek", "The C ++ Standard Library". <br clear="all"></p><br><hr><br><h1 id="8-2020-a-void_t-odyssey">  8.2020: Una odisea void_t </h1><br><p>  <em>Ivan Čukić</em> </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/dZyH01tyIsA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Diapositivas</a> </p><br><p>  C ++ siempre ha tenido un poderoso subconjunto del lenguaje de metaprogramación que permite a los desarrolladores realizar trucos mágicos como la introspección estática para garantizar la ejecución polimórfica sin herencia.  El problema es que esta sintaxis es muy pervertida y demasiado detallada, todo esto hace que la metaprogramación sea una tarea bastante impresionante. </p><br><p>  Las últimas mejoras en el estándar, combinadas con las nuevas características de C ++ 20, hacen que la metaprogramación sea más fácil y los metaprogramas en sí mismos sean más legibles y comprensibles. </p><br><p>  En esta charla, veremos las técnicas modernas de metaprogramación, centrándonos en la <code>void_t</code> mágica void_t. </p><br><p>  Por cierto, en C ++ Rusia 2019 en Moscú, Ivan dará una presentación sobre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Diseño de C ++ solo para movimiento"</a> y también llevará a cabo la capacitación <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Programación funcional aplicada en C ++"</a> : está STL lejos de la programación funcional, que son objetos funcionales, std :: invoke y mónadas , mónadas, mónadas.  Y algunas mónadas más.  El entrenamiento de Ivan no es para el nivel de entrada, será adecuado para los medios que desean abrir más las puertas de la percepción. </p><br><p>  <strong>Sobre el orador</strong> </p><br><p><img width="200" align="left" src="https://habrastorage.org/webt/my/we/wd/mywewdawivogg0fxa8zhxnortdi.jpeg">  Ivan trabaja en el departamento de doctorado en informática, Facultad de Matemáticas, Universidad de Belgrado, y se especializa en el diseño de lenguajes de programación.  Un colaborador de toda la vida de KDE trabajando en Plasma y marcos de bajo nivel para analizar y gestionar las acciones de los usuarios.  Mantenedor KActivities, Contour y Lancelot. <br clear="all"></p><br><hr><br><h1 id="7-modern-c-parallelism-from-cpu-to-gpu">  7. Paralelismo moderno de C ++ de la CPU a la GPU </h1><br><p>  <em>Marca Simon</em> </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/1Icr9ht_hhk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Diapositivas</a> </p><br><p>  La programación paralela se puede utilizar para beneficiarse de arquitecturas heterogéneas y de múltiples núcleos, lo que aumenta significativamente el rendimiento del software.  C ++ moderno ha recorrido un largo camino en la simplificación del proceso de programación paralela mediante la introducción de abstracciones de alto y bajo nivel.  C ++ 17 ha avanzado aún más y nos ha dado nuevos algoritmos paralelos de alto nivel, y se espera aún más de C ++ 20.  En este informe, participaremos en una revisión de las utilidades existentes para organizar el paralelismo y mirar hacia el futuro, donde las GPU y los sistemas heterogéneos recibirán soporte con nuevas características de la biblioteca estándar, y veremos nuevos estándares como SYCL. </p><br><p>  <strong>Sobre el orador</strong> </p><br><p><img width="200" align="left" src="https://habrastorage.org/webt/df/d7/ge/dfd7gedc98ckz7nvemcxwsnmtrm.jpeg">  Simon es un desarrollador de cadenas de herramientas GPGPU con un enfoque en C ++.  A los insalubres les encanta la metaprogramación de plantillas y los lados más oscuros del lenguaje.  Puede encontrarlo fácilmente en los comentarios en el canal StackOverflow, C ++ en Slack o en las reuniones de la comunidad C ++ Edimburgo, donde es uno de los organizadores.  Le gusta hablar sobre cuestiones de formalismo en el lenguaje, patrones pirateados, cerveza, whisky, cine experimental y el trabajo de Carly Rae Jepsen. <br clear="all"></p><br><hr><br><h1 id="6-pamyat--idealnaya-abstrakciya">  6. La memoria es la abstracción perfecta. </h1><br><p>  <em>Fedor Short</em> </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/i87W3KyZgPw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Diapositivas</a> </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* ptr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>; *ptr = <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> ptr;</code> </pre> <br><p>  ¿Qué sucede realmente cuando se ejecutan estas 3 líneas de código?  Examinaremos el asignador de memoria, el sistema operativo y el hardware moderno para dar una respuesta exhaustiva a esta pregunta. </p><br><p>  <strong>Sobre el orador</strong> </p><br><p><img width="200" align="left" src="https://habrastorage.org/webt/oj/ls/gu/ojlsguqgqov5g0utbwku6ydt1xy.png">  Fedor, graduado de Fiztekh, participó en el comercio de alta frecuencia en la bolsa de valores de Moscú.  Trabaja en Yandex, desarrolla un sistema de almacenamiento y procesamiento de datos YT.  Enseña C ++ en el primer año de la escuela de análisis de datos. <br clear="all"></p><br><hr><br><h1 id="5-105-stl-algorithms-in-less-than-an-hour">  5.105 Algoritmos STL en menos de una hora </h1><br><p>  <em>Jonathan boccara</em> </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Diapositivas</a> </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/tO_drboJfxs" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Todos sabemos que sería bueno conocer los algoritmos STL.  Utilizándolos en la construcción de arquitectura, puede hacerlo más expresivo y confiable.  A veces es muy significativo y espectacular. </p><br><p>  ¿Has llegado a la realización de tus algoritmos? </p><br><p>  En este informe, verá los 105 algoritmos, incluidos los agregados en los estándares 11 y 17.  Pero esto no es solo una enumeración: la esencia del informe es mostrar la presencia en estos algoritmos del sistema, los grupos y patrones en los que están organizados, y cómo se relacionan entre sí. </p><br><p>  Este panorama general es la mejor manera de recordarlos a todos y comprenderlos como un conjunto completo de herramientas y formas de hacer que el código sea más expresivo y más confiable. </p><br><p>  <strong>Sobre el orador</strong> </p><br><p><img width="200" align="left" src="https://habrastorage.org/webt/bq/gu/jm/bqgujmdda3wdxrdfnhag914coqa.jpeg">  Jonathan Boccara adora C ++ y, en particular, los problemas de escribir un código expresivo comprensible.  En particular, es por eso que dirige el blog Fluent C ++.  También trabaja como desarrollador senior en Murex, donde maneja enormes bases de código C ++ para su uso en finanzas.  Tienen una práctica interesante en la compañía todos los días para hacer informes cortos en el formato <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"diarios"</a> , que él dirige. <br clear="all"></p><br><hr><br><h1 id="4-asinhronnost-v-programmirovanii">  4. Asincronía en la programación. </h1><br><p>  <em>Ivan Puzyrevsky</em> </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/g7dno0SupKY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  En el campo del desarrollo de aplicaciones multiproceso o distribuidas altamente cargadas, uno puede escuchar cada vez más conversaciones sobre el código asincrónico, incluida la especulación sobre la necesidad (falta de necesidad) de tener en cuenta la asincronía en el código, sobre la comprensibilidad (incomprensibilidad) del código asincrónico y su eficiencia (ineficiencia).  En este informe, trataremos de profundizar en el área temática: analizaremos lo que es asincronía;  cuando surge;  cómo afecta el código que escribimos y el lenguaje de programación que usamos.  Trataremos de averiguar qué futuros y promesas tienen que ver con eso, hablemos un poco sobre las corutinas y los actores.  Afectaremos a JavaScript y a los sistemas operativos.  El propósito del informe es hacer que los compromisos que surgen con uno u otro enfoque para el desarrollo de software multiproceso o distribuido sean más explícitos. </p><br><p>  <strong>Sobre el orador</strong> </p><br><p><img width="200" align="left" src="https://habrastorage.org/webt/t0/ar/cc/t0arccvs0q4e-vo66f6uj1mss8q.jpeg">  Ivan comenzó a trabajar en Yandex en 2009 en el departamento de tecnologías lingüísticas en Search.  Ahora se dedica al desarrollo de almacenamiento distribuido y sistemas de procesamiento de datos.  Graduado del Departamento de Lógica Matemática y Teoría de Algoritmos de la Facultad de Mecánica y Matemáticas de la Universidad Estatal de Moscú.  Profesor de ShAD. <br clear="all"></p><br><hr><br><h1 id="3-c-today-the-beast-is-back">  3. C ++ hoy: la bestia está de vuelta </h1><br><p>  <em>Jon kalb</em> </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/aI64OFHJDc4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Diapositivas</a> </p><br><p>  Este es un informe basado en parte en C ++ Today de O'Reilly: The Beast is Back.  En este informe, especularemos un poco por qué los ingenieros que desean escribir código productivo eligen C ++.  John presentará la perspectiva histórica de centrarse en C ++, explicará cómo vive la comunidad C ++ en este momento y hacia dónde se dirige el lenguaje y su audiencia.  Recientemente, todos se han interesado en un código efectivo, desde fabricantes de teléfonos móviles hasta grandes centros de datos, por lo que C ++ con sus bibliotecas de código abierto se ha convertido nuevamente en un tema candente.  Este informe explica claramente por qué la mayoría de los ingenieros eligen C ++ para todo esto.  Hay un bosquejo general de C ++ en una escala histórica con explicaciones de los puntos de crecimiento y disminución de la popularidad. </p><br><p>  <strong>Sobre el orador</strong> </p><br><p><img width="200" align="left" src="https://habrastorage.org/webt/r-/i7/zw/r-i7zwcioq1nvt-ed8bst0uvhvs.jpeg">  John ha estado codificando en C ++ por más de 20 años.  Durante este tiempo, logró participar en proyectos C ++ de Amazon, Apple, Dow Chemical, Intuit, Lotus, Microsoft, Netscape, Sun, Yahoo!  y en un par de compañías de las que nadie había oído hablar de todos modos.  Es el presidente del Comité Directivo de Boost, y también participa en el programa de seguimiento de C ++ en Silicon Valley Code Camp y es uno de los directores de C ++ Now (también conocido como BoostCon).  En 2014, recibió el profesional más valioso de Microsoft. <br clear="all"></p><br><hr><br><h1 id="2-reflective-metaprogramming-in-c">  2. Metaprogramación reflexiva en C ++ </h1><br><p>  <em>Daveed vandevoorde</em> </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/YyUEVTXhYt4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Diapositivas</a> </p><br><p>  Una vez que el comité de estandarización de C ++ organizó un subgrupo "SG-7", que estudia las posibilidades de implementar la reflexión.  Recientemente, este grupo también participó en la metaprogramación y tomó varias decisiones importantes sobre cómo se vería la posible solución.  En este informe, veremos el pasado, que nos trajo a una vida así, y discutiremos las posibilidades de soporte nativo para la "metaprogramación reflexiva" en C ++. </p><br><p>  <strong>Sobre el orador</strong> </p><br><p><img width="200" align="left" src="https://habrastorage.org/webt/yo/l6/ns/yol6nsli9pcu42zabirattqstqq.jpeg">  David es un científico belga que vive con Princeton en los Estados Unidos.  Es vicepresidente de ingeniería en Edison Design Group, donde contribuye principalmente a su propia interfaz para el compilador de C ++.  Participa activamente en el Comité de Normalización de C ++, donde participa en la evolución del lenguaje central. <br clear="all"></p><br><hr><br><h1 id="1-unexpected-expected">  1. Inesperado esperado </h1><br><p>  <em>Andrei Alexandrescu</em> </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/CGwk3i1bGQI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Escribir código resistente a errores es dolor, dolor en cualquier idioma.  Excepciones, aunque son una forma políticamente correcta de señalar errores en C ++, pero en muchas aplicaciones tiene que usar códigos de retorno, por razones relacionadas con la facilidad de comprensión, la facilidad de procesamiento local, la eficiencia del código generado, etc. </p><br><p>  En este informe, veremos cómo la teoría y la práctica se pueden combinar para resolver problemas de manejo de errores.  El tipo <code>Expected</code> se puede usar tanto localmente (en el estilo de los códigos de retorno) como centralmente (en el estilo de las excepciones), combinando las ventajas de ambos enfoques. </p><br><p>  <strong>Sobre el orador</strong> </p><br><p><img width="200" align="left" src="https://habrastorage.org/webt/on/zx/h3/onzxh31kcjuk_ypu7k46e_q8pqk.jpeg">  El desarrollador rumano Andrei Alexandrescu es un experto en una amplia gama de temas, incluida la arquitectura e implementación de sistemas de software, el diseño de lenguajes de programación, la arquitectura de bibliotecas, todos los aspectos de C ++ y D, el aprendizaje automático y el análisis de lenguajes naturales.  Su enfoque creativo para resolver problemas, el conocimiento más amplio y el carisma hacen de Andrei uno de los oradores más populares del mundo. </p><br><p>  Los libros y artículos de Andrei han influido en toda la industria.  Es autor de libros superventas como Modern C ++ Design, C ++ Coding Standards (junto con Herb Sutter), The D Programming Language y artículos como Simplify Your Exception-Safe Code - Forever (escrito con Petru Marginean) y Mojo: Move of Joint Objects.  Una lista completa de sus obras se puede <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">encontrar aquí</a> . <br clear="all"></p><br><blockquote>  La próxima conferencia de C ++ Rusia se llevará a cabo del 19 al 20 de abril en Moscú, es decir, muy pronto.  Un nuevo programa, nuevos oradores y otro día entero de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">entrenamiento</a> .  El programa se puede ver <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en el sitio web oficial</a> , las <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">entradas</a> también se pueden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">comprar allí</a> . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/442498/">https://habr.com/ru/post/442498/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../442484/index.html">Lo que brilla Crew Dragon Roscosmos</a></li>
<li><a href="../442486/index.html">ReactOS 0.4.11 - Cien más aplicaciones</a></li>
<li><a href="../442492/index.html">Todos pueden aprender inglés fácilmente</a></li>
<li><a href="../442494/index.html">Componente Figma y organización de instancias usando Userpic como ejemplo</a></li>
<li><a href="../442496/index.html">Cerdo corporativo</a></li>
<li><a href="../442500/index.html">Analizador estático Detekt para Kotlin</a></li>
<li><a href="../442502/index.html">Transformamos el lugar de trabajo en un titular por $ 200</a></li>
<li><a href="../442504/index.html">Proxy PHP Xdebug: cuando las características estándar de Xdebug no son suficientes</a></li>
<li><a href="../442506/index.html">¿Se castiga a Rusia por el comercio ilegal de datos personales?</a></li>
<li><a href="../442508/index.html">Cómo udalenka acelera la innovación en GitLab</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>