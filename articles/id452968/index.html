<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐋 🏢 🤬 Indeks dalam PostgreSQL - 10 (Bloom) 😩 🙏🏿 👵🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pada artikel sebelumnya kita membahas mesin pengindeksan PostgreSQL dan antarmuka metode akses, serta indeks hash , B-tree , GiST , SP-GiST , GIN , RU...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Indeks dalam PostgreSQL - 10 (Bloom)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/452968/">  Pada artikel sebelumnya kita membahas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mesin pengindeksan</a> PostgreSQL dan antarmuka metode akses, serta <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">indeks hash</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">B-tree</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GiST</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SP-GiST</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GIN</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RUM</a> , dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">BRIN</a> .  Tapi kita masih perlu melihat indeks Bloom. <br><br><h1>  Bloom </h1><br><h2>  Konsep umum </h2><br>  Filter Bloom klasik adalah struktur data yang memungkinkan kami memeriksa keanggotaan elemen dengan cepat.  Filter ini sangat kompak, tetapi memungkinkan positif palsu: ia dapat secara keliru menganggap suatu elemen sebagai anggota suatu himpunan (false positive), tetapi itu tidak diizinkan untuk mempertimbangkan suatu elemen himpunan tidak menjadi anggota (false negative) . <br><br>  Filter adalah array dari <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-2">m</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-1"> m </script>  bit (juga disebut <em>tanda tangan</em> ) yang awalnya diisi dengan nol. <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-3"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-4">k</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-2"> k </script>  dipilih fungsi hash yang berbeda yang memetakan setiap elemen set ke <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-5"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-6">k</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-3"> k </script>  sedikit tanda tangan.  Untuk menambahkan elemen ke set, kita perlu mengatur masing-masing bit ini di signature menjadi satu.  Akibatnya, jika semua bit yang terkait dengan elemen diatur ke satu, elemen dapat menjadi anggota set, tetapi jika setidaknya satu bit sama dengan nol, elemen tidak pasti diatur. <br><br>  Dalam kasus DBMS, sebenarnya kita miliki <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-7"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-8">N</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-4"> N </script>  filter terpisah dibangun untuk setiap baris indeks.  Sebagai aturan, beberapa bidang termasuk dalam indeks, dan nilainya dari bidang ini yang menyusun set elemen untuk setiap baris. <br><br>  Dengan memilih panjang tanda tangan <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-9"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-10">m</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-5-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-5"> m </script>  , kita dapat menemukan trade-off antara ukuran indeks dan probabilitas positif palsu.  Area aplikasi untuk indeks Bloom adalah tabel besar, signifikan "lebar" yang akan ditanyakan menggunakan filter pada masing-masing bidang.  Metode akses ini, seperti BRIN, dapat dianggap sebagai akselerator pemindaian sekuensial: semua kecocokan yang ditemukan oleh indeks harus diperiksa ulang dengan tabel, tetapi ada kemungkinan untuk menghindari mempertimbangkan sebagian besar baris sama sekali. <br><a name="habracut"></a><br><h2>  Struktur </h2><br>  Kami sudah membahas pohon tanda tangan dalam konteks metode akses <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GiST</a> .  Tidak seperti pohon-pohon ini, indeks Bloom adalah struktur datar.  Ini terdiri dari metapage diikuti oleh halaman reguler dengan baris indeks.  Setiap baris indeks berisi tanda tangan dan referensi ke baris tabel (TID), seperti yang ditunjukkan secara skematis dalam gambar. <br><br><img src="https://habrastorage.org/webt/tl/v3/xp/tlv3xpdlc4iw25iuma6yurx8wto.png"><br><br><h3>  Penciptaan dan pemilihan nilai parameter </h3><br>  Saat membuat indeks Bloom, ukuran total tanda tangan ("panjang") ditentukan, serta jumlah bit yang akan ditetapkan <em>untuk setiap bidang individual yang</em> termasuk dalam indeks ("col1" - "col32"): <br><br><pre><code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> bloom(...) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> (length=..., col1=..., col2=..., ...);</code> </pre> <br>  Cara untuk menentukan jumlah bit terlihat aneh: angka-angka ini harus menjadi parameter kelas operator dan bukan indeks.  Masalahnya adalah bahwa kelas operator tidak dapat dipisah-pisahkan saat ini, meskipun <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bekerja pada ini</a> sedang berlangsung. <br><br><blockquote>  Sayangnya, tidak ada kemajuan lebih lanjut tentang ini. <br></blockquote><br>  Bagaimana kita bisa memilih nilai yang sesuai?  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Teori</a> menyatakan bahwa diberi probabilitas <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-11"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-12">p</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-6-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-6"> p </script>  dari filter untuk mengembalikan false positive, jumlah bit tanda tangan yang optimal dapat diperkirakan sebagai <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-13"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-14">m</span><span class="MJXp-mo" id="MJXp-Span-15" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mo" id="MJXp-Span-16" style="margin-left: 0.267em; margin-right: 0.267em;">−</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-17">n</span><span class="MJXp-mtext" id="MJXp-Span-18">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-19">l</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-20">o</span><span class="MJXp-msubsup" id="MJXp-Span-21"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-22" style="margin-right: 0.05em;">g</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-23" style="vertical-align: -0.4em;">2</span></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-24">p</span><span class="MJXp-mrow" id="MJXp-Span-25"><span class="MJXp-mo" id="MJXp-Span-26" style="margin-left: 0.111em; margin-right: 0.111em;">/</span></span><span class="MJXp-mtext" id="MJXp-Span-27">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-28">l</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-29">n</span><span class="MJXp-mn" id="MJXp-Span-30">2</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-7-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-7"> m = −n \ log_2 p / \ ln 2 </script>  dimana <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-31"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-32">n</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-8-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-8"> n </script>  adalah jumlah bidang dalam indeks dan jumlah bit yang akan ditetapkan adalah <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-33"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-34">k</span><span class="MJXp-mo" id="MJXp-Span-35" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mo" id="MJXp-Span-36" style="margin-left: 0.267em; margin-right: 0.267em;">−</span><span class="MJXp-mtext" id="MJXp-Span-37">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-38">l</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-39">o</span><span class="MJXp-msubsup" id="MJXp-Span-40"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-41" style="margin-right: 0.05em;">g</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-42" style="vertical-align: -0.4em;">2</span></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-43">p</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-9-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-9"> k = - \ log_2 p </script>  . <br><br>  Tanda tangan disimpan di dalam indeks sebagai array angka integer dua-byte, jadi nilai <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-44"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-45">m</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-10-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-10"> m </script>  dapat dengan aman dibulatkan ke <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-46"><span class="MJXp-mn" id="MJXp-Span-47">16</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-11-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-11"> 16 </script>  . <br><br>  Saat memilih probabilitas <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-48"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-49">p</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-12-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-12"> p </script>  , kita perlu memperhitungkan ukuran indeks, yang kira-kira sama <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-50"><span class="MJXp-mo" id="MJXp-Span-51" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-52">m</span><span class="MJXp-mrow" id="MJXp-Span-53"><span class="MJXp-mo" id="MJXp-Span-54" style="margin-left: 0.111em; margin-right: 0.111em;">/</span></span><span class="MJXp-mn" id="MJXp-Span-55">8</span><span class="MJXp-mo" id="MJXp-Span-56" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mn" id="MJXp-Span-57">6</span><span class="MJXp-mo" id="MJXp-Span-58" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-59">N</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-13-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-13"> (m / 8 + 6) N </script>  dimana <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-60"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-61">N</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-14-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-14"> N </script>  adalah jumlah baris dalam tabel dan <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-62"><span class="MJXp-mn" id="MJXp-Span-63">6</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-15-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-15"> 6 </script>  adalah ukuran pointer TID dalam bytes. <br><br>  Beberapa hal yang perlu diperhatikan: <br><br><ul><li>  Probabilitas <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-64"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-65">p</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-16-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-16"> p </script>  dari false positive berhubungan dengan satu filter, oleh karena itu, kami berharap untuk mendapatkannya <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-66"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-67">N</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-68">p</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-17-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-17"> Np </script>  false positive selama pemindaian tabel (tentu saja, untuk kueri yang mengembalikan beberapa baris).  Misalnya, untuk tabel dengan satu juta baris dan probabilitas 0,01, dalam rencana kueri, rata-rata, kita dapat mengharapkan "Baris Dihapus oleh Indeks Periksa kembali: 10000". </li><li>  Filter Bloom adalah struktur probabilistik.  Masuk akal untuk berbicara tentang angka-angka tertentu hanya ketika rata-rata nilai cukup banyak, sementara dalam setiap kasus tertentu, kita bisa mendapatkan apa pun yang dapat kita pikirkan. </li><li>  Perkiraan di atas didasarkan pada model matematika yang ideal dan beberapa asumsi.  Dalam praktiknya, hasilnya cenderung lebih buruk.  Jadi, jangan melebih-lebihkan rumus: mereka hanya sarana untuk memilih nilai awal untuk eksperimen di masa depan. </li><li>  Untuk setiap bidang secara individual, metode akses memungkinkan kita untuk memilih jumlah bit yang akan ditetapkan.  Ada asumsi yang masuk akal bahwa sebenarnya angka optimal tergantung pada distribusi nilai-nilai dalam kolom.  Untuk menyelam lebih dalam, Anda dapat membaca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel ini</a> (referensi untuk penelitian lain dipersilahkan).  Tapi baca kembali item sebelumnya. </li></ul><br><h3>  Memperbarui </h3><br>  Saat baris baru dimasukkan dalam tabel, tanda tangan dibuat: untuk nilai semua bidang yang diindeks, semua bit yang terkait diatur ke satu.  Secara teori, kita harus memiliki k fungsi hash yang berbeda, sementara dalam praktiknya, generator bilangan pseudo-acak mencukupi, yang benihnya dipilih setiap kali dengan bantuan satu-satunya fungsi hash. <br><br>  Filter Bloom biasa tidak mendukung penghapusan elemen, tetapi ini tidak diperlukan untuk indeks Bloom: ketika baris tabel dihapus, seluruh tanda tangan dihapus, bersama dengan baris indeks. <br><br>  Seperti biasa, pembaruan terdiri dari penghapusan versi baris yang sudah usang dan penyisipan yang baru (tanda tangan dihitung dari awal). <br><br><h3>  Memindai </h3><br>  Karena satu-satunya hal yang dapat dilakukan filter Bloom adalah memeriksa keanggotaan suatu elemen dalam satu set, satu-satunya operasi yang didukung oleh indeks Bloom adalah pemeriksaan kesetaraan (seperti dalam indeks hash). <br><br>  Seperti yang telah kami sebutkan, indeks Bloom datar, sehingga dalam perjalanan akses indeks, selalu dibaca berturut-turut dan seluruhnya.  Dalam proses membaca, bitmap dibuat, yang kemudian digunakan untuk mengakses tabel. <br><br>  Dalam akses indeks reguler, diasumsikan bahwa beberapa baris indeks harus dibaca dan, di samping itu, mereka dapat segera dibutuhkan lagi, oleh karena itu, mereka disimpan dalam cache buffer.  Namun, pembacaan indeks Bloom sebenarnya adalah pemindaian berurutan.  Untuk mencegah penggusuran informasi yang berguna dari cache, pembacaan dilakukan melalui cincin buffer kecil, persis sama seperti untuk pemindaian berurutan tabel. <br><br>  Kita harus memperhitungkan bahwa semakin besar ukuran indeks Bloom, semakin tidak menarik bagi perencana.  Ketergantungan ini linear, tidak seperti indeks seperti pohon. <br><br><h2>  Contoh </h2><br><h3>  Meja </h3><br>  Mari kita lihat indeks Bloom dengan contoh tabel besar "flight_bi" dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel sebelumnya</a> .  Untuk mengingatkan Anda, ukuran tabel ini adalah 4 GB dengan sekitar 30 juta baris.  Definisi tabel: <br><br><pre> <code class="pgsql hljs">demo=# \d flights_bi</code> </pre><pre> <code class="plaintext hljs"> Table "bookings.flights_bi" Column | Type | Collation | Nullable | Default --------------------+--------------------------+-----------+----------+--------- airport_code | character(3) | | | airport_coord | point | | | airport_utc_offset | interval | | | flight_no | character(6) | | | flight_type | text | | | scheduled_time | timestamp with time zone | | | actual_time | timestamp with time zone | | | aircraft_code | character(3) | | | seat_no | character varying(4) | | | fare_conditions | character varying(10) | | | passenger_id | character varying(20) | | | passenger_name | text | | |</code> </pre><br>  Pertama mari kita buat ekstensi: meskipun indeks Bloom termasuk dalam pengiriman standar dimulai dengan versi 9.6, itu tidak tersedia secara default. <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extension</span></span> bloom;</code> </pre><br>  Terakhir kali kami dapat mengindeks tiga bidang menggunakan BRIN ("dijadwalkan_time", "actual_time", "airport_utc_offset").  Karena indeks Bloom tidak bergantung pada urutan fisik data, mari kita coba untuk memasukkan hampir semua bidang tabel dalam indeks.  Namun, mari kita mengecualikan bidang waktu ("schedule_time" dan "actual_time"): metode ini hanya mendukung perbandingan untuk kesetaraan, tetapi kueri untuk waktu yang tepat hampir tidak menarik bagi siapa pun (kita dapat, bagaimanapun, membangun indeks pada ekspresi, membulatkan waktu ke hari, tetapi kami tidak akan melakukan ini).  Kami juga harus mengecualikan koordinat geografis bandara ("airport_coord"): melihat ke depan, tipe "titik" tidak didukung. <br><br>  Untuk memilih nilai parameter, mari kita atur probabilitas false positive ke 0,01 (mengingat bahwa sebenarnya kita akan mendapatkan lebih banyak).  Rumus di atas untuk <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-69"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-70">n</span><span class="MJXp-mo" id="MJXp-Span-71" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-72">9</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-18-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-18"> n = 9 </script>  dan <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-73"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-74">N</span><span class="MJXp-mo" id="MJXp-Span-75" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-76">30</span><span class="MJXp-mspace" id="MJXp-Span-77" style="width: 0.167em; height: 0em;"></span><span class="MJXp-mn" id="MJXp-Span-78">000</span><span class="MJXp-mspace" id="MJXp-Span-79" style="width: 0.167em; height: 0em;"></span><span class="MJXp-mrow" id="MJXp-Span-80"><span class="MJXp-mo" id="MJXp-Span-81" style="margin-left: 0em; margin-right: 0em;">$</span></span><span class="MJXp-mn" id="MJXp-Span-82">00</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-19-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-19"> N = 30 \, 000 \, $ 00</script>  berikan ukuran tanda tangan 96 bit dan sarankan pengaturan 7 bit per elemen.  Ukuran perkiraan indeks adalah 515 MB (sekitar seperdelapan tabel). <br><br>  (Dengan ukuran tanda tangan minimal 16 bit, rumus menjanjikan ukuran indeks yang dua kali lebih kecil, tetapi mengizinkan untuk hanya mengandalkan probabilitas 0,5, yang sangat buruk.) <br><br><h3>  Kelas operator </h3><br>  Jadi, mari kita coba membuat indeks. <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> flights_bi_bloom <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> flights_bi <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> bloom(airport_code, airport_utc_offset, flight_no, flight_type, aircraft_code, seat_no, fare_conditions, passenger_id, passenger_name) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> (length=<span class="hljs-number"><span class="hljs-number">96</span></span>, col1=<span class="hljs-number"><span class="hljs-number">7</span></span>, col2=<span class="hljs-number"><span class="hljs-number">7</span></span>, col3=<span class="hljs-number"><span class="hljs-number">7</span></span>, col4=<span class="hljs-number"><span class="hljs-number">7</span></span>, col5=<span class="hljs-number"><span class="hljs-number">7</span></span>, col6=<span class="hljs-number"><span class="hljs-number">7</span></span>, col7=<span class="hljs-number"><span class="hljs-number">7</span></span>, col8=<span class="hljs-number"><span class="hljs-number">7</span></span>, col9=<span class="hljs-number"><span class="hljs-number">7</span></span>);</code> </pre><pre> <code class="plaintext hljs">ERROR: data type character has no default operator class for access method "bloom" HINT: You must specify an operator class for the index or define a default operator class for the data type.</code> </pre><br>  Sayangnya, ekstensi hanya memberi kami dua kelas operator: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> opcname, opcintype::<span class="hljs-type"><span class="hljs-type">regtype</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_opclass <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> opcmethod = (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-type"><span class="hljs-type">oid</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_am <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> amname = <span class="hljs-string"><span class="hljs-string">'bloom'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> opcintype::<span class="hljs-type"><span class="hljs-type">regtype</span></span>::<span class="hljs-type"><span class="hljs-type">text</span></span>;</code> </pre><pre> <code class="plaintext hljs"> opcname | opcintype ----------+----------- int4_ops | integer text_ops | text (2 rows)</code> </pre><br>  Namun untungnya, cukup mudah untuk membuat kelas yang serupa untuk tipe data lainnya juga.  Kelas operator untuk metode akses Bloom harus mengandung tepat satu operator - kesetaraan - dan satu fungsi bantu - hashing.  Cara paling sederhana untuk menemukan operator dan fungsi yang diperlukan untuk tipe arbitrer adalah dengan melihat katalog sistem untuk kelas operator dari metode "hash": <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">distinct</span></span> opc.opcintype::<span class="hljs-type"><span class="hljs-type">regtype</span></span>::<span class="hljs-type"><span class="hljs-type">text</span></span>, amop.amopopr::<span class="hljs-type"><span class="hljs-type">regoperator</span></span>, ampr.amproc <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_am am, pg_opclass opc, pg_amop amop, pg_amproc ampr <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> am.amname = <span class="hljs-string"><span class="hljs-string">'hash'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> opc.opcmethod = am.oid <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amopfamily = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amoplefttype = opc.opcintype <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amoprighttype = opc.opcintype <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> ampr.amprocfamily = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> ampr.amproclefttype = opc.opcintype <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> opc.opcintype::<span class="hljs-type"><span class="hljs-type">regtype</span></span>::<span class="hljs-type"><span class="hljs-type">text</span></span>;</code> </pre><pre> <code class="plaintext hljs"> opcintype | amopopr | amproc -----------+----------------------+-------------- abstime | =(abstime,abstime) | hashint4 aclitem | =(aclitem,aclitem) | hash_aclitem anyarray | =(anyarray,anyarray) | hash_array anyenum | =(anyenum,anyenum) | hashenum anyrange | =(anyrange,anyrange) | hash_range ...</code> </pre><br>  Kami akan membuat dua kelas yang hilang menggunakan informasi ini: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OPERATOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CLASS</span></span> character_ops <span class="hljs-keyword"><span class="hljs-keyword">DEFAULT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TYPE</span></span> <span class="hljs-type"><span class="hljs-type">character</span></span> <span class="hljs-keyword"><span class="hljs-keyword">USING</span></span> bloom <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OPERATOR</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> =(<span class="hljs-type"><span class="hljs-type">character</span></span>,<span class="hljs-type"><span class="hljs-type">character</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> hashbpchar; demo=# <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OPERATOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CLASS</span></span> interval_ops <span class="hljs-keyword"><span class="hljs-keyword">DEFAULT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TYPE</span></span> <span class="hljs-type"><span class="hljs-type">interval</span></span> <span class="hljs-keyword"><span class="hljs-keyword">USING</span></span> bloom <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OPERATOR</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> =(<span class="hljs-type"><span class="hljs-type">interval</span></span>,<span class="hljs-type"><span class="hljs-type">interval</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> interval_hash;</code> </pre><br>  Fungsi hash tidak didefinisikan untuk titik (tipe "titik"), dan untuk alasan inilah kita tidak dapat membangun indeks Bloom pada bidang seperti itu (seperti halnya kita tidak dapat melakukan gabungan hash pada bidang jenis ini). <br><br>  Coba lagi: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> flights_bi_bloom <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> flights_bi <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> bloom(airport_code, airport_utc_offset, flight_no, flight_type, aircraft_code, seat_no, fare_conditions, passenger_id, passenger_name) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> (length=<span class="hljs-number"><span class="hljs-number">96</span></span>, col1=<span class="hljs-number"><span class="hljs-number">7</span></span>, col2=<span class="hljs-number"><span class="hljs-number">7</span></span>, col3=<span class="hljs-number"><span class="hljs-number">7</span></span>, col4=<span class="hljs-number"><span class="hljs-number">7</span></span>, col5=<span class="hljs-number"><span class="hljs-number">7</span></span>, col6=<span class="hljs-number"><span class="hljs-number">7</span></span>, col7=<span class="hljs-number"><span class="hljs-number">7</span></span>, col8=<span class="hljs-number"><span class="hljs-number">7</span></span>, col9=<span class="hljs-number"><span class="hljs-number">7</span></span>);</code> </pre><pre> <code class="plaintext hljs">CREATE INDEX</code> </pre><br>  Ukuran indeks adalah 526 MB, yang agak lebih besar dari yang diharapkan.  Ini karena rumus tidak memperhitungkan overhead halaman. <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> pg_size_pretty(pg_total_relation_size(<span class="hljs-string"><span class="hljs-string">'flights_bi_bloom'</span></span>));</code> </pre><pre> <code class="plaintext hljs"> pg_size_pretty ---------------- 526 MB (1 row)</code> </pre><br><h3>  Pertanyaan </h3><br>  Kami sekarang dapat melakukan pencarian menggunakan berbagai kriteria, dan indeks akan mendukungnya. <br><br>  Seperti yang telah kami sebutkan, filter Bloom adalah struktur probabilistik, oleh karena itu, efisiensi sangat tergantung pada setiap kasus tertentu.  Misalnya, mari kita lihat baris yang terkait dengan dua penumpang, Miroslav Sidorov: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flights_bi <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> passenger_name=<span class="hljs-string"><span class="hljs-string">'MIROSLAV SIDOROV'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN -------------------------------------------------------------------------------------------------- Bitmap Heap Scan on flights_bi (actual time=2639.010..3010.692 rows=2 loops=1) Recheck Cond: (passenger_name = 'MIROSLAV SIDOROV'::text) Rows Removed by Index Recheck: 38562 Heap Blocks: exact=21726 -&gt; Bitmap Index Scan on flights_bi_bloom (actual time=1065.191..1065.191 rows=38564 loops=1) Index Cond: (passenger_name = 'MIROSLAV SIDOROV'::text) Planning time: 0.109 ms Execution time: 3010.736 ms</code> </pre><br>  dan Marfa Soloveva: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flights_bi <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> passenger_name=<span class="hljs-string"><span class="hljs-string">'MARFA SOLOVEVA'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN --------------------------------------------------------------------------------------------------- Bitmap Heap Scan on flights_bi (actual time=9980.884..10142.684 rows=2 loops=1) Recheck Cond: (passenger_name = 'MARFA SOLOVEVA'::text) Rows Removed by Index Recheck: 3950168 Heap Blocks: exact=45757 lossy=67332 -&gt; Bitmap Index Scan on flights_bi_bloom (actual time=1037.588..1037.588 rows=212972 loops=1) Index Cond: (passenger_name = 'MARFA SOLOVEVA'::text) Planning time: 0.157 ms Execution time: 10142.730 ms</code> </pre><br>  Dalam satu kasus, filter hanya mengizinkan 40 ribu positif palsu dan sebanyak 4 juta di antaranya ("Baris Dihapus oleh Indeks Periksa kembali").  Waktu pelaksanaan kueri berbeda sesuai. <br><br>  Dan berikut ini adalah hasil pencarian baris yang sama dengan ID penumpang daripada nama.  Miroslav: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>) demo-# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flights_bi <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> passenger_id=<span class="hljs-string"><span class="hljs-string">'5864 006033'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------------------------------------------------------------------------------- Bitmap Heap Scan on flights_bi (actual time=13747.305..16907.387 rows=2 loops=1) Recheck Cond: ((passenger_id)::text = '5864 006033'::text) Rows Removed by Index Recheck: 9620258 Heap Blocks: exact=50510 lossy=165722 -&gt; Bitmap Index Scan on flights_bi_bloom (actual time=937.202..937.202 rows=426474 loops=1) Index Cond: ((passenger_id)::text = '5864 006033'::text) Planning time: 0.110 ms Execution time: 16907.423 ms</code> </pre><br>  Dan marfa: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flights_bi <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> passenger_id=<span class="hljs-string"><span class="hljs-string">'2461 559238'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN -------------------------------------------------------------------------------------------------- Bitmap Heap Scan on flights_bi (actual time=3881.615..3934.481 rows=2 loops=1) Recheck Cond: ((passenger_id)::text = '2461 559238'::text) Rows Removed by Index Recheck: 30669 Heap Blocks: exact=27513 -&gt; Bitmap Index Scan on flights_bi_bloom (actual time=1084.391..1084.391 rows=30671 loops=1) Index Cond: ((passenger_id)::text = '2461 559238'::text) Planning time: 0.120 ms Execution time: 3934.517 ms</code> </pre><br>  Efisiensinya jauh berbeda lagi, dan kali ini Marfa lebih beruntung. <br><br>  Perhatikan bahwa pencarian oleh dua bidang secara bersamaan akan dilakukan jauh lebih efisien karena kemungkinan false positive <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-83"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-84">p</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-20-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-20"> p </script>  berubah menjadi <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-85"><span class="MJXp-msubsup" id="MJXp-Span-86"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-87" style="margin-right: 0.05em;">p</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-88" style="vertical-align: 0.5em;">2</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-21-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-21"> p ^ 2 </script>  : <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flights_bi <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> passenger_name=<span class="hljs-string"><span class="hljs-string">'MIROSLAV SIDOROV'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> passenger_id=<span class="hljs-string"><span class="hljs-string">'5864 006033'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN -------------------------------------------------------------------------------------------------------------------- Bitmap Heap Scan on flights_bi (actual time=872.593..877.915 rows=2 loops=1) Recheck Cond: (((passenger_id)::text = '5864 006033'::text) AND (passenger_name = 'MIROSLAV SIDOROV'::text)) Rows Removed by Index Recheck: 357 Heap Blocks: exact=356 -&gt; Bitmap Index Scan on flights_bi_bloom (actual time=832.041..832.041 rows=359 loops=1) Index Cond: (((passenger_id)::text = '5864 006033'::text) AND (passenger_name = 'MIROSLAV SIDOROV'::text)) Planning time: 0.524 ms Execution time: 877.967 ms</code> </pre><br>  Namun, pencarian dengan Boolean "atau" tidak didukung sama sekali;  ini adalah batasan perencana daripada metode akses.  Tentu saja, opsi tetap membaca indeks dua kali, membangun dua bitmap, dan bergabung dengan mereka, tetapi ini kemungkinan besar terlalu mahal untuk rencana ini untuk dipilih. <br><br><h2>  Perbandingan dengan BRIN dan Hash </h2><br>  Area aplikasi dari indeks Bloom dan BRIN jelas bersinggungan.  Ini adalah tabel besar yang diinginkan untuk memastikan pencarian dengan bidang yang berbeda, akurasi pencarian dikorbankan untuk kekompakan. <br><br>  Indeks BRIN lebih kompak (katakanlah, hingga puluhan megabyte dalam contoh kami) dan dapat mendukung pencarian berdasarkan rentang, tetapi memiliki batasan kuat terkait dengan pemesanan fisik data dalam file.  Indeks Bloom lebih besar (ratusan megabita), tetapi tidak memiliki batasan kecuali ketersediaan fungsi hash yang sesuai. <br><br>  Seperti indeks Bloom, indeks hash mendukung satu-satunya operasi pemeriksaan kesetaraan.  Indeks hash memastikan akurasi pencarian yang tidak dapat diakses untuk Bloom, tetapi ukuran indeks jauh lebih besar (dalam contoh kami, satu gigabyte untuk hanya satu bidang, dan indeks hash tidak dapat dibuat di beberapa bidang). <br><br><h2>  Properti </h2><br>  Seperti biasa, mari kita lihat properti Bloom (kueri <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sudah disediakan</a> ). <br><br>  Berikut ini adalah properti dari metode akses: <br><br><pre> <code class="plaintext hljs"> amname | name | pg_indexam_has_property --------+---------------+------------------------- bloom | can_order | f bloom | can_unique | f bloom | can_multi_col | t bloom | can_exclude | f</code> </pre><br>  Jelas, metode akses memungkinkan kami untuk membuat indeks pada beberapa kolom.  Sangat tidak masuk akal untuk membuat indeks Bloom pada satu kolom. <br><br>  Properti lapisan indeks berikut tersedia: <br><br><pre> <code class="plaintext hljs"> name | pg_index_has_property ---------------+----------------------- clusterable | f index_scan | f bitmap_scan | t backward_scan | f</code> </pre><br>  Satu-satunya teknik pemindaian yang tersedia adalah pemindaian bitmap.  Karena indeks selalu dipindai seluruhnya, tidak masuk akal untuk menerapkan akses indeks reguler yang mengembalikan baris TID oleh TID. <br><br><pre> <code class="plaintext hljs"> name | pg_index_column_has_property --------------------+------------------------------ asc | f desc | f nulls_first | f nulls_last | f orderable | f distance_orderable | f returnable | f search_array | f search_nulls | f</code> </pre><br>  Hanya tanda hubung di sini;  metode ini bahkan tidak dapat memanipulasi NULLs. <br><br><h2>  Dan akhirnya: </h2><br>  Bukan tidak mungkin seri artikel ini akan dilanjutkan di masa mendatang, ketika jenis indeks minat baru muncul, tetapi sekarang saatnya untuk berhenti. <br><br>  Saya ingin menyampaikan penghargaan kepada kolega-kolega saya dari Postgres Professional (beberapa di antaranya adalah penulis dari banyak metode akses yang dibahas) karena membaca draf dan memberikan komentar mereka.  Dan saya, tentu saja, berterima kasih kepada Anda atas kesabaran dan komentar Anda yang berharga.  Perhatian Anda mendorong saya untuk mencapai titik ini.  Terima kasih </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id452968/">https://habr.com/ru/post/id452968/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id452958/index.html">JMAP - protokol terbuka menggantikan IMAP saat bertukar email</a></li>
<li><a href="../id452960/index.html">Anda akan menjawab untuk semuanya! Kontrak yang Didorong Konsumen melalui mata pengembang</a></li>
<li><a href="../id452962/index.html">Penyebab utama kecelakaan di pusat data adalah peletakan antara komputer dan kursi</a></li>
<li><a href="../id452964/index.html">Penjelasan yang terjangkau dari hipotesis Riemann</a></li>
<li><a href="../id452966/index.html">Mitos kesadaran: pandangan meditasi "neurosentris"</a></li>
<li><a href="../id452974/index.html">Pemrograman asinkron (kursus penuh)</a></li>
<li><a href="../id452978/index.html">ok.tech: Data Dijelaskan</a></li>
<li><a href="../id452980/index.html">AWP KBR-N - Hari X akan segera datang, yang tidak mempersiapkan diri untuk disalahkan</a></li>
<li><a href="../id452982/index.html">Integrasi sederhana dari Proyek MS dan Redmine</a></li>
<li><a href="../id452984/index.html">Arduino dan Raspberry dilarang</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>