<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üÜî üöµ üôéüèΩ Pendekatan Modern untuk Persaingan di Android: Corotins at Kotlin üßöüèæ #‚É£ ‚úåüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habr! 

 Kami mengingatkan Anda bahwa kami telah memiliki pemesanan di muka untuk buku yang telah lama ditunggu-tunggu tentang bahasa Kotlin dar...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pendekatan Modern untuk Persaingan di Android: Corotins at Kotlin</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/457224/"> Halo, Habr! <br><br>  Kami mengingatkan Anda bahwa kami telah memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pemesanan</a> di muka untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">buku yang telah lama ditunggu-tunggu</a> tentang bahasa Kotlin dari seri Big Nerd Ranch Guides yang terkenal.  Hari ini kami memutuskan untuk membawa kepada Anda terjemahan dari sebuah artikel yang menceritakan tentang Kotlin coroutine dan tentang pekerjaan yang benar dengan stream di Android.  Topik sedang dibahas dengan sangat aktif, oleh karena itu, untuk kelengkapan, kami juga menyarankan agar Anda melihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel ini</a> dari Habr dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pos terperinci ini</a> dari blog Axmor Software. <br><a name="habracut"></a><br>  Kerangka kerja kompetitif modern di Java / Android menimbulkan neraka pada panggilan balik dan mengarah ke pemblokiran negara, karena Android tidak memiliki cara yang cukup sederhana untuk menjamin keamanan utas. <br><br>  Corinthine Kotlin adalah toolkit yang sangat efektif dan lengkap yang membuat mengelola kompetisi menjadi lebih mudah dan lebih produktif. <br><br>  <b>Jeda dan blokir: apa bedanya</b> <br><br>  Coroutine tidak mengganti utas, tetapi menyediakan kerangka kerja untuk mengelola mereka.  Filosofi dari corutin adalah untuk mendefinisikan konteks yang memungkinkan Anda untuk <b>menunggu</b> operasi latar belakang untuk menyelesaikan tanpa memblokir utas utama. <br><br>  Tujuan Corutin dalam hal ini adalah untuk menghilangkan panggilan balik dan menyederhanakan persaingan. <br><br>  <b>Contoh paling sederhana</b> <br><br>  Untuk memulainya, mari kita ambil contoh paling sederhana: jalankan coroutine dalam konteks <code>Main</code> (utas utama).  Di dalamnya, kami akan mengekstrak gambar dari aliran <code>IO</code> dan mengirim gambar ini untuk diproses kembali ke <code>Main</code> . <br><br><pre> <code class="kotlin hljs">launch(Dispatchers.Main) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> image = withContext(Dispatchers.IO) { getImage() } <span class="hljs-comment"><span class="hljs-comment">//    IO imageView.setImageBitmap(image) //     }</span></span></code> </pre> <br>  Kode ini sederhana sebagai fungsi single-threaded.  Selain itu, sementara <code>getImage</code> dieksekusi di kumpulan thread yang dialokasikan <code>IO</code> , utas utama gratis dan dapat mengambil tugas lain!  Fungsi withContext menjeda coroutine saat ini saat aksinya berjalan ( <code>getImage()</code> ).  Segera setelah <code>getImage()</code> kembali dan <code>looper</code> dari utas utama tersedia, coroutine akan melanjutkan pekerjaan di utas utama dan memanggil <code>imageView.setImageBitmap(image)</code> . <br><br>  Contoh kedua: sekarang kita perlu menyelesaikan 2 tugas latar belakang agar bisa digunakan.  Kami akan menggunakan duet async / await sehingga kedua tugas ini dilakukan secara paralel, dan menggunakan hasilnya di utas utama segera setelah kedua tugas siap: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> job = launch(Dispatchers.Main) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> deferred1 = async(Dispatchers.Default) { getFirstValue() } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> deferred2 = async(Dispatchers.IO) { getSecondValue() } useValues(deferred1.await(), deferred2.await()) } job.join() <span class="hljs-comment"><span class="hljs-comment">//    ,     </span></span></code> </pre> <br>  <code>async</code> mirip dengan <code>launch</code> , tetapi mengembalikan <code>deferred</code> (entitas Kotlin setara dengan <code>Future</code> ), sehingga hasilnya dapat diperoleh menggunakan <code>await()</code> .  Ketika dipanggil tanpa parameter, ia berfungsi dalam konteks default untuk lingkup saat ini. <br><br>  Sekali lagi, utas utama tetap bebas sementara kami menunggu 2 nilai kami. <br>  Seperti yang Anda lihat, fungsi <code>launch</code> mengembalikan <code>Job</code> , yang dapat digunakan untuk menunggu sampai operasi selesai - ini dilakukan menggunakan fungsi <code>join()</code> .  Ini bekerja seperti dalam bahasa lain, dengan peringatan bahwa itu hanya <b>menunda coroutine, dan tidak menghalangi aliran</b> . <br><br>  <b>Pengiriman</b> <br><br>  Pengiriman adalah konsep kunci ketika bekerja dengan coroutine.  Tindakan ini memungkinkan Anda untuk "melompat" dari satu utas ke utas lainnya. <br><br>  Pertimbangkan seperti apa persamaan untuk pengiriman di <code>Main</code> seperti di java, yaitu, <br><br><pre> <code class="kotlin hljs">runOnUiThread: <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> void runOnUiThread(Runnable action) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Thread.currentThread() != mUiThread) { mHandler.post(action); <span class="hljs-comment"><span class="hljs-comment">//  } else { action.run(); //   } }</span></span></code> </pre> <br>  Implementasi Konteks <code>Main</code> untuk Android adalah dispatcher berbasis <code>Handler</code> .  Jadi ini memang implementasi yang sangat cocok: <br><br><pre> <code class="kotlin hljs">launch(Dispatchers.Main) { ... } vs launch(Dispatchers.Main, CoroutineStart.UNDISPATCHED) { ... } <span class="hljs-comment"><span class="hljs-comment">//   kotlinx 0.26: launch(Dispatchers.Main.immediate) { ... }</span></span></code> </pre> <br>  <code>launch(Dispatchers.Main)</code> mengirimkan <code>Runnable</code> ke <code>Handler</code> , sehingga kodenya tidak segera dieksekusi. <br><br>  <code>launch(Dispatchers.Main, CoroutineStart.UNDISPATCHED)</code> akan segera menjalankan ekspresi lambda di utas saat ini. <br><br>  <code>Dispatchers.Main</code> <b>memastikan bahwa ketika coroutine melanjutkan bekerja, itu akan diarahkan ke utas utama</b> ;  selain itu, Handler digunakan di sini sebagai implementasi Android asli untuk mengirim ke loop acara aplikasi. <br><br>  Implementasi yang tepat terlihat seperti ini: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> Main: HandlerDispatcher = HandlerContext(mainHandler, <span class="hljs-string"><span class="hljs-string">"Main"</span></span>)</code> </pre> <br>  Berikut ini adalah artikel yang bagus untuk membantu Anda memahami seluk-beluk pengiriman di Android: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Memahami Android Core: Looper, Handler, dan HandlerThread</a> . <br><br>  <b>Konteks Coroutine</b> <br><br>  Konteks coroutine (juga dikenal sebagai manajer coroutine) menentukan di mana utas kode akan dieksekusi, apa yang harus dilakukan jika pengecualian dilemparkan, dan merujuk ke konteks induk untuk menyebarkan pembatalan. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> job = Job() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> exceptionHandler = CoroutineExceptionHandler { coroutineContext, throwable -&gt; whatever(throwable) } launch(Disaptchers.Default+exceptionHandler+job) { ... }</code> </pre> <br>  <code>job.cancel()</code> akan membatalkan semua coroutine yang orang tuanya adalah <code>job</code> .  Pengecualian Handler akan menerima semua pengecualian yang dilemparkan ke coroutine ini. <br><br>  <b>Lingkup</b> <br><br>  Antarmuka <code>coroutineScope</code> menyederhanakan penanganan kesalahan: <br>  Jika salah satu coroutine putrinya gagal, maka seluruh ruang lingkup dan semua coroutine anak juga akan dibatalkan. <br><br>  Dalam contoh <code>async</code> , jika tidak mungkin untuk mengekstraksi nilai, sementara tugas lain terus bekerja, kami memiliki keadaan yang rusak, dan kami perlu melakukan sesuatu tentang hal itu. <br><br>  Saat bekerja dengan <code>coroutineScope</code> , fungsi <code>useValues</code> akan dipanggil hanya jika ekstraksi kedua nilai berhasil.  Juga, jika <code>deferred2</code> gagal, <code>deferred1</code> akan dibatalkan. <br><br><pre> <code class="kotlin hljs">coroutineScope { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> deferred1 = async(Dispatchers.Default) { getFirstValue() } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> deferred2 = async(Dispatchers.IO) { getSecondValue() } useValues(deferred1.await(), deferred2.await()) }</code> </pre> <br>  Anda juga dapat ‚Äúmemasukkan ruang lingkup‚Äù seluruh kelas untuk mengatur <code>CoroutineContext</code> default untuk itu dan menggunakannya. <br><br>  Kelas contoh yang mengimplementasikan antarmuka <code>CoroutineScope</code> : <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">open</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ScopedViewModel</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ViewModel</span></span></span></span>(), CoroutineScope { <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> job = Job() <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> coroutineContext = Dispatchers.Main+job <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCleared</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onCleared() job.cancel() } }</code> </pre> <br>  Menjalankan Corutin di <code>CoroutineScope</code> : <br><br>  <code>launch</code> default atau manajer <code>async</code> sekarang menjadi manajer lingkup saat ini. <br><br><pre> <code class="kotlin hljs">launch { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> foo = withContext(Dispatchers.IO) { ‚Ä¶ } <span class="hljs-comment"><span class="hljs-comment">// -    CoroutineContext   ‚Ä¶ } launch(Dispatchers.Default) { // -        ‚Ä¶ }</span></span></code> </pre> <br>  Peluncuran otonom coroutine (di luar CoroutineScope apa pun): <br><br><pre> <code class="kotlin hljs">GlobalScope.launch(Dispatchers.Main) { <span class="hljs-comment"><span class="hljs-comment">// -    . ‚Ä¶ }</span></span></code> </pre> <br>  Anda bahkan dapat menentukan ruang lingkup aplikasi dengan menetapkan operator <code>Main</code> : <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> AppScope : CoroutineScope <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> GlobalScope { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> coroutineContext = Dispatchers.Main.immediate }</code> </pre><br>  <b>Komentar</b> <br><br><ul><li>  Coroutines membatasi interoperabilitas dengan Java </li><li>  Batasi mutabilitas untuk menghindari kunci </li><li>  Coroutine dirancang untuk menunggu, bukan untuk mengatur utas </li><li>  Hindari I / O di <code>Dispatchers.Default</code> (dan <code>Main</code> ...) - inilah gunanya Dispatchers.IO </li><li>  Streaming memakan sumber daya, sehingga konteks single-threaded digunakan </li><li>  <code>Dispatchers.Default</code> didasarkan pada <code>ForkJoinPool</code> , diperkenalkan di Android 5+ </li><li>  Coroutine dapat digunakan melalui saluran </li></ul><br>  <b>Menyingkirkan kunci dan panggilan balik menggunakan saluran</b> <br><br>  Definisi saluran dari dokumentasi JetBrains: <br><br><blockquote>  Saluran <code>Channel</code> konseptual sangat mirip dengan <code>BlockingQueue</code> .  Perbedaan utama adalah bahwa ia tidak memblokir operasi put, ia menyediakan untuk <code>send</code> ditangguhkan (atau penawaran yang tidak menghalangi), dan alih-alih memblokir operasi take, ia menyediakan untuk <code>receive</code> penundaan. </blockquote><br><br>  <b>Aktor</b> <br><br>  Pertimbangkan alat sederhana untuk bekerja dengan saluran: <code>Actor</code> . <br><br>  <code>Actor</code> , sekali lagi, sangat mirip dengan <code>Handler</code> : kita mendefinisikan konteks coroutine (yaitu, thread di mana kita akan melakukan tindakan) dan bekerja dengannya secara berurutan. <br><br>  Perbedaannya, tentu saja, adalah bahwa corutin digunakan di sini;  <b>Anda dapat menentukan kekuatan, dan kode yang dijalankan - jeda</b> . <br><br>  Pada prinsipnya, <code>actor</code> akan mengarahkan ulang perintah apa pun ke saluran coroutine.  Ini <b>menjamin eksekusi perintah dan membatasi operasi dalam konteksnya</b> .  Pendekatan ini sangat membantu menghilangkan <code>synchronize</code> panggilan dan menjaga semua utas gratis! <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> updateActor <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> lazy { actor&lt;Update&gt;(capacity = Channel.UNLIMITED) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (update <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> channel) <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (update) { Refresh -&gt; updateList() <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Filter -&gt; filter.filter(update.query) <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> MediaUpdate -&gt; updateItems(update.mediaList <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> List&lt;T&gt;) <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> MediaAddition -&gt; addMedia(update.media <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> T) <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> MediaListAddition -&gt; addMedia(update.mediaList <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> List&lt;T&gt;) <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> MediaRemoval -&gt; removeMedia(update.media <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> T) } } } <span class="hljs-comment"><span class="hljs-comment">//  fun filter(query: String?) = updateActor.offer(Filter(query)) //  suspend fun filter(query: String?) = updateActor.send(Filter(query))</span></span></code> </pre> <br>  Dalam contoh ini, kami menggunakan kelas Kotlin tersegel, memilih tindakan mana yang harus dilakukan. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Update</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Refresh</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Update</span></span></span></span>() <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Filter</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> query: String?) : Update() <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MediaAddition</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> media: Media) : Update()</code> </pre> <br>  Selain itu, semua tindakan ini akan antri, mereka tidak akan pernah dieksekusi secara paralel.  Ini adalah cara yang mudah untuk mencapai <b>batas variabilitas</b> . <br><br>  <b>Android Life Cycle + Coroutines</b> <br><br>  Aktor juga dapat sangat berguna untuk mengendalikan antarmuka pengguna Android, menyederhanakan pembatalan tugas, dan mencegah kelebihan utas. <br>  Mari kita implementasikan ini dan panggil <code>job.cancel()</code> ketika aktivitas dihancurkan. <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyActivity</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AppCompatActivity</span></span></span></span>(), CoroutineScope { <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> job = SupervisorJob() <span class="hljs-comment"><span class="hljs-comment">//  Job    override val coroutineContext = Dispatchers.Main.immediate+job override fun onDestroy() { super.onDestroy() job.cancel() //      } }</span></span></code> </pre> <br>  Kelas <code>SupervisorJob</code> mirip dengan <code>Job</code> reguler dengan satu pengecualian bahwa pembatalan hanya meluas ke arah hilir. <br><br>  Karenanya, kami tidak membatalkan semua coroutine dalam suatu <code>Activity</code> ketika salah satu dari mereka gagal. <br><br>  Hal-hal sedikit lebih baik dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">fungsi ekstensi</a> yang memungkinkan Anda untuk mengakses <code>CoroutineContext</code> ini dari <code>View</code> apa pun di <code>CoroutineScope</code> . <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> View.coroutineContext: CoroutineContext? <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() = (context <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? CoroutineScope)?.coroutineContext</code> </pre> <br>  Sekarang kita bisa menggabungkan semua ini, fungsi <code>setOnClick</code> membuat aktor gabungan untuk mengontrol tindakan <code>onClick</code> -nya.  Dalam hal beberapa ketukan, tindakan lanjutan akan diabaikan, sehingga menghilangkan kesalahan PPA (aplikasi tidak merespons), dan tindakan ini akan dilakukan dalam lingkup <code>Activity</code> .  Karena itu, ketika aktivitas dihancurkan, semua ini akan dibatalkan. <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> View.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setOnClick</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(action: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">suspend</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ()</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//         val scope = (context as? CoroutineScope)?: AppScope val eventActor = scope.actor&lt;Unit&gt;(capacity = Channel.CONFLATED) { for (event in channel) action() } //       setOnClickListener { eventActor.offer(Unit) } }</span></span></code> </pre> <br>  Dalam contoh ini, kami mengatur <code>Channel</code> ke <code>Conflated</code> sehingga mengabaikan beberapa peristiwa jika ada terlalu banyak.  Anda dapat menggantinya dengan <code>Channel.UNLIMITED</code> jika Anda lebih memilih untuk mengantri acara tanpa kehilangan salah satunya, tetapi tetap ingin melindungi aplikasi dari kesalahan ANR. <br><br>  Anda juga dapat menggabungkan kerangka kerja coroutine dan Siklus Hidup untuk mengotomatiskan pembatalan tugas yang terkait dengan antarmuka pengguna: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> LifecycleOwner.untilDestroy: Job <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> job = Job() lifecycle.addObserver(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>: LifecycleObserver { <span class="hljs-meta"><span class="hljs-meta">@OnLifecycleEvent(Lifecycle.Event.ON_DESTROY)</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onDestroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { job.cancel() } }) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> job } <span class="hljs-comment"><span class="hljs-comment">//  GlobalScope.launch(Dispatchers.Main, parent = untilDestroy) { /*    ! */ }</span></span></code> </pre> <br>  <b>Sederhanakan situasi dengan panggilan balik (bagian 1)</b> <br><br>  Berikut cara mengubah penggunaan API berbasis panggilan balik dengan <code>Channel</code> . <br><br>  API berfungsi seperti ini: <br><br><ol><li>  <code>requestBrowsing(url, listener)</code> mem-parsing folder yang terletak di <code>url</code> . </li><li>  <code>listener</code> menerima <code>onMediaAdded(media: Media)</code> untuk semua file media yang ditemukan di folder ini. </li><li>  <code>listener.onBrowseEnd()</code> dipanggil saat parsing folder </li></ol><br>  Ini adalah fungsi <code>refresh</code> lama di penyedia konten untuk browser VLC: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> refreshList = mutableListOf&lt;Media&gt;() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">refresh</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = requestBrowsing(url, refreshListener) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> refreshListener = <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> : EventListener{ <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onMediaAdded</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(media: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Media</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { refreshList.add(media)) } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onBrowseEnd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> list = refreshList.toMutableList() refreshList.clear() launch { dataset.value = list parseSubDirectories() } } }</code> </pre> <br>  <b>Bagaimana cara memperbaikinya?</b> <br><br>  Buat saluran yang akan dijalankan dalam <code>refresh</code> .  Sekarang panggilan balik browser hanya akan mengarahkan media ke saluran ini, dan kemudian menutupnya. <br><br>  Sekarang fungsi <code>refresh</code> menjadi lebih jelas.  Dia membuat saluran, memanggil browser VLC, lalu membentuk daftar file media dan memprosesnya. <br><br>  Alih-alih <code>select</code> atau <code>consumeEach</code> Anda dapat menggunakan <code>for</code> menunggu media, dan loop ini akan pecah segera setelah <code>browserChannel</code> ditutup. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> browserChannel : Channel&lt;Media&gt; <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onMediaAdded</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(media: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Media</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { browserChannel.offer(media) } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onBrowseEnd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { browserChannel.close() } <span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">refresh</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { browserChannel = Channel(Channel.UNLIMITED) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> refreshList = mutableListOf&lt;Media&gt;() requestBrowsing(url) <span class="hljs-comment"><span class="hljs-comment">//        for (media in browserChannel) refreshList.add(media) //   dataset.value = refreshList parseSubDirectories() }</span></span></code> </pre> <br>  <b>Menyederhanakan situasi dengan callback (bagian 2): Retrofit</b> <br><br>  Pendekatan kedua: kami sama sekali tidak menggunakan kotlinx coroutine, tetapi kami menggunakan kerangka inti coroutine. <br><br>  Lihat bagaimana sebenarnya coroutine bekerja! <br><br>  Fungsi <code>retrofitSuspendCall</code> membungkus permintaan <code>Retrofit Call</code> untuk menjadikannya fungsi <code>suspend</code> . <br><br>  Menggunakan <code>suspendCoroutine</code> kami memanggil metode <code>Call.enqueue</code> dan menjeda coroutine.  Callback yang disediakan dengan cara ini akan memanggil <code>continuation.resume(response)</code> untuk melanjutkan coroutine dengan respons dari server segera setelah diterima. <br><br>  Selanjutnya, kita hanya perlu menggabungkan fungsi Retrofit kita ke <code>retrofitSuspendCall</code> untuk mengembalikan hasil kueri menggunakannya. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-type"><span class="hljs-keyword">reified</span></span></span></span><span class="hljs-function"><span class="hljs-type"> T&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">retrofitSuspendCall</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(request: ()</span></span></span></span> -&gt; Call &lt;T&gt; ) : Response &lt;T&gt; = suspendCoroutine { continuation -&gt; request.invoke().enqueue(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span> : Callback&lt;T&gt; { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onResponse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(call: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Call</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;, response: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Response</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> { continuation.resume(response) } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onFailure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(call: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Call</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;, t: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Throwable</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { continuation.resumeWithException(t) } }) } <span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">browse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(path: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> = retrofitSuspendCall { ApiClient.browse(path) } <span class="hljs-comment"><span class="hljs-comment">//  (   Main) livedata.value = Repo.browse(path)</span></span></code> </pre> <br>  Jadi, panggilan yang memblokir jaringan dibuat dalam utas Retrofit khusus, coroutine ada di sini, menunggu respons dari server, dan tidak ada tempat untuk menggunakannya dalam aplikasi! <br><br>  Implementasi ini terinspirasi oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">perpustakaan gildor / kotlin-coroutines-retrofit</a> . <br><br>  Ada juga <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JakeWharton / retrofit2-kotlin-coroutines-adapter</a> dengan implementasi lain yang memberikan hasil yang serupa. <br><br>  <b>Epilog</b> <br><br>  <code>Channel</code> dapat digunakan dengan banyak cara lain;  Lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">BroadcastChannel untuk</a> implementasi yang lebih kuat yang mungkin berguna bagi Anda. <br><br>  Anda juga dapat membuat saluran menggunakan fungsi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Produce</a> . <br><br>  Akhirnya, menggunakan saluran akan lebih mudah untuk mengatur komunikasi antara komponen-komponen UI: adaptor dapat mengirimkan peristiwa klik ke fragmen / aktivitasnya melalui <code>Channel</code> atau, misalnya, melalui <code>Actor</code> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id457224/">https://habr.com/ru/post/id457224/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id457204/index.html">Windows PowerShell dan Long Paths</a></li>
<li><a href="../id457206/index.html">SQL Index Manager - cerita panjang tentang SQL Server, penggalian kuburan dan pemeliharaan indeks</a></li>
<li><a href="../id457208/index.html">Menghasilkan robots.txt secara dinamis untuk situs ASP.NET Core berdasarkan lingkungan</a></li>
<li><a href="../id457210/index.html">Simpan sumber daya statis di hosting Anda</a></li>
<li><a href="../id457212/index.html">Mengapa tidak ada kata terlambat untuk mulai belajar Java (atau bahasa Java lainnya)</a></li>
<li><a href="../id457232/index.html">Robot lebah "Bumble" - uji terbang pertama di dalam ISS</a></li>
<li><a href="../id457234/index.html">Bias kognitif produk</a></li>
<li><a href="../id457236/index.html">Bagaimana perusahaan IT berjuang untuk menjual musik</a></li>
<li><a href="../id457240/index.html">Berita terbaik minggu ini: jaringan saraf dan gambar foto, pertumbuhan saham Yandex, Huawei membutuhkan $ 1 miliar untuk paten</a></li>
<li><a href="../id457246/index.html">Bagaimana cara berkedip 4 LED pada CortexM menggunakan C ++ 17, tuple dan sedikit fantasi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>