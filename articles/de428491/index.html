<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§öüèª ü§µüèø üêß Proaktive Optimierung der Oracle-Datenbankleistung üèáüèΩ üë©üèΩ‚Äçüé® üîë</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Das erste, was uns begegnet, wenn wir √ºber proaktive Optimierung sprechen, ist, dass nicht bekannt ist, was optimiert werden muss. "Tu das, ich wei√ü n...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Proaktive Optimierung der Oracle-Datenbankleistung</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/428491/">  Das erste, was uns begegnet, wenn wir √ºber proaktive Optimierung sprechen, ist, dass nicht bekannt ist, was optimiert werden muss.  "Tu das, ich wei√ü nicht was." <br><br><ul><li>  Es gibt keinen klassischen Algorithmus. </li><li>  Das Problem ist noch nicht aufgetreten (unbekannt), und man kann nur raten, wo es sein k√∂nnte. </li><li>  Wir m√ºssen einige potenzielle Schwachstellen im System finden. </li><li>  Versuchen Sie, die Abfrageleistung an diesen Stellen zu optimieren. </li></ul><br><h3>  Die Hauptziele einer proaktiven Optimierung <br></h3><br>  Die Hauptaufgaben der proaktiven Optimierung unterscheiden sich von den Aufgaben der reaktiven Optimierung und lauten wie folgt: <br><br><ul><li>  Engp√§sse in der Datenbank beseitigen; </li><li>  Verringerung des Ressourcenverbrauchs der Datenbank. </li></ul><br>  Der letzte Moment ist der grundlegendste.  Bei der reaktiven Optimierung haben wir nicht die Aufgabe, den Ressourcenverbrauch insgesamt zu reduzieren, sondern nur die Reaktionszeit der Funktionalit√§t auf akzeptable Grenzen zu bringen. <br><br><img src="https://habrastorage.org/webt/zl/eg/b5/zlegb5nfhfvxy9bajfsxkv3u7ao.png"><br><br>  Wenn Sie mit Kampfservern arbeiten, haben Sie eine gute Vorstellung davon, was Leistungsvorf√§lle bedeuten.  Sie m√ºssen alles beenden und das Problem schnell l√∂sen.  RNKO Payment Center LLC arbeitet mit vielen Agenten zusammen, und es ist sehr wichtig, dass sie so wenig Probleme wie m√∂glich haben.  Alexander Makarov von HighLoad ++ Siberia erkl√§rte, was getan wurde, um die Anzahl der Leistungsvorf√§lle erheblich zu reduzieren.  Proaktive Optimierung kam zur Rettung.  Und warum und wie es auf einem Kampfserver produziert wird, lesen Sie unten. <br><a name="habracut"></a><br><img src="https://habrastorage.org/webt/r_/kt/zz/r_ktzzegcm2xca_nrh4yusjtpqy.png"><br><br>  <strong>√úber den Sprecher:</strong> Alexander Makarov ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">AL_IG_Makarov</a> ), Leitender Administrator der Oracle-Datenbank, RNKO Payment Center LLC.  Trotz der Position gibt es nur sehr wenig Verwaltung als solche. Die Hauptaufgaben beziehen sich auf die Wartung des Komplexes und seine Entwicklung, insbesondere auf die L√∂sung von Leistungsproblemen. <br><br><h1>  Ist die Optimierung einer Kampfdatenbank proaktiv? <br></h1><br>  Zun√§chst werden wir uns mit den Begriffen befassen, die in diesem Bericht als "proaktive Leistungsoptimierung" bezeichnet werden.  Manchmal k√∂nnen Sie den Standpunkt vertreten, dass eine proaktive Optimierung darin besteht, dass die Analyse von Problembereichen bereits vor dem Start der Anwendung durchgef√ºhrt wird.  Beispielsweise stellen wir fest, dass einige Abfragen nicht optimal funktionieren, da nicht gen√ºgend Index vorhanden ist oder die Abfrage einen ineffizienten Algorithmus verwendet und diese Arbeit auf Testservern ausgef√ºhrt wird. <br><br>  Trotzdem haben wir vom RNCO dieses Projekt <strong>auf</strong> Kampfservern durchgef√ºhrt.  Oft h√∂rte ich: ‚ÄûWie so?  Du machst es auf einem Kampfserver - das hei√üt, es ist keine proaktive Leistungsoptimierung! ‚Äú  Hier m√ºssen wir an den Ansatz erinnern, der in ITIL gepflegt wird.  Aus ITIL-Sicht haben wir: <br><br><ul><li>  Leistungsvorf√§lle sind das, was bereits passiert ist; </li><li>  die Ma√ünahmen, die wir ergreifen, um das Auftreten von Leistungsst√∂rungen zu verhindern. </li></ul><br>  In diesem Sinne sind unsere Handlungen proaktiv.  Trotz der Tatsache, dass wir das Problem auf einem Kampfserver l√∂sen, ist das Problem selbst noch nicht aufgetreten: Der Vorfall ist nicht aufgetreten, wir sind nicht ausgef√ºhrt worden und haben nicht versucht, dieses Problem in kurzer Zeit zu l√∂sen. <br><br>  In diesem Bericht wird Proaktivit√§t als <strong>Proaktivit√§t im Sinne von ITIL verstanden</strong> . Wir l√∂sen das Problem, bevor ein Leistungsvorfall auftritt. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/y68RLr825VE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h1>  Bezugspunkt <br></h1><br>  Das RNKO "Payment Center" bedient zwei gro√üe Systeme: <br><br><ul><li>  RBS-Retail Bank; </li><li>  CFT Bank. </li></ul><br>  Die Art der Last auf diesen Systemen ist gemischt (DSS + OLTP): Es gibt etwas, das sehr schnell funktioniert, es gibt Berichte, es gibt mittlere Lasten. <br><br>  Wir sind mit der Tatsache konfrontiert, dass nicht sehr oft, aber mit einer bestimmten H√§ufigkeit, Leistungsvorf√§lle auftraten.  Diejenigen, die mit Kampfservern arbeiten, stellen sich vor, was es ist.  Dies bedeutet, dass Sie alles beenden und das Problem schnell l√∂sen m√ºssen, da der Client zu diesem Zeitpunkt den Service nicht erhalten kann, etwas entweder √ºberhaupt nicht oder nur sehr langsam funktioniert. <br><br>  Da viele Agenten und Kunden an unsere Organisation gebunden sind, ist dies f√ºr uns sehr wichtig.  Wenn wir Leistungsvorf√§lle nicht schnell l√∂sen k√∂nnen, leiden unsere Kunden auf die eine oder andere Weise.  Zum Beispiel k√∂nnen sie keine Karte auff√ºllen oder eine √úberweisung vornehmen.  Daher haben wir uns gefragt, was getan werden kann, um selbst diese seltenen Leistungsvorf√§lle zu beseitigen.  In einem Modus zu arbeiten, in dem Sie alles fallen lassen und ein Problem l√∂sen m√ºssen - das ist nicht ganz richtig.  Wir verwenden Sprints und erstellen einen Sprint-Arbeitsplan.  Das Vorhandensein von Leistungsst√∂rungen ist auch eine Abweichung vom Arbeitsplan. <br><br>  Damit muss etwas getan werden! <br><br><h1>  Optimierungsans√§tze <br></h1><br>  Wir haben √ºber die Technologie der proaktiven Optimierung nachgedacht und sie verstanden.  Bevor ich jedoch √ºber proaktive Optimierung spreche, muss ich einige Worte zur klassischen reaktiven Optimierung sagen. <br><br><h2>  Reaktive Optimierung <br></h2><br>  Das Szenario ist einfach: Es gibt einen Kampfserver, auf dem etwas passiert ist: Sie haben einen Bericht gestartet, Clients erhalten Anweisungen, zu diesem Zeitpunkt gibt es laufende Aktivit√§ten in der Datenbank, und pl√∂tzlich hat sich jemand entschlossen, ein umfangreiches Verzeichnis zu aktualisieren.  Das System beginnt langsamer zu werden.  In diesem Moment kommt der Kunde und sagt: "Ich kann dies oder das nicht tun" - wir m√ºssen einen Grund finden, warum er dies nicht tun kann. <br><br>  <strong>Klassischer Aktionsalgorithmus:</strong> <br><br><ol><li>  Reproduzieren Sie das Problem. </li><li>  Suchen Sie die Problemstelle. </li><li>  Optimieren Sie den Problemort. </li></ol><br>  Im Rahmen des reaktiven Ansatzes besteht die Hauptaufgabe nicht darin, die Grundursache selbst zu finden und zu beseitigen, sondern das System normal funktionieren zu lassen.  Die Beseitigung der Grundursache kann sp√§ter behandelt werden.  Die Hauptsache ist, den Server schnell wiederherzustellen, damit der Client den Dienst empfangen kann. <br><br><h3>  Die Hauptziele der reaktiven Optimierung <br></h3><br>  Bei der reaktiven Optimierung k√∂nnen zwei Hauptziele unterschieden werden: <br><br>  1. <strong>Verk√ºrzung der Reaktionszeit</strong> . <br><br>  Eine Aktion, z. B. das Empfangen eines Berichts, einer Anweisung oder einer Transaktion, muss f√ºr eine bestimmte Zeit ausgef√ºhrt werden.  Es muss sichergestellt werden, dass der Zeitpunkt des Empfangs des Dienstes an die f√ºr den Kunden akzeptablen Grenzen zur√ºckkehrt.  Vielleicht arbeitet der Service etwas langsamer als gew√∂hnlich, aber f√ºr den Kunden ist dies akzeptabel.  Dann glauben wir, dass der Leistungsvorfall beseitigt wurde, und beginnen, an der Grundursache zu arbeiten. <br><br>  2. <strong>Erh√∂hung der Anzahl der verarbeiteten Objekte pro Zeiteinheit w√§hrend der Stapelverarbeitung</strong> . <br><br>  W√§hrend der Stapelverarbeitung von Transaktionen muss die Verarbeitungszeit eines Objekts aus dem Paket reduziert werden. <br><br>  <strong>Vorteile eines reaktiven Ansatzes:</strong> <br><br>  ‚óè <em>Eine Vielzahl von Werkzeugen und Techniken</em> ist das Hauptvorteil eines reaktiven Ansatzes. <br><br>  Wir k√∂nnen die √úberwachungstools verwenden, um das Problem direkt zu verstehen: Es ist nicht gen√ºgend CPU, Threads, Speicher vorhanden oder das Festplattensystem ist ausgerutscht, oder die Protokolle werden langsam verarbeitet.  Es gibt viele Tools und Techniken, um das aktuelle Leistungsproblem in der Oracle-Datenbank zu untersuchen. <br><br>  ‚óè Die <em>gew√ºnschte Reaktionszeit</em> ist ein weiteres Plus. <br><br>  W√§hrend dieser Arbeit bringen wir die Situation auf eine akzeptable Reaktionszeit, dh wir versuchen nicht, sie auf den Mindestwert zu reduzieren, sondern erreichen einen bestimmten Wert und beenden diese Aktion, weil wir glauben, akzeptable Grenzen erreicht zu haben. <br><br>  <strong>Nachteile des reaktiven Ansatzes:</strong> <br><br><ul><li>  <em>Leistungsvorf√§lle bleiben bestehen</em> - dies ist das gr√∂√üte Minus des reaktiven Ansatzes, da wir die Grundursache nicht immer erreichen k√∂nnen.  Sie h√§tte irgendwo fern bleiben und irgendwo tiefer liegen k√∂nnen, obwohl wir eine akzeptable Leistung erzielt hatten. </li></ul><br>  Und wie geht man mit Leistungsvorf√§llen um, wenn sie noch nicht aufgetreten sind?  Versuchen wir zu formulieren, wie eine proaktive Optimierung durchgef√ºhrt werden kann, um solche Situationen zu verhindern. <br><br><h2>  Proaktive Optimierung <br></h2><br>  Das erste, was uns begegnet, ist, dass nicht bekannt ist, was optimiert werden muss.  "Tu das, ich wei√ü nicht was." <br><br><ul><li>  Es gibt keinen klassischen Algorithmus. </li><li>  Das Problem ist noch nicht aufgetreten (unbekannt), und man kann nur raten, wo es sein k√∂nnte. </li><li>  Wir m√ºssen einige potenzielle Schwachstellen im System finden. </li><li>  Versuchen Sie, die Abfrageleistung an diesen Stellen zu optimieren. </li></ul><br><h3>  Die Hauptziele einer proaktiven Optimierung <br></h3><br>  Die Hauptaufgaben der proaktiven Optimierung unterscheiden sich von den Aufgaben der reaktiven Optimierung und lauten wie folgt: <br><br><ul><li>  Engp√§sse in der Datenbank beseitigen; </li><li>  Verringerung des Ressourcenverbrauchs der Datenbank. </li></ul><br>  Der letzte Moment ist der grundlegendste.  Bei der reaktiven Optimierung haben wir nicht die Aufgabe, den Ressourcenverbrauch insgesamt zu reduzieren, sondern nur die Reaktionszeit der Funktionalit√§t auf akzeptable Grenzen zu bringen. <br><br><h3>  Wie finde ich Engp√§sse in der Datenbank? <br></h3><br>  Wenn wir √ºber dieses Problem nachdenken, entstehen sofort viele Unteraufgaben.  Es ist notwendig durchzuf√ºhren: <br><br><ul><li>  CPU-Test </li><li>  Lasttests f√ºr Lesevorg√§nge / Datens√§tze; </li><li>  Stresstests nach Anzahl der aktiven Sitzungen; </li><li>  Lasttests an ... etc. </li></ul><br>  Wenn wir versuchen, diese Probleme in einem Testkomplex zu simulieren, k√∂nnen wir feststellen, dass das auf dem Testserver aufgetretene Problem nichts mit dem Kampfproblem zu tun hat.  Daf√ºr gibt es viele Gr√ºnde, angefangen mit der Tatsache, dass Testserver normalerweise schw√§cher sind.  Es ist gut, wenn es m√∂glich ist, den Testserver zu einer exakten Kopie des Kampfservers zu machen. Dies garantiert jedoch nicht, dass die Last auf dieselbe Weise reproduziert wird, da Sie die Benutzeraktivit√§t und viele weitere Faktoren, die sich auf die endg√ºltige Last auswirken, genau reproduzieren m√ºssen.  Wenn Sie versuchen, diese Situation zu simulieren, garantiert im Gro√üen und Ganzen niemand, dass genau dasselbe passiert, was auf dem Kampfserver passieren wird. <br><br>  Wenn in einem Fall das Problem auftrat, weil eine neue Registrierung eingetroffen ist, kann es in dem anderen Fall auftreten, weil der Benutzer einen gro√üen Bericht mit einer gro√üen Sortierung gestartet hat, wodurch der tempor√§re Tabellenbereich gef√ºllt wurde, und als Folglich begann das System langsamer zu werden.  Das hei√üt, die Gr√ºnde k√∂nnen unterschiedlich sein und es ist nicht immer m√∂glich, sie vorherzusagen.  Daher haben <strong>wir Versuche, auf Testservern nach Engp√§ssen zu suchen,</strong> fast von Anfang an <strong>aufgegeben</strong> .  Wir haben uns nur auf den Kampfserver und das, was darauf geschah, verlassen. <br><br>  Was ist in diesem Fall zu tun?  Versuchen wir zu verstehen, welche Ressourcen am wahrscheinlichsten fehlen. <br><br><h3>  Verringern des Ressourcenverbrauchs der Datenbank <br></h3><br>  Aufgrund der uns zur Verf√ºgung stehenden Industriekomplexe wird der <strong>h√§ufigste Mangel an Ressourcen bei Festplattenlesungen und CPUs beobachtet</strong> .  Daher werden wir zun√§chst genau in diesen Bereichen nach Schwachstellen suchen. <br><br>  Die zweite wichtige Frage: Wie sucht man nach etwas? <br>  Die Frage ist sehr nicht trivial.  Wir verwenden Oracle Enterprise Edition mit der Option Diagnostic Pack und haben ein solches Tool f√ºr uns gefunden - <b>AWR-Berichte</b> (in anderen Editionen von Oracle k√∂nnen Sie <b>STATSPACK-Berichte verwenden</b> ).  In PostgreSQL gibt es ein Analogon - pgstatspack, es gibt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">pg_profile von</a> Andrey Zubkov.  Das letzte Produkt, so wie ich es verstehe, erschien und begann erst im letzten Jahr zu entwickeln.  F√ºr MySQL konnte ich keine √§hnlichen Tools finden, aber ich bin kein MySQL-Experte. <br><br>  Der Ansatz selbst ist nicht an eine bestimmte Art von Datenbank gebunden.  Wenn es m√∂glich ist, Informationen √ºber die Systemlast aus einem Bericht zu erhalten, k√∂nnen Sie mit der Technik, √ºber die ich jetzt sprechen werde, <strong>an jeder Basis</strong> an einer proaktiven Optimierung arbeiten. <br><br><h3>  <strong>Optimierung der Top 5 Operationen</strong> <br></h3><br>  Die proaktive Optimierungstechnologie, die wir im Payment Center RNCO entwickelt haben und einsetzen, besteht aus vier Phasen. <br><br>  <strong>Stufe 1. Wir erhalten den AWR-Bericht f√ºr den gr√∂√ütm√∂glichen Zeitraum.</strong> <br><br>  Es wird die gr√∂√ütm√∂gliche Zeit ben√∂tigt, um die Last an verschiedenen Wochentagen zu mitteln, da sie manchmal sehr unterschiedlich ist.  Zum Beispiel kommen Registries der letzten Woche am Dienstag bei der RBS-Retail Bank an, sie werden verarbeitet, und den ganzen Tag haben wir eine durchschnittliche Auslastung von etwa zwei bis drei Mal.  An anderen Tagen ist die Belastung geringer. <br><br>  Wenn Sie wissen, dass das System einige Besonderheiten aufweist - an manchen Tagen ist die Last gr√∂√üer, an manchen Tagen geringer -, m√ºssen Sie Berichte f√ºr diese Zeitr√§ume separat erhalten und separat damit arbeiten, wenn wir bestimmte Zeitintervalle optimieren m√∂chten .  Wenn Sie die Gesamtsituation auf dem Server optimieren m√ºssen, k√∂nnen Sie einen umfangreichen Bericht f√ºr den Monat abrufen und sehen, was die Ressourcen des Servers tats√§chlich verbrauchen. <br><br>  Manchmal treten sehr unerwartete Situationen auf.  Im Fall der CFT Bank befindet sich beispielsweise eine Anforderung, die die Berichtsserverwarteschlange √ºberpr√ºft, m√∂glicherweise unter den Top 10.  Dar√ºber hinaus ist diese Anforderung offiziell und f√ºhrt keine Gesch√§ftslogik aus, sondern pr√ºft nur, ob ein Bericht √ºber die Ausf√ºhrung vorliegt oder nicht. <br><br>  <strong>Stufe 2. Wir schauen uns Abschnitte an:</strong> <br><br><ul><li>  SQL nach verstrichener Zeit geordnet - SQL-Abfragen sortiert nach Laufzeit; </li><li>  SQL geordnet nach CPU-Zeit - f√ºr die CPU-Auslastung; </li><li>  SQL sortiert nach Gets - nach logischen Lesungen; </li><li>  Von Reads geordnetes SQL - f√ºr physische Lesungen. </li></ul><br>  Die verbleibenden Abschnitte von SQL, die nach geordnet sind, werden nach Bedarf untersucht. <br><br>  <strong>Stufe 3. Wir bestimmen √ºbergeordnete Operationen und Anforderungen, die von ihnen abh√§ngen.</strong> <br><br>  Der AWR-Bericht enth√§lt separate Abschnitte, in denen je nach Oracle-Version in jedem dieser Abschnitte 15 oder mehr Top-Abfragen angezeigt werden.  Diese Abfragen von Oracle im AWR-Bericht zeigen jedoch ein Durcheinander. <br>  Zum Beispiel gibt es eine √ºbergeordnete Operation, in der sich drei Top-Abfragen befinden k√∂nnen.  Oracle im AWR-Bericht zeigt sowohl die √ºbergeordnete Operation als auch alle diese drei Abfragen an.  Daher m√ºssen Sie eine Analyse dieser Liste durchf√ºhren und feststellen, auf welche betriebsspezifischen Anforderungen Bezug genommen wird, und sie gruppieren. <br><br>  <strong>Stufe 4. Wir optimieren die Top 5 Operationen.</strong> <br><br>  Nach einer solchen Gruppierung ist die Ausgabe eine Liste von Operationen, aus denen Sie die schwierigsten ausw√§hlen k√∂nnen.  Wir sind auf 5 Operationen beschr√§nkt (keine Anfragen, n√§mlich Operationen).  Wenn das System komplexer ist, k√∂nnen Sie mehr nehmen. <br><br><h3>  H√§ufige Fehler beim Entwurf von Abfragen <br></h3><br>  W√§hrend der Anwendung dieser Technik haben wir eine kleine Liste typischer Konstruktionsfehler zusammengestellt.  Einige Fehler sind so einfach, dass es den Anschein hat, als k√∂nnten sie nicht sein. <br><br>  ‚óè <strong>Fehlender Index ‚Üí ‚Äã‚ÄãVollst√§ndiger Scan</strong> <br>  Es gibt sehr zuf√§llige F√§lle, in denen beispielsweise kein Index f√ºr das Kampfschema vorhanden ist.  Wir hatten ein konkretes Beispiel, bei dem eine Abfrage lange Zeit ohne Index schnell funktionierte.  Es gab jedoch einen vollst√§ndigen Scan, und als die Gr√∂√üe der Tabelle allm√§hlich zunahm, begann die Abfrage langsamer zu arbeiten, und von Quartal zu Quartal dauerte es etwas l√§nger.  Am Ende haben wir auf ihn geachtet und es stellte sich heraus, dass der Index nicht da ist. <br><br>  ‚óè <strong>Gro√üe Auswahl ‚Üí Vollst√§ndiger Scan</strong> <br>  Der zweite h√§ufige Fehler ist ein gro√ües Datenmuster - der klassische Fall eines vollst√§ndigen Scans.  Jeder wei√ü, dass ein vollst√§ndiger Scan nur verwendet werden sollte, wenn dies wirklich gerechtfertigt ist.  Manchmal kommt es vor, dass ein vollst√§ndiger Scan auftritt, auf den Sie verzichten k√∂nnen, z. B. wenn Sie die Filterbedingungen vom pl / sql-Code auf die Abfrage √ºbertragen. <br><br>  ‚óè <strong>Ineffektiver Index ‚Üí ‚Äã‚ÄãLong INDEX RANGE SCAN</strong> <br>  Vielleicht ist dies sogar der h√§ufigste Fehler, f√ºr den sie aus irgendeinem Grund sehr wenig sagen - der sogenannte ineffiziente Index (langer Index-Scan, langer INDEX-BEREICH-SCAN).  Zum Beispiel haben wir eine Tabelle f√ºr Registrierungen.  In der Anfrage versuchen wir, alle Registrierungen dieses Agenten zu finden und letztendlich eine Filterbedingung hinzuzuf√ºgen, beispielsweise f√ºr einen bestimmten Zeitraum oder mit einer bestimmten Nummer oder einem bestimmten Kunden.  In solchen Situationen wird der Index aus Gr√ºnden der universellen Verwendung normalerweise nur auf dem Feld "Agent" erstellt.  Das Ergebnis ist das folgende Bild: Im ersten Arbeitsjahr hatte der Agent beispielsweise 100 Eintr√§ge in dieser Tabelle, im n√§chsten Jahr bereits 1.000, in einem anderen Jahr m√∂glicherweise 10.000 Eintr√§ge.  Nach einiger Zeit werden diese Datens√§tze zu 100.000. Offensichtlich beginnt die Anforderung langsam zu arbeiten, da Sie in der Anforderung nicht nur die Agentenkennung selbst, sondern auch einen zus√§tzlichen Filter hinzuf√ºgen m√ºssen, in diesem Fall nach Datum.  Andernfalls wird sich herausstellen, dass die Stichprobengr√∂√üe von Jahr zu Jahr zunimmt, da die Anzahl der Register f√ºr diesen Agenten zunimmt.  Dieses Problem muss auf Indexebene behoben werden.  Wenn es zu viele Daten gibt, sollten wir bereits in Richtung Partitionierung denken. <br><br>  ‚óè <strong>Unn√∂tige Verteilungscode-Verzweigungen</strong> <br>  Dies ist auch ein merkw√ºrdiger Fall, aber es passiert trotzdem.  Wir schauen uns die Top-Abfragen an und sehen dort einige seltsame Abfragen.  Wir kommen zu den Entwicklern und sagen: "Wir haben einige Anfragen gefunden. Lassen Sie uns das herausfinden und sehen, was dagegen getan werden kann."  Der Entwickler denkt nach, kommt dann nach einer Weile und sagt: ‚ÄûDieser Codezweig sollte sich nicht auf Ihrem System befinden.  Sie nutzen diese Funktionalit√§t nicht. ‚Äú  Dann empfiehlt der Entwickler, dass Sie eine spezielle Einstellung aktivieren, um diesen Abschnitt des Codes zu umgehen. <br><br><h3>  Fallstudien <br></h3><br>  Jetzt m√∂chte ich zwei Beispiele aus unserer Praxis betrachten.  Wenn wir uns mit den wichtigsten Fragen befassen, denken wir nat√ºrlich zun√§chst daran, dass es etwas Mega-Schweres, Nicht-Triviales mit komplexen Operationen geben sollte.  In der Tat ist dies nicht immer der Fall.  Manchmal gibt es F√§lle, in denen sehr einfache Abfragen in die Top-Operationen fallen. <br><br><h4>  Beispiel 1 <br></h4><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> o.* <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> rnko_dep_reestr_in_oper o <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> o.type_oper = <span class="hljs-string"><span class="hljs-string">'proc'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> o.ean_rnko <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> l.ean_rnko <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> rnko_dep_link l <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> l.s_rnko = :<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> o.date_oper_bnk <span class="hljs-keyword"><span class="hljs-keyword">desc</span></span>, o.date_reg <span class="hljs-keyword"><span class="hljs-keyword">desc</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ROWNUM</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  In diesem Beispiel besteht eine Abfrage nur aus zwei Tabellen, und dies sind keine schweren Tabellen - nur einige Millionen Datens√§tze.  Es scheint einfacher zu sein?  Die Anfrage traf jedoch ganz oben. <br><br>  Versuchen wir herauszufinden, was mit ihm los ist. <br><br>  Unten sehen Sie ein Bild aus der Enterprise Manager Cloud Control - Daten zu den Statistiken dieser Anforderung (Oracle verf√ºgt √ºber ein solches Tool).  Es ist ersichtlich, dass diese Anforderung regelm√§√üig belastet wird (oberes Diagramm).  Die Nummer 1 auf der Seite zeigt an, dass durchschnittlich nicht mehr als eine Sitzung ausgef√ºhrt wird.  Das gr√ºne Diagramm zeigt, dass die <strong>Anfrage nur die CPU verwendet</strong> , was doppelt interessant ist. <br><br><img src="https://habrastorage.org/webt/cd/jl/tm/cdjltmcxv_hgjn7ykitlcdjwdes.jpeg"><br><br>  Versuchen wir herauszufinden, was hier los ist. <br><br><img src="https://habrastorage.org/webt/gk/h9/8r/gkh98r5cr3dprhk49xl0d3-y1nm.jpeg"><br><br>  Oben finden Sie eine Tabelle mit Statistiken auf Anfrage.  Fast 700.000 Starts - das wird niemanden √ºberraschen.  Das Zeitintervall zwischen der ersten Ladezeit am 15. Dezember und der letzten Ladezeit am 22. Dezember (siehe vorheriges Bild) betr√§gt jedoch eine Woche.  Wenn Sie die Anzahl der Starts pro Sekunde z√§hlen, stellt sich heraus, dass die <strong>Abfrage durchschnittlich jede Sekunde ausgef√ºhrt wird</strong> . <br><br>  Wir schauen weiter.  Die Abfrageausf√ºhrungszeit betr√§gt 0,93 Sekunden, d.h.  weniger als eine Sekunde, das ist gro√üartig.  Wir k√∂nnen uns freuen - die Anfrage ist nicht schwer.  Trotzdem hat er die Spitze erreicht, was bedeutet, dass er viele Ressourcen verbraucht.  Wo verbraucht es viele Ressourcen? <br><br>  Die Tabelle enth√§lt eine Zeile f√ºr logische Lesungen.  Wir sehen, dass f√ºr einen Start fast 8.000 Bl√∂cke ben√∂tigt werden (normalerweise ist 1 Block 8 KB gro√ü).  Es stellt sich heraus, dass die Anforderung, die einmal pro Sekunde ausgef√ºhrt wird, ungef√§hr 64 MB Daten aus dem Speicher l√§dt.  Hier stimmt etwas nicht, wir m√ºssen verstehen. <br><br>  Schauen wir uns den Plan an: Es gibt einen vollst√§ndigen Scan.  Nun, lass uns weitermachen. <br><br><pre> <code class="sql hljs"> Plan hash value: 634977963 <span class="hljs-comment"><span class="hljs-comment">------------------------------------------------------------------- | Id | Operation | Name | ------------------------------------------------------------------- | 0 | SELECT STATEMENT | | |* 1 | COUNT STOPKEY | | | 2 | VIEW | | |* 3 | SORT ORDER BY STOPKEY | | | 4 | NESTED LOOPS | | | 5 | TABLE ACCESS BY INDEX ROWID| RNKO_DEP_LINK | |* 6 | INDEX UNIQUE SCAN | UK_RNKODEPLINK$S_RNKO | |* 7 | TABLE ACCESS FULL | RNKO_DEP_REESTR_IN_OPER | ------------------------------------------------------------------- Predicate Information (identified by operation id): 1 - filter(ROWNUM=1) 3 - filter(ROWNUM=1) 6 - access("L"."S_RNKO"=:1) 7 - filter(("O"."TYPE_OPER"='proc' AND "O"."EAN_RNKO"="L"."EAN_RNKO"))</span></span></code> </pre><br>  In der Tabelle rnko_dep_reestr_in_oper gibt es nur 5 Millionen Zeilen und ihre durchschnittliche Zeilenl√§nge betr√§gt 150 Byte.  Es stellte sich jedoch heraus, dass nicht gen√ºgend Index f√ºr das zu verbindende Feld vorhanden ist - die Unterabfrage ist √ºber das Feld ean_rnko mit der Anforderung verbunden, f√ºr das es keinen Index gibt! <br><br>  Selbst wenn er auftaucht, wird die Situation tats√§chlich nicht sehr gut sein.  Dieser lange Index-Scan (langer INDEX-BEREICH-SCAN) wird ausgef√ºhrt.  ean_rnko ist die interne Kennung des Agenten.  Agentenregister werden akkumuliert, und jedes Jahr erh√∂ht sich die Datenmenge, die diese Anfrage ausw√§hlt, und die Anfrage wird langsamer. <br><br>  <strong>L√∂sung:</strong> Erstellen Sie einen Index f√ºr die Felder ean_rnko und date_reg und bitten Sie die Entwickler, die Scan-Tiefe in dieser Anforderung nach Datum zu begrenzen.  Dann k√∂nnen Sie zumindest teilweise garantieren, dass die Abfrageleistung ungef√§hr an den gleichen Grenzen bleibt, da die Stichprobengr√∂√üe auf ein festes Zeitintervall begrenzt ist und nicht die gesamte Tabelle gelesen werden muss.  Dies ist ein sehr wichtiger Punkt, schauen Sie, was passiert ist. <br><img src="https://habrastorage.org/webt/zl/eg/b5/zlegb5nfhfvxy9bajfsxkv3u7ao.png"><br><br>  Nach der Optimierung betrug die Betriebszeit weniger als eine Hundertstelsekunde (0,93), die Anzahl der Bl√∂cke war durchschnittlich 8,5- bis 1000-mal k√ºrzer als zuvor. <br><br><h4>  Beispiel 2 <br></h4><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> loy$barcodes t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> t.id_processing = :b1 <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> t.id_rec_out <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> t.barcode <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> t.status = <span class="hljs-string"><span class="hljs-string">'u'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> t.id_card <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span></code> </pre><br>  Ich begann die Geschichte damit, dass normalerweise etwas Kompliziertes in der Abfrage oben erwartet wird.  Oben ist ein Beispiel f√ºr eine ‚Äûkomplexe‚Äú Abfrage, die an eine Tabelle (!) Geht und auch in die Top-Abfragen gelangt ist :) Es gibt einen Index f√ºr das Feld ID_PROCESSING! <br>  Diese Abfrage enth√§lt 3 IS NULL-Bedingungen. Wie wir wissen, werden solche Bedingungen nicht indiziert (in diesem Fall k√∂nnen Sie den Index nicht verwenden).  Au√üerdem gibt es nur zwei Bedingungen des Gleichheitstyps (von ID_PROCESSING und STATUS). <br><br>  Wahrscheinlich w√ºrde der Entwickler, der sich diese Abfrage ansehen w√ºrde, zun√§chst vorschlagen, einen Index f√ºr ID_PROCESSING und STATUS zu erstellen.  Angesichts der Datenmenge, die ausgew√§hlt wird (es werden viele davon sein), funktioniert diese L√∂sung jedoch nicht. <br><br>  Die Anforderung verbraucht jedoch viele Ressourcen, was bedeutet, dass etwas getan werden muss, damit sie schneller funktioniert.  Versuchen wir, die Gr√ºnde herauszufinden. <br><img src="https://habrastorage.org/webt/wt/s4/cx/wts4cxw4pwappessb8lypge_uzg.png"><br><br>  Die obigen Statistiken beziehen sich auf einen Tag, aus dem hervorgeht, dass die Anforderung alle 5 Minuten gestartet wird.  Der Hauptressourcenverbrauch ist das Lesen von CPU und Festplatte.  Unten in der Grafik mit Statistiken √ºber die Anzahl der Abfragestarts ist zu sehen, dass alles in Ordnung ist - die Anzahl der Starts √§ndert sich im Laufe der Zeit fast nicht -, eine ziemlich stabile Situation. <br><img src="https://habrastorage.org/webt/5x/09/ge/5x09gen-19peucgd4eu430ichrq.png"><br><br>  Und wenn Sie weiter schauen, k√∂nnen Sie feststellen, dass die Abfragezeit manchmal sehr unterschiedlich ist - mehrmals, was bereits von Bedeutung ist. <br><img src="https://habrastorage.org/webt/ue/tj/mx/uetjmxbf2hbrv6kvzojoshoisyy.png"><br><br>  Lassen Sie es uns als n√§chstes herausfinden. <br><br>  Oracle Enterprise Manager verf√ºgt √ºber ein SQL-Monitoring-Dienstprogramm.  Mit diesem Dienstprogramm k√∂nnen Sie den Ressourcenverbrauch auf Anfrage in Echtzeit anzeigen. <br><img src="https://habrastorage.org/webt/ap/j6/k-/apj6k--jewoeighhu8_7edfkiu8.png"><br><br>  Oben Bericht f√ºr problematische Anfrage.  Zun√§chst sollte uns die Tatsache interessieren, dass der INDEX RANGE SCAN (unterste Zeile) in der Spalte Aktuelle Zeilen 17 Millionen Zeilen enth√§lt.  Wahrscheinlich eine √úberlegung wert. <br><br>  Wenn wir uns den Umsetzungsplan genauer ansehen, stellt sich heraus, dass nach dem n√§chsten Punkt im Plan von diesen 17 Millionen Zeilen nur noch 1705 √ºbrig sind. Die Frage ist, warum 17 Millionen ausgew√§hlt wurden.  In der endg√ºltigen Stichprobe blieben etwa 0,01% <strong>, dh offensichtlich ineffizient, es wurden unn√∂tige Arbeiten durchgef√ºhrt</strong> .  Dar√ºber hinaus wird diese Arbeit alle 5 Minuten durchgef√ºhrt.  Hier ist das Problem!  Daher traf diese Anfrage die Top-Abfragen. <br><br>  Versuchen wir, dieses nicht triviale Problem zu l√∂sen.  Der Index, der sich von Anfang an selbst bittet, ist ineffizient. Sie m√ºssen sich also etwas Kniffliges einfallen lassen und die IS NULL-Bedingungen umgehen. <br><br><h4>  Neuer Index <br></h4><br>  Wir haben uns mit den Entwicklern beraten, √ºberlegt und sind zu dieser Entscheidung gekommen: Wir haben einen Funktionsindex erstellt, in dem sich eine ID_PROCESSING-Spalte befindet, die die Bedingung der Gleichheit in der Anforderung enth√§lt, und wir haben alle anderen Felder als Argumente f√ºr diese Funktion aufgenommen: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> gc.loy$barcod_unload_i <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> gc.loy$barcodes (gc.loy_barcodes_ic_unload(id_rec_out, barcode, id_card, <span class="hljs-keyword"><span class="hljs-keyword">status</span></span>), id_processing);  function loy_barcodes_ic_unload( pIdRecOut in loy$barcodes.id_rec_out%type, pBarcode in loy$barcodes.barcode%type, pIdCard in loy$barcodes.id_card%type, pStatus in loy$barcodes.status%type) return varchar2 deterministic is vRes varchar2(1) := ''; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> pIdRecOut <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> pBarcode <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> pIdCard <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> pStatus = <span class="hljs-string"><span class="hljs-string">'U'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> vRes := pStatus; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>; return vRes; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> loy_barcodes_ic_unload;</code> </pre><br>  Diese Funktion ist typdeterministisch, dh sie gibt bei demselben Parametersatz immer dieselbe Antwort.  Wir haben daf√ºr gesorgt, dass diese Funktion immer einen Wert zur√ºckgibt - in diesem Fall "U".  Wenn alle diese Bedingungen erf√ºllt sind, wird "U" ausgegeben, wenn sie nicht erf√ºllt sind - NULL.  Ein solcher Funktionsindex erm√∂glicht es, Daten effektiv zu filtern. <br><br>  Die Anwendung dieses Index f√ºhrte zu folgendem Ergebnis: <br><br><img src="https://habrastorage.org/webt/xh/wj/nb/xhwjnbiaw-hvj7uumjpwr9uu-mi.png"><br><br>  Hier ist eine Spalte ein Schnappschuss, sie werden jede halbe Stunde der Datenbank erstellt.  Wir haben unser Ziel erreicht und dieser Index war wirklich effektiv.  Sehen wir uns die quantitativen Merkmale an: <br><br><table width="408"><tbody><tr><td width="408" colspan="3">  Durchschnittliche Anforderungsstatistik <br><br></td></tr><tr><td width="174"></td><td width="124">  <strong>Vorher</strong> <br><br></td><td width="110">  <strong>NACHHER</strong> <br><br></td></tr><tr><td width="174">  Verstrichene Zeit, sek <br><br></td><td width="124">  143,21 <br><br></td><td width="110">  60.7 <br><br></td></tr><tr><td width="174">  CPU-Zeit, sek <br><br></td><td width="124">  33.23 <br><br></td><td width="110">  45,38 <br><br></td></tr><tr><td width="174">  Puffer wird blockiert <br><br></td><td width="124">  6`288`237.67 <br><br></td><td width="110">  1`589`836 <br><br></td></tr><tr><td width="174">  Block zum Lesen der Festplatte <br><br></td><td width="124">  266`600.33 <br><br></td><td width="110">  2'680 <br><br></td></tr></tbody></table><br>  Die Betriebszeit verringerte sich um das 2,5-fache und der Ressourcenverbrauch (Buffer Gets) um etwa das 4. Die Anzahl der von der Festplatte gelesenen Datenbl√∂cke nahm erheblich ab. <br><br><h3>  Proaktive Optimierungsergebnisse <br></h3><br>  Wir haben bekommen: <br><br><ul><li>  Reduzierung der Belastung der Datenbank; </li><li>  Verbesserung der Stabilit√§t der Datenbank; </li><li>  eine signifikante Reduzierung der Anzahl von Software-Performance-Vorf√§llen. </li></ul><br>  <strong>Leistungsvorf√§lle wurden um das Zehnfache verringert</strong> .  Dies ist ein subjektiver Betrag, bevor die Vorf√§lle 1-2 Mal im Monat im Komplex der RBS-Retail Bank auftraten, aber jetzt haben wir sie praktisch vergessen. <br><br>  Dies wirft die Frage auf: Was ist mit Software-Performance-Vorf√§llen?  Wir haben uns nicht direkt mit ihnen befasst? <br><br>  Zur√ºck zum letzten Zeitplan.  Wenn Sie sich erinnern, dass ein vollst√§ndiger Scan durchgef√ºhrt wurde, musste eine gro√üe Anzahl von Bl√∂cken im Speicher gespeichert werden.  Da die Anforderung regelm√§√üig ausgef√ºhrt wurde, wurden alle diese Bl√∂cke im Oracle-Cache gespeichert.  Es stellt sich heraus, dass Sie zu diesem Zeitpunkt einen Cache zum Speichern von Datenbl√∂cken ben√∂tigen, wenn zu diesem Zeitpunkt eine hohe Auslastung der Datenbank auftritt und beispielsweise jemand beginnt, den Speicher aktiv zu nutzen.  Daher wird ein Teil der Daten f√ºr unsere Anfrage verdr√§ngt, was bedeutet, dass wir physische Messungen durchf√ºhren m√ºssen.  Wenn Sie physische Messungen durchf√ºhren, erh√∂ht sich die Laufzeit der Abfrage sofort enorm. <br><br>  Das logische Lesen funktioniert mit dem Speicher, es geschieht schnell und der Zugriff auf die Festplatte ist langsam (wenn Sie sich die Zeit ansehen, Millisekunden).  Wenn Sie Gl√ºck haben und diese Daten im Cache des Betriebssystems oder im Array-Cache vorhanden sind, sind es immer noch einige zehn Mikrosekunden.  Das Lesen aus dem Oracle-Cache ist viel schneller. <br><br>  Als wir den vollst√§ndigen Scan loswurden, verschwand die Notwendigkeit, eine so gro√üe Anzahl von Bl√∂cken im Cache (Puffer-Cache) zu speichern.  Wenn diese Ressourcen fehlen, ist die Anforderung mehr oder weniger stabil.  Es gibt keine so gro√üen Spitzen mehr wie beim alten Index. <br><br>  <strong>Zusammenfassung der proaktiven Optimierung:</strong> <br><br><ul><li>  Die anf√§ngliche Abfrageoptimierung sollte auf Testservern durchgef√ºhrt werden, um zu sehen, wie die Abfragen und ihre Gesch√§ftslogik funktionieren, um nichts √úberfl√ºssiges zu tun.  Diese Arbeiten bleiben erhalten. </li><li>  In regelm√§√üigen Abst√§nden, jedoch alle paar Monate, ist es sinnvoll, Berichte bei voller Auslastung vom Server zu entfernen, nach den wichtigsten Abfragen und Vorg√§ngen in der Datenbank zu suchen und diese zu optimieren. </li></ul><br>  <strong>Es gibt viele Tools zum Abrufen von Statistiken in einer Oracle-Datenbank:</strong> <br><br><ul><li>  AWR-Bericht (DBMS_WORKLOAD_REPOSITORY.awr_report_html); </li><li>  Enterprise Manager Cloud Control 12c (SQL-Details); </li><li>  Aktiver SQL-Detailbericht (DBMS_PERF.report_sql); </li><li>  SQL-√úberwachung (Registerkarte in EMCC); </li><li>  SQL-√úberwachungsbericht (DBMS_SQLTUNE.report_sql_monitor *). </li></ul><br>  Einige dieser Tools funktionieren in der Konsole, dh sie sind nicht an den Enterprise Manager gebunden. <br><br><div class="spoiler">  <b class="spoiler_title">Beispiele f√ºr Oracle-Tools zum Sammeln von Statistiken</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/d9/nk/rr/d9nkrrmgv-omldaqotcf1vxxub0.png"><br><br><ul><li>  Das obere Diagramm zeigt, wie viele Sitzungen mit dieser Anforderung arbeiten. </li><li>  Der linke Block zeigt an, wo diese Anforderung gestartet wird und in welchen Modulen sie sich befindet. </li><li>  Unten links - Informationen zur Verwendung des gemeinsam genutzten Pools. </li><li>  Auf der rechten Seite zeigt das Diagramm die Warteereignisse im System.  In diesem Fall ist es nur die CPU. </li><li>  Unten rechts - am interessantesten - eine Platte mit Qualit√§tsmerkmalen, die bei der Analyse von Leistungsproblemen am wichtigsten sind. </li></ul><br><img src="https://habrastorage.org/webt/h-/xw/en/h-xwenxxptrffbthe3bsj-dl0n4.png"><br><br>  SQL-Monitoring zeigt, wie alles in Echtzeit aussieht (wo sich das gr√ºne Zahnrad dreht, funktioniert die Abfrage jetzt). <br><img src="https://habrastorage.org/webt/ke/3n/vg/ke3nvg_q8afcbolkbcxdnkg3qaa.png"><br><br>  Oben finden Sie den internen Inhalt des SQL-Monitoring-Berichts.  In Echtzeit wird angezeigt, welche Abfragezeile ausgef√ºhrt wird und wie viele Zeilen gelesen werden (Spalte "Aktuelle Zeilen").  In diesem Fall hat INDEX RANGE SCAN bereits 5 Millionen gez√§hlt. <br><br><img src="https://habrastorage.org/webt/ow/39/j1/ow39j1yvfaecppovtbgjb8tgsaq.png"><br><br>  Das Textwerkzeug SQL Monitoring Report, in dem einige Informationen (nicht alle) enthalten sind. <br><img src="https://habrastorage.org/webt/br/zu/py/brzupy-mengmdxvh_cppnsogl0w.png"><br></div></div><br>  <strong>Bonus: Die</strong> Spezialisten von RNCO ‚ÄûPayment Center‚Äú und CFT waren gut auf die Konferenz in Nowosibirsk vorbereitet, machten einige n√ºtzliche Berichte und organisierten auch ein echtes Exit-Radio.  Zwei Tage lang gelang es Experten, Rednern und Organisatoren, das CFT-Radio zu besuchen.  Sie k√∂nnen zum sibirischen Sommer zur√ºckkehren, indem Sie Eintr√§ge <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hinzuf√ºgen.</a> Hier sind die Links zu den Bl√∂cken: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kubernetes: Vor- und Nachteile</a> ;  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Data Science &amp; Maschinelles Lernen</a> ;  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DevOps</a> . <br><br><blockquote>  Bei HighLoad ++ in Moskau, das bereits am 8. und 9. November stattfindet, wird es noch interessantere Dinge geben.  Das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Programm</a> enth√§lt Berichte zu allen Aspekten der Arbeit an hoch belasteten Projekten, Meisterklassen, Besprechungen und Veranstaltungen von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Partnern</a> , die fachkundige Ratschl√§ge austauschen und etwas √úberraschendes finden.  Schreiben Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">unbedingt</a> √ºber die interessantesten und benachrichtigen Sie im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Newsletter</a> , verbinden Sie sich! <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de428491/">https://habr.com/ru/post/de428491/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de428477/index.html">F√ºr diejenigen, die eine Firewall w√§hlen</a></li>
<li><a href="../de428481/index.html">Digitale Vertr√§ge: Eine Kurzanleitung f√ºr NICHT Anw√§lte</a></li>
<li><a href="../de428485/index.html">Die meisten nervigen Menschen sind irrelevante Werbung und die Verwendung von Gadgets in der √ñffentlichkeit</a></li>
<li><a href="../de428487/index.html">Warum Ruby on Rails gut ist und wie es die Entwicklung beschleunigt</a></li>
<li><a href="../de428489/index.html">D√ºnnheit und Dicke der Symbole. Sketch Pro, Rendering-Funktionen und ein Spiel mit Linienst√§rke</a></li>
<li><a href="../de428493/index.html">Git subrepo</a></li>
<li><a href="../de428495/index.html">Wie ich 13 Jahre lang einen Fu√üballsimulator gemacht habe</a></li>
<li><a href="../de428497/index.html">Noolite SUF-1-300 Custom Wireless Dimmer</a></li>
<li><a href="../de428499/index.html">Gruselige blaue Riesen k√∂nnen die Geheimnisse der Sternentwicklung enth√ºllen</a></li>
<li><a href="../de428501/index.html">DartUP: Die erste russischsprachige Konferenz √ºber Dart und Flutter am 1. Dezember in St. Petersburg</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>