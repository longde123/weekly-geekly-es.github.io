<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤚🏻 🤵🏿 🐧 Proaktive Optimierung der Oracle-Datenbankleistung 🏇🏽 👩🏽‍🎨 🔑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Das erste, was uns begegnet, wenn wir über proaktive Optimierung sprechen, ist, dass nicht bekannt ist, was optimiert werden muss. "Tu das, ich weiß n...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Proaktive Optimierung der Oracle-Datenbankleistung</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/428491/">  Das erste, was uns begegnet, wenn wir über proaktive Optimierung sprechen, ist, dass nicht bekannt ist, was optimiert werden muss.  "Tu das, ich weiß nicht was." <br><br><ul><li>  Es gibt keinen klassischen Algorithmus. </li><li>  Das Problem ist noch nicht aufgetreten (unbekannt), und man kann nur raten, wo es sein könnte. </li><li>  Wir müssen einige potenzielle Schwachstellen im System finden. </li><li>  Versuchen Sie, die Abfrageleistung an diesen Stellen zu optimieren. </li></ul><br><h3>  Die Hauptziele einer proaktiven Optimierung <br></h3><br>  Die Hauptaufgaben der proaktiven Optimierung unterscheiden sich von den Aufgaben der reaktiven Optimierung und lauten wie folgt: <br><br><ul><li>  Engpässe in der Datenbank beseitigen; </li><li>  Verringerung des Ressourcenverbrauchs der Datenbank. </li></ul><br>  Der letzte Moment ist der grundlegendste.  Bei der reaktiven Optimierung haben wir nicht die Aufgabe, den Ressourcenverbrauch insgesamt zu reduzieren, sondern nur die Reaktionszeit der Funktionalität auf akzeptable Grenzen zu bringen. <br><br><img src="https://habrastorage.org/webt/zl/eg/b5/zlegb5nfhfvxy9bajfsxkv3u7ao.png"><br><br>  Wenn Sie mit Kampfservern arbeiten, haben Sie eine gute Vorstellung davon, was Leistungsvorfälle bedeuten.  Sie müssen alles beenden und das Problem schnell lösen.  RNKO Payment Center LLC arbeitet mit vielen Agenten zusammen, und es ist sehr wichtig, dass sie so wenig Probleme wie möglich haben.  Alexander Makarov von HighLoad ++ Siberia erklärte, was getan wurde, um die Anzahl der Leistungsvorfälle erheblich zu reduzieren.  Proaktive Optimierung kam zur Rettung.  Und warum und wie es auf einem Kampfserver produziert wird, lesen Sie unten. <br><a name="habracut"></a><br><img src="https://habrastorage.org/webt/r_/kt/zz/r_ktzzegcm2xca_nrh4yusjtpqy.png"><br><br>  <strong>Über den Sprecher:</strong> Alexander Makarov ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">AL_IG_Makarov</a> ), Leitender Administrator der Oracle-Datenbank, RNKO Payment Center LLC.  Trotz der Position gibt es nur sehr wenig Verwaltung als solche. Die Hauptaufgaben beziehen sich auf die Wartung des Komplexes und seine Entwicklung, insbesondere auf die Lösung von Leistungsproblemen. <br><br><h1>  Ist die Optimierung einer Kampfdatenbank proaktiv? <br></h1><br>  Zunächst werden wir uns mit den Begriffen befassen, die in diesem Bericht als "proaktive Leistungsoptimierung" bezeichnet werden.  Manchmal können Sie den Standpunkt vertreten, dass eine proaktive Optimierung darin besteht, dass die Analyse von Problembereichen bereits vor dem Start der Anwendung durchgeführt wird.  Beispielsweise stellen wir fest, dass einige Abfragen nicht optimal funktionieren, da nicht genügend Index vorhanden ist oder die Abfrage einen ineffizienten Algorithmus verwendet und diese Arbeit auf Testservern ausgeführt wird. <br><br>  Trotzdem haben wir vom RNCO dieses Projekt <strong>auf</strong> Kampfservern durchgeführt.  Oft hörte ich: „Wie so?  Du machst es auf einem Kampfserver - das heißt, es ist keine proaktive Leistungsoptimierung! “  Hier müssen wir an den Ansatz erinnern, der in ITIL gepflegt wird.  Aus ITIL-Sicht haben wir: <br><br><ul><li>  Leistungsvorfälle sind das, was bereits passiert ist; </li><li>  die Maßnahmen, die wir ergreifen, um das Auftreten von Leistungsstörungen zu verhindern. </li></ul><br>  In diesem Sinne sind unsere Handlungen proaktiv.  Trotz der Tatsache, dass wir das Problem auf einem Kampfserver lösen, ist das Problem selbst noch nicht aufgetreten: Der Vorfall ist nicht aufgetreten, wir sind nicht ausgeführt worden und haben nicht versucht, dieses Problem in kurzer Zeit zu lösen. <br><br>  In diesem Bericht wird Proaktivität als <strong>Proaktivität im Sinne von ITIL verstanden</strong> . Wir lösen das Problem, bevor ein Leistungsvorfall auftritt. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/y68RLr825VE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h1>  Bezugspunkt <br></h1><br>  Das RNKO "Payment Center" bedient zwei große Systeme: <br><br><ul><li>  RBS-Retail Bank; </li><li>  CFT Bank. </li></ul><br>  Die Art der Last auf diesen Systemen ist gemischt (DSS + OLTP): Es gibt etwas, das sehr schnell funktioniert, es gibt Berichte, es gibt mittlere Lasten. <br><br>  Wir sind mit der Tatsache konfrontiert, dass nicht sehr oft, aber mit einer bestimmten Häufigkeit, Leistungsvorfälle auftraten.  Diejenigen, die mit Kampfservern arbeiten, stellen sich vor, was es ist.  Dies bedeutet, dass Sie alles beenden und das Problem schnell lösen müssen, da der Client zu diesem Zeitpunkt den Service nicht erhalten kann, etwas entweder überhaupt nicht oder nur sehr langsam funktioniert. <br><br>  Da viele Agenten und Kunden an unsere Organisation gebunden sind, ist dies für uns sehr wichtig.  Wenn wir Leistungsvorfälle nicht schnell lösen können, leiden unsere Kunden auf die eine oder andere Weise.  Zum Beispiel können sie keine Karte auffüllen oder eine Überweisung vornehmen.  Daher haben wir uns gefragt, was getan werden kann, um selbst diese seltenen Leistungsvorfälle zu beseitigen.  In einem Modus zu arbeiten, in dem Sie alles fallen lassen und ein Problem lösen müssen - das ist nicht ganz richtig.  Wir verwenden Sprints und erstellen einen Sprint-Arbeitsplan.  Das Vorhandensein von Leistungsstörungen ist auch eine Abweichung vom Arbeitsplan. <br><br>  Damit muss etwas getan werden! <br><br><h1>  Optimierungsansätze <br></h1><br>  Wir haben über die Technologie der proaktiven Optimierung nachgedacht und sie verstanden.  Bevor ich jedoch über proaktive Optimierung spreche, muss ich einige Worte zur klassischen reaktiven Optimierung sagen. <br><br><h2>  Reaktive Optimierung <br></h2><br>  Das Szenario ist einfach: Es gibt einen Kampfserver, auf dem etwas passiert ist: Sie haben einen Bericht gestartet, Clients erhalten Anweisungen, zu diesem Zeitpunkt gibt es laufende Aktivitäten in der Datenbank, und plötzlich hat sich jemand entschlossen, ein umfangreiches Verzeichnis zu aktualisieren.  Das System beginnt langsamer zu werden.  In diesem Moment kommt der Kunde und sagt: "Ich kann dies oder das nicht tun" - wir müssen einen Grund finden, warum er dies nicht tun kann. <br><br>  <strong>Klassischer Aktionsalgorithmus:</strong> <br><br><ol><li>  Reproduzieren Sie das Problem. </li><li>  Suchen Sie die Problemstelle. </li><li>  Optimieren Sie den Problemort. </li></ol><br>  Im Rahmen des reaktiven Ansatzes besteht die Hauptaufgabe nicht darin, die Grundursache selbst zu finden und zu beseitigen, sondern das System normal funktionieren zu lassen.  Die Beseitigung der Grundursache kann später behandelt werden.  Die Hauptsache ist, den Server schnell wiederherzustellen, damit der Client den Dienst empfangen kann. <br><br><h3>  Die Hauptziele der reaktiven Optimierung <br></h3><br>  Bei der reaktiven Optimierung können zwei Hauptziele unterschieden werden: <br><br>  1. <strong>Verkürzung der Reaktionszeit</strong> . <br><br>  Eine Aktion, z. B. das Empfangen eines Berichts, einer Anweisung oder einer Transaktion, muss für eine bestimmte Zeit ausgeführt werden.  Es muss sichergestellt werden, dass der Zeitpunkt des Empfangs des Dienstes an die für den Kunden akzeptablen Grenzen zurückkehrt.  Vielleicht arbeitet der Service etwas langsamer als gewöhnlich, aber für den Kunden ist dies akzeptabel.  Dann glauben wir, dass der Leistungsvorfall beseitigt wurde, und beginnen, an der Grundursache zu arbeiten. <br><br>  2. <strong>Erhöhung der Anzahl der verarbeiteten Objekte pro Zeiteinheit während der Stapelverarbeitung</strong> . <br><br>  Während der Stapelverarbeitung von Transaktionen muss die Verarbeitungszeit eines Objekts aus dem Paket reduziert werden. <br><br>  <strong>Vorteile eines reaktiven Ansatzes:</strong> <br><br>  ● <em>Eine Vielzahl von Werkzeugen und Techniken</em> ist das Hauptvorteil eines reaktiven Ansatzes. <br><br>  Wir können die Überwachungstools verwenden, um das Problem direkt zu verstehen: Es ist nicht genügend CPU, Threads, Speicher vorhanden oder das Festplattensystem ist ausgerutscht, oder die Protokolle werden langsam verarbeitet.  Es gibt viele Tools und Techniken, um das aktuelle Leistungsproblem in der Oracle-Datenbank zu untersuchen. <br><br>  ● Die <em>gewünschte Reaktionszeit</em> ist ein weiteres Plus. <br><br>  Während dieser Arbeit bringen wir die Situation auf eine akzeptable Reaktionszeit, dh wir versuchen nicht, sie auf den Mindestwert zu reduzieren, sondern erreichen einen bestimmten Wert und beenden diese Aktion, weil wir glauben, akzeptable Grenzen erreicht zu haben. <br><br>  <strong>Nachteile des reaktiven Ansatzes:</strong> <br><br><ul><li>  <em>Leistungsvorfälle bleiben bestehen</em> - dies ist das größte Minus des reaktiven Ansatzes, da wir die Grundursache nicht immer erreichen können.  Sie hätte irgendwo fern bleiben und irgendwo tiefer liegen können, obwohl wir eine akzeptable Leistung erzielt hatten. </li></ul><br>  Und wie geht man mit Leistungsvorfällen um, wenn sie noch nicht aufgetreten sind?  Versuchen wir zu formulieren, wie eine proaktive Optimierung durchgeführt werden kann, um solche Situationen zu verhindern. <br><br><h2>  Proaktive Optimierung <br></h2><br>  Das erste, was uns begegnet, ist, dass nicht bekannt ist, was optimiert werden muss.  "Tu das, ich weiß nicht was." <br><br><ul><li>  Es gibt keinen klassischen Algorithmus. </li><li>  Das Problem ist noch nicht aufgetreten (unbekannt), und man kann nur raten, wo es sein könnte. </li><li>  Wir müssen einige potenzielle Schwachstellen im System finden. </li><li>  Versuchen Sie, die Abfrageleistung an diesen Stellen zu optimieren. </li></ul><br><h3>  Die Hauptziele einer proaktiven Optimierung <br></h3><br>  Die Hauptaufgaben der proaktiven Optimierung unterscheiden sich von den Aufgaben der reaktiven Optimierung und lauten wie folgt: <br><br><ul><li>  Engpässe in der Datenbank beseitigen; </li><li>  Verringerung des Ressourcenverbrauchs der Datenbank. </li></ul><br>  Der letzte Moment ist der grundlegendste.  Bei der reaktiven Optimierung haben wir nicht die Aufgabe, den Ressourcenverbrauch insgesamt zu reduzieren, sondern nur die Reaktionszeit der Funktionalität auf akzeptable Grenzen zu bringen. <br><br><h3>  Wie finde ich Engpässe in der Datenbank? <br></h3><br>  Wenn wir über dieses Problem nachdenken, entstehen sofort viele Unteraufgaben.  Es ist notwendig durchzuführen: <br><br><ul><li>  CPU-Test </li><li>  Lasttests für Lesevorgänge / Datensätze; </li><li>  Stresstests nach Anzahl der aktiven Sitzungen; </li><li>  Lasttests an ... etc. </li></ul><br>  Wenn wir versuchen, diese Probleme in einem Testkomplex zu simulieren, können wir feststellen, dass das auf dem Testserver aufgetretene Problem nichts mit dem Kampfproblem zu tun hat.  Dafür gibt es viele Gründe, angefangen mit der Tatsache, dass Testserver normalerweise schwächer sind.  Es ist gut, wenn es möglich ist, den Testserver zu einer exakten Kopie des Kampfservers zu machen. Dies garantiert jedoch nicht, dass die Last auf dieselbe Weise reproduziert wird, da Sie die Benutzeraktivität und viele weitere Faktoren, die sich auf die endgültige Last auswirken, genau reproduzieren müssen.  Wenn Sie versuchen, diese Situation zu simulieren, garantiert im Großen und Ganzen niemand, dass genau dasselbe passiert, was auf dem Kampfserver passieren wird. <br><br>  Wenn in einem Fall das Problem auftrat, weil eine neue Registrierung eingetroffen ist, kann es in dem anderen Fall auftreten, weil der Benutzer einen großen Bericht mit einer großen Sortierung gestartet hat, wodurch der temporäre Tabellenbereich gefüllt wurde, und als Folglich begann das System langsamer zu werden.  Das heißt, die Gründe können unterschiedlich sein und es ist nicht immer möglich, sie vorherzusagen.  Daher haben <strong>wir Versuche, auf Testservern nach Engpässen zu suchen,</strong> fast von Anfang an <strong>aufgegeben</strong> .  Wir haben uns nur auf den Kampfserver und das, was darauf geschah, verlassen. <br><br>  Was ist in diesem Fall zu tun?  Versuchen wir zu verstehen, welche Ressourcen am wahrscheinlichsten fehlen. <br><br><h3>  Verringern des Ressourcenverbrauchs der Datenbank <br></h3><br>  Aufgrund der uns zur Verfügung stehenden Industriekomplexe wird der <strong>häufigste Mangel an Ressourcen bei Festplattenlesungen und CPUs beobachtet</strong> .  Daher werden wir zunächst genau in diesen Bereichen nach Schwachstellen suchen. <br><br>  Die zweite wichtige Frage: Wie sucht man nach etwas? <br>  Die Frage ist sehr nicht trivial.  Wir verwenden Oracle Enterprise Edition mit der Option Diagnostic Pack und haben ein solches Tool für uns gefunden - <b>AWR-Berichte</b> (in anderen Editionen von Oracle können Sie <b>STATSPACK-Berichte verwenden</b> ).  In PostgreSQL gibt es ein Analogon - pgstatspack, es gibt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">pg_profile von</a> Andrey Zubkov.  Das letzte Produkt, so wie ich es verstehe, erschien und begann erst im letzten Jahr zu entwickeln.  Für MySQL konnte ich keine ähnlichen Tools finden, aber ich bin kein MySQL-Experte. <br><br>  Der Ansatz selbst ist nicht an eine bestimmte Art von Datenbank gebunden.  Wenn es möglich ist, Informationen über die Systemlast aus einem Bericht zu erhalten, können Sie mit der Technik, über die ich jetzt sprechen werde, <strong>an jeder Basis</strong> an einer proaktiven Optimierung arbeiten. <br><br><h3>  <strong>Optimierung der Top 5 Operationen</strong> <br></h3><br>  Die proaktive Optimierungstechnologie, die wir im Payment Center RNCO entwickelt haben und einsetzen, besteht aus vier Phasen. <br><br>  <strong>Stufe 1. Wir erhalten den AWR-Bericht für den größtmöglichen Zeitraum.</strong> <br><br>  Es wird die größtmögliche Zeit benötigt, um die Last an verschiedenen Wochentagen zu mitteln, da sie manchmal sehr unterschiedlich ist.  Zum Beispiel kommen Registries der letzten Woche am Dienstag bei der RBS-Retail Bank an, sie werden verarbeitet, und den ganzen Tag haben wir eine durchschnittliche Auslastung von etwa zwei bis drei Mal.  An anderen Tagen ist die Belastung geringer. <br><br>  Wenn Sie wissen, dass das System einige Besonderheiten aufweist - an manchen Tagen ist die Last größer, an manchen Tagen geringer -, müssen Sie Berichte für diese Zeiträume separat erhalten und separat damit arbeiten, wenn wir bestimmte Zeitintervalle optimieren möchten .  Wenn Sie die Gesamtsituation auf dem Server optimieren müssen, können Sie einen umfangreichen Bericht für den Monat abrufen und sehen, was die Ressourcen des Servers tatsächlich verbrauchen. <br><br>  Manchmal treten sehr unerwartete Situationen auf.  Im Fall der CFT Bank befindet sich beispielsweise eine Anforderung, die die Berichtsserverwarteschlange überprüft, möglicherweise unter den Top 10.  Darüber hinaus ist diese Anforderung offiziell und führt keine Geschäftslogik aus, sondern prüft nur, ob ein Bericht über die Ausführung vorliegt oder nicht. <br><br>  <strong>Stufe 2. Wir schauen uns Abschnitte an:</strong> <br><br><ul><li>  SQL nach verstrichener Zeit geordnet - SQL-Abfragen sortiert nach Laufzeit; </li><li>  SQL geordnet nach CPU-Zeit - für die CPU-Auslastung; </li><li>  SQL sortiert nach Gets - nach logischen Lesungen; </li><li>  Von Reads geordnetes SQL - für physische Lesungen. </li></ul><br>  Die verbleibenden Abschnitte von SQL, die nach geordnet sind, werden nach Bedarf untersucht. <br><br>  <strong>Stufe 3. Wir bestimmen übergeordnete Operationen und Anforderungen, die von ihnen abhängen.</strong> <br><br>  Der AWR-Bericht enthält separate Abschnitte, in denen je nach Oracle-Version in jedem dieser Abschnitte 15 oder mehr Top-Abfragen angezeigt werden.  Diese Abfragen von Oracle im AWR-Bericht zeigen jedoch ein Durcheinander. <br>  Zum Beispiel gibt es eine übergeordnete Operation, in der sich drei Top-Abfragen befinden können.  Oracle im AWR-Bericht zeigt sowohl die übergeordnete Operation als auch alle diese drei Abfragen an.  Daher müssen Sie eine Analyse dieser Liste durchführen und feststellen, auf welche betriebsspezifischen Anforderungen Bezug genommen wird, und sie gruppieren. <br><br>  <strong>Stufe 4. Wir optimieren die Top 5 Operationen.</strong> <br><br>  Nach einer solchen Gruppierung ist die Ausgabe eine Liste von Operationen, aus denen Sie die schwierigsten auswählen können.  Wir sind auf 5 Operationen beschränkt (keine Anfragen, nämlich Operationen).  Wenn das System komplexer ist, können Sie mehr nehmen. <br><br><h3>  Häufige Fehler beim Entwurf von Abfragen <br></h3><br>  Während der Anwendung dieser Technik haben wir eine kleine Liste typischer Konstruktionsfehler zusammengestellt.  Einige Fehler sind so einfach, dass es den Anschein hat, als könnten sie nicht sein. <br><br>  ● <strong>Fehlender Index → ​​Vollständiger Scan</strong> <br>  Es gibt sehr zufällige Fälle, in denen beispielsweise kein Index für das Kampfschema vorhanden ist.  Wir hatten ein konkretes Beispiel, bei dem eine Abfrage lange Zeit ohne Index schnell funktionierte.  Es gab jedoch einen vollständigen Scan, und als die Größe der Tabelle allmählich zunahm, begann die Abfrage langsamer zu arbeiten, und von Quartal zu Quartal dauerte es etwas länger.  Am Ende haben wir auf ihn geachtet und es stellte sich heraus, dass der Index nicht da ist. <br><br>  ● <strong>Große Auswahl → Vollständiger Scan</strong> <br>  Der zweite häufige Fehler ist ein großes Datenmuster - der klassische Fall eines vollständigen Scans.  Jeder weiß, dass ein vollständiger Scan nur verwendet werden sollte, wenn dies wirklich gerechtfertigt ist.  Manchmal kommt es vor, dass ein vollständiger Scan auftritt, auf den Sie verzichten können, z. B. wenn Sie die Filterbedingungen vom pl / sql-Code auf die Abfrage übertragen. <br><br>  ● <strong>Ineffektiver Index → ​​Long INDEX RANGE SCAN</strong> <br>  Vielleicht ist dies sogar der häufigste Fehler, für den sie aus irgendeinem Grund sehr wenig sagen - der sogenannte ineffiziente Index (langer Index-Scan, langer INDEX-BEREICH-SCAN).  Zum Beispiel haben wir eine Tabelle für Registrierungen.  In der Anfrage versuchen wir, alle Registrierungen dieses Agenten zu finden und letztendlich eine Filterbedingung hinzuzufügen, beispielsweise für einen bestimmten Zeitraum oder mit einer bestimmten Nummer oder einem bestimmten Kunden.  In solchen Situationen wird der Index aus Gründen der universellen Verwendung normalerweise nur auf dem Feld "Agent" erstellt.  Das Ergebnis ist das folgende Bild: Im ersten Arbeitsjahr hatte der Agent beispielsweise 100 Einträge in dieser Tabelle, im nächsten Jahr bereits 1.000, in einem anderen Jahr möglicherweise 10.000 Einträge.  Nach einiger Zeit werden diese Datensätze zu 100.000. Offensichtlich beginnt die Anforderung langsam zu arbeiten, da Sie in der Anforderung nicht nur die Agentenkennung selbst, sondern auch einen zusätzlichen Filter hinzufügen müssen, in diesem Fall nach Datum.  Andernfalls wird sich herausstellen, dass die Stichprobengröße von Jahr zu Jahr zunimmt, da die Anzahl der Register für diesen Agenten zunimmt.  Dieses Problem muss auf Indexebene behoben werden.  Wenn es zu viele Daten gibt, sollten wir bereits in Richtung Partitionierung denken. <br><br>  ● <strong>Unnötige Verteilungscode-Verzweigungen</strong> <br>  Dies ist auch ein merkwürdiger Fall, aber es passiert trotzdem.  Wir schauen uns die Top-Abfragen an und sehen dort einige seltsame Abfragen.  Wir kommen zu den Entwicklern und sagen: "Wir haben einige Anfragen gefunden. Lassen Sie uns das herausfinden und sehen, was dagegen getan werden kann."  Der Entwickler denkt nach, kommt dann nach einer Weile und sagt: „Dieser Codezweig sollte sich nicht auf Ihrem System befinden.  Sie nutzen diese Funktionalität nicht. “  Dann empfiehlt der Entwickler, dass Sie eine spezielle Einstellung aktivieren, um diesen Abschnitt des Codes zu umgehen. <br><br><h3>  Fallstudien <br></h3><br>  Jetzt möchte ich zwei Beispiele aus unserer Praxis betrachten.  Wenn wir uns mit den wichtigsten Fragen befassen, denken wir natürlich zunächst daran, dass es etwas Mega-Schweres, Nicht-Triviales mit komplexen Operationen geben sollte.  In der Tat ist dies nicht immer der Fall.  Manchmal gibt es Fälle, in denen sehr einfache Abfragen in die Top-Operationen fallen. <br><br><h4>  Beispiel 1 <br></h4><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> o.* <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> rnko_dep_reestr_in_oper o <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> o.type_oper = <span class="hljs-string"><span class="hljs-string">'proc'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> o.ean_rnko <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> l.ean_rnko <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> rnko_dep_link l <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> l.s_rnko = :<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> o.date_oper_bnk <span class="hljs-keyword"><span class="hljs-keyword">desc</span></span>, o.date_reg <span class="hljs-keyword"><span class="hljs-keyword">desc</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ROWNUM</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  In diesem Beispiel besteht eine Abfrage nur aus zwei Tabellen, und dies sind keine schweren Tabellen - nur einige Millionen Datensätze.  Es scheint einfacher zu sein?  Die Anfrage traf jedoch ganz oben. <br><br>  Versuchen wir herauszufinden, was mit ihm los ist. <br><br>  Unten sehen Sie ein Bild aus der Enterprise Manager Cloud Control - Daten zu den Statistiken dieser Anforderung (Oracle verfügt über ein solches Tool).  Es ist ersichtlich, dass diese Anforderung regelmäßig belastet wird (oberes Diagramm).  Die Nummer 1 auf der Seite zeigt an, dass durchschnittlich nicht mehr als eine Sitzung ausgeführt wird.  Das grüne Diagramm zeigt, dass die <strong>Anfrage nur die CPU verwendet</strong> , was doppelt interessant ist. <br><br><img src="https://habrastorage.org/webt/cd/jl/tm/cdjltmcxv_hgjn7ykitlcdjwdes.jpeg"><br><br>  Versuchen wir herauszufinden, was hier los ist. <br><br><img src="https://habrastorage.org/webt/gk/h9/8r/gkh98r5cr3dprhk49xl0d3-y1nm.jpeg"><br><br>  Oben finden Sie eine Tabelle mit Statistiken auf Anfrage.  Fast 700.000 Starts - das wird niemanden überraschen.  Das Zeitintervall zwischen der ersten Ladezeit am 15. Dezember und der letzten Ladezeit am 22. Dezember (siehe vorheriges Bild) beträgt jedoch eine Woche.  Wenn Sie die Anzahl der Starts pro Sekunde zählen, stellt sich heraus, dass die <strong>Abfrage durchschnittlich jede Sekunde ausgeführt wird</strong> . <br><br>  Wir schauen weiter.  Die Abfrageausführungszeit beträgt 0,93 Sekunden, d.h.  weniger als eine Sekunde, das ist großartig.  Wir können uns freuen - die Anfrage ist nicht schwer.  Trotzdem hat er die Spitze erreicht, was bedeutet, dass er viele Ressourcen verbraucht.  Wo verbraucht es viele Ressourcen? <br><br>  Die Tabelle enthält eine Zeile für logische Lesungen.  Wir sehen, dass für einen Start fast 8.000 Blöcke benötigt werden (normalerweise ist 1 Block 8 KB groß).  Es stellt sich heraus, dass die Anforderung, die einmal pro Sekunde ausgeführt wird, ungefähr 64 MB Daten aus dem Speicher lädt.  Hier stimmt etwas nicht, wir müssen verstehen. <br><br>  Schauen wir uns den Plan an: Es gibt einen vollständigen Scan.  Nun, lass uns weitermachen. <br><br><pre> <code class="sql hljs"> Plan hash value: 634977963 <span class="hljs-comment"><span class="hljs-comment">------------------------------------------------------------------- | Id | Operation | Name | ------------------------------------------------------------------- | 0 | SELECT STATEMENT | | |* 1 | COUNT STOPKEY | | | 2 | VIEW | | |* 3 | SORT ORDER BY STOPKEY | | | 4 | NESTED LOOPS | | | 5 | TABLE ACCESS BY INDEX ROWID| RNKO_DEP_LINK | |* 6 | INDEX UNIQUE SCAN | UK_RNKODEPLINK$S_RNKO | |* 7 | TABLE ACCESS FULL | RNKO_DEP_REESTR_IN_OPER | ------------------------------------------------------------------- Predicate Information (identified by operation id): 1 - filter(ROWNUM=1) 3 - filter(ROWNUM=1) 6 - access("L"."S_RNKO"=:1) 7 - filter(("O"."TYPE_OPER"='proc' AND "O"."EAN_RNKO"="L"."EAN_RNKO"))</span></span></code> </pre><br>  In der Tabelle rnko_dep_reestr_in_oper gibt es nur 5 Millionen Zeilen und ihre durchschnittliche Zeilenlänge beträgt 150 Byte.  Es stellte sich jedoch heraus, dass nicht genügend Index für das zu verbindende Feld vorhanden ist - die Unterabfrage ist über das Feld ean_rnko mit der Anforderung verbunden, für das es keinen Index gibt! <br><br>  Selbst wenn er auftaucht, wird die Situation tatsächlich nicht sehr gut sein.  Dieser lange Index-Scan (langer INDEX-BEREICH-SCAN) wird ausgeführt.  ean_rnko ist die interne Kennung des Agenten.  Agentenregister werden akkumuliert, und jedes Jahr erhöht sich die Datenmenge, die diese Anfrage auswählt, und die Anfrage wird langsamer. <br><br>  <strong>Lösung:</strong> Erstellen Sie einen Index für die Felder ean_rnko und date_reg und bitten Sie die Entwickler, die Scan-Tiefe in dieser Anforderung nach Datum zu begrenzen.  Dann können Sie zumindest teilweise garantieren, dass die Abfrageleistung ungefähr an den gleichen Grenzen bleibt, da die Stichprobengröße auf ein festes Zeitintervall begrenzt ist und nicht die gesamte Tabelle gelesen werden muss.  Dies ist ein sehr wichtiger Punkt, schauen Sie, was passiert ist. <br><img src="https://habrastorage.org/webt/zl/eg/b5/zlegb5nfhfvxy9bajfsxkv3u7ao.png"><br><br>  Nach der Optimierung betrug die Betriebszeit weniger als eine Hundertstelsekunde (0,93), die Anzahl der Blöcke war durchschnittlich 8,5- bis 1000-mal kürzer als zuvor. <br><br><h4>  Beispiel 2 <br></h4><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> loy$barcodes t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> t.id_processing = :b1 <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> t.id_rec_out <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> t.barcode <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> t.status = <span class="hljs-string"><span class="hljs-string">'u'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> t.id_card <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span></code> </pre><br>  Ich begann die Geschichte damit, dass normalerweise etwas Kompliziertes in der Abfrage oben erwartet wird.  Oben ist ein Beispiel für eine „komplexe“ Abfrage, die an eine Tabelle (!) Geht und auch in die Top-Abfragen gelangt ist :) Es gibt einen Index für das Feld ID_PROCESSING! <br>  Diese Abfrage enthält 3 IS NULL-Bedingungen. Wie wir wissen, werden solche Bedingungen nicht indiziert (in diesem Fall können Sie den Index nicht verwenden).  Außerdem gibt es nur zwei Bedingungen des Gleichheitstyps (von ID_PROCESSING und STATUS). <br><br>  Wahrscheinlich würde der Entwickler, der sich diese Abfrage ansehen würde, zunächst vorschlagen, einen Index für ID_PROCESSING und STATUS zu erstellen.  Angesichts der Datenmenge, die ausgewählt wird (es werden viele davon sein), funktioniert diese Lösung jedoch nicht. <br><br>  Die Anforderung verbraucht jedoch viele Ressourcen, was bedeutet, dass etwas getan werden muss, damit sie schneller funktioniert.  Versuchen wir, die Gründe herauszufinden. <br><img src="https://habrastorage.org/webt/wt/s4/cx/wts4cxw4pwappessb8lypge_uzg.png"><br><br>  Die obigen Statistiken beziehen sich auf einen Tag, aus dem hervorgeht, dass die Anforderung alle 5 Minuten gestartet wird.  Der Hauptressourcenverbrauch ist das Lesen von CPU und Festplatte.  Unten in der Grafik mit Statistiken über die Anzahl der Abfragestarts ist zu sehen, dass alles in Ordnung ist - die Anzahl der Starts ändert sich im Laufe der Zeit fast nicht -, eine ziemlich stabile Situation. <br><img src="https://habrastorage.org/webt/5x/09/ge/5x09gen-19peucgd4eu430ichrq.png"><br><br>  Und wenn Sie weiter schauen, können Sie feststellen, dass die Abfragezeit manchmal sehr unterschiedlich ist - mehrmals, was bereits von Bedeutung ist. <br><img src="https://habrastorage.org/webt/ue/tj/mx/uetjmxbf2hbrv6kvzojoshoisyy.png"><br><br>  Lassen Sie es uns als nächstes herausfinden. <br><br>  Oracle Enterprise Manager verfügt über ein SQL-Monitoring-Dienstprogramm.  Mit diesem Dienstprogramm können Sie den Ressourcenverbrauch auf Anfrage in Echtzeit anzeigen. <br><img src="https://habrastorage.org/webt/ap/j6/k-/apj6k--jewoeighhu8_7edfkiu8.png"><br><br>  Oben Bericht für problematische Anfrage.  Zunächst sollte uns die Tatsache interessieren, dass der INDEX RANGE SCAN (unterste Zeile) in der Spalte Aktuelle Zeilen 17 Millionen Zeilen enthält.  Wahrscheinlich eine Überlegung wert. <br><br>  Wenn wir uns den Umsetzungsplan genauer ansehen, stellt sich heraus, dass nach dem nächsten Punkt im Plan von diesen 17 Millionen Zeilen nur noch 1705 übrig sind. Die Frage ist, warum 17 Millionen ausgewählt wurden.  In der endgültigen Stichprobe blieben etwa 0,01% <strong>, dh offensichtlich ineffizient, es wurden unnötige Arbeiten durchgeführt</strong> .  Darüber hinaus wird diese Arbeit alle 5 Minuten durchgeführt.  Hier ist das Problem!  Daher traf diese Anfrage die Top-Abfragen. <br><br>  Versuchen wir, dieses nicht triviale Problem zu lösen.  Der Index, der sich von Anfang an selbst bittet, ist ineffizient. Sie müssen sich also etwas Kniffliges einfallen lassen und die IS NULL-Bedingungen umgehen. <br><br><h4>  Neuer Index <br></h4><br>  Wir haben uns mit den Entwicklern beraten, überlegt und sind zu dieser Entscheidung gekommen: Wir haben einen Funktionsindex erstellt, in dem sich eine ID_PROCESSING-Spalte befindet, die die Bedingung der Gleichheit in der Anforderung enthält, und wir haben alle anderen Felder als Argumente für diese Funktion aufgenommen: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> gc.loy$barcod_unload_i <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> gc.loy$barcodes (gc.loy_barcodes_ic_unload(id_rec_out, barcode, id_card, <span class="hljs-keyword"><span class="hljs-keyword">status</span></span>), id_processing);  function loy_barcodes_ic_unload( pIdRecOut in loy$barcodes.id_rec_out%type, pBarcode in loy$barcodes.barcode%type, pIdCard in loy$barcodes.id_card%type, pStatus in loy$barcodes.status%type) return varchar2 deterministic is vRes varchar2(1) := ''; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> pIdRecOut <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> pBarcode <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> pIdCard <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> pStatus = <span class="hljs-string"><span class="hljs-string">'U'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> vRes := pStatus; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>; return vRes; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> loy_barcodes_ic_unload;</code> </pre><br>  Diese Funktion ist typdeterministisch, dh sie gibt bei demselben Parametersatz immer dieselbe Antwort.  Wir haben dafür gesorgt, dass diese Funktion immer einen Wert zurückgibt - in diesem Fall "U".  Wenn alle diese Bedingungen erfüllt sind, wird "U" ausgegeben, wenn sie nicht erfüllt sind - NULL.  Ein solcher Funktionsindex ermöglicht es, Daten effektiv zu filtern. <br><br>  Die Anwendung dieses Index führte zu folgendem Ergebnis: <br><br><img src="https://habrastorage.org/webt/xh/wj/nb/xhwjnbiaw-hvj7uumjpwr9uu-mi.png"><br><br>  Hier ist eine Spalte ein Schnappschuss, sie werden jede halbe Stunde der Datenbank erstellt.  Wir haben unser Ziel erreicht und dieser Index war wirklich effektiv.  Sehen wir uns die quantitativen Merkmale an: <br><br><table width="408"><tbody><tr><td width="408" colspan="3">  Durchschnittliche Anforderungsstatistik <br><br></td></tr><tr><td width="174"></td><td width="124">  <strong>Vorher</strong> <br><br></td><td width="110">  <strong>NACHHER</strong> <br><br></td></tr><tr><td width="174">  Verstrichene Zeit, sek <br><br></td><td width="124">  143,21 <br><br></td><td width="110">  60.7 <br><br></td></tr><tr><td width="174">  CPU-Zeit, sek <br><br></td><td width="124">  33.23 <br><br></td><td width="110">  45,38 <br><br></td></tr><tr><td width="174">  Puffer wird blockiert <br><br></td><td width="124">  6`288`237.67 <br><br></td><td width="110">  1`589`836 <br><br></td></tr><tr><td width="174">  Block zum Lesen der Festplatte <br><br></td><td width="124">  266`600.33 <br><br></td><td width="110">  2'680 <br><br></td></tr></tbody></table><br>  Die Betriebszeit verringerte sich um das 2,5-fache und der Ressourcenverbrauch (Buffer Gets) um etwa das 4. Die Anzahl der von der Festplatte gelesenen Datenblöcke nahm erheblich ab. <br><br><h3>  Proaktive Optimierungsergebnisse <br></h3><br>  Wir haben bekommen: <br><br><ul><li>  Reduzierung der Belastung der Datenbank; </li><li>  Verbesserung der Stabilität der Datenbank; </li><li>  eine signifikante Reduzierung der Anzahl von Software-Performance-Vorfällen. </li></ul><br>  <strong>Leistungsvorfälle wurden um das Zehnfache verringert</strong> .  Dies ist ein subjektiver Betrag, bevor die Vorfälle 1-2 Mal im Monat im Komplex der RBS-Retail Bank auftraten, aber jetzt haben wir sie praktisch vergessen. <br><br>  Dies wirft die Frage auf: Was ist mit Software-Performance-Vorfällen?  Wir haben uns nicht direkt mit ihnen befasst? <br><br>  Zurück zum letzten Zeitplan.  Wenn Sie sich erinnern, dass ein vollständiger Scan durchgeführt wurde, musste eine große Anzahl von Blöcken im Speicher gespeichert werden.  Da die Anforderung regelmäßig ausgeführt wurde, wurden alle diese Blöcke im Oracle-Cache gespeichert.  Es stellt sich heraus, dass Sie zu diesem Zeitpunkt einen Cache zum Speichern von Datenblöcken benötigen, wenn zu diesem Zeitpunkt eine hohe Auslastung der Datenbank auftritt und beispielsweise jemand beginnt, den Speicher aktiv zu nutzen.  Daher wird ein Teil der Daten für unsere Anfrage verdrängt, was bedeutet, dass wir physische Messungen durchführen müssen.  Wenn Sie physische Messungen durchführen, erhöht sich die Laufzeit der Abfrage sofort enorm. <br><br>  Das logische Lesen funktioniert mit dem Speicher, es geschieht schnell und der Zugriff auf die Festplatte ist langsam (wenn Sie sich die Zeit ansehen, Millisekunden).  Wenn Sie Glück haben und diese Daten im Cache des Betriebssystems oder im Array-Cache vorhanden sind, sind es immer noch einige zehn Mikrosekunden.  Das Lesen aus dem Oracle-Cache ist viel schneller. <br><br>  Als wir den vollständigen Scan loswurden, verschwand die Notwendigkeit, eine so große Anzahl von Blöcken im Cache (Puffer-Cache) zu speichern.  Wenn diese Ressourcen fehlen, ist die Anforderung mehr oder weniger stabil.  Es gibt keine so großen Spitzen mehr wie beim alten Index. <br><br>  <strong>Zusammenfassung der proaktiven Optimierung:</strong> <br><br><ul><li>  Die anfängliche Abfrageoptimierung sollte auf Testservern durchgeführt werden, um zu sehen, wie die Abfragen und ihre Geschäftslogik funktionieren, um nichts Überflüssiges zu tun.  Diese Arbeiten bleiben erhalten. </li><li>  In regelmäßigen Abständen, jedoch alle paar Monate, ist es sinnvoll, Berichte bei voller Auslastung vom Server zu entfernen, nach den wichtigsten Abfragen und Vorgängen in der Datenbank zu suchen und diese zu optimieren. </li></ul><br>  <strong>Es gibt viele Tools zum Abrufen von Statistiken in einer Oracle-Datenbank:</strong> <br><br><ul><li>  AWR-Bericht (DBMS_WORKLOAD_REPOSITORY.awr_report_html); </li><li>  Enterprise Manager Cloud Control 12c (SQL-Details); </li><li>  Aktiver SQL-Detailbericht (DBMS_PERF.report_sql); </li><li>  SQL-Überwachung (Registerkarte in EMCC); </li><li>  SQL-Überwachungsbericht (DBMS_SQLTUNE.report_sql_monitor *). </li></ul><br>  Einige dieser Tools funktionieren in der Konsole, dh sie sind nicht an den Enterprise Manager gebunden. <br><br><div class="spoiler">  <b class="spoiler_title">Beispiele für Oracle-Tools zum Sammeln von Statistiken</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/d9/nk/rr/d9nkrrmgv-omldaqotcf1vxxub0.png"><br><br><ul><li>  Das obere Diagramm zeigt, wie viele Sitzungen mit dieser Anforderung arbeiten. </li><li>  Der linke Block zeigt an, wo diese Anforderung gestartet wird und in welchen Modulen sie sich befindet. </li><li>  Unten links - Informationen zur Verwendung des gemeinsam genutzten Pools. </li><li>  Auf der rechten Seite zeigt das Diagramm die Warteereignisse im System.  In diesem Fall ist es nur die CPU. </li><li>  Unten rechts - am interessantesten - eine Platte mit Qualitätsmerkmalen, die bei der Analyse von Leistungsproblemen am wichtigsten sind. </li></ul><br><img src="https://habrastorage.org/webt/h-/xw/en/h-xwenxxptrffbthe3bsj-dl0n4.png"><br><br>  SQL-Monitoring zeigt, wie alles in Echtzeit aussieht (wo sich das grüne Zahnrad dreht, funktioniert die Abfrage jetzt). <br><img src="https://habrastorage.org/webt/ke/3n/vg/ke3nvg_q8afcbolkbcxdnkg3qaa.png"><br><br>  Oben finden Sie den internen Inhalt des SQL-Monitoring-Berichts.  In Echtzeit wird angezeigt, welche Abfragezeile ausgeführt wird und wie viele Zeilen gelesen werden (Spalte "Aktuelle Zeilen").  In diesem Fall hat INDEX RANGE SCAN bereits 5 Millionen gezählt. <br><br><img src="https://habrastorage.org/webt/ow/39/j1/ow39j1yvfaecppovtbgjb8tgsaq.png"><br><br>  Das Textwerkzeug SQL Monitoring Report, in dem einige Informationen (nicht alle) enthalten sind. <br><img src="https://habrastorage.org/webt/br/zu/py/brzupy-mengmdxvh_cppnsogl0w.png"><br></div></div><br>  <strong>Bonus: Die</strong> Spezialisten von RNCO „Payment Center“ und CFT waren gut auf die Konferenz in Nowosibirsk vorbereitet, machten einige nützliche Berichte und organisierten auch ein echtes Exit-Radio.  Zwei Tage lang gelang es Experten, Rednern und Organisatoren, das CFT-Radio zu besuchen.  Sie können zum sibirischen Sommer zurückkehren, indem Sie Einträge <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hinzufügen.</a> Hier sind die Links zu den Blöcken: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kubernetes: Vor- und Nachteile</a> ;  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Data Science &amp; Maschinelles Lernen</a> ;  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DevOps</a> . <br><br><blockquote>  Bei HighLoad ++ in Moskau, das bereits am 8. und 9. November stattfindet, wird es noch interessantere Dinge geben.  Das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Programm</a> enthält Berichte zu allen Aspekten der Arbeit an hoch belasteten Projekten, Meisterklassen, Besprechungen und Veranstaltungen von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Partnern</a> , die fachkundige Ratschläge austauschen und etwas Überraschendes finden.  Schreiben Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">unbedingt</a> über die interessantesten und benachrichtigen Sie im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Newsletter</a> , verbinden Sie sich! <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de428491/">https://habr.com/ru/post/de428491/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de428477/index.html">Für diejenigen, die eine Firewall wählen</a></li>
<li><a href="../de428481/index.html">Digitale Verträge: Eine Kurzanleitung für NICHT Anwälte</a></li>
<li><a href="../de428485/index.html">Die meisten nervigen Menschen sind irrelevante Werbung und die Verwendung von Gadgets in der Öffentlichkeit</a></li>
<li><a href="../de428487/index.html">Warum Ruby on Rails gut ist und wie es die Entwicklung beschleunigt</a></li>
<li><a href="../de428489/index.html">Dünnheit und Dicke der Symbole. Sketch Pro, Rendering-Funktionen und ein Spiel mit Linienstärke</a></li>
<li><a href="../de428493/index.html">Git subrepo</a></li>
<li><a href="../de428495/index.html">Wie ich 13 Jahre lang einen Fußballsimulator gemacht habe</a></li>
<li><a href="../de428497/index.html">Noolite SUF-1-300 Custom Wireless Dimmer</a></li>
<li><a href="../de428499/index.html">Gruselige blaue Riesen können die Geheimnisse der Sternentwicklung enthüllen</a></li>
<li><a href="../de428501/index.html">DartUP: Die erste russischsprachige Konferenz über Dart und Flutter am 1. Dezember in St. Petersburg</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>