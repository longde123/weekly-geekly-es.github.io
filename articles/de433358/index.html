<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ§‘ğŸ¼â€ğŸ¤â€ğŸ§‘ğŸ» ğŸŠ ğŸ§‘ğŸ¿ Vertrautheit mit dem Testen in Python. Teil 1 ğŸŒˆ ğŸˆ ğŸ‘©ğŸ¾â€âš•ï¸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Guten Tag an alle! 

 Von unserem Tisch zu Ihrem ... Das heiÃŸt, aus unserem Kurs "Python Developer" haben wir trotz des sich schnell nÃ¤hernden neuen J...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Vertrautheit mit dem Testen in Python. Teil 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/433358/"> Guten Tag an alle! <br><br>  <s>Von unserem Tisch zu Ihrem ...</s> Das heiÃŸt, aus unserem Kurs "Python Developer" haben wir trotz des sich schnell nÃ¤hernden neuen Jahres eine interessante Ãœbersetzung fÃ¼r Sie Ã¼ber verschiedene Testmethoden in Python vorbereitet. <br><br>  Dieses Handbuch richtet sich an Benutzer, die bereits eine coole Python-Anwendung geschrieben haben, fÃ¼r die sie jedoch noch nicht geschrieben haben <br>  sie Tests. <br><br>  Das Testen in Python ist ein umfangreiches Thema mit einer Reihe von Feinheiten, aber es ist nicht notwendig, die Dinge zu komplizieren.  In wenigen einfachen Schritten kÃ¶nnen Sie einfache Tests fÃ¼r die Anwendung erstellen und die KomplexitÃ¤t basierend auf diesen schrittweise erhÃ¶hen. <br><br>  In diesem Handbuch erfahren Sie, wie Sie einen Basistest erstellen, ausfÃ¼hren und alle Fehler finden, bevor Benutzer dies tun!  Sie lernen die verfÃ¼gbaren Tools zum Schreiben und AusfÃ¼hren von Tests kennen, Ã¼berprÃ¼fen die Anwendungsleistung und sehen sich sogar Sicherheitsprobleme an. <br><br><img src="https://habrastorage.org/webt/kh/va/x5/khvax5ew8tluy6c9muhw-oei7cm.png"><br><a name="habracut"></a><br>  <b>Codetests</b> <br><br>  Sie kÃ¶nnen den Code auf viele Arten testen.  In diesem Handbuch lernen Sie die Methoden von den einfachsten bis zu den fortgeschrittensten kennen. <br><br>  <i><b>Automatisiert vs.</b></i>  <i><b>Manuelles Testen</b></i> <i><br></i> <br>  Gute Neuigkeiten!  HÃ¶chstwahrscheinlich haben Sie den Test bereits durchgefÃ¼hrt, ihn aber noch nicht realisiert.  Erinnern Sie sich, wie Sie die Anwendung zum ersten Mal gestartet und verwendet haben?  Haben Sie die Funktionen getestet und damit experimentiert?  Dieser Prozess wird als Erkundungstest bezeichnet und ist eine Form des manuellen Testens. <br><br>  Forschungstests - Tests, die ohne Plan durchgefÃ¼hrt werden.  WÃ¤hrend der Forschungstests recherchieren Sie die Anwendung. <br><br>  Um eine vollstÃ¤ndige Liste manueller Tests zu erstellen, reicht es aus, eine Liste aller Funktionen der Anwendung, der verschiedenen Arten von Eingaben, die sie akzeptiert, und der erwarteten Ergebnisse zu erstellen.  Jedes Mal, wenn Sie etwas im Code Ã¤ndern, mÃ¼ssen Sie jedes der Elemente in dieser Liste erneut Ã¼berprÃ¼fen. <br><br>  Klingt dÃ¼ster, oder? <br><br>  Daher sind automatische Tests erforderlich.  Automatisches Testen - Die AusfÃ¼hrung des Testplans (Teile der Anwendung, die getestet werden mÃ¼ssen, die Reihenfolge der Tests und die erwarteten Ergebnisse) mithilfe eines Skripts und nicht von Menschenhand.  Python verfÃ¼gt bereits Ã¼ber eine Reihe von Tools und Bibliotheken, mit denen Sie automatisierte Tests fÃ¼r Ihre Anwendung erstellen kÃ¶nnen.  Schauen wir uns diese Tools und Bibliotheken in unserem Tutorial an. <br><br>  <i><b>Unit Tests VS.</b></i>  <i><b>Integrationstests</b></i> <br><br>  Die Welt des Testens ist voller Begriffe, und jetzt, da wir den Unterschied zwischen manuellen und automatisierten Tests kennen, werden wir eine Ebene tiefer gehen. <br><br>  Ãœberlegen Sie, wie Sie die Scheinwerfer eines Autos testen kÃ¶nnen?  Sie schalten die Scheinwerfer ein (nennen wir es den Testschritt), steigen selbst aus dem Auto oder bitten einen Freund, zu Ã¼berprÃ¼fen, ob die Scheinwerfer leuchten (und dies ist ein Testvorschlag).  Das Testen mehrerer Komponenten wird als Integrationstest bezeichnet. <br><br>  Denken Sie an alle Dinge, die richtig funktionieren sollten, damit eine einfache Aufgabe das richtige Ergebnis liefert.  Diese Komponenten Ã¤hneln Teilen Ihrer Anwendung: all die Klassen, Funktionen und Module, die Sie geschrieben haben. <br><br>  Die Hauptschwierigkeit beim Integrationstest tritt auf, wenn der Integrationstest nicht das richtige Ergebnis liefert.  Es ist schwierig, das Problem zu bewerten, da der defekte Teil des Systems nicht isoliert werden kann.  Wenn die Scheinwerfer nicht leuchten, sind die Lampen mÃ¶glicherweise defekt.  Oder ist die Batterie schwach?  Oder liegt das Problem vielleicht im Generator?  Oder sogar ein Absturz im Computer der Maschine? <br><br>  Moderne Autos selbst werden Sie Ã¼ber eine kaputte GlÃ¼hbirne informieren.  Dies wird mit einem Unit-Test ermittelt. <br><br>  Der Unit-Test (Unit-Test) ist ein kleiner Test, der den korrekten Betrieb einer einzelnen Komponente Ã¼berprÃ¼ft.  Der Komponententest hilft dabei, die StÃ¶rung zu isolieren und schneller zu beheben. <br><br>  Wir haben Ã¼ber zwei Arten von Tests gesprochen: <br><br><ol><li>  Ein Integrationstest, der die Komponenten des Systems und ihre Interaktion miteinander Ã¼berprÃ¼ft. </li><li>  Ein Komponententest, der eine einzelne Komponente einer Anwendung testet. </li><li>  Sie kÃ¶nnen beide Tests in Python erstellen.  Um einen Test fÃ¼r die integrierte Funktion sum () zu schreiben, mÃ¼ssen Sie die Ausgabe von sum () mit bekannten Werten vergleichen. </li></ol><br>  Auf diese Weise kÃ¶nnen Sie beispielsweise Ã¼berprÃ¼fen, ob die Summe der Zahlen (1, 2, 3) 6 betrÃ¤gt: <br><br><pre><code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> sum([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>]) == <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-string"><span class="hljs-string">"Should be 6"</span></span></code> </pre> <br>  Die Werte sind korrekt, daher wird nichts an REPL ausgegeben.  Wenn das Ergebnis von <code>sum()</code> falsch ist, wird ein <code>AssertionError</code> mit der Meldung "Sollte 6 sein" <code>AssertionError</code> .  ÃœberprÃ¼fen Sie die Anweisungsanweisung erneut, jetzt jedoch mit ungÃ¼ltigen Werten, um einen <code>AssertionError</code> : <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> sum([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>]) == <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-string"><span class="hljs-string">"Should be 6"</span></span> Traceback (most recent call last): File <span class="hljs-string"><span class="hljs-string">"&lt;stdin&gt;"</span></span>, line <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;module&gt; AssertionError: Should be <span class="hljs-number"><span class="hljs-number">6</span></span></code> </pre> <br>  In REPL wird <code>AssertionError</code> angezeigt, da der Wert <code>sum()</code> nicht 6 ist. <br><br>  <code>test_sum.py</code> Sie dies anstelle von REPL in eine neue Python-Datei mit dem Namen <code>test_sum.py</code> und fÃ¼hren Sie es erneut aus: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> sum([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>]) == <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-string"><span class="hljs-string">"Should be 6"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">"__main__"</span></span>: test_sum() print(<span class="hljs-string"><span class="hljs-string">"Everything passed"</span></span>)</code> </pre> <br>  Jetzt haben Sie einen schriftlichen Testfall (Testfall), eine Anweisung und einen Einstiegspunkt (Befehlszeile).  Dies kann nun Ã¼ber die Befehlszeile erfolgen: <br><br><pre> <code class="python hljs">$ python test_sum.py Everything passed</code> </pre> <br>  Sie sehen das erfolgreiche Ergebnis â€Alles bestandenâ€œ. <br><br>  <code>sum()</code> in Python akzeptiert jedes iterable als erstes Argument.  Sie haben die Liste Ã¼berprÃ¼ft.  Versuchen wir, das Tupel zu testen.  Erstellen Sie eine neue Datei mit dem Namen <code>test_sum_2.py</code> mit dem folgenden Code: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> sum([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>]) == <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-string"><span class="hljs-string">"Should be 6"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_sum_tuple</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> sum((<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)) == <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-string"><span class="hljs-string">"Should be 6"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">"__main__"</span></span>: test_sum() test_sum_tuple() print(<span class="hljs-string"><span class="hljs-string">"Everything passed"</span></span>)</code> </pre><br>  <code>test_sum_2.py</code> , gibt das Skript <code>test_sum_2.py</code> Fehler aus, da s <code>um() (1, 2, 2)</code> 5 und nicht 6 sein sollte. Als Ergebnis gibt das Skript eine Fehlermeldung, eine Codezeile und einen Traceback aus: <br><br><pre> <code class="python hljs">$ python test_sum_2.py Traceback (most recent call last): File <span class="hljs-string"><span class="hljs-string">"test_sum_2.py"</span></span>, line <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;module&gt; test_sum_tuple() File <span class="hljs-string"><span class="hljs-string">"test_sum_2.py"</span></span>, line <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> test_sum_tuple <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> sum((<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)) == <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-string"><span class="hljs-string">"Should be 6"</span></span> AssertionError: Should be <span class="hljs-number"><span class="hljs-number">6</span></span></code> </pre> <br>  Sie kÃ¶nnen sehen, wie ein Fehler im Code einen Fehler in der Konsole verursacht, mit Informationen darÃ¼ber, wo er aufgetreten ist und was das erwartete Ergebnis war. <br><br>  Solche Tests eignen sich zur einfachen ÃœberprÃ¼fung, aber was ist, wenn mehr Fehler als in einem vorhanden sind?  TestlÃ¤ufer kommen zur Rettung.  Test Executor ist eine spezielle Anwendung, mit der Tests durchgefÃ¼hrt, Ausgabedaten Ã¼berprÃ¼ft und Tools zum Debuggen und Diagnostizieren von Tests und Anwendungen bereitgestellt werden kÃ¶nnen. <br><br>  <i><b>Auswahl eines Test Executors</b></i> <br><br>  FÃ¼r Python stehen viele TestlÃ¤ufer zur VerfÃ¼gung.  Zum Beispiel ist unittest in die Python-Standardbibliothek integriert.  In diesem Handbuch werden TestfÃ¤lle und unittest Test Executors verwendet.  Unittest-Funktionsprinzipien kÃ¶nnen leicht an andere Frameworks angepasst werden.  Wir listen die beliebtesten TestausfÃ¼hrenden auf: <br><br><ul><li>  unittest; </li><li>  Nase oder Nase2; </li><li>  pytest. </li></ul><br>  Es ist wichtig, einen Testunternehmer zu wÃ¤hlen, der Ihren Anforderungen und Erfahrungen entspricht. <br><br>  <b>unittest</b> <br><br>  unittest ist seit Version 2.1 in die Python-Standardbibliothek integriert.  Sie werden wahrscheinlich in kommerziellen Python-Anwendungen und Open Source-Projekten darauf stoÃŸen. <br>  Unittest hat ein Testframework und einen TestlÃ¤ufer.  Beim Schreiben und AusfÃ¼hren von Tests mÃ¼ssen Sie einige wichtige Anforderungen erfÃ¼llen. <br><br>  unittest erfordert: <br><br><ul><li>  Setzen Sie Tests in Klassen als Methoden ein; </li><li>  Verwenden Sie spezielle Genehmigungsmethoden.  Die TestCase-Klasse anstelle des Ã¼blichen integrierten Assert-Ausdrucks. </li></ul><br><br>  Um ein zuvor geschriebenes Beispiel in einen unittest Testfall zu verwandeln, mÃ¼ssen Sie: <br><br><ol><li>  Unittest aus der Standardbibliothek importieren; </li><li>  Erstellen Sie eine Klasse namens <code>TestSum</code> , die die <code>TestCase</code> Klasse erbt. </li><li>  Konvertieren Sie Testfunktionen in Methoden, indem Sie als erstes Argument <code>self</code> hinzufÃ¼gen. </li><li>  Ã„ndern Sie Anweisungen, indem Sie die Verwendung der <code>self.assertEqual()</code> -Methode in der <code>TestCase</code> Klasse <code>TestCase</code> . </li><li>  Ã„ndern Sie den Einstiegspunkt in der Befehlszeile, um <code>unittest.main()</code> aufzurufen. </li></ol><br>  Erstellen Sie nach diesen Schritten eine neue Datei test_sum_unittest.py mit diesem Code: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> unittest <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestSum</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(unittest.TestCase)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.assertEqual(sum([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>]), <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-string"><span class="hljs-string">"Should be 6"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_sum_tuple</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.assertEqual(sum((<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)), <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-string"><span class="hljs-string">"Should be 6"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">'__main__'</span></span>: unittest.main()</code> </pre> <br>  Wenn Sie dies in der Befehlszeile tun, erhalten Sie einen erfolgreichen Abschluss (angezeigt durch.) Und einen erfolglosen Abschluss (angezeigt durch F): <br><br><pre> <code class="python hljs">$ python test_sum_unittest.py .F ====================================================================== FAIL: test_sum_tuple (__main__.TestSum) ---------------------------------------------------------------------- Traceback (most recent call last): File <span class="hljs-string"><span class="hljs-string">"test_sum_unittest.py"</span></span>, line <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> test_sum_tuple self.assertEqual(sum((<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)), <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-string"><span class="hljs-string">"Should be 6"</span></span>) AssertionError: Should be <span class="hljs-number"><span class="hljs-number">6</span></span> ---------------------------------------------------------------------- Ran <span class="hljs-number"><span class="hljs-number">2</span></span> tests <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0.001</span></span>s FAILED (failures=<span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre><br>  Daher haben Sie zwei Tests mit dem unittest Test Runner durchgefÃ¼hrt. <br><br>  <i>Hinweis: Wenn Sie TestfÃ¤lle fÃ¼r Python 2 und 3 schreiben, seien Sie vorsichtig.</i>  <i>In Versionen von Python 2.7 und niedriger wird unittest als unittest 2 bezeichnet. Wenn Sie aus unittest importieren, erhalten Sie verschiedene Versionen mit unterschiedlichen Funktionen in Python 2 und Python 3.</i> <br><br>  Lesen Sie die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation zu</a> unittest, um mehr Ã¼ber unittest zu erfahren. <br><br>  <b>Nase</b> <br><br>  Mit der Zeit wird es nach dem Schreiben von Hunderten oder sogar Tausenden von Tests fÃ¼r eine Anwendung immer schwieriger, unitteste Ausgabedaten zu verstehen und zu verwenden. <br><br>  Die Nase ist mit allen Tests kompatibel, die mit einem unittest Framework geschrieben wurden, und kann den Test Executor ersetzen.  Die Entwicklung von Nase als Open-Source-Anwendung begann sich zu verlangsamen, und Nase2 wurde erstellt.  Wenn Sie bei Null anfangen, wird empfohlen, Nase2 zu verwenden. <br><br>  Um mit Nase2 zu beginnen, mÃ¼ssen Sie es von PyPl installieren und in der Befehlszeile ausfÃ¼hren.  nas2 versucht, alle Testskripte mit <code>test*.py</code> im Namen und alle von unittest.TestCase geerbten TestfÃ¤lle in Ihrem aktuellen Verzeichnis zu finden: <br><br><pre> <code class="python hljs">$ pip install nose2 $ python -m nose2 .F ====================================================================== FAIL: test_sum_tuple (__main__.TestSum) ---------------------------------------------------------------------- Traceback (most recent call last): File <span class="hljs-string"><span class="hljs-string">"test_sum_unittest.py"</span></span>, line <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> test_sum_tuple self.assertEqual(sum((<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)), <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-string"><span class="hljs-string">"Should be 6"</span></span>) AssertionError: Should be <span class="hljs-number"><span class="hljs-number">6</span></span> ---------------------------------------------------------------------- Ran <span class="hljs-number"><span class="hljs-number">2</span></span> tests <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0.001</span></span>s FAILED (failures=<span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br>  Auf diese Weise wird der in <code>test_sum_unittest.py</code> erstellte Test vom <code>test_sum_unittest.py</code> .  nas2 bietet viele Befehlszeilenflags zum Filtern ausfÃ¼hrbarer Tests.  Weitere Informationen finden Sie in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation zu Nose 2</a> . <br><br>  <b>pytest</b> <br><br>  pytest unterstÃ¼tzt unittest TestfÃ¤lle.  Der eigentliche Vorteil von pytest sind jedoch die TestfÃ¤lle.  Die Pytest-TestfÃ¤lle sind eine Reihe von Funktionen in einer Python-Datei mit test_ am Anfang des Namens. <br><br>  Es gibt noch weitere nÃ¼tzliche Funktionen: <br><br><ul><li>  UnterstÃ¼tzung fÃ¼r integrierte Assert-AusdrÃ¼cke anstelle der Verwendung spezieller self.assert * () -Methoden; </li><li>  UnterstÃ¼tzung fÃ¼r das Filtern von TestfÃ¤llen; </li><li>  Die MÃ¶glichkeit, nach dem letzten fehlgeschlagenen Test neu zu starten. </li><li>  Ein Ã–kosystem aus Hunderten von Plugins, die die FunktionalitÃ¤t erweitern. </li></ul><br>  Ein Beispiel fÃ¼r einen TestSum-Testfall fÃ¼r Pytest sieht folgendermaÃŸen aus: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> sum([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>]) == <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-string"><span class="hljs-string">"Should be 6"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_sum_tuple</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> sum((<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)) == <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-string"><span class="hljs-string">"Should be 6"</span></span></code> </pre> <br>  Sie haben TestCase mithilfe von Klassen und Befehlszeilen-Einstiegspunkten entfernt. <br>  Weitere Informationen finden Sie auf der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pytest-Dokumentationsseite</a> . <br><br>  <b>Den ersten Test schreiben</b> <br><br>  Kombinieren Sie alles, was wir bereits gelernt haben, und testen Sie anstelle der integrierten Funktion <code>sum()</code> eine einfache Implementierung mit denselben Anforderungen. <br><br>  Erstellen Sie einen neuen Ordner fÃ¼r das Projekt, in dem Sie einen neuen Ordner mit dem Namen my_sum erstellen.  Erstellen Sie in my_sum eine leere Datei mit dem Namen <code>_init_.py</code> .  Das Vorhandensein dieser Datei bedeutet, dass der Ordner my_sum als Modul aus dem Ã¼bergeordneten Verzeichnis importiert werden kann. <br><br>  Die Ordnerstruktur sieht folgendermaÃŸen aus: <br><br> <code>project/ <br> â”‚ <br> â””â”€â”€ my_sum/ <br> â””â”€â”€ __init__.py</code> <br> <br>  Ã–ffnen Sie <code>my_sum/__init__.py</code> und erstellen Sie eine neue Funktion namens <code>sum()</code> , die <code>my_sum/__init__.py</code> Eingaben (Liste, Tupel, Menge) Ã¼bernimmt und die Werte hinzufÃ¼gt. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(arg)</span></span></span><span class="hljs-function">:</span></span> total = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> val <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> arg: total += val <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> total</code> </pre> <br>  In diesem Beispiel wird eine Variable namens <code>total</code> , alle Werte in <code>arg</code> und zur <code>total</code> addiert.  Nach Abschluss der Iteration wird das Ergebnis zurÃ¼ckgegeben. <br><br>  <b>Wo schreibe ich einen Test?</b> <br><br>  Sie kÃ¶nnen mit dem Schreiben eines Tests beginnen, indem Sie eine <code>test.py</code> Datei erstellen, die Ihren ersten Testfall enthÃ¤lt.  Zum Testen sollte die Datei in der Lage sein, Ihre Anwendung zu importieren. <code>test.py</code> Sie daher <code>test.py</code> in den Ordner Ã¼ber dem Paket.  Der Verzeichnisbaum sieht folgendermaÃŸen aus: <br><br> <code>project/ <br> â”‚ <br> â”œâ”€â”€ my_sum/ <br> â”‚ â””â”€â”€ __init__.py <br> | <br> â””â”€â”€ test.py</code> <br> <br>  Sie werden feststellen, dass Ihre Datei beim HinzufÃ¼gen neuer Tests umstÃ¤ndlicher und schwieriger zu warten ist. Wir empfehlen daher, den Ordner " <code>tests/</code> erstellen und die Tests in mehrere Dateien aufzuteilen.  <code>test_</code> Sie sicher, dass die Namen aller Dateien mit <code>test_</code> beginnen, damit TestlÃ¤ufer verstehen, dass Python-Dateien Tests enthalten, die ausgefÃ¼hrt werden mÃ¼ssen.  Bei groÃŸen Projekten werden Tests je nach Zweck oder Verwendung in mehrere Verzeichnisse unterteilt. <br><br>  <i>Hinweis: Und was ist Ihre Anwendung ist ein einzelnes Skript?</i> <i><br></i>  <i>Sie kÃ¶nnen beliebige <code>__import__()</code> importieren: Klassen, Funktionen oder Variablen mit der integrierten Funktion <code>__import__()</code> .</i>  <i>Anstelle <code>from my_sum import sum</code> schreiben Sie Folgendes:</i> <br><br><pre> <code class="python hljs">target = __import__(<span class="hljs-string"><span class="hljs-string">"my_sum.py"</span></span>) sum = target.sum</code> </pre> <br>  <i>Wenn Sie <code>__import__()</code> Sie den Projektordner nicht in ein Paket verwandeln, und Sie kÃ¶nnen den Dateinamen angeben.</i>  <i>Dies ist nÃ¼tzlich, wenn der Dateiname mit den Namen der Standardpaketbibliotheken in Konflikt steht.</i>  <i>Zum Beispiel, wenn <code>math.py</code> mit dem Mathematikmodul in Konflikt steht.</i> <br><br>  <b>So strukturieren Sie einen einfachen Test</b> <br><br>  Bevor Sie Tests schreiben, mÃ¼ssen Sie einige Fragen lÃ¶sen: <br><br><ol><li>  Was mÃ¶chten Sie testen? </li><li>  Schreiben Sie einen Unit-Test oder einen Integrationstest? </li></ol><br>  Sie testen derzeit <code>sum()</code> .  Sie kÃ¶nnen verschiedene Verhaltensweisen dafÃ¼r testen, zum Beispiel: <br><br><ul><li>  Ist es mÃ¶glich, eine Liste von ganzen Zahlen zusammenzufassen? </li><li>  Ist es mÃ¶glich, ein Tupel oder eine Menge zusammenzufassen? </li><li>  Kann ich eine Liste von Gleitkommazahlen zusammenfassen? </li><li>  Was passiert, wenn Sie der Eingabe einen schlechten Wert geben: eine einzelne Ganzzahl oder eine Zeichenfolge? </li><li>  Was passiert, wenn einer der Werte negativ ist? </li></ul><br>  Der einfachste Weg zum Testen ist eine Liste von ganzen Zahlen.  Erstellen Sie eine <code>test.py</code> Datei mit dem folgenden Code: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> unittest <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> my_sum <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sum <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestSum</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(unittest.TestCase)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_list_int</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" Test that it can sum a list of integers """</span></span> data = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] result = sum(data) self.assertEqual(result, <span class="hljs-number"><span class="hljs-number">6</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">'__main__'</span></span>: unittest.main()</code> </pre> <br>  Der Code in diesem Beispiel: <br><br><ul><li>  Importiert <code>sum()</code> aus dem von Ihnen erstellten Paket <code>my_sum()</code> . </li><li>  Definiert eine neue Testfallklasse namens TestSum, die unittest.TestCase erbt. </li><li>  Definiert eine Testmethode <code>.test_list_int()</code> zum Testen einer Ganzzahlliste.  Die Methode <code>.test_list_int()</code> fÃ¼hrt die folgenden <code>.test_list_int()</code> </li></ul>  :: <br><ol><li>  Deklariert eine Datenvariable mit einer Liste von Werten <code>(1, 2, 3)</code> ; </li><li>  <code>my_sum.sum(data)</code> Wert <code>my_sum.sum(data)</code> variable <code>result</code> . </li><li>  Bestimmt, dass der Wert des Ergebnisses 6 ist, indem die Methode <code>.assertEqual()</code> fÃ¼r die Klasse <code>.assertEqual()</code> . </li></ol><br><ul><li>  Definiert einen Befehlszeilen-Einstiegspunkt, der den <code>.main()</code> startet. </li></ul><br>  Wenn Sie nicht wissen, was self ist oder wie <code>.assertEqual()</code> definiert ist, kÃ¶nnen Sie Ihr Wissen Ã¼ber objektorientierte Programmierung mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Python 3 Object-Oriented Programming</a> auffrischen. <br><br>  <b>Wie schreibe ich Anweisungen</b> <br><br>  Der letzte Schritt beim Schreiben eines Tests besteht darin, zu Ã¼berprÃ¼fen, ob die Ausgabe mit bekannten Werten Ã¼bereinstimmt.  Dies wird als Behauptung bezeichnet.  Es gibt mehrere allgemeine Richtlinien zum Schreiben von Aussagen: <br><br><ul><li>  Stellen Sie sicher, dass die Tests wiederholbar sind, und fÃ¼hren Sie sie mehrmals aus, um sicherzustellen, dass sie jedes Mal die gleichen Ergebnisse liefern. </li><li>  ÃœberprÃ¼fen und bestÃ¤tigen Sie die Ergebnisse, die fÃ¼r Ihre Eingabe gelten. Stellen Sie sicher, dass das Ergebnis tatsÃ¤chlich die Summe der Werte im Beispiel <code>sum()</code> . </li></ul><br>  Unittest verfÃ¼gt Ã¼ber viele Methoden zum BestÃ¤tigen der Werte, Typen und Existenz von Variablen.  Hier sind einige der am hÃ¤ufigsten verwendeten Methoden: <br><br><table><tbody><tr><th>  Methode </th><th>  Ã„quivalent </th></tr><tr><td>  .assertEqual (a, b) </td><td>  a == b </td></tr><tr><td>  .assertTrue (x) </td><td>  bool (x) ist wahr </td></tr><tr><td>  .assertFalse (x) </td><td>  bool (x) ist falsch </td></tr><tr><td>  .assertIs (a, b) </td><td>  a ist b </td></tr><tr><td>  .assertIsNone (x) </td><td>  x ist Keine </td></tr><tr><td>  .assertIn (a, b) </td><td>  a in b </td></tr><tr><td>  .assertIsInstance (a, b) </td><td>  isinstance (a, b) </td></tr></tbody></table><br><br>  <code>.assertIs()</code> , <code>.assertIsNone()</code> , <code>.assertIn()</code> und <code>.assertIsInstance()</code> haben entgegengesetzte Methoden, die als <code>.assertIsNot()</code> usw. bezeichnet werden. <br><br>  <b>Nebenwirkungen</b> <br><br>  Das Schreiben von Tests ist schwieriger als nur das Betrachten des RÃ¼ckgabewerts einer Funktion.  Durch die CodeausfÃ¼hrung werden hÃ¤ufig andere Teile der Umgebung geÃ¤ndert: Klassenattribute, Dateisystemdateien, Werte in der Datenbank.  Dies ist ein wichtiger Teil des Testens, der als Nebenwirkungen bezeichnet wird.  Entscheiden Sie, ob Sie eine Nebenwirkung testen, bevor Sie sie in Ihre Schadensliste aufnehmen. <br><br>  Wenn Sie feststellen, dass der Codeblock, den Sie testen mÃ¶chten, viele Nebenwirkungen aufweist, verstoÃŸen Sie gegen das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Prinzip</a> der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">alleinigen Verantwortung</a> .  Ein VerstoÃŸ gegen das Prinzip der alleinigen Verantwortung bedeutet, dass ein Code zu viele Dinge tut und ein Refactoring erfordert.  Das Befolgen des Prinzips der alleinigen Verantwortung ist eine hervorragende MÃ¶glichkeit, Code zu entwerfen, fÃ¼r den es nicht schwierig sein wird, einfache, wiederholbare Komponententests zu schreiben und letztendlich zuverlÃ¤ssige Anwendungen zu erstellen. <br><br>  <b>Start des ersten Tests</b> <br><br>  Sie haben den ersten Test erstellt und mÃ¼ssen nun versuchen, ihn auszufÃ¼hren.  Es ist klar, dass es bestanden wird, aber bevor Sie komplexere Tests erstellen, mÃ¼ssen Sie sicherstellen, dass auch solche Tests erfolgreich sind. <br><br>  <b>AusfÃ¼hren von Test Executors</b> <br><br>  Test Executor - Eine Python-Anwendung, die Testcode ausfÃ¼hrt, Zusicherungen Ã¼berprÃ¼ft und Testergebnisse in der Konsole anzeigt.  FÃ¼gen Sie am Ende von test.py diesen kleinen Code hinzu: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">'__main__'</span></span>: unittest.main()</code> </pre> <br>  Dies ist der Einstiegspunkt fÃ¼r die Befehlszeile.  Wenn Sie dieses Skript ausfÃ¼hren, indem Sie python <code>test.py</code> in der Befehlszeile <code>unittest.main()</code> , wird <code>unittest.main()</code> aufgerufen.  Dadurch wird der TestlÃ¤ufer <code>unittest.TestCase</code> alle Klassen in dieser Datei <code>unittest.TestCase</code> werden, die von <code>unittest.TestCase</code> erben. <br><br>  Dies ist eine von vielen MÃ¶glichkeiten, um den unittest Test Runner auszufÃ¼hren.  Wenn Sie eine einzelne Testdatei mit dem Namen <code>test.py</code> , ist der Aufruf von python test.py eine gute MÃ¶glichkeit, um loszulegen. <br><br>  Eine andere MÃ¶glichkeit besteht darin, die unittest-Befehlszeile zu verwenden.  Versuchen wir mal: <br><br><pre> <code class="python hljs">$ python -m unittest test</code> </pre> <br>  Dadurch wird dasselbe Testmodul ( <code>test</code> ) Ã¼ber die Befehlszeile ausgefÃ¼hrt.  Sie kÃ¶nnen zusÃ¤tzliche Parameter hinzufÃ¼gen, um die Ausgabe zu Ã¤ndern.  Einer von ihnen ist -v fÃ¼r ausfÃ¼hrlich.  Versuchen wir Folgendes: <br><br><pre> <code class="bash hljs">$ python -m unittest -v <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> test_list_int (test.TestSum) ... ok ---------------------------------------------------------------------- Ran 1 tests <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> 0.000s</code> </pre><br>  Wir haben einen Test von test.py ausgefÃ¼hrt und die Ergebnisse an die Konsole ausgegeben.  Im ausfÃ¼hrlichen Modus wurden die Namen der durchgefÃ¼hrten Tests und die Ergebnisse der einzelnen Tests aufgelistet. <br><br>  Anstatt den Namen des Moduls anzugeben, das die Tests enthÃ¤lt, kÃ¶nnen Sie die automatische Erkennung wie folgt anfordern: <br><br><pre> <code class="python hljs">$ python -m unittest discover</code> </pre> <br>  Dieser Befehl sucht im aktuellen Verzeichnis nach Dateien mit dem Namen <code>test*.py</code> im Namen, um sie zu testen. <br><br>  Wenn Sie mehrere Testdateien haben und dem <code>test*.py</code> folgen, kÃ¶nnen Sie den Verzeichnisnamen mit dem Flag -s und dem Ordnernamen Ã¼bergeben. <br><br><pre> <code class="python hljs">$ python -m unittest discover -s tests</code> </pre> <br>  unittest fÃ¼hrt alle Tests in einem einzigen Testplan aus und erstellt die Ergebnisse. <br>  Wenn sich Ihr Quellcode nicht im Stammverzeichnis befindet, sondern in einem Unterverzeichnis, z. B. in einem Ordner namens src /, kÃ¶nnen Sie unittest mit dem Flag -t mitteilen, wo die Tests ausgefÃ¼hrt werden sollen, um die Module korrekt zu importieren: <br><br><pre> <code class="python hljs">$ python -m unittest discover -s tests -t src</code> </pre> <br>  unittest findet alle <code>test*.py</code> Dateien im Verzeichnis <code>src/</code> in <code>tests</code> und fÃ¼hrt sie dann aus. <br><br>  <b>Testergebnisse verstehen</b> <b><br></b> <br>  Dies war ein sehr einfaches Beispiel, bei dem alles gut lief. Versuchen wir also, die Ausgabe eines fehlgeschlagenen Tests zu verstehen. <br><br>  <code>sum()</code> muss andere Listen eines numerischen Typs akzeptieren, z. B. BrÃ¼che. <br><br>  <code>test.py</code> am Anfang des Codes in <code>test.py</code> einen Ausdruck hinzu, um den <code>Fraction</code> Typ aus dem <code>fractions</code> Modul der Standardbibliothek zu importieren. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> fractions <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Fraction</code> </pre> <br>  FÃ¼gen Sie nun einen Test mit einer Anweisung hinzu und erwarten Sie einen falschen Wert.  In unserem Fall erwarten wir, dass die Summe von Â¼, Â¼ und â…– gleich 1 ist: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> unittest <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> my_sum <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sum <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestSum</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(unittest.TestCase)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_list_int</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" Test that it can sum a list of integers """</span></span> data = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] result = sum(data) self.assertEqual(result, <span class="hljs-number"><span class="hljs-number">6</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_list_fraction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" Test that it can sum a list of fractions """</span></span> data = [Fraction(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>), Fraction(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>), Fraction(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>)] result = sum(data) self.assertEqual(result, <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">'__main__'</span></span>: unittest.main()</code> </pre><br>  Wenn Sie die Tests erneut mit python -m unittest test ausfÃ¼hren, erhalten Sie Folgendes: <br><br><pre> <code class="python hljs">$ python -m unittest test F. ====================================================================== FAIL: test_list_fraction (test.TestSum) ---------------------------------------------------------------------- Traceback (most recent call last): File <span class="hljs-string"><span class="hljs-string">"test.py"</span></span>, line <span class="hljs-number"><span class="hljs-number">21</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> test_list_fraction self.assertEqual(result, <span class="hljs-number"><span class="hljs-number">1</span></span>) AssertionError: Fraction(<span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>) != <span class="hljs-number"><span class="hljs-number">1</span></span> ---------------------------------------------------------------------- Ran <span class="hljs-number"><span class="hljs-number">2</span></span> tests <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0.001</span></span>s FAILED (failures=<span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br>  In dieser Ausgabe sehen Sie Folgendes: <br><br><ul><li>  Die erste Zeile zeigt die Ergebnisse aller Tests: einer fehlgeschlagen (F), einer bestanden (.); </li><li>  FAIL zeigt einige Details des fehlgeschlagenen Tests: </li></ul><br><ol><li>  Der Name der Testmethode ( <code>test_list_fraction</code> ); </li><li>  <code>test</code> ( <code>test</code> ) und Testfall ( <code>TestSum</code> ); </li><li>  Traceback-Strings mit einem Fehler; </li><li>  Details der Aussage mit dem erwarteten Ergebnis (1) und dem tatsÃ¤chlichen Ergebnis (Bruch (9, 10)) </li></ol><br>  Denken Sie daran, dass Sie der Testausgabe zusÃ¤tzliche Informationen hinzufÃ¼gen kÃ¶nnen, indem Sie dem <code>python -m unittest</code> das Flag -v hinzufÃ¼gen. <br><br>  <b>AusfÃ¼hren von Tests von PyCharm</b> <br><br>  Wenn Sie die PyCharm-IDE verwenden, kÃ¶nnen Sie unittest oder pytest ausfÃ¼hren, indem Sie die folgenden Schritte ausfÃ¼hren: <br><br><ol><li>  WÃ¤hlen Sie im Projekt-Tool-Fenster das Testverzeichnis aus. </li><li>  WÃ¤hlen Sie im KontextmenÃ¼ den Befehl unittest run aus.  Zum Beispiel "Unittests in meinen Tests ...". </li></ol><br>  Dies fÃ¼hrt unittest im Testfenster aus und gibt die Ergebnisse in PyCharm zurÃ¼ck: <br><br><img src="https://habrastorage.org/webt/i0/5e/xv/i05exvqd-ph8-jisw2a1ejgop_c.png"><br><br>  Weitere Informationen finden Sie auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der PyCharm-Website</a> . <br><br>  <b>AusfÃ¼hren von Tests aus Visual Studio-Code</b> <br><br>  Wenn Sie die Microsoft Visual Studio-Code-IDE verwenden, ist die UnterstÃ¼tzung fÃ¼r Unittest, Nose und Pytest bereits im Python-Plugin integriert. <br><br>  Wenn Sie es installiert haben, kÃ¶nnen Sie die Testkonfiguration konfigurieren, indem Sie die Befehlspalette mit Strg + Umschalt + P Ã¶ffnen und "Python-Test" schreiben.  Sie sehen eine Liste mit Optionen: <br><br><img src="https://habrastorage.org/webt/b1/zs/10/b1zs10n-ydybrqz62ywpknjp89q.png"><br><br>  WÃ¤hlen Sie Alle Komponententests debuggen aus. AnschlieÃŸend sendet VSCode eine Anforderung zum Konfigurieren des Testframeworks.  Klicken Sie auf das Zahnrad, um den TestlÃ¤ufer (unittest) und das Ausgangsverzeichnis (.) AuszuwÃ¤hlen. <br><br>  Nach Abschluss des Setups sehen Sie den Status der Tests am unteren Bildschirmrand. Sie kÃ¶nnen schnell auf die Testprotokolle zugreifen und die Tests neu starten, indem Sie auf die folgenden Symbole klicken: <br><br><img src="https://habrastorage.org/webt/rk/k6/cm/rkk6cmqzjwmtc-4upzozzurcjh4.png"><br><br>  Wir sehen, dass die Tests durchgefÃ¼hrt werden, aber einige von ihnen sind fehlgeschlagen. <br><br>  DAS ENDE <br><br>  Im nÃ¤chsten Teil des Artikels werden wir Tests fÃ¼r Frameworks wie Django und Flask untersuchen. <br><br>  Wir warten hier auf Ihre Fragen und Kommentare und wie immer kÃ¶nnen Sie an einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tag der offenen TÃ¼r</a> nach Stanislav <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">fahren</a> . <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zweiter Teil</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de433358/">https://habr.com/ru/post/de433358/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de433348/index.html">Typisiertes DSL in TypeScript von JSX</a></li>
<li><a href="../de433350/index.html">Digitale Veranstaltungen in Moskau vom 17. bis 23. Dezember</a></li>
<li><a href="../de433352/index.html">Die Verdauung von frischen Materialien aus der Welt des Frontends fÃ¼r die letzte Woche Nr. 343 (10. - 16. Dezember 2018)</a></li>
<li><a href="../de433354/index.html">Nachrichten aus der Welt von OpenStreetMap Nr. 438 (12/04/2018 - 12/10/2018)</a></li>
<li><a href="../de433356/index.html">Angreifer haben gelernt, die Zwei-Faktor-Authentifizierung Yahoo Mail und Gmail zu umgehen</a></li>
<li><a href="../de433360/index.html">Wissenschaftler haben versucht vorherzusagen, wann elektrische Flugzeuge RealitÃ¤t werden</a></li>
<li><a href="../de433362/index.html">9 Prinzipien von SchÃ¶nheit, Einfachheit und Pflege in UX</a></li>
<li><a href="../de433364/index.html">LDraw + Unity. Wie ich Lego generiert habe</a></li>
<li><a href="../de433366/index.html">Arbeiten mit externen Ressourcen in Unity3D</a></li>
<li><a href="../de433368/index.html">Wie man das Denken von Lebensmitteln auf die Welt anwendet: ein Beispiel fÃ¼r ein Sweatshirt</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>