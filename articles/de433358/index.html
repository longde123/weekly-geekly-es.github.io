<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧑🏼‍🤝‍🧑🏻 🐊 🧑🏿 Vertrautheit mit dem Testen in Python. Teil 1 🌈 🐈 👩🏾‍⚕️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Guten Tag an alle! 

 Von unserem Tisch zu Ihrem ... Das heißt, aus unserem Kurs "Python Developer" haben wir trotz des sich schnell nähernden neuen J...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Vertrautheit mit dem Testen in Python. Teil 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/433358/"> Guten Tag an alle! <br><br>  <s>Von unserem Tisch zu Ihrem ...</s> Das heißt, aus unserem Kurs "Python Developer" haben wir trotz des sich schnell nähernden neuen Jahres eine interessante Übersetzung für Sie über verschiedene Testmethoden in Python vorbereitet. <br><br>  Dieses Handbuch richtet sich an Benutzer, die bereits eine coole Python-Anwendung geschrieben haben, für die sie jedoch noch nicht geschrieben haben <br>  sie Tests. <br><br>  Das Testen in Python ist ein umfangreiches Thema mit einer Reihe von Feinheiten, aber es ist nicht notwendig, die Dinge zu komplizieren.  In wenigen einfachen Schritten können Sie einfache Tests für die Anwendung erstellen und die Komplexität basierend auf diesen schrittweise erhöhen. <br><br>  In diesem Handbuch erfahren Sie, wie Sie einen Basistest erstellen, ausführen und alle Fehler finden, bevor Benutzer dies tun!  Sie lernen die verfügbaren Tools zum Schreiben und Ausführen von Tests kennen, überprüfen die Anwendungsleistung und sehen sich sogar Sicherheitsprobleme an. <br><br><img src="https://habrastorage.org/webt/kh/va/x5/khvax5ew8tluy6c9muhw-oei7cm.png"><br><a name="habracut"></a><br>  <b>Codetests</b> <br><br>  Sie können den Code auf viele Arten testen.  In diesem Handbuch lernen Sie die Methoden von den einfachsten bis zu den fortgeschrittensten kennen. <br><br>  <i><b>Automatisiert vs.</b></i>  <i><b>Manuelles Testen</b></i> <i><br></i> <br>  Gute Neuigkeiten!  Höchstwahrscheinlich haben Sie den Test bereits durchgeführt, ihn aber noch nicht realisiert.  Erinnern Sie sich, wie Sie die Anwendung zum ersten Mal gestartet und verwendet haben?  Haben Sie die Funktionen getestet und damit experimentiert?  Dieser Prozess wird als Erkundungstest bezeichnet und ist eine Form des manuellen Testens. <br><br>  Forschungstests - Tests, die ohne Plan durchgeführt werden.  Während der Forschungstests recherchieren Sie die Anwendung. <br><br>  Um eine vollständige Liste manueller Tests zu erstellen, reicht es aus, eine Liste aller Funktionen der Anwendung, der verschiedenen Arten von Eingaben, die sie akzeptiert, und der erwarteten Ergebnisse zu erstellen.  Jedes Mal, wenn Sie etwas im Code ändern, müssen Sie jedes der Elemente in dieser Liste erneut überprüfen. <br><br>  Klingt düster, oder? <br><br>  Daher sind automatische Tests erforderlich.  Automatisches Testen - Die Ausführung des Testplans (Teile der Anwendung, die getestet werden müssen, die Reihenfolge der Tests und die erwarteten Ergebnisse) mithilfe eines Skripts und nicht von Menschenhand.  Python verfügt bereits über eine Reihe von Tools und Bibliotheken, mit denen Sie automatisierte Tests für Ihre Anwendung erstellen können.  Schauen wir uns diese Tools und Bibliotheken in unserem Tutorial an. <br><br>  <i><b>Unit Tests VS.</b></i>  <i><b>Integrationstests</b></i> <br><br>  Die Welt des Testens ist voller Begriffe, und jetzt, da wir den Unterschied zwischen manuellen und automatisierten Tests kennen, werden wir eine Ebene tiefer gehen. <br><br>  Überlegen Sie, wie Sie die Scheinwerfer eines Autos testen können?  Sie schalten die Scheinwerfer ein (nennen wir es den Testschritt), steigen selbst aus dem Auto oder bitten einen Freund, zu überprüfen, ob die Scheinwerfer leuchten (und dies ist ein Testvorschlag).  Das Testen mehrerer Komponenten wird als Integrationstest bezeichnet. <br><br>  Denken Sie an alle Dinge, die richtig funktionieren sollten, damit eine einfache Aufgabe das richtige Ergebnis liefert.  Diese Komponenten ähneln Teilen Ihrer Anwendung: all die Klassen, Funktionen und Module, die Sie geschrieben haben. <br><br>  Die Hauptschwierigkeit beim Integrationstest tritt auf, wenn der Integrationstest nicht das richtige Ergebnis liefert.  Es ist schwierig, das Problem zu bewerten, da der defekte Teil des Systems nicht isoliert werden kann.  Wenn die Scheinwerfer nicht leuchten, sind die Lampen möglicherweise defekt.  Oder ist die Batterie schwach?  Oder liegt das Problem vielleicht im Generator?  Oder sogar ein Absturz im Computer der Maschine? <br><br>  Moderne Autos selbst werden Sie über eine kaputte Glühbirne informieren.  Dies wird mit einem Unit-Test ermittelt. <br><br>  Der Unit-Test (Unit-Test) ist ein kleiner Test, der den korrekten Betrieb einer einzelnen Komponente überprüft.  Der Komponententest hilft dabei, die Störung zu isolieren und schneller zu beheben. <br><br>  Wir haben über zwei Arten von Tests gesprochen: <br><br><ol><li>  Ein Integrationstest, der die Komponenten des Systems und ihre Interaktion miteinander überprüft. </li><li>  Ein Komponententest, der eine einzelne Komponente einer Anwendung testet. </li><li>  Sie können beide Tests in Python erstellen.  Um einen Test für die integrierte Funktion sum () zu schreiben, müssen Sie die Ausgabe von sum () mit bekannten Werten vergleichen. </li></ol><br>  Auf diese Weise können Sie beispielsweise überprüfen, ob die Summe der Zahlen (1, 2, 3) 6 beträgt: <br><br><pre><code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> sum([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>]) == <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-string"><span class="hljs-string">"Should be 6"</span></span></code> </pre> <br>  Die Werte sind korrekt, daher wird nichts an REPL ausgegeben.  Wenn das Ergebnis von <code>sum()</code> falsch ist, wird ein <code>AssertionError</code> mit der Meldung "Sollte 6 sein" <code>AssertionError</code> .  Überprüfen Sie die Anweisungsanweisung erneut, jetzt jedoch mit ungültigen Werten, um einen <code>AssertionError</code> : <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> sum([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>]) == <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-string"><span class="hljs-string">"Should be 6"</span></span> Traceback (most recent call last): File <span class="hljs-string"><span class="hljs-string">"&lt;stdin&gt;"</span></span>, line <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;module&gt; AssertionError: Should be <span class="hljs-number"><span class="hljs-number">6</span></span></code> </pre> <br>  In REPL wird <code>AssertionError</code> angezeigt, da der Wert <code>sum()</code> nicht 6 ist. <br><br>  <code>test_sum.py</code> Sie dies anstelle von REPL in eine neue Python-Datei mit dem Namen <code>test_sum.py</code> und führen Sie es erneut aus: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> sum([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>]) == <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-string"><span class="hljs-string">"Should be 6"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">"__main__"</span></span>: test_sum() print(<span class="hljs-string"><span class="hljs-string">"Everything passed"</span></span>)</code> </pre> <br>  Jetzt haben Sie einen schriftlichen Testfall (Testfall), eine Anweisung und einen Einstiegspunkt (Befehlszeile).  Dies kann nun über die Befehlszeile erfolgen: <br><br><pre> <code class="python hljs">$ python test_sum.py Everything passed</code> </pre> <br>  Sie sehen das erfolgreiche Ergebnis „Alles bestanden“. <br><br>  <code>sum()</code> in Python akzeptiert jedes iterable als erstes Argument.  Sie haben die Liste überprüft.  Versuchen wir, das Tupel zu testen.  Erstellen Sie eine neue Datei mit dem Namen <code>test_sum_2.py</code> mit dem folgenden Code: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> sum([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>]) == <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-string"><span class="hljs-string">"Should be 6"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_sum_tuple</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> sum((<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)) == <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-string"><span class="hljs-string">"Should be 6"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">"__main__"</span></span>: test_sum() test_sum_tuple() print(<span class="hljs-string"><span class="hljs-string">"Everything passed"</span></span>)</code> </pre><br>  <code>test_sum_2.py</code> , gibt das Skript <code>test_sum_2.py</code> Fehler aus, da s <code>um() (1, 2, 2)</code> 5 und nicht 6 sein sollte. Als Ergebnis gibt das Skript eine Fehlermeldung, eine Codezeile und einen Traceback aus: <br><br><pre> <code class="python hljs">$ python test_sum_2.py Traceback (most recent call last): File <span class="hljs-string"><span class="hljs-string">"test_sum_2.py"</span></span>, line <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;module&gt; test_sum_tuple() File <span class="hljs-string"><span class="hljs-string">"test_sum_2.py"</span></span>, line <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> test_sum_tuple <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> sum((<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)) == <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-string"><span class="hljs-string">"Should be 6"</span></span> AssertionError: Should be <span class="hljs-number"><span class="hljs-number">6</span></span></code> </pre> <br>  Sie können sehen, wie ein Fehler im Code einen Fehler in der Konsole verursacht, mit Informationen darüber, wo er aufgetreten ist und was das erwartete Ergebnis war. <br><br>  Solche Tests eignen sich zur einfachen Überprüfung, aber was ist, wenn mehr Fehler als in einem vorhanden sind?  Testläufer kommen zur Rettung.  Test Executor ist eine spezielle Anwendung, mit der Tests durchgeführt, Ausgabedaten überprüft und Tools zum Debuggen und Diagnostizieren von Tests und Anwendungen bereitgestellt werden können. <br><br>  <i><b>Auswahl eines Test Executors</b></i> <br><br>  Für Python stehen viele Testläufer zur Verfügung.  Zum Beispiel ist unittest in die Python-Standardbibliothek integriert.  In diesem Handbuch werden Testfälle und unittest Test Executors verwendet.  Unittest-Funktionsprinzipien können leicht an andere Frameworks angepasst werden.  Wir listen die beliebtesten Testausführenden auf: <br><br><ul><li>  unittest; </li><li>  Nase oder Nase2; </li><li>  pytest. </li></ul><br>  Es ist wichtig, einen Testunternehmer zu wählen, der Ihren Anforderungen und Erfahrungen entspricht. <br><br>  <b>unittest</b> <br><br>  unittest ist seit Version 2.1 in die Python-Standardbibliothek integriert.  Sie werden wahrscheinlich in kommerziellen Python-Anwendungen und Open Source-Projekten darauf stoßen. <br>  Unittest hat ein Testframework und einen Testläufer.  Beim Schreiben und Ausführen von Tests müssen Sie einige wichtige Anforderungen erfüllen. <br><br>  unittest erfordert: <br><br><ul><li>  Setzen Sie Tests in Klassen als Methoden ein; </li><li>  Verwenden Sie spezielle Genehmigungsmethoden.  Die TestCase-Klasse anstelle des üblichen integrierten Assert-Ausdrucks. </li></ul><br><br>  Um ein zuvor geschriebenes Beispiel in einen unittest Testfall zu verwandeln, müssen Sie: <br><br><ol><li>  Unittest aus der Standardbibliothek importieren; </li><li>  Erstellen Sie eine Klasse namens <code>TestSum</code> , die die <code>TestCase</code> Klasse erbt. </li><li>  Konvertieren Sie Testfunktionen in Methoden, indem Sie als erstes Argument <code>self</code> hinzufügen. </li><li>  Ändern Sie Anweisungen, indem Sie die Verwendung der <code>self.assertEqual()</code> -Methode in der <code>TestCase</code> Klasse <code>TestCase</code> . </li><li>  Ändern Sie den Einstiegspunkt in der Befehlszeile, um <code>unittest.main()</code> aufzurufen. </li></ol><br>  Erstellen Sie nach diesen Schritten eine neue Datei test_sum_unittest.py mit diesem Code: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> unittest <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestSum</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(unittest.TestCase)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.assertEqual(sum([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>]), <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-string"><span class="hljs-string">"Should be 6"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_sum_tuple</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.assertEqual(sum((<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)), <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-string"><span class="hljs-string">"Should be 6"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">'__main__'</span></span>: unittest.main()</code> </pre> <br>  Wenn Sie dies in der Befehlszeile tun, erhalten Sie einen erfolgreichen Abschluss (angezeigt durch.) Und einen erfolglosen Abschluss (angezeigt durch F): <br><br><pre> <code class="python hljs">$ python test_sum_unittest.py .F ====================================================================== FAIL: test_sum_tuple (__main__.TestSum) ---------------------------------------------------------------------- Traceback (most recent call last): File <span class="hljs-string"><span class="hljs-string">"test_sum_unittest.py"</span></span>, line <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> test_sum_tuple self.assertEqual(sum((<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)), <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-string"><span class="hljs-string">"Should be 6"</span></span>) AssertionError: Should be <span class="hljs-number"><span class="hljs-number">6</span></span> ---------------------------------------------------------------------- Ran <span class="hljs-number"><span class="hljs-number">2</span></span> tests <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0.001</span></span>s FAILED (failures=<span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre><br>  Daher haben Sie zwei Tests mit dem unittest Test Runner durchgeführt. <br><br>  <i>Hinweis: Wenn Sie Testfälle für Python 2 und 3 schreiben, seien Sie vorsichtig.</i>  <i>In Versionen von Python 2.7 und niedriger wird unittest als unittest 2 bezeichnet. Wenn Sie aus unittest importieren, erhalten Sie verschiedene Versionen mit unterschiedlichen Funktionen in Python 2 und Python 3.</i> <br><br>  Lesen Sie die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation zu</a> unittest, um mehr über unittest zu erfahren. <br><br>  <b>Nase</b> <br><br>  Mit der Zeit wird es nach dem Schreiben von Hunderten oder sogar Tausenden von Tests für eine Anwendung immer schwieriger, unitteste Ausgabedaten zu verstehen und zu verwenden. <br><br>  Die Nase ist mit allen Tests kompatibel, die mit einem unittest Framework geschrieben wurden, und kann den Test Executor ersetzen.  Die Entwicklung von Nase als Open-Source-Anwendung begann sich zu verlangsamen, und Nase2 wurde erstellt.  Wenn Sie bei Null anfangen, wird empfohlen, Nase2 zu verwenden. <br><br>  Um mit Nase2 zu beginnen, müssen Sie es von PyPl installieren und in der Befehlszeile ausführen.  nas2 versucht, alle Testskripte mit <code>test*.py</code> im Namen und alle von unittest.TestCase geerbten Testfälle in Ihrem aktuellen Verzeichnis zu finden: <br><br><pre> <code class="python hljs">$ pip install nose2 $ python -m nose2 .F ====================================================================== FAIL: test_sum_tuple (__main__.TestSum) ---------------------------------------------------------------------- Traceback (most recent call last): File <span class="hljs-string"><span class="hljs-string">"test_sum_unittest.py"</span></span>, line <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> test_sum_tuple self.assertEqual(sum((<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)), <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-string"><span class="hljs-string">"Should be 6"</span></span>) AssertionError: Should be <span class="hljs-number"><span class="hljs-number">6</span></span> ---------------------------------------------------------------------- Ran <span class="hljs-number"><span class="hljs-number">2</span></span> tests <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0.001</span></span>s FAILED (failures=<span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br>  Auf diese Weise wird der in <code>test_sum_unittest.py</code> erstellte Test vom <code>test_sum_unittest.py</code> .  nas2 bietet viele Befehlszeilenflags zum Filtern ausführbarer Tests.  Weitere Informationen finden Sie in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation zu Nose 2</a> . <br><br>  <b>pytest</b> <br><br>  pytest unterstützt unittest Testfälle.  Der eigentliche Vorteil von pytest sind jedoch die Testfälle.  Die Pytest-Testfälle sind eine Reihe von Funktionen in einer Python-Datei mit test_ am Anfang des Namens. <br><br>  Es gibt noch weitere nützliche Funktionen: <br><br><ul><li>  Unterstützung für integrierte Assert-Ausdrücke anstelle der Verwendung spezieller self.assert * () -Methoden; </li><li>  Unterstützung für das Filtern von Testfällen; </li><li>  Die Möglichkeit, nach dem letzten fehlgeschlagenen Test neu zu starten. </li><li>  Ein Ökosystem aus Hunderten von Plugins, die die Funktionalität erweitern. </li></ul><br>  Ein Beispiel für einen TestSum-Testfall für Pytest sieht folgendermaßen aus: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> sum([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>]) == <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-string"><span class="hljs-string">"Should be 6"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_sum_tuple</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> sum((<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)) == <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-string"><span class="hljs-string">"Should be 6"</span></span></code> </pre> <br>  Sie haben TestCase mithilfe von Klassen und Befehlszeilen-Einstiegspunkten entfernt. <br>  Weitere Informationen finden Sie auf der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pytest-Dokumentationsseite</a> . <br><br>  <b>Den ersten Test schreiben</b> <br><br>  Kombinieren Sie alles, was wir bereits gelernt haben, und testen Sie anstelle der integrierten Funktion <code>sum()</code> eine einfache Implementierung mit denselben Anforderungen. <br><br>  Erstellen Sie einen neuen Ordner für das Projekt, in dem Sie einen neuen Ordner mit dem Namen my_sum erstellen.  Erstellen Sie in my_sum eine leere Datei mit dem Namen <code>_init_.py</code> .  Das Vorhandensein dieser Datei bedeutet, dass der Ordner my_sum als Modul aus dem übergeordneten Verzeichnis importiert werden kann. <br><br>  Die Ordnerstruktur sieht folgendermaßen aus: <br><br> <code>project/ <br> │ <br> └── my_sum/ <br> └── __init__.py</code> <br> <br>  Öffnen Sie <code>my_sum/__init__.py</code> und erstellen Sie eine neue Funktion namens <code>sum()</code> , die <code>my_sum/__init__.py</code> Eingaben (Liste, Tupel, Menge) übernimmt und die Werte hinzufügt. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(arg)</span></span></span><span class="hljs-function">:</span></span> total = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> val <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> arg: total += val <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> total</code> </pre> <br>  In diesem Beispiel wird eine Variable namens <code>total</code> , alle Werte in <code>arg</code> und zur <code>total</code> addiert.  Nach Abschluss der Iteration wird das Ergebnis zurückgegeben. <br><br>  <b>Wo schreibe ich einen Test?</b> <br><br>  Sie können mit dem Schreiben eines Tests beginnen, indem Sie eine <code>test.py</code> Datei erstellen, die Ihren ersten Testfall enthält.  Zum Testen sollte die Datei in der Lage sein, Ihre Anwendung zu importieren. <code>test.py</code> Sie daher <code>test.py</code> in den Ordner über dem Paket.  Der Verzeichnisbaum sieht folgendermaßen aus: <br><br> <code>project/ <br> │ <br> ├── my_sum/ <br> │ └── __init__.py <br> | <br> └── test.py</code> <br> <br>  Sie werden feststellen, dass Ihre Datei beim Hinzufügen neuer Tests umständlicher und schwieriger zu warten ist. Wir empfehlen daher, den Ordner " <code>tests/</code> erstellen und die Tests in mehrere Dateien aufzuteilen.  <code>test_</code> Sie sicher, dass die Namen aller Dateien mit <code>test_</code> beginnen, damit Testläufer verstehen, dass Python-Dateien Tests enthalten, die ausgeführt werden müssen.  Bei großen Projekten werden Tests je nach Zweck oder Verwendung in mehrere Verzeichnisse unterteilt. <br><br>  <i>Hinweis: Und was ist Ihre Anwendung ist ein einzelnes Skript?</i> <i><br></i>  <i>Sie können beliebige <code>__import__()</code> importieren: Klassen, Funktionen oder Variablen mit der integrierten Funktion <code>__import__()</code> .</i>  <i>Anstelle <code>from my_sum import sum</code> schreiben Sie Folgendes:</i> <br><br><pre> <code class="python hljs">target = __import__(<span class="hljs-string"><span class="hljs-string">"my_sum.py"</span></span>) sum = target.sum</code> </pre> <br>  <i>Wenn Sie <code>__import__()</code> Sie den Projektordner nicht in ein Paket verwandeln, und Sie können den Dateinamen angeben.</i>  <i>Dies ist nützlich, wenn der Dateiname mit den Namen der Standardpaketbibliotheken in Konflikt steht.</i>  <i>Zum Beispiel, wenn <code>math.py</code> mit dem Mathematikmodul in Konflikt steht.</i> <br><br>  <b>So strukturieren Sie einen einfachen Test</b> <br><br>  Bevor Sie Tests schreiben, müssen Sie einige Fragen lösen: <br><br><ol><li>  Was möchten Sie testen? </li><li>  Schreiben Sie einen Unit-Test oder einen Integrationstest? </li></ol><br>  Sie testen derzeit <code>sum()</code> .  Sie können verschiedene Verhaltensweisen dafür testen, zum Beispiel: <br><br><ul><li>  Ist es möglich, eine Liste von ganzen Zahlen zusammenzufassen? </li><li>  Ist es möglich, ein Tupel oder eine Menge zusammenzufassen? </li><li>  Kann ich eine Liste von Gleitkommazahlen zusammenfassen? </li><li>  Was passiert, wenn Sie der Eingabe einen schlechten Wert geben: eine einzelne Ganzzahl oder eine Zeichenfolge? </li><li>  Was passiert, wenn einer der Werte negativ ist? </li></ul><br>  Der einfachste Weg zum Testen ist eine Liste von ganzen Zahlen.  Erstellen Sie eine <code>test.py</code> Datei mit dem folgenden Code: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> unittest <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> my_sum <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sum <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestSum</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(unittest.TestCase)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_list_int</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" Test that it can sum a list of integers """</span></span> data = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] result = sum(data) self.assertEqual(result, <span class="hljs-number"><span class="hljs-number">6</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">'__main__'</span></span>: unittest.main()</code> </pre> <br>  Der Code in diesem Beispiel: <br><br><ul><li>  Importiert <code>sum()</code> aus dem von Ihnen erstellten Paket <code>my_sum()</code> . </li><li>  Definiert eine neue Testfallklasse namens TestSum, die unittest.TestCase erbt. </li><li>  Definiert eine Testmethode <code>.test_list_int()</code> zum Testen einer Ganzzahlliste.  Die Methode <code>.test_list_int()</code> führt die folgenden <code>.test_list_int()</code> </li></ul>  :: <br><ol><li>  Deklariert eine Datenvariable mit einer Liste von Werten <code>(1, 2, 3)</code> ; </li><li>  <code>my_sum.sum(data)</code> Wert <code>my_sum.sum(data)</code> variable <code>result</code> . </li><li>  Bestimmt, dass der Wert des Ergebnisses 6 ist, indem die Methode <code>.assertEqual()</code> für die Klasse <code>.assertEqual()</code> . </li></ol><br><ul><li>  Definiert einen Befehlszeilen-Einstiegspunkt, der den <code>.main()</code> startet. </li></ul><br>  Wenn Sie nicht wissen, was self ist oder wie <code>.assertEqual()</code> definiert ist, können Sie Ihr Wissen über objektorientierte Programmierung mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Python 3 Object-Oriented Programming</a> auffrischen. <br><br>  <b>Wie schreibe ich Anweisungen</b> <br><br>  Der letzte Schritt beim Schreiben eines Tests besteht darin, zu überprüfen, ob die Ausgabe mit bekannten Werten übereinstimmt.  Dies wird als Behauptung bezeichnet.  Es gibt mehrere allgemeine Richtlinien zum Schreiben von Aussagen: <br><br><ul><li>  Stellen Sie sicher, dass die Tests wiederholbar sind, und führen Sie sie mehrmals aus, um sicherzustellen, dass sie jedes Mal die gleichen Ergebnisse liefern. </li><li>  Überprüfen und bestätigen Sie die Ergebnisse, die für Ihre Eingabe gelten. Stellen Sie sicher, dass das Ergebnis tatsächlich die Summe der Werte im Beispiel <code>sum()</code> . </li></ul><br>  Unittest verfügt über viele Methoden zum Bestätigen der Werte, Typen und Existenz von Variablen.  Hier sind einige der am häufigsten verwendeten Methoden: <br><br><table><tbody><tr><th>  Methode </th><th>  Äquivalent </th></tr><tr><td>  .assertEqual (a, b) </td><td>  a == b </td></tr><tr><td>  .assertTrue (x) </td><td>  bool (x) ist wahr </td></tr><tr><td>  .assertFalse (x) </td><td>  bool (x) ist falsch </td></tr><tr><td>  .assertIs (a, b) </td><td>  a ist b </td></tr><tr><td>  .assertIsNone (x) </td><td>  x ist Keine </td></tr><tr><td>  .assertIn (a, b) </td><td>  a in b </td></tr><tr><td>  .assertIsInstance (a, b) </td><td>  isinstance (a, b) </td></tr></tbody></table><br><br>  <code>.assertIs()</code> , <code>.assertIsNone()</code> , <code>.assertIn()</code> und <code>.assertIsInstance()</code> haben entgegengesetzte Methoden, die als <code>.assertIsNot()</code> usw. bezeichnet werden. <br><br>  <b>Nebenwirkungen</b> <br><br>  Das Schreiben von Tests ist schwieriger als nur das Betrachten des Rückgabewerts einer Funktion.  Durch die Codeausführung werden häufig andere Teile der Umgebung geändert: Klassenattribute, Dateisystemdateien, Werte in der Datenbank.  Dies ist ein wichtiger Teil des Testens, der als Nebenwirkungen bezeichnet wird.  Entscheiden Sie, ob Sie eine Nebenwirkung testen, bevor Sie sie in Ihre Schadensliste aufnehmen. <br><br>  Wenn Sie feststellen, dass der Codeblock, den Sie testen möchten, viele Nebenwirkungen aufweist, verstoßen Sie gegen das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Prinzip</a> der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">alleinigen Verantwortung</a> .  Ein Verstoß gegen das Prinzip der alleinigen Verantwortung bedeutet, dass ein Code zu viele Dinge tut und ein Refactoring erfordert.  Das Befolgen des Prinzips der alleinigen Verantwortung ist eine hervorragende Möglichkeit, Code zu entwerfen, für den es nicht schwierig sein wird, einfache, wiederholbare Komponententests zu schreiben und letztendlich zuverlässige Anwendungen zu erstellen. <br><br>  <b>Start des ersten Tests</b> <br><br>  Sie haben den ersten Test erstellt und müssen nun versuchen, ihn auszuführen.  Es ist klar, dass es bestanden wird, aber bevor Sie komplexere Tests erstellen, müssen Sie sicherstellen, dass auch solche Tests erfolgreich sind. <br><br>  <b>Ausführen von Test Executors</b> <br><br>  Test Executor - Eine Python-Anwendung, die Testcode ausführt, Zusicherungen überprüft und Testergebnisse in der Konsole anzeigt.  Fügen Sie am Ende von test.py diesen kleinen Code hinzu: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">'__main__'</span></span>: unittest.main()</code> </pre> <br>  Dies ist der Einstiegspunkt für die Befehlszeile.  Wenn Sie dieses Skript ausführen, indem Sie python <code>test.py</code> in der Befehlszeile <code>unittest.main()</code> , wird <code>unittest.main()</code> aufgerufen.  Dadurch wird der Testläufer <code>unittest.TestCase</code> alle Klassen in dieser Datei <code>unittest.TestCase</code> werden, die von <code>unittest.TestCase</code> erben. <br><br>  Dies ist eine von vielen Möglichkeiten, um den unittest Test Runner auszuführen.  Wenn Sie eine einzelne Testdatei mit dem Namen <code>test.py</code> , ist der Aufruf von python test.py eine gute Möglichkeit, um loszulegen. <br><br>  Eine andere Möglichkeit besteht darin, die unittest-Befehlszeile zu verwenden.  Versuchen wir mal: <br><br><pre> <code class="python hljs">$ python -m unittest test</code> </pre> <br>  Dadurch wird dasselbe Testmodul ( <code>test</code> ) über die Befehlszeile ausgeführt.  Sie können zusätzliche Parameter hinzufügen, um die Ausgabe zu ändern.  Einer von ihnen ist -v für ausführlich.  Versuchen wir Folgendes: <br><br><pre> <code class="bash hljs">$ python -m unittest -v <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> test_list_int (test.TestSum) ... ok ---------------------------------------------------------------------- Ran 1 tests <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> 0.000s</code> </pre><br>  Wir haben einen Test von test.py ausgeführt und die Ergebnisse an die Konsole ausgegeben.  Im ausführlichen Modus wurden die Namen der durchgeführten Tests und die Ergebnisse der einzelnen Tests aufgelistet. <br><br>  Anstatt den Namen des Moduls anzugeben, das die Tests enthält, können Sie die automatische Erkennung wie folgt anfordern: <br><br><pre> <code class="python hljs">$ python -m unittest discover</code> </pre> <br>  Dieser Befehl sucht im aktuellen Verzeichnis nach Dateien mit dem Namen <code>test*.py</code> im Namen, um sie zu testen. <br><br>  Wenn Sie mehrere Testdateien haben und dem <code>test*.py</code> folgen, können Sie den Verzeichnisnamen mit dem Flag -s und dem Ordnernamen übergeben. <br><br><pre> <code class="python hljs">$ python -m unittest discover -s tests</code> </pre> <br>  unittest führt alle Tests in einem einzigen Testplan aus und erstellt die Ergebnisse. <br>  Wenn sich Ihr Quellcode nicht im Stammverzeichnis befindet, sondern in einem Unterverzeichnis, z. B. in einem Ordner namens src /, können Sie unittest mit dem Flag -t mitteilen, wo die Tests ausgeführt werden sollen, um die Module korrekt zu importieren: <br><br><pre> <code class="python hljs">$ python -m unittest discover -s tests -t src</code> </pre> <br>  unittest findet alle <code>test*.py</code> Dateien im Verzeichnis <code>src/</code> in <code>tests</code> und führt sie dann aus. <br><br>  <b>Testergebnisse verstehen</b> <b><br></b> <br>  Dies war ein sehr einfaches Beispiel, bei dem alles gut lief. Versuchen wir also, die Ausgabe eines fehlgeschlagenen Tests zu verstehen. <br><br>  <code>sum()</code> muss andere Listen eines numerischen Typs akzeptieren, z. B. Brüche. <br><br>  <code>test.py</code> am Anfang des Codes in <code>test.py</code> einen Ausdruck hinzu, um den <code>Fraction</code> Typ aus dem <code>fractions</code> Modul der Standardbibliothek zu importieren. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> fractions <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Fraction</code> </pre> <br>  Fügen Sie nun einen Test mit einer Anweisung hinzu und erwarten Sie einen falschen Wert.  In unserem Fall erwarten wir, dass die Summe von ¼, ¼ und ⅖ gleich 1 ist: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> unittest <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> my_sum <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sum <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestSum</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(unittest.TestCase)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_list_int</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" Test that it can sum a list of integers """</span></span> data = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] result = sum(data) self.assertEqual(result, <span class="hljs-number"><span class="hljs-number">6</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_list_fraction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" Test that it can sum a list of fractions """</span></span> data = [Fraction(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>), Fraction(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>), Fraction(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>)] result = sum(data) self.assertEqual(result, <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">'__main__'</span></span>: unittest.main()</code> </pre><br>  Wenn Sie die Tests erneut mit python -m unittest test ausführen, erhalten Sie Folgendes: <br><br><pre> <code class="python hljs">$ python -m unittest test F. ====================================================================== FAIL: test_list_fraction (test.TestSum) ---------------------------------------------------------------------- Traceback (most recent call last): File <span class="hljs-string"><span class="hljs-string">"test.py"</span></span>, line <span class="hljs-number"><span class="hljs-number">21</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> test_list_fraction self.assertEqual(result, <span class="hljs-number"><span class="hljs-number">1</span></span>) AssertionError: Fraction(<span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>) != <span class="hljs-number"><span class="hljs-number">1</span></span> ---------------------------------------------------------------------- Ran <span class="hljs-number"><span class="hljs-number">2</span></span> tests <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0.001</span></span>s FAILED (failures=<span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br>  In dieser Ausgabe sehen Sie Folgendes: <br><br><ul><li>  Die erste Zeile zeigt die Ergebnisse aller Tests: einer fehlgeschlagen (F), einer bestanden (.); </li><li>  FAIL zeigt einige Details des fehlgeschlagenen Tests: </li></ul><br><ol><li>  Der Name der Testmethode ( <code>test_list_fraction</code> ); </li><li>  <code>test</code> ( <code>test</code> ) und Testfall ( <code>TestSum</code> ); </li><li>  Traceback-Strings mit einem Fehler; </li><li>  Details der Aussage mit dem erwarteten Ergebnis (1) und dem tatsächlichen Ergebnis (Bruch (9, 10)) </li></ol><br>  Denken Sie daran, dass Sie der Testausgabe zusätzliche Informationen hinzufügen können, indem Sie dem <code>python -m unittest</code> das Flag -v hinzufügen. <br><br>  <b>Ausführen von Tests von PyCharm</b> <br><br>  Wenn Sie die PyCharm-IDE verwenden, können Sie unittest oder pytest ausführen, indem Sie die folgenden Schritte ausführen: <br><br><ol><li>  Wählen Sie im Projekt-Tool-Fenster das Testverzeichnis aus. </li><li>  Wählen Sie im Kontextmenü den Befehl unittest run aus.  Zum Beispiel "Unittests in meinen Tests ...". </li></ol><br>  Dies führt unittest im Testfenster aus und gibt die Ergebnisse in PyCharm zurück: <br><br><img src="https://habrastorage.org/webt/i0/5e/xv/i05exvqd-ph8-jisw2a1ejgop_c.png"><br><br>  Weitere Informationen finden Sie auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der PyCharm-Website</a> . <br><br>  <b>Ausführen von Tests aus Visual Studio-Code</b> <br><br>  Wenn Sie die Microsoft Visual Studio-Code-IDE verwenden, ist die Unterstützung für Unittest, Nose und Pytest bereits im Python-Plugin integriert. <br><br>  Wenn Sie es installiert haben, können Sie die Testkonfiguration konfigurieren, indem Sie die Befehlspalette mit Strg + Umschalt + P öffnen und "Python-Test" schreiben.  Sie sehen eine Liste mit Optionen: <br><br><img src="https://habrastorage.org/webt/b1/zs/10/b1zs10n-ydybrqz62ywpknjp89q.png"><br><br>  Wählen Sie Alle Komponententests debuggen aus. Anschließend sendet VSCode eine Anforderung zum Konfigurieren des Testframeworks.  Klicken Sie auf das Zahnrad, um den Testläufer (unittest) und das Ausgangsverzeichnis (.) Auszuwählen. <br><br>  Nach Abschluss des Setups sehen Sie den Status der Tests am unteren Bildschirmrand. Sie können schnell auf die Testprotokolle zugreifen und die Tests neu starten, indem Sie auf die folgenden Symbole klicken: <br><br><img src="https://habrastorage.org/webt/rk/k6/cm/rkk6cmqzjwmtc-4upzozzurcjh4.png"><br><br>  Wir sehen, dass die Tests durchgeführt werden, aber einige von ihnen sind fehlgeschlagen. <br><br>  DAS ENDE <br><br>  Im nächsten Teil des Artikels werden wir Tests für Frameworks wie Django und Flask untersuchen. <br><br>  Wir warten hier auf Ihre Fragen und Kommentare und wie immer können Sie an einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tag der offenen Tür</a> nach Stanislav <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">fahren</a> . <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zweiter Teil</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de433358/">https://habr.com/ru/post/de433358/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de433348/index.html">Typisiertes DSL in TypeScript von JSX</a></li>
<li><a href="../de433350/index.html">Digitale Veranstaltungen in Moskau vom 17. bis 23. Dezember</a></li>
<li><a href="../de433352/index.html">Die Verdauung von frischen Materialien aus der Welt des Frontends für die letzte Woche Nr. 343 (10. - 16. Dezember 2018)</a></li>
<li><a href="../de433354/index.html">Nachrichten aus der Welt von OpenStreetMap Nr. 438 (12/04/2018 - 12/10/2018)</a></li>
<li><a href="../de433356/index.html">Angreifer haben gelernt, die Zwei-Faktor-Authentifizierung Yahoo Mail und Gmail zu umgehen</a></li>
<li><a href="../de433360/index.html">Wissenschaftler haben versucht vorherzusagen, wann elektrische Flugzeuge Realität werden</a></li>
<li><a href="../de433362/index.html">9 Prinzipien von Schönheit, Einfachheit und Pflege in UX</a></li>
<li><a href="../de433364/index.html">LDraw + Unity. Wie ich Lego generiert habe</a></li>
<li><a href="../de433366/index.html">Arbeiten mit externen Ressourcen in Unity3D</a></li>
<li><a href="../de433368/index.html">Wie man das Denken von Lebensmitteln auf die Welt anwendet: ein Beispiel für ein Sweatshirt</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>