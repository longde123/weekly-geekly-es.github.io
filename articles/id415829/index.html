<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>♒️ 😇 Ⓜ️ Pengantar kelas data 🤜🏼 😺 🧑🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Salah satu fitur baru yang diperkenalkan di Python 3.7 adalah kelas Data. Mereka dirancang untuk mengotomatisasi pembuatan kode untuk kelas yang digun...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pengantar kelas data</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/415829/"><p>  Salah satu fitur baru yang diperkenalkan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Python 3.7</a> adalah kelas Data.  Mereka dirancang untuk mengotomatisasi pembuatan kode untuk kelas yang digunakan untuk menyimpan data.  Terlepas dari kenyataan bahwa mereka menggunakan mekanisme kerja lain, mereka dapat dibandingkan dengan "tuple bernama yang bisa berubah dengan nilai default." </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PEP 557 - Kelas data</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dokumentasi resmi</a> </li></ul><br><h2 id="vvedenie">  Pendahuluan </h2><br><blockquote>  Semua contoh di atas memerlukan Python 3.7 atau lebih tinggi untuk operasi mereka. </blockquote><p>  Sebagian besar pengembang python harus menulis kelas-kelas ini secara teratur: </p><br><pre><code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RegularBook</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, title, author)</span></span></span><span class="hljs-function">:</span></span> self.title = title self.author = author</code> </pre> <br><p>  Sudah dalam contoh ini, redundansi terlihat.  Judul dan pengidentifikasi penulis digunakan beberapa kali.  Kelas nyata juga akan berisi metode yang ditimpa <code>__eq__</code> dan <code>__repr__</code> . </p><br><p>  Modul <code>dataclasses</code> berisi dekorator <code>@dataclass</code> .  Dengan menggunakannya, kode yang mirip akan terlihat seperti ini: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> dataclasses <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> dataclass @dataclass <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Book</span></span></span><span class="hljs-class">:</span></span> title: str author: str</code> </pre> <a name="habracut"></a><br><p>  Penting untuk dicatat bahwa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">anotasi jenis</a> <strong>diperlukan</strong> .  Semua bidang yang tidak memiliki tanda jenis akan diabaikan.  Tentu saja, jika Anda tidak ingin menggunakan jenis tertentu, Anda dapat menentukan <code>Any</code> dari modul <code>typing</code> . </p><br><p>  Apa yang Anda dapatkan sebagai hasilnya?  Anda secara otomatis mendapatkan kelas, dengan metode yang diterapkan <code>__init__</code> , <code>__repr__</code> , <code>__eq__</code> dan <code>__eq__</code> .  Selain itu, ini akan menjadi kelas reguler dan Anda dapat mewarisi darinya atau menambahkan metode sewenang-wenang. </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>book = Book(title=<span class="hljs-string"><span class="hljs-string">"Fahrenheit 451"</span></span>, author=<span class="hljs-string"><span class="hljs-string">"Bradbury"</span></span>) &gt;&gt;&gt; book Book(title=<span class="hljs-string"><span class="hljs-string">'Fahrenheit 451'</span></span>, author=<span class="hljs-string"><span class="hljs-string">'Bradbury'</span></span>) &gt;&gt;&gt; book.author <span class="hljs-string"><span class="hljs-string">'Bradbury'</span></span> &gt;&gt;&gt; other = Book(<span class="hljs-string"><span class="hljs-string">"Fahrenheit 451"</span></span>, <span class="hljs-string"><span class="hljs-string">"Bradbury"</span></span>) &gt;&gt;&gt; book == other <span class="hljs-keyword"><span class="hljs-keyword">True</span></span></code> </pre> <br><h2 id="alternativy">  Alternatif </h2><br><h3 id="kortezh-ili-slovar">  Tuple atau kamus </h3><br><p>  Tentu saja, jika strukturnya cukup sederhana, Anda dapat menyimpan data dalam kamus atau tuple: </p><br><pre> <code class="python hljs">book = (<span class="hljs-string"><span class="hljs-string">"Fahrenheit 451"</span></span>, <span class="hljs-string"><span class="hljs-string">"Bradbury"</span></span>) other = {<span class="hljs-string"><span class="hljs-string">'title'</span></span>: <span class="hljs-string"><span class="hljs-string">'Fahrenheit 451'</span></span>, <span class="hljs-string"><span class="hljs-string">'author'</span></span>: <span class="hljs-string"><span class="hljs-string">'Bradbury'</span></span>}</code> </pre> <br><p>  Namun, pendekatan ini memiliki kelemahan: </p><br><ul><li>  Harus diingat bahwa variabel berisi data yang terkait dengan struktur ini. </li><li>  Dalam hal kamus, Anda harus melacak nama-nama tombol.  Inisialisasi kamus <code>{'name': 'Fahrenheit 451', 'author': 'Bradbury'}</code> juga akan benar secara formal. </li><li>  Dalam kasus tuple, Anda harus melacak urutan nilai, karena mereka tidak memiliki nama. </li></ul><br><p>  Ada opsi yang lebih baik: </p><br><h3 id="namedtuple">  Namedtuple </h3><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> collections <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> namedtuple NamedTupleBook = namedtuple(<span class="hljs-string"><span class="hljs-string">"NamedTupleBook"</span></span>, [<span class="hljs-string"><span class="hljs-string">"title"</span></span>, <span class="hljs-string"><span class="hljs-string">"author"</span></span>])</code> </pre> <br><p>  Jika kita menggunakan kelas yang dibuat dengan cara ini, kita mendapatkan hal yang sama seperti menggunakan kelas data. </p><br><pre> <code class="plaintext hljs">&gt;&gt;&gt; book = NamedTupleBook("Fahrenheit 451", "Bradbury") &gt;&gt;&gt; book.author 'Bradbury' &gt;&gt;&gt; book NamedTupleBook(title='Fahrenheit 451', author='Bradbury') &gt;&gt;&gt; book == NamedTupleBook("Fahrenheit 451", "Bradbury")) True</code> </pre> <br><p>  Namun terlepas dari kesamaan umum, tuple bernama memiliki keterbatasan.  Mereka datang dari fakta bahwa tuple bernama masih tuple. </p><br><p>  Pertama, Anda masih dapat membandingkan contoh kelas yang berbeda. </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>Car = namedtuple(<span class="hljs-string"><span class="hljs-string">"Car"</span></span>, [<span class="hljs-string"><span class="hljs-string">"model"</span></span>, <span class="hljs-string"><span class="hljs-string">"owner"</span></span>]) &gt;&gt;&gt; book = NamedTupleBook(<span class="hljs-string"><span class="hljs-string">"Fahrenheit 451"</span></span>, <span class="hljs-string"><span class="hljs-string">"Bradbury"</span></span>)) &gt;&gt;&gt; book == Car(<span class="hljs-string"><span class="hljs-string">"Fahrenheit 451"</span></span>, <span class="hljs-string"><span class="hljs-string">"Bradbury"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">True</span></span></code> </pre> <br><p>  Kedua, tuple bernama tidak dapat diubah.  Dalam beberapa situasi, ini berguna, tetapi saya ingin lebih banyak fleksibilitas. <br>  Akhirnya, Anda dapat beroperasi pada tuple bernama juga yang biasa.  Misalnya, beralih lagi. </p><br><h3 id="drugie-proekty">  Proyek lainnya </h3><br><p>  Jika tidak terbatas pada perpustakaan standar, Anda dapat menemukan solusi lain untuk masalah ini.  Secara khusus, proyek ini menarik.  Ia dapat melakukan lebih dari sekadar dataclass dan bekerja pada versi python yang lebih lama seperti 2.7 dan 3.4.  Namun demikian, fakta bahwa itu bukan bagian dari perpustakaan standar mungkin merepotkan </p><br><h2 id="sozdanie">  Ciptaan </h2><br><p>  Anda dapat menggunakan dekorator <code>@dataclass</code> untuk membuat kelas data.  Dalam hal ini, semua bidang kelas yang ditentukan dengan anotasi tipe akan digunakan dalam metode yang sesuai dari kelas yang dihasilkan. </p><br><p>  Sebagai alternatif, ada fungsi <code>make_dataclass</code> , yang berfungsi serupa untuk membuat tupel bernama. </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> dataclasses <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> make_dataclass Book = make_dataclass(<span class="hljs-string"><span class="hljs-string">"Book"</span></span>, [<span class="hljs-string"><span class="hljs-string">"title"</span></span>, <span class="hljs-string"><span class="hljs-string">"author"</span></span>]) book = Book(<span class="hljs-string"><span class="hljs-string">"Fahrenheit 451"</span></span>, <span class="hljs-string"><span class="hljs-string">"Bradbury"</span></span>)</code> </pre> <br><h2 id="znacheniya-po-umolchaniyu">  Nilai default </h2><br><p>  Salah satu fitur yang bermanfaat adalah kemudahan menambahkan nilai default ke bidang.  Masih tidak perlu mendefinisikan ulang metode <code>__init__</code> , cukup tentukan nilai langsung di kelas. </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@dataclass class Book: title: str = "Unknown" author: str = "Unknown author"</span></span></code> </pre> <br><p>  Mereka akan diperhitungkan dalam metode <code>__init__</code> dihasilkan </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>Book() Book(title=<span class="hljs-string"><span class="hljs-string">'Unknown'</span></span>, author=<span class="hljs-string"><span class="hljs-string">'Unknown author'</span></span>) &gt;&gt;&gt; Book(<span class="hljs-string"><span class="hljs-string">"Farenheit 451"</span></span>) Book(title=<span class="hljs-string"><span class="hljs-string">'Farenheit 451'</span></span>, author=<span class="hljs-string"><span class="hljs-string">'Unknown author'</span></span>)</code> </pre> <br><p>  Tetapi seperti halnya kelas dan metode reguler, Anda harus berhati-hati menggunakan standar yang bisa berubah.  Jika, misalnya, Anda perlu menggunakan daftar sebagai nilai default, ada cara lain, tetapi lebih pada itu di bawah ini. </p><br><p>  Selain itu, penting untuk memantau urutan bidang mana dengan nilai default yang ditentukan, karena sama persis dengan urutannya dalam metode <code>__init__</code> </p><br><h2 id="immutabelnye-klassy-dannyh">  Kelas Data Tidak Berubah </h2><br><p>  Contoh tuple bernama tidak berubah.  Dalam banyak situasi, ini adalah ide yang bagus.  Untuk kelas data, Anda dapat melakukannya juga.  Cukup tentukan parameter <code>frozen=True</code> saat membuat kelas, dan jika Anda mencoba mengubah bidangnya, pengecualian <code>FrozenInstanceError</code> akan <code>FrozenInstanceError</code> </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@dataclass(frozen=True) class Book: title: str author: str</span></span></code> </pre> <br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>book = Book(<span class="hljs-string"><span class="hljs-string">"Fahrenheit 451"</span></span>, <span class="hljs-string"><span class="hljs-string">"Bradbury"</span></span>) &gt;&gt;&gt; book.title = <span class="hljs-string"><span class="hljs-string">"1984"</span></span> dataclasses.FrozenInstanceError: cannot assign to field <span class="hljs-string"><span class="hljs-string">'title'</span></span></code> </pre> <br><h2 id="nastroyka-klassa-dannyh">  Pengaturan Kelas Data </h2><br><p>  Selain parameter <code>frozen</code> , dekorator <code>@dataclass</code> memiliki parameter lain: </p><br><ul><li>  <code>init</code> : jika <code>True</code> (default), metode <code>__init__</code> dihasilkan.  Jika kelas sudah memiliki metode <code>__init__</code> yang ditentukan, parameter diabaikan. </li><li>  <code>repr</code> : memungkinkan (secara default) pembuatan metode <code>__repr__</code> .  String yang dihasilkan berisi nama kelas dan nama serta representasi dari semua bidang yang didefinisikan dalam kelas.  Dalam hal ini, masing-masing bidang dapat dikecualikan (lihat di bawah) </li><li>  <code>eq</code> : memungkinkan (secara default) pembuatan metode <code>__eq__</code> .  Objek dibandingkan dengan cara yang sama seolah-olah mereka adalah tupel yang berisi nilai bidang yang sesuai.  Selain itu, pencocokan jenis diperiksa. </li><li>  <code>order</code> memungkinkan (default tidak aktif) pembuatan metode <code>__lt__</code> , <code>__le__</code> , <code>__gt__</code> dan <code>__ge__</code> .  Objek dibandingkan dengan cara yang sama dengan tupel nilai bidang yang sesuai.  Pada saat yang sama, jenis objek juga diperiksa.  Jika <code>order</code> ditentukan, tetapi <code>eq</code> tidak, pengecualian <code>ValueError</code> akan dibuang.  Juga, kelas tidak boleh berisi metode perbandingan yang sudah didefinisikan. </li><li>  <code>unsafe_hash</code> memengaruhi pembuatan metode <code>__hash__</code> .  Perilaku juga tergantung pada nilai-nilai parameter <code>eq</code> dan <code>frozen</code> </li></ul><br><h2 id="nastroyka-otdelnyh-poley">  Kustomisasi masing-masing bidang </h2><br><p>  Dalam sebagian besar situasi standar, ini tidak diperlukan, tetapi dimungkinkan untuk menyesuaikan perilaku kelas data hingga masing-masing bidang menggunakan fungsi bidang. </p><br><h3 id="izmenyaemye-znacheniya-po-umolchaniyu">  Default yang Dapat Diubah </h3><br><p>  Situasi khas yang disebutkan di atas adalah penggunaan daftar atau nilai default yang bisa berubah-ubah.  Anda mungkin menginginkan kelas "rak buku" yang berisi daftar buku.  Jika Anda menjalankan kode berikut: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@dataclass class Bookshelf: books: List[Book] = []</span></span></code> </pre> <br><p>  interpreter akan melaporkan kesalahan: </p><br><pre> <code class="plaintext hljs">ValueError: mutable default &lt;class 'list'&gt; for field books is not allowed: use default_factory</code> </pre> <br><p>  Namun, untuk nilai yang dapat diubah lainnya, peringatan ini tidak akan berfungsi dan akan menyebabkan perilaku program yang salah. </p><br><p>  Untuk menghindari masalah, disarankan untuk menggunakan parameter <code>default_factory</code> dari fungsi <code>field</code> .  Nilainya dapat berupa objek atau fungsi apa pun yang disebut tanpa parameter. <br>  Versi kelas yang benar terlihat seperti ini: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@dataclass class Bookshelf: books: List[Book] = field(default_factory=list)</span></span></code> </pre> <br><h3 id="drugie-parametry">  Pilihan lain </h3><br><p>  Selain <code>default_factory</code> ditentukan, fungsi bidang memiliki parameter berikut: </p><br><ul><li>  <code>default</code> : nilai <code>default</code> .  Parameter ini diperlukan karena bidang ajakan menggantikan nilai bidang default. </li><li>  <code>init</code> : memungkinkan (default) penggunaan suatu bidang dalam metode <code>__init__</code> </li><li>  <code>repr</code> : memungkinkan (default) penggunaan suatu bidang dalam metode <code>__repr__</code> </li><li>  <code>compare</code> termasuk (default) penggunaan bidang dalam metode perbandingan ( <code>__eq__</code> , <code>__le__</code> dan lainnya) </li><li>  <code>hash</code> : mungkin nilai boolean atau <code>None</code> .  Jika <code>True</code> , bidang digunakan untuk menghitung hash.  Jika <code>None</code> ditentukan (secara default), nilai parameter <code>compare</code> digunakan. <br>  Salah satu alasan untuk menentukan <code>hash=False</code> untuk <code>compare=True</code> diberikan <code>compare=True</code> mungkin kesulitan menghitung hash bidang sementara itu diperlukan untuk perbandingan. </li><li>  <code>metadata</code> : kamus khusus atau <code>None</code> .  Nilai tersebut dibungkus dalam <code>MappingProxyType</code> sehingga menjadi tidak berubah.  Parameter ini tidak digunakan oleh kelas data itu sendiri dan dimaksudkan untuk ekstensi pihak ketiga. </li></ul><br><h2 id="obrabotka-posle-inicializacii">  Memproses setelah inisialisasi </h2><br><p>  Metode <code>__init__</code> dibuat secara otomatis memanggil metode <code>__post_init__</code> , jika didefinisikan dalam kelas.  Sebagai aturan, ini disebut dalam bentuk <code>self.__post_init__()</code> , namun, jika variabel tipe <code>InitVar</code> didefinisikan di kelas, mereka akan dilewatkan sebagai parameter metode. </p><br><p>  Jika metode <code>__init__</code> belum dihasilkan, maka <code>__post_init__</code> tidak akan dipanggil. </p><br><p>  Misalnya, tambahkan deskripsi buku yang dihasilkan </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@dataclass class Book: title: str author: str desc: str = None def __post_init__(self): self.desc = self.desc or "`%s` by %s" % (self.title, self.author)</span></span></code> </pre> <br><pre> <code class="plaintext hljs">&gt;&gt;&gt; Book("Fareneheit 481", "Bradbury") Book(title='Fareneheit 481', author='Bradbury', desc='`Fareneheit 481` by Bradbury')</code> </pre> <br><h3 id="parametry-tolko-dlya-inicializacii">  Parameter untuk inisialisasi saja </h3><br><p>  Salah satu kemungkinan yang terkait dengan metode <code>__post_init__</code> adalah parameter yang hanya digunakan untuk inisialisasi.  Jika, ketika mendeklarasikan sebuah field, tentukan <code>InitVar</code> sebagai tipenya, nilainya akan diteruskan sebagai parameter dari metode <code>__post_init__</code> .  Tidak ada cara lain yang bidang yang digunakan dalam kelas data. </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@dataclass class Book: title: str author: str gen_desc: InitVar[bool] = True desc: str = None def __post_init__(self, gen_desc: str): if gen_desc and self.desc is None: self.desc = "`%s` by %s" % (self.title, self.author)</span></span></code> </pre> <br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>Book(<span class="hljs-string"><span class="hljs-string">"Fareneheit 481"</span></span>, <span class="hljs-string"><span class="hljs-string">"Bradbury"</span></span>) Book(title=<span class="hljs-string"><span class="hljs-string">'Fareneheit 481'</span></span>, author=<span class="hljs-string"><span class="hljs-string">'Bradbury'</span></span>, desc=<span class="hljs-string"><span class="hljs-string">'`Fareneheit 481` by Bradbury'</span></span>) &gt;&gt;&gt; Book(<span class="hljs-string"><span class="hljs-string">"Fareneheit 481"</span></span>, <span class="hljs-string"><span class="hljs-string">"Bradbury"</span></span>, gen_desc=<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) Book(title=<span class="hljs-string"><span class="hljs-string">'Fareneheit 481'</span></span>, author=<span class="hljs-string"><span class="hljs-string">'Bradbury'</span></span>, desc=<span class="hljs-keyword"><span class="hljs-keyword">None</span></span>)</code> </pre> <br><h2 id="nasledovanie">  Warisan </h2><br><p>  Ketika Anda menggunakan dekorator <code>@dataclass</code> , ia melewati semua kelas induk dimulai dengan objek dan untuk setiap kelas data menemukan itu menyimpan bidang dalam kamus yang diurutkan, kemudian menambahkan properti dari kelas yang diproses.  Semua metode yang dihasilkan menggunakan bidang dari kamus yang dipesan. </p><br><p>  Akibatnya, jika kelas induk mendefinisikan nilai default, Anda harus mendefinisikan bidang dengan nilai default. </p><br><p>  Karena kamus yang diurutkan menyimpan nilai-nilai dalam urutan penyisipan, untuk kelas-kelas berikut </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@dataclass class BaseBook: title: Any = None author: str = None @dataclass class Book(BaseBook): desc: str = None title: str = "Unknown"</span></span></code> </pre> <br><p>  metode <code>__init__</code> dengan tanda tangan ini akan dihasilkan: </p><br><pre> <code class="plaintext hljs">def __init__(self, title: str="Unknown", author: str=None, desc: str=None)</code> </pre> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id415829/">https://habr.com/ru/post/id415829/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id415815/index.html">Di garis depan sains: analisis artikel arxiv.org</a></li>
<li><a href="../id415817/index.html">Kami meng-overclock cadangan. Kuliah Yandex</a></li>
<li><a href="../id415819/index.html">Laporan Club of Rome 2018, Bab 3.16: Pemerintah Global</a></li>
<li><a href="../id415821/index.html">Cara menata rumah "pintar" dengan kontrol listrik seluas mungkin</a></li>
<li><a href="../id415823/index.html">FindFace ditutup hanya untuk manusia biasa</a></li>
<li><a href="../id415831/index.html">Sepuluh Perintah Baru dari Roskosmos</a></li>
<li><a href="../id415833/index.html">Keuntungan dan kerugian Xamarin</a></li>
<li><a href="../id415835/index.html">Kami menulis GUI ke 1C RAC, atau lagi tentang Tcl / Tk</a></li>
<li><a href="../id415837/index.html">Ikhtisar kecil lentera surya</a></li>
<li><a href="../id415839/index.html">Intisari materi menarik untuk pengembang seluler # 259 (25 Juni - 1 Juli)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>