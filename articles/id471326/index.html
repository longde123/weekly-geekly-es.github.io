<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎌 📱 🎷 The Tale of the Dangerous std :: enable_shared_from_this, atau Zombie antipattern 🍿 🌨️ ☝🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Artikel ini menjelaskan antipattern berbahaya "Zombies", yang dalam beberapa situasi secara alami terjadi ketika menggunakan std :: enable_shared_from...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>The Tale of the Dangerous std :: enable_shared_from_this, atau Zombie antipattern</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471326/">  Artikel ini menjelaskan antipattern berbahaya "Zombies", yang dalam beberapa situasi secara alami terjadi ketika menggunakan std :: enable_shared_from_this.  Materi tersebut berada di persimpangan teknologi C ++ modern dan arsitektur. <br><a name="habracut"></a><br><h3>  Pendahuluan </h3><br>  C ++ 11 memberi pengembang alat yang luar biasa untuk bekerja dengan memori - smart pointer std :: unique_ptr dan sekelompok std :: shared_ptr + std :: lemah_ptr.  Penggunaan pointer cerdas untuk kenyamanan dan keamanan jauh melebihi penggunaan pointer mentah.  Pointer pintar banyak digunakan dalam praktik, seperti  memungkinkan pengembang untuk fokus pada masalah tingkat yang lebih tinggi daripada melacak kebenaran penciptaan / penghapusan entitas yang dibuat secara dinamis. <br>  Std :: enable_shared_from_ template kelas ini juga merupakan bagian dari standar, dan sepertinya agak aneh ketika Anda pertama kali bertemu. <br>  Artikel ini akan membahas bagaimana Anda bisa terjebak dengan penggunaannya. <br><br><h2>  Program pendidikan </h2><br><div class="spoiler">  <b class="spoiler_title">RAII dan pointer cerdas</b> <div class="spoiler_text"> Tujuan langsung dari smart pointer adalah untuk merawat <b>sepotong RAM yang</b> dialokasikan pada heap.  Pointer pintar mengimplementasikan idiom RAII (Akuisisi sumber daya adalah inisialisasi) dan dapat dengan mudah diadaptasi untuk menangani jenis sumber daya lain yang memerlukan inisialisasi dan de-inisialisasi non-sepele, seperti: <br>  - file; <br>  - folder sementara pada disk; <br>  - koneksi jaringan (http, websockets); <br>  - utas eksekusi (utas); <br>  - mutex; <br>  - Lainnya (yang cukup untuk fantasi). <br>  Untuk generalisasi seperti itu, cukup untuk menulis sebuah kelas (pada kenyataannya, kadang-kadang Anda bahkan tidak bisa menulis sebuah kelas, tetapi cukup gunakan deleter - tetapi hari ini kisahnya bukan tentang itu), yang mengimplementasikan: <br>  - inisialisasi dalam konstruktor atau dalam metode terpisah; <br>  - deinitialization pada destructor, <br>  kemudian "bungkus" dalam smart pointer yang sesuai, tergantung pada model kepemilikan yang diperlukan - joint (std :: shared_ptr) atau sole (std :: unique_ptr).  Ini menghasilkan "RAII dua lapis": pointer pintar memungkinkan Anda untuk mentransfer / berbagi kepemilikan sumber daya, dan kelas pengguna menginisialisasi / menonaktifkan inisialisasi sumber daya non-standar. <br>  std :: shared_ptr menggunakan mekanisme penghitungan tautan.  Standar mendefinisikan penghitung tautan kuat (menghitung jumlah salinan std :: shared_ptr) dan penghitung tautan lemah (menghitung jumlah salinan std :: lemah_ptr yang dibuat untuk instance std :: shared_ptr).  Kehadiran setidaknya satu mata rantai yang kuat memastikan bahwa kehancuran belum terjadi.  Properti std :: shared_ptr ini banyak digunakan untuk memastikan validitas suatu objek hingga bekerja dengannya selesai di semua bagian program.  Kehadiran tautan yang lemah tidak mencegah penghancuran objek dan memungkinkan Anda untuk mendapatkan tautan yang kuat hanya sampai dihancurkan. <br>  RAII menjamin pelepasan sumber daya jauh lebih dapat diandalkan daripada panggilan eksplisit untuk menghapus / menghapus [] / gratis / tutup / reset / membuka, karena: <br>  - Anda dapat dengan mudah melupakan panggilan eksplisit; <br>  - panggilan eksplisit dapat dibuat secara keliru lebih dari sekali; <br>  - tantangan eksplisit sulit ketika menerapkan kepemilikan bersama atas sumber daya; <br>  - mekanisme promosi stack di c ++ menjamin panggilan destruktor untuk semua objek yang keluar dari ruang lingkup dalam kasus pengecualian. <br>  Jaminan de-inisialisasi dalam idiom sangat penting sehingga layak mendapat tempat yang baik dalam nama idiom bersama dengan inisialisasi. <br>  Pointer pintar juga memiliki kelemahan: <br>  - keberadaan overhead dalam hal kinerja dan memori (untuk sebagian besar aplikasi tidak signifikan); <br>  - kemungkinan tautan siklis yang menghalangi pelepasan sumber daya dan menyebabkan kebocorannya. <br>  Tentunya setiap pengembang lebih dari sekali membaca tentang tautan melingkar dan melihat contoh sintetik kode bermasalah. <br>  Bahayanya mungkin tampak tidak signifikan karena alasan berikut: <br>  - jika memori sering bocor dan banyak - ini terlihat dalam konsumsinya, dan jika jarang dan sedikit - maka masalahnya tidak mungkin terwujud pada tingkat pengguna akhir; <br>  - menggunakan analisis kode dinamis untuk kebocoran (Valgrind, Clang LeakSanitizer, dll.); <br>  - "Saya tidak menulis seperti itu"; <br>  - "arsitektur saya benar"; <br>  "Kode kita sedang ditinjau." <br></div></div><br><div class="spoiler">  <b class="spoiler_title">std :: enable_share_from_ini</b> <div class="spoiler_text">  Di C ++ 11, kelas helper std :: enable_shared_from_this diperkenalkan.  Untuk pengembang yang berhasil membangun kode tanpa std :: enable_share_from_this, potensi penggunaan kelas ini mungkin tidak jelas. <br>  Apa yang dilakukan std :: enable_shared_from_this? <br>  Ini memungkinkan fungsi anggota dari kelas yang dipakai di std :: shared_ptr untuk menerima tambahan kuat (shared_from_this ()) atau lemah (lemah_from_ini (), mulai dari C ++ 17) salinan std :: shared_ptr di mana ia dibuat .  Anda tidak dapat memanggil shared_from_this () dan lemah_from_this () dari konstruktor dan destruktor. <br><br>  <b>Kenapa begitu sulit?</b>  <b>Anda cukup membangun std :: shared_ptr &lt;T&gt; (ini)</b> <br>  Tidak, kamu tidak bisa.  Semua std :: shared_ptrs yang peduli dengan instance kelas yang sama harus menggunakan satu unit penghitungan tautan.  Tidak ada cara untuk melakukannya tanpa sihir khusus. <br><br>  Prasyarat untuk menggunakan std :: enable_shared_from_this adalah untuk awalnya membuat objek kelas di std :: shared_ptr.  Membuat di tumpukan, mengalokasikan secara dinamis di tumpukan, membuat di std :: unique_ptr - semua ini tidak cocok.  Hanya di std :: shared_ptr. <br><br>  <b>Apakah mungkin membatasi pengguna dengan cara membuat instance kelas?</b> <br>  Ya kamu bisa.  Untuk melakukan ini, cukup: <br>  - menyediakan metode statis untuk membuat instance yang awalnya ditempatkan di std :: shared_ptr; <br>  - Menempatkan konstruktor secara pribadi atau dilindungi; <br>  - Melarang menyalin dan memindahkan semantik. <br>  Kelas masuk ke kandang, menguncinya dan menelan kunci - mulai sekarang semua instansnya akan hidup hanya di std :: shared_ptr, dan tidak ada cara hukum untuk mengeluarkannya dari sana. <br>  Pembatasan seperti itu tidak dapat disebut solusi arsitektur yang baik, tetapi metode ini sepenuhnya sesuai dengan standar. <br>  Selain itu, Anda dapat menggunakan idiom PIMPL: satu-satunya pengguna kelas yang berubah-ubah - fasad - akan membuat implementasi secara ketat di std :: shared_ptr, dan fasad itu sendiri sudah akan dicabut dari pembatasan semacam ini. <br><br>  std :: enable_shared_from_this memiliki nuansa signifikan dalam pewarisan, tetapi mendiskusikannya berada di luar cakupan artikel ini. <br></div></div><br><h2>  Langsung ke intinya </h2><br>  Semua contoh kode yang disediakan dalam artikel dipublikasikan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github</a> . <br>  Kode menunjukkan teknik buruk yang disamarkan sebagai penggunaan C ++ modern yang aman dan aman <br><br><h3>  Simplecyclic </h3><br>  Tampaknya tidak ada yang menandakan masalah.  Deklarasi kelas terlihat sederhana dan mudah.  Kecuali untuk satu detail "kecil" - untuk beberapa alasan pewarisan dari std :: enable_shared_from_ini diterapkan. <br><br><div class="spoiler">  <b class="spoiler_title">SimpleCyclic.h</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; #include &lt;functional&gt; namespace SimpleCyclic { class Cyclic final : public std::enable_shared_from_this&lt;Cyclic&gt; { public: static std::shared_ptr&lt;Cyclic&gt; create(); Cyclic(const Cyclic&amp;) = delete; Cyclic(Cyclic&amp;&amp;) = delete; Cyclic&amp; operator=(const Cyclic&amp;) = delete; Cyclic&amp; operator=(Cyclic&amp;&amp;) = delete; ~Cyclic(); void doSomething(); private: Cyclic(); std::function&lt;void(void)&gt; _fn; }; } // namespace SimpleCyclic</span></span></span></span></code> </pre> <br></div></div><br>  Dan dalam implementasi: <br><br><div class="spoiler">  <b class="spoiler_title">SimpleCyclic.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include "SimpleCyclic.h" namespace SimpleCyclic { Cyclic::Cyclic() = default; Cyclic::~Cyclic() { std::cout &lt;&lt; typeid(*this).name() &lt;&lt; "::" &lt;&lt; __func__ &lt;&lt; std::endl; } std::shared_ptr&lt;Cyclic&gt; Cyclic::create() { return std::shared_ptr&lt;Cyclic&gt;(new Cyclic); } void Cyclic::doSomething() { _fn = [shis = shared_from_this()](){}; std::cout &lt;&lt; typeid(*this).name() &lt;&lt; "::" &lt;&lt; __func__ &lt;&lt; std::endl; } } // namespace SimpleCyclic</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">main.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SimpleCyclic/SimpleCyclic.h"</span></span></span><span class="hljs-meta"> int main() { auto simpleCyclic = SimpleCyclic::Cyclic::create(); simpleCyclic-&gt;doSomething(); return 0; }</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Output Konsol</b> <div class="spoiler_text"><blockquote>  N12SimpleCyclic6CyclicE :: doSomething <br></blockquote><br></div></div><br>  Di dalam tubuh fungsi doSomething (), instance kelas <b>itu sendiri akan</b> membuat salinan kuat tambahan std :: shared_ptr di mana ia ditempatkan.  Kemudian, menggunakan tangkapan umum, salinan ini ditempatkan di fungsi lambda ditugaskan ke bidang data kelas dengan kedok fungsi std :: tidak berbahaya.  Panggilan ke doSomething () menghasilkan referensi melingkar, dan instance kelas tidak akan lagi dihancurkan bahkan setelah penghancuran semua tautan kuat eksternal. <br>  Ada kebocoran memori.  SimpleCyclic :: Cyclic :: ~ Cyclic destructor tidak dipanggil. <br><br>  <b>Instance class "menyimpan" dirinya sendiri.</b> <b><br></b>  <b>Kode macet.</b> <br><br><img src="https://habrastorage.org/webt/xp/jj/_a/xpjj_atj4bf0av8kar46ebxqqew.jpeg"><br>  (gambar diambil <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dari sini</a> ) <br><br>  <b>Dan apa, ini antipattern "Zombie"?</b> <br>  Tidak, ini hanya latihan.  Semua yang paling menarik belum datang. <br><br>  <b>Mengapa pengembang menulis ini?</b> <br>  Contoh sintetis.  Saya tidak mengetahui adanya situasi di mana kode seperti itu akan diperoleh secara harmonis. <br><br>  <b>Jadi, apakah analisis kode dinamis tetap diam?</b> <br>  Tidak, Valgrind dengan jujur ​​melaporkan kebocoran memori: <br><br><div class="spoiler">  <b class="spoiler_title">Posting Valgrind</b> <div class="spoiler_text"><blockquote>  96 (64 langsung, 32 tidak langsung) byte dalam 1 blok <b>pasti hilang</b> dalam catatan kerugian 29 dari 46 <br>  di SimpleCyclic :: Cyclic :: create () di /Users/User/Projects/Zomby_antipattern_concept/SimpleCyclic/SimpleCyclic.cpp:15 <br>  1: malloc di /usr/local/Cellar/valgrind/HEAD-60ab74a/lib/valgrind/vgpreload_memcheck-amd64-darwin.so <br>  2: operator baru (tidak ditandai lama) di /usr/lib/libc++abi.dylib <br>  3: SimpleCyclic :: Cyclic :: create () di /Users/User/Projects/Zomby_antipattern_concept/SimpleCyclic/SimpleCyclic.cpp:15 <br>  4: utama di / Pengguna / Pengguna / Proyek / Zomby_antipattern_concept/SimpleCyclic/main.cpphaps <br></blockquote><br></div></div><br><h3>  Pimplcyclic </h3><br>  Dalam hal ini, file header terlihat benar dan ringkas.  Itu menyatakan fasad yang menyimpan implementasi tertentu di std :: shared_ptr.  Warisan - termasuk dari std :: enable_shared_from_this - tidak ada, tidak seperti contoh sebelumnya. <br><br><div class="spoiler">  <b class="spoiler_title">Pimplcyclic.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; namespace PimplCyclic { class Cyclic { public: Cyclic(); ~Cyclic(); private: class Impl; std::shared_ptr&lt;Impl&gt; _impl; }; } // namespace PimplCyclic</span></span></span></span></code> </pre><br></div></div><br>  Dan dalam implementasi: <br><br><div class="spoiler">  <b class="spoiler_title">Pimplcyclic.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;functional&gt; #include "PimplCyclic.h" namespace PimplCyclic { class Cyclic::Impl : public std::enable_shared_from_this&lt;Cyclic::Impl&gt; { public: ~Impl() { std::cout &lt;&lt; typeid(*this).name() &lt;&lt; "::" &lt;&lt; __func__ &lt;&lt; std::endl; } void doSomething() { _fn = [shis = shared_from_this()](){}; std::cout &lt;&lt; typeid(*this).name() &lt;&lt; "::" &lt;&lt; __func__ &lt;&lt; std::endl; } private: std::function&lt;void(void)&gt; _fn; }; Cyclic::Cyclic() : _impl(std::make_shared&lt;Impl&gt;()) { if (_impl) { _impl-&gt;doSomething(); } } Cyclic::~Cyclic() { std::cout &lt;&lt; typeid(*this).name() &lt;&lt; "::" &lt;&lt; __func__ &lt;&lt; std::endl; } } // namespace PimplCyclic</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">main.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"PimplCyclic/PimplCyclic.h"</span></span></span><span class="hljs-meta"> int main() { auto pimplCyclic = PimplCyclic::Cyclic(); return 0; }</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Output Konsol</b> <div class="spoiler_text"><blockquote>  N11PimplCyclic6Cyclic4ImplE :: doSomething <br>  N11PimplCyclic6CyclicE :: ~ Cyclic <br></blockquote><br></div></div><br>  Memanggil Impl :: doSomething () membuat referensi melingkar dalam sebuah instance dari kelas Impl.  Fasad dihancurkan dengan benar, tetapi implementasinya bocor.  Destuktor PimplCyclic :: Cyclic :: Impl :: ~ Impl tidak disebut. <br>  Contohnya lagi sintetis, tapi kali ini lebih berbahaya - semua peralatan buruk terletak dalam implementasi dan tidak muncul dalam iklan. <br>  Selain itu, untuk membuat tautan melingkar, kode pengguna tidak memerlukan tindakan apa pun selain konstruksi. <br>  Analisis dinamis dalam menghadapi Valgrind, dan kali ini mengungkapkan kebocoran: <br><br><div class="spoiler">  <b class="spoiler_title">Posting Valgrind</b> <div class="spoiler_text"><blockquote>  96 byte dalam 1 blok <b>pasti hilang</b> dalam catatan kerugian 29 dari 46 <br>  dalam PimplCyclic :: Cyclic :: Cyclic () di / Pengguna / Pengguna / Proyek / Zomby_antipattern_concept/PimplCyclic/PimplCyclic.cpp:28 <br>  1: malloc di /usr/local/Cellar/valgrind/HEAD-60ab74a/lib/valgrind/vgpreload_memcheck-amd64-darwin.so <br>  2: operator baru (tidak ditandai lama) di /usr/lib/libc++abi.dylib <br>  3: std :: __ 1 :: __ libcpp_allocate (lama tidak ditandatangani, lama tidak ditandatangani) di /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/new:25 <br>  4: std :: __ 1 :: pengalokasi &lt;std :: __ 1 :: __ shared_ptr_emplace &lt;PimplCyclic :: Cyclic :: Impl, std :: __ 1 :: pengalokasikan &lt;PimplCyclic :: Cyclic :: Impl &gt;&gt;&gt; mengalokasikan (tanpa tanda lama) , batal const *) di /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/memory:1813 <br>  5: std :: __ 1 :: shared_ptr &lt;PimplCyclic :: Cyclic :: Impl&gt; std :: __ 1 :: shared_ptr &lt;PimplCyclic :: Cyclic :: Impl&gt; :: make_shared &lt;&gt; () di /Applications/Xcode.app/Contents /Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/memory:4326 <br>  6: _ZNSt3__1L11make_sharedIN11PimplCyclic6Cyclic4ImplEJEEENS_9enable_ifIXntsr8is_arrayIT_EE5valueENS_10shared_ptrIS5_EEE4typeEDpOT0_ di /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/memory:4706 <br>  7: PimplCyclic :: Cyclic :: Cyclic () di / Pengguna / Pengguna / Proyek / Zomby_antipattern_concept/PimplCyclic/PimplCyclic.cpp:28 <br>  8: PimplCyclic :: Cyclic :: Cyclic () di / Pengguna / Pengguna / Proyek / Zomby_antipattern_concept/PimplCyclic/PimplCyclic.cpp:29 <br>  9: utama di / Pengguna / Pengguna / Proyek / Zomby_antipattern_concept/PimplCyclic/main.cpphaps <br></blockquote><br></div></div><br>  <b>Agak mencurigakan melihat Pimpl, di mana implementasinya disimpan di std :: shared_ptr.</b> <br>  Pimpl klasik berdasarkan pada pointer mentah terlalu kuno, dan std :: unique_ptr memiliki efek samping menyebarkan larangan copy-semantik pada fasad.  Fasad seperti itu akan menerapkan idiom kepemilikan tunggal, yang mungkin tidak sesuai dengan ide arsitektur.  Dari penggunaan std :: shared_ptr untuk menyimpan implementasi, kami menyimpulkan bahwa kelas dirancang untuk memberikan kepemilikan bersama. <br><br>  <b>Bagaimana hal ini berbeda dari memori alokasi kebocoran klasik dengan secara eksplisit memanggil baru tanpa penghapusan berikutnya?</b>  <b>Dengan cara yang sama, semuanya akan menjadi indah di antarmuka, dan dalam implementasi - bug.</b> <br>  Kami sedang mendiskusikan cara <b>-</b> cara <b>modern</b> untuk menembak diri sendiri. <br><br><h2>  Antipattern "Zombies" </h2><br>  Jadi, dari materi di atas jelas: <br>  - pointer pintar dapat diikat ke node; <br>  - penggunaan std :: enable_shared_from_ini dapat berkontribusi untuk ini, karena  memungkinkan turunan suatu kelas untuk mengikat ke dalam simpul dengan hampir tanpa bantuan dari luar. <br><br>  <b>Dan sekarang - perhatian - pertanyaan kunci dari artikel ini: apakah jenis sumber daya dibungkus dengan smart pointer?</b>  <b>Apakah ada perbedaan antara perawatan file RAII dan koneksi HTTPS asinkron?</b> <br><br><h3>  Simplezomby </h3><br>  Kode umum untuk semua contoh zombie berikutnya telah dipindahkan ke Perpustakaan umum. <br><br>  Antarmuka zombie abstrak dengan Pengelola nama sederhana: <br><br><div class="spoiler">  <b class="spoiler_title">Umum / Manajer.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; namespace Common { class Listener; class Manager { public: Manager() = default; Manager(const Manager&amp;) = delete; Manager(Manager&amp;&amp;) = delete; Manager&amp; operator=(const Manager&amp;) = delete; Manager&amp; operator=(Manager&amp;&amp;) = delete; virtual ~Manager() = default; virtual void runOnce(std::shared_ptr&lt;Common::Listener&gt; listener) = 0; }; } // namespace Common</span></span></span></span></code> </pre><br></div></div><br>  Antarmuka abstrak pendengar, siap menerima teks aman: <br><br><div class="spoiler">  <b class="spoiler_title">Umum / Pendengar.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;string&gt; #include &lt;memory&gt; namespace Common { class Listener { public: virtual ~Listener() = default; using Data = std::string; // thread-safe virtual void processData(const std::shared_ptr&lt;const Data&gt; data) = 0; }; } // namespace Common</span></span></span></span></code> </pre><br></div></div><br>  Pendengar yang menampilkan teks ke konsol.  Menerapkan konsep SingletonShared dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Teknik</a> artikel saya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">untuk Menghindari Perilaku Tidak Terdefinisi Ketika Memanggil Singleton</a> : <br><br><div class="spoiler">  <b class="spoiler_title">Umum / Impl / WriteToConsoleListener.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;mutex&gt; #include "Common/Listener.h" namespace Common { class WriteToConsoleListener final : public Listener { public: WriteToConsoleListener(const WriteToConsoleListener&amp;) = delete; WriteToConsoleListener(WriteToConsoleListener&amp;&amp;) = delete; WriteToConsoleListener&amp; operator=(const WriteToConsoleListener&amp;) = delete; WriteToConsoleListener&amp; operator=(WriteToConsoleListener&amp;&amp;) = delete; ~WriteToConsoleListener() override; static std::shared_ptr&lt;WriteToConsoleListener&gt; instance(); // blocking void processData(const std::shared_ptr&lt;const Data&gt; data) override; private: WriteToConsoleListener(); std::mutex _mutex; }; } // namespace Common</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Umum / Impl / WriteToConsoleListener.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include "WriteToConsoleListener.h" namespace Common { WriteToConsoleListener::WriteToConsoleListener() = default; WriteToConsoleListener::~WriteToConsoleListener() { auto lock = std::lock_guard(_mutex); std::cout &lt;&lt; typeid(*this).name() &lt;&lt; "::" &lt;&lt; __func__ &lt;&lt; std::endl; } std::shared_ptr&lt;WriteToConsoleListener&gt; WriteToConsoleListener::instance() { static auto inst = std::shared_ptr&lt;WriteToConsoleListener&gt;(new WriteToConsoleListener); return inst; } void WriteToConsoleListener::processData(const std::shared_ptr&lt;const Data&gt; data) { if (data) { auto lock = std::lock_guard(_mutex); std::cout &lt;&lt; *data &lt;&lt; std::flush; } } } // namespace Common</span></span></span></span></code> </pre><br></div></div><br>  Dan akhirnya, zombie pertama, paling sederhana dan paling cerdik. <br><br><div class="spoiler">  <b class="spoiler_title">SimpleZomby.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; #include &lt;atomic&gt; #include &lt;thread&gt; #include "Common/Manager.h" namespace Common { class Listener; } // namespace Common namespace SimpleZomby { class Zomby final : public Common::Manager, public std::enable_shared_from_this&lt;Zomby&gt; { public: static std::shared_ptr&lt;Zomby&gt; create(); ~Zomby() override; void runOnce(std::shared_ptr&lt;Common::Listener&gt; listener) override; private: Zomby(); using Semaphore = std::atomic&lt;bool&gt;; std::shared_ptr&lt;Common::Listener&gt; _listener; Semaphore _semaphore = false; std::thread _thread; }; } // namespace SimpleZomby</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">SimpleZomby.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;sstream&gt; #include "SimpleZomby.h" #include "Common/Listener.h" namespace SimpleZomby { std::shared_ptr&lt;Zomby&gt; Zomby::create() { return std::shared_ptr&lt;Zomby&gt;(new Zomby()); } Zomby::Zomby() = default; Zomby::~Zomby() { _semaphore = false; if (_thread.joinable()) { _thread.detach(); } if (_listener) { std::ostringstream buf; buf &lt;&lt; typeid(*this).name() &lt;&lt; "::" &lt;&lt; __func__ &lt;&lt; std::endl; _listener-&gt;processData(std::make_shared&lt;Common::Listener::Data&gt;(buf.str())); } } void Zomby::runOnce(std::shared_ptr&lt;Common::Listener&gt; listener) { if (_semaphore) { throw std::runtime_error("SimpleZomby::Zomby::runOnce() called twice"); } _listener = listener; _semaphore = true; _thread = std::thread([shis = shared_from_this()](){ while (shis &amp;&amp; shis-&gt;_listener &amp;&amp; shis-&gt;_semaphore) { shis-&gt;_listener-&gt;processData(std::make_shared&lt;Common::Listener::Data&gt;("SimpleZomby is alive!\n")); std::this_thread::sleep_for(std::chrono::seconds(1)); } }); } } // namespace SimpleZomby</span></span></span></span></code> </pre><br></div></div><br>  Zombie menjalankan fungsi lambda di utas terpisah, secara berkala mengirim string ke pendengar.  Fungsi Lambda untuk bekerja membutuhkan semaphore dan pendengar, yang merupakan bidang kelas zombie.  Fungsi lambda tidak menangkap mereka sebagai bidang yang terpisah, tetapi menggunakan objek sebagai agregator.  Menghancurkan instance dari kelas zombie sebelum fungsi lambda selesai akan menghasilkan perilaku yang tidak terdefinisi.  Untuk menghindari ini, fungsi lambda menangkap salinan shared_from_this () yang kuat. <br>  Dalam destruktor zombie, semaphore disetel ke false, setelah itu detach () dipanggil untuk stream.  Mengatur semaphore memberitahu thread untuk dimatikan. <br><br>  <b>Di destructor, perlu untuk memanggil not detach (), tetapi join ()!</b> <br>  ... dan dapatkan destructor yang memblokir eksekusi untuk waktu yang tidak terbatas, yang mungkin tidak dapat diterima. <br><br>  <b>Jadi ini merupakan pelanggaran RAII!</b>  <b>RAII seharusnya keluar dari destructor hanya setelah melepaskan sumber daya!</b> <br>  Jika benar - maka ya, perusak zombie tidak melepaskan sumber daya, tetapi hanya <b>menjamin bahwa rilis akan dibuat</b> .  Kadang diproduksi - mungkin segera, atau mungkin tidak juga.  Dan bahkan mungkin bahwa main akan selesai bekerja lebih awal - maka utas akan dihapus secara paksa oleh sistem operasi.  Tetapi pada kenyataannya, garis antara RAII "benar" dan "salah" bisa sangat tipis: misalnya, "benar" RAII, yang memanggil std :: filesystem :: remove () di destructor untuk file sementara, mungkin mengembalikan kontrol ke sana saat ketika perintah tulis masih akan berada di salah satu cache yang mudah menguap dan tidak akan ditulis dengan jujur ​​ke piring magnetik hard disk. <br><br><div class="spoiler">  <b class="spoiler_title">main.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;chrono&gt; #include &lt;thread&gt; #include &lt;sstream&gt; #include "Common/Impl/WriteToConsoleListener.h" #include "SimpleZomby/SimpleZomby.h" int main() { auto writeToConsoleListener = Common::WriteToConsoleListener::instance(); { auto simpleZomby = SimpleZomby::Zomby::create(); simpleZomby-&gt;runOnce(writeToConsoleListener); std::this_thread::sleep_for(std::chrono::milliseconds(4500)); } // Zomby should be killed here { std::ostringstream buf; buf &lt;&lt; "============================================================\n" &lt;&lt; "| Zomby was killed |\n" &lt;&lt; "============================================================\n"; if (writeToConsoleListener) { writeToConsoleListener-&gt;processData(std::make_shared&lt;Common::Listener::Data&gt;(buf.str())); } } std::this_thread::sleep_for(std::chrono::milliseconds(5000)); return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Output Konsol</b> <div class="spoiler_text"><blockquote>  SimpleZomby masih hidup! <br>  SimpleZomby masih hidup! <br>  SimpleZomby masih hidup! <br>  SimpleZomby masih hidup! <br>  SimpleZomby masih hidup! <br>  =================================================== =========== <br>  |  Zomby terbunuh | <br>  =================================================== =========== <br>  SimpleZomby masih hidup! <br>  SimpleZomby masih hidup! <br>  SimpleZomby masih hidup! <br>  SimpleZomby masih hidup! <br>  SimpleZomby masih hidup! <br></blockquote><br></div></div><br>  Apa yang bisa dilihat dari output program: <br>  - zombie terus bekerja bahkan setelah meninggalkan bidang visibilitas; <br>  - tidak ada destruktor yang dipanggil untuk zombie atau WriteToConsoleListener. <br>  Kebocoran memori telah terjadi. <br>  Terjadi kebocoran sumber daya.  Dan sumber daya dalam hal ini adalah utas eksekusi. <br>  Kode yang seharusnya dihentikan terus bekerja di utas terpisah. <br>  Kebocoran WriteToConsoleListener bisa dicegah dengan menggunakan teknik SingletonWeak dari artikel saya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Menghindari Perilaku Tidak Pasti Saat Memanggil Singleton</a> , tetapi saya sengaja tidak melakukannya. <br><br><img src="https://habrastorage.org/webt/mg/qu/e3/mgque3fstboi4ot2hvdwniafixe.jpeg"><br>  (gambar diambil <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dari sini</a> ) <br><br>  <b>Kenapa Zombies?</b> <br>  Karena dia terbunuh, dan dia masih hidup. <br><br>  <b>Apa bedanya dengan referensi sirkuler pada contoh sebelumnya?</b> <br>  Fakta bahwa sumber daya yang hilang bukan hanya sepotong memori, tetapi sesuatu yang secara independen mengeksekusi kode secara independen dari utas yang meluncurkannya. <br><br>  <b>Apakah mungkin untuk menghancurkan "Zombies"?</b> <br>  Setelah meninggalkan ruang lingkup (mis., Setelah menghancurkan semua referensi eksternal yang kuat dan lemah terhadap zombie) - itu tidak mungkin.  Zombie akan dihancurkan ketika dia memutuskan untuk menghancurkan dirinya sendiri (ya, itu adalah sesuatu dengan perilaku aktif), mungkin tidak pernah, yaitu.  akan bertahan hingga sistem operasi membersihkan ketika aplikasi berakhir.  Tentu saja, kode pengguna mungkin memiliki beberapa efek pada kondisi untuk keluar dari kode zombie, tetapi efek ini akan tidak langsung dan tergantung pada implementasi. <br><br>  <b>Dan sebelum meninggalkan ruang lingkup?</b> <br>  Anda dapat secara eksplisit memanggil destruktor zombie, tetapi Anda tidak mungkin untuk menghindari perilaku tidak terdefinisi karena penghancuran berulang objek oleh smart pointer destructor juga - ini adalah pertarungan melawan RAII  Atau Anda dapat menambahkan fungsi de-inisialisasi eksplisit - dan ini adalah penolakan RAII. <br><br>  <b>Bagaimana ini berbeda dari hanya memulai utas diikuti oleh detach ()?</b> <br>  Dalam kasus zombie, berbeda dengan panggilan sederhana untuk melepaskan (), ada ide untuk menghentikan aliran.  Hanya saja tidak berhasil.  Memiliki ide yang tepat membantu menutupi masalah. <br><br>  <b>Apakah contohnya masih sintetis?</b> <br>  Sebagian.  Dalam contoh sederhana ini, tidak ada alasan yang cukup untuk menggunakan shared_from_this () - misalnya, Anda bisa melakukan dengan menangkap lemah_from_this () atau mengambil semua bidang yang diperlukan di kelas.  Tetapi dengan kompleksitas tugas, keseimbangan mungkin bergeser ke samping <br>  shared_from_ini (). <br><br>  <b>Valgrind, Valgrind!</b>  <b>Kami memiliki garis pertahanan tambahan terhadap zombie!</b> <br>  Alas dan ah - tetapi Valgrind tidak mengungkapkan kebocoran memori.  Kenapa - saya tidak tahu.  Dalam diagnosa, hanya ada entri <b>"mungkin hilang"</b> yang menunjukkan fungsi sistem - kurang lebih sama dan dengan jumlah yang sama seperti ketika mengerjakan main kosong.  Tidak ada referensi kode pengguna.  Alat analisis dinamis lain mungkin lebih baik, tetapi jika Anda masih mengandalkannya, baca terus. <br><br><h3>  Steppingzomby </h3><br>  Kode dalam contoh ini melanjutkan melalui langkah-langkah resolDnsName ---&gt; connectTcp ---&gt; createSsl ---&gt; sendHttpRequest ---&gt; readHttpReply, mensimulasikan operasi koneksi HTTPS klien dalam eksekusi asinkron.  Setiap langkah membutuhkan waktu sekitar satu detik. <br><br><div class="spoiler">  <b class="spoiler_title">Steppingzomby.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; #include &lt;atomic&gt; #include &lt;thread&gt; #include "Common/Manager.h" namespace Common { class Listener; } // namespace Common namespace SteppingZomby { class Zomby final : public Common::Manager, public std::enable_shared_from_this&lt;Zomby&gt; { public: static std::shared_ptr&lt;Zomby&gt; create(); ~Zomby() override; void runOnce(std::shared_ptr&lt;Common::Listener&gt; listener) override; private: Zomby(); using Semaphore = std::atomic&lt;bool&gt;; std::shared_ptr&lt;Common::Listener&gt; _listener; Semaphore _semaphore = false; std::thread _thread; void resolveDnsName(); void connectTcp(); void establishSsl(); void sendHttpRequest(); void readHttpReply(); }; } // namespace SteppingZomby</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Steppingzomby.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;sstream&gt; #include &lt;string&gt; #include "SteppingZomby.h" #include "Common/Listener.h" namespace { void doSomething(Common::Listener&amp; listener, std::string&amp;&amp; callingFunctionName) { listener.processData(std::make_shared&lt;Common::Listener::Data&gt;(callingFunctionName + " started\n")); std::this_thread::sleep_for(std::chrono::milliseconds(1000)); listener.processData(std::make_shared&lt;Common::Listener::Data&gt;(callingFunctionName + " finished\n")); } } // namespace namespace SteppingZomby { Zomby::Zomby() = default; std::shared_ptr&lt;Zomby&gt; Zomby::create() { return std::shared_ptr&lt;Zomby&gt;(new Zomby()); } Zomby::~Zomby() { _semaphore = false; if (_thread.joinable()) { _thread.detach(); } if (_listener) { std::ostringstream buf; buf &lt;&lt; typeid(*this).name() &lt;&lt; "::" &lt;&lt; __func__ &lt;&lt; std::endl; _listener-&gt;processData(std::make_shared&lt;Common::Listener::Data&gt;(buf.str())); } } void Zomby::runOnce(std::shared_ptr&lt;Common::Listener&gt; listener) { if (_semaphore) { throw std::runtime_error("SteppingZomby::Zomby::runOnce() called twice"); } _listener = listener; _semaphore = true; _thread = std::thread([shis = shared_from_this()](){ if (shis &amp;&amp; shis-&gt;_listener &amp;&amp; shis-&gt;_semaphore) { shis-&gt;resolveDnsName(); } if (shis &amp;&amp; shis-&gt;_listener &amp;&amp; shis-&gt;_semaphore) { shis-&gt;connectTcp(); } if (shis &amp;&amp; shis-&gt;_listener &amp;&amp; shis-&gt;_semaphore) { shis-&gt;establishSsl(); } if (shis &amp;&amp; shis-&gt;_listener &amp;&amp; shis-&gt;_semaphore) { shis-&gt;sendHttpRequest(); } if (shis &amp;&amp; shis-&gt;_listener &amp;&amp; shis-&gt;_semaphore) { shis-&gt;readHttpReply(); } }); } void Zomby::resolveDnsName() { doSomething(*_listener, std::string(typeid(*this).name()) + "::" + __func__); } void Zomby::connectTcp() { doSomething(*_listener, std::string(typeid(*this).name()) + "::" + __func__); } void Zomby::establishSsl() { doSomething(*_listener, std::string(typeid(*this).name()) + "::" + __func__); } void Zomby::sendHttpRequest() { doSomething(*_listener, std::string(typeid(*this).name()) + "::" + __func__); } void Zomby::readHttpReply() { doSomething(*_listener, std::string(typeid(*this).name()) + "::" + __func__); } } // namespace SteppingZomby</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">main.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;chrono&gt; #include &lt;thread&gt; #include &lt;sstream&gt; #include "SteppingZomby/SteppingZomby.h" #include "Common/Impl/WriteToConsoleListener.h" int main() { auto writeToConsoleListener = Common::WriteToConsoleListener::instance(); { auto steppingZomby = SteppingZomby::Zomby::create(); steppingZomby-&gt;runOnce(writeToConsoleListener); std::this_thread::sleep_for(std::chrono::milliseconds(1500)); } // Zombies should be killed here { std::ostringstream buf; buf &lt;&lt; "============================================================\n" &lt;&lt; "| Zomby was killed |\n" &lt;&lt; "============================================================\n"; if (writeToConsoleListener) { writeToConsoleListener-&gt;processData(std::make_shared&lt;Common::Listener::Data&gt;(buf.str())); } } std::this_thread::sleep_for(std::chrono::milliseconds(5000)); return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Output Konsol</b> <div class="spoiler_text"><blockquote>  N13SteppingZomby5ZombyE :: resolDnsName dimulai <br>  N13SteppingZomby5ZombyE :: resolDnsName selesai <br>  N13SteppingZomby5ZombyE :: connectTcp dimulai <br>  =================================================== =========== <br>  |  Zomby terbunuh | <br>  =================================================== =========== <br>  N13SteppingZomby5ZombyE :: connectTcp selesai <br>  N13SteppingZomby5ZombyE :: establishmentSsl dimulai <br>  N13SteppingZomby5ZombyE :: establishmentSsl selesai <br>  N13SteppingZomby5ZombyE :: sendHttpRequest dimulai <br>  N13SteppingZomby5ZombyE :: sendHttpRequest selesai <br>  N13SteppingZomby5ZombyE :: readHttpReply dimulai <br>  N13SteppingZomby5ZombyE :: readHttpReply selesai <br>  N13SteppingZomby5ZombyE :: ~ Zomby <br>  N6Common22WriteToConsoleListenerE :: ~ WriteToConsoleListener <br></blockquote><br></div></div><br>  Seperti pada contoh sebelumnya, panggilan untuk menjalankanOnce () menyebabkan referensi melingkar. <br>  Tapi kali ini, penghancur Zomby dan WriteToConsoleListener dipanggil.  Semua sumber daya dirilis dengan benar hingga aplikasi dihentikan.  Kebocoran memori tidak terjadi. <br><br>  <b>Lalu apa masalahnya?</b> <br>  Masalahnya adalah bahwa zombie hidup terlalu lama - sekitar tiga setengah detik setelah penghancuran semua tautan eksternal yang kuat dan lemah.  Sekitar tiga detik lebih lama dari seharusnya.  Dan selama ini dia terlibat dalam mempromosikan implementasi koneksi HTTPS - sampai dia membawanya ke akhir.  Terlepas dari kenyataan bahwa hasilnya tidak diperlukan lagi.  Terlepas dari kenyataan bahwa logika bisnis yang unggul mencoba menghentikan zombie. <br><br>  <b>Nah, pikirkanlah, Anda mendapatkan jawaban yang tidak Anda butuhkan ....</b> <br>  Dalam kasus koneksi HTTPS klien, konsekuensi <b>di pihak kami</b> mungkin sebagai berikut: <br>  - konsumsi memori; <br>  - Konsumsi CPU; <br>  - Konsumsi port TCP; <br>  - bandwidth saluran komunikasi (baik permintaan maupun responsnya dapat berupa volume dalam megabyte); <br>  - data yang tidak terduga dapat mengganggu pengoperasian logika bisnis tingkat tinggi - hingga transisi ke cabang eksekusi yang salah atau perilaku yang tidak terdefinisi, karena  mekanisme pemrosesan respons mungkin sudah dihancurkan. <br>  Dan <b>di sisi yang jauh</b> (jangan lupa - permintaan HTTPS ditujukan untuk seseorang) - pemborosan sumber daya yang persis sama, plus itu mungkin: <br>  - Menerbitkan foto kucing di situs web perusahaan; <br>  - Menonaktifkan pemanas di bawah lantai di dapur Anda; <br>  - pelaksanaan perintah perdagangan di bursa; <br>  - transfer uang dari akun Anda; <br>  - Peluncuran rudal balistik antarbenua. <br>  Logika bisnis mencoba menghentikan zombie dengan menghapus semua tautan kuat dan lemah ke sana.  Penghentian kemajuan permintaan HTTPS <b>seharusnya terjadi</b> - belum terlambat, data level aplikasi belum dikirim. <br>  Tapi zombie memutuskan dengan caranya sendiri. <br><br>  Logika bisnis dapat membuat objek baru sebagai ganti zombie dan sekali lagi mencoba menghancurkannya, melipatgandakan sumber daya. <br>  Dalam kasus proses yang berkelanjutan (misalnya, koneksi Websocket), pemborosan sumber daya dapat berlanjut selama berjam-jam, dan jika ada mekanisme rekoneksi otomatis dalam implementasi ketika koneksi terputus, umumnya dapat dihentikan. <br><br>  <b>Valgrind?</b> <br>  Tidak ada peluang.  Semuanya dilepaskan dan dibersihkan dengan benar.  Terlambat dan bukan dari utas utama, tetapi sepenuhnya benar. <br><br><h3>  Boozdedzomby </h3><br>  Contoh ini menggunakan boozd :: azzio library, yang merupakan tiruan dari boost :: asio.  Terlepas dari kenyataan bahwa tiruannya agak kasar, itu memungkinkan kami untuk menunjukkan esensi masalah.     io_context::async_read (   ,     ), : <br> — stream,     ; <br> — ,    ; <br> — callback-,       . <br>  io_context::async_read       callback,       (, ).        io_context::run() (     ,        ). <br><br><div class="spoiler"> <b class="spoiler_title">buffer.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;vector&gt; namespace boozd::azzio { using buffer = std::vector&lt;int&gt;; } // namespace boozd::azzio</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title">stream.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;optional&gt; namespace boozd::azzio { class stream { public: virtual ~stream() = default; virtual std::optional&lt;int&gt; read() = 0; }; } // namespace boozd::azzio</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title">io_context.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;functional&gt; #include &lt;optional&gt; #include "buffer.h" namespace boozd::azzio { class stream; class io_context { public: ~io_context(); enum class error_code {no_error, good_error, bad_error, unknown_error, known_error, well_known_error}; using handler = std::function&lt;void(error_code)&gt;; // Start an asynchronous operation to read a certain amount of data from a stream. // This function is used to asynchronously read a certain number of bytes of data from a stream. // The function call always returns immediately. void async_read(stream&amp; s, buffer&amp; b, handler&amp;&amp; handler); // Run the io_context object's event processing loop. void run(); private: using pack = std::tuple&lt;stream&amp;, buffer&amp;&gt;; using pack_optional = std::optional&lt;pack&gt;; using handler_optional = std::optional&lt;handler&gt;; pack_optional _pack_optional; handler_optional _handler_optional; }; } // namespace boozd::azzio</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title">io_context.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;thread&gt; #include &lt;chrono&gt; #include "io_context.h" #include "stream.h" namespace boozd::azzio { io_context::~io_context() { std::cout &lt;&lt; typeid(*this).name() &lt;&lt; "::" &lt;&lt; __func__ &lt;&lt; std::endl; } void io_context::async_read(stream&amp; s, buffer&amp; b, io_context::handler&amp;&amp; handler) { _pack_optional.emplace(s, b); _handler_optional.emplace(std::move(handler)); } void io_context::run() { if (_pack_optional &amp;&amp; _handler_optional) { auto&amp; [s, b] = *_pack_optional; using namespace std::chrono; auto start = steady_clock::now(); while (duration_cast&lt;milliseconds&gt;(steady_clock::now() - start).count() &lt; 1000) { if (auto read = s.read()) b.emplace_back(*read); std::this_thread::sleep_for(milliseconds(100)); } (*_handler_optional)(error_code::no_error); } } } // namespace boozd::azzio</span></span></span></span></code> </pre><br></div></div><br>    boozd::azzio::stream,   : <br><br><div class="spoiler"> <b class="spoiler_title">impl/random_stream.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"boozd/azzio/stream.h"</span></span></span><span class="hljs-meta"> namespace boozd::azzio { class random_stream final : public stream { public: ~random_stream() override; std::optional</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;int&gt; read() override; }; } // namespace boozd::azzio</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title">impl/random_stream.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include "random_stream.h" namespace boozd::azzio { boozd::azzio::random_stream::~random_stream() { std::cout &lt;&lt; typeid(*this).name() &lt;&lt; "::" &lt;&lt; __func__ &lt;&lt; std::endl; } std::optional&lt;int&gt; random_stream::read() { if (!(rand() &amp; 0x1)) return rand(); return std::nullopt; } } // namespace boozd::azzio</span></span></span></span></code> </pre><br></div></div><br> BoozdedZomby     -. -      async_read(),       boozd::azzio   run().     boozd::azzio        ( )      callback-.      ,    , -  shared_from_this. <br><br><div class="spoiler"> <b class="spoiler_title">BoozdedZomby.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; #include &lt;atomic&gt; #include &lt;thread&gt; #include "Common/Manager.h" #include "boozd/azzio/buffer.h" #include "boozd/azzio/io_context.h" #include "boozd/azzio/impl/random_stream.h" namespace Common { class Listener; } // namespace Common namespace BoozdedZomby { class Zomby final : public Common::Manager, public std::enable_shared_from_this&lt;Zomby&gt; { public: static std::shared_ptr&lt;Zomby&gt; create(); ~Zomby() override; void runOnce(std::shared_ptr&lt;Common::Listener&gt; listener) override; private: Zomby(); using Semaphore = std::atomic&lt;bool&gt;; Semaphore _semaphore = false; std::shared_ptr&lt;Common::Listener&gt; _listener; boozd::azzio::random_stream _stream; boozd::azzio::buffer _buffer; boozd::azzio::io_context _context; std::thread _thread; }; } // namespace BoozdedZomby</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title">BoozdedZomby.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;sstream&gt; #include "boozd/azzio/impl/random_stream.h" #include "BoozdedZomby.h" #include "Common/Listener.h" namespace BoozdedZomby { Zomby::Zomby() = default; std::shared_ptr&lt;Zomby&gt; Zomby::create() { return std::shared_ptr&lt;Zomby&gt;(new Zomby()); } Zomby::~Zomby() { _semaphore = false; if (_thread.joinable()) { _thread.detach(); } if (_listener) { std::ostringstream buf; buf &lt;&lt; typeid(*this).name() &lt;&lt; "::" &lt;&lt; __func__ &lt;&lt; std::endl; _listener-&gt;processData(std::make_shared&lt;Common::Listener::Data&gt;(buf.str())); } } void Zomby::runOnce(std::shared_ptr&lt;Common::Listener&gt; listener) { if (_semaphore) { throw std::runtime_error("BoozdedZomby::Zomby::runOnce() called twice"); } _listener = listener; _semaphore = true; _thread = std::thread([shis = shared_from_this()]() { while (shis &amp;&amp; shis-&gt;_semaphore &amp;&amp; shis-&gt;_listener) { auto handler = [shis](auto errorCode) { if (shis &amp;&amp; shis-&gt;_listener &amp;&amp; errorCode == boozd::azzio::io_context::error_code::no_error) { std::ostringstream buf; buf &lt;&lt; "BoozdedZomby has got a fresh data: "; for (auto const &amp;elem : shis-&gt;_buffer) buf &lt;&lt; elem &lt;&lt; ' '; buf &lt;&lt; std::endl; shis-&gt;_listener-&gt;processData(std::make_shared&lt;Common::Listener::Data&gt;(buf.str())); } }; shis-&gt;_buffer.clear(); shis-&gt;_context.async_read(shis-&gt;_stream, shis-&gt;_buffer, handler); shis-&gt;_context.run(); } }); } } // namespace BoozdedZomby</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title">main.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;chrono&gt; #include &lt;thread&gt; #include &lt;sstream&gt; #include "BoozdedZomby/BoozdedZomby.h" #include "Common/Impl/WriteToConsoleListener.h" int main() { auto writeToConsoleListener = Common::WriteToConsoleListener::instance(); { auto boozdedZomby = BoozdedZomby::Zomby::create(); boozdedZomby-&gt;runOnce(writeToConsoleListener); std::this_thread::sleep_for(std::chrono::milliseconds(4500)); } // Zombies should be killed here { std::ostringstream buf; buf &lt;&lt; "============================================================\n" &lt;&lt; "| Zomby was killed |\n" &lt;&lt; "============================================================\n"; if (writeToConsoleListener) { writeToConsoleListener-&gt;processData(std::make_shared&lt;Common::Listener::Data&gt;(buf.str())); } } std::this_thread::sleep_for(std::chrono::milliseconds(5000)); return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title">  </b> <div class="spoiler_text"><blockquote> BoozdedZomby has got a fresh data: 1144108930 101027544 1458777923 1115438165 74243042 <br> BoozdedZomby has got a fresh data: 143542612 1131570933 <br> BoozdedZomby has got a fresh data: 893351816 563613512 704877633 <br> BoozdedZomby has got a fresh data: 1551901393 1399125485 1899894091 937186357 590357944 357571490 <br> ============================================================ <br>  | Zomby was killed | <br> ============================================================ <br> BoozdedZomby has got a fresh data: 1927702196 130060903 1083454666 2118797801 2035308228 824938981 <br> BoozdedZomby has got a fresh data: 2020739063 1635339425 34075629 <br> BoozdedZomby has got a fresh data: 2146319451 500782188 1269406752 884936716 892053144 <br> BoozdedZomby has got a fresh data: 330111137 1723153177 1070477904 <br> BoozdedZomby has got a fresh data: 343098142 280090412 589673557 889688008 2014119113 388471006 <br></blockquote><br></div></div><br>    run_once()   .         .       ,     : <br> — boozdedZomby; <br> — writeToConsoleListener; <br> —   . <br>   . <br>   . <br><br> <b>     ?</b> <br>      .      .          boost::asio.  ,              —        ( ). <br><br> <b>Valgrind?</b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dulu. </font><font style="vertical-align: inherit;">Meskipun sepertinya telah mendeteksi kebocoran.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zombi di alam liar </font></font></h2><br> <b> !    !</b> <br>   . <br> <a href="https://www.boost.org/doc/libs/master/libs/beast/example/http/client/async/"> HTTP-</a> <br> <a href=""> Websocket-</a> <br>    boost ,    BoozdedZomby + SteppingZomby.   ,     .         ,      production —       ,      . <br><br> <b>  ,   boost::asio::io_context!</b> <br> …    n  (, -),    . <br><br>  : <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">     </a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">    stackoverflow ,        </a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">   ,      </a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">         </a> <br><br><h2>  Kesimpulan </h2><br> ,        «». <br><br>         ,       . <br><br>        std::thread    —          . <br><br>      ,   . <br><br>     event-driven,        (polling-based). <br><br>     . <br><br> ,  <b></b>           .       std::enable_shared_from_this,       (       —       ). ,        :            -    . <br><br>           ,    SteppingZomby.       —          shared_from_this (  ,   ,       —   1  6  ). <br><br>           —     ,  .   . <br><br>  ,   ,  .        std::enable_shared_from_this —  <b></b> . <br><br> PS:    —        . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id471326/">https://habr.com/ru/post/id471326/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id471310/index.html">Pendapat saya sangat subyektif tentang pendidikan profesional dan tidak hanya di bidang TI</a></li>
<li><a href="../id471312/index.html">Mempersiapkan Sertifikasi Spring Profesional. Boot musim semi</a></li>
<li><a href="../id471318/index.html">September Machine Learning dan Intelijen Berita Buatan Intisari</a></li>
<li><a href="../id471320/index.html">Alat untuk Pengembang Perangkat Lunak: Perpustakaan Kerangka Terbuka dan Pembelajaran Mesin</a></li>
<li><a href="../id471324/index.html">Apakah jaringan saraf memimpikan Mona Lisa?</a></li>
<li><a href="../id471330/index.html">Kisah-kisah komputer bulan. Bagian 2</a></li>
<li><a href="../id471332/index.html">Kisah-kisah komputer bulan. Bagian 3</a></li>
<li><a href="../id471334/index.html">Untuk menghafal, tetapi tidak menjejalkan - belajar "dengan kartu"</a></li>
<li><a href="../id471336/index.html">Holivar. Sejarah Runet. Bagian 6. Kunci: Lurk, Tape, 282 dan jalur Cina</a></li>
<li><a href="../id471340/index.html">Drimsim vs Mate 20 Pro Round! Tapi untuk siapa?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>