<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üè® ü•à ü§ò No√ß√µes b√°sicas da API JAVA SOUND üó£Ô∏è üíáüèº üë®üèø‚Äçüíª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ol√° Habr! Apresento a voc√™ a tradu√ß√£o do artigo ‚ÄúJava Sound, Getting Started, Part 1, Playback‚Äù . 

 Som em JAVA, parte um, o come√ßo. Tocando som 

 E...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>No√ß√µes b√°sicas da API JAVA SOUND</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/434424/">  Ol√° Habr!  Apresento a voc√™ a tradu√ß√£o do artigo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">‚ÄúJava Sound, Getting Started, Part 1, Playback‚Äù</a> . <br><br><h3>  Som em JAVA, parte um, o come√ßo.  Tocando som </h3><br><iframe width="560" height="315" src="https://www.youtube.com/embed/1JZnj4eNHXE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Este √© o come√ßo de uma s√©rie de oito li√ß√µes que o familiarizar√£o totalmente com a API Java Sound. <br><a name="habracut"></a><br>  O que √© som na percep√ß√£o humana?  Essa √© a sensa√ß√£o que experimentamos quando uma mudan√ßa na press√£o do ar √© transmitida para as pequenas √°reas sensoriais dentro de nossos ouvidos. <br><br>  E o principal objetivo da cria√ß√£o da API de som √© fornecer meios para escrever c√≥digo, o que ajudar√° a transferir ondas de press√£o para os ouvidos do sujeito certo, na hora certa. <br><br>  Tipos de som em Java: <br><br><ol><li>  A API Java Sound suporta dois tipos principais de √°udio (som). </li><li>  Som digitalizado e gravado diretamente como um arquivo </li><li>  Grave como um arquivo MIDI.  Muito distante, mas semelhante √† nota√ß√£o musical, onde os instrumentos musicais s√£o tocados na sequ√™ncia desejada. </li></ol><br>  Esses tipos s√£o bastante diferentes em sua ess√™ncia e vamos nos concentrar no primeiro, j√° que na maioria dos casos estamos lidando com som que precisa ser digitalizado para gravar de uma fonte externa para um arquivo ou vice-versa para reproduzir o som anteriormente gravado nesse arquivo. <br><br><h3>  Pr√©-visualiza√ß√£o </h3><br>  A API Java Sound √© baseada no conceito de <i>linhas e mixers.</i> <br><br>  Seguinte: <br>  Descreveremos as caracter√≠sticas f√≠sicas e el√©tricas da representa√ß√£o anal√≥gica do som aplicada a um <i>mixer de √°udio</i> . <br><br>  Voltaremos ao cen√°rio da banda de rock iniciante, que usa seis microfones e dois alto-falantes est√©reo nesse caso.  Precisamos disso para entender o funcionamento do mixer de √°udio. <br><br>  A seguir, analisamos v√°rios temas Java Sound para programa√ß√£o, como linhas, mixers, formatos para dados de √°udio e muito mais. <br><br>  Vamos entender as rela√ß√µes existentes entre os objetos SourceDataLine, Clip, Mixer, AudioFormat e criar um programa simples que reproduz √°udio. <br><br>  Abaixo, apresentamos um exemplo deste programa, que voc√™ pode usar para gravar e reproduzir o som gravado. <br><br>  No futuro, forneceremos uma explica√ß√£o completa do c√≥digo do programa usado para esse fim.  Mas de maneira alguma completamente nesta li√ß√£o. <br><br><h3>  Exemplo de c√≥digo e considera√ß√£o </h3><br>  <b>Caracter√≠sticas f√≠sicas e el√©tricas do som anal√≥gico</b> <br><br>  O objetivo de nossa li√ß√£o √© apresentar o b√°sico da programa√ß√£o Java usando a API Java Sound. <br><br>  A API Java Sound √© baseada no conceito de um mixer de √°udio, que √© um dispositivo comumente usado para reproduzir som em quase qualquer lugar: de shows de rock a ouvir CDs em casa.  Por√©m, antes de iniciar uma explica√ß√£o detalhada da opera√ß√£o do mixer de √°udio, ser√° √∫til se familiarizar com as caracter√≠sticas f√≠sicas e el√©tricas do pr√≥prio som anal√≥gico. <br><br>  <i>Veja a Fig.</i>  <i>1</i> <br><br><img src="https://habrastorage.org/webt/ez/tu/sq/eztusq7byax0l9nu-5r6vj3vkxe.gif"><br><br>  Vasya Pupyrkin faz um discurso. <br><br>  Esta figura mostra Vasya fazendo um discurso usando um sistema conhecido como endere√ßo amplo.  Esse sistema normalmente inclui um microfone, amplificador e alto-falante.  O objetivo deste sistema √© fortalecer a voz de Vasya para que ele possa ser ouvido mesmo em uma grande multid√£o. <br><br>  <b>Oscile no ar</b> <br><br>  Resumidamente, quando Vasya fala, suas cordas vocais fazem com que as part√≠culas de ar vibrem em sua laringe.  Isso leva ao surgimento de ondas sonoras, que, por sua vez, fazem a membrana do microfone vibrar e depois se transformam em vibra√ß√µes el√©tricas de amplitude muito pequena que simulam exatamente as vibra√ß√µes sonoras do original de Vasya.  Um amplificador, como o pr√≥prio nome indica, amplifica essas vibra√ß√µes el√©tricas.  Ent√£o eles chegam ao alto-falante, que realiza a transforma√ß√£o inversa de vibra√ß√µes el√©tricas amplificadas em ondas sonoras muito amplificadas, mas que ainda assim repetem exatamente as mesmas ondas geradas nas cordas vocais de Vasya Pupyrkin. <br><br>  <b>Microfone din√¢mico</b> <br><br>  Agora vamos ver a Fig.  2, que mostra um diagrama esquem√°tico de um microfone chamado din√¢mico. <br><br><img src="https://habrastorage.org/webt/hz/1v/ui/hz1vui2-yqnq4cg3xdpi5iy-1w0.gif"><br>  <i>Fig.</i>  <i>2 circuito de microfone din√¢mico</i> <br><br>  <b>Vibra√ß√µes sonoras afetam a membrana</b> <br><br>  A press√£o das vibra√ß√µes sonoras atua sobre uma membrana flex√≠vel dentro do microfone.  Isso faz com que a membrana vibre, enquanto as vibra√ß√µes repetem as vibra√ß√µes das ondas sonoras. <br><br>  <b>Bobina m√≥vel</b> <br><br>  Uma bobina de fio fino √© presa √† membrana do microfone.  √Ä medida que a membrana oscila, a bobina tamb√©m faz movimentos alternativos no campo magn√©tico do n√∫cleo, feito de um forte √≠m√£ permanente.  E como Faraday tamb√©m estabeleceu, uma corrente el√©trica surge na bobina. <br><br>  <b>Um sinal el√©trico segue o formato das ondas sonoras.</b> <br><br>  Assim, a partir de uma corrente muito fraca induzida na bobina, √© obtido um sinal el√©trico alternado, repetindo a forma de ondas sonoras que atuam na membrana do microfone.  Al√©m disso, este sinal na forma de uma tens√£o alternada √© alimentado √† entrada do amplificador da Fig.  1 <br><br>  <b>Altifalante</b> <br><br>  De fato, o princ√≠pio de opera√ß√£o do alto-falante repete o dispositivo de um microfone din√¢mico, ligado apenas na dire√ß√£o oposta.  <i>(Naturalmente, neste caso, os fios do enrolamento s√£o muito mais grossos e a membrana √© muito maior para garantir a opera√ß√£o com um sinal amplificado)</i> <i><br></i> <br><br><img src="https://habrastorage.org/webt/0e/ec/4x/0eec4xwyiyp2icsx69azgymv78c.gif"><br><br>  As oscila√ß√µes da membrana do alto-falante afetam as part√≠culas de ar e criam ondas sonoras poderosas.  O formato dessas ondas repete exatamente o formato das ondas sonoras de intensidade muito mais baixa, criadas pelas cordas vocais de Vasya.  Mas a intensidade das novas ondas agora √© suficiente para garantir que as vibra√ß√µes sonoras de Vasya cheguem aos ouvidos das pessoas, mesmo nas fileiras de tr√°s de uma grande multid√£o. <br><br>  <b>Concerto de rock</b> <br><br>  A essa altura, voc√™ deve estar se perguntando o que tudo isso tem a ver com a Java Sound API?  Mas espere um pouco mais, estamos liderando o caminho para o b√°sico do mixer de √°udio. <br><br>  O circuito descrito acima foi bastante simples.  Consistia em Vasya Pupyrkin, um microfone, um amplificador e um alto-falante.  Agora considere o circuito com a Fig.  4, que apresenta o palco preparado para o show de rock do grupo musical iniciante. <br><br><img src="https://habrastorage.org/webt/jh/zh/qo/jhzhqouio0xa25axcr164jch4du.gif"><br><br>  <b>Seis microfones e dois alto-falantes</b> <br><br>  Na Fig.  4 seis microfones est√£o localizados no palco.  Dois alto-falantes (alto-falantes) est√£o localizados nas laterais do palco.  Quando o show come√ßa, os artistas cantam ou tocam m√∫sica em cada um dos seis microfones.  Conseq√ºentemente, teremos seis sinais el√©tricos, que devem ser amplificados individualmente e depois alimentados aos dois alto-falantes.  Al√©m disso, os artistas podem usar v√°rios efeitos especiais de som, por exemplo, reverb, que tamb√©m precisar√£o ser convertidos em sinais el√©tricos antes de aplic√°-los aos alto-falantes. <br><br>  Dois alto-falantes nas laterais do palco foram projetados para criar o efeito do som est√©reo.  Ou seja, o sinal el√©trico proveniente do microfone localizado no palco √† direita deve cair no alto-falante localizado tamb√©m √† direita.  Da mesma forma, o sinal do microfone para a esquerda deve ser alimentado ao alto-falante localizado √† esquerda da cena.  Mas os sinais el√©tricos de outros microfones localizados perto do centro do palco j√° devem ser transmitidos aos dois alto-falantes em propor√ß√µes apropriadas.  E dois microfones no centro devem transmitir o sinal para os dois alto-falantes igualmente. <br><br>  <b>Mixer de √°udio</b> <br><br>  A tarefa discutida acima √© realizada apenas por um dispositivo eletr√¥nico chamado mixer de √°udio. <br><br>  <b>Linha de √°udio (canal)</b> <br><br>  Embora o autor n√£o seja especialista em mixers de √°udio, em seu humilde entendimento, um mixador de √°udio t√≠pico tem a capacidade de receber na entrada um certo n√∫mero de sinais el√©tricos independentes uns dos outros, cada um dos quais representa o sinal de som ou a linha <i>(canal) original.</i> <br><br>  (O conceito de canal de √°udio se tornar√° muito importante quando come√ßarmos a entender a API Java Sound em detalhes. <br><br>  <b>Processamento independente de cada canal de √°udio</b> <br><br>  De qualquer forma, o mixer de √°udio padr√£o tem a capacidade de amplificar cada linha de √°udio independentemente dos outros canais.  Al√©m disso, o mixer geralmente tem a capacidade de impor efeitos especiais ao som, como, por exemplo, reverbera√ß√£o para qualquer uma das linhas de √°udio.  No final, o mixer, como o pr√≥prio nome indica, pode misturar todos os sinais el√©tricos individuais nos canais de sa√≠da conforme definido, de modo a controlar a contribui√ß√£o de cada linha de √°udio para os canais de sa√≠da (esse controle √© geralmente chamado de pan ou pan - distribui√ß√£o no espa√ßo). <br><br>  <b>Retornando ao som est√©reo</b> <br><br>  Assim, no diagrama da Fig.  4, o engenheiro de som do mixer de √°udio tem a capacidade de combinar sinais de seis microfones para obter dois sinais de sa√≠da, cada um dos quais √© transmitido ao seu alto-falante. <br><br>  Para uma opera√ß√£o bem-sucedida, o sinal de cada microfone deve ser fornecido na propor√ß√£o apropriada, dependendo da localiza√ß√£o f√≠sica do microfone no palco.  (Ao alterar o panorama, um engenheiro de som qualificado pode alterar a contribui√ß√£o de cada microfone, se necess√°rio, se, por exemplo, o vocalista principal se mover pelo palco durante um concerto). <br><br>  <b>Hora de voltar ao mundo da programa√ß√£o</b> <br><br>  Voltemos agora do mundo f√≠sico para o mundo da programa√ß√£o.  De acordo com a Sun: <i>‚ÄúO Java Sound n√£o envolve nenhuma configura√ß√£o especial de hardware;</i>  <i>Ele foi projetado para permitir que v√°rios componentes de √°udio sejam instalados no sistema e disponibilizados ao usu√°rio por meio da API.</i>  <i>O Java Sound suporta a funcionalidade padr√£o de entrada e sa√≠da de uma placa de som (por exemplo, para gravar e reproduzir arquivos de √°udio), al√©m da capacidade de misturar v√°rios fluxos de √°udio ‚Äù</i> <br><br>  <b>Misturadores e canais</b> <br><br>  Como j√° mencionado, a Java Sound API √© baseada no conceito de mixers e canais.  Se voc√™ passar do mundo f√≠sico para o mundo da programa√ß√£o, a Sun escrever√° o seguinte sobre o mixer: <br><br>  <i>‚ÄúUm mixer √© um dispositivo de √°udio com um ou mais canais.</i>  <i>Mas o mixer que realmente mistura o sinal de √°udio deve ter v√°rios canais de entrada de fontes de origem e pelo menos um canal de destino de sa√≠da ".</i> <br><br>  Linhas de entrada podem ser inst√¢ncias de classes com objetos SourceDataLine e linhas de sa√≠da podem ser objetos TargetDataLine.  O mixer tamb√©m pode receber som pr√©-gravado e em loop como uma entrada, definindo seus canais de origem de entrada como inst√¢ncias de objetos de classe que implementam a interface Clip. <br><br>  Interface de linha de canal. <br><br>  A Sun relata o seguinte na interface Line: ‚Äú <i>Line √© um elemento de um pipeline de √°udio digital, como uma porta de √°udio de entrada ou sa√≠da, mixer ou caminho de √°udio de ou para um mixer.</i>  <i>Os dados de √°udio que passam pelo canal podem ser mono ou multicanal (por exemplo, est√©reo).</i>  <i>... Um canal pode ter controles, como ganho, pan e reverb. ‚Äù</i> <br><br>  <b>Juntando os termos</b> <br><br>  Portanto, as cita√ß√µes acima da Sun denotam os seguintes termos <br><br>  Sourcedataline <br>  Targetgetataline <br>  Port <br>  Clip <br>  Controles <br><br>  <i>Fig.</i>  <i>5 mostra um exemplo do uso desses termos para criar um programa simples de sa√≠da de √°udio.</i> <br><br><img src="https://habrastorage.org/webt/e1/5r/gh/e15rghejgy0b2reeciyvircdvua.gif"><br><br>  <b>Script do programa</b> <br><br>  Do ponto de vista do software  5 mostra um objeto Mixer obtido com um objeto Clip e dois objetos SourceDataLine. <br><br>  <b>O que √© Clip</b> <br><br>  Clip √© um objeto na entrada do mixer, cujo conte√∫do n√£o muda com o tempo.  Em outras palavras, voc√™ carrega os dados de √°udio no objeto Clipe antes de reproduzi-los.  O conte√∫do de √°udio do objeto Clipe pode ser reproduzido uma ou mais vezes.  Voc√™ pode fazer um loopback do clipe e, em seguida, o conte√∫do ser√° reproduzido repetidamente. <br><br>  <b>Fluxo de entrada</b> <br><br>  O objeto SourceDataLine, por outro lado, √© um objeto de fluxo na entrada do misturador.  Um objeto desse tipo pode receber um fluxo de dados de √°udio e envi√°-lo para o mixer em tempo real.  Os dados de √°udio necess√°rios podem ser obtidos de v√°rias fontes, como arquivos de √°udio, conex√£o de rede ou buffer de mem√≥ria. <br><br>  <b>Diferentes tipos de canais</b> <br><br>  Portanto, os objetos Clip e SourceDataLine podem ser considerados como canais de entrada para o objeto Mixer.  Cada um desses canais de entrada pode ter seus pr√≥prios: panor√¢mica, ganho e reverb. <br><br>  <b>Reproduzir conte√∫do de √°udio</b> <br><br>  Em um sistema t√£o simples, o Mixer l√™ dados das linhas de entrada, usa o controle para misturar sinais de entrada e fornece sa√≠da para um ou mais canais de sa√≠da, como alto-falante, sa√≠da de linha, fone de ouvido e assim por diante. <br><br>  A Listagem 11 mostra um programa simples que captura dados de √°udio de uma porta de microfone, armazena esses dados na mem√≥ria e os reproduz pela porta do alto-falante. <br><br>  Discutiremos apenas captura e reprodu√ß√£o.  A maior parte do programa acima √© criar uma janela e uma interface gr√°fica para o usu√°rio, para que seja poss√≠vel controlar a grava√ß√£o e a reprodu√ß√£o.  N√£o discutiremos esta parte como indo al√©m da meta.  Mas ent√£o consideraremos a captura e reprodu√ß√£o de dados.  Discutiremos a perda nesta li√ß√£o e a captura na pr√≥xima.  Ao longo do caminho, ilustraremos o uso do canal de √°udio com a API Java Sound. <br><br>  Os dados capturados s√£o armazenados em um objeto ByteArrayOutputStream. <br><br>  Um trecho de c√≥digo fornece a leitura de dados de √°udio de um microfone e o armazenamento como um objeto ByteArrayOutputStream. <br><br>  O m√©todo, chamado playAudio, que come√ßa na Listagem 1, reproduz os dados de √°udio que foram capturados e armazenados no objeto ByteArrayOutputStream. <br><br><pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">playAudio</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> audioData[] = byteArrayOutputStream. toByteArray(); InputStream byteArrayInputStream = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ByteArrayInputStream( audioData);</code> </pre> <br>  <i>Listagem 1</i> <br><br>  <b>Come√ßamos com o c√≥digo padr√£o.</b> <br><br>  O snippet de programa na Listagem 1 ainda n√£o est√° relacionado ao Java Sound. <br><br>  Seu objetivo √©: <br><br><ul><li>  Converta dados salvos anteriormente em uma matriz do tipo byte. </li><li>  Obtenha o fluxo de entrada para uma matriz de dados de bytes. </li></ul><br>  Precisamos disso para disponibilizar dados de √°udio para reprodu√ß√£o posterior. <br><br>  <b>V√° para a API de som</b> <br><br>  A linha de c√≥digo na Listagem 2 j√° est√° relacionada √† API Java Sound. <br><br><pre> <code class="java hljs"> AudioFormat audioFormat = getAudioFormat();</code> </pre><br>  <i>Listagem 2</i> <br><br>  Aqui, abordaremos brevemente o t√≥pico, que ser√° discutido em detalhes na pr√≥xima li√ß√£o. <br><br>  <b>Dois formatos independentes</b> <br><br>  Na maioria das vezes, estamos lidando com dois formatos independentes para dados de √°udio. <br><br>  Formato de arquivo (qualquer) que cont√©m dados de √°udio (em nosso programa, ainda n√£o o √©, pois os dados s√£o armazenados na mem√≥ria) <br><br>  O formato dos dados de √°udio enviados √© por si s√≥. <br><br>  <b>O que √© um formato de √°udio?</b> <br><br>  Aqui est√° o que a Sun escreve sobre isso: <br><br>  <i>‚ÄúCada canal de dados tem seu pr√≥prio formato de √°udio associado ao seu fluxo de dados.</i>  <i>O formato (uma inst√¢ncia do AudioFormat) determina a ordem dos bytes do fluxo de √°udio.</i>  <i>Os par√¢metros de formato podem ser o n√∫mero de canais, a frequ√™ncia de amostragem, o bit de quantiza√ß√£o, o m√©todo de codifica√ß√£o, etc. Os m√©todos usuais de codifica√ß√£o podem ser a modula√ß√£o linear por c√≥digo de pulso do PCM e suas variantes. ‚Äù</i> <br><br>  <b>Sequ√™ncia de bytes</b> <br><br>  Os dados de √°udio de origem s√£o uma sequ√™ncia de bytes de dados bin√°rios.  Existem v√°rias op√ß√µes de como voc√™ pode organizar e interpretar essa sequ√™ncia.  N√£o come√ßaremos a lidar com todas essas op√ß√µes em detalhes, mas discutiremos um pouco o formato de √°udio que usamos aqui em nosso programa. <br><br>  <b>Pequena digress√£o</b> <br><br>  Aqui deixamos o m√©todo playAudio por enquanto e observamos o m√©todo getAudioFormat da Listagem 2. <br><br>  <i>O m√©todo getAudioFormat completo √© mostrado na Listagem 3.</i> <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> AudioFormat </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getAudioFormat</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sampleRate = <span class="hljs-number"><span class="hljs-number">8000.0F</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sampleSizeInBits = <span class="hljs-number"><span class="hljs-number">16</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> channels = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> signed = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> bigEndian = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AudioFormat( sampleRate, sampleSizeInBits, channels, signed, bigEndian); }<span class="hljs-comment"><span class="hljs-comment">//end getAudioFormat</span></span></code> </pre><br>  <i>Listagem 3</i> <br><br>  Al√©m de declarar vari√°veis ‚Äã‚Äãinicializadas, o c√≥digo na Listagem 3 cont√©m uma express√£o execut√°vel. <br><br>  <b>Objeto AudioFormat</b> <br><br>  O m√©todo getAudioFormat cria e retorna uma inst√¢ncia de um objeto da classe AudioFormat.  Aqui est√° o que a Sun escreve sobre esta classe: <br><br>  <i>‚ÄúA classe AudioFormat define a ordem espec√≠fica dos dados em um fluxo de √°udio.</i>  <i>Voltando aos campos do objeto AudioFormat, voc√™ pode obter informa√ß√µes sobre como interpretar corretamente os bits em um fluxo de dados bin√°rios. ‚Äù</i> <br><br>  <b>Usamos o construtor mais simples</b> <br><br>  A classe AudioFormat possui dois tipos de construtores (usaremos o mais trivial).  Os seguintes par√¢metros s√£o necess√°rios para este construtor: <br><br><ul><li>  Taxa de amostragem ou taxa de amostragem por segundo (valores dispon√≠veis: 8000, 11025, 16000, 22050 e 44100 amostras por segundo) </li><li>  Profundidade de bits dos dados (8 e 16 bits por contagem est√£o dispon√≠veis) </li><li>  N√∫mero de canais (um canal para mono e dois para est√©reo) </li><li>  Dados assinados ou n√£o assinados usados ‚Äã‚Äãno fluxo (por exemplo, o valor varia de 0 a 255 ou de -127 a +127) </li><li>  A ordem dos bytes de big endian ou little endian.  (se voc√™ estiver transmitindo valores de 16 bits por fluxo de bytes, √© importante saber qual byte vem primeiro - baixo ou alto, pois existem duas op√ß√µes). </li></ul><br>  Como voc√™ pode ver na Listagem 3, no nosso caso, usamos os seguintes par√¢metros para uma inst√¢ncia do objeto AudioFormat. <br><br><ul><li>  8000 amostras por segundo </li><li>  16 tamanho dos dados </li><li>  dados significativos </li><li>  Ordem little-endian </li></ul><br>  Por padr√£o, os dados s√£o codificados pelo PCM linear. <br><br>  O construtor que usamos cria uma inst√¢ncia do objeto AudioFormat usando modula√ß√£o linear por c√≥digo de pulso e os par√¢metros indicados acima (retornaremos ao PCM linear e outros m√©todos de codifica√ß√£o nas li√ß√µes a seguir) <br><br>  <b>Voltar ao m√©todo playAudio novamente</b> <br><br>  Agora que entendemos como o formato de dados de √°udio funciona no som Java, voltemos ao m√©todo playAudio.  Assim que queremos reproduzir os dados de √°udio dispon√≠veis, precisamos de um objeto da classe AudioInputStream.  Temos uma inst√¢ncia disso na Listagem 4. <br><br><pre> <code class="java hljs"> audioInputStream = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AudioInputStream( byteArrayInputStream, audioFormat, audioData.length/audioFormat. getFrameSize());</code> </pre><br>  <i>Listagem 4</i> <br><br>  <b>Par√¢metros para o construtor AudioInputStream</b> <br><br><ul><li>  O construtor para a classe AudioInputStream requer os tr√™s par√¢metros a seguir: </li><li>  O fluxo no qual a inst√¢ncia do objeto AudioInputStream ser√° baseada (como vemos para esse fim, usamos a inst√¢ncia do objeto ByteArrayInputStream criada anteriormente) </li><li>  O formato de dados de √°udio para este fluxo (para esse fim, j√° criamos uma inst√¢ncia do objeto AudioFormat) </li><li>  O tamanho do quadro (quadro) para os dados neste fluxo (veja a descri√ß√£o abaixo) </li><li>  Os dois primeiros par√¢metros s√£o claros no c√≥digo da Listagem 4. No entanto, o terceiro par√¢metro n√£o √© t√£o √≥bvio por si s√≥. </li></ul><br>  <b>Obter tamanho do quadro</b> <br><br>  Como podemos ver na Listagem 4, o valor do terceiro par√¢metro √© criado usando c√°lculos.  Este √© apenas um dos atributos do formato de √°udio que n√£o mencionamos anteriormente e √© chamado de quadro. <br><br>  <b>O que √© um quadro?</b> <br><br>  Para um PCM linear simples usado em nosso programa, o quadro cont√©m um conjunto de amostras para todos os canais em um determinado momento. <br><br>  Assim, o tamanho do quadro √© igual ao tamanho da contagem em bytes vezes o n√∫mero de canais. <br><br>  Como voc√™ deve ter adivinhado, um m√©todo chamado getFrameSize retorna o tamanho do quadro em bytes. <br><br>  <b>C√°lculo do tamanho do quadro</b> <br><br>  Assim, o comprimento dos dados de √°udio em um quadro pode ser calculado dividindo o n√∫mero total de bytes na sequ√™ncia de dados de √°udio pelo n√∫mero de bytes em um quadro.  Este c√°lculo √© usado para o terceiro par√¢metro na Listagem 4. <br><br>  <b>Obtendo um objeto SourceDataLine</b> <br><br>  A pr√≥xima parte do programa que discutiremos √© um sistema simples de sa√≠da de √°udio.  Como podemos ver no diagrama da Figura 5, para resolver esse problema, precisamos de um objeto SourceDataLine. <br><br>  Existem v√°rias maneiras de obter uma inst√¢ncia do objeto SourceDataLine, todas muito complicadas.  O c√≥digo na Listagem 5 recupera e armazena uma refer√™ncia a uma inst√¢ncia do objeto SourceDataLine. <br><br>  (Observe que esse c√≥digo n√£o apenas instancia o objeto SourceDataLine. Ele o obt√©m de maneira indireta.) <br><br><pre> <code class="java hljs"> DataLine.Info dataLineInfo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DataLine.Info( SourceDataLine.class, audioFormat); sourceDataLine = (SourceDataLine) AudioSystem.getLine( dataLineInfo);</code> </pre><br>  <i>Listagem 5</i> <br><br>  O que √© um objeto SourceDataLine? <br><br>  Sobre isso, a Sun escreve o seguinte: <br><br>  <i>‚ÄúSourceDataLine √© um canal de dados no qual os dados podem ser gravados.</i>  <i>Funciona como uma entrada para um mixer.</i>  <i>Um aplicativo grava uma sequ√™ncia de bytes em um SourceDataLine, que armazena em buffer os dados e os entrega ao seu misturador.</i>  <i>O mixer pode transmitir os dados que processa para o pr√≥ximo est√°gio, por exemplo, para a porta de sa√≠da.</i> <i><br><br></i>  <i>Observe que a conven√ß√£o de nomenclatura para esse emparelhamento reflete o relacionamento entre o canal e seu mixer. ‚Äù</i> <br><br>  <b>M√©todo GetLine para a classe AudioSystem</b> <br><br>  Uma maneira de obter uma inst√¢ncia do objeto SourceDataLine √© chamar o m√©todo est√°tico getLine da classe AudioSystem (teremos muito a relatar sobre isso nas pr√≥ximas li√ß√µes). <br><br>  O m√©todo getLine requer um par√¢metro de entrada do tipo Line.Info e retorna um objeto Line que corresponda √† descri√ß√£o no objeto Line.Info j√° definido. <br><br>  <b>Outra digress√£o curta</b> <br><br>  A Sun relata as seguintes informa√ß√µes sobre o objeto Line.Info: <br><br>  ‚ÄúO canal possui seu pr√≥prio objeto de informa√ß√£o (uma inst√¢ncia do Line.Info), que mostra qual mixer (se houver) envia os dados de √°udio misturados como sa√≠da diretamente para o canal e qual mixer (se houver) recebe os dados de √°udio como entrada diretamente do canal.  Variedades de Line podem corresponder √†s subclasses de Line.Info, que permitem especificar outros tipos de par√¢metros relacionados a tipos espec√≠ficos de canais ‚Äù <br><br>  <b>Objeto DataLine.Info</b> <br><br>  A primeira express√£o na Listagem 5 cria uma nova inst√¢ncia do objeto DataLine.Info, que √© um formul√°rio especial (subclasse) do objeto Line.Info. <br><br>  Existem v√°rios construtores sobrecarregados para a classe DataLine.Info.  N√≥s escolhemos o mais f√°cil de usar.  Este construtor requer dois par√¢metros. <br><br>  <b>Objeto de classe</b> <br><br>  O primeiro par√¢metro √© Class, que representa a classe que definimos como SourceDataLine.class <br><br>  O segundo par√¢metro determina o formato de dados desejado para o canal.  Utilizamos uma inst√¢ncia do objeto AudioFormat, que j√° foi definida anteriormente. <br><br>  <b>Onde j√° estamos?</b> <br><br>  Infelizmente, ainda n√£o temos o objeto SourceDataLine mais necess√°rio.  At√© o momento, temos um objeto que fornece apenas informa√ß√µes sobre o objeto SourceDataLine de que precisamos. <br><br>  <b>Obtendo um objeto SourceDataLine</b> <br><br>  A segunda express√£o na Listagem 5 finalmente cria e armazena a inst√¢ncia de SourceDataLine de que precisamos.  Isso acontece chamando o m√©todo est√°tico getLine da classe AudioSystem e passando dataLineInfo como par√¢metro.  (Na pr√≥xima li√ß√£o, veremos como obter o objeto Line, trabalhando diretamente com o objeto Mixer). <br><br>  O m√©todo getLine retorna uma refer√™ncia a um objeto do tipo Line, que √© o pai do SourceDataLine.  Portanto, √© necess√°rio um downcast aqui antes que o valor de retorno seja salvo como SourceDataLine. <br><br>  <b>Vamos nos preparar para usar o objeto SourceDataLine</b> <br><br>  Depois de obter uma inst√¢ncia do objeto SourceDataLine, precisamos prepar√°-la para abertura e execu√ß√£o, conforme mostrado na Listagem 6. <br><br><pre> <code class="java hljs"> sourceDataLine.open(audioFormat); sourceDataLine.start();</code> </pre><br>  <i>Listagem 6</i> <br><br>  <b>M√©todo de abertura</b> <br><br>  Como voc√™ pode ver na Listagem 6, enviamos o objeto AudioFormat ao m√©todo de abertura para o objeto SourceDataLine. <br><br>  Segundo a Sun, este √© um m√©todo: <br><br>  <i>"Abre uma linha (canal) com um formato definido anteriormente, permitindo que ele receba todos os recursos do sistema de que precisa e esteja em condi√ß√µes de trabalho"</i> <br><br>  <b>Estado de descoberta</b> <br><br>  H√° pouco mais que Sun escreve sobre ele neste t√≥pico. <br><br>  <i>‚ÄúAbrir e fechar o canal afeta a distribui√ß√£o dos recursos do sistema.</i>  <i>A abertura bem-sucedida do canal garante que todos os recursos necess√°rios sejam fornecidos ao canal.</i> <i><br><br></i>  <i>A abertura do mixer, que possui portas de entrada e sa√≠da para dados de √°udio, inclui, entre outras coisas, o hardware da plataforma na qual ocorre o trabalho e a inicializa√ß√£o dos componentes de software necess√°rios.</i> <i><br><br></i>  <i>A abertura de um canal, que √© uma rota para dados de √°udio de ou para um mixer, inclui tanto a inicializa√ß√£o quanto o recebimento de recursos ilimitados do mixer.</i>  <i>Em outras palavras, o mixer possui um n√∫mero finito de canais; portanto, v√°rios aplicativos com suas pr√≥prias necessidades de canal (e at√© mesmo um aplicativo) devem compartilhar corretamente os recursos do mixer) ‚Äù</i> <br><br>  <b>Chame o m√©todo start em um canal</b> <br><br>  De acordo com a Sun, chamar o m√©todo start para um canal significa o seguinte: <br><br>  <i>‚ÄúO canal pode usar linhas de E / S.</i>  <i>Se for feita uma tentativa de usar uma linha j√° em opera√ß√£o, o m√©todo n√£o far√° nada.</i>  <i>Mas, depois que o buffer de dados estiver vazio, a linha retoma a E / S inicial, iniciando no primeiro quadro que n√£o conseguiu processar ap√≥s o carregamento completo do buffer. ‚Äù</i> <br><br>  No nosso caso, √© claro, o canal n√£o parou.  Desde que o lan√ßamos pela primeira vez. <br><br>  <b>Agora temos quase tudo o que precisamos</b> <br><br>  Nesse ponto, recebemos todos os recursos de √°udio necess√°rios para reproduzir os dados de √°udio que gravamos e armazenados anteriormente na inst√¢ncia do objeto ByteArrayOutputStream.  (Lembre-se de que esse objeto existe apenas na RAM do computador). <br><br>  <b>Come√ßamos fluxos</b> <br><br>  Criaremos e iniciaremos o fluxo para reproduzir o √°udio.  O c√≥digo na Listagem 7 cria e inicia esse encadeamento. <br><br>  (N√£o confunda a chamada para o m√©todo start neste encadeamento com a chamada para o m√©todo start no objeto SourceDataLine da Listagem 6. Essas s√£o opera√ß√µes completamente diferentes) <br><br><pre> <code class="java hljs">Thread playThread = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PlayThread()); playThread.start(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) { System.out.println(e); System.exit(<span class="hljs-number"><span class="hljs-number">0</span></span>); }<span class="hljs-comment"><span class="hljs-comment">//end catch }//end playAudio</span></span></code> </pre><br>  <i>Listagem 7</i> <br><br>  <b>C√≥digo despretensioso</b> <br><br>  O snippet do programa na Listagem 7, embora muito simples, mostra um exemplo de programa√ß√£o multithread em Java.  Se voc√™ n√£o o entende, deve se familiarizar com este t√≥pico em t√≥picos especializados para aprender Java. <br><br>  Uma vez iniciado o fluxo, ele funcionar√° at√© que todos os dados de √°udio pr√©-gravados sejam reproduzidos at√© o fim. <br><br>  <b>Novo objeto de thread</b> <br><br>  O c√≥digo na Listagem 7 cria uma inst√¢ncia do objeto Thread da classe PlayThread.  Essa classe √© definida como uma classe interna em nosso programa.  Sua descri√ß√£o come√ßa na Listagem 8. <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PlayThread</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Thread</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> tempBuffer[] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[<span class="hljs-number"><span class="hljs-number">10000</span></span>];</code> </pre><br>  <i>Listagem 8</i> <br><br>  <b>O m√©todo run na classe Thread</b> <br><br>  Exceto para declarar uma vari√°vel tempBuffer (que se refere a uma matriz de bytes), uma defini√ß√£o completa dessa classe √© apenas uma defini√ß√£o do m√©todo run.  Como voc√™ j√° deve saber, chamar o m√©todo start em um objeto Thread faz com que o m√©todo run deste objeto seja executado <br><br>  O m√©todo de execu√ß√£o para esse encadeamento come√ßa na Listagem 9. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cnt; <span class="hljs-comment"><span class="hljs-comment">//  //    -1 // while((cnt = audioInputStream. read(tempBuffer, 0, tempBuffer.length)) != -1){ if(cnt &gt; 0){ //   //    //    //   . sourceDataLine.write( tempBuffer, 0, cnt); }//end if }//end while</span></span></code> </pre><br>  <i>Listagem 9</i> <br><br>  <b>A primeira parte do fragmento de programa no m√©todo run</b> <br><br>  O m√©todo run cont√©m duas partes importantes, a primeira das quais √© mostrada na Listagem 9. <br><br>  Em suma, um loop √© usado aqui para ler dados de √°udio de um AudioInputStream e pass√°-los para um SourceDataLine. <br><br>  Os dados enviados para o objeto SourceDataLine s√£o automaticamente transferidos para a sa√≠da de √°udio padr√£o.  Pode ser um alto-falante do computador embutido ou uma sa√≠da de linha.  (Aprenderemos a determinar os dispositivos de som necess√°rios nas li√ß√µes a seguir).  A vari√°vel cnt e o buffer de dados tempBuffer s√£o usados ‚Äã‚Äãpara controlar o fluxo de dados entre as opera√ß√µes de leitura e grava√ß√£o. <br><br>  <b>Lendo dados do AudioInputStream</b> <br><br>  O ciclo de leitura do objeto AudioInputStream l√™ o n√∫mero m√°ximo especificado de bytes de dados do AudioInputStream e coloca sua matriz de bytes. <br><br>  <b>Valor de retorno</b> <br><br>  Al√©m disso, esse m√©todo retorna o n√∫mero total de bytes lidos, ou -1, se o final da sequ√™ncia gravada foi atingido.  O n√∫mero de bytes lidos √© armazenado na vari√°vel cnt. <br><br>  <b>Loop de grava√ß√£o SourceDataLine</b> <br><br>  Se o n√∫mero de bytes lidos for maior que zero, haver√° uma transi√ß√£o para o ciclo de grava√ß√£o de dados no SourceDataLine.  Nesse loop, os dados de √°udio entram no mixer.  Os bytes s√£o lidos da matriz de bytes de acordo com seus √≠ndices e gravados no buffer do canal. <br><br>  <b>Quando o fluxo de entrada seca</b> <br><br>  Quando o loop de leitura retorna -1, isso significa que todos os dados de √°udio gravados anteriormente terminaram e um controle adicional √© passado para o fragmento do programa na Listagem 10. <br><br><pre> <code class="java hljs"> sourceDataLine.drain(); sourceDataLine.close(); }<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) { System.out.println(e); System.exit(<span class="hljs-number"><span class="hljs-number">0</span></span>); }<span class="hljs-comment"><span class="hljs-comment">//end catch }//end run }//   PlayThread</span></span></code> </pre><br>  <i>Listagem 10</i> <br><br>  <b>Bloquear e esperar</b> <br><br>  O c√≥digo na Listagem 10 chama o m√©todo de drenagem no objeto SourceDataLine para que o programa possa bloquear e aguardar o buffer interno esvaziar no SourceDataLine.  Quando o buffer est√° vazio, significa que a pr√≥xima parte inteira √© entregue √† sa√≠da de som do computador. <br><br>  <b>Fechando SourceDataLine</b> <br><br>  Em seguida, o programa chama o m√©todo close para fechar o canal, mostrando assim que todos os recursos do sistema usados ‚Äã‚Äãpelo canal agora est√£o livres.  A Sun relata o seguinte fechamento de canal: <br><br>  <i>‚ÄúFechar o canal sinaliza que todos os recursos envolvidos nesse canal podem ser liberados.</i>  <i>Para liberar recursos, o aplicativo deve fechar os canais, se eles j√° est√£o envolvidos ou n√£o, e quando o aplicativo termina.</i>  <i>Sup√µe-se que os misturadores compartilhem recursos do sistema e possam ser fechados e abertos repetidamente.</i>  <i>Outros canais podem ou n√£o suportar a reabertura ap√≥s o fechamento.</i>  <i>Em geral, os mecanismos para abertura de linhas variam de acordo com diferentes subtipos. ‚Äù</i> <br><br>  <b>E agora o fim da hist√≥ria</b> <br><br>  Ent√£o, aqui, explicamos como nosso programa usa a API Java Sound para garantir a entrega de dados de √°udio da mem√≥ria interna do computador para a placa de som. <br><br>  <b>Execute o programa</b> <br><br>  Agora voc√™ pode compilar e executar o programa da Listagem 11, que termina no final de nossa li√ß√£o. <br><br>  <b>Capturar e reproduzir dados de √°udio</b> <br><br>  O programa demonstra a capacidade de gravar dados de um microfone e reproduzi-los atrav√©s da placa de som do seu computador.  Instru√ß√µes para us√°-lo s√£o muito simples. <br><br>  Execute o programa.  A GUI simples, mostrada na Figura 6, deve aparecer na tela. <br><br><img src="https://habrastorage.org/webt/lf/7l/ew/lf7lew65yqcqstjqvdvmptmhevy.gif"><br><br><ul><li>  Clique no bot√£o Capturar e grave qualquer som no microfone. </li><li>  Clique no bot√£o Parar para parar a grava√ß√£o. </li><li>  Clique no bot√£o Reproduzir para reproduzir a grava√ß√£o atrav√©s da sa√≠da de som do seu computador. </li></ul><br>  Se voc√™ n√£o ouvir nada, tente aumentar a sensibilidade do microfone ou o volume do alto-falante. <br><br>  O programa salva um registro na mem√≥ria do computador, portanto, tenha cuidado.  Se voc√™ tentar salvar muitos dados de √°udio, poder√° ficar sem mem√≥ria RAM. <br><br>  <b>Conclus√£o</b> <br><br><ul><li>  Descobrimos que a API Java Sound √© baseada no conceito de canais e mixers. </li><li>  Recebemos informa√ß√µes iniciais sobre as caracter√≠sticas f√≠sicas e el√©tricas do som anal√≥gico, para que pud√©ssemos entender o dispositivo do mixer de √°udio. </li><li>  Utilizamos um cen√°rio de show de rock amador usando seis microfones e dois alto-falantes est√©reo para descrever a possibilidade de usar um mixer de √°udio. </li><li>  Discutimos v√°rios t√≥picos de programa√ß√£o do Java Sound, incluindo mixers, canais, formato de dados e muito mais. </li><li>  Explicamos o relacionamento geral entre os objetos SourceDataLine, Clip, Mixer, AudioFormat e portas em um programa simples para a sa√≠da de dados de √°udio. </li><li>  N√≥s nos familiarizamos com um programa que nos permite gravar inicialmente e depois reproduzir dados de √°udio. </li><li>  Recebemos uma explica√ß√£o detalhada do c√≥digo usado para reproduzir dados de √°udio gravados anteriormente na mem√≥ria do computador. </li></ul><br>  <b>O que vem a seguir?</b> <br><br>  Neste tutorial, descobrimos que a API Java Sound √© baseada no conceito de mixers e canais.  No entanto, o c√≥digo que discutimos n√£o inclu√≠a misturadores explicitamente.  A classe AudioSystem nos forneceu m√©todos est√°ticos que possibilitam gravar programas de processamento de √°udio sem acessar diretamente os mixers.  Em outras palavras, esses m√©todos est√°ticos nos afastam os misturadores. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Na pr√≥xima li√ß√£o, apresentamos um c√≥digo de captura de dados modificado em compara√ß√£o com o apresentado nesta li√ß√£o. </font><font style="vertical-align: inherit;">A nova vers√£o usar√° explicitamente os misturadores para mostrar como us√°-los quando voc√™ realmente precisar deles.</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> javax.swing.*; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.awt.*; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.awt.event.*; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.*; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> javax.sound.sampled.*; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AudioCapture01</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JFrame</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> stopCapture = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; ByteArrayOutputStream byteArrayOutputStream; AudioFormat audioFormat; TargetDataLine targetDataLine; AudioInputStream audioInputStream; SourceDataLine sourceDataLine; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( String args[])</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AudioCapture01(); }<span class="hljs-comment"><span class="hljs-comment">//end main public AudioCapture01(){ final JButton captureBtn = new JButton("Capture"); final JButton stopBtn = new JButton("Stop"); final JButton playBtn = new JButton("Playback"); captureBtn.setEnabled(true); stopBtn.setEnabled(false); playBtn.setEnabled(false); captureBtn.addActionListener( new ActionListener(){ public void actionPerformed( ActionEvent e){ captureBtn.setEnabled(false); stopBtn.setEnabled(true); playBtn.setEnabled(false); //  //   //   Stop captureAudio(); } } ); getContentPane().add(captureBtn); stopBtn.addActionListener( new ActionListener(){ public void actionPerformed( ActionEvent e){ captureBtn.setEnabled(true); stopBtn.setEnabled(false); playBtn.setEnabled(true); //  //    stopCapture = true; } } ); getContentPane().add(stopBtn); playBtn.addActionListener( new ActionListener(){ public void actionPerformed( ActionEvent e){ //  //    playAudio(); } } ); getContentPane().add(playBtn); getContentPane().setLayout( new FlowLayout()); setTitle("Capture/Playback Demo"); setDefaultCloseOperation( EXIT_ON_CLOSE); setSize(250,70); setVisible(true); } //    //     //   ByteArrayOutputStream private void captureAudio(){ try{ //    audioFormat = getAudioFormat(); DataLine.Info dataLineInfo = new DataLine.Info( TargetDataLine.class, audioFormat); targetDataLine = (TargetDataLine) AudioSystem.getLine( dataLineInfo); targetDataLine.open(audioFormat); targetDataLine.start(); //     //    //   //    Thread captureThread = new Thread( new CaptureThread()); captureThread.start(); } catch (Exception e) { System.out.println(e); System.exit(0); } } //    // ,    //  ByteArrayOutputStream private void playAudio() { try{ //  //  byte audioData[] = byteArrayOutputStream. toByteArray(); InputStream byteArrayInputStream = new ByteArrayInputStream( audioData); AudioFormat audioFormat = getAudioFormat(); audioInputStream = new AudioInputStream( byteArrayInputStream, audioFormat, audioData.length/audioFormat. getFrameSize()); DataLine.Info dataLineInfo = new DataLine.Info( SourceDataLine.class, audioFormat); sourceDataLine = (SourceDataLine) AudioSystem.getLine( dataLineInfo); sourceDataLine.open(audioFormat); sourceDataLine.start(); //    //     //     //      Thread playThread = new Thread(new PlayThread()); playThread.start(); } catch (Exception e) { System.out.println(e); System.exit(0); } } //     //  AudioFormat private AudioFormat getAudioFormat(){ float sampleRate = 8000.0F; //8000,11025,16000,22050,44100 int sampleSizeInBits = 16; //8,16 int channels = 1; //1,2 boolean signed = true; //true,false boolean bigEndian = false; //true,false return new AudioFormat( sampleRate, sampleSizeInBits, channels, signed, bigEndian); } //===================================// //    //    class CaptureThread extends Thread{ byte tempBuffer[] = new byte[10000]; public void run(){ byteArrayOutputStream = new ByteArrayOutputStream(); stopCapture = false; try{ while(!stopCapture){ int cnt = targetDataLine.read( tempBuffer, 0, tempBuffer.length); if(cnt &gt; 0){ //     byteArrayOutputStream.write( tempBuffer, 0, cnt); } } byteArrayOutputStream.close(); }catch (Exception e) { System.out.println(e); System.exit(0); } } } //===================================// //   //     class PlayThread extends Thread{ byte tempBuffer[] = new byte[10000]; public void run(){ try{ int cnt; //     -1 while((cnt = audioInputStream. read(tempBuffer, 0, tempBuffer.length)) != -1){ if(cnt &gt; 0){ //    //   //    //    sourceDataLine.write( tempBuffer, 0, cnt); } } sourceDataLine.drain(); sourceDataLine.close(); }catch (Exception e) { System.out.println(e); System.exit(0); } } } //===================================// }//end outer class AudioCapture01.java</span></span></code> </pre><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Listagem 11</font></font></i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt434424/">https://habr.com/ru/post/pt434424/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt434412/index.html">Remo√ß√£o de foguetes antes do lan√ßamento no Vostochny</a></li>
<li><a href="../pt434414/index.html">Iceberg</a></li>
<li><a href="../pt434416/index.html">Leia em f√©rias. As melhores postagens em nosso blog para 2018</a></li>
<li><a href="../pt434418/index.html">Mais r√°pido, mais alto, mais brilhante: a f√≠sica de acasalar os beija-flores ‚Äúdan√ßando‚Äù</a></li>
<li><a href="../pt434422/index.html">Coisas n√£o rent√°veis</a></li>
<li><a href="../pt434426/index.html">Lista de verifica√ß√£o: como enviar relat√≥rios sobre o sistema tribut√°rio simplificado para 2018</a></li>
<li><a href="../pt434428/index.html">Montamos, reparamos e usamos um rel√≥gio digital vintage</a></li>
<li><a href="../pt434430/index.html">A IBM mostrou um chip de mem√≥ria anal√≥gica de mudan√ßa de fase de 8 bits</a></li>
<li><a href="../pt434440/index.html">[V√≠deo] Navios de guerra, bots e dinheiro atirando em servidores</a></li>
<li><a href="../pt434442/index.html">Cosmon√°utica 2018 - resultados do ano</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>