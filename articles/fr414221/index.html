<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üö¥üèø üì£ üíÉüèª Analyser et travailler avec Codable dans Swift 4 üë®‚Äçüë®‚Äçüëß üë®üèæ‚Äç‚úàÔ∏è ‚ò£Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Le format JSON a gagn√© en popularit√©, il est g√©n√©ralement utilis√© pour le transfert de donn√©es et l'ex√©cution de requ√™tes dans les applications client...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Analyser et travailler avec Codable dans Swift 4</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/414221/"><img src="https://habrastorage.org/webt/ps/2a/r0/ps2ar08o0byyxycknlktyhdafoq.jpeg"><br><br>  Le format JSON a gagn√© en popularit√©, il est g√©n√©ralement utilis√© pour le transfert de donn√©es et l'ex√©cution de requ√™tes dans les applications client-serveur.  L'analyse JSON n√©cessite des outils d'encodage / d√©codage de ce format, et Apple les a r√©cemment mis √† jour.  Dans cet article, nous examinerons les m√©thodes d'analyse JSON √† l'aide du protocole <i>Decodable</i> , comparerons le nouveau protocole <i>Codable</i> avec le pr√©d√©cesseur <i>NSCoding</i> , √©valuerons les avantages et les inconv√©nients, analyserons tout avec des exemples sp√©cifiques et examinerons √©galement certaines des fonctionnalit√©s rencontr√©es lors de la mise en ≈ìuvre des protocoles. <br><a name="habracut"></a><br><br>  <b>Qu'est-ce que Codable?</b> <br><br>  Lors de la WWDC2017, avec la nouvelle version de Swift 4, Apple a introduit de nouveaux outils de codage / d√©codage des donn√©es qui sont mis en ≈ìuvre par les trois protocoles suivants: <br><br>  - <b>Codable</b> <br>  - <b>Encodable</b> <br>  - <b>D√©codable</b> <br><br>  Dans la plupart des cas, ces protocoles sont utilis√©s pour fonctionner avec JSON, mais en plus, ils sont √©galement utilis√©s pour enregistrer des donn√©es sur le disque, les transf√©rer sur le r√©seau, etc.  Encodable est utilis√© pour convertir les structures de donn√©es Swift en objets JSON, tandis que Decodable, au contraire, aide √† convertir les objets JSON en mod√®les de donn√©es Swift.  Le protocole Codable combine les deux pr√©c√©dents et est leur typealias: <br><br><pre><code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">typealias</span></span> <span class="hljs-type"><span class="hljs-type">Codable</span></span> = <span class="hljs-type"><span class="hljs-type">Encodable</span></span> &amp; <span class="hljs-type"><span class="hljs-type">Decodable</span></span></code> </pre> <br><br>  Pour se conformer √† ces protocoles, les types de donn√©es doivent impl√©menter les m√©thodes suivantes: <br><br>  <i>Encodable</i> <br>  encode (to :) - encode le mod√®le de donn√©es dans le type d'encodeur donn√© <br><br>  <i>D√©codable</i> <br>  init (from :) - initialise le mod√®le de donn√©es √† partir du d√©codeur fourni <br><br>  <i>Codable</i> <br>  encoder (√† :) <br>  init (de :) <br><br>  <b>Un cas d'utilisation simple</b> <br><br>  Consid√©rons maintenant un exemple simple d'utilisation de <i>Codable</i> , car il impl√©mente √† la fois <i>Encodable</i> et <i>Decodable</i> , dans cet exemple, vous pouvez imm√©diatement voir toutes les fonctionnalit√©s du protocole.  Disons que nous avons la structure de donn√©es JSON la plus simple: <br><br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"title"</span></span>: <span class="hljs-string"><span class="hljs-string">"Nike shoes"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"price"</span></span>: <span class="hljs-number"><span class="hljs-number">10.5</span></span>, <span class="hljs-attr"><span class="hljs-attr">"quantity"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }</code> </pre> <br><br>  Le mod√®le de donn√©es pour travailler avec ce JSON ressemblera √† ceci: <br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Product</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Codable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> title:<span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> price:<span class="hljs-type"><span class="hljs-type">Double</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> quantity:<span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CodingKeys</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CodingKey</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> title <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> price <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> quantity } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">encode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(to encoder: Encoder)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">throws</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> container = encoder.container(keyedBy: <span class="hljs-type"><span class="hljs-type">CodingKeys</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> container.encode(title, forKey: .title) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> container.encode(price, forKey: .price) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> container.encode(quantity, forKey: .quantity) } <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(from decoder: <span class="hljs-type"><span class="hljs-type">Decoder</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throws</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> container = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> decoder.container(keyedBy: <span class="hljs-type"><span class="hljs-type">CodingKeys</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) title = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> container.decode(<span class="hljs-type"><span class="hljs-type">String</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, forKey: .title) price = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> container.decode(<span class="hljs-type"><span class="hljs-type">Double</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, forKey: .price) quantity = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> container.decode(<span class="hljs-type"><span class="hljs-type">Int</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, forKey: .quantity) } }</code> </pre><br><br>  Les deux m√©thodes n√©cessaires sont impl√©ment√©es, l'√©num√©ration est √©galement d√©crite pour d√©terminer la liste des champs de codage / d√©codage.  En fait, l'√©criture peut √™tre grandement simplifi√©e car <i>Codable</i> prend en charge la <i>g√©n√©ration</i> automatique des m√©thodes d'encodage (to :) et init (from :), ainsi que l'√©num√©ration n√©cessaire.  Autrement dit, dans ce cas, vous pouvez √©crire la structure comme suit: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Product</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Codable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> title:<span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> price:<span class="hljs-type"><span class="hljs-type">Double</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> quantity:<span class="hljs-type"><span class="hljs-type">Int</span></span> }</code> </pre> <br><br>  Extr√™mement simple et minimaliste.  Seulement, n'oubliez pas qu'un tel enregistrement concis ne fonctionnera pas si: <br><br>  - la <i>structure de votre mod√®le de donn√©es est diff√©rente de celle que vous souhaitez encoder / d√©coder</i> <br><br>  - <i>vous devrez peut-√™tre coder / d√©coder des propri√©t√©s suppl√©mentaires en plus des propri√©t√©s de votre mod√®le de donn√©es</i> <br><br>  - <i>Certaines propri√©t√©s de votre mod√®le de donn√©es peuvent ne pas prendre en charge le protocole Codable.</i>  <i>Dans ce cas, vous devrez les convertir de / vers le protocole codable</i> <br><br>  - <i>au cas o√π les noms de variables dans le mod√®le de donn√©es et les noms de champs dans le conteneur ne vous correspondent pas</i> <br><br>  Puisque nous avons d√©j√† consid√©r√© la d√©finition la plus simple d'un mod√®le de donn√©es, il convient de donner un petit exemple de son utilisation pratique: <br><br>  Ainsi, en une seule ligne, vous pouvez analyser la r√©ponse du serveur au format JSON: <br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> product: <span class="hljs-type"><span class="hljs-type">Product</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>! <span class="hljs-type"><span class="hljs-type">JSONDecoder</span></span>().decode(<span class="hljs-type"><span class="hljs-type">Product</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: data)</code> </pre> <br><br>  Et le code suivant, au contraire, cr√©era un objet JSON √† partir du mod√®le de donn√©es: <br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> productObject = <span class="hljs-type"><span class="hljs-type">Product</span></span>(title: <span class="hljs-string"><span class="hljs-string">"Cheese"</span></span>, price: <span class="hljs-number"><span class="hljs-number">10.5</span></span>, quantity: <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> encodedData = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>? <span class="hljs-type"><span class="hljs-type">JSONEncoder</span></span>().encode(productObject)</code> </pre> <br><br>  Tout est tr√®s pratique et rapide.  <i>Apr√®s avoir</i> correctement d√©crit les mod√®les de donn√©es et les avoir <i>cod√©s</i> , vous pouvez litt√©ralement encoder / d√©coder les donn√©es sur une seule ligne.  Mais nous avons consid√©r√© le mod√®le de donn√©es le plus simple contenant un petit nombre de champs d'un type simple.  Consid√©rez les probl√®mes possibles: <br><br>  <b>Tous les champs du mod√®le de donn√©es ne sont pas codables.</b> <br><br>  Pour que votre mod√®le de donn√©es impl√©mente le protocole <i>codable,</i> tous les champs du mod√®le doivent prendre en charge ce protocole.  Par d√©faut, le protocole <i>codable</i> prend en charge les types de donn√©es suivants: <i>cha√Æne, entier, double, donn√©es, URL</i> .  <i>Codable</i> prend √©galement en charge <i>Array, Dictionary, Optional</i> , mais uniquement s'ils contiennent des types <i>Codable</i> .  Si certaines propri√©t√©s du mod√®le de donn√©es ne correspondent pas √† <i>Codable</i> , elles doivent y √™tre apport√©es. <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pet</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Codable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> name: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> age: <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> type: <span class="hljs-type"><span class="hljs-type">PetType</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CodingKeys</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CodingKey</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> name <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> age <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> type } <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(from decoder: <span class="hljs-type"><span class="hljs-type">Decoder</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throws</span></span> { . . . } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">encode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(to encoder: Encoder)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">throws</span></span> { . . . } }</code> </pre> <br><br>  Si dans notre <i>mod√®le de</i> donn√©es <i>codables</i> nous utilisons un type personnalis√©, par exemple, comme <i>PetType</i> , et que nous voulons le coder / d√©coder, alors il doit √©galement impl√©menter son init et son encodage. <br><br>  <b>Le mod√®le de donn√©es ne correspond pas aux champs JSON</b> <br><br>  Si, dans votre mod√®le de donn√©es, 3 champs sont d√©finis, par exemple, et dans l'objet JSON, vous obtenez 5 champs, dont 2 suppl√©mentaires √† ces 3, alors rien ne changera dans l'analyse, vous en retirerez simplement vos 3 champs 5. Si l'inverse se produit situation et dans l'objet JSON il y aura au moins un champ du mod√®le de donn√©es, une erreur d'ex√©cution se produira. <br>  Si certains champs peuvent √™tre facultatifs et p√©riodiquement absents dans un objet JSON, alors dans ce cas, il est n√©cessaire de les rendre facultatifs: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Product</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Codable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> id: <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> productTypeId: <span class="hljs-type"><span class="hljs-type">Int?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> art: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> title: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> description: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> price: <span class="hljs-type"><span class="hljs-type">Double</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> currencyId: <span class="hljs-type"><span class="hljs-type">Int?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> brandId: <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> brand: <span class="hljs-type"><span class="hljs-type">Brand?</span></span> }</code> </pre> <br><br>  <b>Utilisation de structures JSON plus complexes</b> <br><br>  Souvent, la r√©ponse du serveur est un tableau d'entit√©s, c'est-√†-dire que vous demandez, par exemple, une liste de magasins et obtenez une r√©ponse sous la forme: <br><br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"items"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">"title"</span></span>: <span class="hljs-string"><span class="hljs-string">" "</span></span>, <span class="hljs-attr"><span class="hljs-attr">"link"</span></span>: <span class="hljs-string"><span class="hljs-string">"https://www.youtube.com/watch?v=Myp6rSeCMUw"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"created_at"</span></span>: <span class="hljs-number"><span class="hljs-number">1497868174</span></span>, <span class="hljs-attr"><span class="hljs-attr">"previewImage"</span></span>: <span class="hljs-string"><span class="hljs-string">"http://img.youtube.com/vi/Myp6rSeCMUw/mqdefault.jpg"</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">"title"</span></span>: <span class="hljs-string"><span class="hljs-string">"  2"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"link"</span></span>: <span class="hljs-string"><span class="hljs-string">"https://www.youtube.com/watch?v=wsCEuNJmvd8"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"created_at"</span></span>: <span class="hljs-number"><span class="hljs-number">1525952040</span></span>, <span class="hljs-attr"><span class="hljs-attr">"previewImage"</span></span>: <span class="hljs-string"><span class="hljs-string">"http://img.youtube.com/vi/wsCEuNJmvd8/mqdefault.jpg"</span></span> } ] }</code> </pre><br>  Dans ce cas, vous pouvez l'√©crire et le d√©coder simplement comme un tableau d'entit√©s <i>Shop</i> . <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ShopListResponse</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Decodable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CodingKeys</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CodingKey</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> items } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> items: [<span class="hljs-type"><span class="hljs-type">Shop</span></span>] }</code> </pre> <br><br>  Dans cet exemple, la fonction automatique <i>init</i> fonctionnera, mais si vous voulez √©crire le d√©codage vous-m√™me, vous devrez sp√©cifier le type d√©cod√© sous forme de tableau: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.items = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> container.decode([<span class="hljs-type"><span class="hljs-type">Shop</span></span>].<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, forKey: .items)</code> </pre> <br><br>  La structure <i>Shop</i> devrait √©galement impl√©menter le protocole <i>Decodable</i> , <i>respectivement.</i> <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Shop</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Decodable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> id: <span class="hljs-type"><span class="hljs-type">Int?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> title: <span class="hljs-type"><span class="hljs-type">String?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> address: <span class="hljs-type"><span class="hljs-type">String?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shortAddress: <span class="hljs-type"><span class="hljs-type">String?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> createdAt: <span class="hljs-type"><span class="hljs-type">Date?</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CodingKeys</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CodingKey</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> id <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> title <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> address <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> shortAddress = <span class="hljs-string"><span class="hljs-string">"short_address"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> createdAt = <span class="hljs-string"><span class="hljs-string">"created_at"</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(from decoder: <span class="hljs-type"><span class="hljs-type">Decoder</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throws</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> container = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> decoder.container(keyedBy: <span class="hljs-type"><span class="hljs-type">CodingKeys</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.id = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>? container.decode(<span class="hljs-type"><span class="hljs-type">Int</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, forKey: .id) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.title = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>? container.decode(<span class="hljs-type"><span class="hljs-type">String</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, forKey: .title) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.address = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>? container.decode(<span class="hljs-type"><span class="hljs-type">String</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, forKey: .address) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.shortAddress = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>? container.decode(<span class="hljs-type"><span class="hljs-type">String</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, forKey: .shortAddress) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.createdAt = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>? container.decode(<span class="hljs-type"><span class="hljs-type">Date</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, forKey: .createdAt) } }</code> </pre> <br><br>  L'analyse de ce tableau d'√©l√©ments ressemblera √† ceci: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> parsedResult: <span class="hljs-type"><span class="hljs-type">ShopListResponse</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>? <span class="hljs-type"><span class="hljs-type">JSONDecoder</span></span>().decode(<span class="hljs-type"><span class="hljs-type">ShopListResponse</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, from: data)</code> </pre> <br><br>  Ainsi, vous pouvez facilement travailler avec des tableaux de mod√®les de donn√©es et les utiliser dans d'autres mod√®les. <br><br>  <b>Format de date</b> <br><br>  Dans cet exemple, il y a une nuance de plus, ici nous avons rencontr√© pour la premi√®re fois l'utilisation du type <i>Date</i> .  Lorsque vous utilisez ce type, il peut y avoir des probl√®mes avec le codage de la date, et g√©n√©ralement ce probl√®me est coh√©rent avec le backend.  Le format par d√©faut est <i>.deferToDate</i> : <br><br><pre> <code class="hljs vbscript">struct MyDate : Encodable { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> myDate = MyDate(<span class="hljs-built_in"><span class="hljs-built_in">date</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>()) try! encoder.encode(foo)</code> </pre> <br><br>  <i>myDate</i> ressemblera √† ceci: <br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"date"</span></span> : <span class="hljs-number"><span class="hljs-number">519751611.12542897</span></span> }</code> </pre> <br><br>  Si nous devons utiliser, par exemple, le format <i>.iso8601</i> , nous pouvons facilement changer le format en utilisant la propri√©t√© <i>dateEncodingStrategy</i> : <br><br><pre> <code class="hljs">encoder.dateEncodingStrategy = .iso8601</code> </pre> <br><br>  Maintenant, la date ressemblera √† ceci: <br><br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"date"</span></span> : <span class="hljs-string"><span class="hljs-string">"2017-06-21T15:29:32Z"</span></span> }</code> </pre><br>  Vous pouvez √©galement utiliser un format de date personnalis√© ou m√™me √©crire votre propre d√©codeur de date en utilisant les options de formatage suivantes: <br><br>  <i>.formatted (DateFormatter)</i> - son propre format de d√©codeur de date <br>  <i>.custom ((Date, Encoder) lance -&gt; Void)</i> - cr√©ez compl√®tement votre propre format de d√©codage de date <br><br>  <b>Analyse des objets imbriqu√©s</b> <br><br>  Nous avons d√©j√† examin√© comment utiliser des mod√®les de donn√©es dans d'autres mod√®les, mais il est parfois n√©cessaire d'analyser les champs JSON inclus dans d'autres champs sans utiliser de mod√®le de donn√©es distinct.  Le probl√®me sera plus clair si nous le consid√©rons avec un exemple.  Nous avons le JSON suivant: <br><br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-number"><span class="hljs-number">349</span></span>, <span class="hljs-attr"><span class="hljs-attr">"art"</span></span>: <span class="hljs-string"><span class="hljs-string">"M0470500"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"title"</span></span>: <span class="hljs-string"><span class="hljs-string">"- Vichy 50 "</span></span>, <span class="hljs-attr"><span class="hljs-attr">"ratings"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"average_rating"</span></span>: <span class="hljs-number"><span class="hljs-number">4.1034</span></span>, <span class="hljs-attr"><span class="hljs-attr">"votes_count"</span></span>: <span class="hljs-number"><span class="hljs-number">29</span></span> } }</code> </pre> <br><br>  Nous devons analyser les <i>champs</i> <i>¬´average¬ª</i> et <i>¬´votes_count¬ª</i> , cela peut √™tre r√©solu de deux mani√®res, soit cr√©er un mod√®le de donn√©es de notation avec deux champs et y enregistrer les donn√©es, soit utiliser <i>nestedContainer</i> .  Nous avons d√©j√† discut√© du premier cas, et l'utilisation du second ressemblera √† ceci: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Product</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Decodable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> id: <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> art: <span class="hljs-type"><span class="hljs-type">String?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> title: <span class="hljs-type"><span class="hljs-type">String?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> votesCount: <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> averageRating: <span class="hljs-type"><span class="hljs-type">Double</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CodingKeys</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CodingKey</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> id <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> art <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> title <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ratings } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RatingsCodingKeys</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CodingKey</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> votesCount = <span class="hljs-string"><span class="hljs-string">"votes_count"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> averageRating = <span class="hljs-string"><span class="hljs-string">"average_rating"</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">required</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(from decoder: <span class="hljs-type"><span class="hljs-type">Decoder</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throws</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> container = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> decoder.container(keyedBy: <span class="hljs-type"><span class="hljs-type">CodingKeys</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.id = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> container.decode(<span class="hljs-type"><span class="hljs-type">Int</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, forKey: .id) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.art = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>? container.decode(<span class="hljs-type"><span class="hljs-type">String</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, forKey: .art) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.title = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>? container.decode(<span class="hljs-type"><span class="hljs-type">String</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, forKey: .title) <span class="hljs-comment"><span class="hljs-comment">// Nested ratings let ratingsContainer = try container.nestedContainer(keyedBy: RatingsCodingKeys.self, forKey: .ratings) self.votesCount = try ratingsContainer.decode(Int.self, forKey: .votesCount) self.averageRating = try ratingsContainer.decode(Double.self, forKey: .averageRating) } }</span></span></code> </pre> <br><br>  En d'autres <i>termes</i> , ce probl√®me est r√©solu en cr√©ant un autre conteneur suppl√©mentaire √† l'aide de <i>nestedContainter</i> et de son analyse ult√©rieure.  Cette option est pratique si le nombre de champs imbriqu√©s n'est pas si grand, sinon il est pr√©f√©rable d'utiliser un mod√®le de donn√©es suppl√©mentaire. <br><br>  <b>Non-concordance des noms de champ JSON et des propri√©t√©s du mod√®le de donn√©es</b> <br><br>  Si vous pr√™tez attention √† la fa√ßon dont les √©num√©rations sont d√©finies dans nos mod√®les de donn√©es, vous pouvez voir que les √©l√©ments des √©num√©rations re√ßoivent parfois une cha√Æne qui modifie la valeur par d√©faut, par exemple: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RatingsCodingKeys</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CodingKey</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> votesCount = <span class="hljs-string"><span class="hljs-string">"votes_count"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> averageRating = <span class="hljs-string"><span class="hljs-string">"average_rating"</span></span> }</code> </pre> <br><br>  Cette op√©ration est effectu√©e afin de faire correspondre correctement les noms des variables de mod√®le et des champs JSON.  Ceci est g√©n√©ralement requis pour les champs dont le nom se compose de plusieurs mots, et en JSON, ils sont s√©par√©s par des traits de soulignement.  En principe, une telle red√©finition de l'√©num√©ration est la plus populaire et semble simple, mais m√™me alors, Apple a propos√© une solution plus √©l√©gante.  Ce probl√®me peut √™tre r√©solu sur une seule ligne √† l'aide de <i>keyDecodingStrategy</i> .  Cette fonctionnalit√© est apparue dans Swift 4.1 <br><br>  Disons que vous avez un JSON de la forme: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> jsonString = <span class="hljs-string"><span class="hljs-string">""</span></span><span class="hljs-string"><span class="hljs-string">" [ { "</span></span>name<span class="hljs-string"><span class="hljs-string">": "</span></span>MacBook Pro<span class="hljs-string"><span class="hljs-string">", "</span></span>screen_size<span class="hljs-string"><span class="hljs-string">": 15, "</span></span>cpu_count<span class="hljs-string"><span class="hljs-string">": 4 }, { "</span></span>name<span class="hljs-string"><span class="hljs-string">": "</span></span>iMac Pro<span class="hljs-string"><span class="hljs-string">", "</span></span>screen_size<span class="hljs-string"><span class="hljs-string">": 27, "</span></span>cpu_count<span class="hljs-string"><span class="hljs-string">": 18 } ] "</span></span><span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> jsonData = Data(jsonString.utf8)</code> </pre> <br><br>  Cr√©ons un mod√®le de donn√©es pour cela: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Mac</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Codable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> name: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> screenSize: <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cpuCount: <span class="hljs-type"><span class="hljs-type">Int</span></span> }</code> </pre><br>  Les variables du mod√®le sont enregistr√©es conform√©ment √† l'accord, commencent par une lettre minuscule, puis chaque mot commence par une majuscule (ce que l'on appelle <i>camelCase</i> ).  Mais en JSON, les champs sont √©crits avec des <i>traits de</i> soulignement (le soi-disant <i>snake_case</i> ).  Maintenant, pour que l'analyse r√©ussisse, nous devons soit d√©finir une √©num√©ration dans le mod√®le de donn√©es dans laquelle nous √©tablirons la correspondance des noms des champs JSON avec les noms des variables, soit nous obtiendrons une erreur d'ex√©cution.  Mais maintenant, il est possible de simplement d√©finir <i>keyDecodingStrategy</i> <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> decoder = <span class="hljs-type"><span class="hljs-type">JSONDecoder</span></span>() decoder.keyDecodingStrategy = .convertFromSnakeCase <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> macs = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> decoder.decode([<span class="hljs-type"><span class="hljs-type">Mac</span></span>].<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, from: jsonData) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(error.localizedDescription) }</code> </pre> <br><br>  Pour la fonction d' <i>encodage</i> , vous pouvez donc utiliser la transformation inverse: <br><br><pre> <code class="hljs">encoder.keyEncodingStrategy = .convertToSnakeCase</code> </pre> <br><br>  Il est √©galement possible de personnaliser <i>keyDecodingStrategy en</i> utilisant la fermeture suivante: <br><br><pre> <code class="hljs rust"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> jsonDecoder = JSONDecoder() jsonDecoder.keyDecodingStrategy = .custom { keys -&gt; CodingKey <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> key = keys.last!.stringValue.split(separator: <span class="hljs-string"><span class="hljs-string">"-"</span></span>).joined() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> PersonKey(stringValue: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>(key))! }</code> </pre> <br><br>  Cette entr√©e, par exemple, permet d'utiliser le s√©parateur "-" pour JSON.  Un exemple de JSON utilis√©: <br><br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"first-Name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Taylor"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"last-Name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Swift"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"age"</span></span>: <span class="hljs-number"><span class="hljs-number">28</span></span> }</code> </pre><br>  Ainsi, une d√©finition suppl√©mentaire d'une √©num√©ration peut souvent √™tre √©vit√©e. <br><br>  <b>Gestion des erreurs</b> <br><br>  Lors de l'analyse JSON et de la conversion de donn√©es d'un format √† un autre, les erreurs sont in√©vitables, alors examinons les options pour g√©rer diff√©rents types d'erreurs.  Lors du d√©codage, les types d'erreurs suivants sont possibles: <br><br><ul><li>  <i>DecodingError.dataCorrupted (DecodingError.Context)</i> - les donn√©es sont corrompues.  Signifie g√©n√©ralement que les donn√©es que vous essayez de d√©coder ne correspondent pas au format attendu, par exemple, au lieu du JSON attendu, vous avez re√ßu un format compl√®tement diff√©rent. </li><li>  <i>DecodingError.keyNotFound (CodingKey, DecodingError.Context)</i> - le champ demand√© est introuvable.  Signifie que le champ que vous vous attendiez √† recevoir est manquant </li><li>  <i>DecodingError.typeMismatch (Any.Type, DecodingError.Context)</i> - incompatibilit√© de type.  Lorsque le type de donn√©es dans le mod√®le ne correspond pas au type du champ re√ßu </li><li>  <i>DecodingError.valueNotFound (Any.Type, DecodingError.Context)</i> - valeur manquante pour un champ sp√©cifique.  Le champ que vous avez d√©fini dans le mod√®le de donn√©es n'a pas pu √™tre initialis√©, probablement dans les donn√©es re√ßues ce champ est nul.  Cette erreur se produit uniquement avec les champs non facultatifs, si le champ ne doit pas avoir de valeur, n'oubliez pas de le rendre facultatif. </li></ul><br><br>  Lors de l'encodage des donn√©es, une erreur est possible: <br><br>  <i>EncodingError.invalidValue (Any.Type, DecodingError.Context)</i> - n'a pas r√©ussi √† convertir le mod√®le de donn√©es dans un format sp√©cifique <br><br>  Un exemple de gestion des erreurs lors de l'analyse JSON: <br><br><pre> <code class="hljs swift"> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> decoder = <span class="hljs-type"><span class="hljs-type">JSONDecoder</span></span>() <span class="hljs-number"><span class="hljs-number">_</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> decoder.decode(businessReviewResponse.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, from: data) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> <span class="hljs-type"><span class="hljs-type">DecodingError</span></span>.dataCorrupted(<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> context) { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-type"><span class="hljs-type">DecodingError</span></span>.dataCorrupted(context)) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> <span class="hljs-type"><span class="hljs-type">DecodingError</span></span>.keyNotFound(<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> key, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> context) { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-type"><span class="hljs-type">DecodingError</span></span>.keyNotFound(key,context)) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> <span class="hljs-type"><span class="hljs-type">DecodingError</span></span>.typeMismatch(<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> type, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> context) { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-type"><span class="hljs-type">DecodingError</span></span>.typeMismatch(type,context)) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> <span class="hljs-type"><span class="hljs-type">DecodingError</span></span>.valueNotFound(<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> value, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> context) { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-type"><span class="hljs-type">DecodingError</span></span>.valueNotFound(value,context)) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> error{ <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(error) }</code> </pre> <br><br>  Le traitement des erreurs est bien s√ªr pr√©f√©rable de mettre dans une fonction distincte, mais ici, pour plus de clart√©, l'analyse des erreurs est effectu√©e avec l'analyse.  Par exemple, la sortie d'erreur s'il n'y a pas de valeur pour le champ ¬´produit¬ª ressemblera √† ceci: <br><br><img src="https://habrastorage.org/webt/vs/1k/ej/vs1kejm3b5lnxigx-aulilgvvqu.jpeg" alt="image"><br><br>  <b>Comparaison de Codable et NSCoding</b> <br><br>  Bien s√ªr, le protocole Codable est un grand pas en avant dans le codage / d√©codage des donn√©es, mais le protocole NSCoding existait avant lui.  Essayons de les comparer et voyons quels sont les avantages de Codable: <br><br><ul><li>  Lorsque vous utilisez le protocole <i>NSCoding</i> , l'objet doit √™tre une sous-classe de <i>NSObject</i> , ce qui implique automatiquement que notre mod√®le de donn√©es doit √™tre une classe.  Dans <i>Codable</i> , il n'y a pas besoin d'h√©ritage, respectivement, le mod√®le de donn√©es peut √™tre √† la fois <i>class, struct et enum</i> . </li><li>  Si vous avez besoin de fonctions d'encodage et de d√©codage distinctes, comme, par exemple, dans le cas de l'analyse des donn√©es JSON re√ßues via l'API, vous ne pouvez utiliser qu'un seul protocole <i>d√©codable</i> .  Autrement dit, il n'est pas n√©cessaire d'impl√©menter les m√©thodes d' <i>initialisation</i> ou de <i>codage</i> parfois inutiles. </li><li>  Codable peut g√©n√©rer automatiquement les m√©thodes d' <i>initialisation</i> et de <i>codage</i> requises, ainsi que l'√©num√©ration facultative <i>CodingKeys</i> .  Bien s√ªr, cela ne fonctionne que si vous avez des champs simples dans la structure de donn√©es, sinon, une personnalisation suppl√©mentaire sera n√©cessaire.  Dans la plupart des cas, en particulier pour les structures de donn√©es de base, vous pouvez utiliser la g√©n√©ration automatique, surtout si vous red√©finissez <i>keyDecodingStrategy</i> , cela est pratique et r√©duit le code inutile. </li></ul><br><br>  Les <i>protocoles Codable, Decodable</i> et <i>Encodable</i> nous ont permis de franchir une nouvelle √©tape vers la commodit√© de la conversion des donn√©es, de nouveaux outils d'analyse plus flexibles sont apparus, la quantit√© de code a √©t√© r√©duite et une partie des processus de conversion a √©t√© automatis√©e.  Les protocoles sont impl√©ment√©s nativement dans Swift 4 et permettent de r√©duire l'utilisation de biblioth√®ques tierces, telles que <i>SwiftyJSON</i> , tout en conservant la convivialit√©.  Les protocoles permettent √©galement d'organiser correctement la structure du code en s√©parant les mod√®les de donn√©es et les m√©thodes de travail avec eux dans des modules s√©par√©s. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr414221/">https://habr.com/ru/post/fr414221/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr414211/index.html">D√©veloppement d'un serveur TELNET bas√© sur W5500 et ATMEGA8</a></li>
<li><a href="../fr414213/index.html">Un, deux, trois! Chatbot de Google Sheets utilisant l'exemple d'un jeu PvP pour Alice</a></li>
<li><a href="../fr414215/index.html">Blocs personnalis√©s dans les puces (Silicon IP): comment cela fonctionne</a></li>
<li><a href="../fr414217/index.html">Smartphones locaux Vertex: premiers en qualit√©, premiers en puces, premiers en design</a></li>
<li><a href="../fr414219/index.html">L'exp√©rience de l'utilisation de l'√©nergie solaire dans la r√©gion de Moscou: pour, contre et qui en a besoin</a></li>
<li><a href="../fr414223/index.html">C #: compatibilit√© descendante et surcharge</a></li>
<li><a href="../fr414225/index.html">Cr√©ation de votre propre r√©seau d'appareils faits maison bas√©s sur Arduino (partie 1)</a></li>
<li><a href="../fr414227/index.html">Une nouvelle √©tude des indicateurs Telegram apr√®s blocage: les abonn√©s augmentent, la couverture diminue</a></li>
<li><a href="../fr414229/index.html">Analyse de diff√©rentes m√©thodes de formation informatique</a></li>
<li><a href="../fr414231/index.html">Comment j'ai fait un ordinateur compl√®tement silencieux</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>