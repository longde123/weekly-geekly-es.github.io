<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🗣️ 🕥 👊🏼 Emulieren von Eigenschaftsliteralen mit der Java 8-Methodenreferenz 😇 🏁 🎈</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Von einem Übersetzer: Das Vergehen aufgrund des Fehlens eines nameOf-Operators in Java hat mich dazu veranlasst, diesen Artikel zu übersetzen. Für Ung...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Emulieren von Eigenschaftsliteralen mit der Java 8-Methodenreferenz</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/420533/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/rx/cy/ut/rxcyutfwkaqvjicfkhp78xtv_ts.png"></div><br>  <i>Von einem Übersetzer: Das Vergehen aufgrund des Fehlens eines nameOf-Operators in Java hat mich dazu veranlasst, diesen Artikel zu übersetzen.</i>  <i>Für Ungeduldige - am Ende des Artikels gibt es eine vorgefertigte Implementierung in den Quellen und Binärdateien.</i> <br><br>  Eines der Dinge, die Bibliotheksentwicklern in Java häufig fehlen, sind Eigenschaftsliterale.  In diesem Beitrag werde ich zeigen, wie Sie die Methodenreferenz von Java 8 kreativ verwenden können, um Eigenschaftsliterale mithilfe der Bytecode-Generierung zu emulieren. <br><br>  Ähnlich wie bei Klassenliteralen (z. B. <code>Customer.class</code> ) würden Eigenschaftsliterale es ermöglichen, auf Eigenschaften von Bean-Klassen zu verweisen, die typsicher sind.  Dies ist nützlich, um eine API zu entwerfen, bei der Aktionen für Eigenschaften ausgeführt oder auf irgendeine Weise konfiguriert werden müssen. <br><br>  <i>Vom Übersetzer: Unter dem Schnitt analysieren wir, wie dies mit improvisierten Mitteln umgesetzt werden kann.</i> <br><a name="habracut"></a><br>  Betrachten Sie beispielsweise die API für die Indexzuordnungskonfiguration in der Suche im Ruhezustand: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SearchMapping().entity(Address.class) .indexed() .property(<span class="hljs-string"><span class="hljs-string">"city"</span></span>, ElementType.METHOD) .field();</code> </pre><br>  Oder die <code>validateValue()</code> -Methode aus der Bean Validation API, mit der Sie den Wert anhand der Einschränkungen für die Eigenschaft überprüfen können: <br><br><pre> <code class="java hljs">Set&lt;ConstraintViolation&lt;Address&gt;&gt; violations = validator.validateValue(Address.class, <span class="hljs-string"><span class="hljs-string">"city"</span></span>, <span class="hljs-string"><span class="hljs-string">"Purbeck"</span></span> );</code> </pre><br>  In beiden Fällen wird der <code>String</code> Typ verwendet, um auf die <code>city</code> Eigenschaft des <code>Address</code> Objekts zu verweisen. <br><br>  Dies kann zu Fehlern führen: <br><ul><li>  Die Adressklasse verfügt möglicherweise überhaupt nicht über eine Stadteigenschaft.  Oder jemand vergisst möglicherweise, den Zeichenfolgennamen der Eigenschaft zu aktualisieren, nachdem er die Methoden get / set beim Refactoring umbenannt hat. </li><li>  Im Fall von <code>validateValue()</code> können wir nicht überprüfen, ob der Typ des übergebenen Werts mit dem Typ der Eigenschaft übereinstimmt. </li></ul><br>  Benutzer dieser API können diese Probleme nur durch Starten der Anwendung kennenlernen.  Wäre es nicht cool, wenn der Compiler und das Typsystem eine solche Verwendung von Anfang an verhindern würden?  Wenn Java Eigenschaftsliterale hätte, könnten wir dies tun (dieser Code wird nicht kompiliert): <br><br><pre> <code class="java hljs">mapping.entity(Address.class) .indexed() .property(Address::city, ElementType.METHOD ) .field();</code> </pre><br>  Und: <br><br><pre> <code class="java hljs">validator.validateValue(Address.class, Address::city, <span class="hljs-string"><span class="hljs-string">"Purbeck"</span></span>);</code> </pre><br>  Wir könnten die oben genannten Probleme vermeiden: Jeder Tippfehler im Eigenschaftsnamen würde zu einem Kompilierungsfehler führen, der direkt in Ihrer IDE festgestellt werden kann.  Auf diese Weise können wir die Konfigurations-API für den Ruhezustand der Suche so gestalten, dass sie nur die Eigenschaften der Adressklasse akzeptiert, wenn wir die Adressentität konfigurieren.  Im Fall von Bean Validation <code>validateValue()</code> Eigenschaftsliterale sicherstellen, dass ein Wert des richtigen Typs übergeben wird. <br><br><h2>  Java 8-Methodenreferenz </h2><br>  Java 8 unterstützt keine Eigenschaftsliterale (und es ist nicht geplant, sie in Java 11 zu unterstützen), bietet jedoch gleichzeitig eine interessante Möglichkeit, sie zu emulieren: Methodenreferenz (Methodenreferenz).  Ursprünglich wurde die Methodenreferenz hinzugefügt, um die Arbeit mit Lambda-Ausdrücken zu vereinfachen. Sie können jedoch als Eigenschaftsliterale für die Armen verwendet werden. <br><br>  Betrachten Sie die Idee, einen Verweis auf die Getter-Methode als Eigenschaftsliteral zu verwenden: <br><br><pre> <code class="java hljs">validator.validateValue(Address.class, Address::getCity, <span class="hljs-string"><span class="hljs-string">"Purbeck"</span></span>);</code> </pre><br>  Dies funktioniert natürlich nur, wenn Sie einen Getter haben.  Wenn Ihre Klassen jedoch bereits der JavaBeans-Konvention folgen, was meistens der Fall ist, ist das in Ordnung. <br><br>  Wie würde eine Deklaration der <code>validateValue()</code> -Methode aussehen?  Der entscheidende Punkt ist die Verwendung des neuen <code>Function</code> : <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> &lt;T, P&gt; Set&lt;ConstraintViolation&lt;T&gt;&gt; validateValue( Class&lt;T&gt; type, Function&lt;? <span class="hljs-keyword"><span class="hljs-keyword">super</span></span> T, P&gt; property, P value);</code> </pre><br>  Mithilfe von zwei Tippparametern können wir überprüfen, ob der Bin-Typ, die Eigenschaften und der übergebene Wert korrekt sind.  Aus Sicht der API haben wir das, was wir brauchen: Es ist sicher, es zu verwenden, und die IDE ergänzt sogar automatisch die Methodennamen, die mit <code>Address::</code> .  Aber wie leitet man den Namen der Eigenschaft aus dem <code>Function</code> Objekt bei der Implementierung der <code>validateValue()</code> -Methode ab? <br><br>  Und dann beginnt der Spaß, da die Funktionsfunktionsschnittstelle nur eine Methode deklariert - <code>apply()</code> , die den Funktionscode für die übergebene <code>T</code> Instanz ausführt.  Dies scheint nicht das zu sein, was wir brauchten. <br><br><h2>  ByteBuddy zur Rettung </h2><br>  Wie sich herausstellt, besteht der Trick darin, die Funktion anzuwenden!  Durch das Erstellen einer Proxy-Instanz vom Typ T haben wir das Ziel, die Methode aufzurufen und ihren Namen im Proxy-Aufruf-Handler abzurufen.  (Vom Übersetzer: Im Folgenden geht es um dynamische Java-Proxys - java.lang.reflect.Proxy). <br><br>  Java unterstützt standardmäßig dynamische Proxys, diese Unterstützung ist jedoch nur auf Schnittstellen beschränkt.  Da unsere API mit allen Beans funktionieren sollte, einschließlich realer Klassen, werde ich anstelle von Proxy ein großartiges Tool, ByteBuddy, verwenden.  ByteBuddy bietet ein einfaches DSL zum Erstellen von Klassen im laufenden Betrieb, was wir brauchen. <br><br>  Beginnen wir mit der Definition einer Schnittstelle, über die wir den aus der Methodenreferenz extrahierten Eigenschaftsnamen speichern und abrufen können. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PropertyNameCapturer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPropertyName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setPropertyName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String propertyName)</span></span></span></span>; }</code> </pre> <br>  Jetzt verwenden wir ByteBuddy, um programmgesteuert Proxy-Klassen zu erstellen, die mit den für uns interessanten Typen kompatibel sind (z. B. Adresse), und <code>PropertyNameCapturer</code> implementieren: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> &lt;T&gt; T <span class="hljs-comment"><span class="hljs-comment">/* &amp; PropertyNameCapturer */</span></span> getPropertyNameCapturer(Class&lt;T&gt; type) { DynamicType.Builder&lt;?&gt; builder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ByteBuddy() (<span class="hljs-number"><span class="hljs-number">1</span></span>) .subclass( type.isInterface() ? Object.class : type ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type.isInterface()) { (<span class="hljs-number"><span class="hljs-number">2</span></span>) builder = builder.implement(type); } Class&lt;?&gt; proxyType = builder .implement(PropertyNameCapturer.class) (<span class="hljs-number"><span class="hljs-number">3</span></span>) .defineField(<span class="hljs-string"><span class="hljs-string">"propertyName"</span></span>, String.class, Visibility.PRIVATE) .method( ElementMatchers.any()) (<span class="hljs-number"><span class="hljs-number">4</span></span>) .intercept(MethodDelegation.to( PropertyNameCapturingInterceptor.class )) .method(named(<span class="hljs-string"><span class="hljs-string">"setPropertyName"</span></span>).or(named(<span class="hljs-string"><span class="hljs-string">"getPropertyName"</span></span>))) (<span class="hljs-number"><span class="hljs-number">5</span></span>) .intercept(FieldAccessor.ofBeanProperty()) .make() .load( (<span class="hljs-number"><span class="hljs-number">6</span></span>) PropertyNameCapturer.class.getClassLoader(), ClassLoadingStrategy.Default.WRAPPER ) .getLoaded(); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-meta"><span class="hljs-meta">@SuppressWarnings</span></span>(<span class="hljs-string"><span class="hljs-string">"unchecked"</span></span>) Class&lt;T&gt; typed = (Class&lt;T&gt;) proxyType; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> typed.newInstance(); (<span class="hljs-number"><span class="hljs-number">7</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (InstantiationException | IllegalAccessException e) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HibernateException( <span class="hljs-string"><span class="hljs-string">"Couldn't instantiate proxy for method name retrieval"</span></span>, e ); } }</code> </pre><br>  Der Code mag etwas verwirrend erscheinen, also lassen Sie es mich erklären.  Zuerst erhalten wir eine Instanz von ByteBuddy (1), dem DSL-Einstiegspunkt.  Es wird verwendet, um dynamische Typen zu erstellen, die entweder den gewünschten Typ erweitern (wenn es sich um eine Klasse handelt) oder Object erben und den gewünschten Typ implementieren (wenn es sich um eine Schnittstelle handelt) (2). <br><br>  Dann geben wir an, dass der Typ die PropertyNameCapturer-Schnittstelle implementiert, und fügen ein Feld hinzu, in dem der Name der gewünschten Eigenschaft gespeichert wird (3).  Dann sagen wir, dass Aufrufe aller Methoden von PropertyNameCapturingInterceptor (4) abgefangen werden sollten.  Nur setPropertyName () und getPropertyName () (über die PropertyNameCapturer-Schnittstelle) sollten auf die zuvor erstellte Immobilie zugreifen (5).  Schließlich wird die Klasse erstellt, geladen (6) und instanziiert (7). <br><br>  Das ist alles, was wir brauchen, um Proxy-Typen zu erstellen. Dank ByteBuddy kann dies in wenigen Codezeilen erfolgen.  Schauen wir uns nun den Anrufabfangjäger an: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PropertyNameCapturingInterceptor</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@RuntimeType</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">intercept</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@This PropertyNameCapturer capturer, @Origin Method method)</span></span></span><span class="hljs-function"> </span></span>{ (<span class="hljs-number"><span class="hljs-number">1</span></span>) capturer.setPropertyName(getPropertyName(method)); (<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (method.getReturnType() == <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>.class) { (<span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( ... ) { } <span class="hljs-comment"><span class="hljs-comment">// ... handle all primitve types // ... } else { return null; } } private static String getPropertyName(Method method) { (4) final boolean hasGetterSignature = method.getParameterTypes().length == 0 &amp;&amp; method.getReturnType() != null; String name = method.getName(); String propName = null; if (hasGetterSignature) { if (name.startsWith("get") &amp;&amp; hasGetterSignature) { propName = name.substring(3, 4).toLowerCase() + name.substring(4); } else if (name.startsWith("is") &amp;&amp; hasGetterSignature) { propName = name.substring(2, 3).toLowerCase() + name.substring(3); } } else { throw new HibernateException( "Only property getter methods are expected to be passed"); (5) } return propName; } }</span></span></code> </pre><br>  Die intercept () -Methode akzeptiert die aufgerufene Methode und das Ziel für den Aufruf (1).  Die <code>@This</code> <code>@Origin</code> und <code>@This</code> werden verwendet, um geeignete Parameter anzugeben, damit ByteBuddy die richtigen intercept () -Aufrufe in einem dynamischen Proxy generieren kann. <br><br>  Beachten Sie, dass es keine strikte Abhängigkeit des Rezeptors von ByteBuddy-Typen gibt, da ByteBuddy nur zum Erstellen eines dynamischen Proxys verwendet wird, nicht jedoch bei Verwendung. <br><br>  Durch Aufrufen von <code>getPropertyName()</code> (4) können wir den Eigenschaftsnamen <code>getPropertyName()</code> , der der übergebenen Methodenreferenz entspricht, und ihn in <code>PropertyNameCapturer</code> (2) speichern.  Wenn die Methode kein Getter ist, löst der Code eine Ausnahme aus (5).  Der Rückgabetyp des Getters spielt keine Rolle, daher geben wir unter Berücksichtigung des Eigenschaftstyps (3) null zurück. <br><br>  Jetzt können wir den Eigenschaftsnamen in der <code>validateValue()</code> -Methode abrufen: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> &lt;T, P&gt; Set&lt;ConstraintViolation&lt;T&gt;&gt; validateValue( Class&lt;T&gt; type, Function&lt;? <span class="hljs-keyword"><span class="hljs-keyword">super</span></span> T, P&gt; property, P value) { T capturer = getPropertyNameCapturer(type); property.apply(capturer); String propertyName = ((PropertyLiteralCapturer) capturer).getPropertyName(); <span class="hljs-comment"><span class="hljs-comment">//      }</span></span></code> </pre><br>  Nachdem wir die Funktion auf den erstellten Proxy angewendet haben, wandeln wir den Typ in PropertyNameCapturer um und erhalten den Namen von Method. <br><br>  Unter Verwendung der Magie des Generierens von Bytecode haben wir die Methodenreferenz aus Java 8 verwendet, um Eigenschaftsliterale zu emulieren. <br><br>  Wenn wir Immobilienliterale in der Sprache hätten, wären wir natürlich alle besser dran.  Ich würde sogar erlauben, mit privaten Eigenschaften zu arbeiten, und wahrscheinlich könnten Eigenschaften aus Anmerkungen referenziert werden.  Immobilienliterale wären aufgeräumter (ohne das Präfix "get") und würden nicht wie ein Hack aussehen. <br><br><h2>  Vom Übersetzer </h2><br>  Es ist erwähnenswert, dass andere gute Sprachen bereits (oder fast) einen ähnlichen Mechanismus unterstützen: <br><br><ul><li>  C # - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">nameOf-Anweisung</a> </li><li>  Groovy und Scala - es gibt bekannte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Metaprogrammier-Hacks und Makros</a> </li><li>  Kotlin - Es gibt eine normale Syntax <code>User::login.name</code> </li></ul><br>  Wenn Sie das Lombok-Projekt plötzlich mit Java verwenden, wird ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bytecode-Kompilierungszeitgenerator dafür</a> geschrieben. <br><br>  Inspiriert von dem im Artikel beschriebenen Ansatz hat Ihr bescheidener Diener eine kleine Bibliothek zusammengestellt, die nameOfProperty () für Java 8 implementiert: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quellcode</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Binärdateien</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de420533/">https://habr.com/ru/post/de420533/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de420521/index.html">Jetzt offiziell: TLS 1.3 als Standard anerkannt</a></li>
<li><a href="../de420523/index.html">Analyse von binären Optionsdiagrammen oder wie ich mir erneut bewiesen habe, dass es keine Werbegeschenke gibt</a></li>
<li><a href="../de420525/index.html">Netzwerke für die erfahrensten. Teil fünfzehn. QoS</a></li>
<li><a href="../de420527/index.html">Ein Lächeln kann klingen und es ist ansteckend</a></li>
<li><a href="../de420529/index.html">Fortgeschrittene Nutzung von Geeta oder wie man sechs Monate früher in den Ruhestand geht?</a></li>
<li><a href="../de420537/index.html">Eine andere Geschichte darüber, wie Geld relativ ehrlich mit einem Megaphon aufgenommen wird</a></li>
<li><a href="../de420539/index.html">Benutzerdefinierter Ansatz zum Normalisieren und Zurücksetzen von Stilen (custom-reset.css)</a></li>
<li><a href="../de420541/index.html">Forscher von Carnegie Mellon haben die glaubwürdigsten „Deepfakes“ geschaffen</a></li>
<li><a href="../de420547/index.html">Wie ich schrieb und verteidigte ein Diplom in DEVOPS und Ingenieurspraktiken in 1C von Grund auf neu</a></li>
<li><a href="../de420549/index.html">FreeMarker-Vorlagen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>