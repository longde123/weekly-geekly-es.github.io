<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üó£Ô∏è üï• üëäüèº Emulieren von Eigenschaftsliteralen mit der Java 8-Methodenreferenz üòá üèÅ üéà</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Von einem √úbersetzer: Das Vergehen aufgrund des Fehlens eines nameOf-Operators in Java hat mich dazu veranlasst, diesen Artikel zu √ºbersetzen. F√ºr Ung...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Emulieren von Eigenschaftsliteralen mit der Java 8-Methodenreferenz</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/420533/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/rx/cy/ut/rxcyutfwkaqvjicfkhp78xtv_ts.png"></div><br>  <i>Von einem √úbersetzer: Das Vergehen aufgrund des Fehlens eines nameOf-Operators in Java hat mich dazu veranlasst, diesen Artikel zu √ºbersetzen.</i>  <i>F√ºr Ungeduldige - am Ende des Artikels gibt es eine vorgefertigte Implementierung in den Quellen und Bin√§rdateien.</i> <br><br>  Eines der Dinge, die Bibliotheksentwicklern in Java h√§ufig fehlen, sind Eigenschaftsliterale.  In diesem Beitrag werde ich zeigen, wie Sie die Methodenreferenz von Java 8 kreativ verwenden k√∂nnen, um Eigenschaftsliterale mithilfe der Bytecode-Generierung zu emulieren. <br><br>  √Ñhnlich wie bei Klassenliteralen (z. B. <code>Customer.class</code> ) w√ºrden Eigenschaftsliterale es erm√∂glichen, auf Eigenschaften von Bean-Klassen zu verweisen, die typsicher sind.  Dies ist n√ºtzlich, um eine API zu entwerfen, bei der Aktionen f√ºr Eigenschaften ausgef√ºhrt oder auf irgendeine Weise konfiguriert werden m√ºssen. <br><br>  <i>Vom √úbersetzer: Unter dem Schnitt analysieren wir, wie dies mit improvisierten Mitteln umgesetzt werden kann.</i> <br><a name="habracut"></a><br>  Betrachten Sie beispielsweise die API f√ºr die Indexzuordnungskonfiguration in der Suche im Ruhezustand: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SearchMapping().entity(Address.class) .indexed() .property(<span class="hljs-string"><span class="hljs-string">"city"</span></span>, ElementType.METHOD) .field();</code> </pre><br>  Oder die <code>validateValue()</code> -Methode aus der Bean Validation API, mit der Sie den Wert anhand der Einschr√§nkungen f√ºr die Eigenschaft √ºberpr√ºfen k√∂nnen: <br><br><pre> <code class="java hljs">Set&lt;ConstraintViolation&lt;Address&gt;&gt; violations = validator.validateValue(Address.class, <span class="hljs-string"><span class="hljs-string">"city"</span></span>, <span class="hljs-string"><span class="hljs-string">"Purbeck"</span></span> );</code> </pre><br>  In beiden F√§llen wird der <code>String</code> Typ verwendet, um auf die <code>city</code> Eigenschaft des <code>Address</code> Objekts zu verweisen. <br><br>  Dies kann zu Fehlern f√ºhren: <br><ul><li>  Die Adressklasse verf√ºgt m√∂glicherweise √ºberhaupt nicht √ºber eine Stadteigenschaft.  Oder jemand vergisst m√∂glicherweise, den Zeichenfolgennamen der Eigenschaft zu aktualisieren, nachdem er die Methoden get / set beim Refactoring umbenannt hat. </li><li>  Im Fall von <code>validateValue()</code> k√∂nnen wir nicht √ºberpr√ºfen, ob der Typ des √ºbergebenen Werts mit dem Typ der Eigenschaft √ºbereinstimmt. </li></ul><br>  Benutzer dieser API k√∂nnen diese Probleme nur durch Starten der Anwendung kennenlernen.  W√§re es nicht cool, wenn der Compiler und das Typsystem eine solche Verwendung von Anfang an verhindern w√ºrden?  Wenn Java Eigenschaftsliterale h√§tte, k√∂nnten wir dies tun (dieser Code wird nicht kompiliert): <br><br><pre> <code class="java hljs">mapping.entity(Address.class) .indexed() .property(Address::city, ElementType.METHOD ) .field();</code> </pre><br>  Und: <br><br><pre> <code class="java hljs">validator.validateValue(Address.class, Address::city, <span class="hljs-string"><span class="hljs-string">"Purbeck"</span></span>);</code> </pre><br>  Wir k√∂nnten die oben genannten Probleme vermeiden: Jeder Tippfehler im Eigenschaftsnamen w√ºrde zu einem Kompilierungsfehler f√ºhren, der direkt in Ihrer IDE festgestellt werden kann.  Auf diese Weise k√∂nnen wir die Konfigurations-API f√ºr den Ruhezustand der Suche so gestalten, dass sie nur die Eigenschaften der Adressklasse akzeptiert, wenn wir die Adressentit√§t konfigurieren.  Im Fall von Bean Validation <code>validateValue()</code> Eigenschaftsliterale sicherstellen, dass ein Wert des richtigen Typs √ºbergeben wird. <br><br><h2>  Java 8-Methodenreferenz </h2><br>  Java 8 unterst√ºtzt keine Eigenschaftsliterale (und es ist nicht geplant, sie in Java 11 zu unterst√ºtzen), bietet jedoch gleichzeitig eine interessante M√∂glichkeit, sie zu emulieren: Methodenreferenz (Methodenreferenz).  Urspr√ºnglich wurde die Methodenreferenz hinzugef√ºgt, um die Arbeit mit Lambda-Ausdr√ºcken zu vereinfachen. Sie k√∂nnen jedoch als Eigenschaftsliterale f√ºr die Armen verwendet werden. <br><br>  Betrachten Sie die Idee, einen Verweis auf die Getter-Methode als Eigenschaftsliteral zu verwenden: <br><br><pre> <code class="java hljs">validator.validateValue(Address.class, Address::getCity, <span class="hljs-string"><span class="hljs-string">"Purbeck"</span></span>);</code> </pre><br>  Dies funktioniert nat√ºrlich nur, wenn Sie einen Getter haben.  Wenn Ihre Klassen jedoch bereits der JavaBeans-Konvention folgen, was meistens der Fall ist, ist das in Ordnung. <br><br>  Wie w√ºrde eine Deklaration der <code>validateValue()</code> -Methode aussehen?  Der entscheidende Punkt ist die Verwendung des neuen <code>Function</code> : <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> &lt;T, P&gt; Set&lt;ConstraintViolation&lt;T&gt;&gt; validateValue( Class&lt;T&gt; type, Function&lt;? <span class="hljs-keyword"><span class="hljs-keyword">super</span></span> T, P&gt; property, P value);</code> </pre><br>  Mithilfe von zwei Tippparametern k√∂nnen wir √ºberpr√ºfen, ob der Bin-Typ, die Eigenschaften und der √ºbergebene Wert korrekt sind.  Aus Sicht der API haben wir das, was wir brauchen: Es ist sicher, es zu verwenden, und die IDE erg√§nzt sogar automatisch die Methodennamen, die mit <code>Address::</code> .  Aber wie leitet man den Namen der Eigenschaft aus dem <code>Function</code> Objekt bei der Implementierung der <code>validateValue()</code> -Methode ab? <br><br>  Und dann beginnt der Spa√ü, da die Funktionsfunktionsschnittstelle nur eine Methode deklariert - <code>apply()</code> , die den Funktionscode f√ºr die √ºbergebene <code>T</code> Instanz ausf√ºhrt.  Dies scheint nicht das zu sein, was wir brauchten. <br><br><h2>  ByteBuddy zur Rettung </h2><br>  Wie sich herausstellt, besteht der Trick darin, die Funktion anzuwenden!  Durch das Erstellen einer Proxy-Instanz vom Typ T haben wir das Ziel, die Methode aufzurufen und ihren Namen im Proxy-Aufruf-Handler abzurufen.  (Vom √úbersetzer: Im Folgenden geht es um dynamische Java-Proxys - java.lang.reflect.Proxy). <br><br>  Java unterst√ºtzt standardm√§√üig dynamische Proxys, diese Unterst√ºtzung ist jedoch nur auf Schnittstellen beschr√§nkt.  Da unsere API mit allen Beans funktionieren sollte, einschlie√ülich realer Klassen, werde ich anstelle von Proxy ein gro√üartiges Tool, ByteBuddy, verwenden.  ByteBuddy bietet ein einfaches DSL zum Erstellen von Klassen im laufenden Betrieb, was wir brauchen. <br><br>  Beginnen wir mit der Definition einer Schnittstelle, √ºber die wir den aus der Methodenreferenz extrahierten Eigenschaftsnamen speichern und abrufen k√∂nnen. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PropertyNameCapturer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPropertyName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setPropertyName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String propertyName)</span></span></span></span>; }</code> </pre> <br>  Jetzt verwenden wir ByteBuddy, um programmgesteuert Proxy-Klassen zu erstellen, die mit den f√ºr uns interessanten Typen kompatibel sind (z. B. Adresse), und <code>PropertyNameCapturer</code> implementieren: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> &lt;T&gt; T <span class="hljs-comment"><span class="hljs-comment">/* &amp; PropertyNameCapturer */</span></span> getPropertyNameCapturer(Class&lt;T&gt; type) { DynamicType.Builder&lt;?&gt; builder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ByteBuddy() (<span class="hljs-number"><span class="hljs-number">1</span></span>) .subclass( type.isInterface() ? Object.class : type ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type.isInterface()) { (<span class="hljs-number"><span class="hljs-number">2</span></span>) builder = builder.implement(type); } Class&lt;?&gt; proxyType = builder .implement(PropertyNameCapturer.class) (<span class="hljs-number"><span class="hljs-number">3</span></span>) .defineField(<span class="hljs-string"><span class="hljs-string">"propertyName"</span></span>, String.class, Visibility.PRIVATE) .method( ElementMatchers.any()) (<span class="hljs-number"><span class="hljs-number">4</span></span>) .intercept(MethodDelegation.to( PropertyNameCapturingInterceptor.class )) .method(named(<span class="hljs-string"><span class="hljs-string">"setPropertyName"</span></span>).or(named(<span class="hljs-string"><span class="hljs-string">"getPropertyName"</span></span>))) (<span class="hljs-number"><span class="hljs-number">5</span></span>) .intercept(FieldAccessor.ofBeanProperty()) .make() .load( (<span class="hljs-number"><span class="hljs-number">6</span></span>) PropertyNameCapturer.class.getClassLoader(), ClassLoadingStrategy.Default.WRAPPER ) .getLoaded(); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-meta"><span class="hljs-meta">@SuppressWarnings</span></span>(<span class="hljs-string"><span class="hljs-string">"unchecked"</span></span>) Class&lt;T&gt; typed = (Class&lt;T&gt;) proxyType; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> typed.newInstance(); (<span class="hljs-number"><span class="hljs-number">7</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (InstantiationException | IllegalAccessException e) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HibernateException( <span class="hljs-string"><span class="hljs-string">"Couldn't instantiate proxy for method name retrieval"</span></span>, e ); } }</code> </pre><br>  Der Code mag etwas verwirrend erscheinen, also lassen Sie es mich erkl√§ren.  Zuerst erhalten wir eine Instanz von ByteBuddy (1), dem DSL-Einstiegspunkt.  Es wird verwendet, um dynamische Typen zu erstellen, die entweder den gew√ºnschten Typ erweitern (wenn es sich um eine Klasse handelt) oder Object erben und den gew√ºnschten Typ implementieren (wenn es sich um eine Schnittstelle handelt) (2). <br><br>  Dann geben wir an, dass der Typ die PropertyNameCapturer-Schnittstelle implementiert, und f√ºgen ein Feld hinzu, in dem der Name der gew√ºnschten Eigenschaft gespeichert wird (3).  Dann sagen wir, dass Aufrufe aller Methoden von PropertyNameCapturingInterceptor (4) abgefangen werden sollten.  Nur setPropertyName () und getPropertyName () (√ºber die PropertyNameCapturer-Schnittstelle) sollten auf die zuvor erstellte Immobilie zugreifen (5).  Schlie√ülich wird die Klasse erstellt, geladen (6) und instanziiert (7). <br><br>  Das ist alles, was wir brauchen, um Proxy-Typen zu erstellen. Dank ByteBuddy kann dies in wenigen Codezeilen erfolgen.  Schauen wir uns nun den Anrufabfangj√§ger an: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PropertyNameCapturingInterceptor</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@RuntimeType</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">intercept</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@This PropertyNameCapturer capturer, @Origin Method method)</span></span></span><span class="hljs-function"> </span></span>{ (<span class="hljs-number"><span class="hljs-number">1</span></span>) capturer.setPropertyName(getPropertyName(method)); (<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (method.getReturnType() == <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>.class) { (<span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>) <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( ... ) { } <span class="hljs-comment"><span class="hljs-comment">// ... handle all primitve types // ... } else { return null; } } private static String getPropertyName(Method method) { (4) final boolean hasGetterSignature = method.getParameterTypes().length == 0 &amp;&amp; method.getReturnType() != null; String name = method.getName(); String propName = null; if (hasGetterSignature) { if (name.startsWith("get") &amp;&amp; hasGetterSignature) { propName = name.substring(3, 4).toLowerCase() + name.substring(4); } else if (name.startsWith("is") &amp;&amp; hasGetterSignature) { propName = name.substring(2, 3).toLowerCase() + name.substring(3); } } else { throw new HibernateException( "Only property getter methods are expected to be passed"); (5) } return propName; } }</span></span></code> </pre><br>  Die intercept () -Methode akzeptiert die aufgerufene Methode und das Ziel f√ºr den Aufruf (1).  Die <code>@This</code> <code>@Origin</code> und <code>@This</code> werden verwendet, um geeignete Parameter anzugeben, damit ByteBuddy die richtigen intercept () -Aufrufe in einem dynamischen Proxy generieren kann. <br><br>  Beachten Sie, dass es keine strikte Abh√§ngigkeit des Rezeptors von ByteBuddy-Typen gibt, da ByteBuddy nur zum Erstellen eines dynamischen Proxys verwendet wird, nicht jedoch bei Verwendung. <br><br>  Durch Aufrufen von <code>getPropertyName()</code> (4) k√∂nnen wir den Eigenschaftsnamen <code>getPropertyName()</code> , der der √ºbergebenen Methodenreferenz entspricht, und ihn in <code>PropertyNameCapturer</code> (2) speichern.  Wenn die Methode kein Getter ist, l√∂st der Code eine Ausnahme aus (5).  Der R√ºckgabetyp des Getters spielt keine Rolle, daher geben wir unter Ber√ºcksichtigung des Eigenschaftstyps (3) null zur√ºck. <br><br>  Jetzt k√∂nnen wir den Eigenschaftsnamen in der <code>validateValue()</code> -Methode abrufen: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> &lt;T, P&gt; Set&lt;ConstraintViolation&lt;T&gt;&gt; validateValue( Class&lt;T&gt; type, Function&lt;? <span class="hljs-keyword"><span class="hljs-keyword">super</span></span> T, P&gt; property, P value) { T capturer = getPropertyNameCapturer(type); property.apply(capturer); String propertyName = ((PropertyLiteralCapturer) capturer).getPropertyName(); <span class="hljs-comment"><span class="hljs-comment">//      }</span></span></code> </pre><br>  Nachdem wir die Funktion auf den erstellten Proxy angewendet haben, wandeln wir den Typ in PropertyNameCapturer um und erhalten den Namen von Method. <br><br>  Unter Verwendung der Magie des Generierens von Bytecode haben wir die Methodenreferenz aus Java 8 verwendet, um Eigenschaftsliterale zu emulieren. <br><br>  Wenn wir Immobilienliterale in der Sprache h√§tten, w√§ren wir nat√ºrlich alle besser dran.  Ich w√ºrde sogar erlauben, mit privaten Eigenschaften zu arbeiten, und wahrscheinlich k√∂nnten Eigenschaften aus Anmerkungen referenziert werden.  Immobilienliterale w√§ren aufger√§umter (ohne das Pr√§fix "get") und w√ºrden nicht wie ein Hack aussehen. <br><br><h2>  Vom √úbersetzer </h2><br>  Es ist erw√§hnenswert, dass andere gute Sprachen bereits (oder fast) einen √§hnlichen Mechanismus unterst√ºtzen: <br><br><ul><li>  C # - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">nameOf-Anweisung</a> </li><li>  Groovy und Scala - es gibt bekannte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Metaprogrammier-Hacks und Makros</a> </li><li>  Kotlin - Es gibt eine normale Syntax <code>User::login.name</code> </li></ul><br>  Wenn Sie das Lombok-Projekt pl√∂tzlich mit Java verwenden, wird ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bytecode-Kompilierungszeitgenerator daf√ºr</a> geschrieben. <br><br>  Inspiriert von dem im Artikel beschriebenen Ansatz hat Ihr bescheidener Diener eine kleine Bibliothek zusammengestellt, die nameOfProperty () f√ºr Java 8 implementiert: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quellcode</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bin√§rdateien</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de420533/">https://habr.com/ru/post/de420533/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de420521/index.html">Jetzt offiziell: TLS 1.3 als Standard anerkannt</a></li>
<li><a href="../de420523/index.html">Analyse von bin√§ren Optionsdiagrammen oder wie ich mir erneut bewiesen habe, dass es keine Werbegeschenke gibt</a></li>
<li><a href="../de420525/index.html">Netzwerke f√ºr die erfahrensten. Teil f√ºnfzehn. QoS</a></li>
<li><a href="../de420527/index.html">Ein L√§cheln kann klingen und es ist ansteckend</a></li>
<li><a href="../de420529/index.html">Fortgeschrittene Nutzung von Geeta oder wie man sechs Monate fr√ºher in den Ruhestand geht?</a></li>
<li><a href="../de420537/index.html">Eine andere Geschichte dar√ºber, wie Geld relativ ehrlich mit einem Megaphon aufgenommen wird</a></li>
<li><a href="../de420539/index.html">Benutzerdefinierter Ansatz zum Normalisieren und Zur√ºcksetzen von Stilen (custom-reset.css)</a></li>
<li><a href="../de420541/index.html">Forscher von Carnegie Mellon haben die glaubw√ºrdigsten ‚ÄûDeepfakes‚Äú geschaffen</a></li>
<li><a href="../de420547/index.html">Wie ich schrieb und verteidigte ein Diplom in DEVOPS und Ingenieurspraktiken in 1C von Grund auf neu</a></li>
<li><a href="../de420549/index.html">FreeMarker-Vorlagen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>