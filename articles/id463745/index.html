<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔻 🤓 📤 Komplikasi C ++ tidak bisa dihindari. Dan tidak hanya C ++ 🥛 👩🏽 🛌</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saya sudah lama ingin menulis teks yang serupa, tetapi tangan saya tidak menjangkau. Tetapi setelah pertemuan musim panas Komite Standardisasi C ++ ya...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Komplikasi C ++ tidak bisa dihindari. Dan tidak hanya C ++</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/463745/"><p>  Saya sudah lama ingin menulis teks yang serupa, tetapi tangan saya tidak menjangkau.  Tetapi setelah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pertemuan</a> musim panas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Komite Standardisasi C ++</a> yang berakhir dan melolong bahwa kompleksitas bahasa semakin meningkat, saya harus mencari waktu dan memperbaiki pikiran saya sendiri mengenai hal ini. </p><br><p>  Akan ada banyak teks, jadi mereka yang tidak menyesal atas waktu mereka, saya mengundang Anda untuk mencari di bawah kucing. </p><br><h1>  Bahasa pemrograman adalah produk teknologi, tetapi tidak sesederhana itu </h1><br><p>  Beberapa waktu lalu saya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">berkesempatan membaca buku yang menarik, Dilema Inovator</a> .  Di sana, dengan contoh-contoh produk teknologi tinggi, ditunjukkan bagaimana produk baru muncul yang pertama kali kalah dari keputusan yang saat ini mendominasi pasar, dan kemudian secara radikal mengubah keadaan pasar. </p><br><p>  Salah satu contoh yang paling mencolok: fotografi digital, yang benar-benar tidak ada pada tahun 1990-an, tetapi hanya 20 tahun kemudian menyebabkan runtuhnya rakasa abad ke-20 sebagai Kodak (yang, kebetulan, adalah yang pertama membuat prototipe kamera digital). </p><br><img src="https://www.kodak.com/Kodak/uploadedImages/Corporate/About_Us/Heritage/Milestones/timeline_photo_first_digital_cameras_fullres.jpg" alt="gambar"><br><a name="habracut"></a><br><p>  Contoh lain yang dekat dengan pengembang adalah evolusi hard drive.  Dari monster besar dan kuat waktu mainframe dan komputer mini, ke model 3,5 "dan 2,5" inci kecil, dan kemudian ke SSD format M.2 dan kabel langsung ke papan eMMC. </p><br><img src="http://mirtayn.ru/wp-content/uploads/disk_ibm2.jpg" alt="gambar"><br><br><p>  Hal yang sama dengan floppy disk, yang pertama kali mencapai 3,5 ", dan kemudian menghilang sebagai kelas di bawah tekanan USB flash drive. </p><br><img src="https://gallery.ykt.ru/galleries/old/comp/758583.jpg" alt="gambar"><br><br><p>  Contoh lain dari bidang profesional kami adalah pengembangan komputer pribadi.  Yang awalnya tidak mampu bersaing dengan komputer "nyata" pada pertengahan 1970-an.  Dan kemudian mereka menghancurkan komputer mini sebagai kelas.  Kemudian mereka menyebabkan munculnya server modern, agak mengingatkan pada komputer mini.  Dan sekarang PC sendiri menghilang dari konsumsi massal di bawah pengaruh laptop, tablet, dan smartphone. </p><br><img src="https://tr3.cbsistatic.com/hub/i/r/2014/04/07/a0e20eb1-1ca5-4cd0-ae58-85444fa9a1b6/resize/770x/d2a4495ff19c02a50544523af4c406e7/system360model-75e.jpg" alt="gambar"><br><br><p>  Para penulis buku ini menyatakan bahwa peristiwa dalam semua kasus tersebut berkembang sesuai dengan skenario yang sama: </p><br><ul><li>  Pertama, ada kebutuhan untuk produk yang memecahkan masalah tertentu.  Katakanlah disk magnetik fleksibel; </li><li>  karena pada tahap awal semua solusi yang bersaing (yang pada prinsipnya sedikit) didasarkan pada teknologi yang sama, pasar dibagi antara produk yang kurang lebih serupa; </li><li>  produsen produk yang sukses mulai bersaing satu sama lain dan dalam kompetisi ini membawa produk mereka hampir ke rasio kualitas harga yang paling menguntungkan.  Dan, yang paling penting, sementara produk yang ada sekonsisten mungkin dengan pandangan tentang bagaimana tugas-tugas yang dimaksudkan untuk menangani produk-produk ini.  Secara kasar, semua orang tahu bahwa disket 8 "sangat bagus untuk mentransfer informasi dari satu komputer mini ke komputer lain menggunakan disket. Dan tidak ada orang lain yang bisa membayangkan cara lain dalam arus utama; </li><li>  suatu tempat di sela-sela, berdasarkan pada beberapa penemuan / bahan / teknologi baru, muncul produk baru yang secara signifikan lebih rendah daripada produk yang ada di hampir semua hal.  Umumnya lebih mahal.  Sebagai aturan, tidak sebanding dalam kemampuan / kapasitas.  Tetapi memiliki kualitas yang sangat penting: dapat digunakan di mana tidak mungkin atau sulit untuk menerapkan solusi utama.  Misalnya, Anda tidak dapat memasang drive 8 "ke komputer pribadi. Tetapi pemilik PC tidak tertarik membawa disket 8".  Itu tidak praktis.  Sedangkan 5,25 "floppy disk cukup untuk dirinya sendiri. Dan tidak peduli bahwa dengan biaya 5,25 kilobyte" floppy disk awalnya lebih mahal daripada 8. "Masih belum ada pilihan; </li><li>  Pasar baru terbentuk di sekitar produk baru, yang pada awalnya sama sekali tidak menarik bagi produsen produk arus utama.  Tapi, karena itu adalah pasar baru, pemain baru berbondong-bondong ke sana, yang menciptakan persaingan serius satu sama lain.  Dan kompetisi ini dengan cepat menerjemahkan teknologi marginal dan tidak efektif menjadi sangat efektif.  Yang segera berhenti menjadi marjinal, karena begitu melampaui produk utama lama dalam hal totalitasnya, ia segera menggantikannya di ceruk mereka sendiri.  Secara kasar, jika ada ratusan ribu drive 5,25 "dan jutaan disket 5,25", lalu apa gunanya memegang perangkat 8 "yang jauh lebih marjinal saat ini? </li></ul><br><h2>  Memprogram bahasa sebagai produk teknologi </h2><br><p>  Pada pandangan pertama, analogi serupa dapat dilihat dalam cara bahasa pemrograman menjadi arus utama.  Dan mungkin contoh yang paling mencolok di sini adalah bahasa Java dan Go. </p><br><p>  Bahasa Jawa muncul sebagai hasil dari upaya untuk menciptakan "C ++ yang tepat".  Tetapi bahasa yang dihasilkan tidak akan dibutuhkan oleh siapa pun, karena  dia sangat sengsara dan, yang lebih penting, lambat dan rakus.  Di desktop saat itu, bahkan mengingat pertumbuhan cepat daya PC pada waktu itu, Java tidak punya peluang. </p><br><p>  Namun, Java memasuki "pasar" dari perspektif yang sama sekali berbeda, melalui ceruk di mana tidak ada yang benar-benar dapat bekerja saat itu: melalui Internet dan applet browser (semuanya sedikit lebih rumit dan masih ada pasar untuk applet JavaCard dan STK, tetapi kami tidak akan pergi di alam liar).  Internet adalah topik yang sangat panas, dan kemudian tidak ada yang bisa dilakukan untuk situs / halaman dinamis (JavaScript muncul setelah pengumuman Java).  Dan, karena tidak ada yang bisa digunakan selain Jawa, Java mulai digunakan.  Nah, dan kemudian, ketika mengembangkan dan mengatasi penyakit anak-anak, Jawa pergi ke daerah lain, menyingkirkan teknologi lain dari sana.  Meskipun di desktop yang sama dia tidak bisa menggigit sepotong kue yang berarti. </p><br><p>  Bahasa Go hampir tidak bisa menarik minat siapa pun dalam relung tradisional tempat C, C ++, Java, C #, Python, Ruby, dll. Sudah hidup.  Tetapi pengembangan produk untuk Internet telah melahirkan ceruk lain - layanan tenang.  Untuk pengembangan yang Java adalah pembunuhan berlebihan, C ++ terlalu rumit dan berbahaya, Python / Ruby dan dinamika lainnya terlalu lambat.  Dan sekarang salah satu yang paling menyedihkan dalam hal bahasa ekspresif yang dikembangkan pada abad ke-21 hampir menjadi peluru perak bagi ceruk terapan ini.  Dari mana, mungkin, itu akan menyebar di tempat lain dari waktu ke waktu (yang secara pribadi saya tidak akan terkejut melihat tingkat kualifikasi umum generasi muda pengembang). </p><br><p>  Jadi seseorang merasa bahwa pemrograman harus sama dengan bahasa seperti halnya dengan produk teknologi lainnya: kemunculan bahasa-bahasa baru mengarah pada penghilangan yang hampir lengkap, atau untuk mengusir bahasa-bahasa sebelumnya ke dalam celah marginal yang terpisah.  Pada saat yang sama, bahasa-bahasa lama, dalam proses perkembangan mereka dalam kerangka lingkungan kompetitif, menjadi lebih kuat dan ekspresif untuk solusi yang lebih murah untuk tugas-tugas khas mereka.  Akibatnya, bahasa-bahasa lama menjadi semakin banyak dan kompleks.  Dan kurang menarik untuk digunakan di luar relung yang telah mereka tempati. </p><br><p>  Oleh karena itu, tampaknya bahwa siklus hidup produk teknologi yang dijelaskan dalam Dilema Inovator juga harus diperluas ke bahasa pemrograman. </p><br><h2>  Tetapi tidak semuanya begitu sederhana dengan bahasa pemrograman </h2><br><p>  Dalam skema penetrasi produk teknologi baru ke pasar yang dijelaskan dalam Dilema Inovator, salah satu alasan paling penting bagi pengguna untuk beralih dari produk mainstream lama ke produk baru adalah hanya karena pengurangan biaya kepemilikan yang signifikan atau perolehan peluang yang sebelumnya tersedia + penurunan biaya kepemilikan. </p><br><p>  Katakanlah, pengembangan PC dan pertumbuhan kekuatan mereka membuat memiliki armada PC lebih murah daripada memiliki satu atau lebih komputer mini.  Akibatnya, floppy disk tiga inci lebih murah per unit kapasitas daripada 5,25 "(dengan mempertimbangkan keandalan yang lebih besar dan faktor-faktor lain). Akibatnya, fotografi digital lebih murah per bingkai daripada film. Dan seterusnya. </p><br><p>  Tetapi dua indikator yang lebih penting dikaitkan dengan transisi dari satu produk ke produk lainnya - ini adalah biaya / kompleksitas transisi itu sendiri, serta kecepatan Anda dapat beralih ke produk baru.  Indikator-indikator ini dapat diperkirakan dalam uang.  Dan jika manfaat dari transisi ke produk baru hadir, maka transisi dilakukan.  Mungkin tidak cepat, tetapi dilakukan. </p><br><p>  Dan di sini ternyata biaya beralih dari satu bahasa pemrograman ke bahasa yang lain jauh lebih tinggi daripada dalam kasus beralih dari komputer mini ke PC, dari 8 "floppy disk ke 5,25" atau dari HDD ke SSD.  Karena mengubah bahasa pemrograman biasanya penulisan ulang lengkap produk perangkat lunak.  Seringkali dari awal. </p><br><p>  Dan apa artinya menulis ulang?  Gaji tim programmer baru, yang perlu mengulangi fungsi yang sudah tersedia dalam produk.  Dan bahkan jika PL baru memungkinkan Anda untuk membagi dua ukuran tim, itu masih berarti biaya yang signifikan.  Karena jika $ 10 juta dihabiskan untuk mengembangkan versi produk yang lama, maka menulis ulang akan membutuhkan setidaknya $ 5 juta. </p><br><p>  Tetapi, yang lebih penting, ini adalah bahwa produk yang ditulis ulang tidak akan segera muncul.  Itu butuh waktu.  Banyak waktu.  Sekali lagi, jika kami berasumsi bahwa bahasa baru memungkinkan Anda untuk menulis kode kerja dua kali lebih cepat, kemudian menulis ulang produk, pengembangan versi lama yang memakan waktu 5 tahun, hanya akan memerlukan 2,5 tahun. </p><br><p>  Ternyata saat ini Anda harus mulai menginvestasikan banyak uang untuk mendapatkan salinan sesuatu yang telah bekerja lama dan membawa uang sekarang. </p><br><p>  Dan satu sisi lagi dari koin ini harus disebutkan: jika produk perangkat lunak dioperasikan dalam kondisi yang berubah, maka produk tersebut pasti akan diselesaikan atau diproses untuk memenuhi kebutuhan modern.  Pada saat yang sama, bisnis tidak memiliki kesempatan untuk menunggu satu setengah tahun, sampai versi baru produk muncul di PL baru, fungsionalitas baru, diperlukan, di masa mendatang.  Seringkali, kemarin. </p><br><p>  Karena itu, ketika menulis ulang, biaya meningkat: Anda perlu menulis versi baru pada saat yang sama dan mengembangkan yang lama. </p><br><p>  Menurut pendapat saya, inilah tepatnya yang menjelaskan mengapa bahasa baru "dipecat", terutama dalam pengembangan aplikasi baru untuk ceruk aplikasi baru.  Tetapi memadati bahasa-bahasa lama dari daerah-daerah yang sebelumnya diduduki sudah jauh lebih lambat.  Fortran dan Cobol mungkin bisa dianggap sebagai contoh paling mencolok.  Tidak hanya perangkat lunak yang ditulis pada mereka masih beroperasi, sehingga mereka terus menulis kode baru dalam bahasa-bahasa ini.  Dan bahasa-bahasa ini sendiri berkembang. </p><br><p>  Dan menurut saya salah satu mimpi terburuk pemilik produk perangkat lunak di Cobol adalah menulis ulang produk di Jawa atau C #;) </p><br><h2>  Dan faktor penting lainnya: pengembangan IT itu sendiri </h2><br><p>  Poin lain yang ingin saya perhatikan adalah fakta bahwa TI ada belum lama ini dan sejarah evolusi bahasa tingkat tinggi bahkan lebih pendek.  Bagian pertama dari kisah ini tidak mungkin memberi kita dukungan kuat untuk diskusi kita tentang bagaimana beberapa bahasa menggantikan yang lain.  Tahun 1950-an dan 1960-an adalah tahun percobaan.  Selain itu, tahun-tahun ketika pasar komputer itu sendiri tersegmentasi dan bagian penting dari perangkat lunak ditulis untuk komputer dan OS tertentu, tanpa persyaratan khusus untuk portabilitas.  Jumlah pengembang perangkat lunak yang ada, serta berbagai bidang di mana komputer banyak digunakan, tidak dapat dibandingkan dengan keadaan saat ini. </p><br><p>  IMHO, pada dasarnya hal-hal telah berubah pada 1970-an, dan sejak 1980-an kita telah melihat kemunculan senjata nuklir, yang sudah didasarkan pada pengalaman praktis masa lalu dan hasil studi teoretis.  Bagi saya, tepatnya tahun 1980-an (dan mungkin akhir tahun 1970-an) adalah awal dari era bahasa pemrograman yang ditujukan untuk pembuatan perangkat lunak pada skala industri.  Karena di sinilah kita melihat Modula-2, SmallTalk, Ada, C ++, Eiffel, ekstensi objek Pascal, Objective-C, Perl. </p><br><p>  Oleh karena itu, saya akan melangkah lebih jauh dari apa yang muncul di era senjata nuklir industri ini. </p><br><h3>  Ngomong-ngomong </h3><br><p>  Daftar bahasa yang muncul pada 1980-an, saya ingat tentang PL yang dikembangkan oleh Niklaus Wirth: pertama Pascal, lalu Modula / Modula-2, lalu Oberon. </p><br><p>  Dengan contoh bahasa-bahasa ini, orang dapat melihat bagaimana pengalaman penulis mereka mengarah pada penampilan alat yang memperhitungkan kekurangan dari upaya sebelumnya, serta memenuhi persyaratan baru pada waktu mereka. </p><br><p>  Tetapi bahasa yang sama ini juga menunjukkan betapa pentingnya bagi pengguna YaP untuk tetap berada dalam kerangka bahasa yang dipilih sebelumnya.  Transisi dari Pascal ke Modula-2 adalah.  Tetapi tidak berarti besar.  Dan, terlepas dari kenyataan bahwa Modula-2 lebih atau kurang aktif digunakan, itu tidak menjadi sepopuler pewaris Pascal, terutama Delphi.  Dan tidak ada transisi yang dapat diamati ke Oberon sama sekali, sejauh yang saya ingat. </p><br><h1>  Bahasa pemrograman populer tidak bisa hanya diganti.  Dan bagaimana dengan itu? </h1><br><p>  Jadi, pesan utama dalam alasan saya sebelumnya adalah bahwa jika suatu bahasa telah menemukan penggunaan yang kurang lebih luas dan dengan bantuannya banyak berbagai produk perangkat lunak yang digunakan sehari-hari telah dibuat, maka bahasa ini tidak dapat dengan mudah diganti sepenuhnya oleh bahasa pemrograman lain.  Terutama dalam waktu singkat. </p><br><p>  Bahasa pemrograman yang sukses akan terus digunakan selama bertahun-tahun.  Dan kemungkinan besar akan berkembang. </p><br><p>  Dan evolusi bahasa pemrograman menyiratkan perluasan bahasa dengan fitur-fitur baru.  Yang tidak bisa dihindari, karena  kemajuan tidak berhenti.  Orang-orang datang dengan cara yang lebih mudah untuk menyelesaikan masalah yang diketahui.  Menghadapi tugas-tugas baru, yang membutuhkan kemampuan ekspresif tambahan dari bahasa pemrograman.  Dan, karena bahasa pemrograman hanyalah alat, orang-orang bergerak menuju peningkatan alat mereka. </p><br><p>  Yang berarti bahwa bahasa pemrograman yang banyak digunakan hanya ditakdirkan untuk menjadi lebih dan lebih banyak dan lebih kompleks, dalam perjalanan perkembangan mereka memperoleh peluang yang bahkan tidak dibahas pada awalnya. </p><br><p>  Pada prinsipnya, Bjarn Straustrup berbicara tentang ini sejak lama.  Dan bahkan apa yang saya sendiri telah amati selama hampir tiga puluh tahun menegaskan kata-kata Straustrup.  Katakanlah, Jawa modern sudah sangat berbeda dari Jawa 1.0 tahun 1995.  Bahasa C # menunjukkan evolusi yang bahkan lebih mengesankan dari klon yang sukses di Jawa pertama ke bahasa mainstream yang paling ekspresif yang cocok untuk digunakan oleh programmer Hindu (terlepas dari kebangsaan mereka). </p><br><p>  Tetapi contoh yang paling mencolok bagi saya masih bahasa Go.  Yang, sudah di abad ke-21, mereka mulai lakukan dengan sengaja membuang banyak hal yang telah membuktikan diri selama puluhan tahun digunakan secara luas dalam berbagai bahan nuklir.  Dan yang terima kasih, termasuk ini, telah menjadi populer.  Tapi, bagaimanapun, hidup mengambil korban dan Go dipaksa untuk menambahkan sesuatu yang awalnya sengaja ditolak oleh para penulis - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">alat untuk pemrograman umum (alias templat / generik)</a> . </p><br><p>  Jadi bahasa pemrograman populer berkembang menuju pengembangan kemampuan mereka.  Dan itu berarti komplikasi.  Karena fitur baru perlu ditambahkan agar tidak serius memecahkan kode yang sudah ditulis.  Untuk kisah epik dengan Python versi kedua dan ketiga menjadi contoh yang baik, yang sedikit berani mengulangi. </p><br><h2>  Apakah ini sangat buruk? </h2><br><p>  Sisi negatif dari kompleksitas yang semakin meningkat dari bahasa pemrograman (terutama bahasa seperti C ++) nampak jelas: ambang input terlalu tinggi.  Terlalu banyak waktu yang perlu dihabiskan untuk mempelajari bahasa untuk mulai mengeluarkan kode kualitas yang dapat diterima dalam kerangka waktu yang dapat diterima.  Apa yang membuat pengembangan dalam bahasa pemrograman yang kompleks mahal dan berisiko.  Apa yang terjadi jika satu atau lebih pengembang yang memenuhi syarat meninggalkan proyek?  Seberapa cepat dan mudah menemukan pengganti?  Pertanyaan sulit. </p><br><p>  Di sisi lain, karena bahasa pemrograman adalah alat yang sama untuk merekam niat orang tertentu, seperti, misalnya, ekspresi matematika, adalah tepat untuk menggambar analogi dengan matematika. </p><br><p>  Di sekolah, kita mulai belajar matematika dimulai dengan operasi aritmatika yang paling sederhana.  Kemudian kita beralih ke hal-hal yang lebih kompleks: fraksi, derajat, dan akar.  Kemudian kita melangkah lebih jauh, menuju logaritma.  Kemudian kita mengambil kalkulus integral kecil.  Begitu pula dengan geometri. </p><br><p>  Akibatnya, lulusan sekolah menengah normal memiliki peralatan matematika tertentu, yang mungkin berlebihan untuk satu orang.  Saya tidak akan salah jika saya berasumsi bahwa banyak orang sepulang sekolah tidak pernah perlu menghitung apa pun menggunakan logaritma atau mengambil integral. </p><br><p>  Namun demikian, perangkat matematika, yang dikuasai di sekolah menengah, tidak dapat dibandingkan dengan fakta bahwa mahasiswa kemudian akan diberikan kursus dalam matematika yang lebih tinggi.  Terutama jika itu adalah siswa dari fakultas matematika atau fisik (dan tidak hanya secara serius mengunduh matematika lebih tinggi dalam banyak spesialisasi). </p><br><p>  Tapi bagaimanapun, tidak terpikir oleh siapa pun untuk menyalahkan matematika karena semakin dalam Anda terjun ke dalamnya, semakin sulit.  Karena jika seseorang dihadapkan dengan bidang kegiatan di mana ia membutuhkan TFKP, maka tidak ada yang dapat dilakukan, TFKP harus belajar.  Betapapun sulitnya itu.  Ya dan ya, itu normal bahwa tidak semua orang berhasil. </p><br><p>  Sebenarnya, hal yang sama dengan bahasa pemrograman. </p><br><p>  Jika Anda perlu memecahkan masalah yang relatif sederhana, maka Anda punya pilihan: apakah Anda menggunakan bahasa pemrograman yang lebih sederhana, atau Anda menggunakan subset terbatas dari bahasa yang lebih kompleks.  Tetapi jika Anda dihadapkan dengan tugas yang sulit (atau kondisi spesifik untuk solusinya), maka Anda mungkin tidak punya pilihan sama sekali: kompleksitas memecahkan masalah ini dalam bahasa "sederhana" mungkin terlalu besar. </p><br><h2>  Berbicara tentang tugas </h2><br><p>      ,        (..  ,  ,        ,  ..,  ..),          ,         . </p><br><p>       .        , ..         ,        .  ,  ,     . ,  ,      ,        .  , ,     ,       . </p><br><p>  ,     ,  Go, Python, Ruby  PHP,  ,      ,      ,  .  ,  ,         ,  ,          .           . </p><br><p> ,        ,     ,    ,    .  ,  25           GUI     ,          .        ,   25      . </p><br><p>     ,          ,    ,        .    ,     /      ,        ,      . </p><br><p>  ,   , ,         ,       ,  C++, Scala  Haskell. ,   ,       .   ,  ,           Go   C. </p><br><p>             .   . ,    ,    :        ,    ,      . ,  -    C++,     . .., -,    C++   . , -,        C++   ,    ,   . </p><br><h1>  Total </h1><br><p> ,      ?  : </p><br><ul><li> -,  . ,    ,   ,    « »,      1960-1970- ,   .     ,       .      ,   .        (     ).   -       X,             ,   X   . ,        C.  ,      .     . ,    —    .           ; </li><li> -,          ,     40 ,       .   ,  ,    .    , ..     ,     ,     ; </li><li> -,       . -   Ruby/Python, -  Go, -      Java.   -   Rust-, C++, Scala  Haskell-.          ,       .     - ,       «  »,            .   . </li></ul><br><p>  , , - :      ,      -     .       - .       ,    (  ,           ,   ).   ,       - ,   ,     :   ,   ,      -.      ;) </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id463745/">https://habr.com/ru/post/id463745/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id463733/index.html">Mesh VS WiFi: apa yang harus dipilih untuk nirkabel?</a></li>
<li><a href="../id463735/index.html">Qrator memfilter sistem pengiriman konfigurasi jaringan</a></li>
<li><a href="../id463737/index.html">Pemecahan masalah dengan pwnable.kr 21 - horcuxes. Pemrograman Berorientasi Kembali dan Rantai ROP</a></li>
<li><a href="../id463739/index.html">Sistem Manajemen Konfigurasi Jaringan Filter Qrator</a></li>
<li><a href="../id463741/index.html">Firefox (sudah diperbaiki) dan Chrome memungkinkan Anda menggunakan header Alt-Svc untuk memindai port intranet</a></li>
<li><a href="../id463747/index.html">Akses properti di dalam bidang Jsonb untuk Npgsql</a></li>
<li><a href="../id463749/index.html">Scrum vs Kanban: Tetap Tenang dan Pilih Yang Cocok Untukmu</a></li>
<li><a href="../id463751/index.html">iOS 13: Apa yang Anda butuhkan dan apa yang benar-benar tidak perlu Anda lakukan saat mengembangkan untuk OS baru</a></li>
<li><a href="../id463753/index.html">PVS-Studio Mengunjungi Apache Hive</a></li>
<li><a href="../id463755/index.html">Perbedaan antara "Juni", "Tengah" dan "Senior". Dan apa yang harus dilakukan untuk naik satu level</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>