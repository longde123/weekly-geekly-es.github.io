<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🉑 🈶 👈🏼 Métodos de optimización de código para Redd. Parte 1: efecto caché 👵🏾 🎸 💇🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En el primer artículo de la serie, promoví activamente la idea de que el desarrollo de código para Redd es secundario, y el proyecto principal es prim...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Métodos de optimización de código para Redd. Parte 1: efecto caché</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467353/"> En el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">primer artículo de la</a> serie, promoví activamente la idea de que el desarrollo de código para Redd es secundario, y el proyecto principal es primario.  Redd es una herramienta auxiliar, por lo que dedicar mucho tiempo a ello es incorrecto.  Es decir, el desarrollo para ello debería ir rápidamente.  Pero esto no significa en absoluto que los programas resultantes no sean óptimos.  En realidad, si no están optimizados en absoluto, entonces solo la potencia del equipo no será suficiente para implementar el sistema de prueba deseado.  Por lo tanto, el proceso, como dije, debe ser rápido y fácil, pero el desarrollador siempre debe tener en cuenta algunos principios de optimización. <br><br><img src="https://habrastorage.org/webt/ky/gv/ge/kygvge7bilfbzntymcu3qzlk4mq.jpeg"><br><br>  Se han publicado libros gruesos sobre optimización.  Algunos de estos libros son útiles, algunos ya están desactualizados, ya que los principios descritos en ellos han migrado durante mucho tiempo a la etapa de optimización automática al crear código ... Pero hay algunas cosas que no tienen valor al desarrollar programas ordinarios para procesadores ordinarios, por lo que los libros típicos generalmente no describen .  Ahora comenzaremos a considerarlos. <br><a name="habracut"></a><br><h2>  Introduccion </h2><br>  Hasta ahora, escribí sobre el principio de "un problema: un artículo".  Y los artículos se obtuvieron en el formato de conferencias, afectando varios temas a la vez, unidos por un problema común.  Pero algunos lectores dijeron que dichos artículos no podían leerse de una vez.  Por lo tanto, ahora trataremos de hablar sobre un solo tema en un artículo.  También es más fácil para mí escribir así.  Veamos, de repente será más conveniente para todos. <br><br>  Además, deleita a los misteriosos mineros.  Si un artículo se publica por la mañana, entonces el primer inconveniente llega después de un período de tiempo durante el cual es imposible leer el texto completo.  Alguien hace esto puramente desde el principio, ahorrando solo temas sobre UDB y balalaika.  Si la publicación no fue en la mañana, sino en la tarde, entonces arroja un signo negativo con retraso.  El segundo menos llega durante el día (y ese amigo, por cierto, también se salvó de temas sobre UDB y sobre balalaika).  Habrá más artículos en el nuevo formato, lo que significa que habrá momentos más agradables para esta pareja (aunque, personalmente para mí, como autor, se vuelve triste e insultante por sus acciones). <br><br>  Artículos anteriores de la serie: <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Desarrollo del "firmware" más simple para FPGAs instalados en Redd, y depuración utilizando la prueba de memoria como ejemplo.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Desarrollo del "firmware" más simple para FPGAs instalados en Redd.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 2. Código del programa.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Desarrollo de su propio núcleo para incrustar en un sistema de procesador basado en FPGA.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Desarrollo de programas para el procesador central Redd sobre el ejemplo de acceso a la FPGA.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Los primeros experimentos utilizando el protocolo de transmisión en el ejemplo de la conexión de la CPU y el procesador en el FPGA del complejo Redd.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Merry Quartusel, o cómo el procesador ha llegado a tal vida.</a> </li></ol><br><h2>  Comportamiento misterioso de un sistema típico. </h2><br>  Hagamos el sistema de procesador más simple al incluir un reloj, un procesador Nios II / f, un controlador SDRAM y un puerto de salida.  Así es como se ve este sistema Spartan en Platform Designer <br><br><img src="https://habrastorage.org/webt/mr/qt/hm/mrqthmfrz5vespqetdjwcguvclu.png"><br><br>  El código del programa contendrá solo una función, cuyo cuerpo parece algo extraño, ya que contiene muchas líneas repetidas, pero esto nos será útil. <br><br><div class="spoiler">  <b class="spoiler_title">El código está oculto porque es demasiado estricto.</b> <div class="spoiler_text"><pre><code class="plaintext hljs">extern "C" { #include "sys/alt_stdio.h" #include &lt;system.h&gt; #include &lt;io.h&gt; } void MagicFunction() { while (1) { IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); } } int main() { MagicFunction(); /* Event loop never exits. */ while (1); return 0; }</code> </pre> <br></div></div><br>  Pon un punto de interrupción en la última de las líneas: <br><br><pre> <code class="plaintext hljs">IOWR (PIO_0_BASE,0,0);</code> </pre> <br>  en <b>MagicFunction</b> y ejecuta el programa.  ¿Qué obtuvimos a la salida del puerto?  Impulsos muy desiguales: <br><br><img src="https://habrastorage.org/webt/n7/qt/qj/n7qtqjkwhcioypjv02_7ir7k3es.png"><br><br>  El horror  Pues si.  Sin embargo, haga clic en "iniciar" nuevamente para completar otra iteración del ciclo.  Y ahora a la salida vemos un hermoso meandro suave: <br><br><img src="https://habrastorage.org/webt/ez/nz/4k/eznz4kkvo8smagbksijd0tt4bso.png"><br><br>  Otra iteración.  Y uno más ... Meandro estable.  Eliminamos el punto de interrupción y observamos el trabajo en dinámica: ya no hay tales interrupciones.  Hay ráfagas interminables de pulsos. <br><br>  ¿Por qué tuvimos impulsos rotos en el primer pase?  Un accidente?  No  Dejamos de depurar y lo iniciamos nuevamente.  Y nuevamente tenemos impulsos desgarrados.  Las brechas siempre surgen a la entrada del programa. <br><br><h2>  La pista está en el caché </h2><br>  En realidad, la solución a este comportamiento radica en el caché.  Nuestro programa está almacenado en SDRAM.  Obtener código de SDRAM no es rápido.  Es necesario dar un comando de lectura, es necesario dar una dirección, y la dirección consta de dos partes.  Tienes que esperar un poco.  Solo entonces el microcircuito dará los datos.  Para evitar tales demoras cada vez, el microcircuito puede emitir no una, sino varias palabras consecutivas.  No consideraremos los gráficos de tiempo hoy, lo pospondremos para los siguientes artículos. <br><br>  Bueno, en el lado del núcleo del procesador, se creó un caché de forma predeterminada.  Aquí están sus configuraciones: <br><br><img src="https://habrastorage.org/webt/n3/3b/cx/n33bcxjyhe2v_lvaiuqafjzvdoc.png"><br><br>  En realidad, los retrasos ocurren en el momento en que se está cargando por lotes las instrucciones de SDRAM a la caché.  En las próximas iteraciones, el código ya está en la memoria caché, por lo que ya no es necesario cargarlo. <br><br>  El oscilograma muestra un promedio de 8 entradas por puerto (una unidad se escribe 4 veces y cero se escribe 4 veces) por operación de carga.  Un registro: un comando de ensamblador, que se puede encontrar eligiendo el elemento del menú Ventana-&gt; Mostrar vista-&gt; Otro: <br><br><img src="https://habrastorage.org/webt/p-/xp/nh/p-xpnhdsqsklxoqa_ityjp2u-hu.png"><br><br>  y luego Depuración-&gt; Desmontaje: <br><br><img src="https://habrastorage.org/webt/2n/7c/in/2n7cinmvmt04ov-_ibduzwcv9zo.png"><br><br>  Aquí están nuestras cadenas y el código de ensamblaje correspondiente: <br><br><img src="https://habrastorage.org/webt/_q/ox/wz/_qoxwz5u9qkgsn4gd5t0yuy4djw.png"><br><br>  8 equipos de 4 bytes cada uno.  Obtenemos 32 bytes por línea de caché ... Miramos nuestro archivo de ayuda favorito C: \ Work \ CachePlay \ software \ CachePlay_bsp \ system.h y vemos: <br><br><pre> <code class="plaintext hljs">#define ALT_CPU_ICACHE_LINE_SIZE 32 #define ALT_CPU_ICACHE_LINE_SIZE_LOG2 5</code> </pre><br>  Los datos prácticamente calculados coincidieron con la teoría.  Además, de la documentación se deduce que el tamaño de la cadena no se puede cambiar.  Siempre es igual a treinta y dos bytes. <br><br><h2>  Un experimento un poco más complicado </h2><br>  Intentemos provocar un caché para reiniciar durante el trabajo establecido.  Cambiemos un poco el programa de prueba.  Hacemos dos funciones y las llamamos desde la función <b>main ()</b> , colocando un bucle en ella.  No estableceré un punto de interrupción.  Por cierto, si hace que las funciones sean completamente idénticas, el optimizador lo notará y eliminará una de ellas, por lo que al menos una línea, y deberían diferir ... Esto es lo que escribí al principio: los optimizadores son muy inteligentes ahora. <br><br><div class="spoiler">  <b class="spoiler_title">Código de programa de prueba modificado.</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">extern "C" { #include "sys/alt_stdio.h" #include &lt;system.h&gt; #include &lt;io.h&gt; } void MagicFunction1() { IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); } void MagicFunction2() { IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); } int main() { while (1) { MagicFunction1(); MagicFunction2(); } /* Event loop never exits. */ while (1); return 0; }</code> </pre><br></div></div><br>  Obtenemos un resultado bastante hermoso, filmado ya en el modo establecido del programa. <br><br><img src="https://habrastorage.org/webt/6q/ww/xa/6qwwxao-phas4ippal7a1hrhlik.png"><br><br>  Y ahora colocaremos alguna función nueva entre este par de funciones, y no la llamaremos, solo se colocará entre ellas en la memoria.  Ahora intentaré hacer que ocupe más espacio ... El tamaño del caché es de 4 kilobytes, por lo que lo haremos igual a cuatro kilobytes ... Simplemente inserte 1024 NOP, cada uno de los cuales tiene un tamaño de 4 bytes.  Mostraré el final de la primera función, la nueva función y el comienzo de la segunda, para que quede claro cómo cambia el programa: <br><br><pre> <code class="plaintext hljs">... IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); } #define Nops4 __asm__ volatile ("nop");__asm__ volatile ("nop");__asm__ volatile ("nop");__asm__ volatile ("nop"); #define Nops16 Nops4 Nops4 Nops4 Nops4 #define Nops64 Nops16 Nops16 Nops16 Nops16 #define Nops256 Nops64 Nops64 Nops64 Nops64 #define Nops1024 Nops256 Nops256 Nops256 Nops256 volatile void FuncBetween() { Nops1024 } void MagicFunction2() { IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); IOWR (PIO_0_BASE,0,1); IOWR (PIO_0_BASE,0,0); ...</code> </pre><br>  La lógica del programa no ha cambiado, pero cuando se ejecuta ahora tenemos pulsos rotos <br><br><img src="https://habrastorage.org/webt/20/on/rq/20onrqyrzqtcdeiqjiulcaa0yuw.png"><br><br>  Haré una pregunta ingenua: salimos volando del caché y ahora, a medida que se amplía la brecha, ¿siempre habrá carga?  ¡Para nada!  Cambie el tamaño de la función "mala", haciéndola igual a, digamos, cinco kilobytes.  Cinco más que cuatro, ¿seguimos volando?  O no?  Reemplace el inserto con esto: <br><br><pre> <code class="plaintext hljs">volatile void FuncBetween() { Nops1024 Nops256 }</code> </pre><br>  Y de nuevo obtenemos la belleza: <br><br><img src="https://habrastorage.org/webt/cz/hh/up/czhhupgwhqdrrddlaeyg8kv50yg.png"><br><br>  Entonces, ¿qué determina la necesidad de cargar código en el caché?  ¿Podemos predecir algo, o cada vez que necesitamos mirar el hecho?  Profundicemos en la teoría, con la que nos ayuda la <b>Guía de referencia del procesador Nios II</b> . <br><br><h2>  Poco de teoría </h2><br>  Así es como se divide el campo de dirección en el procesador: <br><br><img src="https://habrastorage.org/webt/ba/kw/5_/bakw5_bz0uipk2kzstdfcjuiuvy.png"><br><br>  Como puede ver, la dirección se divide en tres partes.  Etiqueta, línea y offset.  La dimensión del campo de desplazamiento es constante para el procesador Nios II y siempre es de cinco bits, es decir, puede direccionar 32 bytes.  La dimensión del campo "línea" depende del tamaño de la memoria caché especificada al configurar el procesador.  En la figura anterior, es bastante grande.  No sé por qué el documento tiene una dimensión tan grande.  Tenemos un tamaño de caché de 4 kilobytes, lo que significa que la profundidad total de bits y el desplazamiento son de 12 bits.  5 bits toman un desplazamiento, para una línea queda 12-5 = 7 bits. <br><br>  Obtenemos una cierta tabla de 128 filas, cada una de 32 bytes de longitud.  Daré, digamos, las primeras 6 líneas: <br><div class="scrollable-table"><table><tbody><tr><th>  Campo de etiqueta </th><th>  Campo "cadena" </th><th>  LSB </th><th>  Donde conseguir </th></tr><tr><td>  No importante </td><td>  0x00 </td><td>  0x000 a 0x01F </td><td>  A la línea 0 del caché </td></tr><tr><td>  No importante </td><td>  0x01 </td><td>  0x020 a 0x03F </td><td>  Línea 1 caché </td></tr><tr><td>  No importante </td><td>  0x02 </td><td>  0x040 a 0x05F </td><td>  Línea 2 caché </td></tr><tr><td>  No importante </td><td>  0x03 </td><td>  0x060 a 0x07F </td><td>  Line 3 Cache </td></tr><tr><td>  No importante </td><td>  0x04 </td><td>  0x080 a 0x09F </td><td>  Línea 4 caché </td></tr><tr><td>  No importante </td><td>  0x05 </td><td>  0x0A0 a 0x0BF </td><td>  Line 5 Cache </td></tr><tr><td>  ... </td><td>  ... </td><td>  ... </td><td>  ... </td></tr><tr><td>  No importante </td><td>  0x7F </td><td>  0xFE0 a 0xFFF </td><td>  a la línea 127 del caché </td></tr></tbody></table></div><br>  Y entonces recurrimos a la dirección 0x123 <b>004</b> .  Si descarta la parte "no importante", el par "línea + desplazamiento" es 0x004.  Este es el rango de fila cero.  Los datos se cargarán en esta línea.  Y el trabajo adicional con datos del rango 0x123 <b>000</b> a 0x123 <b>01F</b> funcionará a través de la memoria caché.  ¿En qué condiciones se sobrecargará la cadena?  Al acceder a cualquier otra dirección que termine en el rango de 0x000 a 0x01F.  Bueno, es decir, si recurrimos a la dirección 0xABC <b>204</b> , todo permanecerá en su lugar, porque el rango de direcciones más bajas no se superpone con el nuestro.  Y 0xABC <b>804</b> no arruinará nada.  Pero al ejecutar el código desde la dirección 0xABC <b>004, se</b> cargarán nuevos contenidos en la línea de caché.  Y ya la transición a la dirección 0x123 <b>004</b> nuevamente conducirá a una sobrecarga.  Si salta constantemente entre 0xABC <b>004</b> y 0x123 <b>004</b> , se producirá una sobrecarga continua. <br><br>  Tratemos de representar esto en forma de una imagen.  Supongamos que solo tenemos 8 líneas en el caché, es más conveniente colorearlas en diferentes colores.  Haré que el tamaño de línea sea 0x10, es más conveniente pintar las direcciones en la imagen (recuerde que en Nios II real el tamaño de línea siempre es 0x20 bytes).  La memoria late en páginas condicionales que son del mismo tamaño que las líneas de caché.  La página roja de la memoria siempre irá a la línea roja de la memoria caché, de naranja a naranja, y así sucesivamente.  En consecuencia, los contenidos antiguos se descargarán. <br><br><img src="https://habrastorage.org/webt/r0/he/sl/r0heslzwbiuxwjprhq4tnf-xela.png"><br><br>  Bueno, en realidad, el comportamiento del programa durante el experimento ahora está claro.  Cuando las funciones se separaron estrictamente por 4 kilobytes, llegaron a páginas de colores similares.  Por lo tanto el código <br><br><pre> <code class="plaintext hljs"> while (1) { MagicFunction1(); MagicFunction2(); }</code> </pre><br>  condujo a la carga de la memoria caché por el bien de uno, luego por otra función.  Y cuando el espacio no era 4, sino 5 kilobytes, las funciones se espaciaban en bloques de diferentes colores.  No hubo conflicto, todo funcionó sin demora. <br><br><h2>  Conclusiones </h2><br>  Cuando leí hace muchos años que hay líneas de núcleos Cortex A, Cortex R y Cortex M diseñados para cosas productivas, para trabajar en tiempo real y para trabajar en sistemas baratos, respectivamente, al principio no entendí, pero cuál es, de hecho, la diferencia .  No, los sistemas baratos son comprensibles, pero los dos primeros son ¿cuáles son las diferencias?  Sin embargo, después de jugar el núcleo Cortex A9 disponible en el FPGA Cyclone V SoC, sentí todos los inconvenientes del caché cuando trabajaba con hierro.  Hay muchos cachés en el núcleo de Cortex A ... Y la previsibilidad del comportamiento del sistema es casi nula.  Pero el caché mejora el rendimiento.  A veces es mejor si todo funciona no predeciblemente preciso al ritmo, pero rápido que previsiblemente lento.  Esto es especialmente cierto para la informática o, por ejemplo, para mostrar gráficos. <br><br>  Pero el problema principal no es que surjan las cosas descritas en el artículo, sino que el comportamiento del sistema cambiará de un ensamblaje a otro, ya que nadie sabe en qué direcciones caerá la función después de agregar o eliminar código.  Hace 15 años, en el proyecto del emulador de consola de juegos Sega para un decodificador de televisión por cable, tuvimos que hacer un preprocesador completo que, después de cada edición, moviera las funciones que emulaban los comandos del ensamblador de Motorola en el núcleo SPARC-8 para que su tiempo de ejecución fuera siempre el mismo (allí debido a la caché, de lo contrario todo nadó mucho). <br><br>  Pero, ¿cuándo necesitamos previsibilidad?  Por supuesto, al crear diagramas de tiempo mediante programación (recuerde que, en general, en los FPGA también es posible confiar esto al hardware, pero hay algunos detalles con un desarrollo rápido).  Pero cuando se trabaja con algoritmos computacionales, no es tan importante.  A menos que el algoritmo sea complejo, debe asegurarse de que las secciones críticas no causen una sobrecarga constante de caché.  En la mayoría de los casos, el caché no crea problemas y aumenta la productividad. <br><br>  En el próximo artículo, veremos cómo predecir funciones críticas en la memoria no almacenable en caché, que siempre se ejecuta a la velocidad máxima, y ​​discutiremos las ventajas implícitas de los FPGA sobre los sistemas estándar que surgen de las tecnologías utilizadas en este proceso. <br><br><h2>  Para los mas atentos </h2><br>  Un lector corrosivo puede preguntar: "¿Por qué el oscilograma no se rasgó lo suficiente al insertar cuatro kilobytes de código?"  Todo es simple  Si inserta exactamente 4 kilobytes, obtenemos las siguientes direcciones para colocar funciones en la memoria: <br><br><pre> <code class="plaintext hljs"> MagicFunction1(): 0200006c: movhi r2,1024 02000070: movi r4,1 02000074: addi r2,r2,4096 02000078: stwio r4,0(r2) 92 IOWR (PIO_0_BASE,0,0); 0200007c: mov r3,zero 02000080: stwio r3,0(r2) 93 IOWR (PIO_0_BASE,0,1); ... 120 IOWR (PIO_0_BASE,0,0); 020000f0: stwio r3,0(r2) 020000f4: ret 131 Nops1024 FuncBetween(): 020000f8: nop 020000fc: nop 02000100: nop 02000104: nop ... 020010ec: nop 020010f0: nop 020010f4: nop 020010f8: ret 135 IOWR (PIO_0_BASE,0,0); MagicFunction2(): 020010fc: movhi r2,1024 02001100: mov r4,zero 02001104: addi r2,r2,4096</code> </pre><br>  Para una forma de onda idealmente mala, debe insertar NOP para que 4 kilobytes sea su volumen junto con la longitud de la función <b>MagicFunction1 ()</b> .  No importa lo que vaya para una hermosa foto!  Cambie la inserción a esto: <br><br><pre> <code class="plaintext hljs">volatile void FuncBetween() { Nops256 Nops256 Nops256 Nops64 Nops64 Nops64 Nops16 Nops16 }</code> </pre><br>  Una y otra vez presto atención a que el inserto no recibe control.  Simplemente cambia la posición de las funciones en la memoria entre sí.  Con este inserto, obtenemos el terrible horror deseado: <br><br><img src="https://habrastorage.org/webt/7d/by/om/7dbyomefuy0kgtjxmnysanc_lxm.png"><br><br>  Me pareció que esos detalles insertados en el texto principal distraerían a todos del texto principal, así que los puse en una posdata. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/467353/">https://habr.com/ru/post/467353/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../467339/index.html">Y de nuevo, el día 256 del año.</a></li>
<li><a href="../467343/index.html">Por qué dejé de trabajar como freelance: impresiones del desarrollador de backend después de 2 años de "libertad"</a></li>
<li><a href="../467345/index.html">Visite los blogs de TI y las 4 capas de capacitación: una entrevista con Sergei Abdulmanov de Mosigra</a></li>
<li><a href="../467347/index.html">Libro "Creación de contratos inteligentes de Solidez para la cadena de bloques Ethereum. Guía práctica</a></li>
<li><a href="../467349/index.html">Traslado de un programador a Estonia: trabajo, dinero y costo de vida.</a></li>
<li><a href="../467355/index.html">Entrevista con el investigador de mercado y las tendencias de desarrollo de software en Europa Central y Oriental, Eugene Schwab-Chesaru</a></li>
<li><a href="../467357/index.html">PVS-Studio en las nubes: Azure DevOps</a></li>
<li><a href="../467359/index.html">PVS-Studio va a las nubes: Azure DevOps</a></li>
<li><a href="../467361/index.html">Nos olvidamos de la delegación en JavaScript. Delegación de eventos en reaccionar</a></li>
<li><a href="../467363/index.html">Uso de funciones de pérdida personalizadas y métricas de calidad de aprendizaje en Keras</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>