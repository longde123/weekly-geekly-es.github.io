<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèº‚Äçüç≥ ü•ì üëºüèæ Warum, warum und wann ValueTask verwendet werden soll üè° ü§† üöû</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Diese √úbersetzung entstand dank des guten Kommentars 0x1000000 . 
 




 Mit .NET Framework 4 wurde der System.Threading.Tasks-Bereich und damit die T...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Warum, warum und wann ValueTask verwendet werden soll</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/458828/"><p>  <sup>Diese √úbersetzung entstand dank des guten Kommentars <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">0x1000000</a> .</sup> <sup><br></sup> </p><p><img src="https://habrastorage.org/webt/4t/kr/wh/4tkrwhp_br-sobqvgwwyimflsjq.jpeg" alt="Bild"></p><br><p>  Mit .NET Framework 4 wurde der System.Threading.Tasks-Bereich und damit die Task-Klasse eingef√ºhrt.  Dieser Typ und die daraus generierte Task &lt;TResult&gt; haben lange gewartet, bis sie von den Standards in .NET als Schl√ºsselaspekte des asynchronen Programmiermodells erkannt werden, das in C # 5 mit seinen async / await-Anweisungen eingef√ºhrt wurde.  In diesem Artikel werde ich √ºber neue Arten von ValueTask / ValueTask &lt;TResult&gt; sprechen, mit denen die Leistung asynchroner Methoden in F√§llen verbessert werden soll, in denen der Overhead der Speicherzuweisung ber√ºcksichtigt werden sollte. </p><a name="habracut"></a><br><h3 id="task">  Aufgabe </h3><br><p> Die Aufgabe spielt in verschiedenen Rollen, aber die Hauptaufgabe ist das ‚ÄûVersprechen‚Äú (Versprechen), ein Objekt, das den m√∂glichen Abschluss einer Operation darstellt.  Sie initiieren eine Operation und erhalten ein Task-Objekt daf√ºr, das ausgef√ºhrt wird, wenn die Operation abgeschlossen ist. Dies kann im synchronen Modus als Teil der Initialisierung der Operation (z. B. Empfangen von Daten, die sich bereits im Puffer befinden) im asynchronen Modus mit Ausf√ºhrung zum Zeitpunkt erfolgen Sie erhalten Task (Daten werden nicht aus dem Puffer empfangen, sondern sehr schnell) oder im asynchronen Modus, aber nachdem Sie bereits Task haben (Daten von einer Remote-Ressource empfangen).  Da der Vorgang asynchron beendet werden kann, blockieren Sie entweder den Ausf√ºhrungsfluss und warten auf das Ergebnis (wodurch die Asynchronit√§t des Aufrufs h√§ufig bedeutungslos wird) oder erstellen eine R√ºckruffunktion, die nach Abschluss des Vorgangs aktiviert wird.  In .Net 4 wird die Erstellung eines R√ºckrufs durch die ContinueWith-Methoden des Task-Objekts implementiert, die dieses Modell deutlich demonstrieren, indem sie eine Delegatfunktion akzeptieren, um es auszuf√ºhren, nachdem die Task ausgef√ºhrt wurde: </p><br><pre><code class="plaintext hljs">SomeOperationAsync().ContinueWith(task =&gt; { try { TResult result = task.Result; UseResult(result); } catch (Exception e) { HandleException(e); } });</code> </pre> <br><p>  In .NET Framework 4.5 und C # 5 k√∂nnen Task-Objekte einfach vom Operator await aufgerufen werden, wodurch das Ergebnis einer asynchronen Operation leicht abgerufen werden kann. Der generierte Code, der f√ºr die oben genannten Optionen optimiert ist, funktioniert in allen F√§llen ordnungsgem√§√ü, wenn die Operation im synchronen Modus, schnell asynchron oder ausgef√ºhrt wird asynchron mit R√ºckruf: </p><br><pre> <code class="plaintext hljs">TResult result = await SomeOperationAsync(); UseResult(result);</code> </pre> <br><p>  Aufgabe ist eine sehr flexible Klasse und hat eine Reihe von Vorteilen.  Sie k√∂nnen beispielsweise mehrmals auf eine beliebige Anzahl von Verbrauchern gleichzeitig warten.  Sie k√∂nnen es in eine Sammlung (ein W√∂rterbuch) einf√ºgen, damit es in Zukunft wiederholt abgewartet werden kann, um es als Cache f√ºr die Ergebnisse asynchroner Aufrufe zu verwenden.  Sie k√∂nnen die Ausf√ºhrung blockieren, w√§hrend Sie auf den Abschluss der Aufgabe warten, falls erforderlich.  Au√üerdem k√∂nnen Sie verschiedene Vorg√§nge auf Aufgabenobjekte schreiben und anwenden (manchmal auch als ‚ÄûKombinatoren‚Äú bezeichnet), z. B. ‚ÄûWenn vorhanden‚Äú, um asynchron auf den ersten Abschluss mehrerer Aufgaben zu warten. <br>  Diese Flexibilit√§t wird jedoch im h√§ufigsten Fall √ºberfl√ºssig: Rufen Sie einfach die asynchrone Operation auf und warten Sie, bis die Aufgabe abgeschlossen ist: </p><br><pre> <code class="plaintext hljs">TResult result = await SomeOperationAsync(); UseResult(result);</code> </pre> <br><p>  Hier m√ºssen wir nicht mehrmals auf die Ausf√ºhrung warten.  Wir m√ºssen nicht sicherstellen, dass die Erwartungen wettbewerbsf√§hig sind.  Wir m√ºssen keine synchrone Verriegelung durchf√ºhren.  Wir werden keine Kombinatoren schreiben.  Wir warten nur darauf, dass das Versprechen eines asynchronen Vorgangs abgeschlossen wird.  Am Ende schreiben wir auf diese Weise synchronen Code (z. B. TResult result = SomeOperation ();) und dieser wird normalerweise in async / await √ºbersetzt. </p><br><p>  Dar√ºber hinaus weist Task eine potenzielle Schw√§che auf, insbesondere wenn eine gro√üe Anzahl von Instanzen erstellt wird und ein hoher Durchsatz und eine hohe Leistung wichtige Anforderungen sind - Task ist eine Klasse.  Dies bedeutet, dass jede Operation, die eine Aufgabe ben√∂tigt, gezwungen ist, ein Objekt zu erstellen und zu platzieren. Je mehr Objekte erstellt werden, desto mehr Arbeit ist f√ºr den Garbage Collector (GC) erforderlich, und diese Arbeit verbraucht Ressourcen, die wir f√ºr etwas mehr ausgeben k√∂nnten n√ºtzlich. </p><br><p>  Die Laufzeit- und Systembibliotheken tragen in vielen Situationen zur Minderung dieses Problems bei.  Wenn wir zum Beispiel eine Methode wie diese schreiben: </p><br><pre> <code class="plaintext hljs">public async Task WriteAsync(byte value) { if (_bufferedCount == _buffer.Length) { await FlushAsync(); } _buffer[_bufferedCount++] = value; }</code> </pre> <br><p>  In der Regel ist gen√ºgend freier Speicherplatz im Puffer vorhanden, und die Operation wird synchron ausgef√ºhrt.  In diesem Fall m√ºssen Sie nichts mit der Aufgabe tun, die zur√ºckgegeben werden soll. Da es keinen R√ºckgabewert gibt, wird Task als √Ñquivalent einer synchronen Methode verwendet, die einen leeren Wert zur√ºckgibt (void).  Daher kann die Umgebung einfach eine nicht generische Aufgabe zwischenspeichern und sie als Ergebnis der Ausf√ºhrung f√ºr jede asynchrone Methode, die synchron beendet wird, immer wieder verwenden (dieser zwischengespeicherte Singleton kann √ºber Task.CompletedTask abgerufen werden).  Oder Sie schreiben zum Beispiel: </p><br><pre> <code class="plaintext hljs">public async Task&lt;bool&gt; MoveNextAsync() { if (_bufferedCount == 0) { await FillBuffer(); } return _bufferedCount &gt; 0; }</code> </pre> <br><p>  Erwarten Sie im Allgemeinen, dass sich die Daten bereits im Puffer befinden. Die Methode √ºberpr√ºft daher einfach den Wert von _bufferedCount, stellt fest, dass er gr√∂√üer als 0 ist, und gibt true zur√ºck.  und nur wenn sich noch keine Daten im Puffer befinden, m√ºssen Sie eine asynchrone Operation ausf√ºhren.  Und da es nur zwei m√∂gliche Ergebnisse vom Typ Boolean gibt (true und false), gibt es nur zwei m√∂gliche Task-Objekte, die zur Darstellung dieser Ergebnisse ben√∂tigt werden. Die Umgebung kann diese Objekte zwischenspeichern und mit dem entsprechenden Wert zur√ºckgeben, ohne Speicher zuzuweisen.  Nur im Falle eines asynchronen Abschlusses muss die Methode eine neue Aufgabe erstellen, da diese zur√ºckgegeben werden muss, bevor das Ergebnis der Operation bekannt ist. <br></p><p>  Die Umgebung bietet Caching f√ºr einige andere Typen, es ist jedoch unrealistisch, alle m√∂glichen Typen zwischenzuspeichern.  Zum Beispiel die folgende Methode: </p><br><pre> <code class="plaintext hljs">public async Task&lt;int&gt; ReadNextByteAsync() { if (_bufferedCount == 0) { await FillBuffer(); } if (_bufferedCount == 0) { return -1; } _bufferedCount--; return _buffer[_position++]; }</code> </pre> <br><p>  wird auch oft synchron ausgef√ºhrt.  Im Gegensatz zu einer Variante mit einem Ergebnis vom Typ Boolean gibt diese Methode Int32 zur√ºck, das ungef√§hr 4 Milliarden Werte hat, und das Zwischenspeichern aller Varianten von Task &lt;int&gt; erfordert Hunderte von Gigabyte Speicher.  Die Umgebung bietet einen kleinen Cache f√ºr die Aufgabe &lt;int&gt;, aber einen sehr begrenzten Satz von Werten. Wenn diese Methode beispielsweise synchron (die Daten befinden sich bereits im Puffer) mit dem R√ºckgabewert 4 beendet wird, handelt es sich um eine zwischengespeicherte Aufgabe. Wenn der Wert 42 zur√ºckgegeben wird, m√ºssen Sie einen neuen erstellen Task &lt;int&gt;, √§hnlich wie beim Aufrufen von Task.FromResult (42). </p><br><p>  Viele Bibliotheksmethoden versuchen dies zu gl√§tten, indem sie ihren eigenen Cache bereitstellen.  Beispielsweise endet eine √úberlastung in .NET Framework 4.5 der MemoryStream.ReadAsync-Methode immer synchron, wenn Daten aus dem Speicher gelesen werden.  ReadAsync gibt eine Task &lt;int&gt; zur√ºck, wobei ein Int32-Ergebnis angibt, wie viele Bytes gelesen wurden.  Diese Methode wird h√§ufig in einer Schleife verwendet, h√§ufig mit der gleichen erforderlichen Anzahl von Bytes f√ºr jeden Aufruf, und h√§ufig wird dieser Bedarf vollst√§ndig erf√ºllt.  Bei wiederholten Aufrufen von ReadAsync ist zu erwarten, dass die Task &lt;int&gt; synchron mit demselben Wert wie im vorherigen Aufruf zur√ºckgegeben wird.  Daher erstellt ein MemoryStream einen Cache f√ºr ein Objekt, das beim letzten erfolgreichen Aufruf zur√ºckgegeben wurde.  Wenn das Ergebnis beim n√§chsten Aufruf wiederholt wird, wird das zwischengespeicherte Objekt zur√ºckgegeben. Wenn nicht, erstellen Sie ein neues Objekt mit Task.FromResult, speichern Sie es im Cache und geben Sie es zur√ºck. </p><br><p>  Es gibt jedoch viele andere F√§lle, in denen die Operation synchron ausgef√ºhrt wird, das Task &lt;TResult&gt; -Objekt jedoch erstellt werden muss. </p><br><h4 id="valuetasktresult-i-sinhronnoe-vypolnenie">  ValueTask &lt;TResult&gt; und synchrone Ausf√ºhrung </h4><br><p>  All dies erforderte die Implementierung eines neuen Typs in .NET Core 2.0, der in fr√ºheren Versionen von .NET im NuGet System.Threading.Tasks.Extensions: ValueTask &lt;TResult&gt; -Paket verf√ºgbar war. <br>  ValueTask &lt;TResult&gt; wurde in .NET Core 2.0 als Struktur erstellt, die sowohl TResult als auch Task &lt;TResult&gt; umschlie√üen kann.  Dies bedeutet, dass es von der asynchronen Methode zur√ºckgegeben werden kann. Wenn diese Methode synchron und erfolgreich ausgef√ºhrt wird, m√ºssen Sie kein Objekt auf dem Heap platzieren: Sie k√∂nnen diese ValueTask &lt;TResult&gt; -Struktur einfach mit dem Wert TResult initialisieren und zur√ºckgeben.  Nur bei asynchroner Ausf√ºhrung wird das Task &lt;TResult&gt; -Objekt platziert und von ValueTask &lt;TResult&gt; umbrochen (um die Gr√∂√üe der Struktur zu minimieren und den Fall einer erfolgreichen Ausf√ºhrung zu optimieren, platziert die asynchrone Methode, die mit einer nicht unterst√ºtzten Ausnahme endet, auch das Task &lt;TResult&gt; ValueTask &lt;TResult&gt; schlie√üt auch nur Task &lt;TResult&gt; ein und enth√§lt kein zus√§tzliches Feld zum Speichern von Exception. </p><br><p>  Auf dieser Grundlage sollte eine Methode wie MemoryStream.ReadAsync, die jedoch eine ValueTask &lt;int&gt; zur√ºckgibt, sich nicht mit dem Caching befassen, sondern kann wie folgt geschrieben werden: </p><br><pre> <code class="plaintext hljs">public override ValueTask&lt;int&gt; ReadAsync(byte[] buffer, int offset, int count) { try { int bytesRead = Read(buffer, offset, count); return new ValueTask&lt;int&gt;(bytesRead); } catch (Exception e) { return new ValueTask&lt;int&gt;(Task.FromException&lt;int&gt;(e)); } }</code> </pre> <br><h4 id="valuetasktresult-i-asinhronnoe-vypolnenie">  ValueTask &lt;TResult&gt; und asynchrone Ausf√ºhrung </h4><br><p>  Die M√∂glichkeit, eine asynchrone Methode zu schreiben, die synchron abgeschlossen werden kann, ohne dass eine zus√§tzliche Platzierung f√ºr das Ergebnis erforderlich ist, ist ein gro√üer Gewinn.  Aus diesem Grund wurde ValueTask &lt;TResult&gt; in .NET Core 2.0 hinzugef√ºgt, und neue Methoden, die wahrscheinlich in Anwendungen verwendet werden, die Leistung erfordern, werden jetzt mit der R√ºckgabe von ValueTask &lt;TResult&gt; anstelle von Task &lt;TResult&gt; angek√ºndigt.  Wenn wir beispielsweise .NET Core 2.1 eine neue ReadAsync-√úberladung der Stream-Klasse hinzugef√ºgt haben, um Speicher anstelle von Byte [] √ºbergeben zu k√∂nnen, geben wir den ValueTask &lt;int&gt; -Typ zur√ºck.  In dieser Form k√∂nnen Stream-Objekte (bei denen die ReadAsync-Methode sehr h√§ufig synchron ausgef√ºhrt wird, wie im vorherigen Beispiel f√ºr den MemoryStream) mit viel weniger Speicherzuweisung verwendet werden. <br></p><p>  Wenn wir jedoch mit Diensten mit sehr hoher Bandbreite arbeiten, m√∂chten wir dennoch die Speicherzuweisung so weit wie m√∂glich vermeiden, was bedeutet, dass die Speicherzuweisung auch entlang der asynchronen Ausf√ºhrungsroute reduziert und eliminiert wird. <br>  Im Wartemodell ben√∂tigen wir f√ºr jede Operation, die asynchron abgeschlossen wird, die M√∂glichkeit, ein Objekt zur√ºckzugeben, das den m√∂glichen Abschluss der Operation darstellt: Der Aufrufer muss den R√ºckruf umleiten, der am Ende der Operation initiiert wird, und dies erfordert ein eindeutiges Objekt im Heap, das als √úbertragungskanal f√ºr dienen kann diese besondere Operation.  Dies bedeutet gleichzeitig nichts dar√ºber, ob dieses Objekt nach Abschluss des Vorgangs wiederverwendet wird.  Wenn dieses Objekt wiederverwendet werden kann, kann die API einen Cache f√ºr eines oder mehrere dieser Objekte organisieren und f√ºr sequentielle Operationen verwenden, in dem Sinne, dass nicht dasselbe Objekt f√ºr mehrere asynchrone Zwischenoperationen verwendet wird, sondern f√ºr nicht wettbewerbsorientierten Zugriff. <br>  In .NET Core 2.1 wurde die ValueTask &lt;TResult&gt; -Klasse erweitert, um ein √§hnliches Pooling und eine √§hnliche Wiederverwendung zu unterst√ºtzen.  Anstatt nur TResult oder Task &lt;TResult&gt; zu verpacken, kann eine √ºberarbeitete Klasse eine neue IValueTaskSource &lt;TResult&gt; -Schnittstelle umschlie√üen.  Diese Schnittstelle bietet die grundlegenden Funktionen, die erforderlich sind, um eine asynchrone Operation mit einem ValueTask &lt;TResult&gt; -Objekt auf dieselbe Weise wie Task &lt;TResult&gt; zu begleiten: </p><br><pre> <code class="plaintext hljs">public interface IValueTaskSource&lt;out TResult&gt; { ValueTaskSourceStatus GetStatus(short token); void OnCompleted(Action&lt;object&gt; continuation, object state, short token, ValueTaskSourceOnCompletedFlags flags); TResult GetResult(short token); }</code> </pre> <br><p>  Die GetStatus-Methode wird verwendet, um Eigenschaften wie ValueTask &lt;TResult&gt; .IsCompleted zu implementieren, die Informationen zur√ºckgeben, ob eine asynchrone Operation ausgef√ºhrt oder abgeschlossen wird und wie sie abgeschlossen wird (erfolgreich oder nicht).  Die OnCompleted-Methode wird vom wartenden Objekt verwendet, um einen R√ºckruf anzuh√§ngen und die Ausf√ºhrung ab dem Wartepunkt fortzusetzen, wenn der Vorgang abgeschlossen ist.  Die GetResult-Methode wird ben√∂tigt, um das Ergebnis der Operation abzurufen. Nach dem Ende der Operation kann der Aufrufer das TResult-Objekt abrufen oder eine ausgel√∂ste Ausnahme √ºbergeben. </p><br><p>  Die meisten Entwickler ben√∂tigen diese Schnittstelle nicht: Methoden geben einfach ein ValueTask &lt;TResult&gt; -Objekt zur√ºck, das als Wrapper f√ºr ein Objekt erstellt werden kann, das diese Schnittstelle implementiert, und die aufrufende Methode bleibt im Dunkeln.  Diese Schnittstelle ist f√ºr Entwickler gedacht, die bei Verwendung einer leistungskritischen API die Speicherzuweisung vermeiden m√ºssen. </p><br><p>  In .NET Core 2.1 gibt es mehrere Beispiele f√ºr eine solche API.  Die bekanntesten Methoden sind Socket.ReceiveAsync und Socket.SendAsync, wobei beispielsweise in 2.1 neue √úberladungen hinzugef√ºgt wurden </p><br><pre> <code class="plaintext hljs">public ValueTask&lt;int&gt; ReceiveAsync(Memory&lt;byte&gt; buffer, SocketFlags socketFlags, CancellationToken cancellationToken = default);</code> </pre> <br><p>  Diese √úberladung gibt eine ValueTask &lt;int&gt; zur√ºck.  Wenn der Vorgang synchron abgeschlossen wird, kann einfach eine ValueTask &lt;int&gt; mit dem entsprechenden Wert zur√ºckgegeben werden: </p><br><pre> <code class="plaintext hljs">int result = ‚Ä¶; return new ValueTask&lt;int&gt;(result);</code> </pre> <br><p>  Bei asynchroner Beendigung kann ein Objekt aus dem Pool verwendet werden, das die Schnittstelle implementiert: </p><br><pre> <code class="plaintext hljs">IValueTaskSource&lt;int&gt; vts = ‚Ä¶; return new ValueTask&lt;int&gt;(vts);</code> </pre> <br><p>  Die Socket-Implementierung unterst√ºtzt ein solches Objekt im Pool f√ºr den Empfang und eines f√ºr die √úbertragung, da nicht mehr als ein Objekt f√ºr jede Richtung gleichzeitig auf die Ausf√ºhrung warten kann.  Diese √úberlastungen weisen selbst bei einer asynchronen Operation keinen Speicher zu.  Dieses Verhalten wird in der NetworkStream-Klasse weiter deutlich. <br>  In .NET Core 2.1 bietet Stream beispielsweise Folgendes: </p><br><pre> <code class="plaintext hljs">public virtual ValueTask&lt;int&gt; ReadAsync(Memory&lt;byte&gt; buffer, CancellationToken cancellationToken);</code> </pre> <br><p>  welches in NetworkStream neu definiert wird.  Die NetworkStream.ReadAsync-Methode verwendet einfach die Socket.ReceiveAsync-Methode, sodass die Gewinne in Socket an NetworkStream gesendet werden und NetworkStream.ReadAsync auch keinen Speicher zuweist. </p><br><h4 id="neobobschyonnyy-valuetask">  Unshared ValueTask </h4><br><p>  Wenn ValueTask &lt;TResult&gt; in .NET Core 2.0 angezeigt wurde, wurde nur der synchrone Ausf√ºhrungsfall darin optimiert, um die Platzierung des Task &lt;TResult&gt; -Objekts auszuschlie√üen, wenn der TResult-Wert bereits bereit ist.  Dies bedeutete, dass die generische ValueTask-Klasse nicht ben√∂tigt wurde: F√ºr den Fall der synchronen Ausf√ºhrung konnte die Singleton-Task.CompletedTask einfach von der Methode zur√ºckgegeben werden, und dies wurde von der Umgebung implizit in den asynchronen Methoden durchgef√ºhrt, die Task zur√ºckgeben. </p><br><p>  Mit dem Abrufen asynchroner Operationen ohne Zuweisung von Speicher ist die Verwendung der nicht gemeinsam genutzten ValueTask jedoch wieder relevant geworden.  In .NET Core 2.1 haben wir die generischen Werte ValueTask und IValueTaskSource eingef√ºhrt.  Sie bieten direkte Entsprechungen f√ºr generische Versionen f√ºr √§hnliche Zwecke mit nur einem leeren R√ºckgabewert. </p><br><h4 id="realizaciya-ivaluetasksourceivaluetasksourcet">  Implementieren Sie IValueTaskSource / IValueTaskSource &lt;T&gt; </h4><br><p>  Die meisten Entwickler sollten diese Schnittstellen nicht implementieren.  Dar√ºber hinaus ist es nicht so einfach.  Wenn Sie sich dazu entscheiden, k√∂nnen mehrere Implementierungen in .NET Core 2.1 als Ausgangspunkt dienen, zum Beispiel: </p><br><ul><li>  AwaitableSocketAsyncEventArgs </li><li>  AsyncOperation &lt;Tresult&gt; </li><li>  DefaultPipeReader </li></ul><br><p>  Um dies zu vereinfachen, m√∂chten wir in .NET Core 3.0 die gesamte erforderliche Logik pr√§sentieren, die im Typ ManualResetValueTaskSourceCore &lt;TResult&gt; enthalten ist. Diese Struktur kann in ein anderes Objekt eingebettet werden, das IValueTaskSource &lt;TResult&gt; und / oder IValueTaskSource implementiert, damit sie delegiert werden kann Diese Struktur macht den Gro√üteil der Funktionalit√§t aus.  Weitere Informationen hierzu finden Sie unter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/dotnet/corefx/issues/32664</a> im dotnet / corefx-Repository. </p><br><h4 id="patterny-primeneniya-valuetasks">  ValueTasks-Anwendungsmuster </h4><br><p>  Auf den ersten Blick ist der Umfang von ValueTask und ValueTask &lt;TResult&gt; viel eingeschr√§nkter als Task und Task &lt;TResult&gt;.  Dies ist gut und wird sogar erwartet, da die Hauptverwendung darin besteht, einfach den Operator await zu verwenden. </p><br><p>  Da sie jedoch wiederverwendete Objekte umschlie√üen k√∂nnen, gibt es im Vergleich zu Task und Task &lt;TResult&gt; erhebliche Einschr√§nkungen bei ihrer Verwendung, wenn Sie von der √ºblichen Art des einfachen Wartens abweichen.  Im Allgemeinen sollten die folgenden Vorg√§nge niemals mit ValueTask / ValueTask &lt;TResult&gt; ausgef√ºhrt werden: </p><br><ul><li>  <strong>Wiederholtes Warten ValueTask / ValueTask &lt;TResult&gt;</strong> Das Ergebnisobjekt wurde m√∂glicherweise bereits entsorgt und in einer anderen Operation verwendet.  Im Gegensatz dazu wechselt Task / Task &lt;Tresult&gt; niemals von einem abgeschlossenen in einen unvollst√§ndigen Zustand, sodass Sie ihn so oft wie n√∂tig erneut erwarten und jedes Mal das gleiche Ergebnis erzielen k√∂nnen. </li><li>  <strong>Paralleles Warten ValueTask / ValueTask &lt;TResult&gt;</strong> Das Ergebnisobjekt erwartet die Verarbeitung mit jeweils nur einem R√ºckruf von einem Verbraucher. Der Versuch, gleichzeitig aus verschiedenen Flows zu warten, kann leicht zu Rennen und subtilen Programmfehlern f√ºhren.  Dar√ºber hinaus handelt es sich auch um einen spezifischeren Fall der vorherigen ung√ºltigen "erneuten Warte" -Operation.  Im Vergleich dazu bietet Task / Task &lt;Tresult&gt; eine beliebige Anzahl paralleler Wartezeiten. </li><li>  <strong>Verwenden von .GetAwaiter (). GetResult (), wenn der Vorgang noch nicht abgeschlossen ist. Die</strong> Implementierung von IValueTaskSource / IValueTaskSource &lt;TResult&gt; ben√∂tigt keine Sperrunterst√ºtzung, bis der Vorgang abgeschlossen ist, und wird dies h√∂chstwahrscheinlich nicht tun. Daher wird ein solcher Vorgang definitiv zu Rennen f√ºhren und wahrscheinlich wird nicht wie erwartet ausgef√ºhrt.  Task / Task &lt;TResult&gt; blockiert den aufrufenden Thread, bis die Task abgeschlossen ist. </li></ul><br><p>  Wenn Sie eine ValueTask oder ValueTask &lt;TResult&gt; erhalten haben, aber eine dieser drei Operationen ausf√ºhren m√ºssen, k√∂nnen Sie .AsTask () verwenden, Task / Task &lt;TResult&gt; abrufen und dann mit dem empfangenen Objekt arbeiten.  Danach k√∂nnen Sie diese ValueTask / ValueTask &lt;TResult&gt; nicht mehr verwenden. </p><br><p>  Kurz gesagt lautet die Regel: Wenn Sie ValueTask / ValueTask &lt;TResult&gt; verwenden, m√ºssen Sie entweder direkt darauf warten (m√∂glicherweise mit .ConfigureAwait (false)) oder AsTask () aufrufen und nicht mehr verwenden: </p><br><pre> <code class="plaintext hljs">//   ,  ValueTask&lt;int&gt; public ValueTask&lt;int\&gt; SomeValueTaskReturningMethodAsync(); ... // GOOD int result = await SomeValueTaskReturningMethodAsync(); // GOOD int result = await SomeValueTaskReturningMethodAsync().ConfigureAwait(false); // GOOD Task&lt;int&gt; t = SomeValueTaskReturningMethodAsync().AsTask(); // WARNING ValueTask&lt;int&gt; vt = SomeValueTaskReturningMethodAsync(); //       , //     // BAD: await   ValueTask&lt;int&gt; vt = SomeValueTaskReturningMethodAsync(); int result = await vt; int result2 = await vt; // BAD: await  (    ) ValueTask&lt;int&gt; vt = SomeValueTaskReturningMethodAsync(); Task.Run(async () =&gt; await vt); Task.Run(async () =&gt; await vt); // BAD:  GetAwaiter().GetResult(),     ValueTask&lt;int&gt; vt = SomeValueTaskReturningMethodAsync(); int result = vt.GetAwaiter().GetResult();</code> </pre> <br><p>  Ich hoffe, es gibt ein fortgeschritteneres Muster, das Programmierer nur nach sorgf√§ltiger Messung und Erzielung bedeutender Vorteile anwenden k√∂nnen.  Die ValueTask / ValueTask &lt;TResult&gt; -Klassen verf√ºgen √ºber mehrere Eigenschaften, die den aktuellen Status der Operation melden. Beispielsweise gibt die IsCompleted-Eigenschaft true zur√ºck, wenn die Operation abgeschlossen wurde (dh sie wird nicht mehr erfolgreich ausgef√ºhrt oder erfolgreich abgeschlossen oder nicht erfolgreich abgeschlossen), und die IsCompletedSuccessfully-Eigenschaft gibt nur true zur√ºck Wenn es erfolgreich abgeschlossen wurde (w√§hrend des Wartens und Empfangens des Ergebnisses wurde keine Ausnahme ausgel√∂st).  F√ºr die anspruchsvollsten Ausf√ºhrungsthreads, bei denen der Entwickler die im asynchronen Modus anfallenden Kosten vermeiden m√∂chte, k√∂nnen diese Eigenschaften vor einer Operation √ºberpr√ºft werden, die das ValueTask / ValueTask &lt;TResult&gt; -Objekt tats√§chlich zerst√∂rt, z. B. .AsTask ().  Bei der Implementierung von SocketsHttpHandler in .NET Core 2.1 liest der Code beispielsweise aus der Verbindung und empf√§ngt eine ValueTask &lt;int&gt;.  Wenn dieser Vorgang synchron ausgef√ºhrt wird, m√ºssen wir uns keine Gedanken √ºber eine vorzeitige Beendigung des Vorgangs machen.  Wenn es jedoch asynchron ausgef√ºhrt wird, m√ºssen wir die Interrupt-Verarbeitung anschlie√üen, damit die Interrupt-Anforderung die Verbindung unterbricht.  Da dies ein sehr stressiger Code ist, kann die Profilerstellung wie folgt strukturiert werden, wenn f√ºr die Profilerstellung die folgenden kleinen √Ñnderungen erforderlich sind: </p><br><pre> <code class="plaintext hljs">int bytesRead; { ValueTask&lt;int&gt; readTask = _connection.ReadAsync(buffer); if (readTask.IsCompletedSuccessfully) { bytesRead = readTask.Result; } else { using (_connection.RegisterCancellation()) { bytesRead = await readTask; } } }</code> </pre> <br><h4 id="dolzhen-li-kazhdyy-novyy-metod-asinhronnogo-api-vozvraschat-valuetaskvaluetasktresult">  Sollte jede neue asynchrone API-Methode eine ValueTask / ValueTask &lt;TResult&gt; zur√ºckgeben? </h4><br><p>  Um kurz zu antworten: Nein, standardm√§√üig lohnt es sich immer noch, Task / Task &lt;Tresult&gt; zu w√§hlen. <br>  Wie oben hervorgehoben, sind Task und Task &lt;Tresult&gt; einfacher korrekt zu verwenden als ValueTask und ValueTask &lt;TResult&gt;. Solange die Leistungsanforderungen die praktischen Anforderungen nicht √ºberwiegen, werden Task und Task &lt;TResult&gt; bevorzugt.  Dar√ºber hinaus sind mit der R√ºckgabe einer ValueTask &lt;TResult&gt; anstelle einer Task &lt;TResult&gt; geringe Kosten verbunden, dh Mikro-Benchmarks zeigen, dass das Warten auf Task &lt;TResult&gt; schneller ist als das Warten auf ValueTask &lt;TResult&gt;.  Wenn Sie beispielsweise das Task-Caching verwenden, gibt Ihre Methode Task oder Task zur√ºck. Aus Gr√ºnden der Leistung lohnt es sich, bei Task oder Task zu bleiben.  ValueTask / ValueTask &lt;TResult&gt; -Objekte belegen mehrere W√∂rter im Speicher. Wenn sie erwartet werden und ihre Felder in der Zustandsmaschine reserviert sind, die die asynchrone Methode aufruft, belegen sie mehr Speicher darin. <br></p><p>  - ValueTask/ValueTask&lt;TResult&gt;    : )  ,        await, )        , )     ,          .   ,                /  . </p><br><h4 id="chto-dalshe-s-valuetask-i-valuetasktresult">    ValueTask  ValueTask&lt;TResult&gt;? </h4><br><p>    .NET      ,  Task/Task&lt;TResult&gt;,  ,  ValueTask/ValueTask&lt;TResult&gt;,     ,   .      ‚Äì   IAsyncEnumerator&lt;T&gt;,     .NET Core 3.0. IEnumerator&lt;T&gt;   MoveNext,   bool,     IAsyncEnumerator&lt;T&gt;   MoveNextAsync.     , ,     Task,             . ,   ,       ,        (           ),        await   foreach,      ValueTask.        ,         .      C#   ,    ,     ,   . </p><p></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de458828/">https://habr.com/ru/post/de458828/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de458812/index.html">JVM TI: Wie erstelle ich ein Plugin f√ºr eine virtuelle Maschine?</a></li>
<li><a href="../de458814/index.html">Starten einer Website f√ºr ein Produkt mit ungekl√§rter Nachfrage</a></li>
<li><a href="../de458818/index.html">Prominente Zeitgenossen</a></li>
<li><a href="../de458820/index.html">√úber die Implementierung des ber√ºhmten Genres auf der Minecraft-Plattform</a></li>
<li><a href="../de458826/index.html">Wie man alte Artikel aussortiert, damit sie im Bio-Bereich stark wachsen: + 104% des Verkehrs f√ºr sechs Monate</a></li>
<li><a href="../de458830/index.html">Dell Technologies-Webinare: Alle Details unseres Tutorials</a></li>
<li><a href="../de458832/index.html">F√ºnf Studenten und drei verteilte Schl√ºsselwertspeicher</a></li>
<li><a href="../de458834/index.html">Seite der Pers√∂nlichkeit von Paul Allen, von der nicht so viele Menschen wussten, wie ich m√∂chte</a></li>
<li><a href="../de458836/index.html">Borsch Index. Ein systematischer Ansatz zur Bewertung, zum Vergleich und zur Bestimmung des Preis-Leistungs-Verh√§ltnisses</a></li>
<li><a href="../de458840/index.html">Wie wir die Great Chinese Firewall durchbohrt haben (Teil 2)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>