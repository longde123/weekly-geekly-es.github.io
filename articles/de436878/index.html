<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍👨‍👧 👩🏾‍🏭 🚚 BERT ist ein hochmodernes Sprachmodell für 104 Sprachen. Tutorial zum lokalen Starten von BERT und in Google Colab 🤠 🧘🏼 🅿️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="BERT ist ein neuronales Netzwerk von Google, das bei einer Reihe von Aufgaben mit großem Abstand die neuesten Ergebnisse zeigte. Mit BERT können Sie K...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>BERT ist ein hochmodernes Sprachmodell für 104 Sprachen. Tutorial zum lokalen Starten von BERT und in Google Colab</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436878/"><p><img src="https://habrastorage.org/getpro/habr/post_images/2bd/0ba/1c4/2bd0ba1c4fb80fe4d771f555168c9ff0.png" alt="Bild"></p><br><p>  BERT ist ein neuronales Netzwerk von Google, das bei einer Reihe von Aufgaben mit großem Abstand die neuesten Ergebnisse zeigte.  Mit BERT können Sie KI-Programme zur Verarbeitung einer natürlichen Sprache erstellen: Beantworten Sie Fragen in beliebiger Form, erstellen Sie Chat-Bots, automatische Übersetzer, analysieren Sie Text usw. </p><br><p>  Google hat vorab geschulte BERT-Modelle veröffentlicht, aber wie es normalerweise beim maschinellen Lernen der Fall ist, leiden sie unter einem Mangel an Dokumentation.  In diesem Tutorial erfahren Sie daher, wie Sie das neuronale BERT-Netzwerk auf dem lokalen Computer sowie auf der GPU des kostenlosen Servers in Google Colab ausführen. </p><a name="habracut"></a><br><h2 id="zachem-eto-voobsche-nuzhno">  Warum ist es überhaupt notwendig? </h2><br><p>  Um Text an die Eingabe eines neuronalen Netzwerks zu senden, müssen Sie ihn irgendwie in Form von Zahlen darstellen.  Es ist am einfachsten, dies Buchstabe für Buchstabe zu tun und einen Buchstaben auf jeden Eingang des neuronalen Netzwerks anzuwenden.  Dann wird jeder Buchstabe mit einer Zahl von 0 bis 32 (plus einer Art Rand für Satzzeichen) codiert.  Dies ist die sogenannte Zeichenebene. </p><br><p>  Viel bessere Ergebnisse werden jedoch erzielt, wenn wir Vorschläge nicht mit einem Buchstaben präsentieren, sondern indem wir jedem Eingang des neuronalen Netzes sofort ein ganzes Wort (oder zumindest Silben) übermitteln.  Es wird bereits eine Wortebene sein.  Am einfachsten ist es, ein Wörterbuch mit allen vorhandenen Wörtern zu kompilieren und dem Netzwerk die Anzahl der Wörter in diesem Wörterbuch mitzuteilen.  Befindet sich beispielsweise das Wort "Hund" 1678 in diesem Wörterbuch, geben wir die Nummer 1678 für die Eingabe des neuronalen Netzwerks für dieses Wort ein. </p><br><p>  Aber nur in einer natürlichen Sprache mit dem Wort „Hund“ tauchen in einer Person viele Assoziationen gleichzeitig auf: „flauschig“, „böse“, „Freund einer Person“.  Ist es möglich, dieses Merkmal unseres Denkens in der Präsentation für das neuronale Netzwerk irgendwie zu kodieren?  Es stellt sich heraus, dass Sie können.  Dazu reicht es aus, die Wortnummern neu anzuordnen, damit die bedeutungsnahen Wörter nebeneinander stehen.  Sei es zum Beispiel für "Hund" die Nummer 1678 und für das Wort "flauschig" die Nummer 1680. Und für das Wort "Teekanne" ist die Nummer 9000. Wie Sie sehen können, sind die Nummern 1678 und 1680 viel näher beieinander als die Nummer 9000. </p><br><p>  In der Praxis wird jedem Wort nicht eine, sondern mehrere Zahlen zugewiesen - beispielsweise ein Vektor mit 32 Zahlen.  Die Abstände werden als Abstände zwischen den Punkten gemessen, auf die diese Vektoren im Raum der entsprechenden Dimension zeigen (für einen 32-stelligen Vektor ist dies ein Raum mit 32 Dimensionen oder mit 32 Achsen).  Auf diese Weise können Sie ein Wort gleichzeitig mit mehreren Wörtern vergleichen, deren Bedeutung nahe beieinander liegt (abhängig davon, welche Achse gezählt werden soll).  Darüber hinaus können arithmetische Operationen mit Vektoren durchgeführt werden.  Ein klassisches Beispiel: Wenn Sie den Vektor „Mann“ von dem Vektor subtrahieren, der das Wort „König“ bezeichnet, und den Vektor für das Wort „Frau“ hinzufügen, erhalten Sie einen bestimmten Ergebnisvektor.  Und er wird auf wundersame Weise dem Wort "Königin" entsprechen.  Und in der Tat: "König ist Mann + Frau = Königin."  Die Magie!  Und dies ist kein abstraktes Beispiel, aber es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">passiert wirklich</a> .  In Anbetracht der Tatsache, dass neuronale Netze für mathematische Transformationen über ihre Eingaben gut geeignet sind, bietet dies anscheinend eine so hohe Effizienz dieser Methode. </p><br><p>  Dieser Ansatz wird als Einbettung bezeichnet.  Alle maschinellen Lernpakete (TensorFlow, PyTorch) ermöglichen es der ersten Schicht des neuronalen Netzwerks, eine spezielle Schicht der Einbettungsschicht zu erstellen, die dies automatisch ausführt.  Das heißt, am Eingang des neuronalen Netzwerks geben wir die übliche Wortnummer im Wörterbuch ein, und die selbstlernende Einbettungsschicht übersetzt jedes Wort in einen Vektor der angegebenen Länge, beispielsweise 32 Zahlen. </p><br><p>  Sie erkannten jedoch schnell, dass es viel rentabler ist, eine solche Vektordarstellung von Wörtern auf einem riesigen Textkorpus, beispielsweise in der gesamten Wikipedia, vorab zu trainieren und vorgefertigte Wortvektoren in bestimmten neuronalen Netzen zu verwenden, anstatt sie jedes Mal neu zu trainieren. </p><br><p>  Es gibt verschiedene Möglichkeiten, Wörter als Vektoren darzustellen, die sich allmählich weiterentwickelten: word2vec, GloVe, Elmo. </p><br><p>  Im Sommer 2018 stellte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OpenAI fest,</a> dass ein neuronales Netzwerk, das die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Transformer-</a> Architektur mit großen Textmengen vorab trainiert, unerwartet und mit großem Abstand hervorragende Ergebnisse bei vielen verschiedenen Arten von Aufgaben zur Verarbeitung natürlicher Sprache zeigt.  Tatsächlich erzeugt ein solches neuronales Netzwerk an seiner Ausgabe Vektordarstellungen für Wörter und sogar ganze Phrasen.  Und indem Sie einen kleinen Block aus zwei zusätzlichen Schichten von Neuronen auf ein solches Sprachmodell hängen, können Sie dieses neuronale Netzwerk für alle Aufgaben trainieren. </p><br><p>  BERT von Google ist ein erweitertes GPA-Netzwerk von OpenAI (bidirektional statt unidirektional usw.), das ebenfalls auf der Transformer-Architektur basiert.  Derzeit ist BERT bei fast allen gängigen NLP-Benchmarks auf dem neuesten Stand der Technik. </p><br><h2 id="kak-oni-eto-sdelali">  Wie haben sie das gemacht? </h2><br><p>  Die Idee hinter BERT ist sehr einfach: Lassen Sie uns das neuronale Netzwerk mit Phrasen versorgen, in denen wir 15% der Wörter durch [MASK] ersetzen und das neuronale Netzwerk trainieren, um diese maskierten Wörter vorherzusagen. </p><br><p>  Wenn wir beispielsweise den Satz "Ich bin zu [MASK] gekommen und habe [MASK] gekauft" an den Eingang des neuronalen Netzwerks senden, sollten am Ausgang die Wörter "speichern" und "Milch" angezeigt werden.  Dies ist ein vereinfachtes Beispiel von der offiziellen BERT-Seite: Bei längeren Sätzen wird der Bereich möglicher Optionen kleiner und die Reaktion des neuronalen Netzwerks ist eindeutig. </p><br><p>  Und damit das neuronale Netzwerk lernen kann, die Beziehung zwischen verschiedenen Sätzen zu verstehen, werden wir es zusätzlich trainieren, um vorherzusagen, ob die zweite Phrase eine logische Fortsetzung der ersten ist.  Oder ist es eine zufällige Phrase, die nichts mit der ersten zu tun hat? </p><br><p>  Also für zwei Sätze: "Ich ging in den Laden."  und "Und dort Milch gekauft.", sollte das neuronale Netzwerk antworten, dass dies logisch ist.  Und wenn der zweite Satz "Crucian Sky Pluto" ist, dann muss ich antworten, dass dieser Vorschlag nichts mit dem ersten zu tun hat.  Wir werden unten mit diesen beiden BERT-Modi herumspielen. </p><br><p>  Nachdem wir das neuronale Netzwerk 4 Tage lang mit 16 TPU auf dem Korpus von Texten aus Wikipedia und der Büchersammlung BookCorpus trainiert hatten, erhielten wir BERT. </p><br><h2 id="ustanovka-i-nastroyka">  Installation und Einrichtung </h2><br><p>  <em><strong>Hinweis</strong> : In diesem Abschnitt werden wir BERT auf dem lokalen Computer starten und damit spielen.</em>  <em>Um dieses neuronale Netzwerk auf einer lokalen GPU auszuführen, benötigen Sie eine NVidia GTX 970 mit 4 GB Videospeicher oder höher.</em>  <em>Wenn Sie BERT nur in einem Browser ausführen möchten (dafür benötigen Sie nicht einmal eine GPU auf Ihrem Computer), gehen Sie zum Abschnitt "Google Colab".</em> </p><br><p>  Installieren Sie zuerst TensorFlow, falls Sie es noch nicht haben. Befolgen Sie dazu die Anweisungen unter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://www.tensorflow.org/install</a> .  Um die GPU zu unterstützen, müssen Sie zuerst das CUDA Toolkit 9.0, dann das cuDNN SDK 7.2 und erst dann TensorFlow mit GPU-Unterstützung installieren: </p><br><pre><code class="dos hljs">pip install tensorflow-gpu</code> </pre> <br><p>  Grundsätzlich reicht dies aus, um BERT auszuführen.  Es gibt jedoch keine Anweisung als solche. Sie können sie selbst <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erstellen,</a> indem Sie die Quellen in der Datei <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">run_classifier.py sortieren</a> (die übliche Situation beim maschinellen Lernen besteht darin, dass Sie anstelle der Dokumentation in die Quellen gehen müssen).  Wir werden es jedoch einfacher machen und die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Keras BERT-</a> Shell verwenden (sie kann auch zur späteren Feinabstimmung des Netzwerks nützlich sein, da sie eine praktische Keras-Schnittstelle bietet). </p><br><p>  Installieren Sie dazu Keras selbst: </p><br><pre> <code class="dos hljs">pip install keras</code> </pre> <br><p>  Und nach Keras BERT: </p><br><pre> <code class="dos hljs">pip install keras-bert</code> </pre> <br><p>  Wir benötigen auch die Datei tokenization.py aus dem ursprünglichen Github BERT.  Klicken Sie entweder auf die Schaltfläche Raw und speichern Sie sie im Ordner mit dem zukünftigen Skript, oder laden Sie das gesamte Repository herunter und nehmen Sie die Datei von dort, oder nehmen Sie eine Kopie aus dem Repository mit diesem Code <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/blade1780/bert</a> . </p><br><p>  Jetzt ist es Zeit, das vorab trainierte neuronale Netzwerk herunterzuladen.  Es gibt verschiedene Optionen für BERT, die alle auf der offiziellen Seite <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">github.com/google-research/bert aufgeführt</a> sind.  Wir werden die universelle mehrsprachige "BERT-Base, Multilingual Cased" für 104 Sprachen verwenden.  Laden Sie die Datei <a href="">multi_cased_L-12_H-768_A-12.zip</a> (632 MB) herunter und entpacken Sie sie mit dem zukünftigen Skript in den Ordner. </p><br><p>  Alles ist fertig, erstellen Sie die BERT.py-Datei, dann wird es ein bisschen Code geben. </p><br><p>  Importieren Sie die erforderlichen Bibliotheken und legen Sie die Pfade fest </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># coding: utf-8 import sys import codecs import numpy as np from keras_bert import load_trained_model_from_checkpoint import tokenization # ,     BERT folder = 'multi_cased_L-12_H-768_A-12' config_path = folder+'/bert_config.json' checkpoint_path = folder+'/bert_model.ckpt' vocab_path = folder+'/vocab.txt'</span></span></code> </pre> <br><p>  Da wir gewöhnliche Textzeilen in ein spezielles Format von Token übersetzen müssen, werden wir dafür ein spezielles Objekt erstellen.  Achten Sie auf do_lower_case = False, da wir das Cased BERT-Modell verwenden, bei dem zwischen Groß- und Kleinschreibung unterschieden wird. </p><br><pre> <code class="python hljs">tokenizer = tokenization.FullTokenizer(vocab_file=vocab_path, do_lower_case=<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>)</code> </pre> <br><p>  Modell laden </p><br><pre> <code class="python hljs">model = load_trained_model_from_checkpoint(config_path, checkpoint_path, training=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) model.summary()</code> </pre> <br><p>  BERT kann in zwei Modi arbeiten: Erraten der in der Phrase fehlenden Wörter oder Erraten, ob die zweite Phrase nach der ersten logisch ist.  Wir werden beide Optionen ausführen. </p><br><p>  Für den ersten Modus müssen Sie eine Phrase im folgenden Format einreichen: </p><br><pre> <code class="dos hljs">[<span class="hljs-built_in"><span class="hljs-built_in">CLS</span></span>]    [MASK]   [MASK]. [SEP]</code> </pre> <br><p>  Das neuronale Netzwerk sollte einen vollständigen Satz mit den Worten anstelle der Masken zurückgeben: "Ich bin in den Laden gekommen und habe Milch gekauft." </p><br><p>  Für den zweiten Modus müssen beide durch ein Trennzeichen getrennten Phrasen dem Eingang des neuronalen Netzwerks zugeführt werden: </p><br><pre> <code class="dos hljs">[<span class="hljs-built_in"><span class="hljs-built_in">CLS</span></span>]    . [SEP]   . [SEP]</code> </pre> <br><p>  Das neuronale Netzwerk muss antworten, ob die zweite Phrase eine logische Fortsetzung der ersten ist.  Oder ist es eine zufällige Phrase, die nichts mit der ersten zu tun hat? </p><br><p>  Damit BERT funktioniert, müssen Sie drei Vektoren mit einer Länge von jeweils 512 Zahlen vorbereiten: token_input, seg_input und mask_input. </p><br><p>  <strong>Token_input</strong> speichert unseren Quellcode, der mit dem Tokenizer in Token übersetzt wurde.  Die Phrase in Form von Indizes im Wörterbuch befindet sich am Anfang dieses Vektors, und der Rest wird mit Nullen gefüllt. </p><br><p>  In <strong>mask_input müssen</strong> wir 1 für alle Positionen setzen, an denen sich die [MASK] -Maske befindet, und den Rest mit Nullen füllen. </p><br><p>  In <strong>seg_input müssen</strong> wir <strong>die</strong> erste Phrase (einschließlich des Start-CLS- und SEP-Trennzeichens) als 0, die zweite Phrase (einschließlich der End-SEP) als 1 bezeichnen und den Rest bis zum Ende des Vektors mit Nullen füllen. </p><br><p>  BERT verwendet kein Wörterbuch ganzer Wörter, sondern der häufigsten Silben.  Obwohl es auch ganze Wörter hat.  Sie können die Datei vocab.txt im heruntergeladenen neuronalen Netzwerk öffnen und sehen, welche Wörter das neuronale Netzwerk an seiner Eingabe verwendet.  Es gibt ganze Wörter wie Frankreich.  Aber die meisten russischen Wörter müssen in Silben zerlegt werden.  Das Wort "kam" sollte also in "mit" und "## ging" unterteilt werden.  Um die Konvertierung regulärer Textzeilen in das von BERT geforderte Format zu erleichtern, verwenden wir das Modul tokenization.py. </p><br><h2 id="rezhim-1-predskazanie-slov-zakrytyh-tokenom-mask-v-fraze">  Modus 1: Vorhersage von Wörtern, die durch Token [MASK] in einer Phrase geschlossen wurden </h2><br><p>  Die Eingabephrase, die dem Eingang des neuronalen Netzwerks zugeführt wird </p><br><pre> <code class="python hljs">sentence = <span class="hljs-string"><span class="hljs-string">'   [MASK]   [MASK].'</span></span> print(sentence)</code> </pre> <br><p>  Konvertiere es in Token.  Das Problem ist, dass der Tokenizer keine Dienstmarken wie [CLS] und [MASK] verarbeiten kann, obwohl vocab.txt sie im Wörterbuch enthält.  Daher müssen wir unsere Linie manuell mit [MASK] -Markierungen unterbrechen und Klartextstücke auswählen, um sie mithilfe des Tokenizers in BERT-Token zu konvertieren.  Fügen Sie außerdem [CLS] am Anfang und [SEP] am Ende der Phrase hinzu. </p><br><pre> <code class="python hljs">sentence = sentence.replace(<span class="hljs-string"><span class="hljs-string">' [MASK] '</span></span>,<span class="hljs-string"><span class="hljs-string">'[MASK]'</span></span>); sentence = sentence.replace(<span class="hljs-string"><span class="hljs-string">'[MASK] '</span></span>,<span class="hljs-string"><span class="hljs-string">'[MASK]'</span></span>); sentence = sentence.replace(<span class="hljs-string"><span class="hljs-string">' [MASK]'</span></span>,<span class="hljs-string"><span class="hljs-string">'[MASK]'</span></span>) <span class="hljs-comment"><span class="hljs-comment">#    sentence = sentence.split('[MASK]') #     tokens = ['[CLS]'] #      [CLS] #        tokenizer.tokenize(),    [MASK] for i in range(len(sentence)): if i == 0: tokens = tokens + tokenizer.tokenize(sentence[i]) else: tokens = tokens + ['[MASK]'] + tokenizer.tokenize(sentence[i]) tokens = tokens + ['[SEP]'] #      [SEP]</span></span></code> </pre> <br><p>  Token verfügen jetzt über Token, die garantiert in Indizes im Wörterbuch konvertiert werden.  Lass es uns tun: </p><br><pre> <code class="python hljs">token_input = tokenizer.convert_tokens_to_ids(tokens)</code> </pre> <br><p>  Jetzt gibt es in token_input eine Reihe von Zahlen (Wortnummern im Vokabular "vocab.txt"), die dem Eingang des neuronalen Netzwerks zugeführt werden müssen.  Es bleibt nur, diesen Vektor auf eine Länge von 512 Elementen zu erweitern.  Das Python-Konstrukt [0] * length erstellt ein Array mit Längenlängen, das mit Nullen gefüllt ist.  Fügen Sie es einfach unseren Token hinzu, die in Python zwei Arrays zu einem kombinieren. </p><br><pre> <code class="python hljs">token_input = token_input + [<span class="hljs-number"><span class="hljs-number">0</span></span>] * (<span class="hljs-number"><span class="hljs-number">512</span></span> - len(token_input))</code> </pre> <br><p>  Erstellen Sie nun eine Maskenmaske mit einer Länge von 512, setzen Sie überall 1, wobei die Zahl 103 in Token erscheint (was der Markierung [MASK] im Vokabular "vocab.txt" entspricht), und füllen Sie den Rest mit 0: </p><br><pre> <code class="python hljs">mask_input = [<span class="hljs-number"><span class="hljs-number">0</span></span>]*<span class="hljs-number"><span class="hljs-number">512</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(len(mask_input)): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> token_input[i] == <span class="hljs-number"><span class="hljs-number">103</span></span>: mask_input[i] = <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br><p>  Für den ersten BERT-Betriebsmodus muss seg_input vollständig mit Nullen gefüllt sein: </p><br><pre> <code class="python hljs">seg_input = [<span class="hljs-number"><span class="hljs-number">0</span></span>]*<span class="hljs-number"><span class="hljs-number">512</span></span></code> </pre> <br><p>  Im letzten Schritt müssen Sie Python-Arrays in Numpy-Arrays mit der Form (1.512) konvertieren, für die wir sie in ein Subarray [] einfügen: </p><br><pre> <code class="python hljs">token_input = np.asarray([token_input]) mask_input = np.asarray([mask_input]) seg_input = np.asarray([seg_input])</code> </pre> <br><p>  OK, fertig.  Führen Sie nun die Vorhersage des neuronalen Netzwerks aus! </p><br><pre> <code class="python hljs">predicts = model.predict([token_input, seg_input, mask_input])[<span class="hljs-number"><span class="hljs-number">0</span></span>] predicts = np.argmax(predicts, axis=<span class="hljs-number"><span class="hljs-number">-1</span></span>) predicts = predicts[<span class="hljs-number"><span class="hljs-number">0</span></span>][:len(tokens)] <span class="hljs-comment"><span class="hljs-comment">#   ,    ,       </span></span></code> </pre> <br><p>  Formatieren Sie nun das Ergebnis von Token zurück in eine durch Leerzeichen getrennte Zeichenfolge </p><br><pre> <code class="python hljs">out = [] <span class="hljs-comment"><span class="hljs-comment">#   out     [MASK],    1  mask_input for i in range(len(mask_input[0])): if mask_input[0][i] == 1: # [0][i], ..   batch   (1,512),       out.append(predicts[i]) out = tokenizer.convert_ids_to_tokens(out) #     out = ' '.join(out) #       out = tokenization.printable_text(out) #    out = out.replace(' ##','') #   : " ##" -&gt; ""</span></span></code> </pre> <br><p>  Und geben Sie das Ergebnis aus: </p><br><pre> <code class="python hljs">print(<span class="hljs-string"><span class="hljs-string">'Result:'</span></span>, out)</code> </pre> <br><p>  In unserem Beispiel für den Satz "Ich bin zu [MASK] gekommen und habe [MASK] gekauft."  Das neuronale Netz erzeugte das Ergebnis "Haus" und "es": "Ich kam zum Haus und kaufte es."  Zum ersten Mal nicht so schlimm.  Ein Haus zu kaufen ist definitiv besser als Milch. </p><br><div class="spoiler">  <b class="spoiler_title">Andere Beispiele (ich gebe keine erfolglosen an, es gibt viel mehr als erfolgreiche. In den meisten Fällen gibt das Netzwerk eine leere Antwort):</b> <div class="spoiler_text"><p>  Die Erde ist die dritte [MASKE] von der Sonne <br>  Ergebnis: Stern </p><br><p>  bestes Sandwich [MASKE] mit Butter <br>  Ergebnis: Erfüllt </p><br><p>  Nach [MASKE] soll das Mittagessen schlafen <br>  Ergebnis: davon </p><br><p>  Geh weg von [MASKE] <br>  Ergebnis: ## oh - ist das eine Art Fluch?  ) </p><br><p>  [MASKE] von der Tür <br>  Ergebnis: Ansicht </p><br><p>  Mit [MASKE] können Hammer und Nägel Schrank machen <br>  Ergebnis: Hilfe </p><br><p>  Und wenn morgen nicht ist?  Heute ist es zum Beispiel nicht [MASKE]! <br>  Ergebnis: wird sein </p><br><p>  Wie können Sie es leid werden, [MASKE] zu ignorieren? <br>  Ergebnis: sie </p><br><p>  Es gibt alltägliche Logik, es gibt weibliche Logik, aber über die männliche [MASKE] ist nichts bekannt. <br>  Ergebnis: Philosophie </p><br><p>  Bei Frauen wird im Alter von 30 Jahren ein Bild des Prinzen gebildet, das zu jeder [MASKE] passt. <br>  Ergebnis: Mann </p><br><p>  Mit einer Mehrheit stimmten Schneewittchen und die sieben Zwerge mit einer Gegenstimme für [MASKE]. <br>  Ergebnis: Dorf - der erste Buchstabe ist korrekt </p><br><p>  Bewerten Sie Ihre Langeweile auf einer 10-Punkte-Skala: [MASKE] Punkte <br>  Ergebnis: 10 </p><br><p>  Deine [MASKE], [MASKE] und [MASKE]! <br>  Ergebnis: Lieb mich, ich - nein, BERT, ich habe es überhaupt nicht so gemeint </p></div></div><br><p>  Sie können englische Phrasen eingeben (und jede in 104 Sprachen, von denen eine Liste <a href="">hier ist</a> ) </p><br><p>  [MASKE] muss weitergehen! <br>  Ergebnis: I. </p><br><h2 id="rezhim-2-proverka-logichnosti-dvuh-fraz">  Modus 2: Überprüfen der Konsistenz von zwei Phrasen </h2><br><p>  Wir setzen zwei aufeinanderfolgende Phrasen, die dem Eingang des neuronalen Netzwerks zugeführt werden </p><br><pre> <code class="python hljs">sentence_1 = <span class="hljs-string"><span class="hljs-string">'   .'</span></span> sentence_2 = <span class="hljs-string"><span class="hljs-string">'  .'</span></span> print(sentence_1, <span class="hljs-string"><span class="hljs-string">'-&gt;'</span></span>, sentence_2)</code> </pre> <br><p>  Wir werden Token im Format [CLS] Phrase_1 [SEP] Phrase_2 [SEP] erstellen und mit dem Tokenizer einfachen Text in Token konvertieren: </p><br><pre> <code class="python hljs">tokens_sen_1 = tokenizer.tokenize(sentence_1) tokens_sen_2 = tokenizer.tokenize(sentence_2) tokens = [<span class="hljs-string"><span class="hljs-string">'[CLS]'</span></span>] + tokens_sen_1 + [<span class="hljs-string"><span class="hljs-string">'[SEP]'</span></span>] + tokens_sen_2 + [<span class="hljs-string"><span class="hljs-string">'[SEP]'</span></span>]</code> </pre> <br><p>  Wir konvertieren String-Token in numerische Indizes (Wortnummern im Vokabular "vocab.txt") und erweitern den Vektor auf 512: </p><br><pre> <code class="python hljs">token_input = tokenizer.convert_tokens_to_ids(tokens) token_input = token_input + [<span class="hljs-number"><span class="hljs-number">0</span></span>] * (<span class="hljs-number"><span class="hljs-number">512</span></span> - len(token_input))</code> </pre> <br><p>  Die Wortmaske ist in diesem Fall vollständig mit Nullen gefüllt </p><br><pre> <code class="python hljs">mask_input = [<span class="hljs-number"><span class="hljs-number">0</span></span>] * <span class="hljs-number"><span class="hljs-number">512</span></span></code> </pre> <br><p>  Die Vorschlagsmaske sollte jedoch unter der zweiten Phrase (einschließlich der endgültigen SEP) mit Einheiten und alles andere mit Nullen ausgefüllt werden: </p><br><pre> <code class="python hljs">seg_input = [<span class="hljs-number"><span class="hljs-number">0</span></span>]*<span class="hljs-number"><span class="hljs-number">512</span></span> len_1 = len(tokens_sen_1) + <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-comment"><span class="hljs-comment">#   , +2 -   CLS   SEP for i in range(len(tokens_sen_2)+1): # +1, ..   SEP seg_input[len_1 + i] = 1 #   ,   SEP,  #   numpy   (1,) -&gt; (1,512) token_input = np.asarray([token_input]) mask_input = np.asarray([mask_input]) seg_input = np.asarray([seg_input])</span></span></code> </pre> <br><p>  Wir leiten die Phrasen durch das neuronale Netzwerk (diesmal ist das Ergebnis in [1] und nicht in [0], wie oben). </p><br><pre> <code class="python hljs">predicts = model.predict([token_input, seg_input, mask_input])[<span class="hljs-number"><span class="hljs-number">1</span></span>]</code> </pre> <br><p>  Und wir leiten die Wahrscheinlichkeit ab, dass die zweite Phrase eine normale und keine zufällige Menge von Wörtern ist </p><br><pre> <code class="python hljs">print(<span class="hljs-string"><span class="hljs-string">'Sentence is okey:'</span></span>, int(round(predicts[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>]*<span class="hljs-number"><span class="hljs-number">100</span></span>)), <span class="hljs-string"><span class="hljs-string">'%'</span></span>)</code> </pre> <br><p>  In zwei Sätze: </p><br><p>  Ich kam in den Laden.  -&gt; Und kaufte Milch. </p><br><p>  Antwort des neuronalen Netzwerks: </p><br><p>  Satz ist ok: 99% </p><br><p>  Und wenn der zweite Satz "Crucian Sky Pluto" lautet, lautet die Antwort: </p><br><p>  Satz ist ok: 4% </p><br><h2 id="google-colab">  Google Colab </h2><br><p>  Google bietet eine kostenlose Tesla K80-Server-GPU mit 12 GB Videospeicher an (TPUs sind jetzt verfügbar, ihre Konfiguration ist jedoch etwas komplizierter).  Der gesamte Code für Colab sollte als Jupyter-Notizbuch konzipiert sein.  Um BERT in einem Browser zu starten, öffnen Sie einfach den Link </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">http://colab.research.google.com/github/blade1780/bert/blob/master/BERT.ipynb</a> </p><br><p>  <strong>Wählen Sie im</strong> Menü <strong>Laufzeit</strong> die <strong>Option</strong> <strong>Alle ausführen aus</strong> , damit zum ersten Mal alle Zellen gestartet werden, die Modelldownloads und die erforderlichen Bibliotheken verbunden werden.  Stimmen Sie zu, bei Bedarf alle Runtime zurückzusetzen. </p><br><div class="spoiler">  <b class="spoiler_title">Wenn etwas schief gelaufen ist ...</b> <div class="spoiler_text"><p>  Stellen Sie sicher, dass GPU und Python 3 im Menü Laufzeit -&gt; Laufzeittyp ändern ausgewählt sind </p><br><p>  Wenn die Schaltfläche Verbinden nicht aktiv ist, klicken Sie darauf, um eine Verbindung herzustellen. </p></div></div><br><p>  Ändern Sie nun die Eingabezeilen <strong>Satz</strong> , <strong>Satz_1</strong> und <strong>Satz_2</strong> und klicken Sie links auf das Wiedergabesymbol, um nur die aktuelle Zelle zu starten.  Das Ausführen des gesamten Notebooks ist nicht mehr erforderlich. </p><br><p>  Sie können BERT in Google Colab auch von einem Smartphone aus ausführen. Wenn es jedoch nicht geöffnet wird, müssen Sie möglicherweise das Kontrollkästchen Vollversion in Ihren Browsereinstellungen aktivieren. </p><br><h2 id="chto-dalshe">  Was weiter? </h2><br><p>  Um BERT für eine bestimmte Aufgabe zu trainieren, müssen Sie eine oder zwei Schichten eines einfachen Feed-Forward-Netzwerks hinzufügen und nur trainieren, ohne das Haupt-BERT-Netzwerk zu berühren.  Dies kann entweder auf nacktem TensorFlow oder über die Keras BERT-Shell erfolgen.  Ein solches zusätzliches Training für eine bestimmte Domäne erfolgt sehr schnell und ist der Feinabstimmung in Faltungsnetzwerken völlig ähnlich.  Für die SQuAD-Aufgabe können Sie also in nur 30 Minuten ein neuronales Netzwerk auf einer TPU trainieren (verglichen mit 4 Tagen auf 16 TPU für das Training von BERT selbst). </p><br><p>  Dazu müssen Sie untersuchen, wie die letzten Ebenen in BERT dargestellt werden, und über einen geeigneten Datensatz verfügen.  Auf der offiziellen BERT-Seite <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/google-research/bert</a> finden Sie mehrere Beispiele für verschiedene Aufgaben sowie Anweisungen zum Starten der Umschulung für Cloud-TPUs.  Und alles andere muss in der Quelle in den Dateien <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">run_classifier.py</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">extract_features.py nachsehen</a> . </p><br><h3 id="ps">  PS </h3><br><p>  Der hier vorgestellte Code und das Jupyter-Notizbuch für Google Colab <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><strong>werden im Repository gehostet</strong></a> . </p><br><p>  Wunder sind nicht zu erwarten.  Erwarten Sie nicht, dass BERT wie eine Person spricht.  Der Status des Standes der Technik bedeutet keineswegs, dass die Fortschritte in der NLP ein akzeptables Niveau erreicht haben.  Es bedeutet nur, dass BERT besser ist als frühere Modelle, die noch schlechter waren.  Starke Konversations-KI ist noch sehr weit weg.  Darüber hinaus ist BERT in erster Linie ein Sprachmodell und kein vorgefertigter Chat-Bot. Daher werden gute Ergebnisse erst nach einer Umschulung für eine bestimmte Aufgabe angezeigt. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de436878/">https://habr.com/ru/post/de436878/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de436866/index.html">Wie man gefälschte agile Projekte erkennt</a></li>
<li><a href="../de436868/index.html">Betten Sie statische Analysen in den Prozess ein und suchen Sie nicht nach Fehlern</a></li>
<li><a href="../de436872/index.html">PGConf.Russia 2019 kommt bald</a></li>
<li><a href="../de436874/index.html">Neujahrstänze rund um den FC-Adapter oder eine Geschichte darüber, wie weit die Ursachen des Problems von den Symptomen entfernt sind</a></li>
<li><a href="../de436876/index.html">[SAP] SAPUI5 für Dummies Teil 1: Eine vollständige Schritt-für-Schritt-Übung</a></li>
<li><a href="../de436880/index.html">Grundlagen der C ++ - Vorlage: Funktionsvorlagen</a></li>
<li><a href="../de436884/index.html">Wir beherrschen Async / Warten auf ein echtes Beispiel</a></li>
<li><a href="../de436886/index.html">Verwenden von Babel und Webpack zum Einrichten eines React-Projekts von Grund auf neu</a></li>
<li><a href="../de436888/index.html">Geschichte zum Entwerfen einer API</a></li>
<li><a href="../de436890/index.html">React Tutorial Teil 10: Workshop zum Arbeiten mit Komponenteneigenschaften und zum Styling</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>