<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📠 🛢️ 💅🏻 Nous implémentons OSGI sur la plateforme Karaf 🤡 🐄 👩🏿‍💻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="OSGI n'est pas difficile 
 J'ai rencontré à plusieurs reprises que l'OSGI est difficile. Et d'ailleurs, lui-même avait une fois une telle opinion. Ann...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Nous implémentons OSGI sur la plateforme Karaf</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435444/"><h2>  OSGI n'est pas difficile </h2><br>  J'ai rencontré à plusieurs reprises que l'OSGI est difficile.  Et d'ailleurs, lui-même avait une fois une telle opinion.  Année en 2009, pour être exact.  À cette époque, nous avons collecté des projets à l'aide de Maven Tycho et les avons déployés sur Equinox.  Et c'était vraiment plus difficile que de développer et d'assembler des projets pour JavaEE (à ce moment, la version d'EJB 3 vient d'apparaître, vers laquelle nous sommes passés).  Equinox était beaucoup moins pratique que Weblogic, par exemple, et les avantages d'OSGI n'étaient pas alors évidents pour moi. <br><br>  Mais ensuite, après de nombreuses années, j'ai dû démarrer un projet dans un nouvel emploi, qui a été conçu sur la base d'Apache Camel et Apache Karaf.  Ce n'était pas mon idée, je connaissais Camel depuis longtemps et j'ai décidé de lire sur Karaf, même sans offre.  Je l'ai lu un soir et j'ai réalisé - la voici, simple et prête à l'emploi, presque la même solution à certains problèmes d'un JavaEE typique, similaire à ce que j'ai fait une fois à genoux en utilisant Weblogic WLST, Jython et Maven Aether. <br><br>  Supposons donc que vous décidiez d'essayer OSGI sur la plate-forme Karaf.  Par où commencer? <br><a name="habracut"></a><br><h3>  Si vous voulez une compréhension plus profonde </h3><br>  Vous pouvez bien sûr commencer par lire la documentation.  Et c'est possible avec Habré - il y avait de très bons articles ici, disons il y a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">si</a> longtemps.  Mais en général, le karaf a reçu jusqu'à présent, sans le mériter, peu d'attention.  Il y avait quelques autres commentaires <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ceci</a> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cela</a> .  Il vaut mieux ignorer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cette</a> mention de karaf.  Comme on dit, ne lisez pas les journaux soviétiques pour la nuit ... car ils vous diront que le karaf est un cadre OSGI - donc vous n'y croyez pas.  Les frameworks OSGI sont Apache Felix ou Eclipse Equinox, sur la base desquels karaf fonctionne.  Vous pouvez choisir n'importe lequel d'entre eux. <br><br>  Il convient de noter que lorsque Jboss Fuse ou Apache ServiceMix est mentionné, il doit être lu comme «Karaf, avec des composants préinstallés», c'est-à-dire  en fait - la même chose, collectée uniquement par le vendeur.  Je ne recommanderais pas de commencer par cela dans la pratique, mais il est tout à fait possible de lire des articles de revue sur ServiceMix, par exemple. <br><br>  Pour commencer, je vais essayer de déterminer ici très brièvement ce qu'est l'OSGI et à quoi il peut servir. <br><br>  Dans l'ensemble, OSGI est un outil pour créer des applications Java à partir de modules.  Un analogue proche peut être considéré, par exemple, JavaEE, et dans une certaine mesure, les conteneurs OSGI peuvent exécuter des modules JavaEE (par exemple, des applications Web sous la forme de War), et d'autre part, de nombreux conteneurs JavaEE contiennent OSGI à l'intérieur comme moyen de mettre en œuvre la modularité "pour eux-mêmes" ".  Autrement dit, JavaEE et OSGI sont des choses similaires à la compatibilité et complémentaires avec succès. <br><br>  Une partie importante de tout système modulaire est la définition du module lui-même.  Dans le cas d'OSGI, le module est appelé un bundle, et c'est une archive jar bien connue de tous les développeurs avec quelques ajouts (c'est-à-dire qu'elle est très similaire ici, par exemple, à war ou ear).  Par analogie avec JavaEE, les bundles peuvent exporter et importer des services, qui sont essentiellement des méthodes de classe (c'est-à-dire qu'un service est une interface ou toutes les méthodes publiques d'une classe). <br><br>  Les métadonnées du bundle sont familières à tout le monde META-INF / MANIFEST.MF.  Les en-têtes du manifeste OSGI ne se croisent pas avec les en-têtes pour le JRE, respectivement, en dehors du bundle de conteneur OSGI est un bocal ordinaire.  Il est significatif que parmi les métadonnées, il y ait toujours: <br><br><pre><code class="plaintext hljs">Bundle-SymbolicName: com.example.myosgi Bundle-Version: 1.0.0</code> </pre> <br>  Ce sont les «coordonnées» du bundle, et le fait que nous pouvons avoir deux ou plusieurs versions simultanément installées et fonctionnelles du même bundle dans un conteneur est important. <br><br>  Comme pour JavaEE, les bundles ont un cycle de vie qui ressemble à ceci: <img src="https://habrastorage.org/getpro/habr/post_images/b71/a55/263/b71a5526390ea0fd4eaf02a3d5edc67a.png" alt="image">  En plus des services, les bundles peuvent également importer et exporter des packages (packages, au sens habituel du terme pour java).  Les packages exportés sont définis à l'intérieur du bundle et sont mis à la disposition des autres composants lorsque le bundle est installé sur le système.  Ceux importés sont définis quelque part de l'extérieur, doivent être exportés par quelqu'un et fournis au bundle par le conteneur avant qu'il puisse commencer à fonctionner. <br><br>  Les importations de packages peuvent être déclarées facultatives, ainsi que les importations de services.  Et il est assez important que l'importation et l'exportation contiennent une indication de la version (ou de la plage de versions). <br><br><h4>  Différences avec JavaEE </h4><br>  Eh bien, c'est bien qu'ils se ressemblent - nous avons compris.  Et en quoi diffèrent-ils? <br><br>  À mon avis, la principale différence est que l'OSGI nous donne beaucoup plus de flexibilité.  Une fois que le bundle est à l'état DÉMARRÉ, les possibilités ne sont limitées que par votre imagination.  Disons que vous pouvez facilement créer des threads (oui, oui, je connais ManagedExecutorService), des pools de connexions aux bases de données, etc.  Un conteneur ne prend pas le contrôle de toutes les ressources dans la même mesure que JavaEE. <br><br>  Vous pouvez exporter de nouveaux services dans le processus.  Essayez de dire en JavaEE créer dynamiquement un nouveau servlet?  Et ici, il est tout à fait possible, en outre, que le conteneur de servlet karaf créé sur la base de jetty soit immédiatement détecté par votre servlet créé et qu'il soit disponible pour les clients à une URL spécifique. <br><br>  Bien que ce soit une légère simplification, mais si l'application JavaEE dans sa forme classique se compose principalement de composants: <br><br><ul><li>  passif, en attente d'un appel du client </li><li>  définis statiquement, c'est-à-dire au moment du déploiement de l'application. </li></ul><br>  En revanche, une application basée sur OSGI peut contenir: <br><br><ul><li>  composants programmés actifs et passifs, exécution de sondages, enfin, écoute d'une socket, etc. </li><li>  les services peuvent être définis et publiés dynamiquement </li><li>  Vous pouvez vous abonner à des événements de cadre, par exemple, écouter l'enregistrement des services, des bundles, etc., recevoir des liens vers d'autres bundles et services, et faire bien plus encore. </li></ul><br>  Oui, sur JavaEE, une grande partie de cela est également partiellement possible (par exemple, via JNDI), mais dans le cas d'OSGI, dans la pratique, cela est rendu plus facile.  Bien qu'il y ait probablement quelques risques supplémentaires ici. <br><br><h4>  Différences entre karaf et OSGI pur </h4><br>  En plus du framework karaf, il y a beaucoup de choses utiles.  Essentiellement, karaf est un outil pour gérer facilement le cadre OSGI - y installer des bundles (y compris des groupes), les configurer, surveiller, décrire le modèle de rôle et assurer la sécurité, etc. <br><br><h2>  Et pratiquons déjà? </h2><br>  Eh bien, commençons tout de suite avec l'installation.  Il n'y a pas grand-chose à écrire ici - allez sur karaf.apache.org, téléchargez le package de distribution, décompressez-le.  Les versions de karaf diffèrent dans la prise en charge des différentes spécifications OSGI (4, 5 ou 6) et des versions Java.  Je ne recommande pas la famille 2.x, mais 3 (si vous avez Java 8, comme le mien) et 4 peuvent être utilisés, bien qu'aujourd'hui seule la famille 4.x se développe (version actuelle 4.2.2, elle prend en charge OSGI 6 et Java jusqu'à 10). <br><br>  Karaf fonctionne bien sous Windows et Linux, tout ce dont vous avez besoin pour créer un service et l'exécution automatique est disponible.  La prise en charge de MacOS et de nombreux autres types d'Unix est également déclarée. <br><br>  Vous pouvez généralement démarrer karaf immédiatement si vous êtes sur Internet.  Sinon, cela vaut généralement la peine de corriger le fichier de configuration, en indiquant où vous avez le ou les référentiels maven.  Habituellement, ce sera un Nexus d'entreprise, ou disons Artifactory, qui aime quoi.  La configuration karaf se trouve dans le dossier etc de la distribution.  Les noms des fichiers de configuration ne sont pas très évidents, mais dans ce cas, vous avez besoin du fichier org.ops4j.pax.url.mvn.cfg.  Le format de ce fichier est les propriétés java. <br><br>  Vous pouvez spécifier le (s) référentiel (s) à la fois dans le fichier de configuration lui-même, en répertoriant la liste des URL dans les paramètres ou simplement en montrant où se trouve votre fichier settings.xml.  Là, le karaf prendra l'emplacement de votre proxy, ce qui est généralement nécessaire de connaître sur l'intranet. <br><br>  Kafar a besoin de plusieurs ports, ce sont HTTP, HTTPS (si le web est configuré, par défaut non), SSH, RMI, JMX.  S'ils sont occupés avec vous ou si vous souhaitez exécuter plusieurs copies sur le même hôte, vous devrez également les modifier.  Il y a environ cinq de ces ports. <br><br>  Ports tels que jmx et rmi - ici: org.apache.karaf.management.cfg, ssh - org.apache.karaf.shell.cfg, pour changer les ports http / https, vous devrez créer (très probablement pas) le fichier etc / org.ops4j.pax.web.cfg et écrivez la valeur org.osgi.service.http.port = port dont vous avez besoin. <br><br>  Ensuite, vous pouvez certainement le démarrer, et en règle générale, tout commencera.  Pour une utilisation industrielle, vous devrez évidemment apporter des modifications au fichier bin / setenv ou bin / setenv.bat, par exemple, pour allouer la quantité de mémoire requise, mais d'abord, pour voir, ce n'est pas nécessaire. <br><br>  Vous pouvez démarrer Karaf immédiatement avec la console, la commande karaf, ou vous pouvez l'exécuter en arrière-plan avec la commande start server, puis vous y connecter via SSH.  Il s'agit d'un SSH entièrement standard, avec prise en charge de SCP et SFTP.  Vous pouvez exécuter des commandes et copier des fichiers dans les deux sens.  Il est possible de se connecter avec n'importe quel client, par exemple, mon outil préféré est Far NetBox.  La connexion est disponible par identifiant et mot de passe, ainsi que par clés.  Dans les abats jsch, avec tout ce que cela implique. <br><br>  Je recommande d'avoir une fenêtre de console supplémentaire immédiatement pour afficher les journaux qui se trouvent dans data / log / karaf.log (et d'autres fichiers sont généralement là, bien que cela soit personnalisable).  Les journaux vous sont utiles, à partir de messages courts dans la console, tout n'est pas clair. <br><br>  Je conseillerais d'installer immédiatement le Web et la console Web hawtio.  Ces deux choses vous permettront de naviguer plus facilement dans ce qui se passe dans le conteneur et de diriger le processus à partir de là dans une large mesure (en bonus, vous obtiendrez du jolokia et la possibilité de surveiller via http).  L'installation de hawtio se fait par deux commandes depuis la console karaf ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">comme décrit ici</a> ), et hélas, aujourd'hui la version de karaf 3.x n'est plus supportée (vous devrez chercher des versions plus anciennes de hawtio). <br><br>  Hors de la boîte, https ne sera pas immédiatement, pour cela, vous devez faire des efforts tels que la génération de certificats, etc. L'implémentation est basée sur Jetty, donc tous ces efforts sont principalement effectués de la même manière. <br><br><h2>  OK, ça a commencé, quelle est la prochaine étape? </h2><br><img src="https://habrastorage.org/webt/lh/ty/ge/lhtygefalzjfywb-3lr088qvrha.png"><br><br>  En fait, à quoi vous attendiez-vous?  J'ai dit que ce sera ssh.  Tab fonctionne, si cela. <br><br>  Il est temps d'installer une application.  Une application pour OSGI est soit un bundle, soit se compose de plusieurs bundles.  Karaf peut déployer des applications dans plusieurs formats: <br><br><ul><li>  Un ensemble de pots, avec ou sans manifeste OSGI </li><li>  xml contenant Spring DM ou Blueprint </li><li>  xml contenant la soi-disant fonctionnalité, qui est une collection de bundles, d'autres fonctionnalités et de ressources (fichiers de configuration) </li><li>  Archive .kar contenant plusieurs fonctionnalités et un référentiel maven avec des dépendances </li><li>  Applications JavaEE (sous certaines conditions supplémentaires), par exemple .war </li></ul><br>  Il existe plusieurs façons de procéder: <br><br><ul><li>  mettre l'application dans le dossier de déploiement </li><li>  installez à partir de la console avec la commande install </li><li>  installer la fonctionnalité avec la commande de la fonctionnalité: installer la console </li><li>  kar: installer </li></ul><br>  Eh bien, en général, c'est assez similaire à ce qu'un conteneur JavaEE typique peut faire, mais c'est un peu plus pratique (je dirais que c'est beaucoup plus pratique). <br><br><h3>  Pot simple </h3><br>  L'option la plus simple consiste à installer un bocal ordinaire.  Si vous l'avez dans le référentiel maven, alors la commande suffit pour installer: <br><br><pre> <code class="bash hljs">install mvn:groupId/artifactId/version</code> </pre> <br>  Dans le même temps, Karaf se rend compte qu'il a un pot régulier devant lui et le traite, créant un emballage de paquet à la volée, le soi-disant  wrapper, générant un manifeste par défaut, avec les importations et les exportations de packages. <br><br>  Le sentiment d'installer juste un bocal n'est généralement pas beaucoup, car ce bundle sera passif - il exporte uniquement les classes qui seront disponibles pour d'autres bundles. <br><br>  Cette méthode est utilisée pour installer des composants comme Apache Commons Lang, par exemple: <br><br><pre> <code class="bash hljs">install mvn:org.apache.commons.lang3/commons-lang/3.8.1</code> </pre> <br>  Mais cela n'a pas fonctionné :) Voici les coordonnées correctes: <br><br><pre> <code class="bash hljs">install mvn:org.apache.commons/commons-lang3/3.8.1</code> </pre> <br>  Voyons ce qui s'est passé: list -u nous montrera les bundles et leurs sources: <br><br><pre> <code class="bash hljs">karaf@root()&gt; list -u START LEVEL 100 , List Threshold: 50 ID | State | Lvl | Version | Name | Update location ------------------------------------------------------------------------------------------------- 87 | Installed | 80 | 3.8.1 | Apache Commons Lang | mvn:org.apache.commons/commons-lang3/3.8.1 88 | Installed | 80 | 3.6.0 | Apache Commons Lang | mvn:org.apache.commons/commons-lang3/3.6</code> </pre> <br>  Comme vous pouvez le voir, il est tout à fait possible d'installer deux versions d'un composant.  Emplacement de mise à jour - c'est là que nous avons obtenu le bundle et où il peut être mis à jour si nécessaire. <br><br><h3>  Contexte Jar et Spring </h3><br>  S'il y a un contexte printanier à l'intérieur de votre pot, les choses deviennent plus intéressantes.  Karaf Deployer recherche automatiquement les contextes xml dans le dossier META-INF / spring et les crée si tous les bundles externes nécessaires au bundle ont été trouvés avec succès. <br><br>  Ainsi, tous les services qui étaient à l'intérieur des contextes démarreront déjà.  Si vous aviez Camel Spring là-bas, par exemple, les itinéraires Camel commenceront également.  Cela signifie que nous disons un service REST, ou un service d'écoute sur un port TCP, vous pouvez déjà démarrer.  Bien sûr, lancer plusieurs services en écoutant sur un port ne fonctionnera pas de cette façon. <br><br><h3>  Contexte XML Just Spring </h3><br>  Si, par exemple, vous disposiez de définitions JDBC DataSources dans Spring Context, vous pouvez les installer séparément dans Karaf.  C'est-à-dire  prendre un fichier xml contenant uniquement un DataSource sous la forme de &lt;bean&gt;, ou tout autre ensemble de composants, vous pouvez le placer dans le dossier de déploiement.  Le contexte sera lancé de manière standard.  Le seul problème est que les DataSources créées de cette manière ne seront pas visibles par les autres bundles.  Ils doivent être exportés vers OSGI en tant que services.  À ce sujet - un peu plus tard. <br><br><h3>  Printemps dm </h3><br>  Quelle est la différence entre Spring DM (version compatible OSGI) et Spring classique?  Ainsi, dans le cas classique, tous les beans du contexte sont créés au stade de l'initialisation du contexte.  Les nouveaux ne peuvent pas apparaître, les anciens n'iront nulle part.  Dans le cas d'OSGI, de nouveaux bundles peuvent être installés et les anciens bundles supprimés.  L'environnement devient plus dynamique, vous devez en quelque sorte réagir. <br><br>  La méthode de réponse est appelée services.  Un service est généralement une certaine interface, avec ses propres méthodes, qui est publiée par un ensemble.  Un service a des métadonnées qui lui permettent d'être recherché et distingué d'un autre service qui implémente une interface similaire (évidemment, à partir d'une autre DataSource).  Les métadonnées sont un simple ensemble de propriétés de valeur-clé. <br><br>  Étant donné que les services peuvent apparaître et disparaître, ceux qui en ont besoin peuvent souscrire à des services au démarrage ou écouter des événements pour connaître leur apparition ou leur disparition.  Au niveau de Spring DM, en XML, cela est implémenté en deux éléments, service et référence, dont le but de base est assez simple: publier le bean existant à partir du contexte en tant que service, et s'abonner à un service externe en le publiant dans le contexte Spring actuel. <br><br>  Par conséquent, lors de l'initialisation d'un tel bundle, le conteneur trouvera les services externes dont il a besoin pour lui et publiera les bundles implémentés à l'intérieur, les rendant accessibles de l'extérieur.  Un bundle ne démarre qu'après la résolution des liens de service. <br><br>  En fait, tout est un peu plus compliqué, car le bundle peut utiliser une liste de services similaires et s'abonner immédiatement à la liste.  C'est-à-dire  un service, en général, a une propriété telle que la cardinalité, qui prend la valeur 0..N.  Dans ce cas, l'abonnement, où 0..1 est indiqué, décrit un service facultatif, et dans ce cas, le bundle démarre correctement même s'il n'y a pas un tel service dans le système (et au lieu d'un lien vers celui-ci, il obtiendra un talon). <br><br>  Je note qu'un service est n'importe quelle interface (ou vous pouvez publier uniquement des classes), vous pouvez donc bien publier java.util.Map avec des données en tant que service. <br><br>  Entre autres choses, le service vous permet de spécifier des métadonnées et la référence vous permet de rechercher un service par ces métadonnées. <br><br><h3>  Blueprint </h3><br>  Blueprint est la nouvelle incarnation de Spring DM, qui est un peu plus simple.  À savoir, si au printemps vous avez des éléments XML personnalisés, ils ne sont pas là, car ils ne sont pas nécessaires.  Parfois, cela cause toujours des désagréments, mais franchement - rarement.  Si vous ne migrez pas un projet à partir de Spring, vous pouvez commencer immédiatement avec Blueprint. <br><br>  L'essence ici est la même - c'est XML, qui décrit les composants à partir desquels le contexte du bundle est assemblé.  Pour ceux qui connaissent le printemps, rien n'est inconnu du tout. <br><br>  Voici un exemple de description d'un DataSource et de son exportation en tant que service: <br><br><pre> <code class="xml hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">blueprint</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">xmlns</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"http://www.osgi.org/xmlns/blueprint/v1.0.0"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bean</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"dataSource"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"oracle.jdbc.pool.OracleDataSource"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">property</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"URL"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"URL"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">property</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"user"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"USER"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">property</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"password"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"PASSWORD"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bean</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">service</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">interface</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"javax.sql.DataSource"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ref</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"dataSource"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"ds"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">service-properties</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">entry</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">key</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"osgi.jndi.service.name"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"jdbc/ds"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">service-properties</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">service</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">blueprint</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Eh bien, nous avons déployé ce fichier dans le dossier de déploiement et examiné les résultats de la commande list.  Ils ont vu que le paquet n'a pas commencé - dans le statut Indtalled.  Nous essayons de démarrer et nous obtenons un message d'erreur. <br><br>  Maintenant dans la liste des bundles au statut Echec.  Quoi de neuf?  Évidemment, il a également besoin de dépendances, dans ce cas, un Jar avec des classes Oracle JDBC, ou plus précisément, le package oracle.jdbc.pool. <br>  Nous trouvons le fichier jar nécessaire dans le référentiel, ou téléchargeable à partir du site Oracle, et installons, comme décrit précédemment.  Notre DataSource a démarré. <br><br>  Comment utiliser tout ça?  Le lien de service est appelé dans la référence Blueprint (quelque part, dans le contexte d'un autre bundle): <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">reference</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"dataSource"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">interface</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"javax.sql.DataSource"</span></span></span><span class="hljs-tag">/&gt;</span></span></code> </pre> <br>  Ensuite, ce bean devient, comme d'habitude, une dépendance pour d'autres beans (dans l'exemple camel-sql): <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bean</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"sql"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"org.apache.camel.component.sql.SqlComponent"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">property</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"dataSource"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ref</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"dataSource"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bean</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><h3>  Pot et activateur </h3><br>  La manière canonique d'initialiser des bundles consiste à utiliser une classe qui implémente l'interface Activator.  Il s'agit d'une interface de cycle de vie typique contenant des méthodes de démarrage et d'arrêt qui passent le <i>contexte</i> .  À l'intérieur, le bundle démarre généralement ses threads, si nécessaire, commence à écouter les ports, s'abonne à des services externes à l'aide de l'API OSGI, etc.  C'est peut-être la manière la plus complexe, la plus élémentaire et la plus flexible.  Depuis trois ans, je n'en ai jamais eu besoin. <br><br><h2>  Paramètres et configuration </h2><br>  Il est clair qu'une telle configuration de DataSource, comme le montre l'exemple, nécessite peu de personnes.  Login, mot de passe et plus encore, tout est codé en dur dans XML.  Il est nécessaire de supprimer ces paramètres. <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">property</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"url"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"${oracle.ds.url}"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">property</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"user"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"${oracle.ds.user}"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">property</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"password"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"${oracle.ds.password}"</span></span></span><span class="hljs-tag">/&gt;</span></span></code> </pre> <br>  La solution est assez simple et similaire à celle utilisée dans le Spring classique: à un certain point du cycle de vie du contexte, les valeurs des propriétés sont substituées à partir de diverses sources. <br><br>  Sur ce, nous terminerons la première partie.  S'il y a un intérêt pour ce sujet, alors continuez.  Nous verrons comment assembler des applications à partir de bundles, configurer, surveiller et déployer automatiquement des systèmes sur cette plate-forme. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr435444/">https://habr.com/ru/post/fr435444/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr435430/index.html">Les nouvelles les plus cool CES 2019</a></li>
<li><a href="../fr435432/index.html">Nouvelle année, nouveau GitHub: dépôts privés gratuits illimités</a></li>
<li><a href="../fr435436/index.html">5 tendances de l'infrastructure informatique: prévisions pour 2019</a></li>
<li><a href="../fr435438/index.html">PHP: changer la structure de la base de données dans le développement d'équipe</a></li>
<li><a href="../fr435442/index.html">Entonnoir de changement</a></li>
<li><a href="../fr435446/index.html">Algorithme de Verhuff pour un système de nombres pairs arbitraires</a></li>
<li><a href="../fr435448/index.html">À propos de l'expérience de la communication avec un générateur de signaux via QTcpSocket et SCPI</a></li>
<li><a href="../fr435450/index.html">Bonne année, bonne nouvelle MQTT / UDP</a></li>
<li><a href="../fr435452/index.html">Test de bout en bout des microservices avec Catcher</a></li>
<li><a href="../fr435454/index.html">AOP vs fonctionnalités</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>