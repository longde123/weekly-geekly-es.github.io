<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>☂️ 🧘 👩🏽‍⚕️ Apa tumpukan MERN, dan bagaimana cara mengatasinya? 🆙 🔫 🏇🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habr! 

 Sekali waktu, kami merilis proyek percontohan pada tumpukan MEAN (Mongo, Express, Angular, Node), yang umumnya tidak mengecewakan kami,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Apa tumpukan MERN, dan bagaimana cara mengatasinya?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/458096/">  Halo, Habr! <br><br>  Sekali waktu, kami merilis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">proyek</a> percontohan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pada tumpukan MEAN</a> (Mongo, Express, Angular, Node), yang umumnya tidak mengecewakan kami, namun, kami memutuskan untuk tidak melakukan cetakan tambahan dan pembaruan pada saat itu - tidak seperti Manning, yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">memperbarui</a> buku ini. .  Namun demikian, kami terus mencari ke arah ini dan hari ini kami ingin berbicara dengan Anda tentang tumpukan MERN terkait, di mana React berada pada klien, bukan Angular.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Lantai</a> diberikan kepada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tim Smith</a> . <br><br><img src="https://habrastorage.org/webt/1d/hf/l7/1dhfl7yw9am620o13r-nz-i4il8.jpeg"><br><a name="habracut"></a><br>  Peringatan: semua kode untuk artikel ini ada di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br>  Dalam panduan tumpukan MERN ini, kami akan menulis blog sederhana menggunakan React.js, Node.js, Express.js, dan MongoDB untuk memperluas gudang senjata stack penuh kami. <br><br><h3>  Apa itu tumpukan? </h3><br>  Mungkin hal pertama yang dibahas adalah gagasan "tumpukan".  Ada banyak tumpukan berbeda, dan semuanya hanyalah jalur yang berbeda untuk mencapai tujuan yang sama.  Saat membuat aplikasi tumpukan penuh, kami menyediakan untuk bagian klien dengan siapa pengguna akan berinteraksi, dan bagian klien yang sama akan memediasi pekerjaan dengan server dan database - membuat seluruh proses ini sesederhana dan dapat dikelola mungkin. <br><br>  Kita dapat mengatakan bahwa tumpukan adalah seperangkat teknologi tertentu yang digunakan untuk menyelesaikan masalah ini. <br><br>  Meskipun ada banyak tumpukan yang layak dibicarakan, beberapa di antaranya lebih populer daripada yang lain saat ini.  Salah satu tumpukan populer ini disebut MEAN, dan terdiri dari: <br><br><ul><li>  <b>M</b> ongoDb </li><li>  <b>E</b> xpress.js </li><li>  <b>A</b> ngular.js </li><li>  Tidak ada </li></ul><br>  Hari ini kita akan berbicara tentang tumpukan MERN, yang sangat mirip dengan MEAN kecuali bahwa Angular.js diganti di sini dengan React.js.  Dengan demikian, kita dapat menggunakan MongoDB sebagai database, Node.js dan Express, masing-masing, untuk server dan perutean, dan React.js - untuk membuat bagian klien yang dengannya pengguna akan berinteraksi. <br><br><h3>  Bagaimana pengembangan dilakukan dengan tumpukan ini? </h3><br>  Sebelum beralih ke semua seluk-beluk, mari kita lihat secara umum bagaimana semua elemen ini bekerja bersama.  Secara pribadi, butuh beberapa saat untuk membahas hal ini, karena latar belakang saya terkait dengan PHP, di mana bagian klien dan server agak campur aduk. <br><br>  <i>1. Bagian server (Node dan Express.js) dan bagian klien (React.js)</i> <br><br>  Pertama-tama, Anda perlu memahami bahwa bagian server dan bagian klien adalah entitas yang terpisah.  Bagian klien mungkin dalam repositori yang sama dengan server, atau mungkin dalam yang sama sekali berbeda. <br><br>  <i>2. Terminal API digunakan untuk komunikasi</i> <br><br>  Jika Anda sudah memikirkan cara berteman dengan klien dan bagian server, saya akan menjawab: ini dilakukan melalui API.  API (antarmuka program aplikasi) dibuat di server, di mana kita akan mendapatkan "terminal" di mana aplikasi yang terletak di bagian klien dapat berinteraksi dengan server. <br><br>  Mari kita jelaskan dengan jari: bayangkan tangan kiri Anda adalah sisi server, dan tangan kanan Anda adalah sisi klien. <br><br>  Sekarang lipat tangan Anda dan putar jari-jari Anda seolah-olah menjabat tangan Anda sendiri.  Itulah cara kerja bahasa templat.  Mereka memungkinkan Anda untuk hanya menampilkan markup bersama dengan data yang dibuang dengan server - dan di dalamnya komponen klien dan server tumpang tindih sebagian besar. <br><br>  Sekarang buka tanganmu.  Sebarkan jari-jari Anda selebar mungkin dan buat tangan kiri dan kanan hanya menyentuh ujung jari Anda.  Ini adalah cara kerja tumpukan MERN.  Bagian server menyediakan terminal (ujung jari dari tangan kiri) untuk akses ke server, tempat klien mengirim panggilan (melalui ujung jari-jari tangan kanan) dan melalui titik-titik kontak ini bertukar informasi dengan server (tangan kiri). <br><br>  Saya berharap itu menjadi sedikit lebih jelas, dan jika tidak, lupakan semua metafora ini, seolah-olah saya tidak menyebutkannya. <br><br><h3>  Sisi server kami dari Node.js dan Express.js </h3><br>  Meskipun saya tidak akan memberikan petunjuk langkah demi langkah tentang cara membangun tumpukan ini di sini (ini adalah topik untuk artikel terpisah), saya ingin mempertimbangkan berbagai elemen tumpukan yang biasanya digunakan atau dapat digunakan di dalamnya.  Saya sendiri membaca beberapa manual yang memberi tahu cara mengkonfigurasi server, tetapi tidak menjelaskan mengapa perpustakaan khusus ini digunakan untuk ini. <br><br>  Setelah kami membuat file app.js, Anda perlu menginstal sejumlah paket.  Berikut ini adalah paket paling umum yang sebelumnya saya gunakan dalam proyek saya dengan Express.js - mungkin mereka akan berguna bagi Anda juga. <br><br><ul><li>  <b>Express.js</b> adalah kerangka kerja untuk membuat aplikasi web.  Ini memiliki fungsi bawaan untuk menyelesaikan banyak masalah, khususnya, untuk menetapkan rute. </li><li>  <b>Mongoose</b> adalah manajer data objek (ODM) yang menyediakan interoperabilitas antara aplikasi express.js dan database MongoDB. </li><li>  <b>BodyParser</b> adalah pustaka yang memungkinkan aplikasi express.js untuk membaca isi (mis., Konten) dari permintaan yang masuk. </li><li>  <b>DotENV</b> - memungkinkan Anda menggunakan file dengan ekstensi .env untuk bekerja dengan data rahasia. </li><li>  <b>Passport.js</b> - menyediakan otentikasi dalam aplikasi kami, dan menyediakan beberapa metode otentikasi yang berbeda. </li><li>  <b>Validator</b> - validasi sederhana dari banyak tipe data </li><li>  <b>bCrypt</b> - enkripsi data sensitif, seperti kata sandi </li><li>  <b>Nodemon</b> - “hot reboot” untuk node-server kami jika situasinya berubah;  Berkat Nodemon, Anda tidak dapat menghentikan atau memulai ulang server setelah melakukan perubahan apa pun. </li></ul><br>  Tentu saja, ada banyak paket lain, tetapi menurut pengalaman saya, perpustakaan inilah yang paling sering digunakan. <br><br>  Jadi, setelah memilah-milah beberapa paket yang paling banyak digunakan, mari kita lihat kodenya.  Untuk memulai - server kami: <br><br><img src="https://habrastorage.org/webt/xk/g7/f_/xkg7f_3zeltvgqsj-knjstppros.png"><br><br>  Ini adalah server API sederhana.  Seperti yang Anda lihat, itu dilengkapi dengan fungsionalitas CRUD dasar (Buat-Baca-Perbarui-Hapus) - tidak ada yang supernatural.  Melihat lebih dekat, kita melihat bahwa <code>res.json()</code> digunakan di sini untuk memberikan data output untuk URL tertentu - yaitu, HTML atau templat lain tidak digunakan untuk output.  Ini adalah bagaimana kami membangun API kami dengan membuka akses data ke React.js. <br><br>  Anda mungkin juga memperhatikan bahwa saya baru saja menunjuk luwak ke server mongodb saya sendiri yang diinstal pada komputer saya.  Agar mekanisme seperti itu berfungsi dengan benar, MongoDB harus diinstal di komputer dan kantor Anda.  Jika tidak berhasil, buka saja jendela konsol dan masukkan perintah berikut: <br><br><img src="https://habrastorage.org/webt/yz/fr/o2/yzfro2ns9az9yqno2kc522rdnfa.png"><br><br>  Ini akan memulai server MongoDB pada mesin lokal Anda.  Karena semua ini dilakukan secara lokal, Anda tidak akan dapat melihat posting saya jika Anda menjalankan kode dari repositori.  Kami harus menulis konten baru sendiri.  Jika Anda memerlukan rintisan konten, saya sarankan generator <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Fillerama.io yang</a> sangat baik, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengiris</a> teks dari beberapa film dan acara TV favorit saya. <br><br>  Jika Anda tertarik untuk menguji server sendiri, Anda dapat memulainya dengan perintah berikut: <br><br><img src="https://habrastorage.org/webt/83/fr/1z/83fr1z4cgcdnjrx9up44nk5enxe.png"><br><br>  Setelah server mulai dan memberi tahu kami bahwa ia berfungsi pada port 3333, dan juga terhubung ke MongoDB, Anda dapat membuka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tukang pos</a> dan menguji rute kami di sana.  Adapun opsi GET, Anda cukup menyisipkan rute dan klik "Kirim".  Dalam hal POST, Anda harus memilih "Badan" dan mengisi bidang untuk header dan konten utama. <br><br><h3>  Catatan sisi klien </h3><br>  Sekarang kami telah mengkonfigurasi dan meluncurkan server kami, kami dapat mulai bekerja pada klien yang akan berinteraksi dengan pengguna kami.  Klien akan ditulis dalam React.js, dan ini dapat dilakukan dengan beberapa cara berbeda. <br><br>  Yang pertama adalah hanya menambahkan semua pustaka yang diperlukan untuk sisi klien (react, react-dom, react-router, dll) semua ke file <code>package.json</code> sama di mana kami menulis pustaka server.  Dalam proyek ini, saya hanya melakukan itu, tetapi saya harus mengatakan bahwa saya tidak berpikir opsi ini optimal.  Saya pikir seiring perkembangan proyek kami, basis kode akan menjadi semakin rumit, dan jika Anda hanya menggunakan metode ini, maka bekerja dengannya akan menjadi lebih rumit di masa mendatang.  Saya lebih suka jalur ini dalam aplikasi yang dijelaskan justru karena saya tahu pasti: itu tidak akan tumbuh dan tidak akan berubah sama sekali.  Aplikasi ini ditulis hanya untuk keperluan demonstrasi. <br><br>  Pendekatan kedua dan (menurut saya) yang lebih optimal adalah membuat repositori terpisah untuk sisi server dan terpisah untuk klien.  Kami masih dapat mengkloning repositori bagian klien ke direktori dengan proyek kami tanpa masalah, pastikan saja bahwa bagian klien terdaftar dalam file <code>.gitignore</code> kami.  Misalnya, dalam struktur file untuk aplikasi ini ada direktori <code>client</code> , di mana semua kode bagian klien berada.  Kita bisa membawanya ke repositori yang benar-benar terpisah, dan kemudian cukup menambahkan entri berikut ke file <code>.gitignore</code> repositori kami dengan sisi server: <br><br><img src="https://habrastorage.org/webt/o8/sy/h4/o8syh4xj4rxbc5te5wwk_ax_7bc.png"><br><br>  Dengan menambahkan folder <code>client</code> ke file <code>.gitignore</code> , kami menjamin bahwa sistem tidak akan menganggap folder ini sebagai repositori kedua dalam proyek.  Selain itu, pendekatan ini memfasilitasi pekerjaan mendesain ulang atau mengganti bagian klien, karena bagian server tidak terpengaruh sama sekali. <br><br>  Bagaimana tepatnya aplikasi tumpukan penuh Anda akan dirancang sepenuhnya terserah Anda.  Sepertinya saya bahwa jika Anda menyimpan repositori terpisah untuk bagian klien dan server, struktur aplikasi akan sedikit lebih akurat. <br><br><h3>  Kami membuat bagian klien di React.js </h3><br>  Sekarang, setelah memahami organisasi proyek, mari kita bicara, sebenarnya, tentang kode klien.  Di bawah ini adalah file <code>app.js</code> saya untuk aplikasi di React.js, dan saya tidak akan menyisipkan kode untuk setiap komponen dalam posting ini, saya hanya meninggalkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tautan</a> ke repositori dan menjelaskan apa yang masing-masing komponen Bereaksi lakukan. <br><br>  Dan inilah tampilan screenshot halaman utama aplikasi kita: <br><br><img src="https://habrastorage.org/webt/rp/j-/yz/rpj-yzfnehkwotobufkxqxf3zzi.png"><br><br>  Seperti yang Anda lihat, <code>app.js</code> sekali tidak rumit.  Ada &lt;Router&gt; yang memungkinkan Anda mengatur rute di React.js yang menampilkan berbagai komponen berdasarkan URL mereka.  Berikut adalah komponen lain yang akan digunakan dalam aplikasi React.js kami: <br><br><ul><li>  <b>Header</b> - Bilah navigasi yang terletak di bagian atas layar </li><li>  <b>Indeks</b> - Mendaftar entri blog yang tersedia </li><li>  <b>Baru</b> - Formulir di mana pengguna dapat membuat posting baru </li><li>  <b>Single</b> - Menampilkan entri blog tertentu berdasarkan <code>id</code> -nya </li><li>  <b>Sunting</b> - Formulir di mana pengguna dapat memperbarui entri blog yang ditemukan oleh <code>id</code> </li></ul><br>  Kami menggunakan Axios untuk melakukan panggilan http ke terminal API, dan kemudian menggunakan React.js untuk menampilkan data sesuka kami.  Dalam posting ini saya akan memberikan kode Index.js untuk membuatnya lebih jelas bagaimana semuanya bekerja bersama. <br><br><img src="https://habrastorage.org/webt/9j/dp/wo/9jdpwo-gh8ifomloyx0cibju1mi.png"><br><br>  Dalam kode di atas, komponen kelas terlibat, memungkinkan kita untuk menggunakan metode status dan siklus hidup.  Ini diperlukan karena panggilan Axios harus dibuat dalam metode siklus hidup <code>componentDidMount()</code> .  Perlu dicatat bahwa saya mendapatkan kesalahan CORS ketika mencoba melakukan panggilan ke API lokal saya.  Untuk mengatasi masalah ini, saya menambahkan beberapa header ke file server.js di server Express saya - dan itu berhasil.  Kode ini tercantum dalam komentar di file server.js. <br><br>  <i>Mari kita pastikan bahwa bot pencarian membaca aplikasi React.js kami secara normal.</i> <br><br>  Mengakhiri, saya ingin berbicara singkat tentang rendering.  Jika Anda meluncurkan situs kami dan langsung menuju beberapa posting blog, maka mungkin ada beberapa masalah dengan tampilan konten.  Dalam hal ini, menjelajah situs akan merepotkan tidak hanya untuk pengguna, tetapi juga untuk mencari konten pengindeksan robot.  Untuk mengatasi masalah ini, saya sarankan menggunakan alat seperti Gatsby js atau Next js.  Kedua solusi ini berbeda satu sama lain, tetapi keduanya dapat berguna, tergantung pada apa yang Anda butuhkan. <br><br>  Gatsby js adalah generator situs statis.  Anda dapat menulis situs di React.js, dan kemudian Gatsby akan mengubahnya menjadi file statis selama pembuatan, yang akan membuat situs tersebut super cepat.  Gatsby hadir dengan banyak plugin berguna yang membuat alat ini hampir universal.  Omong-omong, situs saya dibuat menggunakan Gatsby.js!  Karena file statis dibuat selama perakitan, situs perlu dibangun kembali setiap kali konten aslinya berubah. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Next.js</a> , pada gilirannya, adalah komponen server untuk menampilkan situs React.js.  Banyak fitur berguna dibangun di dalamnya, khususnya, perutean, pemecahan kode, komponen yang dirancang, dan banyak lagi.  Render server berarti bahwa data akan diperbarui secara otomatis, seperti yang dilakukan pada server, tetapi, sebelum ditampilkan di jendela browser, tahap rendering akan berlangsung.  Itulah mengapa seharusnya tidak ada masalah dengan menampilkan data kepada pengguna, dan robot pencarian juga akan melakukan pekerjaan mereka tanpa masalah. <br><br>  Ada banyak solusi lain dari jenis ini, tetapi saya paling banyak mendengar tentang keduanya, dan ketika mengerjakan proyek ini saya menggunakannya.  Keduanya didokumentasikan dengan sangat baik, sehingga mudah untuk dengan cepat menangani keduanya dan memulai bisnis. <br><br><h3>  Pikiran terakhir pada tumpukan MERN </h3><br>  Semoga artikel ini telah membantu Anda sedikit lebih akurat bagaimana tumpukan MERN bekerja.  Di dalamnya, kita hanya mengambil MongoDB, Express.js dan Node.js dan membuat dari mereka server yang sudah menyediakan terminal API di mana aplikasi React.js kita dapat mengakses data.  Jadi sekarang Anda mengerti banyak, sekarang saatnya untuk melakukan hal-hal hebat! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id458096/">https://habr.com/ru/post/id458096/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id458084/index.html">50 materi yang dipilih tentang penghasilan musisi, suara dalam game dan film, instrumen yang tidak biasa dan yang lama terlupakan</a></li>
<li><a href="../id458088/index.html">Distribusi Linux Terbaik untuk Komputer yang Lebih Lama</a></li>
<li><a href="../id458090/index.html">Apa yang sebenarnya terjadi pada Boeing Malaysia yang hilang (bagian 2/3)</a></li>
<li><a href="../id458092/index.html">Dalam perjalanan ke inti Python</a></li>
<li><a href="../id458094/index.html">Pengawasan video "pintar": seperti apa kehidupan di bawah kamera dengan kecerdasan buatan</a></li>
<li><a href="../id458098/index.html">Perangkap GDPR</a></li>
<li><a href="../id458100/index.html">Python dalam Visual Studio Code - Juni 2019 Release</a></li>
<li><a href="../id458102/index.html">Alur Kerja Pengembangan Web yang Efektif: Pertemuan, Airtable, dan Lainnya</a></li>
<li><a href="../id458104/index.html">RDMA di dalam pusat data dalam implementasi Huawei</a></li>
<li><a href="../id458106/index.html">Menyelam di Jetpack Compose</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>