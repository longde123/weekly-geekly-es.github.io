<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üö∂üèª üìÖ üë©üèæ‚Äçü§ù‚Äçüë®üèº Das Buch "Klassische Informatik Aufgaben in Python" üç´ üôé üñ≤Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Viele Aufgaben auf dem Gebiet der Informatik, die auf den ersten Blick neu oder einzigartig erscheinen, wurzeln tats√§chlich in klassischen Algorithmen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Das Buch "Klassische Informatik Aufgaben in Python"</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/471520/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/op/8x/zc/op8xzcjsvwkjzgse183iwfc_sdw.jpeg" align="left" alt="Bild"></a>  Viele Aufgaben auf dem Gebiet der Informatik, die auf den ersten Blick neu oder einzigartig erscheinen, wurzeln tats√§chlich in klassischen Algorithmen, Codierungsmethoden und Entwicklungsprinzipien.  Und etablierte Techniken sind immer noch der beste Weg, um solche Probleme zu l√∂sen! <br><br>  Das Buch bietet Ihnen die M√∂glichkeit, die Python-Sprache besser zu lernen und sich an bew√§hrten Aufgaben, √úbungen und Algorithmen zu testen.  Sie m√ºssen Dutzende von Programmieraufgaben l√∂sen: von der einfachsten (z. B. Auffinden von Listenelementen mithilfe der bin√§ren Sortierung) bis zu komplexen Aufgaben (Clustering von Daten mithilfe der k-means-Methode).  Anhand von Beispielen f√ºr Suche, Clustering, Grafiken usw. werden Sie sich an das erinnern, was Sie vergessen haben, und die klassischen Techniken zur L√∂sung allt√§glicher Probleme beherrschen. <br><a name="habracut"></a><br><h3>  F√ºr wen ist dieses Buch? </h3><br>  Dieses Buch richtet sich an Programmierer mittlerer und hoher Ebene.  Erfahrene Fachleute, die ihre Kenntnisse in Python vertiefen m√∂chten, finden hier Aufgaben, die aus der Zeit bekannt sind, als sie Informatik oder Programmierung unterrichteten.  Programmierer auf mittlerer Ebene werden mit diesen klassischen Aufgaben in der von ihnen gew√§hlten Sprache - Python - vertraut gemacht.  F√ºr Entwickler, die sich auf ein Programmierinterview vorbereiten, wird die Ver√∂ffentlichung wahrscheinlich zu wertvollem Vorbereitungsmaterial. <br><br>  Zus√§tzlich zu professionellen Programmierern kann dieses Buch von Studenten als n√ºtzlich angesehen werden, die f√ºr Bachelor-Programme in Informatik studieren und sich f√ºr Python interessieren.  Es wird nicht behauptet, eine strenge Einf√ºhrung in Datenstrukturen und Algorithmen zu sein.  Dies ist kein Tutorial zu Datenstrukturen und Algorithmen.  Sie werden auf seinen Seiten keinen Beweis f√ºr Theoreme oder die h√§ufige Verwendung von O-Big-Notationen finden.  Im Gegenteil, dieses Buch ist als zug√§nglicher praktischer Leitfaden f√ºr Methoden zur L√∂sung von Problemen positioniert, die das Endprodukt der Untersuchung der Datenstruktur, Algorithmen und Klassen k√ºnstlicher Intelligenz werden sollten. <br><br>  Ich betone noch einmal: Es wird davon ausgegangen, dass die Leser mit der Syntax und Semantik von Python vertraut sind.  Es ist unwahrscheinlich, dass ein Leser mit null Programmiererfahrung von diesem Buch profitiert, und ein Programmierer mit null Erfahrung in Python wird wahrscheinlich schwierig sein.  Mit anderen Worten, ‚ÄûKlassische Informatikaufgaben in Python‚Äú ist ein Buch f√ºr Python-Programmierer und Informatikstudenten. <br><br><h3>  Auszug.  1.5.  Hanoi T√ºrme </h3><br>  Es gibt drei hohe vertikale S√§ulen (im Folgenden: T√ºrme).  Wir werden sie als A, B und C bezeichnen. Scheiben mit L√∂chern in der Mitte sind auf Turm A aufgereiht. Die breiteste Scheibe - wir nennen sie Scheibe 1 - befindet sich unten.  Die verbleibenden dar√ºber befindlichen Scheiben werden durch zunehmende Anzahl angezeigt und verj√ºngen sich allm√§hlich.  Wenn wir beispielsweise drei Festplatten h√§tten, h√§tte die breiteste davon, die darunter liegende, die Nummer 1. Die n√§chstbeste Festplatte mit der Nummer 2 befindet sich √ºber der Festplatte 1. Schlie√ülich die engste Festplatte mit der Nummer 3 w√ºrde auf Scheibe 2 liegen. <br><br>  Unser Ziel ist es, alle Laufwerke von Turm A nach Turm C zu verschieben, wobei die folgenden Einschr√§nkungen zu ber√ºcksichtigen sind. <br><br><ul><li>  Festplatten k√∂nnen jeweils nur einzeln verschoben werden. </li><li>  Das einzige Laufwerk, das zum Bewegen zur Verf√ºgung steht, befindet sich oben auf einem Turm. </li><li>  Ein breiteres Laufwerk kann niemals auf ein schmaleres Laufwerk gelegt werden. <br>  Schematisch ist die Aufgabe in Abb. 2 dargestellt.  1.7. </li></ul><br><h3>  1.5.1.  Turmmodellierung </h3><br>  Ein Stapel ist eine Datenstruktur, die nach dem LIFO-Prinzip (Last-In-First-Out) modelliert ist.  Das Letzte, was auf den Stapel kommt, wird das erste, das von dort abgerufen wird.  Die beiden Hauptoperationen des Stapels sind Push (Put) und Pop (Extract).  Durch die Push-Operation wird ein neues Element auf den Stapel verschoben, und Pop entfernt es vom Stapel und gibt das zuletzt eingef√ºgte Element zur√ºck.  Sie k√∂nnen den Stapel in Python einfach modellieren, indem Sie die Liste als Sicherungsspeicher verwenden (Listing 1.20). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pz/a2/gs/pza2gsaqiqas4khvhhwc6hdnfwi.png" alt="Bild"></div><br>  Listing 1.20.  hanoi.py <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> typing <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> TypeVar, Generic, List T = TypeVar(<span class="hljs-string"><span class="hljs-string">'T'</span></span>) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Stack</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Generic[T])</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">None</span></span></span><span class="hljs-function">:</span></span> self._container: List[T] = [] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">push</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, item: T)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">None</span></span></span><span class="hljs-function">:</span></span> self._container.append(item) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function"> -&gt; T:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self._container.pop() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__repr__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function"> -&gt; str:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> repr(self._container)</code> </pre> <br><blockquote>  Die vorgestellte Stack-Klasse implementiert die Methode __repr __ (), mit der sich der Inhalt des Turms leicht untersuchen l√§sst.  __repr __ () wird ausgegeben, wenn die Funktion print () auf den Stapel angewendet wird. </blockquote><br><blockquote>  Wie in der Einleitung angegeben, werden im Buch Typanmerkungen verwendet.  Durch das Importieren von Generic aus einem Eingabemodul kann Stack eine parametrische Klasse f√ºr einen bestimmten Typ in Typanmerkungen sein.  Ein beliebiger Typ T ist in T = TypeVar ('T') definiert.  T kann ein beliebiger Typ sein.  Wenn die Typanmerkung anschlie√üend f√ºr Stack zur L√∂sung des Hanoi-Turmproblems verwendet wird, lautet die Eingabeaufforderung Stack [int], dh, der Typ int wird anstelle von T verwendet.  Mit anderen Worten, hier ist der Stapel ein Stapel von ganzen Zahlen.  Wenn Sie Probleme mit Typanmerkungen haben, lesen Sie Anhang B. </blockquote><br>  Stapel sind perfekt f√ºr die Hanoi Tower Challenge.  Um die Scheibe zum Turm zu bewegen, k√∂nnen wir die Push-Operation verwenden.  Um die Scheibe von einem Turm zum anderen zu bewegen, k√∂nnen wir sie vom ersten (Pop) schieben und auf den zweiten legen (Push). <br><br>  Definieren Sie die T√ºrme als Stapelobjekte und f√ºllen Sie den ersten mit Datentr√§gern (Listing 1.21). <br><br>  Listing 1.21.  hanoi.py (Fortsetzung) <br><br><pre> <code class="python hljs">num_discs: int = <span class="hljs-number"><span class="hljs-number">3</span></span> tower_a: Stack[int] = Stack() tower_b: Stack[int] = Stack() tower_c: Stack[int] = Stack() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">1</span></span>, num_discs + <span class="hljs-number"><span class="hljs-number">1</span></span>): tower_a.push(i)</code> </pre> <br><h3>  1.5.2.  Das Problem der Hanoi-T√ºrme l√∂sen </h3><br>  Wie kann ich das Problem der Hanoi-T√ºrme l√∂sen?  Angenommen, wir versuchen, nur ein Laufwerk zu verschieben.  Dann w√ºrden wir wissen, wie das geht, oder?  Tats√§chlich ist das Verschieben einer Festplatte ein grundlegender Fall f√ºr eine rekursive L√∂sung dieses Problems.  Das Verschieben mehrerer Laufwerke ist ein rekursiver Fall.  Der entscheidende Punkt ist, dass wir tats√§chlich zwei Szenarien haben, die codiert werden m√ºssen: Verschieben einer Festplatte (Basisfall) und Verschieben mehrerer Festplatten (rekursiver Fall). <br><br>  Betrachten Sie ein bestimmtes Beispiel, um den rekursiven Fall zu verstehen.  Angenommen, wir haben drei Festplatten - die obere, mittlere und untere, die sich auf Turm A befinden, und wir m√∂chten sie auf Turm C verschieben. (Dies hilft anschlie√üend, das Problem schematisch zu beschreiben.) Zuerst k√∂nnten wir die obere Festplatte auf Turm C verschieben. Dann - Bewegen Sie die mittlere Scheibe zu Turm B und dann die obere Scheibe von Turm C zu Turm B. Jetzt befindet sich die untere Scheibe noch auf Turm A und die beiden oberen Scheiben auf Turm B. Im Wesentlichen haben wir bereits zwei erfolgreich verschoben Fahren Sie von einem Turm (A) zum anderen (B).  Das Verschieben der unteren Festplatte von A nach C ist der Grundfall (Verschieben einer Festplatte).  Jetzt k√∂nnen wir die beiden oberen Platten von B nach C auf die gleiche Weise wie von A nach B verschieben. Wir verschieben die obere Platte nach A, die mittlere Platte nach C und schlie√ülich die obere Platte von A nach C. <br><br><blockquote>  Im Informatikunterricht werden h√§ufig kleine Modelle dieser T√ºrme gefunden, die aus Stiften und Plastikscheiben gebaut sind.  Sie k√∂nnen Ihr eigenes Modell mit drei Stiften und drei Blatt Papier erstellen.  Vielleicht hilft Ihnen dies, die L√∂sung zu visualisieren. </blockquote><br>  In dem Beispiel mit drei Festplatten gab es einen einfachen Grundfall f√ºr das Verschieben einer Festplatte und einen rekursiven Fall f√ºr das Verschieben der verbleibenden Festplatten (in diesem Fall zwei) mithilfe eines tempor√§ren dritten Turms.  Wir k√∂nnen den rekursiven Fall in die folgenden Schritte unterteilen. <br><br><ol><li>  Bewegen Sie die oberen n - 1 Laufwerke von Turm A zu Turm B (vor√ºbergehend), wobei Sie C als Zwischenturm verwenden. </li><li>  Bewegen Sie den unteren Antrieb von A nach C. </li><li>  Bewegen Sie n - 1 Scheiben von Turm B zu Turm C, Turm A ist dazwischen. </li></ol><br>  √úberraschenderweise funktioniert dieser rekursive Algorithmus nicht nur f√ºr drei, sondern f√ºr eine beliebige Anzahl von Festplatten.  Codieren Sie es als hanoi () -Funktion, die f√ºr das Verschieben von Festplatten von einem Turm zu einem anderen mithilfe eines dritten tempor√§ren Turms verantwortlich ist (Listing 1.22). <br><br>  Listing 1.22.  hanoi.py (Fortsetzung) <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hanoi</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(begin: Stack[int], end: Stack[int], temp: Stack[int], n: int)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">None</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n == <span class="hljs-number"><span class="hljs-number">1</span></span>: end.push(begin.pop()) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: hanoi(begin, temp, end, n ‚Äî <span class="hljs-number"><span class="hljs-number">1</span></span>) hanoi(begin, end, temp, <span class="hljs-number"><span class="hljs-number">1</span></span>) hanoi(temp, end, begin, n - <span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br>  Nach dem Aufruf von hanoi () m√ºssen Sie die T√ºrme A, B und C √ºberpr√ºfen, um sicherzustellen, dass die Festplatten erfolgreich verschoben wurden (Listing 1.23). <br><br>  Listing 1.23.  hanoi.py (Fortsetzung) <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">"__main__"</span></span>: hanoi(tower_a, tower_c, tower_b, num_discs) print(tower_a) print(tower_b) print(tower_c)</code> </pre> <br>  Sie werden feststellen, dass die Laufwerke tats√§chlich verschoben wurden.  Bei der Codierung der L√∂sung f√ºr das Hanoi-Tower-Problem ist es nicht erforderlich, jeden Schritt zu verstehen, der zum Verschieben mehrerer Festplatten von Turm A zu Turm C erforderlich ist. Wir haben den allgemeinen rekursiven Algorithmus zum Verschieben einer beliebigen Anzahl von Festplatten verstanden und ihn systematisiert, sodass der Computer den Rest erledigen kann.  Dies ist die Kraft, rekursive L√∂sungen f√ºr Probleme zu formulieren: Wir k√∂nnen uns oft abstrakte L√∂sungen vorstellen, ohne Energie f√ºr die mentale Repr√§sentation jeder einzelnen Handlung zu verschwenden. <br><br>  √úbrigens wird die Funktion hanoi () abh√§ngig von der Anzahl der Festplatten exponentiell ausgef√ºhrt, was die L√∂sung des Problems selbst f√ºr 64 Festplatten ungeeignet macht.  Sie k√∂nnen versuchen, es mit einer anderen Anzahl von Festplatten auszuf√ºhren, indem Sie die Variable num_discs √§ndern.  Mit zunehmender Anzahl von Festplatten nimmt die Anzahl der Schritte zum Ausf√ºhren der Hanoi-Turmaufgabe exponentiell zu. Weitere Details finden Sie in vielen Quellen.  Wenn Sie mehr √ºber die Mathematik hinter der rekursiven L√∂sung dieses Problems erfahren m√∂chten, lesen Sie die Erkl√§rung von Karl Birch im Artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">‚ÄûOn Hanoi Towers‚Äú</a> . <br><br><h3>  1.6.  Echte Anwendungen </h3><br>  Die verschiedenen in diesem Kapitel vorgestellten Methoden (Rekursion, Memoisierung, Komprimierung und Manipulation auf Bitebene) sind in der Entwicklung moderner Software so weit verbreitet, dass man sich die Computerwelt ohne sie nicht vorstellen kann.  Trotz der Tatsache, dass Aufgaben ohne sie gel√∂st werden k√∂nnen, ist es oft logischer oder zweckm√§√üiger, sie mit diesen Methoden zu l√∂sen. <br><br>  Insbesondere liegt der Rekursion nicht nur viele Algorithmen zugrunde, sondern sogar ganzen Programmiersprachen.  In einigen funktionalen Programmiersprachen wie Scheme und Haskell ersetzt die Rekursion Schleifen, die in imperativen Sprachen verwendet werden.  Es ist jedoch zu beachten, dass alles, was mit der rekursiven Methode erreicht werden kann, auch iterativ ausgef√ºhrt werden kann. <br><br>  Memoization wurde erfolgreich eingesetzt, um die Arbeit von Parsern zu beschleunigen - Programmen, die Sprachen interpretieren.  Dies ist bei allen Aufgaben n√ºtzlich, bei denen das Ergebnis einer k√ºrzlich durchgef√ºhrten Berechnung wahrscheinlich erneut angefordert wird.  Ein weiterer Aktionsbereich f√ºr Memoization ist die Laufzeit der Programmiersprache.  Einige dieser Laufzeiten, beispielsweise f√ºr die Prolog-Version, speichern automatisch die Ergebnisse von Funktionsaufrufen (Auto-Mash), sodass die Funktion nicht das n√§chste Mal mit demselben Aufruf ausgef√ºhrt werden muss.  Dies √§hnelt dem Dekorator @lru_cache () in fib6 (). <br><br>  Die Komprimierung hat die Welt des Internets mit seiner begrenzten Bandbreite ertr√§glicher gemacht.  Die in Abschnitt 1.2 beschriebene Bitfolgenmethode ist auf einfache Datentypen in der realen Welt anwendbar, die eine begrenzte Anzahl m√∂glicher Werte aufweisen, f√ºr die sogar 1 Byte redundant ist.  Die meisten Komprimierungsalgorithmen suchen jedoch nach Mustern oder Strukturen in einem Datensatz, die doppelte Informationen eliminieren.  Sie sind viel komplizierter als in Abschnitt 1.2 beschrieben. <br><br>  Einweg-Chiffren sind nicht f√ºr allgemeine Verschl√ºsselungsf√§lle geeignet.  Sie erfordern, dass sowohl der Codierer als auch der Decodierer √ºber einen der Schl√ºssel verf√ºgen (in unserem Beispiel Dummy-Daten), um die urspr√ºnglichen Daten wiederherzustellen. Dies ist zu umst√§ndlich und erm√∂glicht in den meisten Verschl√ºsselungsschemata nicht das Ziel, die Schl√ºssel geheim zu halten.  Vielleicht interessiert Sie aber auch, dass der Name ‚ÄûEinweg-Chiffre‚Äú von Spionen erfunden wurde, die w√§hrend des Kalten Krieges Notizb√ºcher aus echtem Papier mit darin aufgezeichneten fiktiven Daten verwendeten, um verschl√ºsselte Nachrichten zu erstellen. <br><br>  Diese Methoden sind die Bausteine ‚Äã‚Äãvon Programmen, auf denen andere Algorithmen basieren.  In den folgenden Kapiteln sehen Sie, wie weit sie angewendet werden. <br><br><h3>  √úber den Autor </h3><br>  <b>David Kopec</b> ist Dozent f√ºr Informatik und Innovation am Champlain College in Burlington, Vermont.  Er ist ein erfahrener Softwareentwickler und Autor von Classic Computer Science Problems in Swift (Manning, 2018) und Dart for Absolute Beginners (Apress, 2014).  David erwarb einen Bachelor-Abschluss in Wirtschaftswissenschaften und einen Master-Abschluss in Informatik am Dartmouth College.  Sie k√∂nnen ihn auf Twitter √ºber @davekopec kontaktieren. <br><br>  ¬ªWeitere Informationen zum Buch finden Sie auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der Website des Herausgebers</a> <br>  ¬ª <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Inhalt</a> <br>  ¬ª <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Auszug</a> <br><br>  25% Rabatt auf Gutschein f√ºr H√§ndler - <b>Python</b> <br><br>  Nach Bezahlung der Papierversion des Buches wird ein elektronisches Buch per E-Mail verschickt. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de471520/">https://habr.com/ru/post/de471520/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de471508/index.html">Armless Admin = Hyperkonvergenz?</a></li>
<li><a href="../de471512/index.html">28. Oktober, Jekaterinburg - Qualit√§tskommunikation</a></li>
<li><a href="../de471514/index.html">Die √úberschrift "Artikel f√ºr Sie lesen." Januar - Juni 2019</a></li>
<li><a href="../de471516/index.html">Intel 665p - SSD mit 96-Layer-QLC-NAND</a></li>
<li><a href="../de471518/index.html">Apple im Jahr 2019 ist Linux im Jahr 2000</a></li>
<li><a href="../de471522/index.html">Askozia. Funktionsweise von Autoprovisioning Plug & Play</a></li>
<li><a href="../de471524/index.html">Vollst√§ndige √úbersetzung der Anweisungen f√ºr Gutachter Google</a></li>
<li><a href="../de471528/index.html">Stellen Sie Apps mit Docker Swarm bereit</a></li>
<li><a href="../de471530/index.html">GitLab ging einen ungew√∂hnlichen Weg zu CI / CD und Kubernetes</a></li>
<li><a href="../de471532/index.html">Auf Wiedersehen PCB; Hallo Siliziumverbindung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>