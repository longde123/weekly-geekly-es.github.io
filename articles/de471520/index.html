<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚶🏻 📅 👩🏾‍🤝‍👨🏼 Das Buch "Klassische Informatik Aufgaben in Python" 🍫 🙎 🖲️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Viele Aufgaben auf dem Gebiet der Informatik, die auf den ersten Blick neu oder einzigartig erscheinen, wurzeln tatsächlich in klassischen Algorithmen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Das Buch "Klassische Informatik Aufgaben in Python"</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/471520/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/op/8x/zc/op8xzcjsvwkjzgse183iwfc_sdw.jpeg" align="left" alt="Bild"></a>  Viele Aufgaben auf dem Gebiet der Informatik, die auf den ersten Blick neu oder einzigartig erscheinen, wurzeln tatsächlich in klassischen Algorithmen, Codierungsmethoden und Entwicklungsprinzipien.  Und etablierte Techniken sind immer noch der beste Weg, um solche Probleme zu lösen! <br><br>  Das Buch bietet Ihnen die Möglichkeit, die Python-Sprache besser zu lernen und sich an bewährten Aufgaben, Übungen und Algorithmen zu testen.  Sie müssen Dutzende von Programmieraufgaben lösen: von der einfachsten (z. B. Auffinden von Listenelementen mithilfe der binären Sortierung) bis zu komplexen Aufgaben (Clustering von Daten mithilfe der k-means-Methode).  Anhand von Beispielen für Suche, Clustering, Grafiken usw. werden Sie sich an das erinnern, was Sie vergessen haben, und die klassischen Techniken zur Lösung alltäglicher Probleme beherrschen. <br><a name="habracut"></a><br><h3>  Für wen ist dieses Buch? </h3><br>  Dieses Buch richtet sich an Programmierer mittlerer und hoher Ebene.  Erfahrene Fachleute, die ihre Kenntnisse in Python vertiefen möchten, finden hier Aufgaben, die aus der Zeit bekannt sind, als sie Informatik oder Programmierung unterrichteten.  Programmierer auf mittlerer Ebene werden mit diesen klassischen Aufgaben in der von ihnen gewählten Sprache - Python - vertraut gemacht.  Für Entwickler, die sich auf ein Programmierinterview vorbereiten, wird die Veröffentlichung wahrscheinlich zu wertvollem Vorbereitungsmaterial. <br><br>  Zusätzlich zu professionellen Programmierern kann dieses Buch von Studenten als nützlich angesehen werden, die für Bachelor-Programme in Informatik studieren und sich für Python interessieren.  Es wird nicht behauptet, eine strenge Einführung in Datenstrukturen und Algorithmen zu sein.  Dies ist kein Tutorial zu Datenstrukturen und Algorithmen.  Sie werden auf seinen Seiten keinen Beweis für Theoreme oder die häufige Verwendung von O-Big-Notationen finden.  Im Gegenteil, dieses Buch ist als zugänglicher praktischer Leitfaden für Methoden zur Lösung von Problemen positioniert, die das Endprodukt der Untersuchung der Datenstruktur, Algorithmen und Klassen künstlicher Intelligenz werden sollten. <br><br>  Ich betone noch einmal: Es wird davon ausgegangen, dass die Leser mit der Syntax und Semantik von Python vertraut sind.  Es ist unwahrscheinlich, dass ein Leser mit null Programmiererfahrung von diesem Buch profitiert, und ein Programmierer mit null Erfahrung in Python wird wahrscheinlich schwierig sein.  Mit anderen Worten, „Klassische Informatikaufgaben in Python“ ist ein Buch für Python-Programmierer und Informatikstudenten. <br><br><h3>  Auszug.  1.5.  Hanoi Türme </h3><br>  Es gibt drei hohe vertikale Säulen (im Folgenden: Türme).  Wir werden sie als A, B und C bezeichnen. Scheiben mit Löchern in der Mitte sind auf Turm A aufgereiht. Die breiteste Scheibe - wir nennen sie Scheibe 1 - befindet sich unten.  Die verbleibenden darüber befindlichen Scheiben werden durch zunehmende Anzahl angezeigt und verjüngen sich allmählich.  Wenn wir beispielsweise drei Festplatten hätten, hätte die breiteste davon, die darunter liegende, die Nummer 1. Die nächstbeste Festplatte mit der Nummer 2 befindet sich über der Festplatte 1. Schließlich die engste Festplatte mit der Nummer 3 würde auf Scheibe 2 liegen. <br><br>  Unser Ziel ist es, alle Laufwerke von Turm A nach Turm C zu verschieben, wobei die folgenden Einschränkungen zu berücksichtigen sind. <br><br><ul><li>  Festplatten können jeweils nur einzeln verschoben werden. </li><li>  Das einzige Laufwerk, das zum Bewegen zur Verfügung steht, befindet sich oben auf einem Turm. </li><li>  Ein breiteres Laufwerk kann niemals auf ein schmaleres Laufwerk gelegt werden. <br>  Schematisch ist die Aufgabe in Abb. 2 dargestellt.  1.7. </li></ul><br><h3>  1.5.1.  Turmmodellierung </h3><br>  Ein Stapel ist eine Datenstruktur, die nach dem LIFO-Prinzip (Last-In-First-Out) modelliert ist.  Das Letzte, was auf den Stapel kommt, wird das erste, das von dort abgerufen wird.  Die beiden Hauptoperationen des Stapels sind Push (Put) und Pop (Extract).  Durch die Push-Operation wird ein neues Element auf den Stapel verschoben, und Pop entfernt es vom Stapel und gibt das zuletzt eingefügte Element zurück.  Sie können den Stapel in Python einfach modellieren, indem Sie die Liste als Sicherungsspeicher verwenden (Listing 1.20). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pz/a2/gs/pza2gsaqiqas4khvhhwc6hdnfwi.png" alt="Bild"></div><br>  Listing 1.20.  hanoi.py <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> typing <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> TypeVar, Generic, List T = TypeVar(<span class="hljs-string"><span class="hljs-string">'T'</span></span>) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Stack</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Generic[T])</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">None</span></span></span><span class="hljs-function">:</span></span> self._container: List[T] = [] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">push</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, item: T)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">None</span></span></span><span class="hljs-function">:</span></span> self._container.append(item) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function"> -&gt; T:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self._container.pop() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__repr__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function"> -&gt; str:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> repr(self._container)</code> </pre> <br><blockquote>  Die vorgestellte Stack-Klasse implementiert die Methode __repr __ (), mit der sich der Inhalt des Turms leicht untersuchen lässt.  __repr __ () wird ausgegeben, wenn die Funktion print () auf den Stapel angewendet wird. </blockquote><br><blockquote>  Wie in der Einleitung angegeben, werden im Buch Typanmerkungen verwendet.  Durch das Importieren von Generic aus einem Eingabemodul kann Stack eine parametrische Klasse für einen bestimmten Typ in Typanmerkungen sein.  Ein beliebiger Typ T ist in T = TypeVar ('T') definiert.  T kann ein beliebiger Typ sein.  Wenn die Typanmerkung anschließend für Stack zur Lösung des Hanoi-Turmproblems verwendet wird, lautet die Eingabeaufforderung Stack [int], dh, der Typ int wird anstelle von T verwendet.  Mit anderen Worten, hier ist der Stapel ein Stapel von ganzen Zahlen.  Wenn Sie Probleme mit Typanmerkungen haben, lesen Sie Anhang B. </blockquote><br>  Stapel sind perfekt für die Hanoi Tower Challenge.  Um die Scheibe zum Turm zu bewegen, können wir die Push-Operation verwenden.  Um die Scheibe von einem Turm zum anderen zu bewegen, können wir sie vom ersten (Pop) schieben und auf den zweiten legen (Push). <br><br>  Definieren Sie die Türme als Stapelobjekte und füllen Sie den ersten mit Datenträgern (Listing 1.21). <br><br>  Listing 1.21.  hanoi.py (Fortsetzung) <br><br><pre> <code class="python hljs">num_discs: int = <span class="hljs-number"><span class="hljs-number">3</span></span> tower_a: Stack[int] = Stack() tower_b: Stack[int] = Stack() tower_c: Stack[int] = Stack() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">1</span></span>, num_discs + <span class="hljs-number"><span class="hljs-number">1</span></span>): tower_a.push(i)</code> </pre> <br><h3>  1.5.2.  Das Problem der Hanoi-Türme lösen </h3><br>  Wie kann ich das Problem der Hanoi-Türme lösen?  Angenommen, wir versuchen, nur ein Laufwerk zu verschieben.  Dann würden wir wissen, wie das geht, oder?  Tatsächlich ist das Verschieben einer Festplatte ein grundlegender Fall für eine rekursive Lösung dieses Problems.  Das Verschieben mehrerer Laufwerke ist ein rekursiver Fall.  Der entscheidende Punkt ist, dass wir tatsächlich zwei Szenarien haben, die codiert werden müssen: Verschieben einer Festplatte (Basisfall) und Verschieben mehrerer Festplatten (rekursiver Fall). <br><br>  Betrachten Sie ein bestimmtes Beispiel, um den rekursiven Fall zu verstehen.  Angenommen, wir haben drei Festplatten - die obere, mittlere und untere, die sich auf Turm A befinden, und wir möchten sie auf Turm C verschieben. (Dies hilft anschließend, das Problem schematisch zu beschreiben.) Zuerst könnten wir die obere Festplatte auf Turm C verschieben. Dann - Bewegen Sie die mittlere Scheibe zu Turm B und dann die obere Scheibe von Turm C zu Turm B. Jetzt befindet sich die untere Scheibe noch auf Turm A und die beiden oberen Scheiben auf Turm B. Im Wesentlichen haben wir bereits zwei erfolgreich verschoben Fahren Sie von einem Turm (A) zum anderen (B).  Das Verschieben der unteren Festplatte von A nach C ist der Grundfall (Verschieben einer Festplatte).  Jetzt können wir die beiden oberen Platten von B nach C auf die gleiche Weise wie von A nach B verschieben. Wir verschieben die obere Platte nach A, die mittlere Platte nach C und schließlich die obere Platte von A nach C. <br><br><blockquote>  Im Informatikunterricht werden häufig kleine Modelle dieser Türme gefunden, die aus Stiften und Plastikscheiben gebaut sind.  Sie können Ihr eigenes Modell mit drei Stiften und drei Blatt Papier erstellen.  Vielleicht hilft Ihnen dies, die Lösung zu visualisieren. </blockquote><br>  In dem Beispiel mit drei Festplatten gab es einen einfachen Grundfall für das Verschieben einer Festplatte und einen rekursiven Fall für das Verschieben der verbleibenden Festplatten (in diesem Fall zwei) mithilfe eines temporären dritten Turms.  Wir können den rekursiven Fall in die folgenden Schritte unterteilen. <br><br><ol><li>  Bewegen Sie die oberen n - 1 Laufwerke von Turm A zu Turm B (vorübergehend), wobei Sie C als Zwischenturm verwenden. </li><li>  Bewegen Sie den unteren Antrieb von A nach C. </li><li>  Bewegen Sie n - 1 Scheiben von Turm B zu Turm C, Turm A ist dazwischen. </li></ol><br>  Überraschenderweise funktioniert dieser rekursive Algorithmus nicht nur für drei, sondern für eine beliebige Anzahl von Festplatten.  Codieren Sie es als hanoi () -Funktion, die für das Verschieben von Festplatten von einem Turm zu einem anderen mithilfe eines dritten temporären Turms verantwortlich ist (Listing 1.22). <br><br>  Listing 1.22.  hanoi.py (Fortsetzung) <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hanoi</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(begin: Stack[int], end: Stack[int], temp: Stack[int], n: int)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">None</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n == <span class="hljs-number"><span class="hljs-number">1</span></span>: end.push(begin.pop()) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: hanoi(begin, temp, end, n — <span class="hljs-number"><span class="hljs-number">1</span></span>) hanoi(begin, end, temp, <span class="hljs-number"><span class="hljs-number">1</span></span>) hanoi(temp, end, begin, n - <span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br>  Nach dem Aufruf von hanoi () müssen Sie die Türme A, B und C überprüfen, um sicherzustellen, dass die Festplatten erfolgreich verschoben wurden (Listing 1.23). <br><br>  Listing 1.23.  hanoi.py (Fortsetzung) <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">"__main__"</span></span>: hanoi(tower_a, tower_c, tower_b, num_discs) print(tower_a) print(tower_b) print(tower_c)</code> </pre> <br>  Sie werden feststellen, dass die Laufwerke tatsächlich verschoben wurden.  Bei der Codierung der Lösung für das Hanoi-Tower-Problem ist es nicht erforderlich, jeden Schritt zu verstehen, der zum Verschieben mehrerer Festplatten von Turm A zu Turm C erforderlich ist. Wir haben den allgemeinen rekursiven Algorithmus zum Verschieben einer beliebigen Anzahl von Festplatten verstanden und ihn systematisiert, sodass der Computer den Rest erledigen kann.  Dies ist die Kraft, rekursive Lösungen für Probleme zu formulieren: Wir können uns oft abstrakte Lösungen vorstellen, ohne Energie für die mentale Repräsentation jeder einzelnen Handlung zu verschwenden. <br><br>  Übrigens wird die Funktion hanoi () abhängig von der Anzahl der Festplatten exponentiell ausgeführt, was die Lösung des Problems selbst für 64 Festplatten ungeeignet macht.  Sie können versuchen, es mit einer anderen Anzahl von Festplatten auszuführen, indem Sie die Variable num_discs ändern.  Mit zunehmender Anzahl von Festplatten nimmt die Anzahl der Schritte zum Ausführen der Hanoi-Turmaufgabe exponentiell zu. Weitere Details finden Sie in vielen Quellen.  Wenn Sie mehr über die Mathematik hinter der rekursiven Lösung dieses Problems erfahren möchten, lesen Sie die Erklärung von Karl Birch im Artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">„On Hanoi Towers“</a> . <br><br><h3>  1.6.  Echte Anwendungen </h3><br>  Die verschiedenen in diesem Kapitel vorgestellten Methoden (Rekursion, Memoisierung, Komprimierung und Manipulation auf Bitebene) sind in der Entwicklung moderner Software so weit verbreitet, dass man sich die Computerwelt ohne sie nicht vorstellen kann.  Trotz der Tatsache, dass Aufgaben ohne sie gelöst werden können, ist es oft logischer oder zweckmäßiger, sie mit diesen Methoden zu lösen. <br><br>  Insbesondere liegt der Rekursion nicht nur viele Algorithmen zugrunde, sondern sogar ganzen Programmiersprachen.  In einigen funktionalen Programmiersprachen wie Scheme und Haskell ersetzt die Rekursion Schleifen, die in imperativen Sprachen verwendet werden.  Es ist jedoch zu beachten, dass alles, was mit der rekursiven Methode erreicht werden kann, auch iterativ ausgeführt werden kann. <br><br>  Memoization wurde erfolgreich eingesetzt, um die Arbeit von Parsern zu beschleunigen - Programmen, die Sprachen interpretieren.  Dies ist bei allen Aufgaben nützlich, bei denen das Ergebnis einer kürzlich durchgeführten Berechnung wahrscheinlich erneut angefordert wird.  Ein weiterer Aktionsbereich für Memoization ist die Laufzeit der Programmiersprache.  Einige dieser Laufzeiten, beispielsweise für die Prolog-Version, speichern automatisch die Ergebnisse von Funktionsaufrufen (Auto-Mash), sodass die Funktion nicht das nächste Mal mit demselben Aufruf ausgeführt werden muss.  Dies ähnelt dem Dekorator @lru_cache () in fib6 (). <br><br>  Die Komprimierung hat die Welt des Internets mit seiner begrenzten Bandbreite erträglicher gemacht.  Die in Abschnitt 1.2 beschriebene Bitfolgenmethode ist auf einfache Datentypen in der realen Welt anwendbar, die eine begrenzte Anzahl möglicher Werte aufweisen, für die sogar 1 Byte redundant ist.  Die meisten Komprimierungsalgorithmen suchen jedoch nach Mustern oder Strukturen in einem Datensatz, die doppelte Informationen eliminieren.  Sie sind viel komplizierter als in Abschnitt 1.2 beschrieben. <br><br>  Einweg-Chiffren sind nicht für allgemeine Verschlüsselungsfälle geeignet.  Sie erfordern, dass sowohl der Codierer als auch der Decodierer über einen der Schlüssel verfügen (in unserem Beispiel Dummy-Daten), um die ursprünglichen Daten wiederherzustellen. Dies ist zu umständlich und ermöglicht in den meisten Verschlüsselungsschemata nicht das Ziel, die Schlüssel geheim zu halten.  Vielleicht interessiert Sie aber auch, dass der Name „Einweg-Chiffre“ von Spionen erfunden wurde, die während des Kalten Krieges Notizbücher aus echtem Papier mit darin aufgezeichneten fiktiven Daten verwendeten, um verschlüsselte Nachrichten zu erstellen. <br><br>  Diese Methoden sind die Bausteine ​​von Programmen, auf denen andere Algorithmen basieren.  In den folgenden Kapiteln sehen Sie, wie weit sie angewendet werden. <br><br><h3>  Über den Autor </h3><br>  <b>David Kopec</b> ist Dozent für Informatik und Innovation am Champlain College in Burlington, Vermont.  Er ist ein erfahrener Softwareentwickler und Autor von Classic Computer Science Problems in Swift (Manning, 2018) und Dart for Absolute Beginners (Apress, 2014).  David erwarb einen Bachelor-Abschluss in Wirtschaftswissenschaften und einen Master-Abschluss in Informatik am Dartmouth College.  Sie können ihn auf Twitter über @davekopec kontaktieren. <br><br>  »Weitere Informationen zum Buch finden Sie auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der Website des Herausgebers</a> <br>  » <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Inhalt</a> <br>  » <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Auszug</a> <br><br>  25% Rabatt auf Gutschein für Händler - <b>Python</b> <br><br>  Nach Bezahlung der Papierversion des Buches wird ein elektronisches Buch per E-Mail verschickt. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de471520/">https://habr.com/ru/post/de471520/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de471508/index.html">Armless Admin = Hyperkonvergenz?</a></li>
<li><a href="../de471512/index.html">28. Oktober, Jekaterinburg - Qualitätskommunikation</a></li>
<li><a href="../de471514/index.html">Die Überschrift "Artikel für Sie lesen." Januar - Juni 2019</a></li>
<li><a href="../de471516/index.html">Intel 665p - SSD mit 96-Layer-QLC-NAND</a></li>
<li><a href="../de471518/index.html">Apple im Jahr 2019 ist Linux im Jahr 2000</a></li>
<li><a href="../de471522/index.html">Askozia. Funktionsweise von Autoprovisioning Plug & Play</a></li>
<li><a href="../de471524/index.html">Vollständige Übersetzung der Anweisungen für Gutachter Google</a></li>
<li><a href="../de471528/index.html">Stellen Sie Apps mit Docker Swarm bereit</a></li>
<li><a href="../de471530/index.html">GitLab ging einen ungewöhnlichen Weg zu CI / CD und Kubernetes</a></li>
<li><a href="../de471532/index.html">Auf Wiedersehen PCB; Hallo Siliziumverbindung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>