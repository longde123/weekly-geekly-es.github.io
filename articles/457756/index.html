<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèæ‚Äçüîß ‚úçüèº üßôüèª El libro Kafka Streams en acci√≥n. Aplicaciones y microservicios en tiempo real ¬ª üï∂Ô∏è üç∏ üïµüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola habrozhiteli! Este libro es adecuado para cualquier desarrollador que quiera comprender el procesamiento de transmisi√≥n. Comprender la programaci...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>El libro Kafka Streams en acci√≥n. Aplicaciones y microservicios en tiempo real ¬ª</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/457756/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/na/mw/fb/namwfbeornc4ba8jkaodlvjlm68.jpeg" align="left" alt="imagen"></a>  Hola habrozhiteli!  Este libro es adecuado para cualquier desarrollador que quiera comprender el procesamiento de transmisi√≥n.  Comprender la programaci√≥n distribuida lo ayudar√° a comprender mejor Kafka y Kafka Streams.  Ser√≠a bueno conocer el marco Kafka en s√≠, pero esto no es necesario: te dir√© todo lo que necesitas.  Gracias a este libro, los desarrolladores experimentados de Kafka, como los novatos, aprender√°n c√≥mo crear aplicaciones de transmisi√≥n interesantes utilizando la biblioteca Kafka Streams.  Los desarrolladores de Java intermedios y de alto nivel familiarizados con conceptos como la serializaci√≥n aprender√°n c√≥mo aplicar sus habilidades para crear aplicaciones de Kafka Streams.  El c√≥digo fuente del libro est√° escrito en Java 8 y esencialmente utiliza la sintaxis de las expresiones lambda de Java 8, por lo que la capacidad de trabajar con funciones lambda (incluso en otro lenguaje de programaci√≥n) es √∫til para usted. <br><a name="habracut"></a><br><h3>  Extracto  5.3.  Agregaci√≥n y operaciones de ventana </h3><br>  En esta secci√≥n, pasamos a las partes m√°s prometedoras de Kafka Streams.  Hasta ahora hemos cubierto los siguientes aspectos de Kafka Streams: <br><br><ul><li>  crear una topolog√≠a de procesamiento; </li><li>  uso del estado en aplicaciones de transmisi√≥n; </li><li>  hacer conexiones de flujo de datos; </li><li>  diferencias entre secuencias de eventos (KStream) y secuencias de actualizaci√≥n (KTable). </li></ul><br>  En los siguientes ejemplos, juntaremos todos estos elementos.  Adem√°s, se familiarizar√° con las operaciones de ventana, otra gran caracter√≠stica de las aplicaciones de transmisi√≥n.  Nuestro primer ejemplo ser√° la agregaci√≥n simple. <br><br><h3>  5.3.1.  Agregaci√≥n de ventas de stock por industria </h3><br>  La agregaci√≥n y la agrupaci√≥n son herramientas vitales para trabajar con la transmisi√≥n de datos.  Examinar registros individuales a medida que est√°n disponibles a menudo no es suficiente.  Para extraer informaci√≥n adicional de los datos, su agrupaci√≥n y combinaci√≥n son necesarias. <br><br>  En este ejemplo, debe probar el traje de un comerciante intrad√≠a que necesita rastrear el volumen de ventas de acciones de compa√±√≠as en varias industrias.  En particular, est√° interesado en las cinco compa√±√≠as con las mayores ventas de acciones en cada industria. <br><br>  Para dicha agregaci√≥n, necesitar√° varios de los siguientes pasos para traducir los datos a la forma deseada (en t√©rminos generales). <br><br><ol><li>  Cree una fuente basada en temas que publique informaci√≥n de comercio de acciones sin procesar.  Tendremos que asignar un objeto de tipo StockTransaction a un objeto de tipo ShareVolume.  El hecho es que el objeto StockTransaction contiene metadatos de ventas, y solo necesitamos datos sobre la cantidad de acciones vendidas. </li><li>  Agrupe los datos de ShareVolume por s√≠mbolos de stock.  Despu√©s de agrupar por s√≠mbolos, puede contraer estos datos en subtotales de ventas de acciones.  Vale la pena se√±alar que el m√©todo KStream.groupBy devuelve una instancia de tipo KGroupedStream.  Y puede obtener una instancia de KTable llamando al m√©todo KGroupedStream.reduce m√°s tarde. </li></ol><br><blockquote>  <b>¬øQu√© es la interfaz KGroupedStream?</b> <br><br>  Los m√©todos KStream.groupBy y KStream.groupByKey devuelven una instancia de KGroupedStream.  KGroupedStream es una representaci√≥n intermedia de la secuencia de eventos despu√©s de la agrupaci√≥n por clave.  No est√° pensado para trabajar directamente con √©l.  En cambio, KGroupedStream se usa para operaciones de agregaci√≥n, cuyo resultado siempre es KTable.  Y dado que el resultado de las operaciones de agregaci√≥n es KTable y usan almacenamiento de estado, es posible que no todas las actualizaciones se env√≠en m√°s adelante. <br><br>  El m√©todo KTable.groupBy devuelve una KGroupedTable similar, una representaci√≥n intermedia de la secuencia de actualizaciones reagrupadas por clave. </blockquote><br>  Tomemos un breve descanso y miremos la fig.  5.9, que muestra lo que hemos logrado.  Esta topolog√≠a ya deber√≠a serle familiar. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/9v/p3/ne/9vp3ne2cqpquhvlkmjo6wncqwsm.png" alt="imagen"></div><br>  Ahora echemos un vistazo al c√≥digo de esta topolog√≠a (se puede encontrar en el archivo src / main / java / bbejeck / chapter_5 / AggregationsAndReducingExample.java) (Listado 5.2). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/8w/cz/lz/8wczlzab4gf5y7sjluyyu2f1vdi.png" alt="imagen"></div><br>  El c√≥digo dado difiere en brevedad y en un gran volumen de acciones realizadas en varias l√≠neas.  En el primer par√°metro del m√©todo builder.stream, puede notar algo nuevo para usted: el valor del tipo enumerado AutoOffsetReset.EARLIEST (tambi√©n hay LATEST), establecido usando el m√©todo Consumed.withOffsetResetPolicy.  Con este tipo enumerado, puede especificar una estrategia para restablecer las compensaciones para cada uno de KStream o KTable; tiene prioridad sobre el par√°metro para restablecer las compensaciones desde la configuraci√≥n. <br><br><blockquote>  <b>GroupByKey y GroupBy</b> <br><br>  La interfaz de KStream tiene dos m√©todos para agrupar registros: GroupByKey y GroupBy.  Ambos devuelven KGroupedTable, por lo que puede tener una pregunta leg√≠tima: ¬øcu√°l es la diferencia entre ellos y cu√°ndo usar cu√°l? <br><br>  El m√©todo GroupByKey se usa cuando las claves en KStream ya no est√°n vac√≠as.  Y lo m√°s importante, la bandera "requiere volver a particionar" nunca se ha establecido. <br><br>  El m√©todo GroupBy supone que ha cambiado las claves para la agrupaci√≥n, por lo que el indicador de re-partici√≥n se establece en verdadero.  La realizaci√≥n de conexiones, agregaciones, etc. despu√©s del m√©todo GroupBy conducir√° a una nueva divisi√≥n autom√°tica. <br>  Resumen: debe usar GroupByKey en lugar de GroupBy siempre que sea posible. </blockquote><br>  Lo que hacen los m√©todos mapValues ‚Äã‚Äãy groupBy es comprensible, as√≠ que eche un vistazo al m√©todo sum () (se puede encontrar en el archivo src / main / java / bbejeck / model / ShareVolume.java) (Listado 5.3). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/va/bb/e5/vabbe54p2ntwmyk1yllak6s4m4q.png" alt="imagen"></div><br>  El m√©todo ShareVolume.sum devuelve el subtotal del volumen de ventas de acciones, y el resultado de toda la cadena de c√°lculo es un objeto KTable &lt;String, ShareVolume&gt;.  Ahora entiendes qu√© papel juega KTable.  Cuando llegan los objetos ShareVolume, la √∫ltima actualizaci√≥n actual se guarda en la tabla K correspondiente.  Es importante no olvidar que todas las actualizaciones se reflejan en el shareVolumeKTable anterior, pero no todas se env√≠an m√°s. <br><br>  Adem√°s, con la ayuda de esta KTable, realizamos la agregaci√≥n (por el n√∫mero de acciones vendidas) para obtener las cinco compa√±√≠as con las ventas de acciones m√°s altas en cada industria.  Nuestras acciones en este caso ser√°n similares a las acciones durante la primera agregaci√≥n. <br><br><ol><li>  Realice otra operaci√≥n groupBy para agrupar objetos ShareVolume individuales por sector. </li><li>  Proceda a resumir los objetos ShareVolume.  Esta vez, el objeto de agregaci√≥n es una cola prioritaria de un tama√±o fijo.  Solo cinco compa√±√≠as con el mayor n√∫mero de acciones vendidas se mantienen en una cola de tama√±o fijo. </li><li>  Muestre las l√≠neas del p√°rrafo anterior en un valor de cadena y devuelva las cinco m√°s vendidas por el n√∫mero de acciones por industria. </li><li>  Escriba los resultados en forma de cadena para el tema. </li></ol><br>  En la fig.  5.10 muestra un gr√°fico de la topolog√≠a del movimiento de datos.  Como puede ver, la segunda ronda de procesamiento es bastante simple. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/4q/3p/j5/4q3pj5lkggxqnu6lpcmtgo52dqq.png" alt="imagen"></div><br>  Ahora, habiendo entendido claramente la estructura de esta segunda ronda de procesamiento, puede consultar su c√≥digo fuente (lo encontrar√° en el archivo src / main / java / bbejeck / chapter_5 / AggregationsAndReducingExample.java) (Listado 5.4). <br><br>  Hay una variable fixedQueue en este inicializador.  Este es un objeto personalizado: un adaptador para java.util.TreeSet, que se utiliza para rastrear N resultados m√°s altos en orden descendente del n√∫mero de acciones vendidas. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/03/mn/nm/03mnnmhuvjpivozqptxxzpkdrmu.png" alt="imagen"></div><br>  Ya ha encontrado llamadas a groupBy y mapValues, por lo que no nos detendremos en ellas (llamamos al m√©todo KTable.toStream, ya que el m√©todo KTable.print est√° en desuso).  Pero a√∫n no ha visto la versi√≥n KTable del m√©todo agregar (), por lo que pasaremos un tiempo discuti√©ndolo. <br><br>  Como recordar√°, KTable se distingue por el hecho de que los registros con las mismas claves se consideran actualizaciones.  KTable reemplaza el registro anterior por el nuevo.  La agregaci√≥n ocurre de la misma manera: se agregan los √∫ltimos registros con una clave.  Cuando llega un registro, se agrega a una instancia de la clase FixedSizePriorityQueue usando un sumador (el segundo par√°metro en la llamada al m√©todo agregado), pero si ya existe otro registro con la misma clave, el registro anterior se elimina usando el sustractor (el tercer par√°metro en la llamada al m√©todo agregado). <br><br>  Todo esto significa que nuestro agregador, FixedSizePriorityQueue, no agrega todos los valores con una clave, sino que almacena la suma m√≥vil de las cantidades N de los tipos de acciones m√°s vendidas.  Cada entrada contiene el n√∫mero total de acciones vendidas hasta el momento.  KTable le proporcionar√° informaci√≥n sobre las acciones de las empresas que m√°s se venden actualmente; no se requiere la agregaci√≥n continua de cada actualizaci√≥n. <br><br>  Aprendimos a hacer dos cosas importantes: <br><br><ul><li>  agrupar valores en KTable por una clave com√∫n a ellos; </li><li>  Realice operaciones √∫tiles como convoluci√≥n y agregaci√≥n en estos valores agrupados. </li></ul><br>  La capacidad de realizar estas operaciones es importante para comprender el significado de los datos que se mueven a trav√©s de la aplicaci√≥n Kafka Streams y descubrir qu√© informaci√≥n llevan. <br><br>  Tambi√©n hemos reunido algunos de los conceptos clave discutidos anteriormente en este libro.  En el Cap√≠tulo 4, hablamos sobre la importancia de un estado local a prueba de fallas para una aplicaci√≥n de transmisi√≥n.  El primer ejemplo en este cap√≠tulo mostr√≥ por qu√© el estado local es tan importante: permite rastrear la informaci√≥n que ya ha visto.  El acceso local evita demoras en la red, haciendo que la aplicaci√≥n sea m√°s productiva y resistente a errores. <br><br>  Al realizar cualquier operaci√≥n de convoluci√≥n o agregaci√≥n, debe especificar el nombre del almac√©n de estado.  Las operaciones de convoluci√≥n y agregaci√≥n devuelven una instancia de KTable, y KTable usa un almac√©n de estado para reemplazar los resultados antiguos por otros nuevos.  Como ha visto, no todas las actualizaciones se env√≠an m√°s adelante, y esto es importante, ya que las operaciones de agregaci√≥n est√°n dise√±adas para obtener la informaci√≥n final.  Si no se aplica el estado local, KTable enviar√° a√∫n m√°s todos los resultados de agregaci√≥n y convoluci√≥n. <br><br>  A continuaci√≥n, observamos la ejecuci√≥n de operaciones como la agregaci√≥n, dentro de un per√≠odo espec√≠fico de tiempo, las llamadas operaciones de ventanas. <br><br><h3>  5.3.2.  Operaciones de ventana </h3><br>  En la secci√≥n anterior, presentamos la convoluci√≥n y agregaci√≥n "continua".  La aplicaci√≥n realiz√≥ una convoluci√≥n continua de ventas de acciones con la agregaci√≥n posterior de las cinco acciones m√°s vendidas. <br><br>  A veces es necesaria tal agregaci√≥n continua y convoluci√≥n de resultados.  Y a veces solo necesita realizar operaciones en un per√≠odo de tiempo determinado.  Por ejemplo, calcule cu√°ntas transacciones en bolsa se han realizado con acciones de una empresa en particular en los √∫ltimos 10 minutos.  O cu√°ntos usuarios hicieron clic en un nuevo banner publicitario en los √∫ltimos 15 minutos.  Una aplicaci√≥n puede realizar tales operaciones varias veces, pero con resultados relacionados solo con intervalos de tiempo espec√≠ficos (ventanas de tiempo). <br><br><h3>  Contar transacciones de cambio por comprador </h3><br>  En el siguiente ejemplo, participaremos en el seguimiento de las transacciones de cambio para varios operadores, ya sean grandes organizaciones o financistas individuales inteligentes. <br><br>  Hay dos posibles razones para este seguimiento.  Uno de ellos es la necesidad de saber qu√© compran / venden los l√≠deres del mercado.  Si estos grandes jugadores e inversores sofisticados ven oportunidades para s√≠ mismos, tiene sentido seguir su estrategia.  La segunda raz√≥n es el deseo de notar cualquier posible signo de transacciones ilegales utilizando informaci√≥n privilegiada.  Para hacer esto, deber√° analizar la correlaci√≥n de los picos grandes en las ventas con comunicados de prensa importantes. <br><br>  Dicho seguimiento consta de pasos tales como: <br><br><ul><li>  crear una secuencia para leer del tema de transacciones de acciones; </li><li>  agrupaci√≥n de registros entrantes por ID de cliente y s√≠mbolo de stock del stock.  Una llamada al m√©todo groupBy devuelve una instancia de la clase KGroupedStream; </li><li>  KGroupedStream.windowedBy devuelve un flujo de datos limitado por una ventana temporal, que permite la agregaci√≥n de ventanas.  Dependiendo del tipo de ventana, se devuelve TimeWindowedKStream o SessionWindowedKStream; </li><li>  Contando transacciones para una operaci√≥n de agregaci√≥n.  El flujo de datos de la ventana determina si un registro particular se tiene en cuenta en este c√°lculo; </li><li>  escribir resultados en un tema o enviarlos a la consola durante el desarrollo. </li></ul><br>  La topolog√≠a de esta aplicaci√≥n es simple, pero su imagen visual no duele.  Echa un vistazo a la foto.  5.11. <br><br>  Adem√°s consideraremos la funcionalidad de las operaciones de ventana y el c√≥digo correspondiente. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/1h/bd/fi/1hbdfi2s0x4x4up8kkcomwg_omq.png" alt="imagen"></div><br><h3>  Tipos de ventanas </h3><br>  Hay tres tipos de ventanas en Kafka Streams: <br><br><ul><li>  sesi√≥n </li><li>  Tumbling (ca√≠da); </li><li>  deslizamiento / "salto" (deslizamiento / salto). </li></ul><br>  Cu√°l elegir depende de los requisitos comerciales.  Las ventanas de "ca√≠da" y "salto" est√°n limitadas en el tiempo, mientras que las restricciones de sesi√≥n est√°n asociadas con las acciones del usuario: la duraci√≥n de la (s) sesi√≥n (s) se determina √∫nicamente por la forma activa en que se comporta el usuario.  Lo principal es no olvidar que todos los tipos de ventanas se basan en sellos de registros de fecha / hora y no en la hora del sistema. <br><br>  A continuaci√≥n, implementamos nuestra topolog√≠a con cada uno de los tipos de ventana.  El c√≥digo completo se dar√° solo en el primer ejemplo, nada cambiar√° para otros tipos de ventanas, excepto para el tipo de operaci√≥n de la ventana. <br><br><h3>  Ventanas de sesi√≥n </h3><br>  Las ventanas de sesi√≥n son muy diferentes de todos los dem√°s tipos de ventanas.  Est√°n limitados no tanto por el tiempo como por la actividad del usuario (o la actividad de la entidad que desea rastrear).  Las ventanas de sesi√≥n est√°n delimitadas por per√≠odos de inactividad. <br><br>  La figura 5.12 ilustra el concepto de ventanas de sesi√≥n.  Una sesi√≥n m√°s peque√±a se fusionar√° con la sesi√≥n a su izquierda.  Y la sesi√≥n de la derecha ser√° separada, ya que sigue un largo per√≠odo de inactividad.  Las ventanas de sesi√≥n se basan en las acciones del usuario, pero aplique marcas de fecha / hora de los registros para determinar a qu√© sesi√≥n pertenece el registro. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/js/c7/z5/jsc7z525p9wrj_tlmrfa5e3vj_u.png" alt="imagen"></div><br><br><h3>  Uso de Windows de sesi√≥n para rastrear transacciones de Exchange </h3><br>  Utilizaremos ventanas de sesi√≥n para capturar informaci√≥n sobre transacciones de intercambio.  La implementaci√≥n de las ventanas de sesi√≥n se muestra en el Listado 5.5 (que se puede encontrar en src / main / java / bbejeck / chapter_5 / CountingWindowingAndKTableJoinExample.java). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vs/vq/va/vsvqvaqddc3hgy-77fpniuwcbxm.png" alt="imagen"></div><br>  Ya ha cumplido con la mayor√≠a de las operaciones de esta topolog√≠a, por lo que no es necesario considerarlas aqu√≠ nuevamente.  Pero hay varios elementos nuevos que discutiremos ahora. <br><br>  Para cualquier operaci√≥n groupBy, generalmente se realiza alg√∫n tipo de operaci√≥n de agregaci√≥n (agregaci√≥n, convoluci√≥n o conteo).  Puede realizar una agregaci√≥n acumulativa con un total acumulativo o una agregaci√≥n de ventana, en la que los registros se tienen en cuenta dentro de una ventana de tiempo determinada. <br><br>  El c√≥digo en el Listado 5.5 cuenta el n√∫mero de transacciones dentro de las ventanas de sesi√≥n.  En la fig.  5.13 estas acciones se analizan paso a paso. <br><br>  Al llamar a windowedBy (SessionWindows.with (twentySeconds) .until (fifteenMinutes)) creamos una ventana de sesi√≥n con un intervalo inactivo de 20 segundos y un intervalo de retenci√≥n de 15 minutos.  Un intervalo de inactividad de 20 segundos significa que la aplicaci√≥n incluir√° cualquier registro que llegue dentro de los 20 segundos desde el final o el comienzo de la sesi√≥n actual en la sesi√≥n actual (activa). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jh/mk/qv/jhmkqvxrrnrd5mxavzltcu-uglq.png" alt="imagen"></div><br>  A continuaci√≥n, indicamos qu√© operaci√≥n de agregaci√≥n realizar en la ventana de sesi√≥n, en este caso, contar.  Si el registro entrante cae fuera del intervalo de inactividad (a cada lado de la marca de fecha / hora), la aplicaci√≥n crea una nueva sesi√≥n.  El intervalo de guardado significa mantener la sesi√≥n durante un tiempo determinado y permite datos tard√≠os que van m√°s all√° del per√≠odo de inactividad de la sesi√≥n, pero que a√∫n pueden adjuntarse.  Adem√°s, el inicio y el final de una nueva sesi√≥n resultante de la fusi√≥n corresponden a la marca de fecha / hora m√°s temprana y m√°s reciente. <br><br>  Veamos algunas entradas del m√©todo de conteo para ver c√≥mo funcionan las sesiones (Tabla 5.1). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/p-/_f/pn/p-_fpnxaicjsj0ivwzrcxthi77g.png" alt="imagen"></div><br>  Al recibir los registros, buscamos sesiones ya existentes con la misma clave, la hora de finalizaci√≥n es menor que la marca de fecha / hora actual: el intervalo de inactividad y la hora de inicio es mayor que la marca de fecha / hora actual + intervalo de inactividad.  Con esto en mente, cuatro registros de la tabla.  5.1 fusionarse en una sola sesi√≥n de la siguiente manera. <br><br>  1. El registro 1 es lo primero, por lo que la hora de inicio es igual a la hora de finalizaci√≥n y es 00:00:00. <br><br>  2. Luego viene el registro 2, y buscamos sesiones que finalicen no antes de las 23:59:55 y comiencen no m√°s tarde de las 00:00:35.  Busque el registro 1 y combine las sesiones 1 y 2. Tome la hora de inicio de la sesi√≥n 1 (antes) y la hora de finalizaci√≥n de la sesi√≥n 2 (m√°s tarde), para que nuestra nueva sesi√≥n comience a las 00:00:00 y termine a las 00:00:15. <br><br>  3. Llega el registro 3, buscamos sesiones entre 00:00:30 y 00:01:10 y no encontramos ninguna.  Agregue una segunda sesi√≥n para la clave 123-345-654, FFBE, comenzando y terminando a las 00:00:50. <br><br>  4. Llega el registro 4 y buscamos sesiones entre las 23:59:45 y las 00:00:25.  Esta vez hay dos sesiones: 1 y 2. Las tres sesiones se combinan en una, con una hora de inicio de 00:00:00 y una hora de finalizaci√≥n de 00:00:15. <br><br>  De lo que se dice en esta secci√≥n, vale la pena recordar los siguientes matices importantes: <br><br><ul><li>  Las sesiones no son ventanas de tama√±o fijo.  La duraci√≥n de una sesi√≥n est√° determinada por la actividad dentro de un per√≠odo de tiempo determinado; </li><li>  Las marcas de fecha / hora en los datos determinan si un evento cae en una sesi√≥n existente o en un per√≠odo de inactividad. </li></ul><br>  Adem√°s, analizaremos el siguiente tipo de ventanas: ventanas de "salto mortal". <br><br><h3>  Ventanas que caen </h3><br>  Las ventanas "ca√≠das" capturan eventos que caen dentro de un cierto per√≠odo de tiempo.  Imagine que necesita capturar todas las transacciones de intercambio de una empresa cada 20 segundos, para que pueda recopilar todos los eventos durante este per√≠odo de tiempo.  Al final del intervalo de 20 segundos, la ventana "cae" y cambia a un nuevo intervalo de observaci√≥n de 20 segundos.  La figura 5.14 ilustra esta situaci√≥n. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ge/sb/jh/gesbjhkrk4wfpsj94edv21lcgzk.png" alt="imagen"></div><br>  Como puede ver, todos los eventos recibidos en los √∫ltimos 20 segundos se incluyen en la ventana.  Al final de este per√≠odo de tiempo, se crea una nueva ventana. <br><br>  El listado 5.6 muestra el c√≥digo que demuestra el uso de ventanas giratorias para capturar transacciones de intercambio cada 20 segundos (puede encontrarlo en src / main / java / bbejeck / chapter_5 / CountingWindowingAndKtableJoinExample.java). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ej/gw/ba/ejgwbaxfd9vzmdok1u6vl7gqjt4.png" alt="imagen"></div><br>  Gracias a este peque√±o cambio en la llamada al m√©todo TimeWindows.of, puede usar la ventana de ca√≠da.  En este ejemplo, no hay llamada al m√©todo until (), como resultado de lo cual se utilizar√° el intervalo de guardado predeterminado de 24 horas. <br><br>  Finalmente, es hora de pasar a la √∫ltima de las opciones de ventana: saltar ventanas. <br><br><h3>  Ventanas deslizantes ("saltantes") </h3><br>  Las ventanas deslizantes / de "salto" son similares a las "ca√≠das", pero con una ligera diferencia.  Las ventanas deslizantes no esperan el final del intervalo de tiempo antes de crear una nueva ventana para manejar eventos recientes.  Comienzan nuevos c√°lculos despu√©s de un intervalo de espera m√°s corto que la duraci√≥n de la ventana. <br><br>  Para ilustrar las diferencias entre las ventanas "salto mortal" y "salto", volvamos al ejemplo con el c√°lculo de las transacciones de cambio.  Nuestro objetivo, como antes, es contar el n√∫mero de transacciones, pero no queremos esperar todo el tiempo antes de actualizar el contador.  En cambio, actualizaremos el contador a intervalos m√°s cortos.  Por ejemplo, continuaremos contando el n√∫mero de transacciones cada 20 segundos, pero para actualizar el contador cada 5 segundos, como se muestra en la Fig.  5.15.  Al mismo tiempo, tenemos tres ventanas de resultados con datos superpuestos. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/f_/rz/km/f_rzkmhyoxehblurxwysauk3j2k.png" alt="imagen"></div><br>  El listado 5.7 muestra el c√≥digo para especificar ventanas deslizantes (se puede encontrar en src / main / java / bbejeck / chapter_5 / CountingWindowingAndKtableJoinExample.java). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/oa/xr/hn/oaxrhnrcxi78qoylbaatcegq__q.png" alt="imagen"></div><br> ¬´¬ª     ¬´¬ª      advanceBy().       15 . <br><br>     ,      .  ,  ,         : <br><br><ul><li>       ,   ; </li><li> ¬´¬ª          ; </li><li>   ¬´¬ª  ,            . </li></ul><br>   ,   KTable   KStream  . <br><br><h3> 5.3.3.   KStream  KTable </h3><br>   4      KStream.      KTable  KStream.       . KStream ‚Äî  ,  KTable ‚Äî   ,                KTable. <br><br>                .    ,        . <br><br><ol><li>   KTable        KStream      ,   ,    . </li><li>   KTable,       .   KTable     . </li><li>            . </li></ol><br>  ,     . <br><br><h3>  KTable  KStream </h3><br>   KTable  KStream   . <br><br><ol><li>   KTable.toStream(). </li><li>     KStream.map     ,      Windowed  TransactionSummary. </li></ol><br>        (     src/main/java/bbejeck/chapter_5/CountingWindowingAndKtableJoinExample.java) ( 5.8). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jx/_b/9f/jx_b9frqyde6wj2yvo5nk3palwq.png" alt="imagen"></div><br>     KStream.map,       KStream       . <br><br>    ,      KTable    . <br><br><h3>  KTable    </h3><br>  ,    KTable     (      src/main/java/bbejeck/chapter_5/CountingWindowingAndKtableJoinExample.java) ( 5.9). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vb/g5/2w/vbg52wycfxm6ojk2jgpkochuvii.png" alt="imagen"></div><br>  ,    Serde   ,      Serde.     EARLIEST      . <br><br>        ‚Äî . <br><br><h3>         </h3><br>     .      ,         (      src/main/java/bbejeck/chapter_5/CountingWindowingAndKtableJoinExample.java) ( 5.10). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nk/8r/zw/nk8rzwzgk7qtaxv0uq3p_sjaipm.png" alt="imagen"></div><br>   leftJoin  .       4,  JoinWindow  ,     KStream-KTable     KTable    .      :     KTable,  .  :    KTable   KStream    . <br><br>           KStream. <br><br><h3> 5.3.4.  GlobalKTable </h3><br>   ,          .   4      KStream,     ‚Äî  KStream  KTable.                 .      ,   Kafka Streams   .   ,          ,     (    4,   ¬´  ¬ª  4.2.4). <br><br><h3>      </h3><br>     ‚Äî       ,       ;            .  ,               ,           . <br><br><h3>       </h3><br>      ,    ,  ,             .     Kafka Streams   GlobalKTable. <br><br>  GlobalKTable ,         .         ,         ,      .    GlobalKTable     .          . <br><br><h3>   KStream   GlobalKTable </h3><br>   5.3.2        .       : <br><br><pre><code class="plaintext hljs">{customerId='074-09-3705', stockTicker='GUTM'}, 17 {customerId='037-34-5184', stockTicker='CORK'}, 16</code> </pre> <br>  Aunque estos resultados fueron consistentes con el objetivo, ser√≠a m√°s conveniente si tambi√©n se mostraran el nombre del cliente y el nombre completo de la empresa.  Para agregar el nombre de un cliente y el nombre de una empresa, puede realizar conexiones normales, pero deber√° hacer dos asignaciones clave y volver a particionar.  Con GlobalKTable puede evitar el costo de tales operaciones. <br><br>  Para hacer esto, utilizaremos el objeto countStream del Listado 5.11 (el c√≥digo correspondiente se puede encontrar en el archivo src / main / java / bbejeck / chapter_5 / GlobalKTableExample.java), conect√°ndolo con dos objetos GlobalKTable. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/et/ds/zj/etdszjjzni9snwmxxbi21xph8e4.png" alt="imagen"></div><br>  Ya hemos discutido esto antes, as√≠ que no lo repetir√©.  Pero noto que el c√≥digo en toStream (). La funci√≥n Map se abstrae en el objeto de la funci√≥n en aras de la legibilidad en lugar de la expresi√≥n lambda incrustada. <br><br>  El siguiente paso es declarar dos instancias de GlobalKTable (el c√≥digo que se muestra se puede encontrar en src / main / java / bbejeck / chapter_5 / GlobalKTableExample.java) (Listado 5.12). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ut/ca/gd/utcagdf_iab9zjefezaiy2dxt80.png" alt="imagen"></div><br><br>  Tenga en cuenta que los nombres de los temas se describen utilizando tipos enumerados. <br><br>  Ahora que hemos preparado todos los componentes, queda por escribir el c√≥digo para la conexi√≥n (que se puede encontrar en el archivo src / main / java / bbejeck / chapter_5 / GlobalKTableExample.java) (Listado 5.13). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/av/yr/oe/avyroeehcpkzq9rzeiqlernoum8.png" alt="imagen"></div><br>  Aunque hay dos compuestos en este c√≥digo, est√°n organizados en una cadena, ya que ninguno de sus resultados se usa por separado.  Los resultados se muestran al final de toda la operaci√≥n. <br><br>  Cuando inicie la operaci√≥n de conexi√≥n anterior, obtendr√° los siguientes resultados: <br><br><pre> <code class="plaintext hljs">{customer='Barney, Smith' company="Exxon", transactions= 17}</code> </pre> <br>  La esencia no ha cambiado, pero estos resultados parecen m√°s claros. <br><br>  Contando el Cap√≠tulo 4, ya has visto varios tipos de conexiones en acci√≥n.  Se enumeran en la tabla.  5.2.  Esta tabla refleja la conectividad relevante a la versi√≥n 1.0.0 de Kafka Streams;  algo cambiar√° en futuras versiones. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/_u/ka/gh/_ukaghteoopcpk9i5ljf4cjrwju.png" alt="imagen"></div><br>  En conclusi√≥n, le recordar√© lo principal: puede conectar secuencias de eventos (KStream) y actualizaciones de secuencias (KTable) utilizando el estado local.  Adem√°s, si el tama√±o de los datos de referencia no es demasiado grande, puede usar el objeto GlobalKTable.  GlobalKTable replica todas las secciones en cada uno de los nodos de la aplicaci√≥n Kafka Streams, asegurando as√≠ la disponibilidad de todos los datos, independientemente de la secci√≥n a la que corresponda la clave. <br><br>  A continuaci√≥n veremos la posibilidad de Kafka Streams, gracias a la cual puede observar los cambios de estado sin consumir datos del tema Kafka. <br><br><h3>  5.3.5.  Estado de solicitud </h3><br>  Ya hemos realizado varias operaciones relacionadas con el estado y siempre enviamos los resultados a la consola (para fines de desarrollo) o los escribimos en el tema (para operaciones industriales).  Al escribir resultados en un tema, debe usar el consumidor Kafka para verlos. <br><br>  La lectura de datos de estos temas puede considerarse una especie de vistas materializadas.  Para nuestras tareas, podemos usar la definici√≥n de una vista materializada de Wikipedia: ‚Äú... un objeto de base de datos f√≠sico que contiene los resultados de una consulta.  Por ejemplo, puede ser una copia local de datos eliminados, o un subconjunto de las filas y / o columnas de una tabla o resultados de uni√≥n, o una tabla din√°mica obtenida mediante agregaci√≥n ‚Äù(https://en.wikipedia.org/wiki/Materialized_view). <br><br>  Kafka Streams tambi√©n le permite realizar consultas interactivas en tiendas estatales, lo que le permite leer directamente estas vistas materializadas.  Es importante tener en cuenta que la solicitud a la tienda estatal tiene el car√°cter de una operaci√≥n de solo lectura.  Gracias a esto, no puede tener miedo de convertir accidentalmente el estado en una aplicaci√≥n inconsistente durante el procesamiento de datos. <br><br>  La capacidad de consultar directamente los almacenes de estado es importante.  Significa que puede crear aplicaciones: paneles sin tener que recibir primero datos de un consumidor de Kafka.  Aumenta la eficiencia de la aplicaci√≥n, debido al hecho de que no es necesario volver a registrar datos: <br><br><ul><li>  Debido a la localidad de los datos, puede acceder r√°pidamente a ellos. </li><li>  Se excluye la duplicaci√≥n de datos, ya que no se escriben en el almacenamiento externo. </li></ul><br>  Lo principal que me gustar√≠a que recuerde: puede ejecutar directamente solicitudes de estado desde la aplicaci√≥n.  No puede sobreestimar las oportunidades que esto le brinda.  En lugar de consumir datos de Kafka y almacenar registros en la base de datos para la aplicaci√≥n, puede consultar almacenes de estado con el mismo resultado.  Las solicitudes directas a las tiendas estatales significan menos c√≥digo (sin consumidor) y menos software (no se necesita una tabla de base de datos para almacenar los resultados). <br><br>  Hemos cubierto una cantidad considerable de informaci√≥n en este cap√≠tulo, por lo que detendremos temporalmente nuestra discusi√≥n sobre consultas interactivas a las tiendas estatales.  Pero no se preocupe: en el Cap√≠tulo 9 crearemos una aplicaci√≥n simple: un panel de informaci√≥n con consultas interactivas.  Para demostrar consultas interactivas y las posibilidades de agregarlas a las aplicaciones de Kafka Streams, utilizar√° algunos de los ejemplos de este y los cap√≠tulos anteriores. <br><br><h3>  Resumen </h3><br><ul><li>  Los objetos KStream representan secuencias de eventos comparables a las inserciones de bases de datos.  Los objetos de KTable representan flujos de actualizaci√≥n, son m√°s similares a las actualizaciones en la base de datos.  El tama√±o del objeto KTable no crece; los registros antiguos se reemplazan por otros nuevos. </li><li>  Los objetos KTable son necesarios para las operaciones de agregaci√≥n. </li><li>  Con las operaciones de ventana, puede dividir los datos agregados en cestas de tiempo. </li><li>  Gracias a los objetos de GlobalKTable, puede acceder a los datos de referencia en cualquier lugar de la aplicaci√≥n, independientemente de la secci√≥n. </li><li>  Las conexiones entre objetos KStream, KTable y GlobalKTable son posibles. </li></ul><br>  Hasta ahora, nos hemos centrado en crear aplicaciones Kafka Streams utilizando el DSL KStream de alto nivel.  Aunque un enfoque de alto nivel le permite crear programas limpios y concisos, su uso es un compromiso definitivo.  Trabajar con DSL KStream significa aumentar la concisi√≥n del c√≥digo al reducir el grado de control.  En el pr√≥ximo cap√≠tulo, veremos la API de bajo nivel de los nodos del controlador e intentaremos otras compensaciones.  Los programas ser√°n m√°s largos de lo que eran hasta ahora, pero tendremos la oportunidad de crear casi cualquier nodo de procesamiento que podamos necesitar. <br><br>  ‚Üí Se pueden encontrar m√°s detalles sobre el libro en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el sitio web del editor</a> <br><br>  ‚Üí Para Khabrozhiteley 25% de descuento en cupones - <b>Kafka Streams</b> <br><br>  ‚Üí Tras el pago de la versi√≥n en papel del libro, se env√≠a un libro electr√≥nico por correo electr√≥nico. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/457756/">https://habr.com/ru/post/457756/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../457744/index.html">Crear un sistema de extensi√≥n en la biblioteca Qt - Parte 2</a></li>
<li><a href="../457746/index.html">Meteorolog√≠a y vuelos</a></li>
<li><a href="../457750/index.html">Trabaja con JSON RPC en Symfony 4</a></li>
<li><a href="../457752/index.html">No rovers lunares ni bromistas. ¬øQu√© sabemos sobre los robots en Fukushima?</a></li>
<li><a href="../457754/index.html">Estado y asesinos en T</a></li>
<li><a href="../457758/index.html">Los ingenieros salvan a las personas perdidas en el bosque, pero el bosque a√∫n no se ha rendido</a></li>
<li><a href="../457760/index.html">C√≥mo hacer que los contenedores est√©n a√∫n m√°s aislados: una revisi√≥n de las tecnolog√≠as de sandbox de contenedores</a></li>
<li><a href="../457762/index.html">Regla CCD: con qu√© se come</a></li>
<li><a href="../457764/index.html">10 errores del joven PO (parte II)</a></li>
<li><a href="../457766/index.html">Generamos niveles de mosaico y ocultamos cuadrados del jugador</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>