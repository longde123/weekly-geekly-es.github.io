<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😵 🏒 🦈 Manajemen memori atau kurang sering menembak diri sendiri di kaki 🏤 🤟 💞</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habr! Pada artikel ini saya akan mencoba memberi tahu manajemen memori apa dalam program / aplikasi dari sudut pandang programmer aplikasi. Ini ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Manajemen memori atau kurang sering menembak diri sendiri di kaki</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/473294/"><p>  Halo, Habr!  Pada artikel ini saya akan mencoba memberi tahu manajemen memori apa dalam program / aplikasi dari sudut pandang programmer aplikasi.  Ini bukan panduan atau manual lengkap, tetapi hanya gambaran umum dari masalah yang ada dan beberapa pendekatan untuk menyelesaikannya. </p><br><p>  Mengapa ini perlu?  Program adalah urutan instruksi pemrosesan data (dalam kasus yang paling umum).  Data ini perlu <strong>disimpan</strong> , <strong>dimuat</strong> , <strong>ditransfer</strong> , dll. Dalam beberapa cara.  Semua operasi ini tidak terjadi secara instan, oleh karena itu, mereka secara langsung mempengaruhi kecepatan aplikasi akhir Anda.  Kemampuan untuk mengelola data secara optimal dalam proses kerja akan memungkinkan Anda untuk membuat program yang sangat tidak sepele dan sangat menuntut sumber daya. </p><br><p>  Catatan: sebagian besar materi disajikan dengan contoh-contoh dari gim / mesin gim (karena topik ini lebih menarik bagi saya secara pribadi), namun, sebagian besar materi dapat diterapkan ke server penulisan, aplikasi pengguna, paket grafik, dll. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/f13/ef3/482/f13ef3482dfe066b41b53e44179a0242.jpg"></p><br><p>  <em>Tidak mungkin untuk mengingat semuanya.</em>  <em>Tetapi jika Anda tidak berhasil memuatnya, Anda akan mendapatkan sabun</em> </p><a name="habracut"></a><br><h1 id="s-mesta-v-karer">  Langsung dari kelelawar </h1><br><p>  Itu terjadi di industri bahwa proyek game AAA besar dikembangkan terutama pada mesin yang ditulis menggunakan C ++.  Salah satu fitur dari bahasa ini adalah perlunya manajemen memori manual.  Java / C # dll.  Mereka membanggakan pengumpulan sampah (GarbageCollection / GC) - kemampuan untuk membuat objek dan masih tidak membebaskan memori yang digunakan dengan tangan.  Proses ini menyederhanakan dan mempercepat pengembangan, tetapi juga dapat menyebabkan beberapa masalah: seorang pemulung sampah yang dipicu secara berkala dapat membunuh semua waktu lunak-nyata dan menambahkan pembekuan yang tidak menyenangkan ke dalam permainan. </p><br><p>  Ya, dalam proyek-proyek seperti "Minecraft" GC mungkin tidak terlihat, seperti  mereka umumnya tidak menuntut pada sumber daya komputer, tetapi permainan seperti "Red Dead Redemption 2", "God of War", "Last of Us" bekerja "hampir" pada puncak kinerja sistem dan karenanya tidak hanya perlu besar jumlah sumber daya, tetapi juga dalam distribusi yang kompeten. </p><br><p>  Selain itu, bekerja di lingkungan dengan alokasi memori otomatis dan pengumpulan sampah, Anda mungkin menghadapi kurangnya fleksibilitas dalam pengelolaan sumber daya.  Bukan rahasia lagi bahwa Java menyembunyikan semua detail implementasi dan aspek pekerjaannya di bawah tenda, sehingga pada output Anda hanya memiliki antarmuka yang diinstal untuk berinteraksi dengan sumber daya sistem, tetapi mungkin tidak cukup untuk menyelesaikan beberapa masalah.  Misalnya, memulai algoritme dengan jumlah alokasi memori yang tidak konstan di setiap frame (ini bisa berupa pencarian jalur AI, memeriksa visibilitas, animasi, dll.) Mengarah pada penurunan kinerja yang sangat buruk. </p><br><h1 id="kak-vyglyadyat-allokacii-v-kode">  Bagaimana alokasi dalam kode terlihat </h1><br><p>  Sebelum melanjutkan diskusi, saya ingin menunjukkan bagaimana kerja dengan memori dalam C / C ++ secara langsung terjadi dengan beberapa contoh.  Secara umum, antarmuka standar dan paling sederhana untuk mengalokasikan memori proses diwakili oleh operasi berikut: </p><br><pre><code class="plaintext hljs">//        size  void* malloc(size_t size); //      p void free(void* p);</code> </pre> <br><p>  Di sini Anda dapat menambahkan tentang fungsi tambahan yang memungkinkan Anda mengalokasikan memori yang selaras: </p><br><pre> <code class="plaintext hljs">// C11  -     , * alignment void* aligned_alloc(size_t size, size_t alignment); // Posix  -       //        address (*address = allocated_mem_p) int posix_memalign(void** address, size_t alignment, size_t size);</code> </pre> <br><p>  Harap dicatat bahwa platform yang berbeda dapat mendukung standar fungsi yang berbeda, tersedia misalnya pada MacOS dan tidak tersedia saat menang. </p><br><p>  Ke depan, area memori yang selaras <strong>secara khusus</strong> mungkin diperlukan bagi Anda berdua untuk mencapai jalur cache prosesor dan untuk perhitungan menggunakan set register yang diperluas ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SSE</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MMX</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">AVX</a> , dll.). </p><br><p>  Contoh program mainan yang mengalokasikan memori dan mencetak nilai buffer, menafsirkannya sebagai bilangan bulat yang ditandatangani: </p><br><pre> <code class="plaintext hljs">/* main.cpp */ #include &lt;cstdio&gt; #include &lt;cstdlib&gt; int main(int argc, char** argv) { const int N = 10; int* buffer = (int*) malloc(sizeof(int) * N); for(int i = 0; i &lt; N; i++) { printf("%i ", buffer[i]); } free(buffer); return 0; }</code> </pre> <br><p>  Pada macOS 10.14, program ini dapat dibangun dan dijalankan dengan serangkaian perintah berikut: </p><br><pre> <code class="plaintext hljs">$ clang++ main.cpp -o main $ ./main</code> </pre> <br><p>  Catatan: selanjutnya saya tidak ingin menutup operasi C ++ seperti baru / hapus, karena mereka lebih cenderung digunakan untuk membangun / menghancurkan objek secara langsung, tetapi mereka menggunakan operasi yang biasa dengan memori seperti malloc / free. </p><br><h1 id="problemy-s-pamyatyu">  Masalah memori </h1><br><p>  Ada beberapa masalah yang muncul saat bekerja dengan RAM komputer.  Semua dari mereka, satu atau lain cara, disebabkan tidak hanya oleh fitur-fitur OS dan perangkat lunak, tetapi juga oleh arsitektur besi di mana semua hal ini bekerja. </p><br><h3 id="1-kolichestvo-pamyati">  1. Jumlah memori </h3><br><p>  Sayangnya, memori secara fisik terbatas.  Di PlayStation 4, ini adalah 8 GiB GDDR5, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">3,5 GiB yang cadangan sistem operasinya untuk kebutuhannya</a> .  Memori virtual dan pertukaran halaman tidak akan banyak membantu, karena menukar halaman ke disk adalah operasi yang sangat lambat (dalam frame N tetap per detik, jika kita berbicara tentang permainan). </p><br><p>  Perlu juga dicatat " <em>anggaran</em> " terbatas - beberapa batasan artifisial pada jumlah memori yang digunakan, dibuat untuk menjalankan aplikasi pada beberapa platform.  Jika Anda membuat game untuk platform seluler dan ingin mendukung tidak hanya satu, tetapi seluruh lini perangkat, Anda harus membatasi selera Anda demi menyediakan pasar penjualan yang lebih luas.  Ini dapat dicapai baik dengan hanya membatasi konsumsi RAM, dan oleh kemampuan untuk mengkonfigurasi pembatasan ini tergantung pada gadget di mana permainan sebenarnya dimulai. </p><br><h3 id="2-fragmentaciya">  2. Fragmentasi </h3><br><p>  Efek tidak menyenangkan yang muncul selama proses alokasi beberapa bagian memori dengan berbagai ukuran.  Akibatnya, Anda mendapatkan ruang alamat yang terpecah menjadi banyak bagian yang terpisah.  Menggabungkan bagian-bagian ini menjadi satu blok dengan ukuran yang lebih besar tidak akan berfungsi, karena bagian dari memori ditempati, dan kita tidak dapat memindahkannya dengan bebas. </p><br><p><img src="https://habrastorage.org/webt/8f/un/ie/8funiekbmroqz6xqhdpsyrpovcs.png"><br>  Fragmentasi dengan contoh alokasi berurutan dan rilis blok memori </p><br><p>  Sebagai hasilnya: kita dapat memiliki memori bebas yang cukup secara kuantitatif, tetapi tidak secara kualitatif.  Dan permintaan berikutnya, katakanlah, "mengalokasikan ruang untuk trek audio", pengalokasi tidak akan dapat memuaskan, karena tidak ada satu pun memori ukuran ini. </p><br><h3 id="3-kesh-processora">  3. cache CPU </h3><br><p><img src="https://habrastorage.org/getpro/habr/post_images/e9d/592/5e5/e9d5925e5a0fc9629656ead20ce91b36.png"><br>  Hirarki memori komputer </p><br><p>  Cache prosesor modern adalah tautan perantara yang menghubungkan memori utama (RAM) dan prosesor mendaftar secara langsung.  Kebetulan akses baca / tulis ke memori adalah operasi yang sangat lambat (jika kita berbicara tentang jumlah siklus jam CPU yang diperlukan untuk mengeksekusi).  Oleh karena itu, ada beberapa hierarki cache (L1, L2, L3, dll.), Yang memungkinkan, "menurut beberapa prediksi" untuk memuat data dari RAM, atau secara perlahan mendorongnya ke dalam memori yang lebih lambat. </p><br><p>  Menempatkan objek dengan tipe yang sama dalam satu baris dalam memori memungkinkan Anda untuk "secara signifikan" mempercepat proses memprosesnya (jika pemrosesan terjadi secara berurutan), karena dalam hal ini lebih mudah untuk memprediksi data apa yang akan dibutuhkan selanjutnya.  Dan dengan "signifikan" berarti peningkatan produktivitas di kali.  Pengembang mesin Unity telah berulang kali membicarakan hal ini dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">laporan</a> mereka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di GDC</a> . </p><br><h3 id="4-multi-threading">  4. Multi-threading </h3><br><p>  <strong>Memastikan akses aman ke memori bersama di lingkungan multi-utas</strong> adalah salah satu masalah utama yang harus Anda selesaikan saat membuat mesin gim Anda sendiri / gim / aplikasi lain yang menggunakan banyak utas untuk mencapai kinerja yang lebih besar.  Komputer modern diatur dengan cara yang sangat tidak sepele.  Kami memiliki struktur cache yang kompleks dan beberapa inti kalkulator.  Semua ini, jika digunakan secara tidak benar, dapat menyebabkan situasi ketika data yang dibagikan dari proses Anda akan rusak sebagai akibat dari beberapa utas (jika mereka secara bersamaan mencoba untuk bekerja dengan data ini tanpa kontrol akses).  Dalam kasus paling sederhana, akan terlihat seperti ini: <br><img src="https://habrastorage.org/webt/sl/dm/2y/sldm2ybotnk9ncozwf5rkgozifw.png"><br>  Saya tidak ingin mempelajari topik pemrograman multi-utas, karena banyak aspeknya jauh melampaui lingkup artikel atau bahkan keseluruhan buku. </p><br><h3 id="5-mallocfree">  5. Malloc / gratis </h3><br><p>  Operasi alokasi / rilis tidak terjadi secara instan.  Pada sistem operasi modern, jika kita berbicara tentang Windows / Linux / MacOS, mereka diimplementasikan dengan baik dan bekerja <em>dengan cepat di sebagian besar situasi</em> .  Tetapi berpotensi ini adalah operasi yang sangat memakan waktu.  Tidak hanya ini panggilan sistem, tetapi tergantung pada implementasinya, mungkin perlu beberapa saat untuk menemukan bagian memori yang sesuai (First Fit, Best fit, dll.) Atau untuk menemukan tempat untuk memasukkan dan / atau menggabungkan area yang dibebaskan. </p><br><p>  Selain itu, memori yang baru dialokasikan mungkin tidak benar-benar dipetakan ke halaman fisik nyata, yang mungkin juga memakan waktu pada akses pertama. </p><br><p>  Ini adalah detail implementasi, tetapi bagaimana dengan penerapannya?  Malloc / baru tidak tahu di mana, bagaimana, atau mengapa Anda memanggil mereka.  Mereka mengalokasikan memori (dalam kasus terburuk) dari 1 KiB dan 100 MiB sama-sama ... sama buruknya.  Secara langsung, strategi penggunaan diserahkan kepada programmer atau orang yang mengimplementasikan runtime program Anda. </p><br><h3 id="6-memory-corruption">  6. Memori rusak </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Seperti kata wiki</a> , ini adalah salah satu kesalahan yang paling tidak terduga yang hanya muncul selama program, dan paling sering disebabkan langsung oleh kesalahan dalam penulisan program ini.  Tapi apa masalahnya?  Untungnya (atau sayangnya), ini tidak terkait dengan kerusakan komputer Anda.  Sebaliknya, ini menampilkan situasi di mana Anda mencoba untuk bekerja dengan memori yang <em>bukan milik Anda</em> .  Saya akan jelaskan sekarang: </p><br><ol><li>  Ini mungkin merupakan upaya untuk membaca / menulis ke sebagian memori yang tidak terisi. </li><li>  Melampaui batas blok memori yang disediakan untuk Anda.  Masalah ini adalah semacam kasus khusus masalah (1), tetapi lebih buruk karena sistem akan memberi tahu Anda bahwa Anda melampaui batas hanya ketika Anda membiarkan halaman ditampilkan untuk Anda.  Artinya, berpotensi, masalah ini sangat sulit ditangkap, karena OS hanya dapat merespons jika Anda meninggalkan batas halaman virtual yang ditampilkan kepada Anda.  Anda dapat merusak memori proses dan mendapatkan kesalahan yang sangat aneh dari tempat yang tidak diharapkan sama sekali. </li><li>  Melepaskan memori yang sudah dibebaskan (terdengar aneh) atau belum dialokasikan </li><li>  dll. </li></ol><br><p>  Dalam C / C ++, di mana ada aritmatika pointer, Anda akan menemukan ini satu atau dua kali.  Namun, di Java Runtime, Anda harus berkeringat cukup keras untuk mendapatkan kesalahan semacam ini (saya belum mencobanya sendiri, tapi saya pikir ini mungkin, kalau tidak hidup akan terlalu sederhana). </p><br><h3 id="7-utechki-pamyati">  7. Kebocoran memori </h3><br><p>  Ini adalah kasus khusus dari masalah yang lebih umum yang terjadi dalam banyak bahasa pemrograman.  Pustaka C / C ++ standar menyediakan akses ke sumber daya OS.  Itu bisa berupa file, soket, memori, dll.  Setelah digunakan, sumber daya harus ditutup dengan benar dan <br>  memori yang ditempati olehnya harus dibebaskan.  Dan jika kita berbicara secara khusus tentang membebaskan kebocoran yang diakumulasikan sebagai akibat dari program dapat menyebabkan kesalahan "kehabisan memori" ketika OS tidak akan dapat memenuhi permintaan alokasi berikutnya.  Seringkali, pengembang hanya lupa untuk membebaskan memori yang digunakan karena satu dan lain alasan. </p><br><p>  Di sini perlu ditambahkan tentang penutupan dan pelepasan sumber daya yang benar pada GPU, karena driver awal tidak memungkinkan untuk melanjutkan bekerja dengan kartu video jika sesi sebelumnya tidak selesai dengan benar.  Hanya me-reboot sistem yang bisa menyelesaikan masalah ini, yang sangat meragukan - untuk memaksa pengguna me-reboot sistem setelah menjalankan aplikasi Anda. </p><br><h3 id="8-dangling-pointer">  8. Menggantung pointer </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><strong>Pointer menggantung</strong></a> adalah beberapa jargon yang menggambarkan situasi di mana pointer merujuk ke nilai yang tidak valid.  Situasi serupa dapat dengan mudah muncul ketika menggunakan pointer C-style klasik dalam program C / C ++.  Misalkan Anda mengalokasikan memori, menyimpan alamatnya ke dalam pointer p, dan kemudian membebaskan memori (lihat contoh kode): </p><br><pre> <code class="plaintext hljs">//   void* p = malloc(size); // ...  -    //   free(p); //    p? // *p == ?</code> </pre> <br><p>  Pointer menyimpan beberapa nilai, yang dapat kita artikan sebagai alamat blok memori.  Kebetulan kami tidak dapat mengatakan apakah blok memori ini valid atau tidak.  Hanya seorang programmer, berdasarkan perjanjian tertentu, dapat beroperasi dengan pointer.  Dimulai dengan C ++ 11, sejumlah pointer "pointer pintar" tambahan diperkenalkan ke perpustakaan standar, yang memungkinkan untuk melemahkan kontrol sumber daya oleh programmer dengan menggunakan meta-informasi tambahan di dalam diri mereka (lebih lanjut tentang ini nanti). </p><br><p>  Sebagai solusi parsial, Anda dapat menggunakan nilai <em>khusus dari</em> pointer, yang akan memberi sinyal kepada kami bahwa tidak ada apa-apa di alamat ini.  Di C, makro NULL digunakan sebagai nilai dari nilai ini, dan di C ++, kata kunci bahasa nullptr digunakan.  Solusinya parsial, karena: </p><br><ol><li>  Nilai pointer harus ditetapkan secara manual, sehingga programmer bisa lupa melakukannya. </li><li>  nullptr atau hanya 0x0 termasuk dalam set nilai yang diterima oleh pointer, yang tidak baik ketika keadaan khusus suatu objek diekspresikan melalui keadaan biasa.  Ini adalah semacam warisan, dan berdasarkan kesepakatan, OS tidak akan mengalokasikan kepada Anda sepotong memori yang alamatnya dimulai dengan 0x0. </li></ol><br><p>  Kode sampel dengan nol: </p><br><pre> <code class="plaintext hljs">//  -  p free(p); p = nullptr; //   p == nullptr   ,       </code> </pre> <br><p>  Anda dapat mengotomatiskan proses ini sampai batas tertentu: </p><br><pre> <code class="plaintext hljs">void _free(void* &amp;p) { free(p); p = nullptr; } //  -  p _free(p); //   p == nullptr,     //   </code> </pre> <br><h3 id="9-tip-pamyati">  9. Jenis memori </h3><br><p>  <strong>RAM</strong> adalah memori akses acak umum untuk keperluan umum, akses yang melalui bus pusat memiliki semua inti prosesor dan perangkat periferal Anda.  Volumenya bervariasi, tetapi paling sering kita berbicara tentang N gigabytes, di mana N adalah 1,2,4,8,16 dan seterusnya.  Panggilan malloc / free berusaha untuk menempatkan blok memori yang Anda inginkan tepat di RAM komputer. </p><br><p>  <strong>VRAM</strong> (memori video) - memori video, yang disertakan dengan kartu video / akselerator video PC Anda.  Sebagai aturan, lebih kecil dari RAM (sekitar 1,2,4 GiB), tetapi memiliki kecepatan tinggi.  Distribusi jenis memori ini ditangani oleh driver kartu video, dan paling sering Anda tidak memiliki akses langsung ke sana. </p><br><p>  Tidak ada pemisahan seperti itu pada PlayStation 4, dan semua RAM diwakili oleh 8 gigabytes tunggal pada GDDR5.  Karena itu, semua data untuk prosesor dan akselerator video ada di dekatnya. </p><br><p>  Manajemen sumber daya yang baik di mesin permainan mencakup alokasi memori yang kompeten baik di RAM Utama maupun di sisi VRAM.  Di sini Anda mungkin mengalami <strong>duplikasi</strong> ketika data yang sama ada di sana-sini, atau dengan <strong>transfer</strong> data yang <strong>berlebihan</strong> dari RAM ke VRAM dan sebaliknya. </p><br><p>  <strong>Sebagai ilustrasi untuk semua masalah yang disuarakan</strong> : Anda dapat melihat aspek-aspek komputer perangkat pada contoh arsitektur PlayStation 4 (Gbr.).  Berikut adalah prosesor pusat, 8 core, cache level L1 dan L2, bus data, RAM, akselerator grafis, dll.  Untuk deskripsi lengkap dan terperinci, lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Arsitektur Mesin Game"</a> karya Greg Gregory. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/c50/7ba/756/c507ba75624a3c9be702f85ddfa50e11.png"><br>  Arsitektur PlayStation 4 </p><br><h1 id="obschie-podhody-k-resheniyu">  Pendekatan Umum </h1><br><p>  Tidak ada solusi universal.  Tetapi ada satu set beberapa poin di mana Anda harus fokus jika Anda akan menerapkan alokasi dan manajemen memori secara manual dalam aplikasi Anda.  Ini termasuk kontainer dan pengalokasi khusus, strategi alokasi memori, desain sistem / game, manajer sumber daya, dan banyak lagi. </p><br><h2 id="tipy-allokatorov">  Jenis pengalokasi </h2><br><p>  Penggunaan pengalokasi memori khusus didasarkan pada ide berikut: Anda tahu ukuran apa, pada saat apa pekerjaan dan di tempat apa Anda akan membutuhkan potongan memori.  Oleh karena itu, Anda dapat mengalokasikan memori yang diperlukan, entah bagaimana menyusunnya dan menggunakan / menggunakannya kembali.  Ini adalah ide umum / konsep menggunakan pengalokasi khusus.  Apa mereka (tentu saja, tidak semua) dapat dilihat lebih lanjut: </p><br><ol><li><p>  <strong>Pengalokasi linier</strong> <br>  Merupakan penyangga ruang alamat yang berdekatan.  Dalam perjalanan kerja, ini memungkinkan Anda untuk mengalokasikan bagian memori dengan ukuran sewenang-wenang (sedemikian rupa sehingga sesuai dengan buffer).  Tetapi Anda dapat membebaskan semua memori yang dialokasikan hanya 1 kali.  Artinya, sepotong memori sewenang-wenang tidak dapat dibebaskan - itu akan tetap seolah-olah <em>ditempati</em> sampai seluruh buffer ditandai sebagai bersih.  Desain ini menyediakan alokasi dan pelepasan O (1), yang memberikan jaminan kecepatan dalam kondisi apa pun. <br><img src="https://habrastorage.org/webt/eb/tp/vm/ebtpvmrs616uwpgdfpd1nujw69s.png"><br>  Kasus penggunaan umum: dalam proses memperbarui keadaan proses (setiap frame dalam game) Anda dapat menggunakan LinearAllocator untuk mengalokasikan buffer tmp untuk kebutuhan teknis: pemrosesan input, bekerja dengan string, parsing perintah ConsoleManager dalam mode debug, dll. </p><br></li><li><p>  <strong>Alokasi pengalokasian</strong> <br>  Modifikasi pengalokasi linier.  Memungkinkan Anda mengosongkan memori dengan urutan alokasi terbalik, dengan kata lain, berperilaku seperti tumpukan biasa menurut prinsip LIFO.  Ini bisa sangat berguna untuk melakukan perhitungan matematis yang dimuat (hierarki transformasi), untuk mengimplementasikan pekerjaan subsistem scripting, untuk setiap perhitungan di mana prosedur yang ditunjukkan untuk membebaskan memori diketahui sebelumnya. <br><img src="https://habrastorage.org/webt/hu/7j/fm/hu7jfm6iqhxz0uk5xwo_ayzwyfo.png"><br>  Kesederhanaan desain memberikan alokasi memori O (1) dan kecepatan membebaskan. </p><br></li><li><p>  <strong>Pengalokasi kolam renang</strong> <br>  Memungkinkan Anda mengalokasikan blok memori dengan ukuran yang sama.  Ini dapat diimplementasikan sebagai penyangga ruang alamat kontinu, dibagi menjadi blok-blok dengan ukuran yang telah ditentukan.  Blok ini dapat membentuk daftar tertaut.  Dan kita selalu tahu blok mana yang akan diberikan dalam alokasi berikutnya.  Informasi meta ini dapat disimpan di blok itu sendiri, yang memaksakan pembatasan pada ukuran blok minimum (sizeof (void *)).  Pada kenyataannya, ini tidak kritis. <br><img src="https://habrastorage.org/webt/cv/sl/qz/cvslqzmqj1nsp-gtqccoyx6hwy4.png"><br>  Karena semua blok memiliki ukuran yang sama, tidak masalah bagi kami untuk mengembalikan blok mana, dan oleh karena itu, semua operasi alokasi / deallokasi dapat dilakukan dalam O (1). </p><br></li><li><p>  <strong>Pengalokasi bingkai</strong> <br>  Alokasi linear tetapi hanya dengan referensi ke frame saat ini - memungkinkan Anda untuk melakukan alokasi memori tmp dan kemudian secara otomatis melepaskan semuanya ketika mengubah frame.  Ini harus dipilih secara terpisah, karena ini adalah entitas global dan unik dalam kerangka permainan runtime, dan oleh karena itu dapat dibuat dari ukuran yang sangat mengesankan, katakanlah beberapa lusin MiB, yang akan sangat berguna ketika memuat sumber daya dan memprosesnya. </p><br></li><li><p>  <strong>Pengalokasi bingkai ganda</strong> <br>  Ini adalah pengalokasi bingkai ganda, tetapi dengan beberapa fitur.  Ini memungkinkan Anda untuk mengalokasikan memori dalam bingkai saat ini, dan menggunakannya dalam frame saat ini dan berikutnya.  Yaitu, memori yang Anda alokasikan dalam bingkai N akan dibebaskan hanya setelah bingkai N +1.  Ini diwujudkan dengan beralih frame aktif untuk menyorot di akhir setiap frame. <br><img src="https://habrastorage.org/webt/ug/cc/zh/ugcczhvv6ibzbarvb0plwhvgbuu.png"><br>  Tapi jenis pengalokasi ini, seperti yang sebelumnya, memberlakukan sejumlah pembatasan pada masa objek yang dibuat dalam memori yang dialokasikan untuk itu.  Oleh karena itu, Anda harus menyadari bahwa pada akhir frame, data menjadi tidak valid, dan akses berulang ke mereka dapat menyebabkan masalah serius. </p><br></li><li><p>  <strong>Pengalokasi statis</strong> <br>  Jenis pengalokasi ini mengalokasikan memori dari buffer yang diperoleh, misalnya, pada tahap peluncuran program, atau ditangkap pada tumpukan dalam bingkai fungsi.  Berdasarkan jenisnya, ini dapat benar-benar pengalokasi apa pun: linier, kumpulan, tumpukan.  Mengapa disebut <em>statis</em> ?  Ukuran buffer memori yang ditangkap harus diketahui <strong>pada tahap kompilasi</strong> program.  Ini memberlakukan batasan yang signifikan: jumlah memori yang tersedia untuk pengalokasi ini tidak dapat diubah selama operasi.  Tapi apa manfaatnya?  Buffer yang digunakan akan secara otomatis ditangkap dan kemudian dibebaskan (baik setelah selesai bekerja atau saat keluar dari fungsi).  Ini tidak memuat tumpukan, menyelamatkan Anda dari fragmentasi, memungkinkan Anda untuk dengan cepat mengalokasikan memori pada tempatnya. <br>  Anda dapat melihat contoh kode menggunakan pengalokasi ini, jika Anda perlu memecah string menjadi substring dan melakukan sesuatu dengannya: <br><img src="https://habrastorage.org/webt/3s/xk/t5/3sxkt5_00ztji1gesnh0cd1edno.png"><br>  Dapat juga dicatat bahwa penggunaan memori dari stack secara teori jauh lebih efisien, karena  susun bingkai fungsi saat ini dengan probabilitas tinggi sudah akan ada di cache prosesor. </p><br></li></ol><br><p>  Semua pengalokasi ini entah bagaimana menyelesaikan masalah dengan fragmentasi, dengan kurangnya memori, dengan kecepatan menerima dan melepaskan blok ukuran yang diperlukan, dengan umur objek dan memori yang mereka tempati. </p><br><p>  Juga harus dicatat bahwa pendekatan yang tepat untuk desain antarmuka akan memungkinkan Anda untuk membuat semacam <em>hierarki</em> pengalokasi ketika, misalnya: kumpulan mengalokasikan memori dari alokasi bingkai, dan alokasi bingkai pada gilirannya mengalokasikan memori dari alokasi linier.  Struktur serupa dapat dilanjutkan lebih lanjut, beradaptasi dengan tugas dan kebutuhan Anda. </p><br><p><img src="https://habrastorage.org/webt/rf/l8/4a/rfl84aakccaw2qfdw6hxlqiygos.png"></p><br><p>  Saya melihat antarmuka serupa untuk membuat hierarki sebagai berikut: </p><br><pre> <code class="plaintext hljs">class IAllocator { public: virtual void* alloc(size_t size) = 0; virtual void* alloc(size_t size, size_t alignment) = 0; virtual void free (void* &amp;p) = 0; }</code> </pre> <br><p>          malloc/free ,     .  ,        ,            .           /    ,       . </p><br><h2 id="umnye-ukazateli">   </h2><br><p> Smart pointer —        C++   ++11 (   boost,    ).   -,     ,        -  ,        .                . </p><br><p>       ?     : </p><br><ol><li>       </li><li>   (/) </li><li>    </li></ol><br><p>         : </p><br><ol><li><p> <strong>Unique pointer</strong> <br>      1    ( ). <br>   unique pointer ,          .        , ..    1   / . <br>        uniquePtr1  uniquePtr2,    uniquePtr1 , .   1  . <br><img src="https://habrastorage.org/webt/xl/qd/x2/xlqdx2thnzcg7rvvv0va70zpzl4.png"></p><br></li><li><p> <strong>Shared pointer</strong> <br>        (reference counting).       ,    ,      .    , ,      ,    . <br><img src="https://habrastorage.org/webt/jb/y6/wi/jby6wipfn5sv2ghabpuzzresgsk.png"><br>       . -,       ,      .        . -,  -                . </p><br></li><li><p> <strong>Weak pointer</strong> <br>    .       ,    .  Apa artinya ini?           shared pointer.   ,   shared pointer  ,     . ,     shared pointer weak pointer.  ,   (shared)    ,   weak pointer    shared pointer.    —  weak pointer ,     ,  ,       . <br><img src="https://habrastorage.org/webt/nr/bt/bq/nrbtbqg6rukrcdgmij-v08bpim4.png"><br>   shared,   weak pointer     meta-data   .    -   ,     ..   ,  O(N) overhead  ,  N — -  .      , .               ,        .         . </p><br></li></ol><br><p>     :         . ,  shared pointer,     ,    (      )  <em>- - -</em> .           .            meta-info   ,  ,           .  Contoh: </p><br><pre> <code class="plaintext hljs">/*     */ /*   ,  shared pointer */ Array&lt;TSharedPtr&lt;Object&gt;&gt; objects; objects.add(newShared&lt;Object&gt;(...)); ... objects.add(newShared&lt;Object&gt;(...));</code> </pre> <br><pre> <code class="plaintext hljs">/*      (   meta-info    ) */ Array&lt;Object&gt; objects; objects.emplace(...); ... objects.emplace(...);</code> </pre> <br><p>   .            .  Tentang itu lebih jauh. </p><br><h2 id="unique-id"> Unique id </h2><br><p>      ,    .     (id/identificator),   , ,   -.    : </p><br><ol><li> <strong> </strong> <br>     ,   id.    ,   <strong>  </strong> ,  ,          id. </li><li> <strong>  </strong> <br>      ,          (  ,     ) </li><li> <strong>    </strong> <br>    id  ,      ,        id. </li><li> <strong>    </strong> <br>                 . ,   id,     . </li></ol><br><p>     :    id,   ,      id,         . </p><br><p>  id     ,  (Vulkan, OpenGL),   (Godot, CryEngine).  EntityID   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">     CryEngine</a> . </p><br><p>   ,  id   :   .     ,     (   ),     ,      . </p><br><pre> <code class="plaintext hljs">/*    */ class ID { uint32 index; uint32 generation; }</code> </pre> <br><pre> <code class="plaintext hljs">/*  - /  */ class ObjectManager { public: ID create(...); void destroy(ID); void update(ID id, ...); private: Array&lt;uint32&gt; generations; Array&lt;Objects&gt; objects; }</code> </pre> <br><p>   ID        ,     ID .     : </p><br><pre> <code class="plaintext hljs">generation = generations[id.index]; if (generation == id.generation) then /*    */ else /*  ,     */</code> </pre> <br><p>      id      generation  1   id   ids. </p><br><h2 id="konteynery">  </h2><br><p>     C++   ,         .      std,     <strong></strong>   ,   <strong></strong>    .        : </p><br><ul><li> Linked list —   </li><li> Array — /  </li><li> Queue —  </li><li> Stack —  </li><li> Map —   </li><li> Set —  </li></ul><br><p>         ?             memory corruption.        / ,    ,   ,    ,     . </p><br><h1 id="obschie-idei">   </h1><br><p>           ,     ,       .  , ,    /         . </p><br><h2 id="pod-konkretnye-zadachi">    </h2><br><p>   ,      ,       .              ,   (  )   .    ,   malloc/free  ,       ,            . </p><br><p>     ?   ,     (/ ),     ,     ,   .    ,     ,    ,           . </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/554/778/95b/55477895bb7e2fcf71d44ad06ceb8ce3.jpg"><br> ryEngine Sandbox:       </p><br><p>   ,   Unreal, Unity, CryEngine  .,     ,    . ,       , ,     —       ,                 . </p><br><h2 id="pre-allocating"> Pre-allocating </h2><br><p>        ,      /          . </p><br><p>    :   malloc/free      .     ,      "run out of memory", .        .         ,       (,   ,     .). </p><br><p>       .          .  ,         -  .           ,           malloc/free,    : ,  ,  . </p><br><h2 id="ne-nado-boyatsya-dinamicheskoy-pamyati">      </h2><br><p>            .   :     ,       , ,   ..             . </p><br><p>    :   ,      ,       ,    .  open-source ,      ,     .   ,  ,   —     malloc/free. </p><br><h2 id="dizayn-iz-ogranicheniy">    </h2><br><p>  GDC  CD Project Red <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">  </a> ,     ,       "The Witcher: Blood and Wine"    ()        .     ,     ,    ,         ,         . <br><img src="https://habrastorage.org/getpro/habr/post_images/80b/c6c/fb0/80bc6cfb08009ba02caee322cb092110.png"></p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">   </a>    Naughty Dog  ,      "Uncharted 4: A Thief's End"     ,         (,    )       . <br><img src="https://habrastorage.org/getpro/habr/post_images/7c4/2c8/469/7c42c84690c9374423bba12dea6126ff.jpg"></p><br><h1 id="zaklyuchenie">  Kesimpulan </h1><br><p>     ,    ,     ,          .       ,         .     / ,     ,   -   ..       ,        (,    ). </p><br><h1 id="literatura-i-poleznye-ssylki">     </h1><br><ul><li>         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Game Engine Architecture"</a> .           ,  , , ,   ..  ,    ,      . </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Custom memory allocators</a> —        ,     C++  .     ,         . </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Smart pointers</a> —     ,      . </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Start Pre-allocating And Stop Worrying</a> —        </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id473294/">https://habr.com/ru/post/id473294/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id473284/index.html">Senior, TechLead, Arsitek - apa selanjutnya? Bagaimana cara menghadapi rutinitas kerja dan ke mana harus pindah?</a></li>
<li><a href="../id473286/index.html">Kami menulis perlindungan terhadap serangan DDoS pada XDP. Bagian nuklir</a></li>
<li><a href="../id473288/index.html">Buat kode Anda dari awal, ini akan memompa level Anda</a></li>
<li><a href="../id473290/index.html">Julia. Di mana memulai proyek? ...</a></li>
<li><a href="../id473292/index.html">Intisari materi menarik untuk pengembang ponsel # 319 (pada 21-27 Oktober)</a></li>
<li><a href="../id473296/index.html">Memulai tanpa uang. Pengalaman pribadi</a></li>
<li><a href="../id473298/index.html">Cara membangun proses dan berhenti mengejek tim</a></li>
<li><a href="../id473300/index.html">PR di era digital, program loyalitas modern dan pemasaran festival</a></li>
<li><a href="../id473302/index.html">Selamat tinggal HTML, Hai QML</a></li>
<li><a href="../id473308/index.html">Cara melakukan Peninjauan Kode oleh Google</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>