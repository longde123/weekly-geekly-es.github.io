<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üàöÔ∏è üë©üèª‚Äçüî¨ üéôÔ∏è M√ºllsammler. Voller Kurs + Transfer von BOTR üóΩ ‚Ü©Ô∏è üéÖüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Artikel finden Sie zwei Informationsquellen gleichzeitig: 


1. Schlie√üe den Garbage Collector-Kurs in Russisch ab: CLRium # 6 ( aktueller W...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>M√ºllsammler. Voller Kurs + Transfer von BOTR</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/clrium/blog/463293/"><p>  In diesem Artikel finden Sie zwei Informationsquellen gleichzeitig: </p><br><ol><li>  Schlie√üe den Garbage Collector-Kurs in Russisch ab: CLRium # 6 ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">aktueller Workshop hier</a> ) </li><li>  √úbersetzung eines Artikels aus BOTR "Garbage Collector Device" von Maoni Stevens. </li></ol><br><p><img src="https://habrastorage.org/webt/q2/r5/db/q2r5dbgih_azfbdvqe1dxcxsgp8.jpeg"></p><a name="habracut"></a><br><h2 id="1-clrium-5-polnyy-kurs-po-garbage-collector">  1. CLRium Nr. 5: Schlie√üen Sie den Garbage Collector-Kurs ab </h2><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/gx/ef/-t/gxef-ta_pk2ywxouxlgj8zjhhra.png"></a> </p><br><h2 id="2-ustroystvo-sborschika-musora-by-maoni-stephens-maoni0httpsgithubcommaoni0">  2. Garbage Collector Device von Maoni Stephens ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">@ maoni0</a> ) </h2><br><p>  Hinweis: Weitere Informationen zur Garbage Collection im Allgemeinen finden Sie im <em>Garbage Collection-Handbuch</em> .  Spezielle Informationen zum Garbage Collector in der CLR finden Sie im Buch <em>Pro .NET Memory Management</em> .  Links zu beiden Ressourcen finden Sie am Ende des Dokuments. </p><br><h3 id="arhitektura-komponentov">  Komponentenarchitektur </h3><br><p>  Die Speicherbereinigung ist mit zwei Komponenten verbunden: einem Spender und einem Sammler.  Der Allokator ist daf√ºr verantwortlich, Speicher zuzuweisen und gegebenenfalls den Kollektor aufzurufen.  Der Kollektor sammelt M√ºll oder Speicher von Objekten, die vom Programm nicht mehr verwendet werden. </p><br><p>  Es gibt andere M√∂glichkeiten, den Kollektor beispielsweise manuell mit GC.Collect aufzurufen.  Au√üerdem erh√§lt der Finalizer-Thread m√∂glicherweise eine asynchrone Benachrichtigung, dass der Speicher knapp wird (was den Kollektor verursacht). </p><br><h3 id="ustroystvo-raspredelitelya">  Verteilerger√§t </h3><br><p>  Der Verteiler wird von Hilfskomponenten der Laufzeit mit folgenden Informationen aufgerufen: </p><br><ul><li>  die erforderliche Gr√∂√üe des zugewiesenen Grundst√ºcks; </li><li>  Kontext der Speicherzuweisung f√ºr den Ausf√ºhrungsthread; </li><li>  Flags, die beispielsweise angeben, ob das Objekt finalisierbar ist. </li></ul><br><p>  Der Garbage Collector bietet keine speziellen Verarbeitungsmethoden f√ºr verschiedene Objekttypen.  Es erh√§lt Informationen zur Gr√∂√üe des Objekts aus der Laufzeit. </p><br><p>  Je nach Gr√∂√üe unterteilt der Kollektor Objekte in zwei Kategorien: klein (&lt;85.000 Byte) und gro√ü (&gt; = 85.000 Byte).  Im Allgemeinen kann die Montage kleiner und gro√üer Objekte auf die gleiche Weise erfolgen.  Der Kollektor trennt sie jedoch nach Gr√∂√üe, da das Komprimieren gro√üer Objekte viele Ressourcen erfordert. </p><br><p>  Der Garbage Collector weist dem Allokator basierend auf den Zuordnungskontexten Speicher zu.  Die Gr√∂√üe des Zuordnungskontexts wird durch die Bl√∂cke des zugewiesenen Speichers bestimmt. </p><br><ul><li><p>  <strong>Auswahlkontexte</strong> sind kleine Bereiche eines bestimmten Heap-Segments, von denen jeder f√ºr einen bestimmten Ausf√ºhrungsfluss vorgesehen ist.  Auf einer Maschine mit einem Prozessor (dh 1 logischer Prozessor) wird ein einzelner Speicherzuordnungskontext f√ºr Objekte der Generation 0 verwendet. </p><br></li><li><p>  <strong>Block des zugewiesenen Speichers</strong> - Die vom Zuweiser jedes Mal zugewiesene Speichermenge, wenn mehr Speicher ben√∂tigt wird, um ein Objekt innerhalb des Bereichs zu positionieren.  Die Blockgr√∂√üe betr√§gt normalerweise 8 KB und die durchschnittliche Gr√∂√üe verwalteter Objekte betr√§gt 35 Byte.  Daher k√∂nnen Sie in einem Block viele Objekte platzieren. </p><br></li></ul><br><p>  Gro√üe Objekte verwenden keine Kontexte und Bl√∂cke.  Ein gro√ües Objekt kann gr√∂√üer sein als diese kleinen Speicherst√ºcke.  Dar√ºber hinaus zeigen sich die Vorteile der Verwendung dieser Bereiche (siehe unten) nur bei der Arbeit mit kleinen Objekten.  Der Platz f√ºr gro√üe Objekte wird direkt im Heap-Segment zugewiesen. </p><br><p>  Der Verteiler ist so ausgelegt, dass: </p><br><ul><li><p> <strong>Rufen Sie bei Bedarf den Garbage Collector auf: Der</strong> Allokator ruft den Kollektor auf, wenn die f√ºr Objekte zugewiesene Speichermenge den vom Kollektor festgelegten Schwellenwert √ºberschreitet oder wenn der Allokator in diesem Segment keinen Speicher mehr zuordnen kann.  Schwellenwerte und kontrollierte Segmente werden sp√§ter ausf√ºhrlich beschrieben. </p><br></li><li><p>  <strong>Speicherort von Objekten speichern:</strong> Objekte, die sich zusammen in einem Segment des Heaps befinden, werden an nahe beieinander liegenden virtuellen Adressen gespeichert. </p><br></li><li><p>  <strong>Verwenden Sie den Cache effizient: Der</strong> Allokator reserviert Speicher in <em>Bl√∂cken</em> und nicht f√ºr jedes Objekt.  Es wird so viel Speicher auf Null gesetzt, um den Prozessor-Cache vorzubereiten, da einige Objekte direkt darin platziert werden.  Der Block des zugewiesenen Speichers betr√§gt normalerweise 8 KB. </p><br></li><li><p>  <strong>Begrenzen Sie effektiv den dem Ausf√ºhrungsthread zugewiesenen Bereich: Die</strong> N√§he der dem Thread zugewiesenen Kontexte und Speicherbl√∂cke stellt sicher, dass nur ein Thread Daten in den zugewiesenen Speicherplatz schreibt.  Infolgedessen muss die Speicherzuweisung nicht eingeschr√§nkt werden, bis der Speicherplatz im aktuellen Zuordnungskontext beendet ist. </p><br></li><li><p>  <strong>Sicherstellen der Speicherintegrit√§t:</strong> Der Garbage Collector setzt den Speicher f√ºr neu zugewiesene Objekte immer zur√ºck, damit ihre Verkn√ºpfungen nicht auf beliebige Speicherabschnitte verweisen. </p><br></li><li><p>  <strong>Heap-Kontinuit√§t sicherstellen: Der</strong> Allokator erstellt aus dem verbleibenden Speicher in jedem zugewiesenen Block ein freies Objekt.  Wenn beispielsweise 30 Bytes im Block verbleiben und 40 Bytes erforderlich sind, um das n√§chste Objekt aufzunehmen, wandelt der Allokator diese 30 Bytes in ein freies Objekt um und fordert einen neuen Speicherblock an. </p><br></li></ul><br><h2>  API </h2><br><pre><code class="plaintext hljs">Object* GCHeap::Alloc(size_t size,  DWORD); Object* GCHeap::Alloc(alloc_context* acontext, size_t size,  DWORD);</code> </pre> <br><p>  Mit diesen Funktionen k√∂nnen Sie Speicher f√ºr kleine und gro√üe Objekte zuweisen.  Es gibt eine Funktion zum Zuweisen von Speicherplatz direkt auf dem Haufen gro√üer Objekte (LOH): </p><br><pre> <code class="plaintext hljs"> Object* GCHeap::AllocLHeap(size_t size,  DWORD);</code> </pre> <br><h3 id="ustroystvo-sborschika">  Sammelvorrichtung </h3><br><h4 id="zadachi-sborschika-musora">  Garbage Collector-Aufgaben </h4><br><p>  GC ist f√ºr eine effiziente Speicherverwaltung ausgelegt.  Entwickler, die verwalteten Code schreiben, k√∂nnen ihn ohne gro√üen Aufwand verwenden.  Gute Regierungsf√ºhrung bedeutet: </p><br><ul><li>  Die Speicherbereinigung sollte h√§ufig genug erfolgen, um den verwalteten Heap nicht mit einer gro√üen Anzahl (nach Verh√§ltnis oder in absoluter Menge) nicht verwendeter Objekte (Speicher) zu verschmutzen, f√ºr die Speicher zugewiesen ist. </li><li>  Die Speicherbereinigung sollte so selten wie m√∂glich erfolgen, um keine n√ºtzliche Prozessorzeit zu verschwenden, obwohl eine h√§ufigere Erfassung weniger Speicherbedarf erm√∂glicht. </li><li>  Die Speicherbereinigung sollte produktiv sein, denn wenn als Ergebnis der Assembly nur ein kleines St√ºck Speicher freigegeben wurde, waren sowohl die Assembly als auch die aufgewendete Prozessorzeit vergebens. </li><li>  Die Speicherbereinigung sollte schnell erfolgen, da viele Workloads eine kurze Verz√∂gerungszeit erfordern. </li><li>  Entwickler, die verwalteten Code schreiben, m√ºssen nicht viel √ºber die Speicherbereinigung wissen, um eine effiziente Speichernutzung (im Vergleich zu ihrer Arbeitslast) zu erreichen. </li><li>  Der Garbage Collector muss sich an die unterschiedliche Art der Speichernutzung anpassen. </li></ul><br><h4 id="logicheskoe-opisanie-upravlyaemoy-kuchi">  Logische Beschreibung des verwalteten Heaps </h4><br><p>  Der CLR-Garbage Collector sammelt Objekte, die nach Generierung logisch getrennt sind.  Nach dem Zusammenstellen von Objekten in Generation <em>N</em> werden die verbleibenden Objekte als zur Generation <em>N + 1</em> geh√∂rend markiert.  Dieser Prozess wird als F√∂rderung von Objekten √ºber Generationen hinweg bezeichnet.  Es gibt Ausnahmen in diesem Prozess, wenn es notwendig ist, ein Objekt an eine niedrigere Generation zu √ºbertragen oder es √ºberhaupt nicht voranzutreiben. </p><br><p>  Bei kleinen Objekten ist der Haufen in drei Generationen unterteilt: gen0, gen1 und gen2.  F√ºr gro√üe Objekte gibt es nur eine Generation - gen3.  Gen0 und Gen1 werden als kurzlebige Generationen bezeichnet (Objekte leben f√ºr kurze Zeit in ihnen). </p><br><p>  F√ºr eine Reihe kleiner Objekte bedeutet die Generationsnummer ihr Alter.  Zum Beispiel ist gen0 die j√ºngste Generation.  Dies bedeutet nicht, dass alle Objekte in gen0 j√ºnger sind als Objekte in gen1 oder gen2.  Es gibt Ausnahmen, die unten beschrieben werden.  Das Zusammenbauen einer Generation bedeutet das Zusammenbauen von Objekten in dieser Generation sowie in all ihren j√ºngeren Generationen. </p><br><p>  Theoretisch kann die Montage von gro√üen und kleinen Objekten auf die gleiche Weise erfolgen.  Da die Komprimierung gro√üer Objekte jedoch viele Ressourcen erfordert, erfolgt ihre Montage auf andere Weise.  Gro√üe Objekte sind nur in gen2 enthalten und werden aus Leistungsgr√ºnden nur w√§hrend der Speicherbereinigung in dieser Generation gesammelt.  Sowohl gen2 als auch gen3 k√∂nnen gro√ü sein, und das Erstellen eines Objekts in kurzlebigen Generationen (gen0 und gen1) sollte nicht zu ressourcenintensiv sein. </p><br><p>  Objekte werden in der j√ºngsten Generation platziert.  F√ºr kleine Objekte ist dies gen0 und f√ºr gro√üe Objekte gen3. </p><br><h4 id="fizicheskoe-opisanie-upravlyaemoy-kuchi">  Physische Beschreibung des verwalteten Heaps </h4><br><p>  Ein verwalteter Heap besteht aus einer Reihe von Segmenten.  Ein Segment ist ein fortlaufender Speicherblock, den das Betriebssystem an den Garbage Collector √ºbergibt.  Heap-Segmente sind in kleine und gro√üe Abschnitte unterteilt, um kleine und gro√üe Objekte aufzunehmen.  Die Segmente jedes Heaps sind miteinander verbunden.  Beim Laden der CLR ist mindestens ein Segment f√ºr ein kleines Objekt und eines f√ºr ein gro√ües Objekt reserviert. </p><br><p>  In jedem Haufen kleiner Objekte gibt es nur ein kurzlebiges Segment, in dem sich die Generationen gen0 und gen1 befinden.  Dieses Segment kann Objekte zur Generierung von Gen2 enthalten oder nicht.  Zus√§tzlich zu den kurzlebigen Segmenten k√∂nnen ein oder mehrere zus√§tzliche Segmente existieren, die Gen2-Segmente sein werden, da sie Objekte der Generation 2 enthalten. </p><br><p>  Ein Stapel gro√üer Objekte besteht aus einem oder mehreren Segmenten. </p><br><p>  Das Heap-Segment wird von niedrigeren zu h√∂heren Adressen gef√ºllt.  Dies bedeutet, dass Objekte an den unteren Adressen des Segments √§lter sind als Objekte am Senior.  Es gibt auch Ausnahmen, die unten beschrieben werden. </p><br><p>  Heap-Segmente werden nach Bedarf zugewiesen.  Wenn sie keine verwendeten Objekte enthalten, werden Segmente gel√∂scht.  Das anf√§ngliche Segment auf dem Heap ist jedoch immer vorhanden.  F√ºr jeden Heap wird jeweils ein Segment zugewiesen.  Bei kleinen Objekten geschieht dies w√§hrend der Speicherbereinigung und bei gro√üen Objekten w√§hrend der Speicherzuweisung f√ºr sie.  Ein solches Schema erh√∂ht die Produktivit√§t, da gro√üe Objekte nur in Generation 2 zusammengesetzt werden (was viele Ressourcen erfordert). </p><br><p>  Heap-Segmente werden in Auswahlen zusammengef√ºgt.  Das letzte Segment in der Kette ist immer kurzlebig.  Segmente, in denen alle Objekte gesammelt werden, k√∂nnen beispielsweise als kurzlebig wiederverwendet werden.  Die Wiederverwendung von Segmenten gilt nur f√ºr Haufen kleiner Objekte.  Jedes Mal gro√üe Objekte aufnehmen, wenn die gesamte Gruppe gro√üer Objekte ber√ºcksichtigt wird.  Kleine Objekte werden nur in kurzlebigen Segmenten platziert. </p><br><h4 id="porogovoe-znachenie-obyoma-vydelennoy-pamyati">  Schwellenwert des zugewiesenen Speichers </h4><br><p>  Dies ist ein logisches Konzept, das sich auf die Gr√∂√üe jeder Generation bezieht.  Wenn es √ºberschritten wird, beginnt die Generierung mit der Speicherbereinigung. </p><br><p>  Der Schwellenwert f√ºr eine bestimmte Generation wird in Abh√§ngigkeit von der Anzahl der √ºberlebenden Objekte in dieser Generation festgelegt.  Wenn dieser Betrag hoch ist, wird der Schwellenwert h√∂her.  Es wird erwartet, dass das Verh√§ltnis von verwendeten und nicht verwendeten Objekten w√§hrend der Garbage Collection-Sitzung der n√§chsten Generation besser ist. </p><br><h2>  Generationsauswahl f√ºr die Speicherbereinigung </h2><br><p>  Bei Aktivierung muss der Kollektor bestimmen, in welcher Generation gebaut werden soll.  Neben dem Schwellenwert beeinflussen weitere Faktoren diese Auswahl: </p><br><ul><li>  Fragmentierung einer Generation - Wenn eine Generation stark fragmentiert ist, ist die darin enthaltene Speicherbereinigung wahrscheinlich produktiv. </li><li>  Wenn der Arbeitsspeicher des Ger√§ts zu voll ist, kann der Kollektor eine gr√ºndlichere Reinigung durchf√ºhren. Wenn durch eine solche Bereinigung mit gr√∂√üerer Wahrscheinlichkeit Speicherplatz frei wird und unn√∂tiger Seitenwechsel vermieden wird (Speicher im gesamten Computer). </li><li>  Wenn einem kurzlebigen Segment der Speicherplatz ausgeht, kann der Kollektor eine gr√ºndlichere Reinigung in diesem Segment durchf√ºhren (mehr Objekte der Generation 1 sammeln), um die Zuweisung eines neuen Heap-Segments zu vermeiden. </li></ul><br><h3 id="process-sborki-musora">  Speicherbereinigungsprozess </h3><br><h4 id="etap-markirovki">  Markierungsphase </h4><br><p>  W√§hrend dieser Phase sollte die CLR alle lebenden Objekte finden. </p><br><p>  Der Vorteil eines Sammlers mit Unterst√ºtzung von Generationen ist seine F√§higkeit, M√ºll nur in einem Teil des Haufens zu reinigen, anstatt st√§ndig alle Objekte zu beobachten.  Beim Sammeln von M√ºll in kurzlebigen Generationen sollte der Kollektor von der Laufzeitumgebung Informationen dar√ºber erhalten, welche Objekte in diesen Generationen noch vom Programm verwendet werden.  Dar√ºber hinaus k√∂nnen Objekte in √§lteren Generationen Objekte in j√ºngeren Generationen verwenden und sich auf diese beziehen. </p><br><p>  Um alte Objekte zu markieren, die auf neue verweisen, verwendet der Garbage Collector spezielle Bits.  Bits werden vom JIT-Compiler-Mechanismus w√§hrend Zuweisungsvorg√§ngen gesetzt.  Wenn das Objekt zur kurzlebigen Erzeugung geh√∂rt, setzt der JIT-Compiler das Byte, das das Bit enth√§lt, das die Anfangsposition angibt.  Beim Sammeln von M√ºll in kurzlebigen Generationen kann der Kollektor diese Bits f√ºr den gesamten verbleibenden Heap verwenden und nur die Objekte anzeigen, denen diese Bits entsprechen. </p><br><h4 id="etap-planirovaniya">  Planungsphase </h4><br><p>  Zu diesem Zeitpunkt wird die Komprimierung modelliert, um ihre Wirksamkeit zu bestimmen.  Wenn das Ergebnis produktiv ist, beginnt der Kollektor mit der eigentlichen Komprimierung.  Ansonsten macht er nur die Reinigung. </p><br><h4 id="etap-peremescheniya">  B√ºhne bewegen </h4><br><p>  Wenn der Kollektor eine Komprimierung durchf√ºhrt, werden die Objekte verschoben.  In diesem Fall m√ºssen Sie die Links zu diesen Objekten aktualisieren.  W√§hrend der Verschiebungsphase muss der Kollektor alle Verkn√ºpfungen finden, die auf Objekte in den Generationen verweisen, in denen die Speicherbereinigung stattfindet.  Im Gegensatz dazu markiert der Kollektor w√§hrend der Markierungsphase nur lebende Objekte, sodass er keine schwachen Glieder ber√ºcksichtigen muss. </p><br><h4 id="etap-szhatiya">  Kompressionsstufe </h4><br><p>  Diese Phase ist recht einfach, da der Sammler bereits in der Planungsphase neue Adressen f√ºr sich bewegende Objekte festgelegt hat.  Beim Komprimieren werden Objekte an diese Adressen kopiert. </p><br><h4 id="etap-uborki">  Reinigungsphase </h4><br><p>  W√§hrend dieser Phase sucht der Sammler nach ungenutztem Raum zwischen lebenden Objekten.  Anstelle dieses Raumes schafft er freie Objekte.  Nicht verwendete Objekte in der N√§he werden zu einem freien Objekt.  Alle freien Objekte werden in die <em>Liste der freien Objekte aufgenommen</em> . </p><br><h3 id="code-flow">  Code-Fluss </h3><br><p>  Bedingungen: </p><br><ul><li>  <strong>WKS GC:</strong> Garbage Collection im Workstation-Modus </li><li>  <strong>SVR GC:</strong> Garbage Collection im Servermodus </li></ul><br><h4 id="funkcionalnoe-povedenie">  Funktionsverhalten </h4><br><h5 id="wks-gc-bez-parallelnoy-sborki-musora">  WKS GC ohne parallele Speicherbereinigung </h5><br><ol><li>  Der Benutzer-Thread verwendet den gesamten ihm zugewiesenen Speicher und ruft den Garbage Collector auf. </li><li>  Der Collector ruft <code>SuspendEE</code> auf, um alle verwalteten Threads <code>SuspendEE</code> . </li><li>  Der Sammler w√§hlt eine Generation zur Reinigung. </li><li>  Das Markieren von Objekten beginnt. </li><li>  Der Kollektor geht in die Planungsphase und bestimmt den Komprimierungsbedarf. </li><li>  Bei Bedarf verschiebt der Kollektor Objekte und f√ºhrt eine Komprimierung durch.  In einem anderen Fall wird nur die Reinigung durchgef√ºhrt. </li><li>  Der Collector ruft <code>RestartEE</code> auf, um die verwalteten Threads <code>RestartEE</code> zu starten. </li><li>  Benutzer-Threads funktionieren weiterhin. </li></ol><br><h5 id="wks-gc-s-parallelnoy-sborkoy-musora">  WKS GC mit paralleler Speicherbereinigung </h5><br><p>  Dieser Algorithmus beschreibt die Speicherbereinigung im Hintergrund. </p><br><ol><li>  Der Benutzer-Thread verwendet den gesamten ihm zugewiesenen Speicher und ruft den Garbage Collector auf. </li><li>  Der Collector ruft <code>SuspendEE</code> auf, um alle verwalteten Threads <code>SuspendEE</code> . </li><li>  Der Kollektor bestimmt, ob die Hintergrund-Garbage Collection ausgef√ºhrt werden soll. </li><li>  In diesem Fall wird der Hintergrund-Garbage-Collection-Thread aktiviert.  Dieser Thread ruft <code>RestartEE</code> auf, um verwaltete Threads <code>RestartEE</code> . </li><li>  Die Speicherzuweisung f√ºr verwaltete Prozesse wird gleichzeitig mit der Hintergrundbereinigung fortgesetzt. </li><li>  Ein Benutzer-Thread kann den gesamten ihm zugewiesenen Speicher verwenden und die kurzlebige Speicherbereinigung (auch als Speicherbereinigung mit hoher Priorit√§t bezeichnet) starten.  Es l√§uft genauso wie im Workstation-Modus ohne parallele Garbage Collection. </li><li>  Der Hintergrund-Garbage-Collection- <code>SuspendEE</code> ruft <code>SuspendEE</code> erneut auf, um die Markierung abzuschlie√üen, und ruft dann <code>RestartEE</code> auf, um eine parallele Bereinigung mit laufenden Benutzerthreads zu starten. </li><li>  Die Hintergrund-Speicherbereinigung ist abgeschlossen. </li></ol><br><h5 id="svr-gc-bez-parallelnoy-sborki-musora">  SVR GC ohne parallele Speicherbereinigung </h5><br><ol><li>  Der Benutzer-Thread verwendet den gesamten ihm zugewiesenen Speicher und ruft den Garbage Collector auf. </li><li>  Garbage Collection-Threads im <code>SuspendEE</code> werden aktiviert und bewirken, dass <code>SuspendEE</code> die Ausf√ºhrung verwalteter Threads <code>SuspendEE</code> . </li><li>  Garbage Collection-Streams f√ºhren im Servermodus dieselben Vorg√§nge wie im Workstation-Modus ohne parallele Garbage Collection aus. </li><li>  Garbage Collection-Threads im <code>RestartEE</code> rufen <code>RestartEE</code> auf, um verwaltete Threads zu starten. </li><li>  Benutzer-Threads funktionieren weiterhin. </li></ol><br><h5 id="svr-gc-s-parallelnoy-sborkoy-musora">  SVR GC mit paralleler Speicherbereinigung </h5><br><p>  Der Algorithmus ist der gleiche wie bei der parallelen Speicherbereinigung im Workstation-Modus. In Server-Threads wird nur die Nicht-Phonon-Erfassung durchgef√ºhrt. </p><br><h2 id="fizicheskaya-arhitektura">  Physische Architektur </h2><br><p>  Dieser Abschnitt hilft Ihnen beim Verst√§ndnis des Codeflusses. </p><br><p>  Wenn dem Benutzer-Thread der Speicherplatz ausgeht, kann er mithilfe der Funktion <code>try_allocate_more_space</code> freien Speicherplatz <code>try_allocate_more_space</code> . </p><br><p>  Die Funktion <code>try_allocate_more_space</code> ruft <code>GarbageCollectGeneration</code> wenn Sie den Garbage Collector starten m√ºssen. </p><br><p>  Wenn die Garbage Collection im Workstation-Modus nicht parallel ist, wird <code>GarbageCollectGeneration</code> in dem vom Garbage Collector aufgerufenen Benutzer-Thread ausgef√ºhrt.  Der Codestream lautet wie folgt: </p><br><pre> <code class="plaintext hljs"> GarbageCollectGeneration() { SuspendEE(); garbage_collect(); RestartEE(); } garbage_collect() { generation_to_condemn(); gc1(); } gc1() { mark_phase(); plan_phase(); } plan_phase() { //   ,   //    if (compact) { relocate_phase(); compact_phase(); } else make_free_lists(); }</code> </pre> <br><p>  Wenn die parallele Speicherbereinigung im Workstation-Modus (standardm√§√üig) ausgef√ºhrt wird, sieht der Code-Fluss f√ºr die Hintergrund-Speicherbereinigung folgenderma√üen aus: </p><br><pre> <code class="plaintext hljs"> GarbageCollectGeneration() { SuspendEE(); garbage_collect(); RestartEE(); } garbage_collect() { generation_to_condemn(); //     //      do_background_gc(); } do_background_gc() { init_background_gc(); start_c_gc (); //           . wait_to_proceed(); } bgc_thread_function() { while (1) { //    //  gc1(); } } gc1() { background_mark_phase(); background_sweep(); }</code> </pre> <br><h1>  Ressourcen-Links </h1><br><ul><li>  <a href="">.NET CLR GC-Implementierung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Das Garbage Collection Handbook: Die Kunst der automatischen Speicherverwaltung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">M√ºllabfuhr (Wikipedia)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pro .NET Speicherverwaltung</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de463293/">https://habr.com/ru/post/de463293/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de463279/index.html">PHP Digest Nr. 162 (1. - 12. August 2019)</a></li>
<li><a href="../de463281/index.html">Warum es bei Google Play nur wenige innovative Anwendungen gibt oder warum Programmieren manchmal magisch ist</a></li>
<li><a href="../de463285/index.html">ShIoTiny: Knoten, Links und Ereignisse oder Funktionen von Zeichenprogrammen</a></li>
<li><a href="../de463289/index.html">Diskrete Mathematik f√ºr WMS: Clustering von Lagerbest√§nden</a></li>
<li><a href="../de463291/index.html">W√ºrfel oder Knochen</a></li>
<li><a href="../de463295/index.html">C ++ und CMake - Brothers Forever, Teil II</a></li>
<li><a href="../de463297/index.html">Loyalit√§t nach Ihrem Geschmack</a></li>
<li><a href="../de463299/index.html">Tipps und Tricks von Kubernetes: So steigern Sie die Produktivit√§t</a></li>
<li><a href="../de463301/index.html">Gonkey - Microservice Testing Tool</a></li>
<li><a href="../de463303/index.html">Facebook h√∂rt schlie√ülich auf, Anzeigen f√ºr Telefonnummern zu schalten, die f√ºr 2FA eingegeben werden</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>