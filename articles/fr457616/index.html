<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👵🏾 🥌 🧑🏻‍🤝‍🧑🏻 Mon "Wow, je ne savais pas ça!" moments avec plaisanterie 🦗 🚕 👨🏻‍🎓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour à tous! Le cours de développeur JavaScript démarre ce jeudi. À cet égard, nous avons décidé de partager la traduction d'un autre matériel inté...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mon "Wow, je ne savais pas ça!" moments avec plaisanterie</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/457616/">  Bonjour à tous!  Le cours de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">développeur JavaScript</a> démarre ce jeudi.  À cet égard, nous avons décidé de partager la traduction d'un autre matériel intéressant.  Bonne lecture. <br><br><img src="https://habrastorage.org/webt/nj/it/db/njitdbm66p75yhokzwoeudcnti8.png"><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Jest</a> a toujours été mon outil de test unitaire indispensable.  Il est tellement fiable que je commence à penser que je l'ai toujours sous-utilisé.  Bien que les tests aient fonctionné, au fil du temps, je les ai refaçonnés ici et là, car je ne savais pas que Jest pouvait le faire.  A chaque fois c'est un nouveau code quand je vérifie la documentation Jest. <a name="habracut"></a><br><br>  Donc, je vais partager quelques-unes de mes astuces Jest préférées que certains d'entre vous connaissent peut-être déjà parce que vous lisez la documentation et que vous ne m'aimez pas (honte), mais j'espère que cela aidera ceux qui viennent de la parcourir rapidement ! <br><br>  Soit dit en passant, j'utilise Jest v24.8.0 comme matériel de référence, alors faites attention, certaines choses peuvent ne pas fonctionner avec la version de Jest que vous utilisez actuellement.  De plus, les exemples ne représentent pas le code de test réel, ce n'est qu'une démonstration. <br><br><h2>  # 1  .toBe vs .toEqual </h2><br>  Au début, toutes ces déclarations me semblaient normales: <br><br><pre><code class="javascript hljs">expect(<span class="hljs-string"><span class="hljs-string">'foo'</span></span>).toEqual(<span class="hljs-string"><span class="hljs-string">'foo'</span></span>) expect(<span class="hljs-number"><span class="hljs-number">1</span></span>).toEqual(<span class="hljs-number"><span class="hljs-number">1</span></span>) expect([<span class="hljs-string"><span class="hljs-string">'foo'</span></span>]).toEqual([<span class="hljs-string"><span class="hljs-string">'foo'</span></span>])</code> </pre> <br>  Basé sur l'utilisation de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">chai</a> pour les déclarations d'égalité (to.equal), cela est tout à fait naturel.  En fait, Jest ne se plaindra pas, et ces déclarations passent comme d'habitude. <br><br>  Cependant, Jest a .toBe et .toEqual.  Le premier est utilisé pour affirmer l'égalité à l'aide d' <a href="">Object.is</a> , et le second est de fournir une comparaison approfondie des objets et des tableaux.  .toEqual a un recours à <a href="">Object.is</a> s'il s'avère que vous n'avez pas besoin d'une comparaison approfondie, comme affirmer des égalités pour des valeurs primitives, ce qui explique pourquoi l'exemple précédent s'est très bien passé. <br><br><pre> <code class="javascript hljs">expect(<span class="hljs-string"><span class="hljs-string">'foo'</span></span>).toBe(<span class="hljs-string"><span class="hljs-string">'foo'</span></span>) expect(<span class="hljs-number"><span class="hljs-number">1</span></span>).toBe(<span class="hljs-number"><span class="hljs-number">1</span></span>) expect([<span class="hljs-string"><span class="hljs-string">'foo'</span></span>]).toEqual([<span class="hljs-string"><span class="hljs-string">'foo'</span></span>])</code> </pre> <br>  De cette façon, vous pouvez ignorer tous les <code>if-else</code> dans <code>.toEqual</code> utilisant <code>.toBe</code> si vous savez déjà quelles valeurs vous testez. <br>  Une erreur courante est que vous utiliserez <code>.toBe</code> pour affirmer l'égalité des valeurs primitives. <br><br><pre> <code class="javascript hljs">expect([<span class="hljs-string"><span class="hljs-string">'foo'</span></span>]).toBe([<span class="hljs-string"><span class="hljs-string">'foo'</span></span>])</code> </pre> <br>  Si vous regardez le <a href="">code source</a> lorsque .toBe se bloque, il essaiera de déterminer si vous avez vraiment fait cette erreur en <a href="">appelant la fonction</a> utilisée par .toEqual.  Cela peut être un goulot d'étranglement lors de l'optimisation de votre test. <br><br>  Si vous êtes sûr d'utiliser des valeurs primitives, votre code peut être réorganisé comme tel à des fins d'optimisation: <br><br><pre> <code class="javascript hljs">expect(<span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.is(<span class="hljs-string"><span class="hljs-string">'foo'</span></span>, <span class="hljs-string"><span class="hljs-string">'foo'</span></span>)).toBe(<span class="hljs-literal"><span class="hljs-literal">true</span></span>)</code> </pre> <br>  Plus de détails dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation</a> . <br><br><h2>  # 2  Des comparaisons plus adaptées </h2><br>  Techniquement, vous pouvez utiliser <code>.toBe</code> pour valider toutes les valeurs.  Avec Jest, vous pouvez utiliser spécifiquement certains outils de comparaison pour rendre votre test plus lisible (et dans certains cas plus court). <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// expect([1,2,3].length).toBe(3) // expect([1,2,3]).toHaveLength(3) const canBeUndefined = foo() // expect(typeof canBeUndefined !== 'undefined').toBe(true) // expect(typeof canBeUndefined).not.toBe('undefined') // expect(canBeUndefined).not.toBe(undefined) // expect(canBeUndefined).toBeDefined() class Foo { constructor(param) { this.param = param } // expect(new Foo('bar') instanceof Foo).toBe(true) // expect(new Foo('bar')).toBeInstanceOf(Foo)</span></span></code> </pre> <br>  Ce ne sont que quelques-uns de ceux que j'ai sélectionnés dans la longue liste de compilateurs Jest dans la documentation, vous pouvez jeter un œil au reste vous-même. <br><br><h2>  # 3  Test d'instantanés sur des éléments sans interface utilisateur </h2><br>  Vous avez peut-être entendu parler du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">test d'instantanés dans Jest</a> , où il permet de suivre les modifications apportées aux éléments de votre interface utilisateur.  Mais les tests avec des instantanés ne se limitent pas à cela. <br><br>  Considérez cet exemple: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> allEmployees = getEmployees() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> happyEmployees = giveIncrementByPosition(allEmployees) expect(happyEmployees[<span class="hljs-number"><span class="hljs-number">0</span></span>].nextMonthPaycheck).toBe(<span class="hljs-number"><span class="hljs-number">1000</span></span>) expect(happyEmployees[<span class="hljs-number"><span class="hljs-number">1</span></span>].nextMonthPaycheck).toBe(<span class="hljs-number"><span class="hljs-number">5000</span></span>) expect(happyEmployees[<span class="hljs-number"><span class="hljs-number">2</span></span>].nextMonthPaycheck).toBe(<span class="hljs-number"><span class="hljs-number">4000</span></span>) <span class="hljs-comment"><span class="hljs-comment">// ...etc</span></span></code> </pre> <br>  Ce serait fatigant si vous réclamiez de plus en plus d'employés.  De plus, s'il s'avère que plus de demandes sont nécessaires pour chaque employé, multipliez le nombre de nouvelles demandes par le nombre d'employés et vous aurez une idée. <br>  Avec le test d'instantané, tout cela peut être fait simplement comme ceci: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> allEmployees = getEmployees() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> happyEmployees = giveIncrementByPosition(allEmployees) expect(happyEmployees).toMatchSnapshot()</code> </pre> <br>  Chaque fois que des régressions se produisent, vous saurez exactement quel arbre dans le nœud ne correspond pas à l'image. <br><br>  Mais la commodité a un prix: cette méthode est plus sujette aux erreurs.  Il est possible que vous ne sachiez pas que l'image est en fait incorrecte, et à la fin vous la prendrez quand même.  Vérifiez donc votre instantané comme s'il s'agissait de votre propre code d'approbation (car il l'est). <br><br>  Bien sûr, les tests ne se limitent pas aux instantanés.  Lisez la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation</a> complète. <br><br><h2>  # 4  decrire.chaque et test.chaque </h2><br>  Avez-vous déjà passé un test quelque peu similaire à celui-ci? <br><br><pre> <code class="javascript hljs">describe(<span class="hljs-string"><span class="hljs-string">'When I am a supervisor'</span></span>, () =&gt; { test(<span class="hljs-string"><span class="hljs-string">'I should have a supervisor badge'</span></span>, () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> employee = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Employee({ <span class="hljs-attr"><span class="hljs-attr">level</span></span>: <span class="hljs-string"><span class="hljs-string">'supervisor'</span></span> }) expect(employee.badges).toContain(<span class="hljs-string"><span class="hljs-string">'badge-supervisor'</span></span>) }) test(<span class="hljs-string"><span class="hljs-string">'I should have a supervisor level'</span></span>, () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> employee = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Employee({ <span class="hljs-attr"><span class="hljs-attr">level</span></span>: <span class="hljs-string"><span class="hljs-string">'supervisor'</span></span> }) expect(employee.level).toBe(<span class="hljs-string"><span class="hljs-string">'supervisor'</span></span>) }) }) describe(<span class="hljs-string"><span class="hljs-string">'When I am a manager'</span></span>, () =&gt; { test(<span class="hljs-string"><span class="hljs-string">'I should have a manager badge'</span></span>, () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> employee = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Employee({ <span class="hljs-attr"><span class="hljs-attr">level</span></span>: <span class="hljs-string"><span class="hljs-string">'manager'</span></span> }) expect(employee.badges).toContain(<span class="hljs-string"><span class="hljs-string">'badge-manager'</span></span>) }) test(<span class="hljs-string"><span class="hljs-string">'I should have a manager level'</span></span>, () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> employee = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Employee({ <span class="hljs-attr"><span class="hljs-attr">level</span></span>: <span class="hljs-string"><span class="hljs-string">'manager'</span></span> }) expect(employee.level).toBe(<span class="hljs-string"><span class="hljs-string">'manager'</span></span>) }) })</code> </pre> <br>  C'est monotone et routinier, non?  Imaginez faire cela avec beaucoup de cas. <br>  Avec <code>description.each</code> et <code>test.each</code> vous pouvez compresser le code comme suit: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> levels = [[<span class="hljs-string"><span class="hljs-string">'manager'</span></span>], [<span class="hljs-string"><span class="hljs-string">'supervisor'</span></span>]] <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> privileges = [[<span class="hljs-string"><span class="hljs-string">'badges'</span></span>, <span class="hljs-string"><span class="hljs-string">'toContain'</span></span>, <span class="hljs-string"><span class="hljs-string">'badge-'</span></span>], [<span class="hljs-string"><span class="hljs-string">'level'</span></span>, <span class="hljs-string"><span class="hljs-string">'toBe'</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>]] describe.each(levels)(<span class="hljs-string"><span class="hljs-string">'When I am a %s'</span></span>, (level) =&gt; { test.each(privileges)(<span class="hljs-string"><span class="hljs-string">`I should have a </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${level}</span></span></span><span class="hljs-string"> %s`</span></span>, (kind, assert, prefix) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> employee = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Employee({ level }) expect(employee[kind])[assert](<span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${prefix}</span></span></span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${level}</span></span></span><span class="hljs-string">`</span></span>) }) })</code> </pre> <br>  Cependant, je n'ai pas encore utilisé cela dans mon propre test, car je préfère que mon test soit détaillé, mais je pensais juste que ce serait une astuce intéressante. <br><br>  Voir la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation</a> pour plus de détails sur les arguments (spoiler: la syntaxe du tableau est vraiment cool). <br><br><h2>  # 5  Imitation unique des fonctions globales </h2><br>  À un moment donné, vous devrez tester quelque chose qui dépend des fonctions globales dans un cas de test particulier.  Par exemple, une fonction qui reçoit des informations sur la date actuelle à l'aide de l'objet javascript Date ou une bibliothèque qui en dépend.  La difficulté est qu'en ce qui concerne la date actuelle, vous ne pouvez jamais obtenir la bonne déclaration. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now() } expect(foo()).toBe(<span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now()) <span class="hljs-comment"><span class="hljs-comment">// This would throw occasionally: // expect(received).toBe(expected) // Object.is equality // // Expected: 1558881400838 // Received: 1558881400837</span></span></code> </pre> <br><br>  En fin de compte, vous devrez redéfinir l'objet Date global afin qu'il soit cohérent et gérable: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now() } <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-number"><span class="hljs-number">1234567890123</span></span> expect(foo()).toBe(<span class="hljs-number"><span class="hljs-number">1234567890123</span></span>) <span class="hljs-comment"><span class="hljs-comment">//</span></span></code> </pre> <br>  Cependant, cela est considéré comme une mauvaise pratique, car la redéfinition est maintenue entre les tests.  Vous ne le remarquerez pas s'il n'y a pas d'autre test basé sur Date.now, mais il fuira aussi. <br><br><pre> <code class="javascript hljs">test(<span class="hljs-string"><span class="hljs-string">'First test'</span></span>, () =&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now() <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-number"><span class="hljs-number">1234567890123</span></span> expect(foo()).toBe(<span class="hljs-number"><span class="hljs-number">1234567890123</span></span>) <span class="hljs-comment"><span class="hljs-comment">// }) test('Second test', () =&gt; { function foo () { return Date.now() expect(foo()).not.toBe(1234567890123) // ??? })</span></span></code> </pre><br>  J'avais l'habitude de le "craquer" pour qu'il ne fuit pas: <br><br><pre> <code class="javascript hljs">test(<span class="hljs-string"><span class="hljs-string">'First test'</span></span>, () =&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> oriDateNow = <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-number"><span class="hljs-number">1234567890123</span></span> expect(foo()).toBe(<span class="hljs-number"><span class="hljs-number">1234567890123</span></span>) <span class="hljs-comment"><span class="hljs-comment">// Date.now = oriDateNow }) test('Second test', () =&gt; { function foo () { return Date.now() expect(foo()).not.toBe(1234567890123) // as expected })</span></span></code> </pre> <br>  Cependant, il existe une manière bien meilleure et moins piratée de procéder: <br><br><pre> <code class="javascript hljs">test(<span class="hljs-string"><span class="hljs-string">'First test'</span></span>, () =&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now() jest.spyOn(<span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>, <span class="hljs-string"><span class="hljs-string">'now'</span></span>).mockImplementationOnce(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-number"><span class="hljs-number">1234567890123</span></span>) expect(foo()).toBe(<span class="hljs-number"><span class="hljs-number">1234567890123</span></span>) <span class="hljs-comment"><span class="hljs-comment">// }) test('Second test', () =&gt; { function foo () { return Date.now() expect(foo()).not.toBe(1234567890123) // as expected })</span></span></code> </pre> <br>  Ainsi, <code>jest.spyOn</code> suit l'objet global Date. Il imite l'implémentation de la fonction now pour un seul appel.  Cela laissera à son tour Date.now intact pour le reste des tests. <br><br>  Il y a certainement plus d'informations sur les talons à Jest.  Voir la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation</a> complète pour plus de détails. <br><br>  Cet article est assez long, donc je pense que c'est tout pour le moment.  Cela n'affecte qu'une petite partie des capacités de Jest, et je souligne juste mes favoris.  Si vous avez d'autres faits intéressants, faites-le moi savoir. <br><br>  De plus, si vous avez souvent utilisé Jest, consultez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Majestic</a> , qui est une interface graphique sans interface graphique pour Jest, une très bonne alternative à la sortie ennuyeuse du terminal.  Je ne sais pas si l'auteur est en dev.to, mais néanmoins du respect pour cette personne. <br><br>  Comme toujours, merci de votre attention! <br><br>  C’est tout.  Rendez-vous sur le parcours. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr457616/">https://habr.com/ru/post/fr457616/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr457606/index.html">Alan Kay: Ce que l'on peut appeler la chose la plus étonnante que les ordinateurs ont rendue possible</a></li>
<li><a href="../fr457608/index.html">Comment visualiser les données dans une histoire captivante</a></li>
<li><a href="../fr457610/index.html">Analyse des vulnérabilités de Evil Parcel</a></li>
<li><a href="../fr457612/index.html">Comment accélérer la décompression LZ4 dans ClickHouse?</a></li>
<li><a href="../fr457614/index.html">Les secrets de la recherche d'un emploi à l'étranger auprès d'un chasseur de têtes en exercice</a></li>
<li><a href="../fr457618/index.html">Être un développeur full-stack moderne</a></li>
<li><a href="../fr457622/index.html">Mesurer les performances Qt</a></li>
<li><a href="../fr457624/index.html">Comment nous avons cassé l'ancienne cabane et construit un gratte-ciel à sa place</a></li>
<li><a href="../fr457626/index.html">Révision des niveaux d'accès utilisateur à l'aide de Power BI à l'aide de l'exemple de Bitrix CMS (BUS)</a></li>
<li><a href="../fr457628/index.html">Programme P2M efficace et gestion de projet</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>