<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ“¬ ğŸ‘¨â€ğŸ‘¨â€ğŸ‘§ ğŸ‘¨ğŸ¼â€ğŸ’» Cuplikan vs Clover - kalahkan kuis waktu-nyata paling populer ğŸˆ¹ â™ï¸ ğŸ•£</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="April 2018. Saya berusia 14 tahun. Teman saya dan saya bermain di kuis online yang sangat populer "Clover" dari VKontakte. Salah satu dari kami (biasa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cuplikan vs Clover - kalahkan kuis waktu-nyata paling populer</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435360/">  April 2018.  Saya berusia 14 tahun. Teman saya dan saya bermain di kuis online yang sangat populer "Clover" dari VKontakte.  Salah satu dari kami (biasanya saya) selalu di belakang laptop untuk mencoba dengan cepat pertanyaan google dan melihat melalui hasil pencarian untuk jawaban yang benar.  Tapi tiba-tiba saya menyadari bahwa saya melakukan hal yang sama setiap waktu, dan memutuskan untuk mencoba menulisnya dengan Python 3, yang sebagian saya kenal saat itu. <br><br><h3>  Langkah 0. Apa yang terjadi di sini? </h3><br>  Untuk memulainya, saya akan menyegarkan kembali ingatan Anda mekanisme "Semanggi". <br><br>  Permainan untuk semua orang dimulai pada waktu yang sama - pukul 13:00 dan 20:00 waktu Moskow.  Untuk bermain, Anda harus masuk ke aplikasi saat ini dan terhubung ke siaran langsung.  Permainan ini berlangsung selama 15 menit, di mana pertanyaan dikirimkan kepada peserta di telepon <b>pada saat yang sama</b> .  Jawabannya adalah <b>10 detik.</b>  Kemudian jawaban yang benar diumumkan.  Semua yang menebak melangkah lebih jauh.  Ada 12 pertanyaan secara total, dan jika Anda menjawab semua, Anda akan menerima hadiah uang tunai. <br><img src="https://habrastorage.org/webt/xg/ef/lg/xgeflg-76ljroqjb56rghhgs9-c.jpeg" alt="gambar"><br>  Ternyata tugas kami adalah menangkap langsung pertanyaan baru dari server Clover, memprosesnya melalui mesin pencari, dan menentukan jawaban yang benar berdasarkan hasil pencarian.  Diputuskan untuk mengeluarkan jawaban dalam bot telegram sehingga pemberitahuan darinya akan muncul di ponsel selama pertandingan.  Dan semua ini diinginkan dalam beberapa detik, karena waktu respons sangat terbatas.  Jika Anda ingin melihat bagaimana kode yang cukup sederhana, tetapi bekerja (dan melihat yang ini akan berguna bagi pemula) membantu kami mengalahkan Clover - selamat datang di cut. <br><a name="habracut"></a><br><h3>  Langkah 1. Dapatkan pertanyaan dari server </h3><br>  Pada awalnya itu tampaknya tahap yang paling sulit.  Saya sudah mengambil napas dalam-dalam dan siap untuk naik ke alam liar seperti visi komputer, mencegat lalu lintas atau mendekompilasi aplikasi ... Ketika tiba-tiba sebuah kejutan menunggu saya - Clover memiliki API terbuka!  Itu tidak didokumentasikan di mana pun, tetapi jika selama pertandingan, segera setelah semua pemain ditanya pertanyaan, buat permintaan di api.vk.com, maka sebagai tanggapan kami akan mendapatkan pertanyaan yang diajukan dan pilihan jawaban di JSON: <br><br><img src="https://habrastorage.org/webt/sa/hv/qr/sahvqrm_nu5aglc9okyzgnkvo2c.png" alt="gambar"><br><br><pre><code class="plaintext hljs">https://api.vk.com/method/execute.getLastQuestion?v=5.5&amp;access_token=VK_USER_TOKEN</code> </pre> <br><br>  Sebagai access_token, perlu untuk mentransfer token API dari setiap pengguna VKontakte, tetapi penting bahwa itu pada awalnya dikeluarkan khusus untuk Clover.  App_id-nya adalah 6334949. <br><br><h3>  Langkah 2. Kami memproses masalah ini melalui mesin pencari </h3><br>  Ada dua opsi: gunakan API mesin pencari resmi atau tambahkan argumen pencarian langsung ke bilah alamat, dan pars hasilnya.  Pada awalnya saya mencoba yang kedua, tetapi saya tidak hanya menangkap captcha, saya juga kehilangan banyak waktu, karena halaman dimuat rata-rata dalam 2 detik.  Dan saya mengingatkan Anda bahwa disarankan untuk bertemu dua detik ini.  Baik dan yang paling penting, saya tidak mendapatkan teks yang besar dan terstruktur dari mesin pencari pada topik yang diperlukan, karena hanya potongan-potongan kecil dari bahan yang diperlukan, yang disebut <b>snippet,</b> bertahan di halaman pencarian: <br><br><img src="https://habrastorage.org/webt/-6/4l/ss/-64lsssqhrx5tfpl0i6atmf_ujq.png"><br><br>  Jadi saya mulai mencari API.  Google tidak cocok - solusi mereka sangat terbatas dan mengembalikan data yang sangat sedikit.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Yandex.XML</a> ternyata yang paling murah hati - memungkinkan Anda mengirim 10.000 permintaan per hari, tidak lebih dari 5 per detik, dan mengembalikan data dengan sangat cepat.  Permintaan untuk itu secara opsional adalah jumlah halaman (hingga 100) dan jumlah bagian - nilai khusus yang digunakan untuk membentuk snippet.  Kami mendapatkan data dalam XML.  Namun, ini semua cuplikan yang sama. <br><br>  Agar Anda dapat membiasakan diri dan bermain dengan apa yang dikembalikan Yandex, berikut adalah contoh jawaban untuk pertanyaan "Apa nama antagonis utama dalam seri video" The Legend of Zelda? ": <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Yandex.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Berkendara</a> . <br><br>  Saya beruntung, dan ternyata di pypi, modul <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pencarian yandex</a> terpisah sudah ada untuk ini.  Maka, saya mencoba mendapatkan pertanyaan dari server, menemukannya di Yandex, membuat satu teks besar dari cuplikan dan memecahnya menjadi kalimat: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> requests <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> req <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> yandex_search <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> json apiurl = <span class="hljs-string"><span class="hljs-string">"https://api.vk.com/method/execute.getLastQuestion?access_token=VK_USER_TOKEN&amp;v=5.5"</span></span> clever_response = (json.loads(req.get(apiurl).content))[<span class="hljs-string"><span class="hljs-string">"response"</span></span>] <span class="hljs-comment"><span class="hljs-comment"># {'text': '          Â«   Â»?', 'answers': [{'id': 0, 'users_answered': 0, 'text': 'Â« Â»'}, {'id': 1, 'users_answered': 0, 'text': 'Â« Â»'}, {'id': 2, 'users_answered': 0, 'text': 'Â«Â»'}], 'stop_time': 0, 'is_first': 0, 'is_last': 1, 'number': 12, 'id': 22, 'sent_time': 1533921436} question = str(clever_response["text"]) ans1, ans2, ans3 = str(clever_response["answers"][0]["text"]).lower(), str(clever_response["answers"][1]["text"]).lower(), str(clever_response["answers"][2]["text"]).lower() def yandexfind(question): finded = yandex.search(question).items snips = "" for i in finded: snips += (i.get("snippet")) + "\n" return snips items = yandexfind(question) itemslist = list(items.split(". "))</span></span></code> </pre> <br><br><h3>  Langkah 3. Mencari jawaban </h3><br>  Pada awalnya, tugas mengenali jawaban secara akurat berdasarkan cuplikan tampaknya tidak realistis bagi saya (saya mengingatkan Anda bahwa pada saat menulis kode, saya adalah pemula mutlak).  Karena itu, saya memutuskan untuk menyederhanakan tugas yang kami lakukan dengan pencarian manual. <br><br>  Apa yang saya dan teman saya lakukan ketika mengarahkan pertanyaan kami ke mesin pencari?  Mereka mulai cepat melihat melalui mata untuk jawaban dalam hasil.  Apa masalah dengan pendekatan ini?  Dalam <s>banyak huruf,</s> ada sejumlah besar yang tidak perlu, tidak mengandung informasi tentang jawaban, proposal.  Mencari dengan mata saya terkadang membutuhkan waktu lama.  Oleh karena itu, hal pertama yang saya putuskan untuk lakukan adalah memilih semua kalimat dengan menyebutkan salah satu jawaban dan menampilkannya sehingga kami akan mencari jawabannya dalam teks yang sangat kecil yang secara akurat berisi informasi yang kami butuhkan. <br><br><pre> <code class="python hljs">hint = [] <span class="hljs-comment"><span class="hljs-comment"># ,      for sentence in itemslist: #     if (ans1 in sentence) or (ans2 in sentence) or (ans3 in sentence): hint.append(sentence) if len(hint) &gt; 4: break</span></span></code> </pre><br><br>  Tampaknya mendapatkan tawaran yang tepat, membacanya dan menjawab dengan benar.  Tetapi bagaimana jika kita tidak menemukan satu kalimat pun?  Dalam hal ini, saya memutuskan untuk memotong kata-kata agar tidak ketinggalan jika ada dalam kasus lain.  Dan juga untuk menangkap yang terbentuk dari sumbernya.  Singkatnya, saya baru saja memotong akhir mereka menjadi dua karakter: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(hint) == <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cut</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(string) &gt; <span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> string[<span class="hljs-number"><span class="hljs-number">0</span></span>:<span class="hljs-number"><span class="hljs-number">-2</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> string short_ans1, short_ans2, short_ans3 = cut(ans1), cut(ans2), cut(ans3) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> pred <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> itemslist: <span class="hljs-comment"><span class="hljs-comment">#     if (short_ans1 in pred) or (short_ans2 in pred) or (short_ans3 in pred) hint.append(pred)</span></span></code> </pre> <br><br>  Tetapi bahkan setelah jaring pengaman seperti itu, masih ada kasus ketika petunjuk tetap kosong, hanya karena hasilnya tidak selalu menyentuh pada jawaban.  Katakan, pada pertanyaan, <i>"Manakah dari penulis ini yang memiliki kisah, yang dinamai seperti lagu dari grup Bi 2?"</i>  tidak ada jawaban pasti yang dapat ditemukan.  Dalam hal ini, saya menggunakan pendekatan yang berlawanan - saya bertanya tentang jawaban dan menyimpulkan opsi berdasarkan seberapa sering kata-kata dari pertanyaan tersebut disebutkan dalam hasil. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(hint) == <span class="hljs-number"><span class="hljs-number">0</span></span>: questionlist = question.split(<span class="hljs-string"><span class="hljs-string">" "</span></span>) blacklist = [<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> w <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> questionlist: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> w <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> blacklist: questionlist.remove(w) yandex_ans1 = yandexfind(ans1) yandex_ans2 = yandexfind(ans2) yandex_ans3 = yandexfind(ans3) <span class="hljs-comment"><span class="hljs-comment">#      ,     count_ans1, count_ans2, count_ans3 = 0, 0, 0 for w in questionlist: count_ans1 += yandex_ans1.count(w) count_ans2 += yandex_ans2.count(w) count_ans3 += yandex_ans3.count(w) if (count_ans1 + count_ans2 + count_ans3) &gt; 5: if count_ans1 &gt; (count_ans2 + count_ans3): print(ans1) elif count_ans2 &gt; (count_ans1 + count_ans3): print(ans2) elif count_ans3 &gt; (count_ans2 + count_ans1): print(ans3)</span></span></code> </pre><br><br>  Pada titik ini, skrip mendapatkan fungsionalitas dasar.  Dan sekarang, hanya satu setengah minggu setelah rilis Clover, kami duduk dan sudah bermain dengan "cheat" buatan sendiri.  Anda seharusnya melihat wajah kami bersama seorang teman ketika kami pertama kali <b>memenangkan permainan</b> dengan membaca saran di baris perintah seolah-olah dengan sihir! <br><br><h3>  Langkah 4. Tampilkan jawaban yang jelas </h3><br>  Namun format ini segera lelah.  Pertama, Anda harus duduk dengan laptop setiap pertandingan.  Kedua, teman-teman saya meminta skrip, dan saya bosan menjelaskan kepada semua orang cara memasukkan token VKontakte mereka, cara mengkonfigurasi Yandex.XML (terkait dengan IP, artinya, perlu membuat akun untuk setiap pengguna skrip) dan cara memasang python di komputer. <br><br>  Akan jauh lebih baik jika jawaban muncul dalam pemberitahuan push di ponsel tepat selama pertandingan!  Hanya melihat bagian atas layar dan menjawab seperti yang tertulis di pemberitahuan push!  Dan Anda dapat mengatur ini untuk semua orang jika Anda membuat saluran telegram Anda untuk skrip!  Luar biasa! <br><br>  Tetapi hanya menampilkan kalimat yang sama di telegram bukanlah suatu pilihan.  Membacanya dari ponsel Anda sangat merepotkan.  Karena itu, saya harus mempelajari naskah sendiri untuk memahami jawaban mana yang benar. <br><br>  Kami mengimpor <b>telebot</b> dan mengubah semua fungsi <b>cetak ()</b> menjadi <b>send_tg ()</b> dan <b>notsure ()</b> , yang akan kami gunakan dalam metode terakhir, karena ia sedikit lebih sering hilang daripada yang lain: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send_tg</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ans)</span></span></span><span class="hljs-function">:</span></span> bot.send_message(<span class="hljs-string"><span class="hljs-string">"@autoclever"</span></span>, str(ans).capitalize()) print(str(ans)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">notsure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ans)</span></span></span><span class="hljs-function">:</span></span> send_tg(ans.capitalize() + <span class="hljs-string"><span class="hljs-string">".  !"</span></span>) hint.append(<span class="hljs-string"><span class="hljs-string">"WE TRIED!"</span></span>)</code> </pre><br><br>  Dan pada saat itu, saya menyadari bahwa cuplikan jauh lebih baik daripada teks panjang!  Karena mesin pencari berusaha sangat keras untuk <b>memberikan jawaban</b> atas permintaan kami, dan tidak hanya menemukan kecocokan dalam kata-kata.  Dan dia berhasil - potongan sering berisi jawaban yang benar daripada yang salah, yaitu, tidak perlu menganalisis teks.  Dan saya, pada kenyataannya, tidak tahu caranya. <br><br>  Jadi kita sederhana untuk menghitung penyebutan kata-kata dalam hasil: <br><br><pre> <code class="python hljs">anscounts = { ans1: <span class="hljs-number"><span class="hljs-number">0</span></span>, ans2: <span class="hljs-number"><span class="hljs-number">0</span></span>, ans3: <span class="hljs-number"><span class="hljs-number">0</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> s <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> hint: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> [ans1, ans2, ans3]: anscounts[a] += s.count(a) right = (max(anscounts, key=anscounts.get)) send_tg(right) <span class="hljs-comment"><span class="hljs-comment">#!</span></span></code> </pre><br><br>  Apa yang terjadi sebagai hasilnya: <br><img src="https://habrastorage.org/webt/0n/h4/gd/0nh4gd2p5ao6up1nrwdzlnlwdss.png" alt="gambar"><br><br><h3>  Nasib selanjutnya </h3><br>  Dalam keadilan, saya harus mengatakan bahwa saya tidak berhasil dalam mesin kematian.  Rata-rata, bot menjawab dengan benar hanya 9-10 dari 12 pertanyaan.  Dapat dimengerti, karena ada orang-orang rumit yang tidak menyerah pada penguraian pencarian Yandex.  Saya, dan teman-teman saya, bosan terus-menerus terbang melewati beberapa pertanyaan dan menunggu permainan yang sukses, di mana bot akhirnya akan menjawab semuanya dengan benar.  Sebuah keajaiban tidak terjadi, saya tidak benar-benar ingin memodifikasi naskah lagi, dan kemudian, setelah berhenti berharap untuk kemenangan yang mudah, kami meninggalkan permainan. <br><br>  Seiring waktu, ide saya mulai merayap ke kepala pengembang muda lainnya.  Menjelang matahari terbenam tahun 2018, setidaknya ada 10 bot dan situs yang menampilkan tebakan mereka tentang masalah di Clover.  Tugasnya tidak begitu sulit.  Tapi yang mengejutkan, tidak ada satu pun dari mereka yang pernah melewati 9-10 pertanyaan per game, dan kemudian semuanya turun menjadi 7-8 sama sekali, seperti bot saya.  Rupanya, para penyusun pertanyaan memperjelas bagaimana menyusun pertanyaan sehingga pekerjaan mesin pencari tidak relevan. <br><br>  Sayangnya, bot tidak dapat diselesaikan lagi, karena pada tanggal 31 Desember Clover menghabiskan siaran terakhir, dan saya tidak memiliki pertanyaan.  Namun, itu adalah pengalaman hebat bagi seorang programmer pemula.  Dan tentunya akan ada tantangan besar untuk yang maju - bayangkan saja duo word2vec dan text2vec, permintaan asinkron ke Yandex, Google dan Wikipedia pada saat yang sama, pengelompokan pertanyaan tingkat lanjut dan algoritme untuk merumuskan kembali pertanyaan jika terjadi kegagalan ... Eh!  Mungkin, untuk kesempatan seperti itu saya lebih menyukai game ini daripada gameplaynya. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id435360/">https://habr.com/ru/post/id435360/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id435346/index.html">Berlangganan Kafka melalui HTTP atau cara menyederhanakan kait web Anda</a></li>
<li><a href="../id435348/index.html">MCerver sederhana - shell kecil untuk server Minecraft</a></li>
<li><a href="../id435352/index.html">Konferensi DEFCON 18. Spionase praktis menggunakan ponsel. Bagian 2</a></li>
<li><a href="../id435354/index.html">Konferensi DEFCON 18. Spionase praktis menggunakan ponsel. Bagian 1</a></li>
<li><a href="../id435358/index.html">Antiquities: Minidisk in the Age of iPod</a></li>
<li><a href="../id435362/index.html">Kecepatan hash</a></li>
<li><a href="../id435364/index.html">Menyesuaikan penyelesaian ketergantungan di Musim Semi</a></li>
<li><a href="../id435368/index.html">Anatomi patologis di tempat kerja</a></li>
<li><a href="../id435372/index.html">Beberapa kata tentang FastPath dan FastTrack di MikroTik</a></li>
<li><a href="../id435374/index.html">Matematika di Gamedev sederhana. Triangulasi dan Triangle.Net di Unity</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>