<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧛🏾 👅 👩🏿‍🤝‍👩🏽 Eine einfache Möglichkeit, mehrere Sprachen hinzuzufügen 👨🏿‍🎓 😇 💬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einführung 
 Im Rahmen meines Projekts stand ich vor der Aufgabe, die aktuelle Website des Unternehmens mehrsprachig zu gestalten. Genauer gesagt: um ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Eine einfache Möglichkeit, mehrere Sprachen hinzuzufügen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437124/"><h2>  Einführung </h2><br>  Im Rahmen meines Projekts stand ich vor der Aufgabe, die aktuelle Website des Unternehmens mehrsprachig zu gestalten.  Genauer gesagt: um die Möglichkeit zu schaffen, die Website schnell und einfach ins Englische, Polnische, Italienische usw. zu übersetzen. <br><br>  Eine Suche im Internet ergab, dass die vorhandenen Optionen zum Erstellen einer mehrsprachigen Website äußerst umfangreich und ineffizient sind.  Das Verbinden von Bibliotheken von Drittanbietern ist häufig problematisch, und Tipps zum Schreiben Ihrer Lösung sind mit einem großen Arbeitsaufwand des gleichen Typs verbunden. <br><br>  Das Schreiben einer alternativen Methode zum Ändern des Gebietsschemas dauerte nur wenige Stunden, und die Beibehaltung der semantischen Einheit minimiert die Änderungen beim Hinzufügen neuer Seiten vollständig. <br><br>  Die Quelldateien für die Beispielseite mit automatischer Übersetzung können <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">auf github</a> heruntergeladen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">werden</a> <br><a name="habracut"></a><br><h2>  Bestehende Alternativen </h2><br>  Als die Aufgabe gerade in der Entwicklung auftauchte, bestand der erste Schritt natürlich darin, vorgefertigte Lösungen und Tipps in den Foren zu studieren, wie die Möglichkeit einer Änderung des Gebietsschemas am einfachsten und korrektesten implementiert werden kann.  Die beliebtesten Internetquellen zum Erstellen mehrsprachiger Websites bieten die folgenden Lösungen: <br><br><ul><li>  Erstellen doppelter HTML-Blöcke mit Text in verschiedenen Sprachen, von denen nur einer für den Benutzer aktiv bleibt und der Rest ausgeblendet ist (Anzeige: keine). <br><br>  Der offensichtliche Nachteil dieser Methode ist die unglaublich schnelle Zunahme des Codes und ein sofortiger Verlust der Lesbarkeit und Wartbarkeit des Codes.  Darüber hinaus ist diese Lösung anfällig für Textfehler und Skalierbarkeit in Bezug auf die Erhöhung der Anzahl der Sprachen (im Folgenden als Gebietsschemas bezeichnet). <br></li><li>  Verbinden eines maschinellen Übersetzungsdienstes eines Drittanbieters (z. B. Google Übersetzer) mit vielen integrierten Sprachen und minimalen Änderungen am Quellcode der Seite. <br><br>  Als die Aufgabe zum ersten Mal in der Aufgabenliste angezeigt wurde, haben wir diese Methode als die offensichtlichste und bequemste verwendet. Die Erfahrung mit Muttersprachlern aus den USA und Israel hat jedoch gezeigt, dass die maschinelle Übersetzung beim Ändern des Gebietsschemas häufig Fehler macht und die Benutzer der Website sehr scharf darauf reagieren Übersetzungsfehler.  Am Ende rieten die strategischen Partner nachdrücklich, die Methode zum Ändern des Gebietsschemas zu ändern, und diese Methode musste aufgegeben werden. <br></li><li>  Ändern der Sprache mithilfe der Funktionen von js oder Bibliotheken / Frameworks von Drittanbietern wie jQuery basierend auf der Suche und direkten Änderung von DOM-Elementen. <br><br>  Ein Merkmal dieses Ansatzes ist die Suche nach einer großen Anzahl von js-Selektoren, deren Text ersetzt werden muss.  Dieser Ansatz mag für kleine Projekte gut funktionieren, aber mit zunehmender Anzahl von Seiten nimmt die Anzahl von Textersetzungsfunktionen proportional zu, was bei großen Projekten zu einem Effizienzverlust führt. <br></li></ul><br><h2>  Alternative Lösung </h2><br>  Die Grundlage des von mir vorgeschlagenen Ansatzes als Alternative zu bestehenden Methoden ist seltsamerweise nicht die von mir geschriebene Basis, die im Allgemeinen trivial ist, und das Design von Selektoren, deren Unterstützung es Ihnen ermöglicht, die Übersetzung einer beliebigen Anzahl von Seiten in eine beliebige Sprache ohne diese flexibel und einfach zu konfigurieren Änderungen der Codebasis und übermäßige Duplizierung von Daten. <br><br>  Bei der Änderung des Gebietsschemas mit einem alternativen Ansatz werden drei Hauptakteure unterschieden: <br><br><ul><li>  HTML-Seite mit der festgelegten Regel für Blockselektoren mit Text <br></li><li>  Allgemeiner js-Dienst, dessen Hauptaufgabe darin besteht, textContet-DOM-Elemente gemäß der Selektorentwurfsregel zu ersetzen <br></li><li>  JSON-Datei für das Gebietsschema, die eine Struktur enthält, die HTML-Blöcke in allen Sprachen enthält, die beim Ändern des Gebietsschemas verwendet werden <br></li></ul><br>  Durch die Einhaltung der Entwurfsregeln für Selektoren veränderlicher Elemente muss der js-Code des Gebietsschema-Änderungsdienstes nicht mehr geändert werden. Dies ist ein großes Plus in Bezug auf die Skalierbarkeit des Projekts. <br><br><h2>  Die Regel zum Erstellen von Selektoren </h2><br>  Die meisten Methoden zum Ändern des Seitengebietsschemas (unter den Alternativen 1.3 und teilweise 2) schlagen vor, dass Sie den zu ändernden HTML-Block auf irgendeine Weise „markieren“ müssen, da dies durch Ändern des Klassenfelds korrekt ist.  Der gleiche Mechanismus verwendet eine alternative Option. <br><br>  Der erste Schritt beim Entwerfen von Selektoren besteht darin, die Quellseite in Funktionsblöcke der obersten Ebene aufzuteilen.  Auf der Seite unseres Unternehmens befinden sich Blöcke: <br>  Wir geben jedem Block einen bedingten Namen, zum Beispiel <br><br><ul><li><p>  <strong>Menü</strong> </p></li><li><p>  <strong>Visitenkarte</strong> (zu Hause) </p></li><li><p>  Beispiel für einen <strong>Servicebetrieb</strong> (Beispiel) </p></li><li><p>  <strong>Partner</strong> (Kunden) </p></li><li><p>  <strong>Servicebereich</strong> (userfulBlock) </p></li><li><p>  <strong>Beispiele für den Service</strong> (Beispiele) </p></li><li><p>  <strong>Kontakte und Feedback</strong> (Kontakte) </p></li></ul><br><div class="spoiler">  <b class="spoiler_title">Website-Beispiel</b> <div class="spoiler_text"><img src="https://ferretvideo.com/articles/changeLocale/2.jpg" alt="Website-Beispiel"><br></div></div><br>  Danach teilen wir jeden Block weiter in kleinere Funktionsblöcke auf, wie dies bei der React-Bibliothek der Fall ist. <br><br><div class="spoiler">  <b class="spoiler_title">Website-Beispiel</b> <div class="spoiler_text"><img src="https://ferretvideo.com/articles/changeLocale/1.jpg" alt="Website-Beispiel"><br></div></div><br>  Wir weisen den ausgewählten Bereichen unsere Namen zu und erhalten eine Struktur des Formulars: <br><br><ul><li><p>  <strong>Menü</strong> </p></li><li><p>  Hauptleitung, Beschreibung, Tasten </p></li><li><p>  <strong>Beispielstatistik</strong> , Überschrift, Beschreibung, Schaltflächen </p></li><li><p>  <strong>Client-</strong> Schaltflächen </p></li><li><p>  <strong>userfulBlock-</strong> Überschrift, userfulCards, elseBlock </p></li><li><p>  <strong>Beispiele</strong> Überschrift, Karten </p></li><li><p>  <strong>Kontakte</strong> Überschrift, Beschreibung, Kontakte, Formular </p></li></ul><br>  Wir setzen diesen Vorgang fort, bis wir die Blöcke erreichen, die den Quelltext enthalten. <br><br>  Als Ergebnis erhalten wir eine vorgefertigte JSON-Dateistruktur für das Gebietsschema, die alle erforderlichen Texte zum Ändern der Sprache enthält.  Basierend auf diesem Algorithmus wird auch die Regel zum Erstellen von Selektoren bestimmt: <br><br>  Jeder Selektor beginnt mit dem Schlüsselwort locale, und dann werden gemäß dem Strich-Groß- / Kleinschreibung-Stil die Namen aller übergeordneten Blöcke hinzugefügt, einschließlich des Blocks, der den Quelltext enthält. Beispielsweise enthält die Beispielbeschreibung auf der ersten Karte den Selektor für das Gebietsschema-Beispielkartenbeschreibung <br><br><div class="spoiler">  <b class="spoiler_title">Website-Beispiel</b> <div class="spoiler_text"><img src="https://ferretvideo.com/articles/changeLocale/3.jpg" alt="Website-Beispiel"><br></div></div><br>  Ein Beispiel für die resultierende Gebietsschema-JSON-Datei ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">auf Github</a> zu sehen <br><br><h2>  Gebietsschema-Änderungsdienst </h2><br>  Der Gebietsschemaänderungsdienst ist ein Modul, das die Funktion zum Laden einer Gebietsschemadatei enthält <br><br><pre><code class="javascript hljs">loadLocale(defLang)</code> </pre> <br>  mit dem optionalen Parameter defLang - die nach dem Laden des Gebietsschemas festgelegte Sprache (Standardsprache) sowie die Hauptfunktion zum Ändern des aktuellen Gebietsschemas <br><br><pre> <code class="javascript hljs">changeLocale(lang)</code> </pre> <br>  Angabe der gewünschten Sprache. <br><br><h3>  Gebietsschema-Download-Funktion </h3><br>  Die Funktion zum Laden des Gebietsschemas verwendet die Standardanforderung XMLHttpRequest für Daten.  Die Verwendung dieses Standards beruht auf dem Wunsch, die Anzahl der Abhängigkeiten und die Benutzerfreundlichkeit der Anforderung zu minimieren.  Nach dem Empfang der Gebietsschemadatei wird in der Konsole eine Benachrichtigung über den Empfang von Daten angezeigt, und die Funktion zum Ändern des Gebietsschemas in die Standardsprache wird aufgerufen, wenn diese Sprache als optionaler Parameter an die Funktion übergeben wurde.  Hier können Sie sich mit dem Funktionscode vertraut machen: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loadLocale</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">defLang</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> xhr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XMLHttpRequest(); xhr.open(<span class="hljs-string"><span class="hljs-string">"GET"</span></span>, <span class="hljs-string"><span class="hljs-string">'http://localhost:3000/locale.json'</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); xhr.onreadystatechange = saveLocale.bind(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); xhr.onerror = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"no found page"</span></span>); }; xhr.send(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">saveLocale</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xhr.readyState == XMLHttpRequest.DONE &amp;&amp; xhr.status == <span class="hljs-number"><span class="hljs-number">200</span></span>) { locale = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.parse(xhr.responseText); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"locale loaded"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(defLang) changeLocale(defLang); } } }</code> </pre><br><h3>  Gebietsschemaänderungsfunktion </h3><br><h4>  Datentypen </h4><br>  Es ist eine rekursive Funktion, deren Hauptaufgabe darin besteht, das Objekt mit dem Seitengebietsschema zu durchlaufen (unter Verwendung des DFS-Algorithmus).  Durch die Verwendung der Rekursion beim Erstellen einer Funktion können Sie den Algorithmus so einfach und präzise wie möglich codieren. Eine zu große Rekursionstiefe kann jedoch zu einem Stapelüberlauf führen.  Funktionen zur Umgehung dieses Problems finden Sie im gleichnamigen Forum oder in den entsprechenden Artikeln auf habr.com. <br><br>  Die rekursive Funktion basiert auf der Verarbeitung von 4 Datentypen: <br><br><ul><li>  Feld mit einer Quelltextzeichenfolge, die zum Hinzufügen zur Seite verwendet wird. <br>  Zum Beispiel: <br><br><pre> <code class="plaintext hljs">"main": "    "</code> </pre> <br></li><li>  Feld mit einem Array von Quelltextzeilen, die zum Hinzufügen verwendet werden <br>  Seite.  Dieses Feld ist erforderlich, um Listen zu erstellen, deren Elemente geändert werden können. <br>  bestellen.  Zum Beispiel: <br><br><pre> <code class="plaintext hljs">"menu":["Home","Example","Clients","Info","Contacts"]</code> </pre> <br></li><li>  Verschachtelte Datenstruktur mit eigenen Feldern, die zum Erstellen benötigt werden <br>  Seitenarchitektur.  Zum Beispiel: <br><br><pre> <code class="plaintext hljs"> "home": { "main": "selling quest from your video", "description": "for social networks &amp; sites", "buttons": ["try","order"] }</code> </pre><br></li><li>  Ein Array verschachtelter Datenstrukturen mit denselben verwendeten Feldern.  So. <br>  Arrays werden verwendet, wenn Listen identischer Codeblöcke angezeigt werden, z. <br>  Karten von Teammitgliedern oder Portfolio oder Tarife für erbrachte Dienstleistungen. <br>  Zum Beispiel: <br><br><pre> <code class="plaintext hljs"> "usefulCards": [ { "headline": "Marketers and agencies", "statistics": ["convers 26%", "retent 25%"], "button": "ORDER" }, { "headline": "Production studios and TV platforms", "statistics": ["convers 24%", "retent 33%"], "button": "ORDER" }, { "headline": "Conference creators", "statistics": ["convers 65%", "retent 15%"], "button": "ORDER" }, { "headline": "Bloggers and streamers", "statistics": ["convers 24%", "retent 33%"], "button": "ORDER" } ],</code> </pre><br>  Auf einer Site könnte es so aussehen: <br><br><div class="spoiler">  <b class="spoiler_title">Website-Beispiel</b> <div class="spoiler_text"><img src="https://ferretvideo.com/articles/changeLocale/4.jpg" alt="Website-Beispiel"><br></div></div><br></li></ul><br><h4>  Verarbeitungsfunktionen </h4><br>  Die Verarbeitung des Quelldatentyps wird von einer separaten Funktion ausgeführt <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getText</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">key, object, name,startIndex</span></span></span><span class="hljs-function">)</span></span></code> </pre> <br>  Der Eingabefeldname des Strukturfelds mit dem Quelltext, das aktuelle Gebietsschemaobjekt, das den hinzuzufügenden Text enthält, und der aktuelle Auswahlname, der für die Suche nach dem DOM-Element erforderlich ist. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getText</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">key, object, name, startIndex</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> elementKey=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(startIndex) elementKey = startIndex; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( ; elementKey &lt; <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementsByClassName(name + <span class="hljs-string"><span class="hljs-string">"-"</span></span> + key).length; elementKey++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-built_in"><span class="hljs-built_in">isNaN</span></span>(elementKey)) <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementsByClassName(name + <span class="hljs-string"><span class="hljs-string">"-"</span></span> + key)[elementKey].textContent = object[key]; }</code> </pre><br>  Die Verarbeitung eines Arrays von Strings mit Quelltext erfolgt ebenfalls über eine separate Funktion <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getArrayText</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">key, object, name,startIndex</span></span></span><span class="hljs-function">)</span></span></code> </pre> <br>  Die Signatur und der Hauptteil dieser Funktion unterscheiden sich nicht von der Vergangenheit, außer dass die Elemente aus dem Array den DOM-Elementen zugewiesen sind. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getArrayText</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">key, object, name, startIndex</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> elementKey=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(startIndex) elementKey = startIndex; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( ; elementKey &lt; <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementsByClassName(name + <span class="hljs-string"><span class="hljs-string">"-"</span></span> + key).length; elementKey++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-built_in"><span class="hljs-built_in">isNaN</span></span>(elementKey)) <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementsByClassName(name + <span class="hljs-string"><span class="hljs-string">"-"</span></span> + key)[elementKey].textContent = object[key][elementKey % object[key].length]; }</code> </pre><br>  Die rekursive Hauptfunktion zum Ersetzen von Text befasst sich mit der Klassifizierung des aktuellen Gebietsschemafelds in einen der vier oben genannten Typen und der entsprechenden Reaktion auf den resultierenden Typ: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">changeText</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name, object, startIndex</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (key <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> object) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.isArray(object[key]) &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> object[key] != <span class="hljs-string"><span class="hljs-string">'string'</span></span> &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> object[key][<span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-string"><span class="hljs-string">'string'</span></span>) getArrayText(key, object, name); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> object[key] == <span class="hljs-string"><span class="hljs-string">"object"</span></span> ){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">isNaN</span></span>(key)) changeText(name + <span class="hljs-string"><span class="hljs-string">"-"</span></span> + key, object[key]); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> changeText(name, object[key],key); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> getText(key, object, name, startIndex); }</code> </pre><br>  Diese Funktion akzeptiert das aktuelle Sprachgebietsschema und den Stammselektor (in diesem Fall „Gebietsschema“).  Ferner ruft sich die Funktion beim Erkennen einer verschachtelten Struktur oder eines Arrays von Strukturen rekursiv auf und ändert die Eingabeparameter entsprechend. <br><br>  Der Hauptvorteil des alternativen Ansatzes besteht darin, dass der oben beschriebene Dienst keine funktionalen Änderungen erfordert und unter Verwendung der von Ihnen erstellten Gebietsschemadatei als js-Datei hinzugefügt wird. <br><br><h2>  Fazit </h2><br>  Das Wesentliche des oben beschriebenen Ansatzes ist eine feste Regel zum Beschreiben von Selektoren und zum Erstellen einer Gebietsschemadatei.  Dank dessen gibt es eine einzigartige Möglichkeit, alle Seiten sofort zu übersetzen und bereits übersetztes Material wiederzuverwenden. <br><br>  Der oben beschriebene Algorithmus zum Aufbau der Selektoren ist nicht obligatorisch und für den Dienst kritisch.  Der Dienst ist flexibel zum Erweitern und Hinzufügen neuer Methoden und Algorithmen sowie zum Erstellen von Selektornamen und JSON-Gebietsschemastrukturen.  Ein mögliches Plus wäre, das Gebietsschema im Browser-Cookie zu speichern und das Gebietsschema abhängig vom Standort des Benutzers des Dienstes zu ändern. <br><br>  Die Quelldateien für die Beispielseite mit automatischer Übersetzung können <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">auf github</a> heruntergeladen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">werden</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de437124/">https://habr.com/ru/post/de437124/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de437114/index.html">Offenes Webinar: „SSH / NC / Socat: Tipps und Tricks“</a></li>
<li><a href="../de437116/index.html">AWS, MongoDB und die wirtschaftlichen Realitäten von Open Source</a></li>
<li><a href="../de437118/index.html">AI und 2048. Teil 1: Monte-Carlo-Methode</a></li>
<li><a href="../de437120/index.html">Koreanischer Bürostuhl: Harachair Miracle Sensations</a></li>
<li><a href="../de437122/index.html">Dinge benennen</a></li>
<li><a href="../de437126/index.html">Papiere mit DevFest SPB 2018</a></li>
<li><a href="../de437128/index.html">QtCreator und seine Verwendung als IDE für Rust</a></li>
<li><a href="../de437132/index.html">Die Entwicklung der Entwicklung von Automotoren seit Anfang der 90er Jahre</a></li>
<li><a href="../de437134/index.html">Was Bitfury macht: unser Entwicklungsverdau</a></li>
<li><a href="../de437136/index.html">Die langweilige Firma Ilona Mask ist bereit, beim Bau eines riesigen europäischen Beschleunigers zu helfen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>