<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔙 🏴󠁧󠁢󠁥󠁮󠁧󠁿 🏮 Efectos de filtrado SVG. Parte 6. Creando texturas con feTurbulence 🏇🏾 👢 😟</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Aprenda a utilizar el poderoso filtro primitivo feTurbulence SVG para crear sus propias texturas y efectos de distorsión. 





 La serie de artículos...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Efectos de filtrado SVG. Parte 6. Creando texturas con feTurbulence</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/441234/"><p>  Aprenda a utilizar el poderoso filtro <strong>primitivo feTurbulence</strong> SVG para crear sus propias texturas y efectos de distorsión. </p><br><p><img src="https://habrastorage.org/webt/eq/sn/t8/eqsnt8noyajxh4ljl8xf8l1j8vw.png"></p><br><p>  La serie de artículos propuesta, " <strong>Efectos de filtrado SVG</strong> " <strong>,</strong> de Sara Soueidan, un desarrollador independiente de interfaz UI / UX y autor de muchos artículos técnicos con sede en Líbano, se centra en el trabajo de los filtros SVG y consta de los siguientes artículos: </p><br><h1 id="effekty-filtracii-svg">  Efectos de filtrado SVG </h1><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Efectos de filtrado SVG.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 1. Filtros SVG 101</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Efectos de filtrado SVG.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 2. Esquema de texto con <strong>feMorfología</strong></a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Efectos de filtrado SVG.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 3. Efecto de posterización de imagen usando <strong>feComponentTransfer</strong></a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Efectos de filtrado SVG.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 4. Imágenes a dos colores con <strong>feComponentTransfer</strong></a> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Efectos de filtrado SVG.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 5. Hacer coincidir el texto con la textura de la superficie con <strong>feDisplacementMap</strong></a> </li><li>  Efectos de filtrado SVG.  Parte 6. Creando texturas con feTurbulence </li></ol><br><hr><a name="habracut"></a><br><p>  <strong>feTurbulence</strong> es una de las primitivas de filtro SVG más potentes.  La especificación define esta primitiva de la siguiente manera: </p><br><blockquote>  Esta primitiva de filtro crea una imagen utilizando la función de turbulencia de Perlin.  Permite la síntesis de texturas artificiales como nubes o mármol.  [...] <br>  La imagen resultante llenará toda la subregión de la primitiva de filtro para esta primitiva de filtro. </blockquote><p>  En otras palabras, la <strong>primitiva del</strong> filtro <strong>feTurbulence</strong> genera y muestra el ruido de Perlin.  Este tipo de ruido es útil para simular varios fenómenos naturales, como nubes, fuego y humo, y generar texturas complejas como mármol o granito.  Y al igual que <strong>feFlood</strong> , la primitiva <strong>feTurbulence</strong> llena el área de filtrado con nuevo contenido. </p><br><p>  En este artículo, veremos cómo puede crear ruido usando <strong>feTurbulence</strong> y cómo este ruido puede usarse para distorsionar imágenes y texto, como hicimos con la textura <strong>feDisplacementMap</strong> en el artículo anterior.  Luego observamos cómo se puede usar el ruido generado en combinación con los efectos de iluminación SVG para crear una textura simple para papel rugoso. </p><br><p>  Pero primero, <strong>revisemos feTurbulence</strong> y sus atributos y veamos cómo cada uno de ellos afecta el ruido generado. </p><br><h2 id="sozdanie-turbulentnosti-i-fraktalnogo-shuma-pri-pomoschi-feturbulence">  Creando turbulencia y ruido fractal con feTurbulence </h2><br><p>  Cuando tenía la intención de escribir esta serie, decidí evitar lo más posible los detalles técnicos crudos sobre las primitivas de filtro.  Es por eso que no entraremos en los detalles técnicos de las funciones utilizadas para generar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><strong>ruido Perlin</strong></a> . </p><br><p>  Después de leer acerca de la función que subyace a la generación de ruido, descubrí que no me ayuda en absoluto cuando configuro una primitiva para el experimento.  Al final, trabajamos con un generador de ruido aleatorio.  Por lo tanto, en la mayoría de los casos, encontrará que crear una textura será un tema de experimentación y ajuste hasta que obtenga el resultado deseado.  Con el tiempo, será un poco más fácil predecir cómo se verá una textura. </p><br><p>  Descubrí que jugar con la primitiva <strong>feTurbulencia</strong> y visualizar sus atributos era la mejor manera de conocerlos y me ayudó a comprender qué hace cada uno de estos atributos.  Por lo tanto, estamos utilizando un enfoque visual para comprender <strong>feTurbulence</strong> con algunas demostraciones interactivas. </p><br><p>  <strong>FeTurbulence</strong> ahora genera ruido utilizando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><strong>la función de turbulencia de Perlin</strong></a> .  Tiene 5 atributos principales que controlan la función y, por lo tanto, su resultado visual: </p><br><ul><li>  <strong>tipo</strong> ; </li><li>  <strong>frecuencia base</strong> ; </li><li>  <strong>numOctaves</strong> ; </li><li>  <strong>semilla</strong> </li><li>  <strong>StitchTiles</strong> . </li></ul><br><p>  Examinaremos cómo cada uno de estos atributos afecta el resultado visual sin entrar en los detalles técnicos de la función.  Encontrará que en la mayoría de los casos solo necesita preocuparse por tres de estos atributos: <strong>type</strong> , <strong>baseFrequency</strong> y <strong>numOctaves</strong> . </p><br><h3 id="basefrequency">  frecuencia base </h3><br><p>  Para generar ruido, solo se <strong>requiere el</strong> atributo <strong>baseFrequency</strong> .  <strong>baseFrequency</strong> afecta el tamaño (o escala) y la granularidad del ruido generado. </p><br><p>  El efecto de la frecuencia base se entiende mejor cuando se visualiza y anima.  Es por eso que creé la próxima demostración.  Con el control deslizante, puede cambiar el valor de la frecuencia base utilizada y ver cómo afecta el ruido generado en tiempo real.  Notará que cuando aumenta o disminuye el valor del atributo <strong>baseFrequency, el</strong> patrón generado <strong>permanece sólido, cada vez más pequeño o más grande,</strong> respectivamente, y <strong>parece que está escalado y sale de la fuente en la esquina superior izquierda</strong> . </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://codepen.io/SaraSoueidan/embed/preview/oJKObg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  La reducción de los valores de <strong>frecuencia base</strong> , como 0.001, genera patrones grandes, mientras que el aumento de los valores, 0.5+, crea patrones más pequeños.  Los valores comienzan en 0 (sin frecuencia == sin patrón) y superiores.  Los valores negativos no están permitidos.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><strong>Como señala Michael Mullani</strong></a> , "los valores que van desde 0.02 a 0.2 son puntos de partida útiles para la mayoría de las texturas". </p><br><p>  Tenga en cuenta que el ruido generado no tiene un color de fondo.  Esto significa que si elimina el color de fondo blanco en el SVG, puede ver el fondo del cuerpo oscuro a través del ruido. </p><br><p>  El atributo <strong>baseFrequency</strong> también toma dos valores.  Si especifica dos valores, el primero se usará para la frecuencia base a lo largo del eje X, y el segundo corresponderá al eje Y. Al proporcionar dos valores diferentes, puede generar ruido vertical u horizontal, que puede usarse para implementar algunos efectos fantásticos, como veremos en la siguiente sección </p><br><p>  <strong>Juegue nuevamente</strong> con los valores de <strong>baseFrequency</strong> en esta demostración y observe cómo cambia a lo largo de los ejes X e Y si le da valores diferentes.  La demostración comienza con un agradable ruido horizontal.  El <strong>valor</strong> de <strong>frecuencia base x</strong> de 0.01 es relativamente pequeño, lo que hace que el patrón horizontal sea grande (a medida que se estira).  Si lo reduce aún más, por ejemplo, a 0.001, verá que el patrón horizontal se parecerá más a las líneas.  Pruébalo </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://codepen.io/SaraSoueidan/embed/preview/yZBBzN" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h3 id="type">  tipo </h3><br><p>  Como su nombre lo indica, el atributo <strong>type</strong> se usa para indicar el tipo de ruido generado por la primitiva <strong>feTurbulence</strong> .  Hay dos tipos: </p><br><ul><li>  <strong>turbulencia</strong> , que es el valor predeterminado; </li><li>  <strong>Ruido fractal</strong> . </li></ul><br><p>  <strong>fractalNoise</strong> crea <strong>patrones</strong> más difusos y suaves; esta es una buena base para crear texturas gaseosas como las nubes.  <strong>La turbulencia</strong> produce más líneas que simulan ondas y, por lo tanto, son adecuadas como base para texturas fluidas. </p><br><p><img src="https://habrastorage.org/webt/qy/zw/3g/qyzw3gv0j-yz9g1q5ymzhuc7skm.png" alt="Ruido de turbulencia a la izquierda y ruido fractal a la derecha"><br>  Fig_1.  Ruido como turbulencia a la izquierda y ruido fractal a la derecha. </p><br><p>  Cambie el valor del atributo <strong>type</strong> en la siguiente demostración para ver cómo cambia el patrón creado: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://codepen.io/SaraSoueidan/embed/preview/GzKeeg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h3 id="numoctaves">  numOctaves </h3><br><p>  <strong>numOctaves</strong> abreviado como "número de octava" que representa el nivel de detalle del ruido. </p><br><p>  En música, una octava es la diferencia en tonos entre dos notas cuando una tiene una frecuencia dos veces mayor que la otra.  Por lo tanto, cuanto mayor es la octava, mayor es la frecuencia.  En <strong>feTurbulence</strong> , cuanto mayor es el número de octavas, más detalles puede ver en el ruido que crea.  Por defecto, el ruido generado es una octava, lo que significa que el valor predeterminado para el atributo <strong>numOctaves</strong> es 1. </p><br><p>  Arrastre el control deslizante en la siguiente demostración para ver el efecto de aumentar el número de octavas en la textura generada: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://codepen.io/SaraSoueidan/embed/preview/YdmmBV" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Notarás que a partir de <strong>numOctaves</strong> = "5" el efecto de agregar octavas se vuelve casi invisible. </p><br><h3 id="seed">  semilla </h3><br><p>  El grano, como se <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><strong>define en la especificación</strong></a> , es el "número inicial para el generador de números pseudoaleatorios".  En otras palabras, proporciona una semilla diferente para la función aleatoria utilizada para generar nuestro ruido aleatorio. </p><br><p>  Visualmente, verá que esto afecta dónde y cómo se generan las "líneas onduladas".  Esto también se entiende mejor cuando ve cómo esto afecta el ruido generado en dos rectángulos adyacentes. </p><br><p>  Cuando se usa el mismo valor inicial para dos rectángulos adyacentes, la función utilizada para crear ruido a través de los dos rectángulos es continua, y esto se reflejará visualmente por la continuidad de las "líneas onduladas" a lo largo de los bordes de estos dos rectángulos. </p><br><p><img src="https://habrastorage.org/webt/f4/ns/yz/f4nsyz3yza-bxpo5gynia5vl188.png" alt="La continuidad de una función que genera ruido aleatorio se puede ver en los bordes de dos rectángulos usando el mismo valor inicial"><br>  Fig_2.  La continuidad de una función que genera ruido aleatorio se puede ver en los bordes de dos rectángulos usando el mismo valor inicial. </p><br><p>  Juegue con el valor del atributo <strong>semilla</strong> en la próxima demostración, vea cómo afecta el ruido generado y observe que el ruido es continuo a lo largo de los bordes de dos rectángulos usando el mismo valor inicial. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://codepen.io/SaraSoueidan/embed/preview/XovQEv" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h3 id="stitchtiles">  puntada </h3><br><p>  <strong>stitchTiles</strong> se puede utilizar para crear un efecto de costura entre los "mosaicos" de ruido.  El efecto de este atributo es muy similar al efecto de la semilla, lo que significa que es más obvio cuando tiene dos áreas adyacentes (o "mosaicos") de ruido. </p><br><p>  Como se menciona en la especificación, a veces el resultado de la generación de ruido mostrará roturas claras en los bordes del mosaico.  Puede decirle al navegador que intente aplanar los resultados para que los dos mosaicos aparezcan "unidos". Realmente me gusta que el atributo y su efecto se comparen con la costura. </p><br><p>  Por defecto, no se intenta lograr transiciones suaves en el borde de las hojas que contienen una función de turbulencia, ya que el valor predeterminado para <strong>stitchTiles</strong> es <strong>noStitch</strong> .  Si desea crear un efecto de costura, puede cambiar el valor a <strong>puntada</strong> . </p><br><p>  Para comparar el resultado de <strong>stitchTiles</strong> con el resultado de la <strong>semilla</strong> , apliqué el mismo valor de <strong>semilla</strong> al ruido generado en los dos rectángulos en la siguiente demostración.  Ya puedes ver que el ruido parece continuo entre ellos.  Cambie la opción <strong>stitchTiles</strong> a " <strong>on</strong> ", cambiando su valor a <strong>stitch</strong> para ver cómo el ruido cambia su ubicación alrededor de los bordes. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://codepen.io/SaraSoueidan/embed/preview/VqoOwz" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Como mencioné anteriormente, solo hay tres atributos, lo más probable es que use <strong>type</strong> , <strong>baseFrequency</strong> y <strong>numOctaves</strong> .  Entonces nos centraremos en estos tres, avanzando. </p><br><h2 id="ispolzuem-shum-feturbulence-dlya-iskazheniya-kontenta">  Uso del ruido feTurbulence para distorsionar el contenido </h2><br><p>  Aquí comienza la diversión.  ¿Y cómo comenzamos a usar el ruido generado?  De hecho, solo llenar el área de filtrado con ruido es en sí mismo inútil. </p><br><p>  En un artículo anterior, utilizamos <strong>feDisplacementMap</strong> para alinear un fragmento de texto con la textura de la imagen externa.  Y mencionamos que <strong>feDisplacementMap</strong> usa la información de color de una imagen para distorsionar otra.  La imagen utilizada como mapa de desplazamiento puede ser cualquiera.  Esto significa que puede ser una imagen externa o una imagen generada en SVG, por ejemplo, una imagen de degradado o un patrón ... bueno, o una textura de ruido. </p><br><p>  En otras palabras, el ruido que generamos con <strong>feTurbulence</strong> también se puede utilizar para distorsionar el contenido si se aplica junto con <strong>feDisplacementMap</strong> .  En el siguiente ejemplo, usamos la salida de <strong>feTurbulence</strong> para compensar la imagen junto con <strong>feDisplacementMap</strong> .  Utilizo el modelo de ruido horizontal al proporcionar dos valores diferentes para el atributo <strong>baseFrequency</strong> , similar a lo que hicimos anteriormente. </p><br><pre><code class="plaintext hljs">&lt;svg viewBox="0 0 180 100"&gt; &lt;filter id="noise" x="0%" y="0%" width="100%" height="100%"&gt; &lt;feTurbulence baseFrequency="0.01 0.4" result="NOISE" numOctaves="2" /&gt; &lt;feDisplacementMap in="SourceGraphic" in2="NOISE" scale="20" xChannelSelector="R" yChannelSelector="R"&gt;&lt;/feDisplacementMap&gt; &lt;/filter&gt; &lt;image xlink:href="..." x="0" y="0" width="100%" height="100%" filter="url(#noise)"&gt;&lt;/image&gt; &lt;/svg&gt;</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://codepen.io/SaraSoueidan/embed/preview/VgZZqB" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  La intensidad con la que la turbulencia distorsiona la imagen se indica en el atributo de <strong>venta</strong> en <strong>feDisplacementMap</strong> .  Utilicé una gran importancia para que el efecto se viera más dramático. </p><br><p>  Ahora, en base a esta sencilla aplicación, podemos abrir muchas más posibilidades para combinar estos hechos: </p><br><ul><li>  Los filtros SVG también se pueden aplicar al contenido HTML; </li><li>  <strong>Los</strong> valores de <strong>baseFrequency</strong> son números y, por lo tanto, se pueden <strong>animar</strong> . </li></ul><br><p>  Hace poco menos de dos años, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><strong>Adrien Denat</strong></a> escribió el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><strong>artículo correcto</strong></a> en el que experimentó con un efecto similar aplicado a los botones HTML.  Vamos a romper y recrear el siguiente efecto de clic de botón: </p><br><p><img src="https://habrastorage.org/webt/zc/j1/1u/zcj11uzosfkidw_nhs51icwucn0.gif"></p><br><p>  Comenzaremos creando una textura de ruido.  Este es el estado en el que el botón está distorsionado, y luego, tan pronto como lo obtengamos, animaremos el estado inicial del botón a este estado distorsionado y de regreso haciendo clic. </p><br><p>  Nuestro objetivo aquí es distorsionar el botón horizontalmente.  Es decir  Utilizaremos y ajustaremos el ruido horizontal de la demostración anterior.  Su efecto de distorsión en la imagen es incluso demasiado fuerte, así que para empezar marcaré el código cambiando el valor de turbulencia de (0.01 0.4) a (0 0.2): </p><br><pre> <code class="plaintext hljs">&lt;filter id='noise' x='0%' y='0%' width='100%' height='100%'&gt; &lt;feTurbulence type="turbulence" baseFrequency="0 0.2" result="NOISE" numOctaves="2" /&gt; &lt;feDisplacementMap in="SourceGraphic" in2="NOISE" scale="30" xChannelSelector="R" yChannelSelector="R"&gt;&lt;/feDisplacementMap&gt; &lt;/filter&gt;</code> </pre> <br><p>  El efecto ha mejorado un poco, pero el botón todavía está más distorsionado de lo que nos gustaría: </p><br><p><img src="https://habrastorage.org/webt/zc/3k/ef/zc3kefcfi1uifcdsaqskvyh8rya.png"></p><br><p>  Queremos que la distorsión sea menos dramática.  Tenga en cuenta que podemos reducir instantáneamente el efecto de ruido cambiando el tipo de ruido de la turbulencia predeterminada a un <strong>ruido fractal</strong> más <strong>suave</strong> .  Tan pronto como hagamos esto, veremos que el efecto de distorsión también se suavizará: </p><br><p><img src="https://habrastorage.org/webt/od/7-/3u/od7-3ubszs7r5_axgrbdzx1lixi.png"></p><br><p>  Se ve mucho mejor. </p><br><p>  Ahora que tenemos el efecto de distorsión con el que estamos contentos, comenzaremos nuestra demostración con un filtro que inicialmente no hace casi nada: </p><br><pre> <code class="plaintext hljs">&lt;filter id='noise' x='0%' y='0%' width='100%' height='100%'&gt; &lt;feTurbulence type="fractalNoise" baseFrequency="0 0.000001" result="NOISE" numOctaves="2" /&gt; &lt;feDisplacementMap in="SourceGraphic" in2="NOISE" scale="30" xChannelSelector="R" yChannelSelector="R"&gt;&lt;/feDisplacementMap&gt; &lt;/filter&gt;</code> </pre> <br><p>  Vamos a aplicar este filtro a nuestro botón en CSS: </p><br><pre> <code class="plaintext hljs">button { -webkit-filter: url(#noise); filter: url(#noise); }</code> </pre> <br><p>  En este punto, el botón aún no aparece distorsionado. </p><br><p>  A continuación, vamos a usar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><strong>el código de Adrien</strong></a> , aunque una versión ligeramente modificada que usa GSAP para animar el valor del atributo <strong>baseFrequency</strong> a (0 0.2) y viceversa dentro de la primitiva <strong>feTurbulence</strong> haciendo clic en: </p><br><pre> <code class="plaintext hljs">var bt = document.querySelectorAll('.button')[0], turbVal = { val: 0.000001 }, turb = document.querySelectorAll('#noise feTurbulence')[0], btTl = new TimelineLite({ paused: true, onUpdate: function() { turb.setAttribute('baseFrequency', '0 ' + turbVal.val); } }); btTl.to(turbVal, 0.2, { val: 0.2 }) .to(turbVal, 0.2, { val: 0.000001 }); bt.addEventListener('click', function() { btTl.restart(); });</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><strong>Y eso es realmente todo lo que se necesita.</strong></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><strong>Puedes jugar con la demo aquí</strong></a> : </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://codepen.io/SaraSoueidan/embed/preview/rPBmOa" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  En el momento de escribir este artículo, la demostración funciona en Chrome y Firefox.  Estos son errores en la versión actual de Safari, pero el problema se resolverá en la próxima versión, ya que Safari Tech Preview muestra que la demostración funciona bien. </p><br><p>  Aunque esto no funciona en MS Edge, el botón no está distorsionado en absoluto, lo que significa que la falta de soporte no afecta la capacidad de usarlo.  Esto es genial porque <strong>aún puedes usar este efecto como una mejora</strong> .  Si el efecto no es compatible, el botón se verá y se comportará como un botón normal sin efecto. </p><br><p>  El artículo de Adrian incluye <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><strong>algunos efectos de distorsión de botones más</strong></a> que usan los mismos principios que acabamos de ver y que definitivamente vale la pena ver.  Hay uno o dos buenos trucos que todos deben aprender. </p><br><h2 id="volnistyy-tekst-s-ispolzovaniem-feturbulence">  Texto ondulado usando feTurbulence </h2><br><p>  Uno de mis usos favoritos de <strong>feTurbulence</strong> es el efecto de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><strong>texto ondulado</strong></a> de Lucas Beber.  En su demo, Lucas usa varias funciones de <strong>feTurbulencia</strong> : </p><br><pre> <code class="plaintext hljs">&lt;svg xmlns="http://www.w3.org/2000/svg" version="1.1"&gt; &lt;defs&gt; &lt;filter id="squiggly-0"&gt; &lt;feTurbulence id="turbulence" baseFrequency="0.02" numOctaves="3" result="noise" seed="0" /&gt; &lt;feDisplacementMap id="displacement" in="SourceGraphic" in2="noise" scale="6" /&gt; &lt;/filter&gt; &lt;filter id="squiggly-1"&gt; &lt;feTurbulence id="turbulence" baseFrequency="0.02" numOctaves="3" result="noise" seed="1" /&gt; &lt;feDisplacementMap in="SourceGraphic" in2="noise" scale="8" /&gt; &lt;/filter&gt; &lt;filter id="squiggly-2"&gt; &lt;feTurbulence id="turbulence" baseFrequency="0.02" numOctaves="3" result="noise" seed="2" /&gt; &lt;feDisplacementMap in="SourceGraphic" in2="noise" scale="6" /&gt; &lt;/filter&gt; &lt;filter id="squiggly-3"&gt; &lt;feTurbulence id="turbulence" baseFrequency="0.02" numOctaves="3" result="noise" seed="3" /&gt; &lt;feDisplacementMap in="SourceGraphic" in2="noise" scale="8" /&gt; &lt;/filter&gt; &lt;filter id="squiggly-4"&gt; &lt;feTurbulence id="turbulence" baseFrequency="0.02" numOctaves="3" result="noise" seed="4" /&gt; &lt;feDisplacementMap in="SourceGraphic" in2="noise" scale="6" /&gt; &lt;/filter&gt; &lt;/defs&gt; &lt;/svg&gt;</code> </pre> <br><p>  ... y aplicándolos a través de CSS a un texto HTML usando animación CSS, anima de uno a otro: </p><br><pre> <code class="plaintext hljs">@keyframes squiggly-anim { 0% { -webkit-filter: url("#squiggly-0"); filter: url("#squiggly-0"); } 25% { -webkit-filter: url("#squiggly-1"); filter: url("#squiggly-1"); } 50% { -webkit-filter: url("#squiggly-2"); filter: url("#squiggly-2"); } 75% { -webkit-filter: url("#squiggly-3"); filter: url("#squiggly-3"); } 100% { -webkit-filter: url("#squiggly-4"); filter: url("#squiggly-4"); } }</code> </pre> <br><p>  ... creando así un efecto ondulado. </p><br><p>  Nuevamente, el texto utilizado es real, es decir.  Está disponible para búsqueda, selección, acceso y edición (utilizando el atributo <strong>contenteditable</strong> ).  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><strong>Echa un vistazo a la demostración en vivo</strong></a> , pero ten cuidado, ya que  Esta demostración requiere muchos recursos y es posible que no tenga que abrir Codepen en su teléfono móvil. </p><br><p><img src="https://habrastorage.org/webt/zu/24/_o/zu24_ohstp_gwe4srzy80dxv8ig.gif"></p><br><p>  Entonces, algunas conclusiones útiles de esta sección: </p><br><ul><li>  El ruido generado por <strong>feTurbulence</strong> se puede utilizar para distorsionar el contenido SVG y HTML. </li><li>  El valor de <strong>baseFrequency</strong> puede ser animado. </li><li>  Puede reducir la cantidad de distorsión ajustando los valores en <strong>frecuencia base</strong> y suavizando el ruido con el tipo de ruido <strong>fractal</strong> . </li><li>  Aunque puede animar los filtros SVG en general, generalmente se recomienda no exagerar, ya que pueden requerir muchos recursos.  Intenta mantener la animación limitada a áreas pequeñas;  cuanto mayor sea el área animada, más recursos consumirá. </li></ul><br><p>  La primitiva <strong>feurbulencia</strong> rara vez, si es que alguna vez, se usa sola.  Casi siempre lo usan otras primitivas de filtro para lograr efectos individuales. </p><br><p>  En esta sección, lo usamos como un mapa de desplazamiento en <strong>feDisplacementMap</strong> .  Veamos qué más puedes hacer con él. </p><br><h2 id="imitaciya-prirodnoy-tekstury-pri-pomoschi-feturbulence">  Imitación de textura natural con fe Turbulencia </h2><br><p>  Otra forma útil de utilizar el ruido generado por <strong>feTurbulence</strong> es simular una textura natural.  Si alguna vez usó Complementos de generación de ruido en <strong>After Effects</strong> , es posible que ya haya encontrado esta funcionalidad y ejemplos de esto. </p><br><p><img src="https://habrastorage.org/webt/iy/cd/-k/iycd-kxtpu0ac7be_d6ooscwlmk.png"><br>  Fig_7.  Texturas de muestra creadas en After Effects con el complemento <strong>Fractal Noise</strong> .  ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Fuente</a> ) </p><br><p>  <strong>feTurbulence</strong> genera ruido (valores aleatorios) para cada uno de los componentes R, G, B y A. Puede cambiar los valores de cada uno de estos componentes para obtener diferentes variaciones de ruido.  Para simular una textura, generalmente necesitamos hacer exactamente eso: ajustar los componentes R / G / B / A (cancelar componentes, saturar otros, etc.). Para obtener el resultado deseado.  En otros casos, todo lo que tenemos que hacer es arrojar algo de luz sobre esto.  Literalmente </p><br><p>  En esta sección, veremos el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><strong>efecto de textura de papel rugoso</strong></a> creado por Michael Mullany.  Para crear esta textura, necesitamos iluminar la textura del ruido generado por <strong>feTurbulence</strong> usando fuentes de iluminación SVG. </p><br><h3 id="istochniki-sveta-v-svg">  Fuentes de luz en SVG </h3><br><p>  SVG proporciona convenientemente varias primitivas que puede usar para iluminar objetos o imágenes. </p><br><p>  Hay dos primitivas de filtro que se utilizan para indicar el tipo de luz que desea: </p><br><ul><li>  <strong>feDiffuseLighting</strong> , que indica luz indirecta de una fuente externa, y se utiliza mejor para los efectos de la luz solar; </li><li>  <strong>feSpecularLighting</strong> , que define la luz secundaria que regresa de las superficies reflectantes. </li></ul><br><p>  Ambas primitivas iluminan un objeto o imagen usando el canal alfa de esta imagen como un mapa del terreno.  Los valores transparentes permanecen planos, mientras que los valores opacos se elevan para formar picos que se iluminan más notablemente. </p><br><p>  En otras palabras, el filtro de fuente de luz utiliza el canal alfa de entrada para obtener información de profundidad: las áreas con mayor opacidad se elevan hacia el observador y las áreas con menos opacidad se alejan de él.  Esto significa que el valor alfa de un píxel en la entrada se usa como la altura de ese píxel en la dimensión z, y el filtro usa esta altura para calcular una superficie virtual que reflejará una cierta cantidad de luz de la fuente de luz.  ¡Esto es algo muy poderoso! </p><br><p>  Ambos tipos de luz aceptan un atributo llamado <strong>surfaceScale</strong> , que es prácticamente un factor de índice z.  A medida que aumenta este valor, las "pendientes" de la textura de la superficie se vuelven más pronunciadas. </p><br><blockquote>  "Dado que <strong>feTurbulence</strong> genera un canal alfa lleno de valores de ruido de 0 a 1, forma una buena variable de la superficie Z que crea deslumbramiento cuando lo iluminamos".  —Michael Mullany </blockquote><p>  Después de decidir el tipo de luz, debe elegir una fuente de luz.  Hay <strong>tres tipos de fuentes de luz</strong> en SVG: </p><br><ul><li>  <strong>feDistantLight</strong> : es una fuente de luz remota que está tan lejos como se desee y, por lo tanto, se determina en términos de su ángulo de inclinación desde el objetivo.  Esta es la forma más adecuada de representar la luz solar. </li><li>  <strong>fePointLight</strong> : representa el punto de luz que emana de un punto específico, representado como una coordenada tridimensional X / Y / Z.  Parece una fuente de luz dentro de una habitación o dentro de una escena. </li><li>  <strong>feSpotLight</strong> : este es un foco que se comporta como un punto de luz, pero su haz se puede reducir a un cono y la luz puede girar hacia otros objetivos. </li></ul><br><p>  Cada una de estas tres fuentes de luz tiene sus propios atributos, que se utilizan para ajustar la luz que genera al indicar la ubicación de la fuente en el espacio 3D.  Los atributos están más allá del alcance de este artículo, pero puede obtener más información sobre ellos en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><strong>esta especificación</strong></a> . </p><br><p>  Para crear y aplicar un efecto de iluminación, debe adjuntar una fuente de luz al tipo de iluminación.  Por lo tanto, comienza eligiendo el tipo de iluminación que desea y luego elige la fuente de la que procederá.  Y luego, finalmente, debe especificar el color de su iluminación.  La propiedad de <strong>color de iluminación</strong> se utiliza para determinar el color de la fuente de luz para <strong>feDiffuseLighting</strong> y <strong>feSpecularLighting</strong> . </p><br><p>  Habiendo considerado los conceptos básicos de las fuentes de iluminación, ahora pasamos a nuestro ejemplo. </p><br><p>  Para la textura del papel rugoso, utilizaremos la luz solar.  Esto significa que utilizaremos iluminación difusa blanca que proviene de una fuente distante.  Traducido al código, nuestra luz se ve así: </p><br><pre> <code class="plaintext hljs">&lt;feDiffuseLighting lighting-color="white" surfaceScale="2" in=".." result=".."&gt; &lt;feDistantLight azimuth="45" elevation="60" /&gt; &lt;/feDiffuseLighting&gt;</code> </pre> <br><p>  Los atributos de <strong>acimut</strong> y <strong>elevación</strong> determinan la posición de la fuente de luz en el espacio tridimensional.  Hay <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><strong>un artículo de Rafael Pons</strong></a> que es simplemente sorprendente al explicar estos dos conceptos de una manera simple y fácil de entender, junto con ilustraciones hermosas y convenientes que ayudan con la explicación.  Recomiendo mirarlo. </p><br><p>  Ahora que tenemos la luz, necesitamos crear nuestro ruido para iluminarlo con esta luz.  Dividiremos la demostración en etapas para descubrir cómo se crea. </p><br><p>  Necesitamos comenzar en alguna parte, y comenzaremos generando ruido básico aleatorio como la base de nuestra textura: </p><br><pre> <code class="plaintext hljs">&lt;feTurbulence baseFrequency='0.04' result='noise' /&gt;</code> </pre> <br><p>  Nuestro ruido se ve así: </p><br><p><img src="https://habrastorage.org/webt/x3/s1/nc/x3s1nczn8xxc_3nndnn0dnzp474.png"></p><br><p>  Luego arrojamos nuestra luz sobre él, y luego lo tomamos desde allí: </p><br><pre> <code class="plaintext hljs">&lt;feTurbulence baseFrequency='0.04' result='noise' /&gt; &lt;feDiffuseLighting in='noise' lighting-color='white' surfaceScale='2'&gt; &lt;feDistantLight azimuth='45' elevation='60' /&gt; &lt;/feDiffuseLighting&gt;</code> </pre> <br><p>  La iluminación brillante de nuestro ruido nos da la siguiente textura: </p><br><p><img src="https://habrastorage.org/webt/wn/tv/ax/wntvaxtgh5kv1s3k4e8ouexcyzm.png"></p><br><p>  Este no es el resultado de la textura que estamos buscando.  Lo primero que notamos aquí es la presencia de muchas líneas afiladas en la textura.  Queremos deshacernos de ellos porque no hay líneas afiladas en la superficie del papel.  Necesitamos suavizar estas líneas.  Esto se puede hacer cambiando el tipo de ruido generado a <strong>fractalNoise</strong> : </p><br><pre> <code class="plaintext hljs">&lt;feTurbulence type="fractalNoise" baseFrequency='0.04' result='noise' /&gt; &lt;feDiffuseLighting in='noise' lighting-color='white' surfaceScale='2'&gt; &lt;feDistantLight azimuth='45' elevation='60' /&gt; &lt;/feDiffuseLighting&gt;</code> </pre> <br><p>  Esto elimina todos estos bordes afilados y alineados de nuestra textura: </p><br><p><img src="https://habrastorage.org/webt/x0/ql/iy/x0qliy7petifqf1j6j3t0uiwkpg.png"></p><br><p>  Ahora estamos un paso más cerca de nuestra textura de papel rugosa. </p><br><p>  Sin embargo, la textura anterior no es lo suficientemente rugosa.  Carece de la necesaria "aspereza".  Un aumento en el número de piezas pequeñas debería hacerlo más grueso.  Para hacer esto, aumentaremos el valor de <strong>numOctaves</strong> .  Descubrimos que aproximadamente 5 es un gran número para obtener el nivel deseado de rugosidad: </p><br><pre> <code class="plaintext hljs">&lt;feTurbulence type="fractalNoise" baseFrequency='0.04' numOctaves="5" result='noise' /&gt; &lt;feDiffuseLighting in='noise' lighting-color='white' surfaceScale='2'&gt; &lt;feDistantLight azimuth='45' elevation='60' /&gt; &lt;/feDiffuseLighting&gt;</code> </pre> <br><p>  Y nuestra textura de papel ahora se ve así: </p><br><p><img src="https://habrastorage.org/webt/2l/us/_c/2lus_co5ckpwdne52rnmqochozq.png"></p><br><p>  Genial </p><br><p>  Puedes jugar con la demo aquí: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://codepen.io/SaraSoueidan/embed/preview/oppeJM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Esta demostración funciona en todos los principales navegadores, incluido MS Edge. </p><br><p>  Si lo desea, puede ajustar el efecto un poco más, jugando con la fuente y la distancia de la luz.  Por ejemplo, disminuir la <strong>elevación de una</strong> fuente de luz de 60 a 40 debería aumentar el contraste entre las pequeñas colinas en la textura.  Entonces la textura se verá más o menos así: </p><br><p><img src="https://habrastorage.org/webt/nt/kh/o-/ntkho-s-ilzh9lzzwchmrtvqktm.png"></p><br><p>  Recomiendo jugar con los valores de los atributos de las fuentes de luz y ruido y ver cómo afectan la textura resultante. </p><br><h2 id="zaklyuchenie">  Conclusión </h2><br><p>  La primitiva <strong>feTurbulence</strong> es una de las operaciones SVG más interesantes y poderosas.  En combinación con otras primitivas y animaciones, es capaz de crear efectos, texturas e interacciones realmente interesantes y atractivos. </p><br><p>  Supongo que <strong>feTurbulence</strong> es uno de esos filtros con los que le gustaría experimentar o analizar el código de otras personas para estudiarlo mejor.  Sin embargo, creo que adivino cómo se verá la textura después de un tiempo.  Y dado que podemos hacer mucho con una sola textura, si la usa con otras primitivas, hay casi innumerables efectos posibles que puede crear con ella.  Le recomiendo que mire el trabajo de otras personas y lo desarme para aprender mejor. </p><br><p>  Yoksel está <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><strong>experimentando con los filtros SVG de</strong></a> Codepen después de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><strong>hablar sobre los filtros SVG hace</strong></a> unos meses.  Por lo tanto, puede encontrar bastantes efectos para analizar y aprender en su perfil Codepen. </p><br><p><img src="https://habrastorage.org/webt/ou/d2/yi/oud2yi8fduvtdb8exyqibtbos0w.gif" alt="Uno de los últimos experimentos de Yoksel con filtros SVG usando ** feTurbulence **"><br>  Fig_13.  Uno de los últimos experimentos de Yoksel con filtros SVG usando <strong>feTurbulence</strong> . </p><br><p>  Espero que este artículo te haya inspirado y haya abierto una nueva puerta a tu imaginación para que puedas ver lo que puedes hacer con los filtros SVG. </p><br><p>  En el último artículo de esta serie, compartiré algunos recursos y herramientas adicionales para ayudarlo a avanzar con los filtros SVG y comenzar a construir por su cuenta.  Quédate con nosotros </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/441234/">https://habr.com/ru/post/441234/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../441218/index.html">OpenAI Gym + ROS + Gazebo: entrenando un robot independiente en casa. Parte 1</a></li>
<li><a href="../441220/index.html">Análisis de ataques masivos recientes con captura de DNS</a></li>
<li><a href="../441222/index.html">¿Por qué Kubernetes es tan complicado con los repositorios?</a></li>
<li><a href="../441224/index.html">Cree un ejemplo ARCore de caras aumentadas en Unity</a></li>
<li><a href="../441226/index.html">Forbes publicó una lista de las compañías de Internet rusas más caras en 2019</a></li>
<li><a href="../441236/index.html">Habraiting 2018: los mejores materiales para 2018</a></li>
<li><a href="../441238/index.html">Inglés de programación</a></li>
<li><a href="../441240/index.html">¿Han perdido evidencia de una nueva física en el Gran Colisionador de Hadrones?</a></li>
<li><a href="../441242/index.html">Centro de Monitoreo de la Red de Comunicación: el nuevo "defensor" estatal de Runet</a></li>
<li><a href="../441244/index.html">La vulnerabilidad de WinRar, sin cerrar durante 19 años, le permite colocar el archivo desempaquetado en cualquier lugar</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>