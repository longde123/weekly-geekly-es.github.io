<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👰🏿 👨🏾‍🏫 ⚕️ طلب استجابة متزامن باستخدام Apache Kafka 👩‍👩‍👦 🎅🏻 👨‍🔬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="جذبت حدثا الهندسة المعمارية بشكل عام ، وأباتشي كافكا على وجه الخصوص ، الكثير من الاهتمام مؤخرا. للاستفادة الكاملة من بنية الحدث ، يجب أن تكون آلية تفو...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>طلب استجابة متزامن باستخدام Apache Kafka</h1><div class="post__body post__body_full" style=";text-align:right;direction:rtl"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/476156/" style=";text-align:right;direction:rtl"> جذبت <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">حدثا الهندسة المعمارية</a> بشكل عام ، <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">وأباتشي كافكا على</a> وجه الخصوص ، الكثير من الاهتمام مؤخرا.  للاستفادة الكاملة من بنية الحدث ، يجب أن تكون آلية تفويض الحدث غير متزامنة بشكل أساسي.  ومع ذلك ، قد يكون هناك بعض سيناريوهات / تدفقات استخدام محددة تتطلب دلالات " <b>طلب استجابة متزامن"</b> .  يوضح هذا الإصدار كيفية تنفيذ <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">طلب - استجابة</a></b> باستخدام <b>Apache Kafka</b> . <br><br>  ترجم بواسطة <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">middle_java</a></b> <br><a name="habracut"></a><br>  تاريخ المقالة الأصلية: 26 أكتوبر 2018 <br><br>  اباتشي كافكا بطبيعته غير متزامن.  لذلك ، <b>فإن</b> دلالات <b>طلب الاستجابة</b> لـ Apache Kafka ليست طبيعية.  ومع ذلك ، فإن هذا التحدي ليس جديدا.  يوفر <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">طلب -</a></b> نمط <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">طلب</a></b> تكامل المؤسسة آلية مثبتة للرسائل المتزامنة عبر قنوات غير متزامنة: <br><br><img src="https://habrastorage.org/webt/ww/cy/0h/wwcy0hvrj6iie7amwxpk1twfbui.gif"><br><br>  يكمل نمط عنوان المرسل نموذج <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">طلب الرد</a></b> بآلية للمقدم للإشارة إلى العنوان الذي يجب إرسال الرد إليه: <br><br><img src="https://habrastorage.org/webt/rw/nd/qq/rwndqqxh42kt82xadcbvgjb76wa.gif"><br><br>  في الآونة الأخيرة ، أضاف <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">Spring Kafka</a> <b>2.1.3</b> دعمًا من مربع نموذج "Request Reply" ، وفي الإصدار <b>2.2</b> تم تلميع بعض خشونه.  دعونا نرى كيف يعمل هذا الدعم: <br><br><h2 style=";text-align:right;direction:rtl">  جانب العميل: AnswerKafkaTemplate </h2><br>  يشكل التجريد المعروف للقالب الأساس لجزء العميل من آلية طلب الرد في الربيع. <br><br><pre style=";text-align:right;direction:rtl"><code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ReplyingKafkaTemplate &lt; String, Request, Reply &gt; replyKafkaTemplate( ProducerFactory &lt; String, Request &gt; pf, KafkaMessageListenerContainer &lt; String, Reply &gt; lc) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReplyingKafkaTemplate &lt; &gt; (pf, lc); }</code> </pre> <br>  كل شيء بسيط إلى الأمام هنا: لقد قمنا بإعداد <b>ReplyKafkaTemplate</b> ، والذي يرسل رسائل الطلب مع مفاتيح السلسلة ويتلقى رسائل الاستجابة مع مفاتيح السلسلة.  ومع ذلك ، يجب أن تستند ReplyKafkaTemplate على طلب ProducerFactory ، واستجابة ConsumerFactory ، و MessageListenerContainer مع تكوينات المستهلك والمنتج المناسبة.  لذلك ، التكوين المطلوب ذو وزن كبير: <br><br><pre style=";text-align:right;direction:rtl"> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Value</span></span>(<span class="hljs-string"><span class="hljs-string">"${kafka.topic.car.reply}"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String replyTopic; <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Map &lt; String, Object &gt; consumerConfigs() { Map &lt; String, Object &gt; props = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap &lt; &gt; (); props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers); props.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class); props.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, JsonDeserializer.class); props.put(ConsumerConfig.GROUP_ID_CONFIG, groupId); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> props; } <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Map &lt; String, Object &gt; producerConfigs() { Map &lt; String, Object &gt; props = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap &lt; &gt; (); props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers); props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class); props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, JsonSerializer.class); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> props; } <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ProducerFactory &lt; String, Request &gt; requestProducerFactory() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DefaultKafkaProducerFactory &lt; &gt; (producerConfigs()); } <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ConsumerFactory &lt; String, Reply &gt; replyConsumerFactory() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DefaultKafkaConsumerFactory &lt; &gt; (consumerConfigs(), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringDeserializer(), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JsonSerializer &lt; Reply &gt; ()); } <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> KafkaMessageListenerContainer &lt; String, Reply &gt; replyListenerContainer() { ContainerProperties containerProperties = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ContainerProperties(replyTopic); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> KafkaMessageListenerContainer &lt; &gt; (replyConsumerFactory(), containerProperties); }</code> </pre> <br>  في هذه الحالة ، يكون استخدام <b>replyKafkaTemplate</b> لإرسال طلب متزامن وتلقي استجابة كما يلي: <br><br><pre style=";text-align:right;direction:rtl"> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Value</span></span>(<span class="hljs-string"><span class="hljs-string">"${kafka.topic.car.request}"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String requestTopic; <span class="hljs-meta"><span class="hljs-meta">@Value</span></span>(<span class="hljs-string"><span class="hljs-string">"${kafka.topic.car.reply}"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String replyTopic; <span class="hljs-meta"><span class="hljs-meta">@Autowired</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ReplyingKafkaTemplate &lt; String, Request, Reply &gt; requestReplyKafkaTemplate; ... RequestReply request = RequestReply.request(...); <span class="hljs-comment"><span class="hljs-comment">// producer record ProducerRecord &lt; String, Request &gt; record = new ProducerRecord &lt; String, Request &gt; (requestTopic, request); //       record.headers().add(new RecordHeader(KafkaHeaders.REPLY_TOPIC, requestReplyTopic.getBytes())); //     Kafka          RequestReplyFuture &lt; String, Request, Reply &gt; sendAndReceive = requestReplyKafkaTemplate.sendAndReceive(record); sendAndReceive.addCallback(new ListenableFutureCallback &lt; ConsumerRecord &lt; String, Reply &gt;&gt; () { @Override public void onSuccess(ConsumerRecord &lt; String, Reply &gt; result) { //   consumer record Reply reply = result.value(); System.out.println("Reply: " + reply.toString()); } });</span></span></code> </pre> <br>  هناك أيضًا الكثير من <b>القواعد النمطيّة</b> وواجهة برمجة التطبيقات منخفضة المستوى ، وحتى واجهة برمجة تطبيقات <b>ListenableFuture</b> القديمة التي عفا عليها الزمن بدلًا من برنامج <b>CompleteableFuture</b> الحديث. <br><br>  <b>requestReplyKafkaTemplate</b> يهتم بإنشاء <b>وتهيئة</b> رأس <b>KafkaHeaders.CORRELATION_ID</b> ، لكن يجب علينا تعيين رأس <b>KafkaHeaders</b> بشكل صريح. <b>REPLY_TOPIC</b> رأس الطلب.  يرجى أيضًا ملاحظة أن نفس موضوع الإجابة كان غير مقصود أعلاه في <b>replyListenerContainer</b> .  بعض الوحل.  ليس تماما ما كنت أتوقع من الربيع التجريد. <br><br><h2 style=";text-align:right;direction:rtl">  جانب الخادم: SENDTo </h2><br>  على جانب الخادم ، فإن <b>تطبيق KafkaListener</b> المعتاد الذي يستمع إلى موضوع الطلب مصمم بشكل إضافي مع التعليق التوضيحي <b>SendTo</b> لتقديم رسالة استجابة.  يتم تلقائيًا التفاف الكائن الذي يتم إرجاعه بواسطة طريقة المستمع في رسالة الاستجابة ، <b>وتتم</b> إضافة <b>CORRELATION_ID ،</b> ويتم نشر الاستجابة في الموضوع المحدد في رأس <b>REPLY_TOPIC</b> . <br><br><pre style=";text-align:right;direction:rtl"> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Map &lt; String, Object &gt; consumerConfigs() { Map &lt; String, Object &gt; props = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap &lt; &gt; (); props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers); props.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class); props.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, JsonSerializer.class); props.put(ConsumerConfig.GROUP_ID_CONFIG, groupId); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> props; } <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Map &lt; String, Object &gt; producerConfigs() { Map &lt; String, Object &gt; props = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap &lt; &gt; (); props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers); props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class); props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, JsonSerializer.class); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> props; } <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ConsumerFactory &lt; String, Request &gt; requestConsumerFactory() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DefaultKafkaConsumerFactory &lt; &gt; (consumerConfigs(), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringDeserializer(), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JsonSerializer &lt; Request &gt; ()); } <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> KafkaListenerContainerFactory &lt; ConcurrentMessageListenerContainer &lt; String, Request &gt;&gt; requestListenerContainerFactory() { ConcurrentKafkaListenerContainerFactory &lt; String, Request &gt; factory = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConcurrentKafkaListenerContainerFactory &lt; &gt; (); factory.setConsumerFactory(requestConsumerFactory()); factory.setReplyTemplate(replyTemplate()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> factory; } <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ProducerFactory &lt; String, Reply &gt; replyProducerFactory() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DefaultKafkaProducerFactory &lt; &gt; (producerConfigs()); } <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> KafkaTemplate &lt; String, Reply &gt; replyTemplate() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> KafkaTemplate &lt; &gt; (replyProducerFactory()); }</code> </pre> <br>  بعض التكوين مطلوب أيضًا هنا ، لكن تكوين المستمع أبسط: <br><br><pre style=";text-align:right;direction:rtl"> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@KafkaListener</span></span>(topics = <span class="hljs-string"><span class="hljs-string">"${kafka.topic.car.request}"</span></span>, containerFactory = <span class="hljs-string"><span class="hljs-string">"requestListenerContainerFactory"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@SendTo</span></span>() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Reply </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">receive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Request request)</span></span></span><span class="hljs-function"> </span></span>{ Reply reply = ...; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> reply; }</code> </pre> <br><h2 style=";text-align:right;direction:rtl">  ولكن ماذا عن حالات متعددة للمستهلك؟ </h2><br>  يبدو أن كل شيء يعمل حتى نستخدم عدة حالات للمستهلك.  إذا كان لدينا العديد من مثيلات العملاء ، فنحن بحاجة إلى التأكد من إرسال الاستجابة إلى مثيل العميل الصحيح.  تفترض وثائق Spring Kafka أن كل مستهلك يمكنه استخدام موضوع فريد أو أنه يتم إرسال قيمة رأس <b>KafkaHeaders</b> إضافية مع الطلب. <b>RESPONSE_PARTITION</b> هو حقل من أربعة بايت يحتوي على تمثيل BIG-ENDIAN لرقم قسم عدد صحيح.  من الواضح أن استخدام موضوعات منفصلة لعملاء مختلفين ليس مرنًا للغاية ، لذلك نختار إعداد <b>REPLY_PARTITION</b> الصريح.  ثم يجب على العميل معرفة القسم الذي تم تعيينه له.  تقترح الوثائق استخدام تكوين صريح لتحديد قسم معين.  دعونا إضافته إلى مثالنا: <br><br><pre style=";text-align:right;direction:rtl"> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Value</span></span>(<span class="hljs-string"><span class="hljs-string">"${kafka.topic.car.reply.partition}"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> replyPartition; ... <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> KafkaMessageListenerContainer &lt; String, RequestReply &gt; replyListenerContainer() { ContainerProperties containerProperties = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ContainerProperties(replyTopic); TopicPartitionInitialOffset initialOffset = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TopicPartitionInitialOffset(replyTopic, replyPartition); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> KafkaMessageListenerContainer &lt; &gt; (replyConsumerFactory(), containerProperties, initialOffset); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] intToBytesBigEndian(<span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> data) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] { (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)((data &gt;&gt; <span class="hljs-number"><span class="hljs-number">24</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0xff</span></span>), (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)((data &gt;&gt; <span class="hljs-number"><span class="hljs-number">16</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0xff</span></span>), (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)((data &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0xff</span></span>), (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)((data &gt;&gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0xff</span></span>), }; } ... record.headers().add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RecordHeader(KafkaHeaders.REPLY_TOPIC, requestReplyTopic.getBytes())); record.headers().add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RecordHeader(KafkaHeaders.REPLY_PARTITION, intToBytesBigEndian(replyPartition))); RequestReplyFuture &lt; String, RequestReply, RequestReply &gt; sendAndReceive = requestReplyKafkaTemplate.sendAndReceive(record); ...</code> </pre> <br>  ليست جميلة جدا ، لكنها تعمل.  التكوين المطلوب واسع النطاق وواجهة برمجة التطبيقات تبدو منخفضة المستوى.  تؤدي الحاجة إلى تكوين أقسام بشكل صريح إلى تعقيد عملية زيادة عدد العملاء بشكل ديناميكي.  من الواضح ، يمكنك أن تفعل أفضل. <br><br><h2 style=";text-align:right;direction:rtl">  تغليف معالجة الموضوع للاستجابة والقسم </h2><br>  لنبدأ بتغليف نمط <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">عنوان</a></b> المرسل ، مع تمرير الموضوع للاستجابة والقسم.  يجب حقن موضوع الاستجابة في <b>RequestReplyTemplate</b> ، وبالتالي ، يجب ألا يكون موجودًا في واجهة برمجة التطبيقات على الإطلاق.  عندما يتعلق الأمر بالأقسام للحصول على إجابة ، سنفعل العكس: سنقوم باستخراج القسم (الأقسام) المعين لمستمع الموضوع للإجابة ، ونقل هذا القسم تلقائيًا.  هذا يلغي الحاجة للعميل لرعاية هذه الرؤوس. <br>  في الوقت نفسه ، لنقم أيضًا <b>بإنشاء</b> واجهة برمجة التطبيقات (API) بحيث تشبه طريقة <b>KafkaTemplate</b> القياسية (التحميل الزائد <b>لأسلوب sendAndReceive () مع</b> معلمات مبسطة وإضافة الطرق المحمّلة الزائدة باستخدام الموضوع الافتراضي): <br><br><pre style=";text-align:right;direction:rtl"> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PartitionAwareReplyingKafkaTemplate</span></span></span><span class="hljs-class"> &lt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">K</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">V</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">R</span></span></span><span class="hljs-class"> &gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ReplyingKafkaTemplate</span></span></span><span class="hljs-class"> &lt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">K</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">V</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">R</span></span></span><span class="hljs-class"> &gt; </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PartitionAwareReplyingKafkaTemplate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ProducerFactory &lt; K, V &gt; producerFactory, GenericMessageListenerContainer &lt; K, R &gt; replyContainer)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(producerFactory, replyContainer); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> TopicPartition </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getFirstAssignedReplyTopicPartition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (getAssignedReplyTopicPartitions() != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; getAssignedReplyTopicPartitions().iterator().hasNext()) { TopicPartition replyPartition = getAssignedReplyTopicPartitions().iterator().next(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.logger.isDebugEnabled()) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.logger.debug(<span class="hljs-string"><span class="hljs-string">"Using partition "</span></span> + replyPartition.partition()); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> replyPartition; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> KafkaException(<span class="hljs-string"><span class="hljs-string">"Illegal state: No reply partition is assigned to this instance"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] intToBytesBigEndian(<span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> data) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] { (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)((data &gt;&gt; <span class="hljs-number"><span class="hljs-number">24</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0xff</span></span>), (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)((data &gt;&gt; <span class="hljs-number"><span class="hljs-number">16</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0xff</span></span>), (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)((data &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0xff</span></span>), (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)((data &gt;&gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0xff</span></span>), }; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> RequestReplyFuture &lt; K, V, R &gt; sendAndReceiveDefault(<span class="hljs-meta"><span class="hljs-meta">@Nullable</span></span> V data) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sendAndReceive(getDefaultTopic(), data); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> RequestReplyFuture &lt; K, V, R &gt; sendAndReceiveDefault(K key, <span class="hljs-meta"><span class="hljs-meta">@Nullable</span></span> V data) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sendAndReceive(getDefaultTopic(), key, data); } ... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> RequestReplyFuture &lt; K, V, R &gt; sendAndReceive(String topic, <span class="hljs-meta"><span class="hljs-meta">@Nullable</span></span> V data) { ProducerRecord &lt; K, V &gt; record = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ProducerRecord &lt; &gt; (topic, data); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> doSendAndReceive(record); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> RequestReplyFuture &lt; K, V, R &gt; sendAndReceive(String topic, K key, <span class="hljs-meta"><span class="hljs-meta">@Nullable</span></span> V data) { ProducerRecord &lt; K, V &gt; record = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ProducerRecord &lt; &gt; (topic, key, data); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> doSendAndReceive(record); } ... <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> RequestReplyFuture &lt; K, V, R &gt; sendAndReceive(ProducerRecord &lt; K, V &gt; record) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> doSendAndReceive(record); } <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> RequestReplyFuture &lt; K, V, R &gt; doSendAndReceive(ProducerRecord &lt; K, V &gt; record) { TopicPartition replyPartition = getFirstAssignedReplyTopicPartition(); record.headers() .add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RecordHeader(KafkaHeaders.REPLY_TOPIC, replyPartition.topic().getBytes())) .add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RecordHeader(KafkaHeaders.REPLY_PARTITION, intToBytesBigEndian(replyPartition.partition()))); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.sendAndReceive(record); } }</code> </pre> <br>  الخطوة التالية: تكييف <b>ListenableFuture</b> مع <b>CompleteableFuture</b> الأكثر حداثة. <br><br><pre style=";text-align:right;direction:rtl"> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CompletableFutureReplyingKafkaTemplate</span></span></span><span class="hljs-class"> &lt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">K</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">V</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">R</span></span></span><span class="hljs-class"> &gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PartitionAwareReplyingKafkaTemplate</span></span></span><span class="hljs-class"> &lt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">K</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">V</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">R</span></span></span><span class="hljs-class"> &gt; </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CompletableFutureReplyingKafkaTemplate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ProducerFactory &lt; K, V &gt; producerFactory, GenericMessageListenerContainer &lt; K, R &gt; replyContainer)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(producerFactory, replyContainer); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> CompletableFuture &lt; R &gt; requestReplyDefault(V value) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> adapt(sendAndReceiveDefault(value)); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> CompletableFuture &lt; R &gt; requestReplyDefault(K key, V value) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> adapt(sendAndReceiveDefault(key, value)); } ... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> CompletableFuture &lt; R &gt; requestReply(String topic, V value) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> adapt(sendAndReceive(topic, value)); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> CompletableFuture &lt; R &gt; requestReply(String topic, K key, V value) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> adapt(sendAndReceive(topic, key, value)); } ... <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> CompletableFuture &lt; R &gt; adapt(RequestReplyFuture &lt; K, V, R &gt; requestReplyFuture) { CompletableFuture &lt; R &gt; completableResult = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CompletableFuture &lt; R &gt; () { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cancel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> mayInterruptIfRunning)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> result = requestReplyFuture.cancel(mayInterruptIfRunning); <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.cancel(mayInterruptIfRunning); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } }; <span class="hljs-comment"><span class="hljs-comment">//       requestReplyFuture.getSendFuture().addCallback(new ListenableFutureCallback &lt; SendResult &lt; K, V &gt;&gt; () { @Override public void onSuccess(SendResult &lt; K, V &gt; sendResult) { // NOOP } @Override public void onFailure(Throwable t) { completableResult.completeExceptionally(t); } }); //     requestReplyFuture.addCallback(new ListenableFutureCallback &lt; ConsumerRecord &lt; K, R &gt;&gt; () { @Override public void onSuccess(ConsumerRecord &lt; K, R &gt; result) { completableResult.complete(result.value()); } @Override public void onFailure(Throwable t) { completableResult.completeExceptionally(t); } }); return completableResult; } }</span></span></code> </pre> <br>  نحن نضعها في مكتبة أدوات ، والآن لدينا واجهة برمجة تطبيقات تتوافق أكثر مع فلسفة Spring الأساسية للتصميم ، <b>"Convention over Configuration"</b> .  هنا هو رمز العميل النهائي: <br><br><pre style=";text-align:right;direction:rtl"> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Autowired</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> CompletableFutureReplyingKafkaTemplate &lt; String, Request, Reply &gt; requestReplyKafkaTemplate; ... requestReplyKafkaTemplate.requestReply(request).thenAccept(reply - &gt; System.out.println(<span class="hljs-string"><span class="hljs-string">"Reply: "</span></span> + reply.toString()); );</code> </pre> <br><h2 style=";text-align:right;direction:rtl">  لتلخيص </h2><br>  للتلخيص ، يوفر Spring for Kafka 2.2 تطبيقًا وظيفيًا بالكامل لنمط <b>طلب الرد</b> في Apache Kafka ، لكن واجهة برمجة التطبيقات لا تزال بها بعض الحواف الخشنة.  في هذه المشكلة ، رأينا أن بعض التجريدات والتعديلات الإضافية لواجهة برمجة التطبيقات يمكن أن توفر واجهة برمجة تطبيقات عالية المستوى أكثر منطقية. <br><br>  <b>تحذير 1:</b> <br>  واحدة من المزايا الرئيسية للهيكل الذي يحركه الحدث هو الفصل بين منتجي الحدث والمستهلكين ، مما يجعل من الممكن إنشاء أنظمة أكثر مرونة وتطوراً.  إن استخدام دلالات متزامنة "طلب - استجابة" هو العكس تمامًا عندما ترتبط الأطراف الطالبة والمستجيبة ارتباطًا وثيقًا.  لذلك ، يجب استخدامه فقط إذا لزم الأمر. <br><br>  <b>تحذير 2:</b> <br>  إذا كانت هناك حاجة إلى <b>طلب استجابة متزامن</b> ، فإن <b>البروتوكول</b> القائم على <b>HTTP يكون</b> أبسط وأكثر فعالية من استخدام <b>قناة غير متزامنة مثل Apache Kafka</b> . <br>  ومع ذلك ، قد تكون هناك سيناريوهات يكون فيها <b>طلب - استجابة متزامن عبر كافكا</b> منطقيًا.  اختيار معقول أفضل أداة لهذا المنصب. <br><br>  يمكن العثور على مثال يعمل بشكل كامل في <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">github.com/callistaenterprise/blog-synchronous-kafka</a> . <br><br><h2 style=";text-align:right;direction:rtl">  تعليقات </h2><br>  <i>Federico • قبل 7 أشهر</i> <br>  وعندما تكون لدينا احتياجات مختلطة ، على سبيل المثال ، في 50٪ من الحالات نحتاج إلى طلب استجابة وفي 50٪ نحتاج إلى إدارة الأحداث؟  كيف نفعل هذا؟  التكوين الذي يحتاجه Spring Kafka يبدو فظيعًا جدًا. <br><br>  <i>جهانزيب قيوم • منذ 6 أشهر</i> <br>  يتمتع Spring الآن بدعم افتراضي باستخدام أقسام في موضوع واحد شائع للاستجابة. <br><br>  بدءًا من الإصدار 2.2 ، يحاول القالب تحديد موضوع الاستجابة أو القسم من حاوية الاستجابة المكونة (حاوية الرد). <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">https://docs.spring.io/spring-kafka/reference/html/#replying-template</a> <br><br>  <i>نير روزنبرغ • منذ 8 أشهر</i> <br>  مرحبا، <br>  في الفقرة الأخيرة ، كتبت أنه قد تكون هناك سيناريوهات عندما يكون طلب - استجابة متزامن عبر كافكا منطقيًا مقارنةً بـ HTTP. <br>  هل يمكنك إعطاء أمثلة على مثل هذه السيناريوهات؟ <br>  شكرا لك <br>  نير <br><br>  <i>Janne Keskitalo nir rozenberg • منذ 8 أشهر</i> <br>  سنقوم بتقسيم نظام معالجة المعاملات كبير الحجم إلى عدة خدمات مصغرة ولدي فكرة لاستخدام مراسلة Kafka للطلب والاستجابة لتحقيق تقارب مماثل في المعالجة.  بشكل أساسي ، يتم استخدام كافكا لتوجيه جميع المكالمات من عميل واحد إلى نفس عملية معالج المعاملات ، والتي تنفذ بعد ذلك بالتسلسل واحد في وقت واحد.  يضمن هذا النوع من المعالجة إمكانية الخطية ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">https://stackoverflow.com/a/19515375/7430325</a> ) ، والاتصال السببي ، كما يتيح التخزين المؤقت الفعال.  بشكل أساسي ، سيتم نقل جهود التنسيق من قاعدة البيانات إلى كافكا ، ويمكننا بدء تشغيل قاعدة البيانات في وضع عزل تسلسلي صارم. <br>  لا يزال يتعين علي الخوض في تفاصيل دلالات معاملاتنا لمعرفة أين تنخفض ، لذلك هذه مجرد فكرة. <br><br>  ترجم بواسطة <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">middle_java</a></b> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/ar476156/">https://habr.com/ru/post/ar476156/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar476140/index.html">كيفية تحسين الاستماع إذا كنت تعرف 7000 كلمة ولكنك لا تفهمها عن طريق الأذن؟</a></li>
<li><a href="../ar476142/index.html">لماذا تجنب استخدام الاستثناءات للتحكم في التدفق في Java</a></li>
<li><a href="../ar476144/index.html">كيف تحتاج ولا تحتاج إلى كتابة دردشة للروبوتات باستخدام مثال روبوتتي للعب Secret Santa</a></li>
<li><a href="../ar476146/index.html">كيفية توسيع نطاق مراكز البيانات. تقرير ياندكس</a></li>
<li><a href="../ar476148/index.html">postfix + dovecot + mysql على فري</a></li>
<li><a href="../ar476160/index.html">ولادة البرامج التعليمية وتاريخها: من الآلات الميكانيكية إلى أجهزة الكمبيوتر الأولى</a></li>
<li><a href="../ar476162/index.html">نقوم بإنشاء تطبيق ويب حديث. الإلمام بالمشروع والتحضير للعمل. الجزء 1</a></li>
<li><a href="../ar476164/index.html">"هذا هو أيضا تحليل البيانات." تحدث عن المعلوماتية الحيوية مع ميخائيل جلفاند</a></li>
<li><a href="../ar476166/index.html">"الرجل الحديدي الحقيقي" حطم رقما قياسيا لسرعة الطيران</a></li>
<li><a href="../ar476172/index.html">مؤتمر قبعة سوداء الولايات المتحدة الأمريكية. الثراء أو الموت: كسب المال على الإنترنت باستخدام القبعة السوداء. الجزء 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>