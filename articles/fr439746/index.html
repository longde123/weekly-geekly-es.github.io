<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•£ üßùüèª üíÖüèº Comprendre les promesses JavaScript üëÖ üò± üëàüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, Habr! Je vous pr√©sente la traduction de l'article ¬´Comprendre les promesses en JavaScript¬ª de Sukhjinder Arora. 



 De l'auteur de la traduc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comprendre les promesses JavaScript</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/439746/">  Bonjour, Habr!  Je vous pr√©sente la traduction de l'article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">¬´Comprendre les promesses en JavaScript¬ª</a> de Sukhjinder Arora. <br><br><img src="https://habrastorage.org/webt/ox/6m/oa/ox6moan9gwhmc2oouqbhyfzumtm.png"><br><a name="habracut"></a><br>  <i>De l'auteur de la traduction: En plus de l'auteur lui-m√™me, j'esp√®re que l'article vous a √©t√© utile.</i>  <i>S'il vous pla√Æt, si elle vous a vraiment aid√© √† apprendre quelque chose de nouveau par vous-m√™me, alors ne soyez pas trop paresseux pour aller √† l'article original et remercier l'auteur!</i>  <i>Je serai heureux de vos commentaires!</i> <i><br><br></i>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Lien vers la traduction de l'article sur JavaScript asynchrone du m√™me auteur</a> .</i> <br><br>  JavaScript est un langage de programmation monothread, ce qui signifie qu'une seule chose peut √™tre faite √† la fois.  Avant ES6, nous utilisions des rappels pour g√©rer les t√¢ches asynchrones, telles que les requ√™tes r√©seau. <br><br>  En utilisant des promesses, nous pouvons √©viter ¬´l'enfer du rappel¬ª et rendre notre code plus propre, plus lisible et plus facile √† comprendre. <br><br>  Supposons que nous voulons obtenir des donn√©es du serveur de mani√®re asynchrone, en utilisant des rappels, nous ferions quelque chose comme ceci: <br><br><pre><code class="javascript hljs">getData(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(x); getMoreData(x, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">y</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(y); getSomeMoreData(y, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">z</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(z); }); }); });</code> </pre> <br>  Ici, je demande des donn√©es au serveur √† l'aide de la fonction <i>getData ()</i> , qui re√ßoit des donn√©es √† l'int√©rieur de la fonction de rappel.  √Ä l'int√©rieur de la fonction de rappel, je demande des donn√©es suppl√©mentaires en appelant la fonction <i>getMoreData ()</i> , en passant les donn√©es pr√©c√©dentes en argument, etc. <br><br>  C'est ce que nous appelons ¬´l'enfer du rappel¬ª, o√π chaque rappel est imbriqu√© dans l'autre, et chaque rappel interne d√©pend de son parent. <br><br>  Nous pouvons r√©√©crire l'extrait ci-dessus en utilisant des promesses: <br><br><pre> <code class="javascript hljs">getData() .then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(x); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getMoreData(x); }) .then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">y</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(y); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getSomeMoreData(y); }) .then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">z</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(z); });</code> </pre> <br>  Vous pouvez voir ce qui est devenu plus lisible qu'avec le premier exemple de rappel. <br><br><h2>  Quelles sont les promesses? </h2><br>  Une promesse (promesse) est un objet qui contient la valeur future d'une op√©ration asynchrone.  Par exemple, si vous demandez des donn√©es au serveur, Promis nous promet de recevoir ces donn√©es, que nous pourrons utiliser √† l'avenir. <br><br>  Avant de plonger dans tous ces trucs techniques, regardons la terminologie des promesses. <br><br><h3>  √âtats promis </h3><br>  Une promesse en JavaScript, comme une promesse dans la vie r√©elle, a 3 √©tats.  Cela peut √™tre 1) non r√©solu (en attente), 2) r√©solu / r√©solu (termin√©) ou 3) rejet√© / rejet√©. <br><br><img src="https://habrastorage.org/webt/pk/hr/zz/pkhrzzgtdsgqvtptwn26gmtbjhk.png"><br><br>  <b>Non r√©solu ou en attente</b> - Promis attend si le r√©sultat n'est pas pr√™t.  Autrement dit, il attend l'ach√®vement de quelque chose (par exemple, l'ach√®vement d'une op√©ration asynchrone). <br>  <b>R√©solu ou termin√©</b> - Promis r√©solu si le r√©sultat est disponible.  Autrement dit, quelque chose a termin√© son ex√©cution (par exemple, une op√©ration asynchrone) et tout s'est bien pass√©. <br>  <b>Rejet√©</b> - Promis rejet√© si une erreur s'est produite lors de l'ex√©cution. <br><br>  Maintenant que nous savons ce qu'est Promis et sa terminologie, revenons √† la partie pratique des promesses. <br><br><h3>  Cr√©er des promesses </h3><br>  Dans la plupart des cas, vous utiliserez simplement des promesses, pas les cr√©erez, mais il est toujours important de savoir comment elles sont cr√©√©es. <br><br>  Syntaxe: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { ... });</code> </pre> <br>  Nous avons cr√©√© une nouvelle promesse en utilisant le constructeur Promises, cela prend un argument, un rappel, √©galement connu sous le nom de fonction ex√©cutive, qui prend 2 rappels, <i>r√©soudre</i> et <i>rejeter</i> . <br><br>  La fonction ex√©cutive est ex√©cut√©e imm√©diatement apr√®s la cr√©ation de la promesse.  Une promesse est faite en appelant <i>resolver ()</i> et rejet√©e par <i>reject ()</i> .  Par exemple: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(allWentWell) { resolve(<span class="hljs-string"><span class="hljs-string">'  !'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { reject(<span class="hljs-string"><span class="hljs-string">'-   '</span></span>); } });</code> </pre> <br>  <i>resolver ()</i> et <i>rejeter ()</i> prennent un argument, qui peut √™tre une cha√Æne, un nombre, une expression logique, un tableau ou un objet. <br><br>  Jetons un coup d'≈ìil √† un autre exemple pour bien comprendre comment les promesses sont cr√©√©es. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> randomNumber = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random(); setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(randomNumber &lt; <span class="hljs-number"><span class="hljs-number">.6</span></span>) { resolve(<span class="hljs-string"><span class="hljs-string">'  !'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { reject(<span class="hljs-string"><span class="hljs-string">'-   '</span></span>); } }, <span class="hljs-number"><span class="hljs-number">2000</span></span>); });</code> </pre> <br>  Ici, j'ai cr√©√© une nouvelle promesse en utilisant le constructeur Promis.  Une promesse est ex√©cut√©e ou rejet√©e 2 secondes apr√®s sa cr√©ation.  Une promesse est ex√©cut√©e si <i>randomNumber est</i> inf√©rieur √† 0,6 et rejet√© dans les autres cas. <br><br>  Lorsqu'une promesse a √©t√© cr√©√©e, elle est en attente et sa valeur n'est pas <i>d√©finie</i> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cs/wr/c2/cswrc2jdrixhaguff2w9oijiyf4.png"></div><br>  Apr√®s 2 secondes, le temporisateur se termine, la promesse est ex√©cut√©e ou rejet√©e de mani√®re al√©atoire, et sa valeur sera celle transmise √† la fonction de <i>r√©solution</i> ou de <i>rejet</i> .  Voici un exemple de deux cas: <br><br>  Ach√®vement r√©ussi: <br><br><img src="https://habrastorage.org/webt/eq/3y/ss/eq3ysskatvuvjnvpoaz9k7zdmvi.png"><br><br>  Promesse de rejet: <br><br><img src="https://habrastorage.org/webt/qn/7v/ee/qn7vee1ebi19qgo4zzv72tgpfjg.png"><br><br>  <b>Remarque: la</b> promesse ne peut √™tre ex√©cut√©e ou rejet√©e qu'une seule fois.  D'autres appels pour <i>r√©soudre ()</i> ou <i>rejeter ()</i> n'affecteront en aucun cas l'√©tat de la promesse.  Un exemple: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { resolve(<span class="hljs-string"><span class="hljs-string">'Promise resolved'</span></span>); <span class="hljs-comment"><span class="hljs-comment">//   reject('Promise rejected'); //       });</span></span></code> </pre> <br>  Depuis que <i>resolver () a</i> √©t√© appel√© en premier, la promesse a maintenant le statut ¬´termin√©e¬ª.  L'appel ult√©rieur √† <i>rejeter ()</i> n'affectera en aucun cas l'√©tat de la promesse. <br><br><h3>  Utilisation de Promis </h3><br>  Maintenant, nous savons comment cr√©er des promesses, voyons maintenant comment appliquer la promesse d√©j√† cr√©√©e.  Nous utilisons des promesses en utilisant les m√©thodes <i>then ()</i> et <i>catch ()</i> . <br><br>  Par exemple, interroger les donn√©es d'une API √† l'aide de la <i>r√©cup√©ration</i> , qui renvoie une promesse. <br><br>  <b>syntaxe</b> <i>.then ()</i> <b>:</b> <i>promise.then (successCallback, failureCallback)</i> <br><br>  <i>successCallback</i> est appel√© si la promesse a √©t√© ex√©cut√©e avec succ√®s.  Il prend un argument, qui est la valeur transmise √† <i>resolver ()</i> . <br><br>  <i>failureCallback</i> est appel√© si la promesse a √©t√© rejet√©e.  Il prend un argument, qui est la valeur donn√©e √† <i>rejeter ()</i> . <br><br>  Un exemple: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> randomNumber = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(randomNumber &lt; <span class="hljs-number"><span class="hljs-number">.7</span></span>) { resolve(<span class="hljs-string"><span class="hljs-string">'  !'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { reject(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'-   '</span></span>)); } }); promise.then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data); <span class="hljs-comment"><span class="hljs-comment">//  '  !' }, (error) =&gt; { console.log(error); //   } );</span></span></code> </pre> <br>  Si la promesse a √©t√© ex√©cut√©e, <i>successCallback</i> est <i>appel√©e</i> avec la valeur transmise √† <i>resolver ()</i> .  Et si la promesse a √©t√© rejet√©e, <i>failCallback</i> est <i>appel√©</i> avec la valeur pass√©e √† rejeter (). <br><br>  <i>Syntaxe .catch ()</i> <b>:</b> <i>promise.catch (failureCallback)</i> <br><br>  Nous utilisons <i>catch ()</i> pour g√©rer les erreurs.  Ceci est plus lisible que la gestion des erreurs dans <i>failureCallback</i> dans le rappel de la m√©thode <i>then ()</i> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { reject(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'-   '</span></span>)); }); promise .then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data); }) .catch(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(error); <span class="hljs-comment"><span class="hljs-comment">//   });</span></span></code> </pre> <br><h3>  Cha√Æne de promesse </h3><br>  Les m√©thodes <i>then ()</i> et <i>catch ()</i> peuvent √©galement renvoyer une nouvelle promesse, qui peut √™tre trait√©e par une cha√Æne d'autres then () √† la fin de la m√©thode then () pr√©c√©dente. <br><br>  Nous utilisons une cha√Æne de promesses lorsque nous voulons r√©aliser une s√©quence de promesses. <br><br>  Par exemple: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { resolve(<span class="hljs-string"><span class="hljs-string">'Promise1 '</span></span>); }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { resolve(<span class="hljs-string"><span class="hljs-string">'Promise2 '</span></span>); }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise3 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { reject(<span class="hljs-string"><span class="hljs-string">'Promise3 '</span></span>); }); promise1 .then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data); <span class="hljs-comment"><span class="hljs-comment">// Promise1  return promise2; }) .then((data) =&gt; { console.log(data); // Promise2  return promise3; }) .then((data) =&gt; { console.log(data); }) .catch((error) =&gt; { console.log(error); // Promise3  });</span></span></code> </pre> <br><h4>  Alors qu'est-ce qui se passe ici? </h4><br>  Lorsque la <i>promesse1 est</i> remplie, la m√©thode <i>then ()</i> est appel√©e <i>,</i> qui renvoie la promesse2. <br>  Ensuite, lorsque la <i>promesse2</i> est <i>remplie</i> , <i>()</i> est √† nouveau appel√© et renvoie la <i>promesse3</i> . <br><br>  Puisque promise3 est rejet√©, au lieu du suivant <i>alors ()</i> , <i>catch ()</i> est appel√©, qui g√®re le rejet de <i>promise3</i> . <br><br>  <b>Remarque:</b> En r√®gle g√©n√©rale, une m√©thode <i>catch ()</i> suffit pour g√©rer le rejet de l'une des promesses de la cha√Æne, si cette m√©thode est √† la fin. <br><br><h4>  Erreur courante </h4><br>  Beaucoup de nouveaux arrivants font une erreur en investissant des promesses √† l'int√©rieur des autres.  Par exemple: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { resolve(<span class="hljs-string"><span class="hljs-string">'Promise1 '</span></span>); }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { resolve(<span class="hljs-string"><span class="hljs-string">'Promise2 '</span></span>); }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise3 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { reject(<span class="hljs-string"><span class="hljs-string">'Promise3 '</span></span>); }); promise1.then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data); <span class="hljs-comment"><span class="hljs-comment">// Promise1  promise2.then((data) =&gt; { console.log(data); // Promise2  promise3.then((data) =&gt; { console.log(data); }).catch((error) =&gt; { console.log(error); // Promise3  }); }).catch((error) =&gt; { console.log(error); }) }).catch((error) =&gt; { console.log(error); });</span></span></code> </pre> <br>  Bien que cela fonctionne correctement, il est consid√©r√© comme un mauvais style et rend le code moins lisible.  Si vous avez une s√©quence de promesses √† ex√©cuter, il vaudra mieux les mettre l'une apr√®s l'autre que de les mettre l'une dans l'autre. <br><br><h3>  Promise.all () </h3><br>  Cette m√©thode prend un tableau de promesses et renvoie une nouvelle promesse qui sera ex√©cut√©e lorsque toutes les promesses √† l'int√©rieur du tableau seront ex√©cut√©es ou rejet√©es d√®s qu'une promesse rejet√©e sera trouv√©e.  Par exemple: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { resolve(<span class="hljs-string"><span class="hljs-string">'Promise1 '</span></span>); }, <span class="hljs-number"><span class="hljs-number">2000</span></span>); }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { resolve(<span class="hljs-string"><span class="hljs-string">'Promise2 '</span></span>); }, <span class="hljs-number"><span class="hljs-number">1500</span></span>); }); <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all([promise1, promise2]) .then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data[<span class="hljs-number"><span class="hljs-number">0</span></span>], data[<span class="hljs-number"><span class="hljs-number">1</span></span>])) .catch(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(error));</code> </pre> <br>  Ici, l'argument √† l'int√©rieur de <i>then ()</i> est un tableau qui contient les valeurs des promesses dans le m√™me ordre dans lequel elles ont √©t√© pass√©es √† <i>Promise.all ()</i> . (Seulement si toutes les promesses sont ex√©cut√©es) <br><br>  La promesse est rejet√©e avec la cause du rejet de la premi√®re promesse dans le tableau transf√©r√©.  Par exemple: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { resolve(<span class="hljs-string"><span class="hljs-string">'Promise1 '</span></span>); }, <span class="hljs-number"><span class="hljs-number">2000</span></span>); }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { reject(<span class="hljs-string"><span class="hljs-string">'Promise2 '</span></span>); }, <span class="hljs-number"><span class="hljs-number">1500</span></span>); }); <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all([promise1, promise2]) .then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data[<span class="hljs-number"><span class="hljs-number">0</span></span>], data[<span class="hljs-number"><span class="hljs-number">1</span></span>])) .catch(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(error)); <span class="hljs-comment"><span class="hljs-comment">// Promise2 </span></span></code> </pre> <br>  Ici, nous avons deux promesses, o√π l'une est ex√©cut√©e apr√®s 2 secondes et l'autre s'√©carte apr√®s 1,5 seconde.  D√®s que la deuxi√®me promesse est rejet√©e, la <i>promesse</i> renvoy√©e par <i>Promise.all ()</i> est rejet√©e sans attendre la premi√®re. <br><br>  Cette m√©thode peut √™tre utile lorsque vous avez plusieurs promesses et que vous souhaitez savoir quand toutes les promesses sont termin√©es.  Par exemple, si vous demandez des donn√©es √† une API tierce et que vous souhaitez faire quelque chose avec ces donn√©es uniquement lorsque toutes les demandes ont abouti. <br><br>  Par cons√©quent, nous avons <i>Promise.all ()</i> , qui attend l'ex√©cution r√©ussie de toutes les promesses, ou termine son ex√©cution lorsqu'il d√©tecte le premier √©chec dans le tableau de promesses. <br><br><h3>  Promise.race () </h3><br>  Cette m√©thode accepte un tableau de promesses et renvoie une nouvelle promesse qui sera ex√©cut√©e d√®s que la promesse remplie dans le tableau sera remplie ou rejet√©e si la promesse rejet√©e se produit plus t√¥t.  Par exemple: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { resolve(<span class="hljs-string"><span class="hljs-string">'Promise1 '</span></span>); }, <span class="hljs-number"><span class="hljs-number">1000</span></span>); }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { reject(<span class="hljs-string"><span class="hljs-string">'Promise2 '</span></span>); }, <span class="hljs-number"><span class="hljs-number">1500</span></span>); }); <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.race([promise1, promise2]) .then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data)) <span class="hljs-comment"><span class="hljs-comment">// Promise1  .catch((error) =&gt; console.log(error));</span></span></code> </pre> <br>  Ici, nous avons deux promesses, o√π l'une est ex√©cut√©e apr√®s 1 seconde et l'autre s'√©carte apr√®s 1,5 seconde.  D√®s que la premi√®re promesse est remplie, la promesse renvoy√©e par Promise.race () aura le statut rempli sans attendre le statut de la deuxi√®me promesse. <br><br>  Ici, les <i>donn√©es</i> qui sont pass√©es √† <i>then ()</i> sont la valeur de la premi√®re promesse ex√©cut√©e. <br><br>  Par cons√©quent, <i>Promise.race ()</i> attend la premi√®re promesse et prend son statut comme le statut de la promesse retourn√©e. <br><br>  <i>Commentaire de l'auteur de la traduction: D'o√π le nom lui-m√™me.</i>  <i>Race - Race</i> <br><br><h2>  Conclusion </h2><br>  Nous avons appris quelles sont les promesses et ce qu'elles mangent en JavaScript.  Les promesses se composent de deux parties 1) Cr√©ez une promesse et 2) Utilisez une promesse.  La plupart du temps, vous utiliserez des promesses plut√¥t que de les cr√©er, mais il est important de savoir comment elles sont cr√©√©es. <br><br>  C'est tout, j'esp√®re que cet article vous a √©t√© utile! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr439746/">https://habr.com/ru/post/fr439746/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr439734/index.html">D√©ployer Kubernetes sur le bureau en quelques minutes avec MicroK8s</a></li>
<li><a href="../fr439736/index.html">Connexion VPN IPSec entre MikroTik et Kerio Control</a></li>
<li><a href="../fr439738/index.html">A la recherche du bouton "Bien faire". Zyxel dans le r√©seau des petites et moyennes entreprises</a></li>
<li><a href="../fr439742/index.html">Admission au programme Master JetBrains √† l'Universit√© ITMO</a></li>
<li><a href="../fr439744/index.html">Des chercheurs du MIT ont con√ßu une ¬´rectenne¬ª qui convertit les signaux Wi-Fi en √©lectricit√©</a></li>
<li><a href="../fr439748/index.html">Le condens√© de mat√©riaux int√©ressants pour le d√©veloppeur mobile # 285 (du 4 au 10 f√©vrier)</a></li>
<li><a href="../fr439750/index.html">Apprenez la gestion des produits - o√π?</a></li>
<li><a href="../fr439752/index.html">IRM multic≈ìur</a></li>
<li><a href="../fr439754/index.html">Google va commencer √† d√©velopper des montres intelligentes</a></li>
<li><a href="../fr439756/index.html">Pourquoi ai-je besoin d'un g√©n√©rateur thermoacoustique?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>