<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥣 🧝🏻 💅🏼 Comprendre les promesses JavaScript 👅 😱 👈🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, Habr! Je vous présente la traduction de l'article «Comprendre les promesses en JavaScript» de Sukhjinder Arora. 



 De l'auteur de la traduc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comprendre les promesses JavaScript</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/439746/">  Bonjour, Habr!  Je vous présente la traduction de l'article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">«Comprendre les promesses en JavaScript»</a> de Sukhjinder Arora. <br><br><img src="https://habrastorage.org/webt/ox/6m/oa/ox6moan9gwhmc2oouqbhyfzumtm.png"><br><a name="habracut"></a><br>  <i>De l'auteur de la traduction: En plus de l'auteur lui-même, j'espère que l'article vous a été utile.</i>  <i>S'il vous plaît, si elle vous a vraiment aidé à apprendre quelque chose de nouveau par vous-même, alors ne soyez pas trop paresseux pour aller à l'article original et remercier l'auteur!</i>  <i>Je serai heureux de vos commentaires!</i> <i><br><br></i>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Lien vers la traduction de l'article sur JavaScript asynchrone du même auteur</a> .</i> <br><br>  JavaScript est un langage de programmation monothread, ce qui signifie qu'une seule chose peut être faite à la fois.  Avant ES6, nous utilisions des rappels pour gérer les tâches asynchrones, telles que les requêtes réseau. <br><br>  En utilisant des promesses, nous pouvons éviter «l'enfer du rappel» et rendre notre code plus propre, plus lisible et plus facile à comprendre. <br><br>  Supposons que nous voulons obtenir des données du serveur de manière asynchrone, en utilisant des rappels, nous ferions quelque chose comme ceci: <br><br><pre><code class="javascript hljs">getData(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(x); getMoreData(x, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">y</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(y); getSomeMoreData(y, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">z</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(z); }); }); });</code> </pre> <br>  Ici, je demande des données au serveur à l'aide de la fonction <i>getData ()</i> , qui reçoit des données à l'intérieur de la fonction de rappel.  À l'intérieur de la fonction de rappel, je demande des données supplémentaires en appelant la fonction <i>getMoreData ()</i> , en passant les données précédentes en argument, etc. <br><br>  C'est ce que nous appelons «l'enfer du rappel», où chaque rappel est imbriqué dans l'autre, et chaque rappel interne dépend de son parent. <br><br>  Nous pouvons réécrire l'extrait ci-dessus en utilisant des promesses: <br><br><pre> <code class="javascript hljs">getData() .then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(x); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getMoreData(x); }) .then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">y</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(y); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getSomeMoreData(y); }) .then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">z</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(z); });</code> </pre> <br>  Vous pouvez voir ce qui est devenu plus lisible qu'avec le premier exemple de rappel. <br><br><h2>  Quelles sont les promesses? </h2><br>  Une promesse (promesse) est un objet qui contient la valeur future d'une opération asynchrone.  Par exemple, si vous demandez des données au serveur, Promis nous promet de recevoir ces données, que nous pourrons utiliser à l'avenir. <br><br>  Avant de plonger dans tous ces trucs techniques, regardons la terminologie des promesses. <br><br><h3>  États promis </h3><br>  Une promesse en JavaScript, comme une promesse dans la vie réelle, a 3 états.  Cela peut être 1) non résolu (en attente), 2) résolu / résolu (terminé) ou 3) rejeté / rejeté. <br><br><img src="https://habrastorage.org/webt/pk/hr/zz/pkhrzzgtdsgqvtptwn26gmtbjhk.png"><br><br>  <b>Non résolu ou en attente</b> - Promis attend si le résultat n'est pas prêt.  Autrement dit, il attend l'achèvement de quelque chose (par exemple, l'achèvement d'une opération asynchrone). <br>  <b>Résolu ou terminé</b> - Promis résolu si le résultat est disponible.  Autrement dit, quelque chose a terminé son exécution (par exemple, une opération asynchrone) et tout s'est bien passé. <br>  <b>Rejeté</b> - Promis rejeté si une erreur s'est produite lors de l'exécution. <br><br>  Maintenant que nous savons ce qu'est Promis et sa terminologie, revenons à la partie pratique des promesses. <br><br><h3>  Créer des promesses </h3><br>  Dans la plupart des cas, vous utiliserez simplement des promesses, pas les créerez, mais il est toujours important de savoir comment elles sont créées. <br><br>  Syntaxe: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { ... });</code> </pre> <br>  Nous avons créé une nouvelle promesse en utilisant le constructeur Promises, cela prend un argument, un rappel, également connu sous le nom de fonction exécutive, qui prend 2 rappels, <i>résoudre</i> et <i>rejeter</i> . <br><br>  La fonction exécutive est exécutée immédiatement après la création de la promesse.  Une promesse est faite en appelant <i>resolver ()</i> et rejetée par <i>reject ()</i> .  Par exemple: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(allWentWell) { resolve(<span class="hljs-string"><span class="hljs-string">'  !'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { reject(<span class="hljs-string"><span class="hljs-string">'-   '</span></span>); } });</code> </pre> <br>  <i>resolver ()</i> et <i>rejeter ()</i> prennent un argument, qui peut être une chaîne, un nombre, une expression logique, un tableau ou un objet. <br><br>  Jetons un coup d'œil à un autre exemple pour bien comprendre comment les promesses sont créées. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> randomNumber = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random(); setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(randomNumber &lt; <span class="hljs-number"><span class="hljs-number">.6</span></span>) { resolve(<span class="hljs-string"><span class="hljs-string">'  !'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { reject(<span class="hljs-string"><span class="hljs-string">'-   '</span></span>); } }, <span class="hljs-number"><span class="hljs-number">2000</span></span>); });</code> </pre> <br>  Ici, j'ai créé une nouvelle promesse en utilisant le constructeur Promis.  Une promesse est exécutée ou rejetée 2 secondes après sa création.  Une promesse est exécutée si <i>randomNumber est</i> inférieur à 0,6 et rejeté dans les autres cas. <br><br>  Lorsqu'une promesse a été créée, elle est en attente et sa valeur n'est pas <i>définie</i> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cs/wr/c2/cswrc2jdrixhaguff2w9oijiyf4.png"></div><br>  Après 2 secondes, le temporisateur se termine, la promesse est exécutée ou rejetée de manière aléatoire, et sa valeur sera celle transmise à la fonction de <i>résolution</i> ou de <i>rejet</i> .  Voici un exemple de deux cas: <br><br>  Achèvement réussi: <br><br><img src="https://habrastorage.org/webt/eq/3y/ss/eq3ysskatvuvjnvpoaz9k7zdmvi.png"><br><br>  Promesse de rejet: <br><br><img src="https://habrastorage.org/webt/qn/7v/ee/qn7vee1ebi19qgo4zzv72tgpfjg.png"><br><br>  <b>Remarque: la</b> promesse ne peut être exécutée ou rejetée qu'une seule fois.  D'autres appels pour <i>résoudre ()</i> ou <i>rejeter ()</i> n'affecteront en aucun cas l'état de la promesse.  Un exemple: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { resolve(<span class="hljs-string"><span class="hljs-string">'Promise resolved'</span></span>); <span class="hljs-comment"><span class="hljs-comment">//   reject('Promise rejected'); //       });</span></span></code> </pre> <br>  Depuis que <i>resolver () a</i> été appelé en premier, la promesse a maintenant le statut «terminée».  L'appel ultérieur à <i>rejeter ()</i> n'affectera en aucun cas l'état de la promesse. <br><br><h3>  Utilisation de Promis </h3><br>  Maintenant, nous savons comment créer des promesses, voyons maintenant comment appliquer la promesse déjà créée.  Nous utilisons des promesses en utilisant les méthodes <i>then ()</i> et <i>catch ()</i> . <br><br>  Par exemple, interroger les données d'une API à l'aide de la <i>récupération</i> , qui renvoie une promesse. <br><br>  <b>syntaxe</b> <i>.then ()</i> <b>:</b> <i>promise.then (successCallback, failureCallback)</i> <br><br>  <i>successCallback</i> est appelé si la promesse a été exécutée avec succès.  Il prend un argument, qui est la valeur transmise à <i>resolver ()</i> . <br><br>  <i>failureCallback</i> est appelé si la promesse a été rejetée.  Il prend un argument, qui est la valeur donnée à <i>rejeter ()</i> . <br><br>  Un exemple: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> randomNumber = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(randomNumber &lt; <span class="hljs-number"><span class="hljs-number">.7</span></span>) { resolve(<span class="hljs-string"><span class="hljs-string">'  !'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { reject(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'-   '</span></span>)); } }); promise.then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data); <span class="hljs-comment"><span class="hljs-comment">//  '  !' }, (error) =&gt; { console.log(error); //   } );</span></span></code> </pre> <br>  Si la promesse a été exécutée, <i>successCallback</i> est <i>appelée</i> avec la valeur transmise à <i>resolver ()</i> .  Et si la promesse a été rejetée, <i>failCallback</i> est <i>appelé</i> avec la valeur passée à rejeter (). <br><br>  <i>Syntaxe .catch ()</i> <b>:</b> <i>promise.catch (failureCallback)</i> <br><br>  Nous utilisons <i>catch ()</i> pour gérer les erreurs.  Ceci est plus lisible que la gestion des erreurs dans <i>failureCallback</i> dans le rappel de la méthode <i>then ()</i> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { reject(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'-   '</span></span>)); }); promise .then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data); }) .catch(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(error); <span class="hljs-comment"><span class="hljs-comment">//   });</span></span></code> </pre> <br><h3>  Chaîne de promesse </h3><br>  Les méthodes <i>then ()</i> et <i>catch ()</i> peuvent également renvoyer une nouvelle promesse, qui peut être traitée par une chaîne d'autres then () à la fin de la méthode then () précédente. <br><br>  Nous utilisons une chaîne de promesses lorsque nous voulons réaliser une séquence de promesses. <br><br>  Par exemple: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { resolve(<span class="hljs-string"><span class="hljs-string">'Promise1 '</span></span>); }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { resolve(<span class="hljs-string"><span class="hljs-string">'Promise2 '</span></span>); }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise3 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { reject(<span class="hljs-string"><span class="hljs-string">'Promise3 '</span></span>); }); promise1 .then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data); <span class="hljs-comment"><span class="hljs-comment">// Promise1  return promise2; }) .then((data) =&gt; { console.log(data); // Promise2  return promise3; }) .then((data) =&gt; { console.log(data); }) .catch((error) =&gt; { console.log(error); // Promise3  });</span></span></code> </pre> <br><h4>  Alors qu'est-ce qui se passe ici? </h4><br>  Lorsque la <i>promesse1 est</i> remplie, la méthode <i>then ()</i> est appelée <i>,</i> qui renvoie la promesse2. <br>  Ensuite, lorsque la <i>promesse2</i> est <i>remplie</i> , <i>()</i> est à nouveau appelé et renvoie la <i>promesse3</i> . <br><br>  Puisque promise3 est rejeté, au lieu du suivant <i>alors ()</i> , <i>catch ()</i> est appelé, qui gère le rejet de <i>promise3</i> . <br><br>  <b>Remarque:</b> En règle générale, une méthode <i>catch ()</i> suffit pour gérer le rejet de l'une des promesses de la chaîne, si cette méthode est à la fin. <br><br><h4>  Erreur courante </h4><br>  Beaucoup de nouveaux arrivants font une erreur en investissant des promesses à l'intérieur des autres.  Par exemple: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { resolve(<span class="hljs-string"><span class="hljs-string">'Promise1 '</span></span>); }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { resolve(<span class="hljs-string"><span class="hljs-string">'Promise2 '</span></span>); }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise3 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { reject(<span class="hljs-string"><span class="hljs-string">'Promise3 '</span></span>); }); promise1.then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data); <span class="hljs-comment"><span class="hljs-comment">// Promise1  promise2.then((data) =&gt; { console.log(data); // Promise2  promise3.then((data) =&gt; { console.log(data); }).catch((error) =&gt; { console.log(error); // Promise3  }); }).catch((error) =&gt; { console.log(error); }) }).catch((error) =&gt; { console.log(error); });</span></span></code> </pre> <br>  Bien que cela fonctionne correctement, il est considéré comme un mauvais style et rend le code moins lisible.  Si vous avez une séquence de promesses à exécuter, il vaudra mieux les mettre l'une après l'autre que de les mettre l'une dans l'autre. <br><br><h3>  Promise.all () </h3><br>  Cette méthode prend un tableau de promesses et renvoie une nouvelle promesse qui sera exécutée lorsque toutes les promesses à l'intérieur du tableau seront exécutées ou rejetées dès qu'une promesse rejetée sera trouvée.  Par exemple: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { resolve(<span class="hljs-string"><span class="hljs-string">'Promise1 '</span></span>); }, <span class="hljs-number"><span class="hljs-number">2000</span></span>); }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { resolve(<span class="hljs-string"><span class="hljs-string">'Promise2 '</span></span>); }, <span class="hljs-number"><span class="hljs-number">1500</span></span>); }); <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all([promise1, promise2]) .then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data[<span class="hljs-number"><span class="hljs-number">0</span></span>], data[<span class="hljs-number"><span class="hljs-number">1</span></span>])) .catch(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(error));</code> </pre> <br>  Ici, l'argument à l'intérieur de <i>then ()</i> est un tableau qui contient les valeurs des promesses dans le même ordre dans lequel elles ont été passées à <i>Promise.all ()</i> . (Seulement si toutes les promesses sont exécutées) <br><br>  La promesse est rejetée avec la cause du rejet de la première promesse dans le tableau transféré.  Par exemple: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { resolve(<span class="hljs-string"><span class="hljs-string">'Promise1 '</span></span>); }, <span class="hljs-number"><span class="hljs-number">2000</span></span>); }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { reject(<span class="hljs-string"><span class="hljs-string">'Promise2 '</span></span>); }, <span class="hljs-number"><span class="hljs-number">1500</span></span>); }); <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all([promise1, promise2]) .then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data[<span class="hljs-number"><span class="hljs-number">0</span></span>], data[<span class="hljs-number"><span class="hljs-number">1</span></span>])) .catch(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(error)); <span class="hljs-comment"><span class="hljs-comment">// Promise2 </span></span></code> </pre> <br>  Ici, nous avons deux promesses, où l'une est exécutée après 2 secondes et l'autre s'écarte après 1,5 seconde.  Dès que la deuxième promesse est rejetée, la <i>promesse</i> renvoyée par <i>Promise.all ()</i> est rejetée sans attendre la première. <br><br>  Cette méthode peut être utile lorsque vous avez plusieurs promesses et que vous souhaitez savoir quand toutes les promesses sont terminées.  Par exemple, si vous demandez des données à une API tierce et que vous souhaitez faire quelque chose avec ces données uniquement lorsque toutes les demandes ont abouti. <br><br>  Par conséquent, nous avons <i>Promise.all ()</i> , qui attend l'exécution réussie de toutes les promesses, ou termine son exécution lorsqu'il détecte le premier échec dans le tableau de promesses. <br><br><h3>  Promise.race () </h3><br>  Cette méthode accepte un tableau de promesses et renvoie une nouvelle promesse qui sera exécutée dès que la promesse remplie dans le tableau sera remplie ou rejetée si la promesse rejetée se produit plus tôt.  Par exemple: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { resolve(<span class="hljs-string"><span class="hljs-string">'Promise1 '</span></span>); }, <span class="hljs-number"><span class="hljs-number">1000</span></span>); }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { reject(<span class="hljs-string"><span class="hljs-string">'Promise2 '</span></span>); }, <span class="hljs-number"><span class="hljs-number">1500</span></span>); }); <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.race([promise1, promise2]) .then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data)) <span class="hljs-comment"><span class="hljs-comment">// Promise1  .catch((error) =&gt; console.log(error));</span></span></code> </pre> <br>  Ici, nous avons deux promesses, où l'une est exécutée après 1 seconde et l'autre s'écarte après 1,5 seconde.  Dès que la première promesse est remplie, la promesse renvoyée par Promise.race () aura le statut rempli sans attendre le statut de la deuxième promesse. <br><br>  Ici, les <i>données</i> qui sont passées à <i>then ()</i> sont la valeur de la première promesse exécutée. <br><br>  Par conséquent, <i>Promise.race ()</i> attend la première promesse et prend son statut comme le statut de la promesse retournée. <br><br>  <i>Commentaire de l'auteur de la traduction: D'où le nom lui-même.</i>  <i>Race - Race</i> <br><br><h2>  Conclusion </h2><br>  Nous avons appris quelles sont les promesses et ce qu'elles mangent en JavaScript.  Les promesses se composent de deux parties 1) Créez une promesse et 2) Utilisez une promesse.  La plupart du temps, vous utiliserez des promesses plutôt que de les créer, mais il est important de savoir comment elles sont créées. <br><br>  C'est tout, j'espère que cet article vous a été utile! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr439746/">https://habr.com/ru/post/fr439746/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr439734/index.html">Déployer Kubernetes sur le bureau en quelques minutes avec MicroK8s</a></li>
<li><a href="../fr439736/index.html">Connexion VPN IPSec entre MikroTik et Kerio Control</a></li>
<li><a href="../fr439738/index.html">A la recherche du bouton "Bien faire". Zyxel dans le réseau des petites et moyennes entreprises</a></li>
<li><a href="../fr439742/index.html">Admission au programme Master JetBrains à l'Université ITMO</a></li>
<li><a href="../fr439744/index.html">Des chercheurs du MIT ont conçu une «rectenne» qui convertit les signaux Wi-Fi en électricité</a></li>
<li><a href="../fr439748/index.html">Le condensé de matériaux intéressants pour le développeur mobile # 285 (du 4 au 10 février)</a></li>
<li><a href="../fr439750/index.html">Apprenez la gestion des produits - où?</a></li>
<li><a href="../fr439752/index.html">IRM multicœur</a></li>
<li><a href="../fr439754/index.html">Google va commencer à développer des montres intelligentes</a></li>
<li><a href="../fr439756/index.html">Pourquoi ai-je besoin d'un générateur thermoacoustique?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>