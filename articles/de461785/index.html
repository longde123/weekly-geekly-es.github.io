<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§µ ü•â üë®üèæ‚Äçüíª RISC-V Nachteile ‚òéÔ∏è üè∏ üí™üèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Urspr√ºnglich habe ich dieses Dokument vor einigen Jahren als Ausf√ºhrungskern-Verifizierungsingenieur in ARM geschrieben. Nat√ºrlich wurde meine Meinung...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>RISC-V Nachteile</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/461785/">  Urspr√ºnglich habe ich dieses Dokument vor einigen Jahren als Ausf√ºhrungskern-Verifizierungsingenieur in ARM geschrieben.  Nat√ºrlich wurde meine Meinung durch die eingehende Arbeit mit den Executive Cores verschiedener Prozessoren beeinflusst.  Machen Sie es also bitte f√ºr einen Rabatt: Vielleicht bin ich zu kategorisch. <br><br>  Ich glaube jedoch immer noch, dass die Entwickler von RISC-V es viel besser machen k√∂nnten.  Wenn ich heute einen 32-Bit- oder 64-Bit-Prozessor entworfen h√§tte, h√§tte ich wahrscheinlich eine solche Architektur implementiert, um die vorhandenen Tools zu nutzen. <br><br>  Der Artikel beschrieb urspr√ºnglich den RISC-V 2.0-Befehlssatz.  F√ºr Version 2.2 wurden einige Aktualisierungen vorgenommen. <br><a name="habracut"></a><br><h1>  Urspr√ºngliches Vorwort: Einige pers√∂nliche Meinungen </h1><br>  Der RISC-V-Befehlssatz wurde auf ein absolutes Minimum reduziert.  Viel Aufmerksamkeit wird der Minimierung der Anzahl von Anweisungen, der Normalisierung der Codierung usw. gewidmet. Dieser Wunsch nach Minimalismus hat zu falscher Orthogonalit√§t (wie der Wiederverwendung derselben Anweisung f√ºr √úberg√§nge, Aufrufe und R√ºckgaben) und obligatorischer Ausf√ºhrlichkeit gef√ºhrt, was sowohl Gr√∂√üe als auch Menge erh√∂ht Anweisungen. <br><br>  Hier ist zum Beispiel der C-Code: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readidx</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *p, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> idx)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p[idx]; }</code> </pre> <br>  Dies ist ein einfacher Fall der Indizierung eines Arrays, eine sehr h√§ufige Operation.  Dies ist die Kompilierung f√ºr x86_64: <br><br><pre> <code class="plaintext hljs">mov eax, [rdi+rsi*4] ret</code> </pre> <br>  oder ARM: <br><br><pre> <code class="plaintext hljs">ldr r0, [r0, r1, lsl #2] bx lr // return</code> </pre> <br>  F√ºr RISC-V ist jedoch der folgende Code erforderlich: <br><br><pre> <code class="plaintext hljs">slli a1, a1, 2 add a0, a1, a1 lw a0, a0, 0 jalr r0, r1, 0 // return</code> </pre> <br>  Vereinfachung RISC-V vereinfacht den Decoder (d. H. Das CPU-Front-End) durch Ausf√ºhren weiterer Anweisungen.  Das Skalieren der Breite der Pipeline ist jedoch ein schwieriges Problem, w√§hrend das Decodieren von leicht (oder stark) unregelm√§√üigen Befehlen gut implementiert ist (die Hauptschwierigkeit tritt auf, wenn es schwierig ist, die L√§nge des Befehls zu bestimmen: Dies wird besonders im x86-Befehlssatz mit zahlreichen Pr√§fixen deutlich). <br><br>  Die Vereinfachung der Anweisungen sollte nicht an ihre Grenzen gebracht werden.  Register und Registeraddition mit einer Verschiebung des Registerspeichers ist eine einfache und sehr h√§ufige Anweisung in Programmen, und es ist f√ºr den Prozessor sehr einfach, sie effektiv zu implementieren.  Wenn der Prozessor den Befehl nicht direkt implementieren kann, kann es relativ einfach sein, ihn in seine Komponenten zu zerlegen.  Dies ist ein viel einfacheres Problem als das Zusammenf√ºhren von Sequenzen einfacher Operationen. <br><br>  Wir m√ºssen zwischen ‚Äûkomplexen‚Äú spezifischen Anweisungen von CISC-Prozessoren - komplizierten, selten verwendeten und ineffizienten Anweisungen - und ‚Äûfunktionalen‚Äú Anweisungen unterscheiden, die CISC- und RISC-Prozessoren gemeinsam sind und eine kleine Folge von Operationen kombinieren.  Letztere werden h√§ufig und mit hoher Leistung eingesetzt. <br><br><h1>  Mittelm√§√üige Umsetzung </h1><br><ul><li>  Fast unbegrenzte Erweiterbarkeit.  Obwohl dies das Ziel von RISC-V ist, entsteht ein fragmentiertes, inkompatibles √ñkosystem, das mit √§u√üerster Vorsicht verwaltet werden muss. <br></li><li>  Der gleiche Befehl ( <code>JALR</code> ) wird f√ºr Aufrufe und f√ºr R√ºckgaben sowie f√ºr registerindirekte Verzweigungen verwendet, bei denen eine zus√§tzliche Decodierung f√ºr die Verzweigungsvorhersage erforderlich ist <br><ul><li>  Rufen Sie an: <code>Rd</code> = <code>R1</code> <br></li><li>  R√ºckgabe: <code>Rd</code> = <code>R0</code> , <code>Rs</code> = <code>R1</code> <br></li><li>  Indirekter √úbergang: <code>Rd</code> = <code>R0</code> , <code>Rs</code> ‚â† <code>R1</code> <br></li><li>  (Seltsamer √úbergang: <code>Rd</code> ‚â† <code>R0</code> , <code>Rd</code> ‚â† <code>R1</code> ) </li></ul></li><li>  Die Codierung mit variabler L√§nge des Aufzeichnungsfelds synchronisiert sich nicht selbst (dies ist h√§ufig - beispielsweise ein √§hnliches Problem mit x86 und Thumb-2 -, verursacht jedoch verschiedene Probleme sowohl bei der Implementierung als auch bei der Sicherheit, z. B. bei der r√ºckw√§rtsorientierten Programmierung, d. H. ROP-Angriffen ) <br></li><li>  RV64I erfordert eine Zeichenerweiterung f√ºr alle 32-Bit-Werte.  Dies f√ºhrt dazu, dass die obere H√§lfte von 64-Bit-Registern nicht mehr zum Speichern von Zwischenergebnissen verwendet werden kann, was zu einer unn√∂tigen speziellen Platzierung der oberen H√§lfte der Register f√ºhrt.  Es ist optimaler, die Erweiterung mit Nullen zu verwenden (da sie die Anzahl der Schalter verringert und normalerweise optimiert werden kann, indem das "Null" -Bit verfolgt wird, wenn bekannt ist, dass die obere H√§lfte Null ist). <br></li><li>  Die Multiplikation ist optional.  Obwohl schnelle Multiplikationsbl√∂cke auf winzigen Kristallen einen betr√§chtlichen Bereich einnehmen k√∂nnen, k√∂nnen Sie immer etwas langsamere Schaltkreise verwenden, die die vorhandene ALU f√ºr mehrere Multiplikationszyklen aktiv nutzen. <br></li><li>  <code>LR</code> / <code>SC</code> strenge Fortschrittsanforderungen f√ºr eine begrenzte Teilmenge von Anwendungen.  Obwohl diese Einschr√§nkung recht streng ist, f√ºhrt sie m√∂glicherweise zu Problemen bei kleinen Implementierungen (insbesondere ohne Cache). <br><ul><li>  Dies scheint ein Ersatz f√ºr die CAS-Anweisung zu sein, siehe Kommentar unten </li></ul></li><li>  Die Speicher-Sticky-Bits FP und der Rundungsmodus befinden sich im selben Register.  Dies erfordert eine Serialisierung des FP-Kanals, wenn die RMW-Operation ausgef√ºhrt wird, um den Rundungsmodus zu √§ndern. <br></li><li>  <code>FP</code> Befehle sind f√ºr eine Genauigkeit von 32, 64 und 128 Bit codiert, jedoch nicht f√ºr 16 Bit (was in der Hardware weitaus h√§ufiger vorkommt als 128 Bit). <br><ul><li>  Dies kann leicht behoben werden: Code der Dimension <code>0b10</code> frei. <br></li><li>  <i>Update:</i> In Version 2.2 wurde ein <i>Dezimalplatzhalter</i> angezeigt, es gibt jedoch keinen Platzhalter mit halber Genauigkeit.  Der Geist ist unverst√§ndlich. </li></ul></li><li>  Die Art und Weise, wie FP-Werte in der FP-Registerdatei dargestellt werden, ist nicht definiert, aber beobachtbar (√ºber Laden / Speichern). <br><ul><li>  Emulatorautoren werden dich hassen <br></li><li>  Die Migration virtueller Maschinen kann unm√∂glich werden <br></li><li>  <i>Update:</i> Version 2.2 erfordert breitere NaN-Boxing-Werte </li></ul></li></ul><br><h1>  Schlecht </h1><br><ul><li>  Es gibt keine Bedingungscodes, stattdessen werden die Anweisungen zum Vergleichen und Verzweigen verwendet.  Dies ist an sich kein Problem, aber die Folgen sind unangenehm: <br><ul><li>  Reduzierter Codierungsraum in bedingten Verzweigungen aufgrund der Notwendigkeit, einen oder zwei Registerspezifizierer zu codieren <br></li><li>  Keine bedingte Auswahl (n√ºtzlich f√ºr sehr unvorhersehbare √úberg√§nge) <br></li><li>  Keine √úbertragung / Subtraktion mit √úbertragung oder Ausleihe <br></li><li>  (Beachten Sie, dass dies immer noch besser ist als Befehlss√§tze, die Flags in das allgemeine Register schreiben und dann zu den empfangenen Flags wechseln.) </li></ul></li><li>  Es scheint, dass in einem nicht privilegierten ISA hochpr√§zise Z√§hler (Hardware-Zyklen) <i>erforderlich sind</i> .  In der Praxis ist die Bereitstellung von Anwendungen ein hervorragender Vektor f√ºr Angriffe auf Kan√§le von Drittanbietern <br></li><li>  Multiplikation und Division sind Teil derselben Erweiterung, und es scheint, dass, wenn eine implementiert ist, die andere ebenfalls implementiert werden sollte.  Die Multiplikation ist viel einfacher als die Division und bei den meisten Prozessoren √ºblich, die Division jedoch nicht. <br></li><li>  Die grundlegende Befehlssatzarchitektur enth√§lt keine atomaren Anweisungen.  Multi-Core-Mikrocontroller werden immer h√§ufiger eingesetzt, sodass atomare Anweisungen wie LL / SC kosteng√ºnstig sind (f√ºr eine minimale Implementierung in einem einzelnen [Multi-Core] -Prozessor wird nur 1 Bit Prozessorstatus ben√∂tigt). <br></li><li>  <code>LR</code> / <code>SC</code> befinden sich in derselben Erweiterung wie komplexere atomare Anweisungen, was die Flexibilit√§t f√ºr kleine Implementierungen einschr√§nkt <br></li><li>  Allgemeine atomare Anweisungen (nicht <code>LR</code> / <code>SC</code> ) enthalten kein <code>CAS</code> Grundelement <br><ul><li>  Der <code>CmpHi:CmpLo</code> darin, die Notwendigkeit eines Befehls zu vermeiden, der f√ºnf Register liest ( <code>Addr</code> , <code>CmpHi:CmpLo</code> , <code>SwapHi:SwapLo</code> ), aber dies wird wahrscheinlich weniger Implementierungsaufwand verursachen als der garantierte Vorw√§rts- <code>LR</code> / <code>SC</code> , der als bereitgestellt wird Ersatz </li></ul></li><li>  Es werden atomare Anweisungen angeboten, die mit 32-Bit- und 64-Bit-Werten arbeiten, jedoch nicht mit 8-Bit- oder 16-Bit-Werten <br></li><li>  F√ºr RV32I gibt es keine M√∂glichkeit, den DP-FP-Wert zwischen einer Ganzzahl- und einer FP-Registerdatei zu √ºbertragen, au√üer √ºber den Speicher, dh aus 32-Bit-Ganzzahlregistern ist es unm√∂glich, eine 64-Bit-Gleitkommazahl mit doppelter Genauigkeit zu erstellen. Sie m√ºssen zuerst den Zwischenwert in den Speicher schreiben und laden ihn von dort in die Registerdatei <br></li><li>  Beispielsweise haben der 32-Bit- <code>ADD</code> Befehl in RV32I und der 64-Bit- <code>ADD</code> Befehl in RVI64 die gleichen Codierungen, und in RVI64 wird eine weitere <code>ADD.W</code> Codierung <code>ADD.W</code> .  Dies ist eine unn√∂tige Komplikation f√ºr einen Prozessor, der beide Anweisungen implementiert. Es w√§re vorzuziehen, stattdessen eine neue 64-Bit-Codierung hinzuzuf√ºgen. <br></li><li>  Keine <code>MOV</code> Anweisungen.  Der Mnemonikcode des <code>MV</code> Befehls wird vom Assembler in den Befehl <code>MV rD, rS</code> -&gt; <code>ADDI rD, rS, 0</code> .  Hochleistungsprozessoren optimieren in der Regel <code>MOV</code> Anweisungen, w√§hrend sie Anweisungen umfassend neu anordnen.  Als kanonische Form des <code>MV</code> Befehls in RISC-V wurde ein Befehl mit einem direkten 12-Bit-Operanden gew√§hlt. <br><ul><li>  In Abwesenheit von <code>MOV</code> der <code>ADD rD, rS, r0</code> Befehl <code>ADD rD, rS, r0</code> dem kanonischen <code>MOV</code> tats√§chlich vorzuziehen, da es einfacher zu decodieren ist und Operationen mit dem Nullregister (r0) in der CPU normalerweise optimiert werden </li></ul></li></ul><br><h1>  Schrecklich </h1><br><ul><li>  <code>JAL</code> 5 Bits f√ºr die Codierung des Kommunikationsregisters aus, was immer gleich <code>R1</code> (oder <code>R0</code> f√ºr √úberg√§nge). <br><ul><li>  Dies bedeutet, dass der RV32I eine 21-Bit-Verzweigungsverschiebung verwendet.  Dies reicht f√ºr gro√üe Anwendungen - beispielsweise Webbrowser - nicht aus, ohne mehrere Befehlssequenzen und / oder ‚ÄûZweiginseln‚Äú zu verwenden. <br></li><li>  Dies ist eine Verschlechterung gegen√ºber Version 1.0 der Befehlsarchitektur! </li></ul></li><li>  Trotz des gro√üen Aufwands f√ºr eine einheitliche Codierung werden Lade- / Speicheranweisungen unterschiedlich codiert (Gro√ü- und Kleinschreibung und unmittelbare Felder √§ndern sich). <br><ul><li>  Offensichtlich war die Codierungsorthogonalit√§t des Ausgangsregisters der Codierungsorthogonalit√§t von zwei stark verwandten Befehlen vorzuziehen.  Diese Wahl erscheint etwas seltsam, da die Adressgenerierung zeitkritischer ist. </li></ul></li><li>  Es gibt keine Anweisungen zum Laden des Speichers mit Registervers√§tzen ( <code>Rbase</code> + <code>Roffset</code> ) oder Indizes ( <code>Rbase</code> + <code>Rindex</code> &lt;&lt; <code>Scale</code> ). <br></li><li>  <code>FENCE.I</code> impliziert eine vollst√§ndige Synchronisation des Anweisungscaches mit allen vorherigen Repositorys, mit oder ohne eingez√§unt.  Implementierungen m√ºssen entweder alle I $ auf dem Zaun l√∂schen oder nach D $ und dem Speicherpuffer suchen <br></li><li>  In RV32I erfordert das Lesen von 64-Bit-Z√§hlern das zweimalige Lesen der oberen H√§lfte, das Vergleichen und Verzweigen im Fall einer √úbertragung zwischen der unteren und oberen H√§lfte w√§hrend eines Lesevorgangs <br><ul><li>  Typischerweise enthalten 32-Bit-ISAs einen Befehl zum Lesen eines speziellen Paarregisters, um dieses Problem zu vermeiden. </li></ul></li><li>  Es gibt keinen architektonisch definierten Speicherplatz f√ºr die Hinweiscodierung, sodass Anweisungen aus diesem Speicherplatz auf √§lteren Prozessoren (die als <code>NOP</code> verarbeitet werden) keinen Fehler verursachen, sondern auf den modernsten CPUs <br><ul><li>  Typische Beispiele f√ºr reine NOP-Hinweise sind Dinge wie die Spinlock-Ausbeute <br></li><li>  Neuere Prozessoren haben auch komplexere Hinweise (mit sichtbaren Nebenwirkungen auf den neueren Prozessoren; z. B. werden Anweisungen zur x86-Rahmenpr√ºfung im Hinweisbereich codiert, damit die Bin√§rdateien abw√§rtskompatibel bleiben). </li></ul></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de461785/">https://habr.com/ru/post/de461785/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de461771/index.html">Sag nein zum Schweigen: vom Kinderzimmer ins B√ºro</a></li>
<li><a href="../de461773/index.html">Airtest IDE - eine neue Methode zum Testen der Automatisierung mobiler Spiele?</a></li>
<li><a href="../de461775/index.html">3 F√§lle f√ºr die Verwendung von Sellerie in einer Django-Anwendung</a></li>
<li><a href="../de461779/index.html">80% Ihrer Unternehmensdaten stehen Ihnen nicht zur Verf√ºgung. Was tun?</a></li>
<li><a href="../de461781/index.html">"Ycombinator Startup School 2019." Video der ersten drei Wochen</a></li>
<li><a href="../de461787/index.html">Android-Textanzeige</a></li>
<li><a href="../de461793/index.html">Ivan Ponomarev √ºber die Kafka Streams API bei jug.msk.ru</a></li>
<li><a href="../de461797/index.html">Geschichten des Dienstes. Ein leichtfertiger Beitrag √ºber ernsthafte Arbeit</a></li>
<li><a href="../de461801/index.html">DisplayPort-LVDS</a></li>
<li><a href="../de461803/index.html">Datenversionskontrolle (DVC): Datenversionierung und Experimentierreproduzierbarkeit</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>