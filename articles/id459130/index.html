<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ—³ï¸ ğŸŒ¾ â˜¢ï¸ Penanganan kesalahan yang lembut di layanan microser ğŸ˜³ ğŸ‘¨ğŸ»â€ğŸ”¬ ğŸ‘¨â€ğŸ‘§â€ğŸ‘¦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Artikel tersebut menunjukkan cara menerapkan penanganan kesalahan dan pencatatan berdasarkan prinsip "Dibuat dan Lupa" di Go. Metode ini dirancang unt...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Penanganan kesalahan yang lembut di layanan microser</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459130/"><p>  Artikel tersebut menunjukkan cara menerapkan penanganan kesalahan dan pencatatan berdasarkan prinsip "Dibuat dan Lupa" di Go.  Metode ini dirancang untuk layanan microser on Go, bekerja dalam wadah Docker dan dibangun sesuai dengan prinsip-prinsip Arsitektur Bersih. </p><a name="habracut"></a><br><p>  Artikel ini adalah versi terperinci dari laporan dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pertemuan Go</a> baru-baru ini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di Kazan</a> .  Jika Anda tertarik dengan Go dan tinggal di Kazan, Innopolis, Yoshkar-Ola yang cantik atau di kota lain terdekat, Anda harus mengunjungi halaman komunitas: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">golangkazan.github.io</a> . </p><br><p>  Pada pertemuan tersebut, tim kami dalam dua laporan menunjukkan bagaimana kami mengembangkan layanan microser on Go - prinsip apa yang kami ikuti dan bagaimana kami menyederhanakan hidup kami.  Artikel ini berfokus pada konsep kami tentang penanganan kesalahan, yang sekarang kami sampaikan ke semua layanan Microsoft baru kami. </p><br>
<h2 id="soglasheniya-o-strukture-mikroservisa">  Perjanjian Struktur Layanan Mikro </h2><br><p>  Sebelum menyentuh aturan untuk penanganan kesalahan, ada baiknya memutuskan batasan apa yang kami amati saat mendesain dan mengkode.  Untuk melakukan ini, ada baiknya memberi tahu seperti apa bentuk layanan microser kami. </p><br><p>  Pertama-tama, kami menghormati arsitektur yang bersih.  Kami membagi kode menjadi tiga level dan mengamati aturan dependensi: paket pada level yang lebih dalam tidak tergantung pada paket eksternal dan tidak ada dependensi siklik.  Untungnya, dependensi round-robin langsung dari paket dilarang di Go.  Ketergantungan tidak langsung melalui terminologi peminjaman, asumsi tentang perilaku atau casting ke suatu tipe masih dapat muncul, mereka harus dihindari. </p><br><p>  Beginilah level kami terlihat: </p><br><ol><li>  Level domain berisi aturan logika bisnis yang ditentukan oleh area subjek. <br><ul><li>  terkadang kita melakukannya tanpa domain jika tugasnya sederhana </li><li>  <em>aturan:</em> kode di tingkat domain hanya tergantung pada kemampuan Go, perpustakaan Go standar dan perpustakaan yang dipilih yang memperluas bahasa Go </li></ul></li><li>  Lapisan aplikasi berisi aturan logika bisnis yang ditentukan oleh tugas aplikasi. <br><ul><li>  <em>aturan:</em> kode di tingkat aplikasi mungkin tergantung pada domain </li></ul></li><li>  Level infrastruktur berisi kode infrastruktur yang menghubungkan aplikasi dengan berbagai teknologi untuk penyimpanan (MySQL, Redis), transportasi (GRPC, HTTP), interaksi dengan lingkungan eksternal dan dengan layanan lainnya <br><ul><li>  <em>aturan:</em> kode di tingkat infrastruktur mungkin tergantung pada domain dan aplikasi </li><li>  <em>aturan:</em> hanya satu teknologi per paket Go </li></ul></li><li>  Paket utama membuat semua objek - "singleton seumur hidup", menghubungkan mereka bersama dan meluncurkan coroutine berumur panjang - misalnya, ia mulai memproses permintaan HTTP dari port 8081 </li></ol><br><p>  Ini adalah bagaimana struktur direktori microservice terlihat (bagian di mana kode Go): </p><br><p><img src="https://habrastorage.org/webt/dk/ft/id/dkftidhxmqh30yy9zbdaeajfbgy.png" alt="Gambar: Go Project Tree"></p><br><p>  Untuk setiap konteks aplikasi (modul), struktur paket terlihat seperti ini: </p><br><ul><li> paket aplikasi mendeklarasikan antarmuka Layanan yang berisi semua tindakan yang mungkin dilakukan pada tingkat tertentu yang mengimplementasikan antarmuka struktur layanan dan fungsi <code>func NewService(...) Service</code> </li><li>  isolasi pekerjaan dengan database dicapai karena kenyataan bahwa domain atau paket aplikasi mendeklarasikan antarmuka Repositori, yang diimplementasikan pada tingkat infrastruktur dalam paket dengan nama visual "mysql" </li><li>  kode transportasi terletak di paket <code>infrastructure/transport</code> <br><ul><li>  kami menggunakan GRPC, sehingga stubs server dihasilkan dari file proto (mis. antarmuka server, struktur Respons / Permintaan dan semua kode interaksi klien) </li></ul></li></ul><br><p>  Semua ini ditunjukkan dalam diagram: </p><br><p><img src="https://habrastorage.org/webt/-p/gm/hi/-pgmhid0ohkvijl2zmghnlokz7y.png" alt="Gambar: Buka Diagram Paket Proyek"></p><br><h2 id="principy-obrabotki-oshibok">  Prinsip penanganan kesalahan </h2><br><p>  Semuanya sederhana di sini: </p><br><ol><li>  Kami percaya bahwa kesalahan dan panik terjadi saat memproses permintaan ke API - yang berarti bahwa kesalahan atau panik hanya memengaruhi satu permintaan </li><li>  Kami percaya bahwa log hanya diperlukan untuk analisis insiden (dan ada debugger untuk debugging), oleh karena itu, informasi tentang permintaan diterima dalam log, dan, pertama-tama, kesalahan tak terduga saat memproses permintaan </li><li>  Kami percaya bahwa seluruh infrastruktur dibangun untuk memproses log (misalnya, berdasarkan pada ELK) - dan layanan mikro memainkan peran pasif di dalamnya, menulis log ke stderr </li></ol><br><p>  Kami tidak akan fokus pada kepanikan: jangan lupa untuk menangani kepanikan di setiap goroutine dan selama pemrosesan setiap permintaan, setiap pesan, setiap tugas asinkron yang diluncurkan oleh permintaan.  Hampir selalu panik bisa berubah menjadi kesalahan untuk mencegah seluruh aplikasi selesai. </p><br><h2 id="idioma-sentinel-errors">  Kesalahan Idiom Sentinel </h2><br><p>  Pada tingkat logika bisnis, hanya kesalahan yang diharapkan yang ditentukan oleh aturan bisnis yang diproses.  Sentinel Errors akan membantu Anda mengidentifikasi kesalahan seperti itu - kami menggunakan idiom ini alih-alih menulis tipe data kami sendiri untuk kesalahan.  Contoh: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> app <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"errors"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ErrNoCake = errors.New(<span class="hljs-string"><span class="hljs-string">"no cake found"</span></span>)</code> </pre> <br><p>  Variabel global dideklarasikan di sini, yang, atas persetujuan tuan kita, kita tidak boleh berubah di mana pun.  Jika Anda tidak menyukai variabel global dan menggunakan linter untuk mendeteksinya, maka Anda dapat bertahan dengan beberapa konstanta, seperti yang disarankan Dave Cheney di pos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kesalahan Konstan</a> : </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> app <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Error <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e Error)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Error</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>(e) } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ErrNoCake = Error(<span class="hljs-string"><span class="hljs-string">"no cake found"</span></span>)</code> </pre> <br><blockquote>  Jika Anda menyukai pendekatan ini, Anda mungkin ingin menambahkan jenis <code>ConstError</code> ke pustaka bahasa Go perusahaan Anda. </blockquote><br><h2 id="kompoziciya-oshibok">  Komposisi kesalahan </h2><br><p>  Keuntungan utama Sentinel Errors adalah kemampuan untuk membuat kesalahan dengan mudah.  Secara khusus, ketika membuat kesalahan atau menerima kesalahan dari luar, alangkah baiknya menambahkan stacktrace ke dalamnya.  Untuk tujuan tersebut, ada dua solusi populer. </p><br><ul><li>  paket xerrors, yang dalam Go 1.13 akan dimasukkan dalam perpustakaan standar sebagai percobaan </li><li>  paket <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github.com/pkg/errors</a> oleh Dave Cheney <br><ul><li>  paket tersebut dibekukan dan tidak berkembang, tetapi tetap saja bagus </li></ul></li></ul><br><p>  Tim kami masih menggunakan <code>github.com/pkg/errors</code> dan <code>errors.WithStack</code> Fungsi <code>errors.WithStack</code> (ketika kami tidak memiliki apa-apa untuk ditambahkan, kecuali stacktrace) atau <code>errors.Wrap</code> (ketika kami memiliki sesuatu untuk dikatakan tentang kesalahan ini).  Kedua fungsi menerima kesalahan pada input dan mengembalikan kesalahan baru, tetapi dengan stacktrace.  Contoh dari lapisan infrastruktur: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> mysql <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/pkg/errors"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r *repository)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindOne</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span> { row := r.client.QueryRow(sql, params...) <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> err := row.Scan(...) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> sql.ErrNoRows: <span class="hljs-comment"><span class="hljs-comment">//     stacktrace return nil, errors.WithStack(app.ErrNoCake) } }</span></span></code> </pre> <br><p>  Kami menyarankan agar setiap kesalahan hanya dibungkus satu kali.  Ini mudah dilakukan jika Anda mengikuti aturan: </p><br><ul><li>  setiap kesalahan eksternal dibungkus satu kali dalam salah satu paket infrastruktur </li><li>  setiap kesalahan yang dihasilkan oleh aturan logika bisnis dilengkapi dengan stacktrace pada saat pembuatan </li></ul><br><h2 id="pervoprichina-oshibki">  Akar penyebab kesalahan </h2><br><p>  Semua kesalahan diharapkan dibagi menjadi yang diharapkan dan yang tidak terduga.  Untuk menangani kesalahan yang diharapkan, Anda harus menyingkirkan efek komposisi.  Paket xerrors dan <code>github.com/pkg/errors</code> memiliki semua yang Anda butuhkan: khususnya, paket kesalahan memiliki <code>errors.Cause</code> Fungsi penyebab, yang mengembalikan akar penyebab kesalahan.  Fungsi ini dalam satu lingkaran, satu demi satu, mengambil kesalahan sebelumnya sementara kesalahan diekstraksi berikutnya memiliki metode <code>Cause() error</code> . </p><br><p>  Contoh yang kami ekstrak akar penyebabnya dan langsung membandingkannya dengan kesalahan sentinel: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s *service)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SaveCake</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { state, err := s.repo.FindOne(...) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> errors.Cause(err) == ErrNoCake { err = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-comment"><span class="hljs-comment">// No cake is OK, create a new one // ... } else if err != nil { // ... } }</span></span></code> </pre> <br><h2 id="obrabotka-oshibok-v-defer">  Kesalahan dalam menangani penundaan </h2><br><p>  Mungkin Anda menggunakan linter, yang membuat Anda memeriksa semua kesalahan secara manual.  Dalam hal ini, Anda mungkin sangat marah ketika linter meminta Anda untuk memeriksa kesalahan dengan metode <code>.Close()</code> dan metode lain yang hanya Anda <code>defer</code> .  Pernahkah Anda mencoba menangani kesalahan dengan benar dalam penundaan, terutama jika ada kesalahan lain sebelumnya?  Dan kami telah mencoba dan sedang terburu-buru untuk berbagi resep. </p><br><p>  Bayangkan kita memiliki semua pekerjaan dengan database secara ketat melalui transaksi.  Menurut aturan dependensi, level aplikasi dan domain tidak boleh secara langsung atau tidak langsung bergantung pada infrastruktur dan teknologi SQL.  Ini berarti bahwa <strong>pada tingkat aplikasi dan domain tidak ada kata "transaksi"</strong> . </p><br><p>  Solusi paling sederhana adalah mengganti kata "transaksi" dengan sesuatu yang abstrak;  dengan demikian pola Unit Kerja lahir.  Dalam implementasi kami, layanan dalam paket aplikasi menerima pabrik melalui antarmuka UnitOfWorkFactory, dan selama setiap operasi membuat objek UnitOfWork yang menyembunyikan transaksi.  Objek UnitOfWork memungkinkan Anda untuk mendapatkan Repositori. </p><br><div class="spoiler">  <b class="spoiler_title">Lebih lanjut tentang UnitOfWork</b> <div class="spoiler_text"><p>  Untuk lebih memahami penggunaan Unit Kerja, lihat diagram: </p><br><p><img src="https://habrastorage.org/webt/08/hi/iy/08hiiyavd51o3_aof9ys_s9noue.png" alt="Image Go Unit Kerja"></p><br><ul><li>  Repositori merupakan kumpulan objek abstrak yang persisten (misalnya, agregat level domain) dari tipe yang ditentukan </li><li>  UnitOfWork menyembunyikan transaksi dan membuat objek Repositori </li><li>  UnitOfWorkFactory hanya memungkinkan layanan untuk membuat transaksi baru tanpa mengetahui apa pun tentang transaksi. </li></ul><br><p>  Apakah tidak berlebihan untuk membuat transaksi untuk setiap operasi, bahkan awalnya atom?  Terserah Anda;  Kami percaya bahwa menjaga independensi logika bisnis lebih penting daripada menghemat menciptakan transaksi. </p><br><p>  Apakah mungkin untuk menggabungkan UnitOfWork dan Repositori?  Itu mungkin, tetapi kami percaya bahwa ini melanggar prinsip Tanggung Jawab Tunggal. </p></div></div><br><p>  Seperti inilah tampilannya: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> UnitOfWork <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { Repository() Repository Complete(err *error) }</code> </pre> <br><p>  Antarmuka UnitOfWork menyediakan metode Lengkap, yang mengambil satu parameter masuk: pointer ke antarmuka kesalahan.  Ya, itu adalah penunjuk, dan itu adalah parameter masuk-keluar - dalam kasus lain, kode di sisi panggilan akan jauh lebih rumit. </p><br><p>  Contoh operasi dengan unitOfWork: </p><br><blockquote>  Perhatian: kesalahan <strong>harus</strong> dinyatakan sebagai nilai balik yang dinamai.  Jika alih-alih nilai balik bernama err Anda menggunakan variabel lokal err, maka Anda tidak dapat menggunakannya dalam penundaan!  Dan belum ada satupun linter yang akan mendeteksi ini - lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">go-critic # 801</a> </blockquote><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s *service)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CookCake</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err error)</span></span></span></span> { unitOfWork, err := s.unitOfWorkFactory.New() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> unitOfWork.Complete(&amp;err) repo := unitOfWork.Repository() } <span class="hljs-comment"><span class="hljs-comment">// ...  </span></span></code> </pre> <br><p>  Jadi penyelesaiannya terealisasi <del>  transaksi </del>  UnitOfWork: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(u *unitOfWork)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Complete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err *error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> *err == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-comment"><span class="hljs-comment">//     -  commit txErr := u.tx.Commit() *err = errors.Wrap(txErr, "cannot complete transaction") } else { //    -  rollback txErr := return u.tx.Rollback() //  rollback   ,    *err = mergeErrors(*err, errors.Wrap(txErr, "cannot rollback transaction")) } }</span></span></code> </pre> <br><p>  Fungsi <code>mergeErrors</code> menggabungkan dua kesalahan, tetapi memproses nol tanpa masalah, bukan satu atau kedua kesalahan.  Pada saat yang sama, kami percaya bahwa kedua kesalahan terjadi selama pelaksanaan satu operasi pada tahapan yang berbeda, dan kesalahan pertama lebih penting - oleh karena itu, ketika kedua kesalahan tidak nol, kami menyimpan yang pertama, dan dari kesalahan kedua kami hanya menyimpan pesan: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> errors <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mergeErrors</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err error, nextErr error)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { err = nextErr } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> nextErr != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { err = errors.Wrap(err, nextErr.Error()) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err }</code> </pre> <br><blockquote>  Mungkin Anda harus menambahkan fungsi <code>mergeErrors</code> ke pustaka perusahaan Anda untuk Go. </blockquote><br><h2 id="podsistema-logirovaniya">  Subsistem logging </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Daftar Periksa</a> Artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">: apa yang harus Anda lakukan sebelum memulai layanan-layanan mikro dalam</a> saran menyarankan: </p><br><ul><li>  log ditulis dalam stderr </li><li>  log harus dalam JSON, satu objek JSON ringkas per baris </li><li>  Seharusnya ada seperangkat bidang standar: <br><ul><li>  timestamp - waktu acara dalam <strong>milidetik</strong> , lebih disukai dalam format RFC 3339 (contoh: "1985-04-12T23: 20: 50.52Z") </li><li>  level - level kepentingan, misalnya, "info" atau "kesalahan" </li><li>  app_name - nama aplikasi </li><li>  dan bidang lainnya </li></ul></li></ul><br><p>  Kami lebih suka menambahkan dua bidang lagi ke pesan kesalahan: <code>"error"</code> dan <code>"stacktrace"</code> . </p><br><p>  Ada banyak perpustakaan pencatatan kualitas untuk bahasa Golang, misalnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sirupsen / logrus</a> , yang kami gunakan.  Tapi kami tidak menggunakan perpustakaan secara langsung.  Pertama-tama, dalam paket <code>log</code> kami, kami mengurangi antarmuka pustaka yang terlalu luas menjadi satu antarmuka Logger: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> log <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Logger <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { WithField(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}) Logger WithFields(Fields) Logger Debug(...<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}) Info(...<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}) Error(error, ...<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}) }</code> </pre> <br><p>  Jika programmer ingin menulis log, ia harus mendapatkan antarmuka Logger dari luar, dan ini harus dilakukan di tingkat infrastruktur, bukan aplikasi atau domain.  Antarmuka logger ringkas: </p><br><ul><li>  itu mengurangi jumlah tingkat keparahan untuk debug, info dan kesalahan, seperti yang disarankan artikel ini. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mari kita bicara tentang pencatatan.</a> </li><li>  itu memperkenalkan aturan khusus untuk metode Kesalahan: metode selalu menerima objek kesalahan </li></ul><br><p>  Kekakuan ini memungkinkan kita untuk mengarahkan pemrogram ke arah yang benar: jika seseorang ingin melakukan perbaikan dalam sistem logging itu sendiri, ia harus melakukannya dengan mempertimbangkan seluruh infrastruktur pengumpulan dan pemrosesan mereka, yang hanya dimulai pada layanan mikro (dan biasanya berakhir di suatu tempat di Kibana dan Zabbix). </p><br><p>  Namun, dalam paket log ada antarmuka lain yang memungkinkan Anda untuk menghentikan program ketika kesalahan fatal terjadi dan karena itu hanya dapat digunakan dalam paket utama: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> log <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> MainLogger <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { Logger FatalError(error, ...<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}) }</code> </pre> <br><h2 id="paket-jsonlog">  Paket jsonlog </h2><br><p>  Menerapkan antarmuka Logger paket <code>jsonlog</code> kami, yang mengonfigurasi pustaka logrus dan mengabstraksi pekerjaan dengannya.  Secara skematis terlihat seperti ini: </p><br><p><img src="https://habrastorage.org/webt/g4/we/6m/g4we6m81oxxtd1nlvwklblru6eq.png" alt="Diagram Paket Pencatat Gambar"></p><br><p>  Paket berpemilik memungkinkan Anda untuk menghubungkan kebutuhan layanan Microsoft (diungkapkan oleh antarmuka <code>log.Logger</code> ), kemampuan perpustakaan logrus, dan fitur infrastruktur Anda, pencatatan. </p><br><p>  Sebagai contoh, kami menggunakan ELK (Pencarian Elastis, Logstash, Kibana), dan karenanya dalam paket jsonlog kami: </p><br><ul><li>  setel format <code>logrus.JSONFormatter</code> untuk <code>logrus.JSONFormatter</code> <br><ul><li>  pada saat yang sama, kami mengatur opsi FieldMap, yang dengannya kami mengubah bidang <code>"time"</code> menjadi <code>"@timestamp"</code> , dan bidang <code>"msg"</code> menjadi <code>"message"</code> </li></ul></li><li>  pilih level log </li><li>  tambahkan hook yang mengekstrak stacktrace dari objek <code>Error(error, ...interface{})</code> diteruskan ke metode <code>Error(error, ...interface{})</code> </li></ul><br><p>  Layanan Microsoft menginisialisasi logger di fungsi utama: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initLogger</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(config Config)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(log.MainLogger, error)</span></span></span></span> { logLevel, err := jsonlog.ParseLevel(config.LogLevel) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, errors.Wrap(err, <span class="hljs-string"><span class="hljs-string">"failed to parse log level"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> jsonlog.NewLogger(&amp;jsonlog.Config{ Level: logLevel, AppName: <span class="hljs-string"><span class="hljs-string">"cookingservice"</span></span> }), <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br><h2 id="obrabotka-oshibok-i-logirovanie-s-pomoschyu-middleware">  Penanganan Kesalahan dan Penebangan dengan Middleware </h2><br><p>  Kami beralih ke GRPC di layanan microser kami di Go.  Tetapi bahkan jika Anda menggunakan HTTP API, prinsip-prinsip umum adalah untuk Anda. </p><br><p>  Pertama-tama, penanganan kesalahan dan penebangan harus terjadi pada tingkat <code>infrastructure</code> dalam paket yang bertanggung jawab untuk transportasi, karena dialah yang menggabungkan pengetahuan tentang aturan protokol transportasi dan pengetahuan tentang <code>app.Service</code> . <code>app.Service</code> antarmuka layanan.  Ingat seperti apa hubungan paket itu: </p><br><p><img src="https://habrastorage.org/webt/fw/zn/hz/fwznhzsxd35ydgajmotnvprqbum.png" alt="Diagram Paket GRPC Gambar"></p><br><p>  Lebih mudah untuk memproses kesalahan dan memelihara log menggunakan pola Middleware (Middleware adalah nama pola Penghias di dunia Golang dan Node.js): </p><br><p>  Di mana menambahkan Middleware?  Berapa banyak yang seharusnya ada? </p><br><p>  Ada beberapa opsi untuk menambahkan Middleware, Anda pilih: </p><br><ul><li>  Anda dapat menghias <code>app.Service</code> Antarmuka layanan, tetapi kami tidak menyarankan melakukan ini karena antarmuka ini tidak menerima informasi lapisan transport, seperti IP klien </li><li>  Dengan GRPC Anda dapat menggantung satu penangan pada semua permintaan (lebih tepatnya, dua - unary dan steam), tetapi kemudian semua metode API akan dicatat dalam gaya yang sama dengan kumpulan bidang yang sama </li><li>  Dengan GRPC, pembuat kode membuatkan kami antarmuka server tempat kami memanggil <code>app.Service</code> Metode layanan - kami menghias antarmuka ini karena memiliki informasi tingkat transportasi dan kemampuan untuk mencatat berbagai metode API dengan cara yang berbeda. </li></ul><br><p>  Secara skematis terlihat seperti ini: </p><br><p><img src="https://habrastorage.org/webt/vn/dl/eh/vndlehx5hogpu09hj3zekrzmyie.png" alt="Gambar GRPC Middleware Package Diagram"></p><br><p>  Anda dapat membuat berbagai Middlewares untuk penanganan kesalahan (dan panik) dan untuk pencatatan.  Anda bisa menyilangkan semuanya menjadi satu.  Kami akan mempertimbangkan contoh di mana semuanya disilangkan menjadi satu Middleware, yang dibuat seperti ini: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewMiddleware</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(next api.BackendService, logger log.Logger)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">api</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BackendService</span></span></span></span> { server := &amp;errorHandlingMiddleware{ next: next, logger: logger, } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> server }</code> </pre> <br><p>  Kami mendapatkan antarmuka <code>api.BackendService</code> sebagai <code>api.BackendService</code> dan menghiasnya, mengembalikan implementasi antarmuka <code>api.BackendService</code> sebagai <code>api.BackendService</code> . </p><br><p>  Metode API sewenang-wenang di Middleware diimplementasikan sebagai berikut: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(m *errorHandlingMiddleware)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ListCakes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ctx context.Context, req *api.ListCakesRequest)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*api.ListCakesResponse, error)</span></span></span></span> { start := time.Now() res, err := m.next.ListCakes(ctx, req) m.logCall(start, err, <span class="hljs-string"><span class="hljs-string">"ListCakes"</span></span>, log.Fields{ <span class="hljs-string"><span class="hljs-string">"cookIDs"</span></span>: req.CookIDs, }) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res, translateError(err) }</code> </pre> <br><p>  Di sini kami melakukan tiga tugas: </p><br><ol><li>  Panggil metode ListCakes dari objek yang didekorasi </li><li>  Kami <code>logCall</code> metode <code>logCall</code> , meneruskan semua informasi penting, termasuk satu set bidang yang dipilih secara individual yang termasuk dalam log </li><li>  Pada akhirnya, kami mengganti kesalahan dengan memanggil translateError. </li></ol><br><p>  Terjemahan kesalahan akan dibahas nanti.  Dan <code>logCall</code> dilakukan dengan metode <code>logCall</code> , yang hanya memanggil metode antarmuka Logger yang benar: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(m *errorHandlingMiddleware)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">logCall</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(start time.Time, err error, method </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, fields log.Fields)</span></span></span></span> { fields[<span class="hljs-string"><span class="hljs-string">"duration"</span></span>] = fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">"%v"</span></span>, time.Since(start)) fields[<span class="hljs-string"><span class="hljs-string">"method"</span></span>] = method logger := m.logger.WithFields(fields) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { logger.Error(err, <span class="hljs-string"><span class="hljs-string">"call failed"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { logger.Info(<span class="hljs-string"><span class="hljs-string">"call finished"</span></span>) } }</code> </pre> <br><h2 id="translyaciya-oshibok">  Terjemahan kesalahan </h2><br><p>  Kami harus mendapatkan akar penyebab kesalahan dan mengubahnya menjadi kesalahan yang dapat dipahami di tingkat transportasi dan didokumentasikan dalam API layanan Anda. </p><br><p>  Di GRPC, sangat sederhana - gunakan fungsi <code>status.Errorf</code> untuk membuat kesalahan dengan kode status.  Jika Anda memiliki HTTP API (REST API), Anda dapat membuat jenis kesalahan sendiri yang <strong>seharusnya tidak diketahui oleh tingkat aplikasi dan domain.</strong> </p><br><p>  Pada perkiraan pertama, terjemahan kesalahannya terlihat seperti ini: </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// ! ! -   err  status.Error func translateError(err error) error { switch errors.Cause(err) { case app.ErrNoCake: err = status.Errorf(codes.NotFound, err.Error()) default: err = status.Errorf(codes.Internal, err.Error()) } return err }</span></span></code> </pre> <br><p>  Saat memvalidasi argumen input, antarmuka yang didekorasi dapat mengembalikan kesalahan <code>status.Status</code> ketik dengan kode status, dan versi pertama dari translateError akan kehilangan kode status ini. </p><br><p>  Mari kita buat versi yang disempurnakan dengan melakukan casting ke jenis antarmuka (ketikan bebek hidup panjang!): </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> statusError <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { GRPCStatus() *status.Status } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isGrpcStatusError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(er error)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span></span> { _, ok := err.(statusError) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ok } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">translateError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err error)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> isGrpcStatusError(err) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> errors.Cause(err) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> app.ErrNoCake: err = status.Errorf(codes.NotFound, err.Error()) <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: err = status.Errorf(codes.Internal, err.Error()) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err }</code> </pre> <br><p>  Fungsi <code>translateError</code> dibuat secara individual untuk setiap konteks (modul independen) di layanan mikro Anda dan menerjemahkan kesalahan logika bisnis menjadi kesalahan tingkat transportasi. </p><br><h2 id="podvedyom-itogi">  Untuk meringkas </h2><br><p>  Kami menawarkan beberapa aturan untuk menangani kesalahan dan bekerja dengan log.  Apakah mengikuti atau tidak itu terserah Anda. </p><br><ol><li>  Ikuti prinsip Arsitektur Bersih, jangan langsung atau tidak langsung melanggar aturan dependensi.  Logika bisnis seharusnya hanya bergantung pada bahasa pemrograman, dan bukan pada teknologi eksternal. </li><li>  Gunakan paket yang menawarkan komposisi kesalahan dan pembuatan stacktrace.  Misalnya, "github.com/pkg/errors" atau paket xerrors, yang akan segera menjadi bagian dari perpustakaan standar Go. </li><li>  Jangan gunakan perpustakaan logging pihak ketiga di microservice - buat perpustakaan Anda sendiri dengan paket log dan jsonlog, yang akan menyembunyikan detail implementasi logging </li><li>  Gunakan pola Middleware untuk menangani kesalahan dan menulis log pada arah pengangkutan tingkat infrastruktur program </li></ol><br><p>  Di sini kami tidak mengatakan apa pun tentang teknologi penelusuran kueri (misalnya, OpenTracing), pemantauan metrik (misalnya, kinerja kueri basis data) dan hal-hal lain seperti pencatatan.  Anda sendiri yang akan berurusan dengan ini, kami percaya pada Anda. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id459130/">https://habr.com/ru/post/id459130/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id459118/index.html">Bagaimana kami merancang dan mengimplementasikan jaringan baru pada Huawei di kantor Moskow, bagian 2</a></li>
<li><a href="../id459120/index.html">Komputer Tertanam Modular Seri UNO-1000/2000</a></li>
<li><a href="../id459122/index.html">Aleksey Savvateev: Hadiah Nobel Jean Tyrol untuk menganalisis pasar yang tidak sempurna (2014) dan reputasi kolektif</a></li>
<li><a href="../id459126/index.html">Raspberry Pi Robot Tank dengan Intel Neural Computer Stick 2</a></li>
<li><a href="../id459128/index.html">Antarmuka Jepang di dunia nyata</a></li>
<li><a href="../id459134/index.html">Pengalaman menggunakan BDD</a></li>
<li><a href="../id459136/index.html">Pil Biru Palsu</a></li>
<li><a href="../id459138/index.html">Bagaimana kunci rahasia Huawei masuk ke firmware router Cisco</a></li>
<li><a href="../id459140/index.html">Penempatan implan: bagaimana hal ini dilakukan?</a></li>
<li><a href="../id459142/index.html">Membangun grafik garis rata-rata bergerak yang bergerak dalam R. Mengambil data melalui NBA API</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>