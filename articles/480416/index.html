<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üñïüèø üë©üèΩ‚Äçüé® ‚õΩÔ∏è Matem√°ticas gen√©ricas inseguras en C # üéÖüèº üë®üèª‚Äçüç≥ ‚úãüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Desafortunadamente, no fue f√°cil traducir adecuadamente el nombre de la fealdad que comenc√© al ruso. Me sorprendi√≥ descubrir que la documentaci√≥n ofic...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Matem√°ticas gen√©ricas inseguras en C #</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/480416/"><p><img src="https://habrastorage.org/webt/mj/zg/yw/mjzgywquj0lud4_vs9bjh8xdacu.png"></p><br><p> Desafortunadamente, no fue f√°cil traducir adecuadamente el nombre de la fealdad que comenc√© al ruso.  Me sorprendi√≥ descubrir que la documentaci√≥n oficial de <a href="https://docs.microsoft.com/ru-ru/dotnet/csharp/programming-guide/generics/" rel="nofollow">MSDN</a> llama "plantillas" gen√©ricas "(similar a las plantillas <code>C++</code> , supongo).  En la cuarta edici√≥n de <a href="https://www.microsoftpressstore.com/store/clr-via-c-sharp-9780735667457" rel="nofollow"><code>"CLR</code> v√≠a <code>C#</code> " que</a> me llam√≥ la atenci√≥n <a href="https://www.microsoftpressstore.com/store/clr-via-c-sharp-9780735667457" rel="nofollow">,</a> <a href="https://twitter.com/jeffrichter" rel="nofollow">Jeffrey Richter</a> , traducido por <a href="https://habr.com/en/company/piter/">Peter</a> , los gen√©ricos se denominan "generalizaciones", lo que refleja el concepto mucho mejor.  Este art√≠culo hablar√° sobre <em>operaciones matem√°ticas generalizadas inseguras en <code>C#</code></em> .  Teniendo en cuenta que <code>C#</code> no <code>C#</code> destinado a la inform√°tica de alto rendimiento (aunque, por supuesto, es capaz de hacerlo, pero no puede competir con el mismo <code>C/C++</code> ), las operaciones matem√°ticas en <code>BCL</code> no reciben mucha atenci√≥n.  Intentemos simplificar el trabajo con tipos aritm√©ticos b√°sicos usando <code>C#</code> y <code>CLR</code> . </p><a name="habracut"></a><br><h2 id="postanovka-zadachi">  Declaraci√≥n del problema. </h2><br><p>  <strong>Descargo de responsabilidad</strong> : el art√≠culo contendr√° muchos fragmentos de c√≥digo, algunos de los cuales ilustrar√© con enlaces al maravilloso recurso <a href="https://sharplab.io/" rel="nofollow">SharpLab</a> ( <a href="https://github.com/ashmind/SharpLab" rel="nofollow">Gi <s>r</s> tHub</a> ) de <a href="https://twitter.com/ashmind" rel="nofollow">Andrey Shchekin</a> . </p><br><p>  La mayor√≠a de los c√°lculos de una forma u otra se reducen a operaciones b√°sicas.  La suma, la resta (inversi√≥n, negaci√≥n), la multiplicaci√≥n y la divisi√≥n pueden complementarse con operaciones de comparaci√≥n y verificaci√≥n de igualdad.  Por supuesto, todas estas acciones se pueden realizar f√°cil y simplemente en variables de cualquier tipo aritm√©tico b√°sico de <code>C#</code> .  El √∫nico problema es que <code>C#</code> debe <em>saber</em> en el momento de la compilaci√≥n que las operaciones se realizan en tipos espec√≠ficos, y parece que escribir un m√©todo que agregue de manera eficiente (y transparente) dos n√∫meros enteros y dos n√∫meros de punto flotante es imposible. </p><br><p>  Especifiquemos nuestros deseos para un m√©todo hipot√©tico generalizado que realiza alguna operaci√≥n matem√°tica simple: </p><br><ol><li>  Un m√©todo debe tener restricciones de tipo generalizadas que nos protegen de intentar agregar (o multiplicar, dividir) dos tipos arbitrarios.  Necesitamos alguna restricci√≥n de tipo gen√©rico. </li><li>  Para la pureza del experimento, los tipos aceptados y devueltos deben ser los mismos.  Por ejemplo, un operador binario debe tener una firma de la forma <code>(T, T) =&gt; T</code> </li><li>  El m√©todo debe ser al menos parcialmente optimizado.  Por ejemplo, el boxeo ubicuo es inaceptable. </li></ol><br><h2 id="a-chto-tam-u-sosedey">  ¬øY qu√© hay de los vecinos? </h2><br><p>  Veamos <code>F#</code> .  No soy fuerte en <code>F#</code> , pero la mayor√≠a de las restricciones de <code>C#</code> est√°n dictadas por las limitaciones de <code>CLR</code> , lo que significa que <code>F#</code> sufre los mismos problemas.  Puede intentar declarar un m√©todo de suma generalizado expl√≠cito y el m√©todo de suma habitual y ver lo que dice el sistema de inferencia de tipo <code>F#</code> : </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">let</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_gen</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x : </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'a) (y : '</span></span></span></span><span class="hljs-function"><span class="hljs-params">a</span></span></span><span class="hljs-function">)</span></span> = x + y <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> xy = x + y add_gen <span class="hljs-number"><span class="hljs-number">5.0</span></span> <span class="hljs-number"><span class="hljs-number">6.0</span></span> |&gt; ignore <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> <span class="hljs-number"><span class="hljs-number">5.0</span></span> <span class="hljs-number"><span class="hljs-number">6.0</span></span> |&gt; ignore</code> </pre> <br><p>  En <a href="https://sharplab.io/" rel="nofollow">este caso,</a> ambos m√©todos resultar√°n no generalizados y el c√≥digo generado ser√° id√©ntico.  Dada la rigidez del sistema de tipo <code>F#</code> , donde no hay conversiones impl√≠citas de la forma <code>int -&gt; double</code> , despu√©s de la primera llamada de estos m√©todos con par√°metros de tipo <code>double</code> (en t√©rminos de <code>C#</code> ), llame a m√©todos con par√°metros de otros tipos (incluso con una posible p√©rdida de precisi√≥n debido a la conversi√≥n de tipos) m√°s fallar√° </p><br><p>  Vale la pena se√±alar que si reemplaza el operador <code>+</code> con el operador de igualdad <code>=</code> , la <a href="https://sharplab.io/" rel="nofollow">imagen se vuelve ligeramente diferente</a> : ambos m√©todos se vuelven generalizados (desde el punto de vista de <code>C#</code> ), y se llama a un m√©todo auxiliar especial, disponible en <code>F#</code> para realizar la comparaci√≥n. </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">let</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eq_gen</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x : </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'a) (y : '</span></span></span></span><span class="hljs-function"><span class="hljs-params">a</span></span></span><span class="hljs-function">)</span></span> = x = y <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> eq xy = x = y eq_gen <span class="hljs-number"><span class="hljs-number">5.0</span></span> <span class="hljs-number"><span class="hljs-number">6.0</span></span> |&gt; ignore eq_gen <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span> |&gt; ignore eq <span class="hljs-number"><span class="hljs-number">5.0</span></span> <span class="hljs-number"><span class="hljs-number">6.0</span></span> |&gt; ignore eq <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span> |&gt; ignore</code> </pre> <br><h3 id="chto-naschet-java">  ¬øQu√© hay de <code>Java</code> ? </h3><br><p>  Es dif√≠cil para m√≠ hablar de <code>Java</code> , pero, por lo que puedo decir, los tipos significativos <a href="https://en.wikipedia.org/wiki/Comparison_of_C_Sharp_and_Java" rel="nofollow">no</a> est√°n en la forma habitual para nosotros, pero todav√≠a hay tipos <em>primitivos</em> .  Para trabajar con primitivas en <code>Java</code> hay <a href="https://en.wikipedia.org/wiki/Comparison_of_C_Sharp_and_Java" rel="nofollow">envoltorios</a> (por ejemplo, una referencia <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Long.html" rel="nofollow"><code>Long</code></a> para primitivo by-value <code>long</code> ), que tienen un <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Number.html" rel="nofollow"><code>Number</code></a> clase base com√∫n.  Por lo tanto, puede generalizar parcialmente las operaciones con <code>Number</code> , pero este es un tipo de referencia, que es poco probable que tenga un efecto positivo en el rendimiento. </p><br><p>  <em>Corr√≠geme si me equivoco.</em> </p><br><h3 id="c">  <code>C++</code> ? </h3><br><p>  <code>C++</code> es un lenguaje para tramposos. <br>  <code>C++</code> allana el camino para caracter√≠sticas que algunos consideran ... poco <a href="https://ru.wikiquote.org/wiki/%25D0%2597%25D0%25B2%25D1%2591%25D0%25B7%25D0%25B4%25D0%25BD%25D1%258B%25D0%25B5_%25D0%25B2%25D0%25BE%25D0%25B9%25D0%25BD%25D1%258B._%25D0%25AD%25D0%25BF%25D0%25B8%25D0%25B7%25D0%25BE%25D0%25B4_III:_%25D0%259C%25D0%25B5%25D1%2581%25D1%2582%25D1%258C_%25D1%2581%25D0%25B8%25D1%2582%25D1%2585%25D0%25BE%25D0%25B2" rel="nofollow">naturales</a> . <br>  Las plantillas (tambi√©n conocidas como plantillas), en contraste con las generalizaciones (gen√©ricos), son, en sentido literal, <em>plantillas</em> .  Al declarar una plantilla, puede restringir expl√≠citamente los tipos para los que esta plantilla est√° disponible.  Por esta raz√≥n, en <code>C++</code> , por ejemplo, el siguiente c√≥digo es v√°lido: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; template&lt;typename T, std::enable_if_t&lt;std::is_arithmetic&lt;T&gt;::value&gt;* = nullptr&gt; T Add (T left, T right) { return left + right; } int main() { std::cout &lt;&lt; Add(5, 6) &lt;&lt; std::endl; std::cout &lt;&lt; Add(5.0, 6.0) &lt;&lt; std::endl; // std::cout &lt;&lt; Add("a", "b") &lt;&lt; std::endl; Does not compile }</span></span></span></span></code> </pre> <br><p>  <code>is_arithmetic</code> , desafortunadamente, permite tanto <code>char</code> como <code>bool</code> como par√°metros.  Por otro lado, <code>char</code> puede ser equivalente a <code>sbyte</code> en terminolog√≠a de <code>C#</code> , aunque los tama√±os reales de los tipos enteros dependen de la plataforma / compilador / fase lunar. </p><br><h3 id="yazyki-s-dinamicheskoy-tipizaciey">  Lenguajes de escritura din√°mica </h3><br><p>  Finalmente, considere un par de lenguajes din√°micamente escritos (e <em>interpretados</em> ), agudizados por la computaci√≥n.  En tales lenguajes, generalmente la generalizaci√≥n de la computaci√≥n no causa problemas: si el tipo de par√°metros es adecuado para la ejecuci√≥n, condicionalmente, adem√°s, la operaci√≥n se realizar√°, de lo contrario fallar√° con un error. </p><br><p>  En <code>Python</code> (3.7.3 x64): </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + y type(add(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>)) <span class="hljs-comment"><span class="hljs-comment"># &lt;class 'int'&gt; type(add(5.0, 6.0)) # &lt;class 'float'&gt; type(add('a', 'b') # &lt;class 'str'&gt;</span></span></code> </pre> <br><p>  En <code>R</code> (3.6.1 x64) </p><br><pre> <code class="cpp hljs">add &lt;- function(x, y) x + y # <span class="hljs-function"><span class="hljs-function">Or </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">typeof</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> vctrs::</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vec_ptype_show</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(add(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">5</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">6</span></span></span></span><span class="hljs-function"><span class="hljs-params">))</span></span></span><span class="hljs-function"> # Prototype: </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> vctrs::</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vec_ptype_show</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(add(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">5L</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">6L</span></span></span></span><span class="hljs-function"><span class="hljs-params">))</span></span></span><span class="hljs-function"> # Prototype: integer vctrs::</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vec_ptype_show</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(add(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"5"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"6"</span></span></span></span><span class="hljs-function"><span class="hljs-params">))</span></span></span><span class="hljs-function"> # Error in x + y : non-numeric argument to binary </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">operator</span></span></span></span></code> </pre> <br><h2 id="obratno-v-mir-c-ogranichivaem-obobschennyy-tip-matematicheskoy-funkcii">  Por el contrario, en el mundo C #: restringimos el tipo generalizado de funci√≥n matem√°tica </h2><br><p>  Lamentablemente, no podemos hacer esto.  En <code>C#</code> los tipos primitivos son tipos por valor, es decir,  estructuras que, aunque se heredan de <code>System.Object</code> (y <a href="https://docs.microsoft.com/en-us/dotnet/api/system.valuetype%3Fview%3Dnetcore-3.0" rel="nofollow"><code>System.ValueType</code></a> ), no tienen mucho en com√∫n.  Una limitaci√≥n natural y l√≥gica es <code>where T : struct</code> .  Comenzando con <code>C# 7.3</code> tenemos la restricci√≥n <code>where T : unmanaged</code> , lo que significa que <code>T</code> es un <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/unmanaged-types" rel="nofollow"><code> ,        null</code></a> .  Adem√°s de los tipos aritm√©ticos primitivos que necesitamos, <code>char</code> , <code>bool</code> , <code>decimal</code> , <em>cualquier</em> <code>Enum</code> y <em>cualquier</em> estructura cuyos campos tengan el mismo tipo <code>unmanaged</code> satisfacen estos requisitos.  Es decir  <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/unmanaged-types" rel="nofollow">este tipo</a> pasar√° la prueba: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Coords&lt;T&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : unmanaged { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> TX; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> TY; }</code> </pre> <br><p>  Por lo tanto, no podemos escribir una funci√≥n generalizada que acepte solo los tipos aritm√©ticos deseados.  De ah√≠ lo <code>Unsafe</code> en el t√≠tulo del art√≠culo: tendremos que confiar en que los programadores usen nuestro c√≥digo.  Un intento de llamar al m√©todo hipot√©tico generalizado <code>T Add&lt;T&gt;(T left, T right) where T : unmanaged</code> conducir√° a resultados impredecibles si el programador pasa objetos de un tipo incompatible como argumentos. </p><br><h2 id="eksperiment-pervyy-naivnyy-dynamic">  El primer experimento, ingenuo: <code>dynamic</code> </h2><br><p>  <code>dynamic</code> es la primera y obvia herramienta que puede ayudarnos a resolver nuestro problema.  Por supuesto, el uso de la <code>dynamic</code> para los c√°lculos es absolutamente in√∫til: la <code>dynamic</code> equivalente al <code>object</code> , y el compilador convierte los m√©todos llamados con una variable <code>dynamic</code> en un reflejo monstruoso.  Como beneficio adicional: empacar / desempacar nuestros tipos de valor.  Aqu√≠ hay <a href="https://sharplab.io/" rel="nofollow">un ejemplo</a> : </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Class</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Method</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x = Add(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> y = Add(<span class="hljs-number"><span class="hljs-number">5.0</span></span>, <span class="hljs-number"><span class="hljs-number">6.0</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">dynamic</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Add</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">dynamic</span></span></span></span><span class="hljs-function"><span class="hljs-params"> left, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">dynamic</span></span></span></span><span class="hljs-function"><span class="hljs-params"> right</span></span></span><span class="hljs-function">)</span></span> =&gt; left + right; }</code> </pre> <br><p>  Solo mire la <code>IL</code> <code>Method</code> M√©todo: </p><br><pre> <code class="cs hljs">.<span class="hljs-function"><span class="hljs-function">method </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> hidebysig </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Method</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) cil managed</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Method begins at RVA 0x2050 // Code size 53 (0x35) .maxstack 8 IL_0000: ldc.i4.5 IL_0001: box [System.Private.CoreLib]System.Int32 IL_0006: ldc.i4.6 IL_0007: box [System.Private.CoreLib]System.Int32 IL_000c: call object Class::Add(object, object) IL_0011: pop IL_0012: ldc.r8 5 IL_001b: box [System.Private.CoreLib]System.Double IL_0020: ldc.r8 6 IL_0029: box [System.Private.CoreLib]System.Double IL_002e: call object Class::Add(object, object) IL_0033: pop IL_0034: ret } // end of method Class::Method</span></span></code> </pre> <br><p>  Cargado <code>5</code> , <em>empaquetado</em> , cargado <code>6</code> , empaquetado, llamado <code>object Add(object, object)</code> . <br>  La opci√≥n obviamente no nos conviene. </p><br><h2 id="eksperiment-vtoroy-v-lob">  El segundo experimento, "en la frente" </h2><br><p>  Bueno, la <code>dynamic</code> no es para nosotros, pero el n√∫mero de nuestros tipos es finito, y se conocen de antemano.  Vamos a armarnos con una <s>palanca de</s> rama y escribirlo: si <em>nuestro</em> tipo <em>es</em> , calculemos algo, de lo contrario, esta es la excepci√≥n. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> T Add&lt;T&gt;(T left, T right) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : unmanaged { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(left <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i32Left &amp;&amp; right <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i32Right) { <span class="hljs-comment"><span class="hljs-comment">// ??? } // ... throw new NotSupportedException(); }</span></span></code> </pre> <br><p>  III, aqu√≠ nos encontramos con un problema.  Si comprende con qu√© tipos estamos trabajando, tambi√©n puede aplicarles la operaci√≥n, entonces el <code>int</code> condicional resultante debe convertirse a un tipo <code>T</code> desconocido y esto no es muy simple.  La <code>return (T)(i32Left + i32Right)</code> no se compila: no hay garant√≠a de que <code>T</code> sea <code>int</code> (aunque sabemos que lo es).  Puede probar el <code>return (T)(object)(i32Left + i32Right)</code> conversi√≥n doble <code>return (T)(object)(i32Left + i32Right)</code> .  Primero, la cantidad se empaca, luego se desempaqueta en <code>T</code>  Esto <strong>solo</strong> funcionar√° si los tipos <a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/types/boxing-and-unboxing" rel="nofollow">coinciden</a> antes del empaque y despu√©s del empaque.  No puede empaquetar <code>int</code> , pero descompr√≠malo en <code>double</code> , incluso si hay una conversi√≥n impl√≠cita <code>int -&gt; double</code> .  El problema con <a href="https://sharplab.io/" rel="nofollow">este</a> c√≥digo es la ramificaci√≥n gigante y la abundancia de paquetes desempacables, incluso en condiciones.  Esta opci√≥n tampoco es buena. </p><br><h2 id="refleksiya-i-metadannye">  Reflexi√≥n y Metadatos </h2><br><p>  Bueno, juega y eso es suficiente.  Todo el mundo sabe que hay operadores en <code>C#</code> que pueden anularse.  Ah√≠ hay <code>+</code> , <code>-</code> , <code>==</code> , <code>==</code> <code>!=</code> Y as√≠ sucesivamente.  Todo lo que tenemos que hacer es extraer un m√©todo est√°tico de tipo <code>T</code> correspondiente al operador, por ejemplo, adiciones, eso es todo.  Bueno, s√≠, nuevamente un par de paquetes, pero sin ramificaciones y sin problemas.  Todo se puede almacenar en cach√© por tipo <code>T</code> y, en general, acelerar el proceso en todos los sentidos, reduciendo una operaci√≥n matem√°tica a llamar a un √∫nico m√©todo de reflexi√≥n.  Bueno, algo como esto: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> T Add&lt;T&gt;(T left, T right) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : unmanaged { <span class="hljs-comment"><span class="hljs-comment">// Simple example without cache. var method = typeof(T) .GetMethod(@"op_Addition", new [] {typeof(T), typeof(T)}) ?.CreateDelegate(typeof(Func&lt;T, T, T&gt;)) as Func&lt;T, T, T&gt;; return method?.Invoke(left, right) ?? throw new InvalidOperationException(); }</span></span></code> </pre> <br><p>  Lamentablemente esto <a href="https://jonskeet.uk/csharp/genericoperators.html" rel="nofollow">no funciona</a> .  El hecho es que los tipos aritm√©ticos (pero no <code>decimal</code> ) <em>no tienen</em> un m√©todo tan est√°tico.  Todas las operaciones se implementan a trav√©s de operaciones <code>IL</code> , como <a href="" rel="nofollow"><code>add</code></a> .  La reflexi√≥n normal no resuelve nuestro problema. </p><br><h2 id="systemlinqexpressions">  System.Linq.Expressions </h2><br><p>  La soluci√≥n basada en <code>Expressions</code> se describe en el blog de <a href="https://twitter.com/jonskeet" rel="nofollow">John Skeet</a> <a href="https://jonskeet.uk/csharp/genericoperators.html" rel="nofollow">aqu√≠</a> (por Marc Gravell). <br>  La idea es bastante simple.  Supongamos que tenemos un tipo <code>T</code> que admite la operaci√≥n <code>+</code> .  Creemos una expresi√≥n como esta: </p><br><pre> <code class="cs hljs">(x, y) =&gt; x + y;</code> </pre> <br><p>  Despu√©s de eso, habiendo almacenado en cach√©, lo usaremos.  Construir tal expresi√≥n es bastante f√°cil.  Necesitamos dos par√°metros y una operaci√≥n.  As√≠ que vamos a escribirlo. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Dictionary&lt;(Type Type, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Op), Delegate&gt; Cache = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;(Type Type, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Op), Delegate&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> T Add&lt;T&gt;(T left, T right) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : unmanaged { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(T); <span class="hljs-comment"><span class="hljs-comment">// If op is cached by type and function name, use cached version if (Cache.TryGetValue((t, nameof(Add)), out var del)) return del is Func&lt;T, T, T&gt; specificFunc ? specificFunc(left, right) : throw new InvalidOperationException(nameof(Add)); var leftPar = Expression.Parameter(t, nameof(left)); var rightPar = Expression.Parameter(t, nameof(right)); var body = Expression.Add(leftPar, rightPar); var func = Expression.Lambda&lt;Func&lt;T, T, T&gt;&gt;(body, leftPar, rightPar).Compile(); Cache[(t, nameof(Add))] = func; return func(left, right); }</span></span></code> </pre> <br><p>  En el centro se public√≥ informaci√≥n √∫til sobre √°rboles de expresi√≥n y delegados. </p><br><p>  T√©cnicamente, las expresiones nos permiten resolver todos nuestros problemas: cualquier operaci√≥n b√°sica se puede reducir a llamar a un m√©todo generalizado.  Cualquier operaci√≥n m√°s compleja se puede escribir de la misma manera, utilizando expresiones m√°s complejas.  Esto es <em>casi</em> suficiente. </p><br><h2 id="narushaem-vse-pravila">  Rompemos todas las reglas </h2><br><p>  ¬øEs posible lograr algo m√°s usando el poder de <code>CLR/C#</code> ?  Veamos en qu√© <s>a√±o</s> se genera <s>el</s> c√≥digo mediante m√©todos de adici√≥n <a href="https://sharplab.io/" rel="nofollow">para diferentes tipos</a> : </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Class</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Add</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y</span></span></span><span class="hljs-function">)</span></span> =&gt; x + y; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Add</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y</span></span></span><span class="hljs-function">)</span></span> =&gt; x + y; <span class="hljs-comment"><span class="hljs-comment">// Decimal only to show difference public static decimal Add(decimal x, decimal y) =&gt; x + y; }</span></span></code> </pre> <br><p>  El c√≥digo <code>IL</code> correspondiente contiene el mismo conjunto de instrucciones: </p><br><pre> <code class="cs hljs">ldarg<span class="hljs-number"><span class="hljs-number">.0</span></span> ldarg<span class="hljs-number"><span class="hljs-number">.1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> ret</code> </pre> <br><p>  Este es el c√≥digo operativo <a href="" rel="nofollow"><code>add</code></a> en el que se compila la adici√≥n de tipos primitivos aritm√©ticos.  <code>decimal</code> en este lugar llama a <code>static decimal decimal.op_Addition(decimal, decimal)</code> .  Pero, ¬øqu√© sucede si escribimos un m√©todo que se generalizar√°, pero que contiene exactamente este c√≥digo <code>IL</code> ?  Bueno, John Skeet advierte que esto <a href="https://jonskeet.uk/csharp/genericoperators.html" rel="nofollow">no vale la pena</a> .  En su caso, considera todos los tipos (incluido el <code>decimal</code> ), as√≠ como sus an√°logos <code>nullable</code> .  Esto requerir√° operaciones <code>IL</code> no triviales y necesariamente conducir√° a un error.  Pero a√∫n podemos intentar implementar operaciones b√°sicas. </p><br><p>  Para mi sorpresa, <code>Visual Studio</code> no contiene plantillas para proyectos <code>IL</code> y archivos <code>IL</code> .  No puede simplemente tomar y describir parte del c√≥digo en <code>IL</code> e incluirlo en su ensamblaje.  Naturalmente, el c√≥digo abierto viene en nuestra ayuda.  El proyecto <a href="https://github.com/ins0mniaque/ILSupport" rel="nofollow"><code>ILSupport</code></a> contiene plantillas para proyectos <code>IL</code> , as√≠ como un conjunto de instrucciones que se pueden agregar a <code>*.csproj</code> para incluir el c√≥digo <code>IL</code> en el proyecto.  Por supuesto, describir todo en <code>IL</code> es bastante dif√≠cil, por lo que el autor del proyecto usa el atributo <a href="https://docs.microsoft.com/en-us/dotnet/api/system.runtime.compilerservices.methodimplattribute%3Fview%3Dnetcore-3.0" rel="nofollow"><code>MethodImpl</code></a> incorporado con el indicador <a href="https://docs.microsoft.com/en-us/dotnet/api/system.runtime.compilerservices.methodimploptions%3Fredirectedfrom%3DMSDN%26view%3Dnetcore-3.0" rel="nofollow"><code>ForwardRef</code></a> .  Este atributo le permite declarar el m√©todo como <code>extern</code> y no describir el cuerpo del m√©todo.  Se parece a esto: </p><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">MethodImpl(MethodImplOptions.ForwardRef)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> T Add&lt;T&gt;(T left, T right) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : unmanaged;</code> </pre> <br><p>  El siguiente paso es escribir la implementaci√≥n del m√©todo en el archivo <code>*.il</code> con el c√≥digo <code>IL</code> : </p><br><pre> <code class="cs hljs">.method <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> hidebysig !!T Add&lt;valuetype .ctor (<span class="hljs-keyword"><span class="hljs-keyword">class</span></span> [<span class="hljs-title"><span class="hljs-title">mscorlib</span></span>]<span class="hljs-title"><span class="hljs-title">System</span></span>.<span class="hljs-title"><span class="hljs-title">ValueType</span></span> <span class="hljs-title"><span class="hljs-title">modreq</span></span> ([<span class="hljs-title"><span class="hljs-title">mscorlib</span></span>]<span class="hljs-title"><span class="hljs-title">System</span></span>.<span class="hljs-title"><span class="hljs-title">Runtime</span></span>.<span class="hljs-title"><span class="hljs-title">InteropServices</span></span>.<span class="hljs-title"><span class="hljs-title">UnmanagedType</span></span>)) <span class="hljs-title"><span class="hljs-title">T</span></span>&gt;(!!<span class="hljs-title"><span class="hljs-title">T</span></span> <span class="hljs-title"><span class="hljs-title">left</span></span>, !!<span class="hljs-title"><span class="hljs-title">T</span></span> <span class="hljs-title"><span class="hljs-title">right</span></span>) <span class="hljs-title"><span class="hljs-title">cil</span></span> <span class="hljs-title"><span class="hljs-title">managed</span></span> { .param type [<span class="hljs-number"><span class="hljs-number">1</span></span>] .custom instance <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> System.Runtime.CompilerServices.IsUnmanagedAttribute::.ctor() = (<span class="hljs-number"><span class="hljs-number">01</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> ) ldarg<span class="hljs-number"><span class="hljs-number">.0</span></span> ldarg<span class="hljs-number"><span class="hljs-number">.1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> ret }</code> </pre> <br><p>  En ninguna parte se refiere expl√≠citamente al tipo <code>!!T</code> , sugerimos que el <code>CLR</code> agregue dos argumentos y devuelva el resultado.  No <strong>hay</strong> controles de tipo, y todo est√° en la conciencia del desarrollador.  Sorprendentemente, funciona, y <em>relativamente</em> r√°pido. </p><br><h2 id="nemnogo-benchmarka">  Un poco de referencia </h2><br><p>  Probablemente, un punto de referencia honesto se basar√≠a en una expresi√≥n bastante compleja, cuyo c√°lculo "frontal" se comparar√≠a con estos peligrosos m√©todos <code>IL</code> .  Escrib√≠ un algoritmo simple que resume los cuadrados de n√∫meros previamente calculados y almacenados en una matriz <code>double</code> y divide la cantidad final por el n√∫mero de n√∫meros.  Para realizar la operaci√≥n, utilic√© los operadores <code>C#</code> <code>+</code> , <code>*</code> y <code>/</code> , como lo hacen las personas sanas, las funciones creadas con <code>Expressions</code> y las funciones <code>IL</code> . </p><br><div class="spoiler">  <b class="spoiler_title">Los resultados son aproximadamente los siguientes:</b> <div class="spoiler_text"><ul><li>  <code>DirectSum</code> es la suma usando operadores est√°ndar <code>+</code> , <code>*</code> y <code>/</code> ; </li><li>  <code>BranchSum</code> utiliza la ramificaci√≥n por tipo y convierte a trav√©s del <code>object</code> ; </li><li>  <code>UnsafeBranchSum</code> utiliza ramificaciones por tipo y se <code>Unsafe.As&lt;,&gt;()</code> trav√©s de <code>Unsafe.As&lt;,&gt;()</code> ; </li><li>  <code>ExpressionSum</code> utiliza <code>ExpressionSum</code> cach√© para cada operaci√≥n ( <code>Expression</code> ); </li><li>  <code>UnsafeSum</code> usa el c√≥digo <code>IL</code> inseguro presentado en el art√≠culo </li></ul><br><p>  Punto de referencia de la carga √∫til: sumar los cuadrados de elementos de una matriz precargada aleatoriamente de tipo <code>double</code> y tama√±o <code>N</code> , seguido de dividir la suma por <code>N</code> y almacenarla;  optimizaciones incluidas. </p><br><pre> <code class="plaintext hljs">BenchmarkDotNet=v0.12.0, OS=Windows 10.0.18362 Intel Core i7-2700K CPU 3.50GHz (Sandy Bridge), 1 CPU, 8 logical and 4 physical cores .NET Core SDK=3.1.100 [Host] : .NET Core 3.1.0 (CoreCLR 4.700.19.56402, CoreFX 4.700.19.56404), X64 RyuJIT Job-POXTAH : .NET Core 3.1.0 (CoreCLR 4.700.19.56402, CoreFX 4.700.19.56404), X64 RyuJIT Runtime=.NET Core 3.1</code> </pre><br><div class="scrollable-table"><table><thead><tr><th>  M√©todo </th><th>  N </th><th>  Media </th><th>  Error </th><th>  Stddev </th><th>  Ratio </th><th>  RatioSD </th></tr></thead><tbody><tr><td>  <strong>Directsum</strong> </td><td>  <strong>1000</strong> </td><td>  <strong>2.128 nosotros</strong> </td><td>  <strong>0.0341 nosotros</strong> </td><td>  <strong>0.0303 nosotros</strong> </td><td>  <strong>1.00</strong> </td><td>  <strong>0.00</strong> </td></tr><tr><td>  Branchum </td><td>  1000 </td><td>  57.468 nosotros </td><td>  0.4478 nosotros </td><td>  0.3496 nosotros </td><td>  26,97 </td><td>  0,46 </td></tr><tr><td>  InseguroRamaSum </td><td>  1000 </td><td>  72.924 nosotros </td><td>  0.4131 nosotros </td><td>  0.3864 nosotros </td><td>  34,28 </td><td>  0,50 </td></tr><tr><td>  Expresi√≥nSum </td><td>  1000 </td><td>  144.555 nosotros </td><td>  2.5182 nosotros </td><td>  2.2323 nosotros </td><td>  67,94 </td><td>  1,29 </td></tr><tr><td>  Unsafesum </td><td>  1000 </td><td>  5.054 nosotros </td><td>  0.0324 nosotros </td><td>  0.0303 nosotros </td><td>  2,37 </td><td>  0,03 </td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  <strong>Directsum</strong> </td><td>  <strong>10,000</strong> </td><td>  <strong>21.174 nosotros</strong> </td><td>  <strong>0.3092 nosotros</strong> </td><td>  <strong>0.2741 nosotros</strong> </td><td>  <strong>1.00</strong> </td><td>  <strong>0.00</strong> </td></tr><tr><td>  Branchum </td><td>  10,000 </td><td>  573.972 nosotros </td><td>  2.9274 nosotros </td><td>  2.5951 nosotros </td><td>  27/11 </td><td>  0,40 </td></tr><tr><td>  InseguroRamaSum </td><td>  10,000 </td><td>  735.031 nosotros </td><td>  9.1016 nosotros </td><td>  8.0683 nosotros </td><td>  34,72 </td><td>  0,53 </td></tr><tr><td>  Expresi√≥nSum </td><td>  10,000 </td><td>  1,462.593 us </td><td>  9.0932 nosotros </td><td>  8.0609 nosotros </td><td>  69,09 </td><td>  1.02 </td></tr><tr><td>  Unsafesum </td><td>  10,000 </td><td>  50.388 nosotros </td><td>  0.3956 nosotros </td><td>  0.3701 nosotros </td><td>  2,38 </td><td>  0,03 </td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  <strong>Directsum</strong> </td><td>  <strong>100,000</strong> </td><td>  <strong>210.021 nosotros</strong> </td><td>  <strong>1.9832 nosotros</strong> </td><td>  <strong>1.7581 nosotros</strong> </td><td>  <strong>1.00</strong> </td><td>  <strong>0.00</strong> </td></tr><tr><td>  Branchum </td><td>  100,000 </td><td>  6.046.340 nosotros </td><td>  86.9740 us </td><td>  77.1002 nosotros </td><td>  28,79 </td><td>  0,42 </td></tr><tr><td>  InseguroRamaSum </td><td>  100,000 </td><td>  7,406.489 nosotros </td><td>  65.7415 nosotros </td><td>  58.2782 nosotros </td><td>  35,27 </td><td>  0.27 </td></tr><tr><td>  Expresi√≥nSum </td><td>  100,000 </td><td>  14.021.642 nosotros </td><td>  189,2625 nosotros </td><td>  167.7763 us </td><td>  66,77 </td><td>  0,88 </td></tr><tr><td>  Unsafesum </td><td>  100,000 </td><td>  505.551 nosotros </td><td>  2.3662 nosotros </td><td>  2.2133 nosotros </td><td>  2,41 </td><td>  0,03 </td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>  <strong>Directsum</strong> </td><td>  <strong>1,024,000</strong> </td><td>  <strong>2,306.751 nosotros</strong> </td><td>  <strong>22.4173 nosotros</strong> </td><td>  <strong>20.9692 nosotros</strong> </td><td>  <strong>1.00</strong> </td><td>  <strong>0.00</strong> </td></tr><tr><td>  Branchum </td><td>  1,024,000 </td><td>  61,643.224 nosotros </td><td>  610.3048 nosotros </td><td>  570.8795 nosotros </td><td>  26,72 </td><td>  0.28 </td></tr><tr><td>  InseguroRamaSum </td><td>  1,024,000 </td><td>  75,644.639 us </td><td>  494.4096 nosotros </td><td>  462.4711 nosotros </td><td>  32,80 </td><td>  0,39 </td></tr><tr><td>  Expresi√≥nSum </td><td>  1,024,000 </td><td>  154,327.137 nosotros </td><td>  1,267.2469 nosotros </td><td>  1.185,3835 nosotros </td><td>  66,91 </td><td>  0,55 </td></tr><tr><td>  Unsafesum </td><td>  1,024,000 </td><td>  5,295.990 us </td><td>  14.9537 nosotros </td><td>  12.4871 nosotros </td><td>  2,29 </td><td>  0,02 </td></tr></tbody></table></div></div></div><br><p>  Nuestro c√≥digo inseguro es aproximadamente <code>2.5</code> veces m√°s lento (en t√©rminos de una operaci√≥n).  Esto se puede atribuir al hecho de que en el caso de un c√°lculo de "frente", el compilador compila <code>a + b</code> en el c√≥digo de operaci√≥n <code>add</code> , y en el caso de un m√©todo inseguro, se llama a una funci√≥n est√°tica, que es naturalmente m√°s lenta. </p><br><h2 id="vmesto-zaklyucheniya-kogda-true--true">  En lugar de concluir: cuando es <code>true != true</code> </h2><br><p>  Hace unos d√≠as, me encontr√© con un <a href="https://twitter.com/jaredpar/status/1205540750764625920" rel="nofollow">tweet de</a> Jared Parsons: </p><br><blockquote>  Hay casos en los que lo siguiente imprimir√° "falso" <br>  bool b = ... <br>  if (b) Console.WriteLine (b.IsTrue ()); </blockquote><p>  Esta fue la respuesta a <a href="https://twitter.com/vreshetnikov/status/1204929378368417792" rel="nofollow">esta entrada</a> , que muestra el c√≥digo de verificaci√≥n de <code>bool</code> para <code>true</code> , que se parece a esto: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsTrue</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (b == <span class="hljs-literal"><span class="hljs-literal">true</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (b == <span class="hljs-literal"><span class="hljs-literal">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !<span class="hljs-literal"><span class="hljs-literal">true</span></span> &amp;&amp; !<span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><p>  Los cheques parecen redundantes, ¬øverdad?  Jared da un contraejemplo que demuestra <a href="https://gist.github.com/jaredpar/a0835afc71139284c09bfda203d8c011" rel="nofollow">algunas de las caracter√≠sticas</a> del comportamiento <code>bool</code> .  La idea es que <code>bool</code> es <code>byte</code> ( <code>sizeof(bool) == 1</code> ), mientras que <code>false</code> coincide con <code>0</code> y <code>true</code> coincide con <code>1</code> .  Siempre y cuando no balancees los punteros, <code>bool</code> comporta de manera inequ√≠voca y previsible.  Sin embargo, como ha demostrado Jared, puede crear un <code>bool</code> usando <code>2</code> como valor inicial, y algunas de las comprobaciones fallar√°n correctamente: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> b = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>* ptr = (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>*)&amp;b; *ptr = <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre> <br><p>  Podemos lograr un efecto similar usando nuestras operaciones matem√°ticas inseguras (esto no funciona con <code>Expressions</code> ): </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fakeTrue = Subtract&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt;(<span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> val = *(<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>*)&amp;fakeTrue; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(fakeTrue) Assert.AreNotEqual(fakeTrue, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Assert.Fail(<span class="hljs-string"><span class="hljs-string">"Clause not entered."</span></span>);</code> </pre> <br><p>  S√≠, s√≠, verificamos dentro de la rama <code>true</code> si la condici√≥n es <code>true</code> y esperamos que, de hecho, no sea <em><code>true</code></em> .  ¬øPor qu√© es esto as√≠?  Si resta de <code>0</code> ( <code>=false</code> ) <code>1</code> ( <code>=true</code> ) sin comprobaciones, para el <code>byte</code> ser√° igual a <code>255</code> .  Naturalmente, <code>255</code> (nuestro <code>fakeTrue</code> ) no es <code>1</code> (verdadero <code>true</code> ), por lo que se ejecuta <code>fakeTrue</code> .  La ramificaci√≥n funciona de manera diferente. </p><br><p>  <code>if</code> produce inversi√≥n: se inserta una rama condicional;  si la condici√≥n es <em>falsa</em> , se produce una transici√≥n al punto despu√©s del final del bloque <code>if</code> .  La validaci√≥n se realiza mediante la <code>brfalse_S</code> <code>brfalse</code> / <code>brfalse_S</code> .  Compara el √∫ltimo valor en la pila con <em>cero</em> .  Si el valor es cero, entonces es <code>false</code> , pasamos por encima del bloque <code>if</code> .  En nuestro caso, <code>fakeTrue</code> simplemente no es igual a cero, por lo que la verificaci√≥n pasa y la ejecuci√≥n contin√∫a dentro del bloque <code>if</code> , donde comparamos <code>fakeBool</code> con el valor verdadero y obtenemos un resultado negativo. </p><br><p>  UPD01: <br>  Despu√©s de discutir en los comentarios con <a href="https://habr.com/en/users/shai_hulud/" class="user_link">shai_hulud</a> y <a href="https://habr.com/en/users/shai_hulud/" class="user_link">blowin</a> , agregu√© otro m√©todo a los puntos de referencia que implementa una rama como <code>if(typeof(T) == typeof(int)) return (T)(object)((int)(object)left + (int)(object)right);</code>  .  A pesar del hecho de que <code>JIT</code> deber√≠a optimizar las comprobaciones, al menos cuando <code>T</code> es una <code>struct</code> , dichos m√©todos a√∫n funcionan un orden de magnitud m√°s lento.  No es obvio si las transformaciones <code>T</code> -&gt; <code>int</code> -&gt; <code>T</code> optimizadas, o si se usa boxing / unboxing.  Los resultados del punto de referencia <code>MethodImpl</code> ven afectados significativamente por los indicadores <code>MethodImpl</code> . </p><br><p>  UPD02: <br>  <a href="https://habr.com/en/users/xxxvano/" class="user_link">xXxVano</a> en los comentarios mostr√≥ un ejemplo de uso de ramificaci√≥n por tipo y convierte <code>T</code> &lt;--&gt; un tipo espec√≠fico usando <code>Unsafe.As&lt;TFrom, TTo&gt;()</code> .  Por analog√≠a con la ramificaci√≥n habitual y el <code>object</code> personalizado personalizado, escrib√≠ tres operaciones (suma, multiplicaci√≥n y divisi√≥n) con ramificaci√≥n para todos los tipos aritm√©ticos, despu√©s de lo cual agregu√© otro punto de referencia ( <code>UnsafeBranchSum</code> ).  A pesar del hecho de que todos los m√©todos (excepto las expresiones) generan un c√≥digo ASM casi id√©ntico (hasta donde mi limitado conocimiento del ensamblador me permite juzgar), por alguna raz√≥n desconocida, ambos m√©todos con ramificaci√≥n son muy lentos en comparaci√≥n con la suma directa ( <code>DirectSum</code> ) y utilizando gen√©ricos y c√≥digo <code>IL</code> .  No tengo ninguna explicaci√≥n para este efecto, el hecho de que el tiempo dedicado crece proporcionalmente a <code>N</code> indica que hay alg√∫n tipo de sobrecarga constante para <em>cada</em> operaci√≥n, a pesar de toda la magia de <code>JIT</code> .  Falta esta sobrecarga en la versi√≥n <code>IL</code> de los m√©todos.   ,   <code>IL</code> -    ,    /    /  ,          100%  (  ,   ). <br>   ,      , -       . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/480416/">https://habr.com/ru/post/480416/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../480402/index.html">¬øC√≥mo pÃ∂–µÃ∂—Ä T–≤Ã∂—ãÃ∂–πÃ∂ el segundo mitap de Android de Tinkoff</a></li>
<li><a href="../480404/index.html">Mikrotik y Linux. Rutina y Automatizaci√≥n</a></li>
<li><a href="../480408/index.html">52 conjuntos de datos para proyectos de capacitaci√≥n</a></li>
<li><a href="../480412/index.html">Alexei Ragozin sobre las caracter√≠sticas nuevas y antiguas de Java Flight Recorder en OpenJDK 11 en la reuni√≥n jug.msk.ru</a></li>
<li><a href="../480414/index.html">El resumen de materiales frescos del mundo del front-end para la √∫ltima semana No. 393 (9 al 15 de diciembre de 2019)</a></li>
<li><a href="../480420/index.html">Entrevista con Matthew "Oki" O'Connor sobre la aterosclerosis y su tratamiento</a></li>
<li><a href="../480422/index.html">Gu√≠a de estilo de Google en C ++. Parte 1</a></li>
<li><a href="../480424/index.html">Gu√≠a de estilo de Google en C ++. Parte 9</a></li>
<li><a href="../480430/index.html">C√≥mo funciona el c√≥dec de video. Parte 2. Qu√©, por qu√©, c√≥mo</a></li>
<li><a href="../480432/index.html">El problema del primer espectador, o la dif√≠cil conversi√≥n de las transmisiones de video WebRTC a HLS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>