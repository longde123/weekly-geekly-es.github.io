<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>âŒ ğŸ‘¦ğŸ¾ ğŸ…ğŸ½ Kursus MIT "Keamanan Sistem Komputer". Kuliah 3: Buffer Overflows: Eksploitasi dan Perlindungan, Bagian 1 ğŸ¤šğŸ¿ ğŸ‘¨ğŸ¾â€ğŸ”¬ ğŸ‘ï¸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Institut Teknologi Massachusetts. Kursus Kuliah # 6.858. "Keamanan sistem komputer." Nikolai Zeldovich, James Mickens. Tahun 2014 
 Keamanan Sistem Ko...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kursus MIT "Keamanan Sistem Komputer". Kuliah 3: Buffer Overflows: Eksploitasi dan Perlindungan, Bagian 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ua-hosting/blog/416839/"><h3>  Institut Teknologi Massachusetts.  Kursus Kuliah # 6.858.  "Keamanan sistem komputer."  Nikolai Zeldovich, James Mickens.  Tahun 2014 </h3><br>  Keamanan Sistem Komputer adalah kursus tentang pengembangan dan implementasi sistem komputer yang aman.  Ceramah mencakup model ancaman, serangan yang membahayakan keamanan, dan teknik keamanan berdasarkan pada karya ilmiah baru-baru ini.  Topik meliputi keamanan sistem operasi (OS), fitur, manajemen aliran informasi, keamanan bahasa, protokol jaringan, keamanan perangkat keras, dan keamanan aplikasi web. <br><br>  Kuliah 1: â€œPendahuluan: model ancamanâ€ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 3</a> <br>  Kuliah 2: "Kontrol serangan hacker" <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 3</a> <br>  Kuliah 3: â€œBuffer Overflows: Exploits and Protectionâ€ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 3</a> <a name="habracut"></a><br><br>  Selamat datang di ceramah tentang eksploitasi untuk buffer overflows.  Hari ini kita akan mengakhiri diskusi tentang <b>batas</b> - <b>batas Baggy</b> dan kemudian beralih ke metode perlindungan buffer overflow lainnya. <br><br><img src="https://habrastorage.org/webt/oq/lp/5p/oqlp5prpdjjnr1e7sdxhtnp_pay.jpeg"><br><br>  Selanjutnya, kita akan berbicara tentang materi cetak kuliah hari ini, yang dikhususkan untuk <b>Pemrograman Berorientasi Buta (BROP)</b> - pemrograman berorientasi-balik buta.  Ini adalah teknik eksploitasi yang dapat dilakukan bahkan jika penyerang tidak memiliki biner target.  Eksploitasi ini bertujuan menghancurkan "kenari" di tumpukan sistem 64-bit.  Jadi jika Anda seperti saya ketika saya pertama kali membaca materi ini, Anda seharusnya merasa seperti menonton film Christopher Nolan.  Itu hanya ledakan otak! <br><br>  Kami akan mempertimbangkan bagaimana gadget ini berfungsi dengan baik.  Oleh karena itu, saya berharap bahwa pada akhir kuliah Anda akan dapat memahami semua teknologi tinggi yang dijelaskan dalam materi kuliah ini.  Tapi pertama-tama, seperti yang saya katakan, kita akan mengakhiri diskusi tentang <b>batas-batas Baggy</b> .  Pertimbangkan contoh yang sangat sederhana. <br><br>  Misalkan kita akan menetapkan pointer <b>p</b> dan mengalokasikan ukuran 44 byte untuknya.  Asumsikan juga bahwa ukuran slot adalah 16 byte. <br><br>  Apa yang terjadi ketika kami menetapkan fungsi <b>malloc</b> ?  Anda sudah tahu bahwa dalam hal ini sistem <b>batas Baggy</b> akan mencoba melengkapi distribusi ini dengan logaritma <b>2n</b> .  Jadi untuk pointer kita 44 byte, 64 byte memori akan dialokasikan.  Tetapi ukuran slot adalah 16 byte, jadi kami akan membuat 64/16 = 4 tabel batas masing-masing 16 byte.  Setiap entri ini akan ditempatkan di log distribusi ukuran. <br><br>  Selanjutnya, tetapkan pointer pointer lain <b>* q = p + 60</b> .  Kami melihat bahwa nilai ini di luar batas karena ukuran <b>p</b> adalah 44 byte, dan di sini 60 byte.  Tapi <b>batas Baggy</b> bekerja sehingga dalam hal ini tidak ada hal <b>buruk yang</b> akan terjadi, meskipun programmer seharusnya tidak melakukannya. <br><br>  Sekarang mari kita asumsikan bahwa hal berikutnya yang kita lakukan adalah menetapkan pointer lain, yang akan sama dengan <b>char * r = q + 16</b> .  Sekarang ini sebenarnya akan menyebabkan kesalahan, karena ukuran offset akan menjadi 60 + 16 = 76, yang merupakan 12 byte lebih besar dari 4 slot (4x16 = 64 byte) yang <b>dialokasikan</b> sistem <b>batas Baggy</b> .  Dan kelebihan ini benar-benar lebih dari setengah slot. <br><br><img src="https://habrastorage.org/webt/tr/dc/6t/trdc6tmpujijucydynnv2t5ojyw.jpeg"><br><br>  Jika Anda ingat, dalam hal ini sistem <b>Batas Baggy akan</b> segera merespons kesalahan sinkronisasi kritis, yang akan menyebabkan program macet dan benar-benar menghentikannya. <br><br>  Jadi mari kita bayangkan bahwa kita hanya memiliki dua baris: <br><br>  <b>char * p = malloc (44)</b> <b><br></b>  <b>char * q = p + 60</b> <br><br>  Dan tidak ada baris ketiga dengan kode tersebut.  Sebaliknya, kami akan melakukan ini: <br><br>  <b>char * s = q + 8</b> <br><br>  Dalam hal ini, pointer akan memiliki nilai 60 + 8 = 68 bit, yang akan menjadi 4 byte lebih dari batas yang ditetapkan oleh <b>batas Baggy</b> .  Bahkan, ini tidak akan menyebabkan kesalahan kritis, meskipun nilainya melampaui batas.  Apa yang kami lakukan di sini adalah mengatur bit orde tinggi untuk pointer.  Jadi, jika seseorang kemudian mencoba mereduksinya, ini akan menyebabkan kesalahan kritis pada saat ini. <br><br><img src="https://habrastorage.org/webt/xp/i-/p-/xpi-p-rmy0hsdh3f53yw6qrtb0o.jpeg"><br><br>  Dan hal terakhir yang akan kita lakukan adalah menetapkan pointer lain: <br><br>  <b>char * t = s - 32</b> <br><br>  Faktanya, kami melakukan ini - kami mengembalikan pointer ke perbatasan.  Jadi jika awalnya <b>s</b> melampaui, maka sekarang kita telah mengembalikannya ke volume yang dialokasikan sebelumnya yang kita buat untuk pointer.  Oleh karena itu, sekarang <b>t</b> tidak akan memiliki bit orde tinggi dalam komposisinya, dan dapat dengan mudah dideferensikan. <br><br><img src="https://habrastorage.org/webt/27/2g/y6/272gy657iydta1tibemfmgqhcxe.jpeg"><br><br>  <b>Audiens:</b> bagaimana program mengetahui bahwa <b>r</b> memiliki kelebihan lebih dari setengah tumpukan? <br><br>  <b>Profesor Mickens:</b> perhatikan bahwa ketika kami membuat <b>r</b> , kami mendapat kode alat yang akan bekerja di semua operasi ini dengan pointer.  Jadi kita bisa tahu di mana <b>q</b> akan ditempatkan, dan kita tahu bahwa itu berada dalam <b>batas-batas Baggy</b> .  Karena itu, ketika kami melakukan operasi ini <b>q + 16</b> , alat <b>Baggy bounds</b> tahu dari mana nilai awal ini berasal.  Dan kemudian, jika offset dari ukuran asli ini <b>terjadi</b> , <b>batas Baggy akan</b> dengan mudah menentukan bahwa offset lebih besar dari Â½ dari ukuran slot. <br><br>  Pada prinsipnya, ketika Anda melakukan operasi dengan pointer, Anda harus melihat apakah mereka melebihi ukuran yang dialokasikan atau tidak.  Pada titik tertentu, Anda memiliki pointer yang terletak di dalam batas batas <b>Baggy</b> , dan kemudian terjadi sesuatu yang membuatnya melampaui batas.  Jadi, tepat ketika ini terjadi, kita akan menemukan bahwa semacam â€œmerajutâ€ kode kita. <br><br>  Semoga ini bisa dimengerti.  Itu adalah ikhtisar pekerjaan rumah yang sangat singkat, tetapi saya harap Anda dapat dengan mudah memahaminya. <br><br>  Jadi, kami memiliki pointer yang terlihat seperti ini: <br><br>  <b>char * p = malloc (256)</b> , lalu kita tambahkan pointer <b>char * q = p + 256</b> , setelah itu kita akan mencoba untuk meringkas pointer ini. <br><br>  Jadi apa yang akan terjadi?  Perhatikan bahwa 256 adalah urutan <b>2n</b> , jadi itu akan berada dalam <b>batas Baggy</b> .  Oleh karena itu, ketika kita menambahkan 256 bit, ini berarti bahwa kita membuat lintasan lain ke ujung <b>batas batas Baggy</b> .  Seperti pada contoh sebelumnya, baris ini cukup baik, tetapi mengarah pada fakta bahwa bit pesanan yang lebih tinggi akan ditetapkan untuk <b>q</b> .  Karena itu, ketika kami mencoba untuk menundanya, semuanya akan meledak dan harus menghubungi agen asuransi kami.  Apakah itu jelas? <br><br><img src="https://habrastorage.org/webt/mk/oe/hn/mkoehn3hnwp9d100bt_wre7a2xg.jpeg"><br><br>  Dari 2 contoh ini, Anda dapat memahami cara <b>kerja</b> sistem <b>Batas Baggy</b> .  Seperti yang saya sebutkan di kuliah terakhir, Anda tidak perlu benar-benar instrumen setiap operasi pointer jika Anda dapat menggunakan analisis kode statis untuk mengetahui bahwa serangkaian operasi pointer tertentu aman.  Saya akan menunda diskusi lebih lanjut dari beberapa analisis statis, tetapi cukup untuk mengatakan bahwa Anda tidak selalu perlu melakukan tindakan matematika ini, kami telah memeriksa ini sebelumnya. <br><br>  Pertanyaan lain yang disebutkan di Piazza: bagaimana memastikan kompatibilitas <b>batas</b> - <b>batas Baggy</b> dengan perpustakaan non-alat sebelumnya.  Idenya adalah bahwa ketika <b>Baggy terikat</b> menginisialisasi tabel perbatasan, mereka menetapkan bahwa semua catatan harus dalam 31 bit.  Oleh karena itu, ketika kita membaca tabel batas, setiap rekaman di dalamnya mewakili nilai dari formulir <b>2n + 31</b> .  Jadi, menginisialisasi batas-batas awal ukuran 31 bit, kami mengasumsikan bahwa setiap pointer akan memiliki ukuran maksimum yang mungkin sebesar <b>2n + 31</b> .  Biarkan saya memberi Anda contoh yang sangat sederhana yang akan membuat ini jelas. <br><br>  Misalkan kita memiliki ruang memori yang kita gunakan untuk tumpukan.  Ruang memori ini terdiri dari dua komponen.  Di bagian atas, kami memiliki tumpukan yang telah dialokasikan menggunakan kode non-alat, dan di bawah ini adalah tumpukan yang telah dialokasikan dengan kode alat.  Jadi apa yang akan dilakukan <b>batasan Baggy</b> ?  Seperti yang Anda ingat, sistem ini memiliki konsep slot, yang ukurannya 16 bit.  Oleh karena itu, tabel batas akan terdiri dari 2 bagian, dimulai dari 31 bit. <br><br>  Namun, ketika menjalankan kode alat, itu sebenarnya akan menggunakan algoritma <b>batas Baggy</b> untuk menetapkan nilai yang sesuai untuk baris tabel ini. <br><br><img src="https://habrastorage.org/webt/vu/bp/wb/vubpwbtkublhjc6ay3ytcek6j-y.jpeg"><br><br>  Ketika sebuah pointer datang dari atas ruang memori, selalu diatur ke batas maksimum <b>2n + 31</b> .  Ini berarti bahwa <b>batas Baggy</b> tidak akan pernah mempertimbangkan bahwa operasi penunjuk yang telah "datang" dari pustaka non-alat dapat melampaui batas. <br><br>  Idenya adalah bahwa dalam kode alat, kita akan selalu melakukan perbandingan ini untuk pointer, tetapi jika kita menetapkan batas penulisan pointer untuk kode non-alat dari formulir <b>2n + 31</b> , maka kita tidak akan pernah memiliki kesalahan dereferensi.  Artinya, kami memiliki interaksi yang baik antara <b>entri</b> kode <b>batas Baggy</b> dan <b>catatan</b> non-instrumental dari perpustakaan sebelumnya. <br><br>  Ini berarti bahwa kami memiliki sistem ini, yang bagus, karena tidak merusak program saat menggunakan pustaka non-alat, tetapi ia memiliki masalah.  Masalahnya adalah bahwa kita tidak pernah dapat menentukan batas pointer yang dihasilkan oleh kode non-alat.  Karena kita tidak akan pernah mengatur bit orde tinggi ketika, misalnya, pointer ini mendapat terlalu banyak atau terlalu sedikit ruang.  Jadi, kami sebenarnya tidak dapat memastikan keamanan memori untuk operasi yang terjadi saat menggunakan kode non-instrumental.  Anda juga tidak dapat menentukan kapan kami meneruskan pointer yang melampaui batas ukuran dari kode instrumental ke kode non-instrumental.  Dalam hal ini, sesuatu yang tak terbayangkan dapat terjadi.  Jika Anda memiliki pointer yang ditarik dari kode alat, maka bit set orde tinggi diatur ke 1. Jadi sepertinya ia memiliki dimensi raksasa. <br><br>  Kami tahu bahwa jika kami hanya menempatkan kode ini dalam kode alat, kami dapat menghapus tanda ini di beberapa titik saat kembali ke perbatasan.  Tetapi jika kita hanya mengirimkan alamat yang sangat besar ini ke kode non-instrumental, maka itu dapat melakukan sesuatu yang tidak terbayangkan.  Bahkan mungkin mengembalikan pointer ini kembali ke batas, tetapi kita tidak akan pernah memiliki kesempatan untuk menghapus bit orde tinggi ini.  Jadi kita masih dapat memiliki masalah bahkan ketika menggunakan rangkaian yang ditunjukkan di sini. <br><br>  <b>Audiens:</b> jika kita memiliki kode alat untuk mengalokasikan memori, apakah ia menggunakan fungsi <b>malloc yang</b> sama dengan yang digunakan kode atribut? <br><br>  <b>Profesor:</b> Ini adalah pertanyaan yang sulit.  Jika kita mempertimbangkan kasusnya di sini, maka ini diamati dengan seksama, karena kita memiliki dua bidang memori, yang masing-masing mematuhi aturan yang ditetapkan untuk itu.  Tetapi pada prinsipnya, itu akan tergantung pada kode yang menggunakan bahasa pemrograman yang dipilih.  Bayangkan dalam C ++, misalnya, Anda dapat menetapkan kualifikasi Anda sendiri.  Jadi itu tergantung pada detail kode tertentu. <br><br>  <b>Pemirsa:</b> bagaimana kualifikasi dapat memeriksa apakah batasnya diatur ke 31 bit atau tidak? <br><br>  <b>Profesor:</b> di tingkat bawah, algoritma distribusi berfungsi sehingga saat Anda memanggil sistem yang tidak dikenal, penunjuknya bergerak ke atas.  Jadi, jika Anda memiliki beberapa pengalokasi, maka mereka semua mencoba mengalokasikan memori, masing-masing memiliki sepotong ingatan sendiri, yang mereka simpan sendiri, pada dasarnya, dengan benar.  Jadi dalam kehidupan nyata itu bisa lebih terfragmentasi daripada di level tinggi. <br><br>  Jadi, semua yang kami periksa di atas terkait dengan pengoperasian <b>batas Baggy</b> dalam sistem 32-bit.  Pertimbangkan apa yang terjadi ketika menggunakan sistem 64-bit.  Dalam sistem seperti itu, Anda sebenarnya dapat menyingkirkan tabel batas, karena kami dapat menyimpan beberapa informasi tentang batas-batas dalam pointer itu sendiri. <br><br>  Pertimbangkan seperti apa penunjuk biasa di batas Baggy.  Ini terdiri dari 3 bagian.  21 bit dialokasikan untuk bagian pertama, nol, 5 bit lainnya dialokasikan untuk ukuran, ini adalah ukuran utama dari log, dan 38 bit lainnya adalah bit dari alamat biasa. <br><br><img src="https://habrastorage.org/webt/gb/r5/6m/gbr56manocplt3wn7ueqgoxpcne.jpeg"><br><br>  Alasan mengapa ini tidak secara besar-besaran membatasi ukuran alamat program yang Anda gunakan adalah bahwa sebagian besar bit orde tinggi dari sistem operasi dan / atau peralatan yang terletak di 2 bagian pertama dari pointer tidak memungkinkan aplikasi digunakan karena berbagai alasan.  Jadi, ternyata, kami tidak banyak mengurangi jumlah aplikasi yang digunakan dalam sistem.  Seperti inilah tampilan pointer biasa. <br><br>  Apa yang terjadi ketika kita hanya memiliki satu dari petunjuk ini?  Nah, pada sistem 32-bit, yang bisa kita lakukan hanyalah mengatur bit pesanan tinggi dan berharap benda ini tidak akan pernah mendapatkan lebih dari setengah ukuran slot.  Tetapi sekarang karena kita memiliki semua ruang alamat tambahan ini, Anda dapat meletakkan offset di luar batas OOB (di luar batas) langsung di pointer ini.  Jadi kita bisa melakukan sesuatu seperti yang ditunjukkan pada gambar, membagi pointer menjadi 4 bagian dan mendistribusikan kembali ukurannya. <br><br>  Dengan demikian, kita bisa mendapatkan 13 bit untuk batas offset, yaitu, tulis seberapa jauh penunjuk OOB ini dari tempat seharusnya.  Kemudian lagi, Anda dapat mengatur ukuran sebenarnya dari objek yang ditunjukkan di sini menjadi 5, dan sisanya dari bagian nol, yang sekarang akan menjadi 21-13 = 8 bit.  Dan kemudian ikuti bagian alamat kami dari 38 bit.  Dalam contoh ini, Anda melihat keuntungan menggunakan sistem 64-bit. <br><br><img src="https://habrastorage.org/webt/vx/ja/mp/vxjamp6bu-jxmc5xfrslev98o-s.jpeg"><br><br>  Perhatikan bahwa di sini kita memiliki ukuran biasa untuk pointer biasa, dalam kedua kasus ukuran ini adalah 64 bit, dan deskripsinya adalah dasar.  Dan ini bagus, karena ketika menggunakan pointer "tebal", kita perlu banyak kata untuk menggambarkannya. <br>  Saya juga mencatat bahwa kode non-alat dapat dengan mudah diterapkan di sini, karena ia berfungsi dan menggunakan ukuran yang sama dengan pointer biasa.  Kita bisa meletakkan hal-hal ini di sebuah <b>struct</b> , misalnya, dan ukuran <b>struct</b> ini akan tetap tidak berubah.  Jadi ini sangat bagus ketika kita memiliki kesempatan untuk bekerja di dunia 64-bit. <br><br>  <b>Hadirin:</b> mengapa pada kasus kedua offset terletak di depan ukuran, dan tidak seperti pada kasus sebelumnya, dan apa yang akan terjadi jika ukuran offset besar? <br><br>  <b>Profesor:</b> Saya pikir dalam beberapa kasus kita memiliki masalah terbatas yang harus kita selesaikan.  Misalnya, masalah akan terjadi jika ada lebih banyak bit.  Tetapi pada dasarnya, saya tidak berpikir ada alasan mengapa Anda tidak bisa membaca beberapa dari hal-hal ini.  Kecuali kondisi ketat tertentu, yang tidak saya pikirkan sekarang, seharusnya menentukan ukuran bagian nol, jika tidak mungkin ada masalah dengan perangkat keras. <br><br>  Jadi, Anda masih dapat memulai buffer overflow di sistem <b>Batas Baggy</b> , karena menerapkan pendekatan di atas tidak menyelesaikan semua masalah, bukan?  Masalah lain yang mungkin Anda temui jika Anda memiliki kode non-instrumental, karena kami tidak akan dapat mendeteksi masalah dalam kode non-instrumental.  Anda juga dapat menemukan kerentanan memori yang timbul dari sistem alokasi memori dinamis.  Jika Anda ingat, dalam kuliah sebelumnya kami melihat petunjuk aneh ini untuk <b>membebaskan malloc</b> , dan <b>batasan Baggy</b> tidak dapat mencegah terjadinya hal-hal seperti itu. <br><br>  Kami juga membahas pada kuliah terakhir tentang fakta bahwa penunjuk kode tidak memiliki batasan yang akan dikaitkan dengan mereka.  Misalkan kita memiliki struktur di mana buffer memori terletak di bagian bawah, dan pointer di bagian atas, dan buffer overflow.  Kami berasumsi bahwa buffer overflow masih dalam <b>batas Baggy</b> .  Maka Anda harus mendefinisikan kembali pointer fungsi ini.  Kalau tidak, jika kita mencoba menggunakannya, itu dapat dikirim ke kode berbahaya untuk menyerang bagian memori yang terkontrol.  Dan dalam hal ini, batas tidak akan membantu kami, karena kami tidak memiliki batas yang terkait, terkait dengan pointer fungsi ini. <br><br>  Jadi, berapa harga menggunakan <b>batas Baggy</b> ?  Bahkan, kami hanya memiliki 4 komponen dari harga ini. <br><br><img src="https://habrastorage.org/webt/2v/vo/c0/2vvoc00hrhpzj90khybubng8zsa.jpeg"><br><br>  Yang pertama adalah ruang.  Karena jika Anda menggunakan pointer "tebal", maka jelas bahwa Anda harus membuat pointer lebih besar.  Jika Anda menggunakan sistem <b>batas Baggy</b> yang baru saja kita bicarakan, Anda harus menyimpan tabel perbatasan.  Dan tabel ini memiliki ukuran slot yang memungkinkan Anda mengontrol seberapa besar tabel ini hingga Anda kehabisan kemungkinan memori yang dialokasikan untuknya. <br><br>  Selain itu, Anda juga menambah beban pada CPU, yang dipaksa untuk melakukan semua operasi instrumental ini dengan pointer.  Karena untuk setiap atau hampir setiap penunjuk, perlu untuk memeriksa batas menggunakan mode operasi yang sama, yang akan memperlambat eksekusi program Anda. <br><br>  Ada juga masalah dengan alarm palsu.  Kita telah membahas apa yang mungkin terjadi bahwa sebuah program menghasilkan pointer yang melampaui batas, tetapi tidak pernah mencoba untuk meringkasnya.  Sebenarnya, ini bukan masalah.  <b>Batas longgar</b> akan menandai bendera "di luar <b>batas</b> " ini jika melampaui 1/2 dari ukuran slot, setidaknya dalam solusi 32-bit. <br><br>  Apa yang akan Anda lihat di sebagian besar alat keamanan adalah bahwa alarm palsu mengurangi kemungkinan orang akan menggunakan alat ini.  Karena dalam praktiknya, kita semua berharap bahwa kita peduli dengan keamanan, tetapi apa yang benar-benar menggairahkan orang?  Mereka ingin dapat mengunggah foto bodoh mereka ke Facebook, mereka ingin mempercepat proses pengunggahan dan sebagainya.  Jadi, jika Anda benar-benar ingin alat keamanan Anda diminati, mereka seharusnya tidak memiliki alarm palsu.  Mencoba untuk menangkap semua kerentanan biasanya mengarah ke alarm palsu, yang akan mengganggu pengembang atau pengguna. <br><br>  Ini juga mengarah pada pengeluaran tidak produktif yang Anda butuhkan dukungan kompiler.  Karena Anda harus menambahkan semua alat ke sistem, melewati pemeriksaan pointer, dan seterusnya dan seterusnya. <br><br>  Jadi, untuk menggunakan sistem <b>batas Baggy</b> kita harus membayar harga, yang terdiri dari penggunaan ruang yang berlebihan, peningkatan beban CPU, alarm palsu dan kebutuhan untuk menggunakan kompiler. <br><br>  Ini <b>menyimpulkan</b> diskusi tentang <b>batas-batas Baggy</b> . <br><br>  Sekarang kita dapat memikirkan dua strategi mitigasi buffer overflow lainnya.  Bahkan, mereka jauh lebih mudah untuk dijelaskan dan dipahami. <br><br>  Salah satu pendekatan ini disebut <b>memori yang tidak dapat dieksekusi</b> .  Gagasan utamanya adalah bahwa perangkat keras swap akan menunjukkan 3 bit <b>R</b> , <b>W,</b> dan <b>X</b> - baca, tulis, dan jalankan - untuk setiap halaman yang Anda miliki di memori.       ,   ,  .  2  ,     ,  ,  ,    . <br><br>     ,     .     ,  ,      ,    ,     -   .    ,  .   Â« <b>W</b>  <b>X</b> Â» ,       ,      ,     ,       ,   .     ,       ,      .        .  ,        ,     .    ? <br><br>     -   ,         .    ,     .     ,       ,    . <br><br>    ,       ,   ,       ,      .      ,           ,      .     . <br><br>     ,        .     â€“  <b>just-in-time</b> ,      . <br><br>       -,    JavaScript    .    JavaScript,      ,    -   - Â«Â» , - Â«Â» ,       x86    .    ,         . <br>      . ,  ,    <b>just-in-time</b>    <b>W</b> ,       <b>X</b> .     ,        ,    . <br><br>        â€”       .  ,  ,      ,    . <br><br><img src="https://habrastorage.org/webt/f_/xj/xi/f_xjxihqdru85yadpa__ytdao-4.jpeg"><br><br> ,   ,       .     GDB,         ,        .  ,       .      ,      .       . <br><br> ,      .  ,           ,     ,   ,    ,     . <br><br>     : , ,   â€”     .    ,  ,    ,    ,   , , , -   .           ,     ,  . <br><br> ,    ,           ,     GDB  ,     ,         ,       ,     .        . <br>  ,    ,    ,   ,       .    -   ,    - ,        .        ,      .       ,     ,           . <br><br>    ,      ? ,  .      ,    ,               .    ,    ,    ,  ,  -    ,          . <br><br> 27:10  <br><br> : <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kursus MIT "Keamanan Sistem Komputer".</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> 3: Â« :   Â»,  2</a> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/xSQxaie_h1o" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> . <br><br>  Terima kasih telah tinggal bersama kami.  Apakah Anda suka artikel kami?  Ingin melihat materi yang lebih menarik?  Dukung kami dengan melakukan pemesanan atau merekomendasikannya kepada teman-teman Anda, <b>diskon 30% untuk pengguna Habr pada analog unik dari server entry-level yang kami temukan untuk Anda:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Seluruh kebenaran tentang VPS (KVM) E5-2650 v4 (6 Cores) 10GB DDR4 240GB SSD 1Gbps dari $ 20 atau bagaimana membagi server?</a>  (opsi tersedia dengan RAID1 dan RAID10, hingga 24 core dan hingga 40GB DDR4). <br><br>  <b>Dell R730xd 2 kali lebih murah?</b>  Hanya kami yang memiliki <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">2 x Intel Dodeca-Core Xeon E5-2650v4 128GB DDR4 6x480GB SSD 1Gbps 100 TV dari $ 249</a> di Belanda dan Amerika Serikat!</b>  Baca tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cara Membangun Infrastruktur Bldg.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kelas menggunakan server Dell R730xd E5-2650 v4 seharga 9.000 euro untuk satu sen?</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id416839/">https://habr.com/ru/post/id416839/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id416827/index.html">Kontainer Dewasa (Bagian 02): Panduan Praktis untuk Terminologi</a></li>
<li><a href="../id416829/index.html">Pola Model ABI v0.5.6 Beta</a></li>
<li><a href="../id416831/index.html">Routing eksternal dari lalu lintas domestik Rusia akan dikurangi menjadi 5%</a></li>
<li><a href="../id416833/index.html">Selamat datang di MskDotNet Meetup # 24</a></li>
<li><a href="../id416837/index.html"># Dashanalune 0</a></li>
<li><a href="../id416841/index.html">Cara menguji hipotesis dan menghasilkan uang di Swift menggunakan tes terpisah</a></li>
<li><a href="../id416843/index.html">Mesin roket nuklir dan sistem propulsi listrik roket nuklir</a></li>
<li><a href="../id416845/index.html">10 alasan untuk menggunakan itracking atau meninggalkannya selamanya</a></li>
<li><a href="../id416847/index.html">Situs Admin Ammyy kembali diganggu</a></li>
<li><a href="../id416849/index.html">Oh, kode saya. Bagaimana menjadi administrator sistem</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>