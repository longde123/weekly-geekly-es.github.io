<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèø‚Äçüè≠ üà∂ ‚≠êÔ∏è Auf dem Weg zu einer besseren Zukunft f√ºr intelligente Compiler üí≥ üî• üìò</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Jetzt ist das Thema maschinelles Lernen und k√ºnstliche Intelligenz derzeit √§u√üerst beliebt. Dank der Rechenleistung von Computern k√∂nnen Ideen und Alg...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Auf dem Weg zu einer besseren Zukunft f√ºr intelligente Compiler</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/450850/">  Jetzt ist das Thema maschinelles Lernen und k√ºnstliche Intelligenz derzeit √§u√üerst beliebt. Dank der Rechenleistung von Computern k√∂nnen Ideen und Algorithmen, die seit langem entstanden sind, implementiert und erheblich verbessert werden.  Fast jeden Tag k√∂nnen Sie Nachrichten √ºber neue Erfolge in diesem Bereich lesen.  Dar√ºber hinaus wird maschinelles Lernen in fast allen Bereichen eingesetzt ... und die Entwicklung von Compilern ist keine Ausnahme.  Das Gebiet ist jedoch sehr spezifisch und hat seine eigenen Merkmale und Schwierigkeiten bei der Erstellung intelligenter Compiler.  Gleichzeitig gibt es viele Studien zu diesem Thema, die seit langem sowohl im akademischen Umfeld als auch in verschiedenen Unternehmen durchgef√ºhrt werden. <br><br>  Wo genau wird versucht, beim Erstellen von Compilern Methoden des maschinellen Lernens anzuwenden?  Und warum sind die ‚Äûintelligenten‚Äú Compiler bisher nicht Teil des t√§glichen Lebens des Entwicklers geworden? <br><a name="habracut"></a><br><h2>  Optionen f√ºr die Verwendung von maschinellem Lernen in der Compilerentwicklung </h2><br>  Beginnen wir mit der ersten Frage zu bestimmten Anwendungen des maschinellen Lernens.  Tatsache ist, dass moderne Compiler komplexe Systeme mit einer Vielzahl von Optimierungen sind, mit denen Sie effizienteren Maschinencode erhalten.  Einige der Optimierungen und andere Aufgaben, wie z. B. die Registerzuordnung, sind jedoch NP-vollst√§ndig, was Compilerentwickler dazu zwingt, heuristische Algorithmen zu verwenden.  Infolgedessen verf√ºgen die meisten Compiler √ºber eine gro√üe Anzahl von Optimierungsflags, mit denen Sie die verwendeten Heuristiken konfigurieren k√∂nnen.  In LLVM verf√ºgt fast jede Passage √ºber mehrere versteckte Optionen, die sich auf den Betrieb auswirken k√∂nnen. Sie k√∂nnen entweder mit dem Flag ‚Äìmllvm beim Aufrufen von clang oder im Dienstprogramm opt verwendet werden.  Diese Vielzahl von Flags verbirgt sich jedoch hinter den viel h√§ufiger verwendeten Optionen, die viele Einstellungen gleichzeitig enthalten und normalerweise als Optimierungsstufen bezeichnet werden.  F√ºr C / C ++ - Compiler sind diese den meisten -O1, -O2, -O3 zur Optimierung der Laufzeit und -Os zur Optimierung der Codegr√∂√üe bekannt.  Leider ist der optimale Code nicht immer das Ergebnis (Assembler-Experten k√∂nnen den generierten Code optimal umschreiben). Viel h√§ngt vom Quellcode in einer Hochsprache, der Prozessorarchitektur, den Sprachfunktionen usw. ab. <br><br>  Trotz der Tatsache, dass moderne Prozessoren heute √ºber gen√ºgend RAM und eine recht hohe Leistung verf√ºgen, gibt es immer noch Bereiche, in denen Anwendungsleistung, Energieeffizienz und Maschinencodegr√∂√üe eine Schl√ºsselrolle spielen.  Beispiele f√ºr solche Bereiche umfassen Softwareentwicklung f√ºr eingebettete Systeme mit einer begrenzten Menge an RAM, digitale Signalverarbeitung, Echtzeitsysteme usw.  In F√§llen, in denen Sie leistungsstarken Maschinencode f√ºr ausreichend gro√üe Systeme ben√∂tigen, ist die Auswahl der richtigen Kompilierungsoptionen, die das beste Ergebnis liefern, eine wichtige Aufgabe.  Dar√ºber hinaus ist das Worst- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Case</a> -Laufzeitproblem ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">WCET</a> ) nicht verschwunden, wenn Echtzeitsysteme die Ausf√ºhrungszeit einer bestimmten Aufgabe auf der Plattform berechnen und nach M√∂glichkeit minimieren m√ºssen.  Bisher k√∂nnen sich Programmierer, die mit Systemen mit begrenztem RAM arbeiten, nicht vollst√§ndig auf Compiler verlassen und optimieren den generierten Maschinencode h√§ufig unabh√§ngig voneinander. <br><br>  F√ºr eine Person ist es schwierig vorherzusagen, welche Optimierungen zu einem guten Ergebnis f√ºhren und welche zu Regressionen f√ºhren k√∂nnen, da Sie hierf√ºr ein gutes Verst√§ndnis der Feinheiten der verwendeten heuristischen Algorithmen, eine gute Kenntnis der Struktur und der Passagen des verwendeten Compilers sowie eine vollst√§ndige Kenntnis des Codes des kompilierten Programms ben√∂tigen Der aktuelle Anwendungsentwicklungsprozess ist nicht m√∂glich.  Infolgedessen wird das Identifizieren der besten Kompilierungsoptionen f√ºr ein Programm f√ºr eine Person zu einer Aufgabe der umfassenden Suche nach verschiedenen Kombinationen von Optionen und Messungen der Leistung und der Codegr√∂√üen. <br><br>  Dar√ºber hinaus gibt es eine Einschr√§nkung in Form einer Kompilierungseinheit, mit der Sie arbeiten und f√ºr die Sie Optionen ausw√§hlen k√∂nnen.  F√ºr C / C ++ ist dies also immer noch eine Datei, die viel Code enthalten kann. Vielleicht w√§re es n√ºtzlich, sie auf verschiedene Arten zu optimieren, aber im Moment ist dies nicht m√∂glich.  Daher ist ein ‚Äûintelligenter‚Äú Compiler, der Code trainieren und dann f√ºr eine Vielzahl von F√§llen gut optimieren kann, f√ºr einige Entwickler ein Traum. <br><br><h2>  Bestehende Forschung und L√∂sungen </h2><br>  Nat√ºrlich ist das Problem der automatisierten Auswahl von Kompilierungsoptionen f√ºr Forscher seit vielen Jahren von Interesse.  Eines der bekanntesten Projekte ist die Entwicklung von G. Fursin und Forschern aus seinem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MILEPOST GCC-</a> Team, einer Version des gcc-Compilers, der Optimierungsdurchl√§ufe auf der Grundlage vorheriger Schulungen anhand der erhaltenen Datenprobe ausw√§hlen kann.  In dieser Arbeit verwendeten wir einen Satz von 55 Merkmalen zur L√∂sung des Problems und ein ziemlich einfaches Modell, das auf der Idee basiert, gute L√∂sungen basierend auf dem K-Algorithmus der n√§chsten Nachbarn zu verteilen.  Diese Entwicklung hat gezeigt, dass Optimierungsdurchl√§ufe zu Code f√ºhren k√∂nnen, der doppelt so schnell ist wie Code, der mit der Standardoption f√ºr maximale Optimierung -O3 erhalten wird. <br><br>  Es gibt auch Studien von G. Pekhimenko und A.D.  Braun f√ºr IBMs TPO ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Toronto Portable Optimizer</a> ).  Ihre Hauptaufgabe bestand darin, heuristisch ausw√§hlbare Werte f√ºr Optimierungen und genau die Code-Transformationen auszuw√§hlen.  F√ºr die Implementierung wurde eine logistische Regression verwendet, die es erm√∂glichte, effektive Bu√ügeldeinstellungen f√ºr ein schnelleres Training vorzunehmen.  Der Klassifikator wurde in Matlab gebaut.  Die Nutzungswahrscheinlichkeit wurde f√ºr jeden Durchgang berechnet und bei mehr als 50% verwendet.  Aufgrund der Eigenschaft, die sie in dieser Studie zu reduzieren versuchten, war es die statische Kompilierungszeit. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">A.Askhari</a> war mit der direkten Auswahl von Kompilierungsoptionen f√ºr das gesamte Programm besch√§ftigt, um Ausf√ºhrungszeit, Kompilierungszeit, Codegr√∂√üe und Stromverbrauch zu minimieren.  Hierzu wurden das von G. Fursin und A. Lokhmotov (ebenfalls auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub entwickelt</a> ) entwickelte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">cTuning Framework</a> und das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Collective Mind Framework</a> verwendet. <br><br>  Es gibt auch Studien von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">M. Stephenson und S. Amarasinge zur</a> Auswahl von Optimierungen f√ºr bestimmte besonders wichtige Algorithmen (Zuweisung von Registern, DATENPR√ÑFETCHING, HYPERBLOCK-FORMATION).  F√ºr jede Funktion wurden entsprechend ihre eigenen Eigenschaften verwendet.  F√ºr die L√∂sung wurde ein genetischer Algorithmus verwendet.  Das getestete Produkt wurde am Open Research Compiler (ORC) getestet. <br><br>  Es gibt auch ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MAGEEC-Projekt</a> (Machine Guided Energy Efficient Compiler), dessen Ziele etwas anders sind.  Die entwickelte Infrastruktur verwendet maschinelles Lernen, um die Optimierungen auszuw√§hlen, die erforderlich sind, um den Code mit maximaler Energieeffizienz f√ºr Hochleistungsrechnersysteme zu generieren.  MAGEEC wurde entwickelt, um sowohl mit gcc als auch mit LLVM zu arbeiten.  Dieser Compiler ist Teil des gr√∂√üeren TSERO-Projekts (Total Software Energy Reporting and Optimization). <br><br>  Eine Forschung, die in direktem Zusammenhang mit LLVM steht, ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">LLVMTuner</a> , ein Softwareprodukt, das an der Universit√§t von Illinois von I. Chen und W. Adwe entwickelt wurde.  2017 wurde ein Bericht vorgelegt, in dem die zu diesem Zeitpunkt verf√ºgbaren Ergebnisse beschrieben wurden.  In dieser Arbeit haben wir einzelne ‚Äûhei√üe‚Äú Zyklen optimiert.  Dieses Framework wurde f√ºr die automatisierte Konfiguration gro√üer Programme entwickelt.  LLVMTuner l√§uft auf LLVM IR-Middleware, verwendet Profiling zur Identifizierung von Hot Loops und passt die Heuristik automatisch an.  Der Fokus liegt auf Zyklen der obersten Ebene.  Die ausgew√§hlten Zyklen und eventuelle Aufruffunktionen werden an ein separates Modul √ºbertragen, das weiter den notwendigen Optimierungen unterzogen wird.  Mit dieser L√∂sung k√∂nnen Sie die Leistung gro√üer Programme verbessern. <br><br><h2>  Bestehende Probleme </h2><br>  Es gibt jedoch keinen weit verbreiteten Compiler, der die Heuristiken zur Optimierung von Durchl√§ufen unabh√§ngig anpasst.  Was ist das Problem?  Wie Sie wissen, h√§ngen die Effektivit√§t der Methoden des maschinellen Lernens und die Qualit√§t der erhaltenen Modelle von der richtigen Auswahl der Merkmale und der Qualit√§t der Daten f√ºr das Training ab (trotz der Existenz von Algorithmen, die weniger empfindlich auf ‚Äûverrauschte‚Äú Daten reagieren).  Ohne die Struktur und die im Compiler verwendeten Algorithmen zu kennen, ist es nicht einfach, einen vollst√§ndigen und ausreichenden Satz von Merkmalen f√ºr das Training auszuw√§hlen, obwohl es ziemlich klare und logische gibt, zum Beispiel die Gr√∂√üe des Zyklus, die Anzahl der Ausg√§nge aus dem Zyklus usw.  Daher ist es schwierig, eine universelle L√∂sung zu entwickeln, die f√ºr viele Compiler gleichzeitig geeignet ist, und es ist keine Tatsache, dass dies im Allgemeinen m√∂glich ist.  Dar√ºber hinaus ist dies wahrscheinlich nicht erforderlich. <br><br>  Da die Entwicklung von Compilern in relativ kurzer Zeit effizient und machbar sein sollte, ist es selbstverst√§ndlich, dass selbst gro√üe Unternehmen ihre industriellen Compiler auf der Grundlage vorgefertigter L√∂sungen entwickeln.  Die meisten modernen L√∂sungen lassen sich in zwei Kategorien einteilen: Ausf√ºhrung auf virtuellen Maschinen, z. B. JVM - JIT-Compiler, und Compiler auf Basis von LLVM, einem System, das eine virtuelle Maschine mit RISC-√§hnlichen Anweisungen implementiert - statische und dynamische Compiler.  Nat√ºrlich gibt es immer noch firmeneigene L√∂sungen, aber diese werden weniger wettbewerbsf√§hig, da keine gro√üe Community an der Entwicklung der in ihnen verwendeten Technologien beteiligt ist.  Daher verwenden heute viele gro√üe Unternehmen wie Google, Apple, Adobe und ARM LLVM, um ihre eigenen L√∂sungen zu entwickeln.  Nat√ºrlich bleibt gcc der Hauptcompiler f√ºr C / C ++, es gibt andere L√∂sungen f√ºr andere Sprachen, aber wenn beispielsweise eine L√∂sung f√ºr LLVM gefunden wird, wird dies bereits einen anst√§ndigen Teil der derzeit vorhandenen Compiler abdecken. <br><br>  Das Sammeln von Merkmalen f√ºr das Training wird ebenfalls zu einem gro√üen Problem, da Multi-Pass-Compiler die Zwischendarstellung stark transformieren und die im Anfangsstadium gesammelten Merkmale f√ºr sp√§tere Compiler-Optimierungen nicht ganz relevant sind. Diese Merkmale k√∂nnen sich mit hoher Wahrscheinlichkeit √§ndern.  Dar√ºber hinaus ist es sinnvoll, Merkmale f√ºr verschiedene Arten von Elementen getrennt zu erfassen: Module, Zyklen, Basisbl√∂cke, da Optimierungen normalerweise so ausgelegt sind, dass sie einen bestimmten Elementtyp √§ndern. In LLVM werden die Passagen auch nach diesem Kriterium unterteilt. <br><br>  Zun√§chst stellt sich jedoch die Frage, welche Elemente identifiziert werden m√ºssen, f√ºr die Merkmale erfasst werden m√ºssen.  Es gibt viele M√∂glichkeiten, eindeutige Bezeichner zu berechnen, die bei allen Optimierungen gespeichert werden k√∂nnen, zum Beispiel: <br><br><ul><li>  AST-basierter Frontend-Hash </li><li>  eindeutige Nummern, die beim Front-End-Parsing zugewiesen wurden </li><li>  64-Bit-Zahl, die auf der Grundlage von B√∂gen in CFG (Kontrollflussdiagramm) unter Verwendung einer Pr√ºfsumme (√§hnlich wie PGO (Profilgesteuerte Optimierung) in LLVM) generiert wird </li></ul><br>  Sie m√ºssen diese Bezeichner jedoch w√§hrend der Transformationen ordnungsgem√§√ü speichern, wenn die Elemente zu einem zusammengef√ºhrt, geteilt, neu erstellt und die urspr√ºnglichen gel√∂scht werden k√∂nnen. Dies ist keine leichte Aufgabe. <br><br>  Zweitens ist es im Prinzip schwierig, die Grenzen der im Quellcode geschriebenen Quellzyklen, Basisbl√∂cke usw. auf dem bereits konvertierten IR zu bewerten.  Beispielsweise gehen aufgrund der von LLVM √ºbernommenen mehrstufigen Generierung von Maschinencode Informationen √ºber Maschinenbasiseinheiten nach der Codegenerierung auf der Grundlage von Maschinenanweisungen in AsmPrinter verloren.  Dementsprechend gehen auch Informationen √ºber die Kennungen der Basisbl√∂cke und Zyklen verloren, f√ºr die beispielsweise der Versatz vom Beginn der Funktion gemessen wird, so dass mit diesem Verfahren der Versatz nur in der Phase der Erzeugung des Maschinencodes in Form der Anzahl von Bytes erhalten werden kann.  In den nachfolgenden Phasen des Generierens von Maschinencode k√∂nnen jedoch beim Arbeiten mit Maschinenfragmenten verschiedene Ausrichtungen hinzugef√ºgt werden, die die Gr√∂√üe der zuvor ber√ºcksichtigten Anweisungen √§ndern, und es werden auch keine Anweisungen hinzugef√ºgt.  Aus diesem Grund kann der Berechnungsfehler f√ºr die Basisbl√∂cke am Ende gro√üer Funktionen sehr gro√ü sein, bis zu einer vollst√§ndigen Verschiebung zu einem anderen Block / Zyklus.  Und obwohl einige der Transformationen in den sp√§teren Phasen verfolgt und ber√ºcksichtigt werden k√∂nnen, gibt dies keine Garantie f√ºr die Genauigkeit der Messungen, da die Gr√∂√üe der Anweisungen bis zum Linker variieren kann. <br><br><img src="https://habrastorage.org/webt/af/xw/2-/afxw2-jziob0rhikr1nqaw_wmai.png"><br><br>  Wie Sie sehen, ist selbst die Erfassung von Attributen, auf deren Grundlage Schulungen erforderlich sind, recht kompliziert und zeitaufw√§ndig und wird in Zukunft wahrscheinlich zum Input-Set f√ºr das trainierte Modell f√ºr die Entscheidungsfindung.  Und es gibt keine offensichtlichen L√∂sungen f√ºr diese Probleme, was die unmittelbare Arbeit im Zusammenhang mit maschinellem Lernen erschwert und eine gro√üe Anzahl von Menschen anzieht, da nicht gen√ºgend Datens√§tze vorhanden sind.  Nun, die typischen Schwierigkeiten, L√∂sungen f√ºr Probleme des maschinellen Lernens zu finden, Modelle, Methoden auszuw√§hlen, die richtige Teilmenge von Attributen mit einer gro√üen Anzahl von Attributen zu bestimmen usw.  existieren in diesem Fall.  Fast jeder, der auf maschinelles Lernen gesto√üen ist, kennt sie und vielleicht gibt es hier nichts Einzigartiges und Spezifisches f√ºr Compiler. <br><br>  Es ist schwer vorherzusagen, wann sich Smart Compiler verbreiten werden.  Moderne Compiler haben auch andere Probleme, die mit dieser Methode wahrscheinlich nicht gel√∂st werden k√∂nnen und die derzeit wahrscheinlich mehr Priorit√§t haben.  Compiler sind jedoch bereits viel intelligenter geworden als zu Beginn ihres Erscheinungsbilds, und dieser Prozess wird fortgesetzt, obwohl er m√∂glicherweise etwas langsamer ist, als die meisten Entwickler es w√ºnschen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de450850/">https://habr.com/ru/post/de450850/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de450838/index.html">Warum die Einheit nicht Primzahlen zugeordnet wird und wann sie allgemein als Zahl betrachtet wurde</a></li>
<li><a href="../de450840/index.html">Die letzte Taschenlampe ist m√ºde oder wird das Flackern Wei√ürussland retten (upd. Spinner?)</a></li>
<li><a href="../de450844/index.html">Einf√ºhrung in die Beispielzuordnung</a></li>
<li><a href="../de450846/index.html">Die Wunder der Verpackung von Microsoft: der Linux-Kernel in Windows 10 und die IE-Engine in Chromium Edge</a></li>
<li><a href="../de450848/index.html">√úber gelben Phosphor und die Panik des Menschen</a></li>
<li><a href="../de450854/index.html">Erfahrung in der Entwicklung eines Unity-Assets zur Suche nach einem Pfad im 3D-Raum</a></li>
<li><a href="../de450858/index.html">Open Source Networking-Treffen - jetzt in Yandex.Cloud # 3.2019</a></li>
<li><a href="../de450860/index.html">Smart Sockel REDMOND SkyPort 100S</a></li>
<li><a href="../de450862/index.html">@ Pythonetc April 2019</a></li>
<li><a href="../de450864/index.html">Tipps und Tricks von meinem Telegramm-Kanal @pythonetc, April 2019</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>