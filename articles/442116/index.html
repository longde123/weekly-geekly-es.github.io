<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💴 🐳 🔥 Mejora de la funcionalidad del componente React con React.memo () 💲 🎅🏿 🃏</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Le presentamos una traducción del artículo de Chidume Nnamdi, que se publicó en blog.bitsrc.io. Si desea aprender cómo evitar renderizaciones innecesa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mejora de la funcionalidad del componente React con React.memo ()</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/plarium/blog/442116/">  Le presentamos una traducción del artículo de Chidume Nnamdi, que se publicó en blog.bitsrc.io.  Si desea aprender cómo evitar renderizaciones innecesarias y lo útiles que son las nuevas herramientas en React, bienvenido a cat. <br><br><img src="https://habrastorage.org/webt/pd/cr/7a/pdcr7arl6hgkxg17v5c4laoxsj8.jpeg"><a name="habracut"></a><br><br>  El equipo React.js está trabajando duro para hacer que React se ejecute lo más rápido posible.  Para permitir a los desarrolladores acelerar sus aplicaciones React, se han agregado las siguientes herramientas: <br><br><ul><li>  React. Perezoso y suspenso para carga de componentes retrasada; </li><li>  Componente puro </li><li>  los ganchos del ciclo de vida debenComponentUpdate (...) {...}. </li></ul><br>  En este artículo, consideraremos, entre otras, otra herramienta de optimización agregada en React v16.6 para acelerar las funciones de los componentes: <b>React.memo</b> . <br><br>  Consejo: Use <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Bit</a> para instalar y compartir componentes React.  Use sus componentes para crear nuevas aplicaciones y compartirlas con el equipo para acelerar las cosas.  ¡Pruébalo! <br><br><img src="https://habrastorage.org/webt/uk/nn/k8/uknnk8ugyblbcsges3q5aag8n3m.gif"><br><br><h3>  Render extra </h3><br>  En React, cada componente corresponde a una unidad de vista.  Los componentes también tienen estados.  Cuando el valor del estado cambia debido a las acciones del usuario, el componente se da cuenta de que se necesita volver a dibujar.  El componente Reaccionar se puede volver a dibujar cualquier cantidad de veces.  En algunos casos, esto es necesario, pero la mayoría de las veces puede prescindir de un renderizador, especialmente porque ralentiza enormemente la aplicación. <br><br>  Considere el siguiente componente: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestC</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(props) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(props); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = { <span class="hljs-attr"><span class="hljs-attr">count</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> } } componentWillUpdate(nextProps, nextState) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'componentWillUpdate'</span></span>) } componentDidUpdate(prevProps, prevState) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'componentDidUpdate'</span></span>) } render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> &lt;div &gt; {</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">.state.count} &lt;button onClick={(</span></span></span><span class="hljs-function">)=&gt;</span></span><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.setState({<span class="hljs-attr"><span class="hljs-attr">count</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>})}&gt;Click Me&lt;<span class="hljs-regexp"><span class="hljs-regexp">/button&gt; &lt;/</span></span>div&gt; ); } } <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> TestC;</code> </pre> <br>  El valor inicial del estado {count: 0} es 0. Si hace clic en el botón Click me, el estado del conteo se convertirá en 1. En nuestra pantalla, 0 también cambiará a 1. Pero si hacemos clic nuevamente en el botón, comienzan los problemas: el componente no se debe volver a dibujar, porque La condición no ha cambiado.  El valor del contador "a" es 1, el nuevo valor también es uno, lo que significa que no hay necesidad de actualizar el DOM. <br><br>  Para ver la actualización de nuestro TestC, en el que se establece el mismo estado dos veces, agregué dos métodos de ciclo de vida.  React inicia el ciclo componentWillUpdate cuando el componente se actualiza / redibuja debido a un cambio de estado.  El ciclo componentdidUpdate React comienza cuando un componente se procesa correctamente. <br><br>  Si lanzamos el componente en el navegador e intentamos hacer clic en el botón Hacer clic varias veces, obtenemos el siguiente resultado: <br><br><img src="https://habrastorage.org/webt/qj/l9/zx/qjl9zx25xiry_bzjrwasb9t4b5k.png"><br><br>  La repetición de la entrada componentWillUpdate en nuestra consola indica que el componente se vuelve a dibujar incluso cuando el estado no cambia.  Este es un render extra. <br><br><h3>  Componente puro / shouldComponentUpdate </h3><br>  El enlace del ciclo de vida shouldComponentUpdate ayudará a evitar la representación innecesaria en los componentes React. <br><br>  React inicia el método <b>shouldComponentUpdate</b> al comienzo de la representación del componente y recibe una luz verde de este método para continuar el proceso o una señal de que el proceso está <b>inhibido</b> . <br><br>  Deje que debería debería ser nuestro UpdateComponentUpdate así: <br><br><pre> <code class="javascript hljs">shouldComponentUpdate(nextProps, nextState) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> }</code> </pre> <br><ul><li>  <code>nextProps</code> : el siguiente valor de <code>props</code> que recibirá el componente; </li><li>  <code>nextState</code> : el siguiente valor de <code>state</code> que recibirá el componente. </li></ul><br>  Entonces permitimos que React represente el componente porque el valor de retorno es <code>true</code> . <br><br>  Supongamos que escribimos lo siguiente: <br><br><pre> <code class="javascript hljs">shouldComponentUpdate(nextProps, nextState) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> }</code> </pre><br>  En este caso, prohibimos que React procese el componente, porque <code>false</code> devuelve <code>false</code> . <br>  De lo anterior se deduce que para renderizar el componente necesitamos devolver <code>true</code> .  Ahora podemos reescribir el componente TestC de la siguiente manera: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestC</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(props) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(props); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = { <span class="hljs-attr"><span class="hljs-attr">count</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> } } componentWillUpdate(nextProps, nextState) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'componentWillUpdate'</span></span>) } componentDidUpdate(prevProps, prevState) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'componentDidUpdate'</span></span>) } shouldComponentUpdate(nextProps, nextState) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state.count === nextState.count) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> } render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> &lt;div&gt; { </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">.state.count } &lt;button onClick = { (</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.setState({ <span class="hljs-attr"><span class="hljs-attr">count</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }) }&gt; Click Me &lt;<span class="hljs-regexp"><span class="hljs-regexp">/button&gt; &lt;/</span></span>div&gt; ); } } <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> TestC;</code> </pre><br>  Agregamos un enlace shouldComponentUpdate al componente TestC.  Ahora el valor de <code>count</code> en el objeto de estado actual <code>this.state.count</code> compara con el valor de <code>count</code> en el siguiente objeto de estado <code>nextState.count</code> .  Si son iguales <code>===</code> , no se vuelve a dibujar y <code>false</code> devuelve <code>false</code> .  Si no son iguales, <code>true</code> devuelve <code>true</code> y se inicia un renderizador para mostrar el nuevo valor. <br><br>  Si probamos el código en un navegador, veremos un resultado familiar: <br><br><img src="https://habrastorage.org/webt/jp/wd/2x/jpwd2xhiz5zckb5f2c-xwosbife.png"><br><br>  Pero al hacer clic en el botón <code>Click Me</code> clic varias veces, todo lo que vemos es lo siguiente (¡se muestra solo una vez!): <br><br> <code>componentWillUpdate <br> componentDidUpdate</code> <br> <br><img src="https://habrastorage.org/webt/gy/xc/ir/gyxcir1kjjyki18hzqxdfz5hzeu.png"><br><br>  Puede cambiar el estado del componente TestC en la pestaña React DevTools.  Haga clic en la pestaña Reaccionar, seleccione TestC a la derecha y verá el valor del estado del contador: <br><br><img src="https://habrastorage.org/webt/pi/qg/ix/piqgixsafppm6jygqftfm8nkpyq.png"><br><br>  Este valor puede ser cambiado.  Haga clic en el texto del contador, escriba 2 y presione Entrar. <br><br><img src="https://habrastorage.org/webt/v3/4m/tl/v34mtl_unwz6gmkip2kxw_4a1km.png"><br><br>  El estado del conteo cambiará y en la consola veremos: <br><br><pre> <code class="javascript hljs">componentWillUpdate componentDidUpdate componentWillUpdate componentDidUpdate</code> </pre><br><img src="https://habrastorage.org/webt/ql/3y/_i/ql3y_ijc3qwx9byxo_lu8ckbg-g.png"><br><br>  El valor anterior era 1 y el nuevo era 2, por lo que era necesario volver a dibujar. <br>  Pasemos al <b>componente puro</b> . <br><br>  Pure Component apareció en React en la versión v15.5.  Se utiliza para comparar valores predeterminados ( <code>change detection</code> ).  Usando <code>extend React.PureComponent</code> , no tiene que agregar el método del ciclo de vida <code>shouldComponentUpdate</code> a los componentes: el seguimiento de cambios ocurre por sí mismo. <br><br>  Agregue un PureComponent al componente TestC. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestC</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PureComponent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(props) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(props); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = { <span class="hljs-attr"><span class="hljs-attr">count</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> } } componentWillUpdate(nextProps, nextState) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'componentWillUpdate'</span></span>) } componentDidUpdate(prevProps, prevState) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'componentDidUpdate'</span></span>) } <span class="hljs-comment"><span class="hljs-comment">/*shouldComponentUpdate(nextProps, nextState) { if (this.state.count === nextState.count) { return false } return true }*/</span></span> render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> &lt;div&gt; { </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">.state.count } &lt;button onClick = { (</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.setState({ <span class="hljs-attr"><span class="hljs-attr">count</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }) }&gt; Click Me &lt;<span class="hljs-regexp"><span class="hljs-regexp">/button&gt; &lt;/</span></span>div &gt; ); } } <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> TestC;</code> </pre><br>  Como puede ver, <code>shouldComponentUpdate</code> en un comentario.  Ya no lo necesitamos: todo el trabajo lo realiza <code>React.PureComponent</code> . <br><br>  Al reiniciar el navegador para probar la nueva solución, y al hacer clic en el botón <code>Click Me</code> clic varias veces, obtenemos: <br><br><img src="https://habrastorage.org/webt/jp/wd/2x/jpwd2xhiz5zckb5f2c-xwosbife.png"><br><br><img src="https://habrastorage.org/webt/gy/xc/ir/gyxcir1kjjyki18hzqxdfz5hzeu.png"><br><br>  Como puede ver, solo apareció una entrada de <code>component*Update</code> en la consola. <br><br>  Después de ver cómo trabajar en React con redibujar en las clases de componentes de ES6, pasamos a las funciones de los componentes.  ¿Cómo lograr los mismos resultados con ellos? <br><br><h3>  Componentes de funciones </h3><br>  Ya sabemos cómo optimizar el trabajo con clases usando el componente Pure y el <code>shouldComponentUpdate</code> ciclo de vida <code>shouldComponentUpdate</code> .  Nadie argumenta que los componentes de clase son los componentes principales de React, pero puede usar funciones como componentes. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestC</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> I am a functional component </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ) }</code> </pre> <br>  Es importante recordar que los componentes de la función, a diferencia de los componentes de la clase, no tienen estado (aunque ahora que han <code>useState</code> ganchos de <code>useState</code> , esto puede discutirse), lo que significa que no podemos configurar su redibujo.  Los métodos de ciclo de vida que utilizamos al trabajar con clases no están disponibles aquí.  Si podemos agregar ganchos de ciclo de vida a los componentes de la función, podemos agregar el método <code>shouldComponentUpdate</code> para decirle a React que se necesita un procesador de funciones.  (Quizás el autor cometió un error de hecho en la última oración. - Aprox. Ed.) Y, por supuesto, no podemos usar <code>extend React.PureComponent</code> . <br><br>  Convertimos nuestra clase de componente ES6 TestC en una función de componente. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TestC = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Rendering TestC :`</span></span> props) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> {props.count} </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ) } <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> TestC; <span class="hljs-comment"><span class="hljs-comment">// App.js &lt;TestC count={5} /&gt;</span></span></code> </pre> <br>  Después de renderizar en la consola, vemos la entrada <code>Rendering TestC :5</code> . <br><br><img src="https://habrastorage.org/webt/zl/ul/q4/zlulq4t7iokqfn9my1s9yka6v_w.png"><br><br>  Abra DevTools y haga clic en la pestaña Reaccionar.  Aquí intentaremos cambiar el valor de las propiedades del componente TestC.  Seleccione TestC, y las propiedades del contador con todas las propiedades y valores de TestC se abrirán a la derecha.  Solo vemos el contador con el valor actual de 5. <br><br>  Haga clic en el número 5 para cambiar el valor.  En su lugar, aparecerá una ventana de entrada. <br><br><img src="https://habrastorage.org/webt/1h/u-/31/1hu-31ov7pulpn2iuqatr667rns.png"><br><br>  Si cambiamos el valor numérico y presionamos Enter, las propiedades del componente cambiarán de acuerdo con el valor que ingresamos.  Supongamos que a los 45. <br><br><img src="https://habrastorage.org/webt/bn/9t/yx/bn9tyxzi3bznqpx_6onqz2athra.png"><br><br>  Vaya a la pestaña Consola. <br><br><img src="https://habrastorage.org/webt/1m/8a/k8/1m8ak8oggdsmsahkqbg8npptrau.png"><br><br>  El componente TestC se volvió a dibujar porque el valor anterior de 5 cambió al actual - 45. Vuelva a la pestaña Reaccionar y cambie el valor a 45, luego regrese a la Consola. <br><br><img src="https://habrastorage.org/webt/ea/mu/vy/eamuvycxua6dksm8yp_o2b0bcym.png"><br><br>  Como puede ver, el componente se vuelve a dibujar, aunque los valores anteriores y nuevos son los mismos.  :( <br><br>  ¿Cómo gestionar un renderizador? <br><br><h3>  Solución: React.memo () </h3><br>  <code>React.memo()</code> es una nueva característica introducida en React v16.6.  Su principio de funcionamiento es similar al principio de <code>React.PureComponent</code> : ayuda en la gestión del rediseño de funciones de componentes.  <code>React.memo(...)</code> para componentes de clase es <code>React.PureComponent</code> para componentes de función. <br><br>  <b>¿Cómo trabajar con React.memo (...)?</b> <br>  Bastante simple  Digamos que tenemos una función componente. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Funcomponent = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> Hiya!! I am a Funtional component </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ) }</code> </pre><br>  Solo necesitamos pasar FuncComponent como argumento para la función React.memo. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Funcomponent = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> Hiya!! I am a Funtional component </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ) } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MemodFuncComponent = React.memo(FunComponent)</code> </pre> <br>  React.memo devuelve MemodFuncComponent <code>purified MemodFuncComponent</code> .  Esto es lo que dibujaremos en el marcado JSX.  Cuando las propiedades y el estado de un componente cambian, React compara las propiedades y estados anteriores y actuales del componente.  Y solo si no son idénticos, la función componente se vuelve a dibujar. <br><br>  Aplique esto al componente de función TestC. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> TestC = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Rendering TestC :'</span></span>, props) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> { props.count } </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/&gt;</span></span></span><span class="xml"> ) } TestC = React.memo(TestC);</span></span></code> </pre> <br>  Abra un navegador y descargue la aplicación.  Abra DevTools y vaya a la pestaña Reaccionar.  Seleccione <code>&lt;Memo(TestC)&gt;</code> . <br><br>  Si en el bloque de la derecha cambiamos las propiedades del contador a 89, la aplicación se volverá a dibujar. <br><br><img src="https://habrastorage.org/webt/kf/tl/ms/kftlmsn1bznnmh9loxbedc_acqi.png"><br><br>  Si cambiamos el valor al anterior, 89, entonces ... <br><br><img src="https://habrastorage.org/webt/j4/ak/tq/j4aktqq4qfwkizulxk2h-em4ism.png"><br><br>  ¡No habrá redibujos! <br><br>  Gloria a reaccionar.memo (...)!  :) <br><br>  Sin usar <code>React.memo(...)</code> en nuestro primer ejemplo, la función del componente TestC se vuelve a dibujar incluso cuando el valor anterior cambia a uno idéntico.  Ahora, gracias a <code>React.memo(...)</code> , podemos evitar la representación innecesaria de las funciones de los componentes. <br><br><h3>  Conclusión </h3><br><ul><li>  Vamos a repasar la lista? </li><li>  <code>React.PureComponent</code> - plata; </li><li>  <code>React.memo(...)</code> - oro; </li><li>  <code>React.PureComponent</code> funciona con clases ES6; </li><li>  <code>React.memo(...)</code> funciona con funciones; </li><li>  <code>React.PureComponent</code> optimiza el rediseño de las clases ES6; </li><li>  <code>React.memo(...)</code> optimiza el rediseño de la función; </li><li>  la optimización de funciones es una idea excelente; </li><li>  <code>React</code> nunca volverá a ser lo mismo. </li></ul><br>  Si tiene alguna pregunta sobre el artículo o cualquier información adicional, cambios u objeciones, no dude en escribirme comentarios, correos electrónicos o mensajes privados. <br><br>  Gracias </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/442116/">https://habr.com/ru/post/442116/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../442104/index.html">Guía del usuario de Kibana. Visualización. Parte 5</a></li>
<li><a href="../442108/index.html">Guía para desarrolladores para crear aplicaciones de IA</a></li>
<li><a href="../442110/index.html">Antipatterns Vim</a></li>
<li><a href="../442112/index.html">Nuevos lenguajes de programación matan silenciosamente nuestra conexión con la realidad</a></li>
<li><a href="../442114/index.html">Guía para la auditoría automática de contratos inteligentes. Parte 3: Mythril</a></li>
<li><a href="../442118/index.html">El grupo minero de Coinhive deja de funcionar</a></li>
<li><a href="../442120/index.html">Capacitación de modelos TensorFlow con el Servicio Azure Machine Learning</a></li>
<li><a href="../442122/index.html">Un simple señor moscovita: una entrevista con el creador de Duke Nukem</a></li>
<li><a href="../442124/index.html">Facebook dará a los usuarios la oportunidad de limpiar su historia</a></li>
<li><a href="../442128/index.html">Vida en partículas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>