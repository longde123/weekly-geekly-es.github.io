<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>   Mejora de la funcionalidad del componente React con React.memo ()   </title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Le presentamos una traducci贸n del art铆culo de Chidume Nnamdi, que se public贸 en blog.bitsrc.io. Si desea aprender c贸mo evitar renderizaciones innecesa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mejora de la funcionalidad del componente React con React.memo ()</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/plarium/blog/442116/">  Le presentamos una traducci贸n del art铆culo de Chidume Nnamdi, que se public贸 en blog.bitsrc.io.  Si desea aprender c贸mo evitar renderizaciones innecesarias y lo 煤tiles que son las nuevas herramientas en React, bienvenido a cat. <br><br><img src="https://habrastorage.org/webt/pd/cr/7a/pdcr7arl6hgkxg17v5c4laoxsj8.jpeg"><a name="habracut"></a><br><br>  El equipo React.js est谩 trabajando duro para hacer que React se ejecute lo m谩s r谩pido posible.  Para permitir a los desarrolladores acelerar sus aplicaciones React, se han agregado las siguientes herramientas: <br><br><ul><li>  React. Perezoso y suspenso para carga de componentes retrasada; </li><li>  Componente puro </li><li>  los ganchos del ciclo de vida debenComponentUpdate (...) {...}. </li></ul><br>  En este art铆culo, consideraremos, entre otras, otra herramienta de optimizaci贸n agregada en React v16.6 para acelerar las funciones de los componentes: <b>React.memo</b> . <br><br>  Consejo: Use <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Bit</a> para instalar y compartir componentes React.  Use sus componentes para crear nuevas aplicaciones y compartirlas con el equipo para acelerar las cosas.  隆Pru茅balo! <br><br><img src="https://habrastorage.org/webt/uk/nn/k8/uknnk8ugyblbcsges3q5aag8n3m.gif"><br><br><h3>  Render extra </h3><br>  En React, cada componente corresponde a una unidad de vista.  Los componentes tambi茅n tienen estados.  Cuando el valor del estado cambia debido a las acciones del usuario, el componente se da cuenta de que se necesita volver a dibujar.  El componente Reaccionar se puede volver a dibujar cualquier cantidad de veces.  En algunos casos, esto es necesario, pero la mayor铆a de las veces puede prescindir de un renderizador, especialmente porque ralentiza enormemente la aplicaci贸n. <br><br>  Considere el siguiente componente: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestC</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(props) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(props); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = { <span class="hljs-attr"><span class="hljs-attr">count</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> } } componentWillUpdate(nextProps, nextState) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'componentWillUpdate'</span></span>) } componentDidUpdate(prevProps, prevState) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'componentDidUpdate'</span></span>) } render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> &lt;div &gt; {</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">.state.count} &lt;button onClick={(</span></span></span><span class="hljs-function">)=&gt;</span></span><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.setState({<span class="hljs-attr"><span class="hljs-attr">count</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>})}&gt;Click Me&lt;<span class="hljs-regexp"><span class="hljs-regexp">/button&gt; &lt;/</span></span>div&gt; ); } } <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> TestC;</code> </pre> <br>  El valor inicial del estado {count: 0} es 0. Si hace clic en el bot贸n Click me, el estado del conteo se convertir谩 en 1. En nuestra pantalla, 0 tambi茅n cambiar谩 a 1. Pero si hacemos clic nuevamente en el bot贸n, comienzan los problemas: el componente no se debe volver a dibujar, porque La condici贸n no ha cambiado.  El valor del contador "a" es 1, el nuevo valor tambi茅n es uno, lo que significa que no hay necesidad de actualizar el DOM. <br><br>  Para ver la actualizaci贸n de nuestro TestC, en el que se establece el mismo estado dos veces, agregu茅 dos m茅todos de ciclo de vida.  React inicia el ciclo componentWillUpdate cuando el componente se actualiza / redibuja debido a un cambio de estado.  El ciclo componentdidUpdate React comienza cuando un componente se procesa correctamente. <br><br>  Si lanzamos el componente en el navegador e intentamos hacer clic en el bot贸n Hacer clic varias veces, obtenemos el siguiente resultado: <br><br><img src="https://habrastorage.org/webt/qj/l9/zx/qjl9zx25xiry_bzjrwasb9t4b5k.png"><br><br>  La repetici贸n de la entrada componentWillUpdate en nuestra consola indica que el componente se vuelve a dibujar incluso cuando el estado no cambia.  Este es un render extra. <br><br><h3>  Componente puro / shouldComponentUpdate </h3><br>  El enlace del ciclo de vida shouldComponentUpdate ayudar谩 a evitar la representaci贸n innecesaria en los componentes React. <br><br>  React inicia el m茅todo <b>shouldComponentUpdate</b> al comienzo de la representaci贸n del componente y recibe una luz verde de este m茅todo para continuar el proceso o una se帽al de que el proceso est谩 <b>inhibido</b> . <br><br>  Deje que deber铆a deber铆a ser nuestro UpdateComponentUpdate as铆: <br><br><pre> <code class="javascript hljs">shouldComponentUpdate(nextProps, nextState) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> }</code> </pre> <br><ul><li>  <code>nextProps</code> : el siguiente valor de <code>props</code> que recibir谩 el componente; </li><li>  <code>nextState</code> : el siguiente valor de <code>state</code> que recibir谩 el componente. </li></ul><br>  Entonces permitimos que React represente el componente porque el valor de retorno es <code>true</code> . <br><br>  Supongamos que escribimos lo siguiente: <br><br><pre> <code class="javascript hljs">shouldComponentUpdate(nextProps, nextState) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> }</code> </pre><br>  En este caso, prohibimos que React procese el componente, porque <code>false</code> devuelve <code>false</code> . <br>  De lo anterior se deduce que para renderizar el componente necesitamos devolver <code>true</code> .  Ahora podemos reescribir el componente TestC de la siguiente manera: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestC</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(props) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(props); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = { <span class="hljs-attr"><span class="hljs-attr">count</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> } } componentWillUpdate(nextProps, nextState) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'componentWillUpdate'</span></span>) } componentDidUpdate(prevProps, prevState) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'componentDidUpdate'</span></span>) } shouldComponentUpdate(nextProps, nextState) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state.count === nextState.count) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> } render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> &lt;div&gt; { </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">.state.count } &lt;button onClick = { (</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.setState({ <span class="hljs-attr"><span class="hljs-attr">count</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }) }&gt; Click Me &lt;<span class="hljs-regexp"><span class="hljs-regexp">/button&gt; &lt;/</span></span>div&gt; ); } } <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> TestC;</code> </pre><br>  Agregamos un enlace shouldComponentUpdate al componente TestC.  Ahora el valor de <code>count</code> en el objeto de estado actual <code>this.state.count</code> compara con el valor de <code>count</code> en el siguiente objeto de estado <code>nextState.count</code> .  Si son iguales <code>===</code> , no se vuelve a dibujar y <code>false</code> devuelve <code>false</code> .  Si no son iguales, <code>true</code> devuelve <code>true</code> y se inicia un renderizador para mostrar el nuevo valor. <br><br>  Si probamos el c贸digo en un navegador, veremos un resultado familiar: <br><br><img src="https://habrastorage.org/webt/jp/wd/2x/jpwd2xhiz5zckb5f2c-xwosbife.png"><br><br>  Pero al hacer clic en el bot贸n <code>Click Me</code> clic varias veces, todo lo que vemos es lo siguiente (隆se muestra solo una vez!): <br><br> <code>componentWillUpdate <br> componentDidUpdate</code> <br> <br><img src="https://habrastorage.org/webt/gy/xc/ir/gyxcir1kjjyki18hzqxdfz5hzeu.png"><br><br>  Puede cambiar el estado del componente TestC en la pesta帽a React DevTools.  Haga clic en la pesta帽a Reaccionar, seleccione TestC a la derecha y ver谩 el valor del estado del contador: <br><br><img src="https://habrastorage.org/webt/pi/qg/ix/piqgixsafppm6jygqftfm8nkpyq.png"><br><br>  Este valor puede ser cambiado.  Haga clic en el texto del contador, escriba 2 y presione Entrar. <br><br><img src="https://habrastorage.org/webt/v3/4m/tl/v34mtl_unwz6gmkip2kxw_4a1km.png"><br><br>  El estado del conteo cambiar谩 y en la consola veremos: <br><br><pre> <code class="javascript hljs">componentWillUpdate componentDidUpdate componentWillUpdate componentDidUpdate</code> </pre><br><img src="https://habrastorage.org/webt/ql/3y/_i/ql3y_ijc3qwx9byxo_lu8ckbg-g.png"><br><br>  El valor anterior era 1 y el nuevo era 2, por lo que era necesario volver a dibujar. <br>  Pasemos al <b>componente puro</b> . <br><br>  Pure Component apareci贸 en React en la versi贸n v15.5.  Se utiliza para comparar valores predeterminados ( <code>change detection</code> ).  Usando <code>extend React.PureComponent</code> , no tiene que agregar el m茅todo del ciclo de vida <code>shouldComponentUpdate</code> a los componentes: el seguimiento de cambios ocurre por s铆 mismo. <br><br>  Agregue un PureComponent al componente TestC. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestC</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PureComponent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(props) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(props); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = { <span class="hljs-attr"><span class="hljs-attr">count</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> } } componentWillUpdate(nextProps, nextState) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'componentWillUpdate'</span></span>) } componentDidUpdate(prevProps, prevState) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'componentDidUpdate'</span></span>) } <span class="hljs-comment"><span class="hljs-comment">/*shouldComponentUpdate(nextProps, nextState) { if (this.state.count === nextState.count) { return false } return true }*/</span></span> render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> &lt;div&gt; { </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">.state.count } &lt;button onClick = { (</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.setState({ <span class="hljs-attr"><span class="hljs-attr">count</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }) }&gt; Click Me &lt;<span class="hljs-regexp"><span class="hljs-regexp">/button&gt; &lt;/</span></span>div &gt; ); } } <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> TestC;</code> </pre><br>  Como puede ver, <code>shouldComponentUpdate</code> en un comentario.  Ya no lo necesitamos: todo el trabajo lo realiza <code>React.PureComponent</code> . <br><br>  Al reiniciar el navegador para probar la nueva soluci贸n, y al hacer clic en el bot贸n <code>Click Me</code> clic varias veces, obtenemos: <br><br><img src="https://habrastorage.org/webt/jp/wd/2x/jpwd2xhiz5zckb5f2c-xwosbife.png"><br><br><img src="https://habrastorage.org/webt/gy/xc/ir/gyxcir1kjjyki18hzqxdfz5hzeu.png"><br><br>  Como puede ver, solo apareci贸 una entrada de <code>component*Update</code> en la consola. <br><br>  Despu茅s de ver c贸mo trabajar en React con redibujar en las clases de componentes de ES6, pasamos a las funciones de los componentes.  驴C贸mo lograr los mismos resultados con ellos? <br><br><h3>  Componentes de funciones </h3><br>  Ya sabemos c贸mo optimizar el trabajo con clases usando el componente Pure y el <code>shouldComponentUpdate</code> ciclo de vida <code>shouldComponentUpdate</code> .  Nadie argumenta que los componentes de clase son los componentes principales de React, pero puede usar funciones como componentes. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestC</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> I am a functional component </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ) }</code> </pre> <br>  Es importante recordar que los componentes de la funci贸n, a diferencia de los componentes de la clase, no tienen estado (aunque ahora que han <code>useState</code> ganchos de <code>useState</code> , esto puede discutirse), lo que significa que no podemos configurar su redibujo.  Los m茅todos de ciclo de vida que utilizamos al trabajar con clases no est谩n disponibles aqu铆.  Si podemos agregar ganchos de ciclo de vida a los componentes de la funci贸n, podemos agregar el m茅todo <code>shouldComponentUpdate</code> para decirle a React que se necesita un procesador de funciones.  (Quiz谩s el autor cometi贸 un error de hecho en la 煤ltima oraci贸n. - Aprox. Ed.) Y, por supuesto, no podemos usar <code>extend React.PureComponent</code> . <br><br>  Convertimos nuestra clase de componente ES6 TestC en una funci贸n de componente. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TestC = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Rendering TestC :`</span></span> props) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> {props.count} </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ) } <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> TestC; <span class="hljs-comment"><span class="hljs-comment">// App.js &lt;TestC count={5} /&gt;</span></span></code> </pre> <br>  Despu茅s de renderizar en la consola, vemos la entrada <code>Rendering TestC :5</code> . <br><br><img src="https://habrastorage.org/webt/zl/ul/q4/zlulq4t7iokqfn9my1s9yka6v_w.png"><br><br>  Abra DevTools y haga clic en la pesta帽a Reaccionar.  Aqu铆 intentaremos cambiar el valor de las propiedades del componente TestC.  Seleccione TestC, y las propiedades del contador con todas las propiedades y valores de TestC se abrir谩n a la derecha.  Solo vemos el contador con el valor actual de 5. <br><br>  Haga clic en el n煤mero 5 para cambiar el valor.  En su lugar, aparecer谩 una ventana de entrada. <br><br><img src="https://habrastorage.org/webt/1h/u-/31/1hu-31ov7pulpn2iuqatr667rns.png"><br><br>  Si cambiamos el valor num茅rico y presionamos Enter, las propiedades del componente cambiar谩n de acuerdo con el valor que ingresamos.  Supongamos que a los 45. <br><br><img src="https://habrastorage.org/webt/bn/9t/yx/bn9tyxzi3bznqpx_6onqz2athra.png"><br><br>  Vaya a la pesta帽a Consola. <br><br><img src="https://habrastorage.org/webt/1m/8a/k8/1m8ak8oggdsmsahkqbg8npptrau.png"><br><br>  El componente TestC se volvi贸 a dibujar porque el valor anterior de 5 cambi贸 al actual - 45. Vuelva a la pesta帽a Reaccionar y cambie el valor a 45, luego regrese a la Consola. <br><br><img src="https://habrastorage.org/webt/ea/mu/vy/eamuvycxua6dksm8yp_o2b0bcym.png"><br><br>  Como puede ver, el componente se vuelve a dibujar, aunque los valores anteriores y nuevos son los mismos.  :( <br><br>  驴C贸mo gestionar un renderizador? <br><br><h3>  Soluci贸n: React.memo () </h3><br>  <code>React.memo()</code> es una nueva caracter铆stica introducida en React v16.6.  Su principio de funcionamiento es similar al principio de <code>React.PureComponent</code> : ayuda en la gesti贸n del redise帽o de funciones de componentes.  <code>React.memo(...)</code> para componentes de clase es <code>React.PureComponent</code> para componentes de funci贸n. <br><br>  <b>驴C贸mo trabajar con React.memo (...)?</b> <br>  Bastante simple  Digamos que tenemos una funci贸n componente. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Funcomponent = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> Hiya!! I am a Funtional component </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ) }</code> </pre><br>  Solo necesitamos pasar FuncComponent como argumento para la funci贸n React.memo. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Funcomponent = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> Hiya!! I am a Funtional component </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ) } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MemodFuncComponent = React.memo(FunComponent)</code> </pre> <br>  React.memo devuelve MemodFuncComponent <code>purified MemodFuncComponent</code> .  Esto es lo que dibujaremos en el marcado JSX.  Cuando las propiedades y el estado de un componente cambian, React compara las propiedades y estados anteriores y actuales del componente.  Y solo si no son id茅nticos, la funci贸n componente se vuelve a dibujar. <br><br>  Aplique esto al componente de funci贸n TestC. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> TestC = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Rendering TestC :'</span></span>, props) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> { props.count } </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/&gt;</span></span></span><span class="xml"> ) } TestC = React.memo(TestC);</span></span></code> </pre> <br>  Abra un navegador y descargue la aplicaci贸n.  Abra DevTools y vaya a la pesta帽a Reaccionar.  Seleccione <code>&lt;Memo(TestC)&gt;</code> . <br><br>  Si en el bloque de la derecha cambiamos las propiedades del contador a 89, la aplicaci贸n se volver谩 a dibujar. <br><br><img src="https://habrastorage.org/webt/kf/tl/ms/kftlmsn1bznnmh9loxbedc_acqi.png"><br><br>  Si cambiamos el valor al anterior, 89, entonces ... <br><br><img src="https://habrastorage.org/webt/j4/ak/tq/j4aktqq4qfwkizulxk2h-em4ism.png"><br><br>  隆No habr谩 redibujos! <br><br>  Gloria a reaccionar.memo (...)!  :) <br><br>  Sin usar <code>React.memo(...)</code> en nuestro primer ejemplo, la funci贸n del componente TestC se vuelve a dibujar incluso cuando el valor anterior cambia a uno id茅ntico.  Ahora, gracias a <code>React.memo(...)</code> , podemos evitar la representaci贸n innecesaria de las funciones de los componentes. <br><br><h3>  Conclusi贸n </h3><br><ul><li>  Vamos a repasar la lista? </li><li>  <code>React.PureComponent</code> - plata; </li><li>  <code>React.memo(...)</code> - oro; </li><li>  <code>React.PureComponent</code> funciona con clases ES6; </li><li>  <code>React.memo(...)</code> funciona con funciones; </li><li>  <code>React.PureComponent</code> optimiza el redise帽o de las clases ES6; </li><li>  <code>React.memo(...)</code> optimiza el redise帽o de la funci贸n; </li><li>  la optimizaci贸n de funciones es una idea excelente; </li><li>  <code>React</code> nunca volver谩 a ser lo mismo. </li></ul><br>  Si tiene alguna pregunta sobre el art铆culo o cualquier informaci贸n adicional, cambios u objeciones, no dude en escribirme comentarios, correos electr贸nicos o mensajes privados. <br><br>  Gracias </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/442116/">https://habr.com/ru/post/442116/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../442104/index.html">Gu铆a del usuario de Kibana. Visualizaci贸n. Parte 5</a></li>
<li><a href="../442108/index.html">Gu铆a para desarrolladores para crear aplicaciones de IA</a></li>
<li><a href="../442110/index.html">Antipatterns Vim</a></li>
<li><a href="../442112/index.html">Nuevos lenguajes de programaci贸n matan silenciosamente nuestra conexi贸n con la realidad</a></li>
<li><a href="../442114/index.html">Gu铆a para la auditor铆a autom谩tica de contratos inteligentes. Parte 3: Mythril</a></li>
<li><a href="../442118/index.html">El grupo minero de Coinhive deja de funcionar</a></li>
<li><a href="../442120/index.html">Capacitaci贸n de modelos TensorFlow con el Servicio Azure Machine Learning</a></li>
<li><a href="../442122/index.html">Un simple se帽or moscovita: una entrevista con el creador de Duke Nukem</a></li>
<li><a href="../442124/index.html">Facebook dar谩 a los usuarios la oportunidad de limpiar su historia</a></li>
<li><a href="../442128/index.html">Vida en part铆culas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>