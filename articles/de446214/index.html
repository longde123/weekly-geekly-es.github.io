<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§ë üòõ üêΩ OS1: Ein primitiver Kernel auf Rust f√ºr x86. Teil 3. Speicherkarte, Seitenfehlerausnahme, Heap und Zuordnungen üë©üèª‚Äç‚öñÔ∏è üë®‚Äçüë©‚Äçüëß‚Äçüë¶ ü§öüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Erster Teil 
 Zweiter Teil 


 Das Thema des heutigen Gespr√§chs ist die Arbeit mit dem Ged√§chtnis. Ich werde √ºber das Initialisieren des Seitenverzeic...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>OS1: Ein primitiver Kernel auf Rust f√ºr x86. Teil 3. Speicherkarte, Seitenfehlerausnahme, Heap und Zuordnungen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/446214/"><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erster Teil</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zweiter Teil</a> </p><br><p>  Das Thema des heutigen Gespr√§chs ist die Arbeit mit dem Ged√§chtnis.  Ich werde √ºber das Initialisieren des Seitenverzeichnisses, das Zuordnen des physischen Speichers, das Verwalten des virtuellen und meines Organisationsheaps f√ºr den Allokator sprechen. </p><br><p>  Wie ich im ersten Artikel sagte, habe ich beschlossen, 4 MB Seiten zu verwenden, um mein Leben zu vereinfachen und mich nicht mit hierarchischen Tabellen befassen zu m√ºssen.  Ich hoffe, dass ich in Zukunft wie bei den meisten modernen Systemen auf 4-KB-Seiten gehen kann.  Ich k√∂nnte ein fertiges verwenden (zum Beispiel einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">solchen Blockzuweiser</a> ), aber mein eigenes zu schreiben war etwas interessanter und ich wollte ein bisschen mehr verstehen, wie das Ged√§chtnis lebt, also habe ich Ihnen etwas zu sagen. </p><a name="habracut"></a><br><p> Als ich mich das letzte Mal f√ºr die architekturabh√§ngige Methode setup_pd entschieden habe und damit fortfahren wollte, gab es jedoch ein weiteres Detail, das ich im vorherigen Artikel nicht behandelt habe - die VGA-Ausgabe mit Rust und dem Standard-Println-Makro.  Da seine Implementierung trivial ist, werde ich es unter dem Spoiler entfernen.  Der Code befindet sich im Debug-Paket. </p><br><div class="spoiler">  <b class="spoiler_title">Makrodruck</b> <div class="spoiler_text"><pre><code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[macro_export]</span></span> <span class="hljs-built_in"><span class="hljs-built_in">macro_rules!</span></span> print { ($($arg:tt)*) =&gt; ($crate::debug::_print(<span class="hljs-built_in"><span class="hljs-built_in">format_args!</span></span>($($arg)*))); } <span class="hljs-meta"><span class="hljs-meta">#[macro_export]</span></span> <span class="hljs-built_in"><span class="hljs-built_in">macro_rules!</span></span> println { () =&gt; ($crate::<span class="hljs-built_in"><span class="hljs-built_in">print!</span></span>(<span class="hljs-string"><span class="hljs-string">"\n"</span></span>)); ($($arg:tt)*) =&gt; ($crate::<span class="hljs-built_in"><span class="hljs-built_in">print!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}\n"</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">format_args!</span></span>($($arg)*))); } <span class="hljs-meta"><span class="hljs-meta">#[cfg(target_arch = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"x86"</span></span></span><span class="hljs-meta">)]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_print</span></span></span></span>(args: core::fmt::Arguments) { <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> core::fmt::Write; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> super::arch::vga; vga::VGA_WRITER.lock().write_fmt(args).unwrap(); } <span class="hljs-meta"><span class="hljs-meta">#[cfg(target_arch = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"x86_64"</span></span></span><span class="hljs-meta">)]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_print</span></span></span></span>(args: core::fmt::Arguments) { <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> core::fmt::Write; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> super::arch::vga; <span class="hljs-comment"><span class="hljs-comment">// vga::VGA_WRITER.lock().write_fmt(args).unwrap(); }</span></span></code> </pre> </div></div><br><p>  Jetzt kehre ich mit gutem Gewissen in die Erinnerung zur√ºck. </p><br><h1 id="inicializaciya-direktorii-stranic">  Seitenverzeichnis-Initialisierung </h1><br><p>  Unsere kmain-Methode hat drei Argumente als Eingabe verwendet, von denen eines die virtuelle Adresse der Seitentabelle ist.  Um es sp√§ter f√ºr die Zuordnung und Speicherverwaltung zu verwenden, m√ºssen Sie die Struktur von Datens√§tzen und Verzeichnissen festlegen.  F√ºr x86 sind das Seitenverzeichnis und die Seitentabelle recht gut beschrieben, daher beschr√§nke ich mich auf eine kleine Einf√ºhrung.  Der Seitenverzeichniseintrag ist eine Zeigergr√∂√üenstruktur, f√ºr uns sind es 4 Bytes.  Der Wert enth√§lt eine physikalische Adresse von 4 KB der Seite.  Das niedrigstwertige Byte des Datensatzes ist f√ºr Flags reserviert.  Der Mechanismus zum Konvertieren einer virtuellen Adresse in eine physische Adresse sieht folgenderma√üen aus (bei meiner 4-MB-Granularit√§t erfolgt die Verschiebung um 22 Bit. Bei anderen Granularit√§ten ist die Verschiebung unterschiedlich und es werden hierarchische Tabellen verwendet!): </p><br><blockquote>  Virtuelle Adresse 0xC010A110 -&gt; Holen Sie sich den Index in das Verzeichnis, indem Sie die Adresse 22 Bit nach rechts verschieben -&gt; Index 0x300 -&gt; Holen Sie sich die physische Adresse der Seite durch Index 0x300, √ºberpr√ºfen Sie Flags und Status -&gt; 0x1000000 -&gt; Nehmen Sie die unteren 22 Bits der virtuellen Adresse als Offset, f√ºgen Sie hinzu an die physikalische Adresse der Seite -&gt; 0x1000000 + 0x10A110 = physikalische Adresse im Speicher 0x110A110 </blockquote><p>  Um den Zugriff zu beschleunigen, verwendet der Prozessor TLB - Translation Lookaside Buffer, der Seitenadressen zwischenspeichert. </p><br><p>  Hier ist also, wie mein Verzeichnis und seine Eintr√§ge beschrieben werden und die Methode setup_pd implementiert ist.  Zum Schreiben einer Seite wird die Konstruktormethode implementiert, die die Ausrichtung um 4 KB und das Setzen von Flags garantiert, sowie eine Methode zum Abrufen der physischen Adresse der Seite.  Ein Verzeichnis ist nur ein Array von 1024 Vier-Byte-Eintr√§gen.  Das Verzeichnis kann einer Seite mithilfe der Methode set_by_addr eine virtuelle Adresse zuordnen. </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[derive(Debug, Clone, Copy, PartialEq, Eq)]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PDirectoryEntry</span></span></span></span>(<span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> PDirectoryEntry { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">by_phys_address</span></span></span></span>(address: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, flags: PDEntryFlags) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span> { PDirectoryEntry((address <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>) &amp; ADDRESS_MASK | flags.bits()) } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">flags</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; PDEntryFlags { PDEntryFlags::from_bits_truncate(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">phys_address</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> &amp; ADDRESS_MASK } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dbg</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PDirectory</span></span></span></span> { entries: [PDirectoryEntry; <span class="hljs-number"><span class="hljs-number">1024</span></span>] } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> PDirectory { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">at</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, idx: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) -&gt; PDirectoryEntry { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.entries[idx] } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set_by_addr</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, logical_addr: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, entry: PDirectoryEntry) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.set(PDirectory::to_idx(logical_addr), entry); } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, idx: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, entry: PDirectoryEntry) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.entries[idx] = entry; <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { invalidate_page(idx); } } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">to_logical_addr</span></span></span></span>(idx: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> { (idx &lt;&lt; <span class="hljs-number"><span class="hljs-number">22</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">to_idx</span></span></span></span>(logical_addr: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> { (logical_addr &gt;&gt; <span class="hljs-number"><span class="hljs-number">22</span></span>) } } <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> lazy_static::lazy_static; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> spin::Mutex; lazy_static! { <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> PAGE_DIRECTORY: Mutex&lt;&amp;<span class="hljs-symbol"><span class="hljs-symbol">'static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> PDirectory&gt; = Mutex::new( <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> *(<span class="hljs-number"><span class="hljs-number">0xC0000000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> PDirectory) } ); } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup_pd</span></span></span></span>(pd: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> data = PAGE_DIRECTORY.lock(); *data = &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> *(pd <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> PDirectory); }</code> </pre> <br><p>  Ich habe die anf√§ngliche statische Initialisierung sehr umst√§ndlich zu einer nicht vorhandenen Adresse gemacht. Ich w√§re Ihnen dankbar, wenn Sie mir schreiben w√ºrden, wie es in der Rust-Community √ºblich ist, solche Initialisierungen mit Neuzuweisung von Links durchzuf√ºhren. </p><br><p>  Jetzt, da wir Seiten aus Code auf hoher Ebene verwalten k√∂nnen, k√∂nnen wir mit der Kompilierung der Speicherinitialisierung fortfahren.  Dies geschieht in zwei Schritten: durch Verarbeiten der physischen Speicherkarte und Initialisieren des virtuellen Managers </p><br><pre> <code class="rust hljs"> <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> mb_magic { <span class="hljs-number"><span class="hljs-number">0x2BADB002</span></span> =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"multibooted v1, yeah, reading mb info"</span></span>); boot::init_with_mb1(mb_pointer); }, . . . . . . } memory::init();</code> </pre> <br><h1 id="karta-pamyati-grub-i-karta-fizicheskoy-pamyati-os1">  GRUB-Speicherkarte und OS1-Speicherkarte </h1><br><p>  Um eine Speicherkarte von GRUB zu erhalten, habe ich beim Booten das entsprechende Flag im Header gesetzt und GRUB hat mir die physikalische Adresse der Struktur gegeben.  Ich habe es aus der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">offiziellen Dokumentation</a> in die Rust-Notation portiert und Methoden hinzugef√ºgt, um bequem √ºber die Speicherkarte zu iterieren.  Der gr√∂√üte Teil der GRUB-Struktur wird nicht gef√ºllt, und zu diesem Zeitpunkt ist es f√ºr mich nicht sehr interessant.  Die Hauptsache ist, dass ich die Menge des verf√ºgbaren Speichers nicht manuell bestimmen m√∂chte. </p><br><p>  Bei der Initialisierung √ºber Multiboot konvertieren wir zuerst die physische Adresse in eine virtuelle.  Theoretisch kann GRUB die Struktur an einer beliebigen Stelle positionieren. Wenn die Adresse √ºber die Seite hinausgeht, m√ºssen Sie eine virtuelle Seite im Seitenverzeichnis zuweisen.  In der Praxis liegt die Struktur fast immer neben dem ersten Megabyte, das wir bereits beim Booten zugewiesen haben.  F√ºr alle F√§lle √ºberpr√ºfen wir das Flag, dass die Speicherkarte vorhanden ist, und fahren mit ihrer Analyse fort. </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mod</span></span> multiboot2; <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mod</span></span> multiboot; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> super::arch; <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process_pointer</span></span></span></span>(mb_pointer: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> { <span class="hljs-comment"><span class="hljs-comment">//if in first 4 MB - map to kernel address space if mb_pointer &lt; 0x400000 { arch::KERNEL_BASE | mb_pointer } else { arch::paging::allocate_page(mb_pointer, arch::MB_INFO_BASE, arch::paging::PDEntryFlags::PRESENT | arch::paging::PDEntryFlags::WRITABLE | arch::paging::PDEntryFlags::HUGE_PAGE ); arch::MB_INFO_BASE | mb_pointer } } pub fn init_with_mb1(mb_pointer: usize) { let ln_pointer = unsafe { process_pointer(mb_pointer) }; println!("mb pointer 0x{:X}", ln_pointer); let mb_info = multiboot::from_ptr(ln_pointer); println!("mb flags: {:?}", mb_info.flags().unwrap()); if mb_info.flags().unwrap().contains(multiboot::MBInfoFlags::MEM_MAP) { multiboot::parse_mmap(mb_info); println!("Multiboot memory map parsed, physical memory map has been built"); } else { panic!("MB mmap is not presented"); } }</span></span></code> </pre> <br><p>  Eine Speicherkarte ist eine verkn√ºpfte Liste, f√ºr die die anf√§ngliche physikalische Adresse in der Grundstruktur angegeben ist (vergessen Sie nicht, alles in virtuelle zu √ºbersetzen) und die Gr√∂√üe des Arrays in Bytes.  Sie m√ºssen die Liste basierend auf der Gr√∂√üe jedes Elements durchlaufen, da sich ihre Gr√∂√üen <em>theoretisch</em> unterscheiden k√∂nnen.  So sieht die Iteration aus: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> MultibootInfo { . . . . . . <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_mmap</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, index: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;*<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MemMapEntry&gt; { <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> crate::arch::get_mb_pointer_base; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> base: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> = get_mb_pointer_base(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.mmap_addr <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> iter: *<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MemMapEntry = (base <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.mmap_addr) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MemMapEntry; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..index { iter = ((iter <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) + ((*iter).size <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) + <span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MemMapEntry; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((iter <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) - base) &gt;= (<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.mmap_addr + <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.mmap_lenght) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">None</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {} } <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(iter) } }</code> </pre> <br><p>  Beim Parsen einer Speicherkarte durchlaufen wir die GRUB-Struktur und konvertieren sie in eine Bitmap, mit der OS1 den physischen Speicher verwaltet.  Ich habe mich entschlossen, mich auf einen kleinen Satz verf√ºgbarer Werte f√ºr die Steuerung zu beschr√§nken - frei, besch√§ftigt, reserviert, nicht verf√ºgbar, obwohl GRUB und BIOS mehr Optionen bieten.  Also durchlaufen wir die Karteneintr√§ge und konvertieren ihren Status von GRUB / BIOS-Werten in Werte f√ºr OS1: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_mmap</span></span></span></span>(mbi: &amp;MultibootInfo) { <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> mmap_opt = mbi.get_mmap(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> i: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> mmap = mmap_opt.unwrap(); crate::memory::physical::map((*mmap).addr <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, (*mmap).len <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, translate_multiboot_mem_to_os1(&amp;(*mmap).mtype)); mmap_opt = mbi.get_mmap(i); <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> mmap_opt { <span class="hljs-literal"><span class="hljs-literal">None</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>, _ =&gt; i += <span class="hljs-number"><span class="hljs-number">1</span></span>, } } } } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">translate_multiboot_mem_to_os1</span></span></span></span>(mtype: &amp;<span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> crate::memory::physical::{RESERVED, UNUSABLE, USABLE}; <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> mtype { &amp;MULTIBOOT_MEMORY_AVAILABLE =&gt; USABLE, &amp;MULTIBOOT_MEMORY_RESERVED =&gt; UNUSABLE, &amp;MULTIBOOT_MEMORY_ACPI_RECLAIMABLE =&gt; RESERVED, &amp;MULTIBOOT_MEMORY_NVS =&gt; UNUSABLE, &amp;MULTIBOOT_MEMORY_BADRAM =&gt; UNUSABLE, _ =&gt; UNUSABLE } }</code> </pre> <br><p>  Der physische Speicher wird im memory :: Physical-Modul verwaltet, f√ºr das wir die obige Map-Methode aufrufen und ihm die Adresse, die L√§nge und den Status der Region √ºbergeben.  Alle 4 GB Speicher, die dem System m√∂glicherweise zur Verf√ºgung stehen und in vier Megabyte-Seiten unterteilt sind, werden in einer Bitmap durch zwei Bits dargestellt, sodass Sie 4 Status f√ºr 1024 Seiten speichern k√∂nnen.  Insgesamt ben√∂tigt diese Konstruktion 256 Bytes.  Eine Bitmap f√ºhrt zu einer schrecklichen Speicherfragmentierung, ist aber verst√§ndlich und einfach zu implementieren, was f√ºr meinen Zweck die Hauptsache ist. </p><br><p>  Ich werde die Bitmap-Implementierung unter dem Spoiler entfernen, um den Artikel nicht zu √ºberladen.  Die Struktur kann die Anzahl der Klassen und den freien Speicher z√§hlen, Seiten nach Index und Adresse markieren und auch nach freien Seiten suchen (dies wird in Zukunft ben√∂tigt, um den Heap zu implementieren).  Die Karte selbst ist ein Array von 64 u32-Elementen. Um die erforderlichen zwei Bits (Bl√∂cke) zu isolieren, wird die Umwandlung in den sogenannten Chunk (Index im Array, Packen von 16 Bl√∂cken) und Block (Bitposition im Chunk) verwendet. </p><br><div class="spoiler">  <b class="spoiler_title">Bitmap f√ºr den physischen Speicher</b> <div class="spoiler_text"><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> USABLE: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> USED: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> RESERVED: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> UNUSABLE: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> DEAD: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> = <span class="hljs-number"><span class="hljs-number">0xDEAD</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PhysMemoryInfo</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> total: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, used: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, reserved: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, chunks: [<span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>; <span class="hljs-number"><span class="hljs-number">64</span></span>], } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> PhysMemoryInfo { <span class="hljs-comment"><span class="hljs-comment">// returns (chunk, page) pub fn find_free(&amp;self) -&gt; (usize, usize) { for chunk in 0..64 { for page in 0.. 16 { if ((self.chunks[chunk] &gt;&gt; page * 2) &amp; 3) ^ 3 == 3 { return (chunk, page) } else {} } } (DEAD, 0) } // marks page to given flag and returns its address pub fn mark(&amp;mut self, chunk: usize, block: usize, flag: usize) -&gt; usize { self.chunks[chunk] = self.chunks[chunk] ^ (3 &lt;&lt; (block * 2)); let mask = (0xFFFFFFFC ^ flag).rotate_left(block as u32 * 2); self.chunks[chunk] = self.chunks[chunk] &amp; (mask as u32); if flag == USED { self.used += 1; } else if flag == UNUSABLE || flag == RESERVED { self.reserved += 1; } else { if self.used &gt; 0 { self.used -= 1; } } (chunk * 16 + block) &lt;&lt; 22 } pub fn mark_by_addr(&amp;mut self, addr: usize, flag: usize) { let block_num = addr &gt;&gt; 22; let chunk: usize = (block_num / 16) as usize; let block: usize = block_num - chunk * 16; self.mark(chunk, block, flag); } pub fn count_total(&amp; mut self) { let mut count: usize = 0; for i in 0..64 { let mut chunk = self.chunks[i]; for _j in 0..16 { if chunk &amp; 0b11 != 0b11 { count += 1; } chunk = chunk &gt;&gt; 2; } } self.total = count; } pub fn get_total(&amp;self) -&gt; usize { self.total } pub fn get_used(&amp;self) -&gt; usize { self.used } pub fn get_reserved(&amp;self) -&gt; usize { self.reserved } pub fn get_free(&amp;self) -&gt; usize { self.total - self.used - self.reserved } }</span></span></code> </pre> </div></div><br><p>  Und jetzt kommen wir zur Analyse eines Elements der Karte.  Wenn ein Kartenelement einen Speicherbereich mit weniger als einer Seite von 4 MB oder mehr beschreibt, markieren wir diese Seite als Ganzes.  Wenn mehr - in St√ºcke von 4 MB schlagen und jedes St√ºck durch Rekursion separat markieren.  In der Phase der Initialisierung der Bitmap betrachten wir alle Speicherabschnitte als unzug√§nglich, sodass die verbleibenden Abschnitte als unzug√§nglich markiert werden, wenn die Karte beispielsweise 128 MB leer ist. </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> lazy_static::lazy_static; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> spin::Mutex; lazy_static! { <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> RAM_INFO: Mutex&lt;PhysMemoryInfo&gt; = Mutex::new(PhysMemoryInfo { total: <span class="hljs-number"><span class="hljs-number">0</span></span>, used: <span class="hljs-number"><span class="hljs-number">0</span></span>, reserved: <span class="hljs-number"><span class="hljs-number">0</span></span>, chunks: [<span class="hljs-number"><span class="hljs-number">0xFFFFFFFF</span></span>; <span class="hljs-number"><span class="hljs-number">64</span></span>] }); } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">map</span></span></span></span>(addr: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, len: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, flag: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// if len &lt;= 4MiB then mark whole page with flag if len &lt;= 4 * 1024 * 1024 { RAM_INFO.lock().mark_by_addr(addr, flag); } else { let pages: usize = len &gt;&gt; 22; for map_page in 0..(pages - 1) { map(addr + map_page &lt;&lt; 22, 4 * 1024 * 1024, flag); } map(addr + (pages &lt;&lt; 22), len - (pages &lt;&lt; 22), flag); } }</span></span></code> </pre> <br><h1 id="kucha-i-upravlenie-ey">  Haufen und sie verwalten </h1><br><p>  Die Verwaltung des virtuellen Speichers beschr√§nkt sich derzeit nur auf die Heap-Verwaltung, da der Kernel nicht viel mehr wei√ü.  In Zukunft wird es nat√ºrlich notwendig sein, den gesamten Speicher zu verwalten, und dieser kleine Manager wird neu geschrieben.  Im Moment brauche ich jedoch nur statischen Speicher, der den ausf√ºhrbaren Code und den Stapel enth√§lt, sowie dynamischen Heap-Speicher, in dem ich die Strukturen f√ºr Multithreading zuweisen werde.  Wir weisen statischen Speicher beim Booten zu (und bisher haben wir 4 MB begrenzt, weil der Kernel in sie passt) und im Allgemeinen gibt es jetzt keine Probleme damit.  Au√üerdem habe ich zu diesem Zeitpunkt keine DMA-Ger√§te, daher ist alles sehr einfach, aber verst√§ndlich. </p><br><p>  Ich habe dem Heap 512 MB des obersten Kernel-Speicherplatzes (0xE0000000) gegeben, ich speichere die Heap-Nutzungszuordnung (0xDFC00000) 4 MB niedriger.  Ich benutze eine Bitmap, um den Zustand zu beschreiben, genau wie f√ºr den physischen Speicher, aber es gibt nur 2 Zust√§nde darin - besch√§ftigt / frei.  Die Gr√∂√üe des Speicherblocks betr√§gt 64 Byte - dies ist viel f√ºr kleine Variablen wie u32, u8, aber m√∂glicherweise optimal zum Speichern von Datenstrukturen.  Es ist jedoch unwahrscheinlich, dass wir einzelne Variablen auf dem Heap speichern m√ºssen. Jetzt besteht der Hauptzweck darin, Kontextstrukturen f√ºr Multitasking zu speichern. </p><br><p>  Bl√∂cke mit 64 Bytes sind in Strukturen gruppiert, die den Status einer gesamten 4-MB-Seite beschreiben, sodass wir mehreren Seiten sowohl kleine als auch gro√üe Speichermengen zuweisen k√∂nnen.  Ich verwende die folgenden Begriffe: Chunk - 64 Bytes, Pack - 2 KB (ein U32 - 64 Bytes * 32 Bit pro Paket), Seite - 4 MB. </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[repr(packed)]</span></span> <span class="hljs-meta"><span class="hljs-meta">#[derive(Copy, Clone)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HeapPageInfo</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">//every bit represents 64 bytes chunk of memory. 0 is free, 1 is busy //u32 size is 4 bytes, so page information total size is 8KiB pub _4mb_by_64b: [u32; 2048], } #[repr(packed)] #[derive(Copy, Clone)] struct HeapInfo { //Here we can know state of any 64 bit chunk in any of 128 4-MiB pages //Page information total size is 8KiB, so information about 128 pages requires 1MiB reserved data pub _512mb_by_4mb: [HeapPageInfo; 128], }</span></span></code> </pre> <br><p>  Wenn ich Speicher von einem Allokator anfordere, betrachte ich drei F√§lle, abh√§ngig von der Granularit√§t: </p><br><ul><li>  Eine Anforderung f√ºr einen Speicher von weniger als 2 KB kam vom Allokator.  Sie m√ºssen ein Paket finden, in dem es frei ist [Gr√∂√üe / 64, jeder Rest ungleich Null f√ºgt eins hinzu], Chunks hintereinander markieren, diese Chunks als besch√§ftigt markieren und die Adresse des ersten Chunks zur√ºckgeben. </li><li>  Vom Allokator wurde eine Anforderung f√ºr Speicher mit weniger als 4 MB, aber mehr als 2 KB gestellt.  Sie m√ºssen eine Seite mit kostenlosen [Gr√∂√üe / 2048, jeder Rest ungleich Null f√ºgt eine hinzu] Packs in einer Reihe finden.  Markieren Sie [size / 2048] -Packs als besch√§ftigt. Wenn ein Rest vorhanden ist, markieren Sie [rest] Chunks im letzten Pack als besch√§ftigt. </li><li>  Eine Anforderung f√ºr einen Speicher von mehr als 4 MB kam vom Allokator.  Suchen Sie [Gr√∂√üe / 4 Mi, jeder Kontostand ungleich Null f√ºgt eine] Seite in einer Reihe hinzu, markieren Sie [Gr√∂√üe / 4 Mi] Seiten als belegt, wenn ein Kontostand vorhanden ist - markieren Sie [Kontostand] -Pakete als belegt.  Markieren Sie in der letzten Packung den Rest der Bl√∂cke als besch√§ftigt. </li></ul><br><p>  Die Suche nach freien Bereichen h√§ngt auch von der Granularit√§t ab - ein Array wird f√ºr Iterations- oder Bitmasken ausgew√§hlt.  Wann immer Sie ins Ausland gehen, passiert OOM.  Bei der Freigabe wird ein √§hnlicher Algorithmus verwendet, nur zum Markieren freigegeben.  Der freigegebene Speicher wird nicht zur√ºckgesetzt.  Der ganze Code ist gro√ü, ich werde ihn unter den Spoiler stellen. </p><br><div class="spoiler">  <b class="spoiler_title">Bitmap f√ºr virtuellen Speicher</b> <div class="spoiler_text"><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">//512 MiB should be enough for kernel heap. If not - ooops... pub const KHEAP_START: usize = 0xE0000000; //I will keep 1MiB info about my heap in separate 4MiB page before heap at this point pub const KHEAP_INFO_ADDR: usize = 0xDFC00000; pub const KHEAP_CHUNK_SIZE: usize = 64; pub fn init() { KHEAP_INFO.lock().init(); } #[repr(packed)] #[derive(Copy, Clone)] struct HeapPageInfo { //every bit represents 64 bytes chunk of memory. 0 is free, 1 is busy //u32 size is 4 bytes, so page information total size is 8KiB pub _4mb_by_64b: [u32; 2048], } impl HeapPageInfo { pub fn init(&amp;mut self) { for i in 0..2048 { self._4mb_by_64b[i] = 0; } } pub fn mark_chunks_used(&amp;mut self, _32pack: usize, chunk: usize, n: usize) { let mask: u32 = 0xFFFFFFFF &gt;&gt; (32 - n) &lt;&lt; chunk; self._4mb_by_64b[_32pack] = self._4mb_by_64b[_32pack] | mask; } pub fn mark_chunks_free(&amp;mut self, _32pack: usize, chunk: usize, n: usize) { let mask: u32 = 0xFFFFFFFF &gt;&gt; (32 - n) &lt;&lt; chunk; self._4mb_by_64b[_32pack] = self._4mb_by_64b[_32pack] ^ mask; } pub fn empty(&amp;self) -&gt; bool { for i in 0..2048 { if self._4mb_by_64b[i] != 0 { return false } } true } } #[repr(packed)] #[derive(Copy, Clone)] struct HeapInfo { //Here we can know state of any 64 bit chunk in any of 128 4-MiB pages //Page information total size is 8KiB, so information about 128 pages requires 1MiB reserved data pub _512mb_by_4mb: [HeapPageInfo; 128], } impl HeapInfo { pub fn init(&amp;mut self) { for i in 0..128 { self._512mb_by_4mb[i].init(); } } // returns page number pub fn find_free_pages_of_size(&amp;self, n: usize) -&gt; usize { if n &gt;= 128 { 0xFFFFFFFF } else { let mut start_page: usize = 0xFFFFFFFF; let mut current_page: usize = 0xFFFFFFFF; for page in 0..128 { if self._512mb_by_4mb[page].empty() { if current_page - start_page == n { return start_page } if start_page == 0xFFFFFFFF { start_page = page; } current_page = page; } else { start_page = 0xFFFFFFFF; current_page = 0xFFFFFFFF; } } 0xFFFFFFFF } } // returns (page number, 32pack number) pub fn find_free_packs_of_size(&amp;self, n: usize) -&gt; (usize, usize) { if n &lt; 2048 { for page in 0..128 { let mut start_pack: usize = 0xFFFFFFFF; let mut current_pack: usize = 0xFFFFFFFF; for _32pack in 0..2048 { let _32pack_info = self._512mb_by_4mb[page]._4mb_by_64b[_32pack]; if _32pack_info == 0 { if current_pack - start_pack == n { return (page, start_pack) } if start_pack == 0xFFFFFFFF { start_pack = _32pack; } current_pack = _32pack; } else { start_pack = 0xFFFFFFFF; current_pack = 0xFFFFFFFF; } } } (0xFFFFFFFF, 0xFFFFFFFF) } else { (0xFFFFFFFF, 0xFFFFFFFF) } } // returns (page number, 32pack number, chunk number) pub fn find_free_chunks_of_size(&amp;self, n: usize) -&gt; (usize, usize, usize) { if n &lt; 32 { for page in 0..128 { for _32pack in 0..2048 { let _32pack_info = self._512mb_by_4mb[page]._4mb_by_64b[_32pack]; let mask: u32 = 0xFFFFFFFF &gt;&gt; (32 - n); for chunk in 0..(32-n) { if ((_32pack_info &gt;&gt; chunk) &amp; mask) ^ mask == mask { return (page, _32pack, chunk) } } } } (0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF) } else { (0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF) } } fn mark_chunks_used(&amp;mut self, page: usize, _32pack: usize, chunk: usize, n: usize) { self._512mb_by_4mb[page].mark_chunks_used(_32pack, chunk, n); } fn mark_chunks_free(&amp;mut self, page: usize, _32pack: usize, chunk: usize, n: usize) { self._512mb_by_4mb[page].mark_chunks_free(_32pack, chunk, n); } fn mark_packs_used(&amp;mut self, page: usize, _32pack:usize, n: usize) { for i in _32pack..(_32pack + n) { self._512mb_by_4mb[page]._4mb_by_64b[i] = 0xFFFFFFFF; } } fn mark_packs_free(&amp;mut self, page: usize, _32pack:usize, n: usize) { for i in _32pack..(_32pack + n) { self._512mb_by_4mb[page]._4mb_by_64b[i] = 0; } } } use lazy_static::lazy_static; use spin::Mutex; lazy_static! { static ref KHEAP_INFO: Mutex&lt;&amp;'static mut HeapInfo&gt; = Mutex::new(unsafe { &amp;mut *(KHEAP_INFO_ADDR as *mut HeapInfo) }); } fn allocate_n_chunks_less_than_pack(n: usize, align: usize) -&gt; *mut u8 { let mut heap_info = KHEAP_INFO.lock(); let (page, _32pack, chunk) = heap_info.find_free_chunks_of_size(n); if page == 0xFFFFFFFF { core::ptr::null_mut() } else { let tptr: usize = KHEAP_START + 0x400000 * page + _32pack * 32 * 64 + chunk * 64; let res = tptr % align; let uptr = if res == 0 { tptr } else { tptr + align - res }; //check bounds: more than start and less than 4GiB - 64B //but according to chunks error should never happen if uptr &gt;= KHEAP_START &amp;&amp; uptr &lt;= 0xFFFFFFFF - 64 * n { heap_info.mark_chunks_used(page, _32pack, chunk, n); uptr as *mut u8 } else { core::ptr::null_mut() } } } fn allocate_n_chunks_less_than_page(n: usize, align: usize) -&gt; *mut u8 { let mut heap_info = KHEAP_INFO.lock(); let packs_n: usize = n / 32; let lost_chunks = n - packs_n * 32; let mut packs_to_alloc = packs_n; if lost_chunks != 0 { packs_to_alloc += 1; } let (page, pack) = heap_info.find_free_packs_of_size(packs_to_alloc); if page == 0xFFFFFFFF { core::ptr::null_mut() } else { let tptr: usize = KHEAP_START + 0x400000 * page + pack * 32 * 64; let res = tptr % align; let uptr = if res == 0 { tptr } else { tptr + align - res }; //check bounds: more than start and less than 4GiB - 64B //but according to chunks error should never happen if uptr &gt;= KHEAP_START &amp;&amp; uptr &lt;= 0xFFFFFFFF - 64 * n { heap_info.mark_packs_used(page, pack, packs_n); if lost_chunks != 0 { heap_info.mark_chunks_used(page, pack + packs_to_alloc, 0, lost_chunks); } uptr as *mut u8 } else { core::ptr::null_mut() } } } //unsupported yet fn allocate_n_chunks_more_than_page(n: usize, align: usize) -&gt; *mut u8 { let mut heap_info = KHEAP_INFO.lock(); let packs_n: usize = n / 32; let lost_chunks = n - packs_n * 32; let mut packs_to_alloc = packs_n; if lost_chunks != 0 { packs_to_alloc += 1; } let pages_n: usize = packs_to_alloc / 2048; let mut lost_packs = packs_to_alloc - pages_n * 2048; let mut pages_to_alloc = pages_n; if lost_packs != 0 { pages_to_alloc += 1; } if lost_chunks != 0 { lost_packs -= 1; } let page = heap_info.find_free_pages_of_size(pages_to_alloc); if page == 0xFFFFFFFF { core::ptr::null_mut() } else { let tptr: usize = KHEAP_START + 0x400000 * page; let res = tptr % align; let uptr = if res == 0 { tptr } else { tptr + align - res }; //check bounds: more than start and less than 4GiB - 64B * n //but according to chunks error should never happen if uptr &gt;= KHEAP_START &amp;&amp; uptr &lt;= 0xFFFFFFFF - 64 * n { for i in page..(page + pages_n) { heap_info.mark_packs_used(i, 0, 2048); } if lost_packs != 0 { heap_info.mark_packs_used(page + pages_to_alloc, 0, lost_packs); } if lost_chunks != 0 { heap_info.mark_chunks_used(page + pages_to_alloc, lost_packs, 0, lost_chunks); } uptr as *mut u8 } else { core::ptr::null_mut() } } } // returns pointer pub fn allocate_n_chunks(n: usize, align: usize) -&gt; *mut u8 { if n &lt; 32 { allocate_n_chunks_less_than_pack(n, align) } else if n &lt; 32 * 2048 { allocate_n_chunks_less_than_page(n, align) } else { allocate_n_chunks_more_than_page(n, align) } } pub fn free_chunks(ptr: usize, n: usize) { let page: usize = (ptr - KHEAP_START) / 0x400000; let _32pack: usize = ((ptr - KHEAP_START) - (page * 0x400000)) / (32 * 64); let chunk: usize = ((ptr - KHEAP_START) - (page * 0x400000) - (_32pack * (32 * 64))) / 64; let mut heap_info = KHEAP_INFO.lock(); if n &lt; 32 { heap_info.mark_chunks_free(page, _32pack, chunk, n); } else if n &lt; 32 * 2048 { let packs_n: usize = n / 32; let lost_chunks = n - packs_n * 32; heap_info.mark_packs_free(page, _32pack, packs_n); if lost_chunks != 0 { heap_info.mark_chunks_free(page, _32pack + packs_n, 0, lost_chunks); } } else { let packs_n: usize = n / 32; let pages_n: usize = packs_n / 2048; let lost_packs: usize = packs_n - pages_n * 2048; let lost_chunks = n - packs_n * 32; for i in page..(page + pages_n) { heap_info.mark_packs_free(i, 0, 2048); } if lost_packs != 0 { heap_info.mark_packs_free(page + pages_n, 0, lost_packs); } if lost_chunks != 0 { heap_info.mark_chunks_free(page + pages_n, packs_n, 0, lost_chunks); } } }</span></span></code> </pre> </div></div><br><h1 id="allokaciya-i-page-fault">  Zuordnung und Seitenfehler </h1><br><p>  Um den Heap verwenden zu k√∂nnen, ben√∂tigen Sie einen Allokator.  Wenn wir es hinzuf√ºgen, √∂ffnen sich f√ºr uns ein Vektor, B√§ume, Hash-Tabellen, Kisten und mehr, ohne die es fast unm√∂glich ist, weiterzuleben.  Sobald wir das Allokationsmodul anschlie√üen und einen globalen Allokator deklarieren, wird das Leben sofort einfacher. </p><br><p>  Die Implementierung des Allokators ist sehr einfach - sie bezieht sich einfach auf den oben beschriebenen Mechanismus. </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> alloc::alloc::{GlobalAlloc, Layout}; <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Os1Allocator</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Sync</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Os1Allocator {} <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> GlobalAlloc <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Os1Allocator { <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">alloc</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, layout: Layout) -&gt; *<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> super::logical::{KHEAP_CHUNK_SIZE, allocate_n_chunks}; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> size = layout.size(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> chunk_count: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> size &gt; KHEAP_CHUNK_SIZE { chunk_count = size / KHEAP_CHUNK_SIZE; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> KHEAP_CHUNK_SIZE * chunk_count != size { chunk_count += <span class="hljs-number"><span class="hljs-number">1</span></span>; } } allocate_n_chunks(chunk_count, layout.align()) } <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dealloc</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, ptr: *<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>, layout: Layout) { <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> super::logical::{KHEAP_CHUNK_SIZE, free_chunks}; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> size = layout.size(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> chunk_count: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> size &gt; KHEAP_CHUNK_SIZE { chunk_count = size / KHEAP_CHUNK_SIZE; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> KHEAP_CHUNK_SIZE * chunk_count != size { chunk_count += <span class="hljs-number"><span class="hljs-number">1</span></span>; } } free_chunks(ptr <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, chunk_count); } }</code> </pre> <br><p>  Der Allokator in lib.rs wird wie folgt aktiviert: </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#![feature(alloc, alloc_error_handler)]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> alloc; <span class="hljs-meta"><span class="hljs-meta">#[global_allocator]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> ALLOCATOR: memory::allocate::Os1Allocator = memory::allocate::Os1Allocator;</code> </pre> <br><p>  Und wenn wir versuchen, uns nur so zuzuweisen, erhalten wir eine Seitenfehlerausnahme, da wir die Zuweisung des virtuellen Speichers noch nicht ausgearbeitet haben.  Nun, wie so!  Nun, Sie m√ºssen zum Material des vorherigen Artikels zur√ºckkehren und Ausnahmen hinzuf√ºgen.  Ich habe mich f√ºr die verz√∂gerte Zuweisung des virtuellen Speichers entschieden, dh, die Seite wurde nicht zum Zeitpunkt der Speicheranforderung, sondern zum Zeitpunkt des Zugriffsversuchs zugewiesen.  Gl√ºcklicherweise erlaubt und f√∂rdert der x86-Prozessor dies.   Page fault     ,   ,    ,          ‚Äî      ,     ,    CR2 ‚Äî  ,    . </p><br><p>    ,      .        32 (     ,     ,     32 ),    .           Rust.           ,        .  ,   ,   iret    ,    ,     Page fault   Protection fault.        Protection fault ‚Äî ,        . </p><br><pre> <code class="plaintext hljs">eE_page_fault: pushad mov eax, [esp + 32] push eax mov eax, cr2 push eax call kE_page_fault pop eax pop eax popad add esp, 4 iret</code> </pre> <br><p>  Rust         ,    .     ,     .            .            . </p><br><pre> <code class="rust hljs"><span class="hljs-built_in"><span class="hljs-built_in">bitflags!</span></span> { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PFErrorCode</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> PROTECTION = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//1 - protection caused, 0 - not present page caused const WRITE = 1 &lt;&lt; 1; //1 - write caused, 0 - read caused const USER_MODE = 1 &lt;&lt; 2; //1 - from user mode, 0 - from kernel const RESERVED = 1 &lt;&lt; 3; //1 - reserved page (PAE/PSE), 0 - not const INSTRUCTION = 1 &lt;&lt; 4; //1 - instruction fetch caused, 0 - not } } impl PFErrorCode { pub fn to_pd_flags(&amp;self) -&gt; super::super::paging::PDEntryFlags { use super::super::paging; let mut flags = paging::PDEntryFlags::empty(); if self.contains(PFErrorCode::WRITE) { flags.set(paging::PDEntryFlags::WRITABLE, true); } if self.contains(PFErrorCode::USER_MODE) { flags.set(paging::PDEntryFlags::USER_ACCESSIBLE, true); } flags } } #[no_mangle] pub unsafe extern fn kE_page_fault(ptr: usize, code: usize) { use super::super::paging; println!("Page fault occured at addr 0x{:X}, code {:X}", ptr, code); let phys_address = crate::memory::physical::alloc_page(); let code_flags: PFErrorCode = PFErrorCode::from_bits(code).unwrap(); if !code_flags.contains(PFErrorCode::PROTECTION) { //page not presented, we need to allocate the new one let mut flags: paging::PDEntryFlags = code_flags.to_pd_flags(); flags.set(paging::PDEntryFlags::HUGE_PAGE, true); paging::allocate_page(phys_address, ptr, flags); println!("Page frame allocated at Paddr {:#X} Laddr {:#X}", phys_address, ptr); } else { panic!("Protection error occured, cannot handle yet"); } }</span></span></code> </pre> <br><p>        ,   .  ,       .           .          ,      .    ,      ,        : </p><br><pre> <code class="rust hljs"> <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"memory: total {} used {} reserved {} free {}"</span></span>, memory::physical::total(), memory::physical::used(), memory::physical::reserved(), memory::physical::free()); <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> alloc::vec::<span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> vec: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; = <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>::new(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">1000000</span></span> { vec.push(i); } <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"vec len {}, ptr is {:?}"</span></span>, vec.len(), vec.as_ptr()); <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Still works, check reusage!"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> vec2: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; = <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>::new(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">10</span></span> { vec2.push(i); } <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"vec2 len {}, ptr is {:?}, vec is still here? {}"</span></span>, vec2.len(), vec2.as_ptr(), vec.get(<span class="hljs-number"><span class="hljs-number">1000</span></span>).unwrap()); <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Still works!"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"memory: total {} used {} reserved {} free {}"</span></span>, memory::physical::total(), memory::physical::used(), memory::physical::reserved(), memory::physical::free());</code> </pre> <br><p>     : <br><img src="https://habrastorage.org/webt/7x/y3/bs/7xy3bs8m91uxbmexphxpelzc2cs.jpeg" alt="OS1-Heap"></p><br><p>  ,   ,           .          3,5  + 3 ,   .          3,5     . </p><br><p> IRQ 1    ‚Äî        Alt + PrntScrn :) </p><br><p> ,    ,      Rust ‚Äî       ,   ‚Äî    ,    ! </p><br><p>       ,                . </p><br><p>  Vielen Dank f√ºr Ihre Aufmerksamkeit! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de446214/">https://habr.com/ru/post/de446214/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de446204/index.html">Prognose, wie Internetbeschr√§nkungen √ºberwunden werden</a></li>
<li><a href="../de446206/index.html">React Tutorial Teil 26: Anwendungsarchitektur, Container- / Komponentenmuster</a></li>
<li><a href="../de446208/index.html">React Tutorial Teil 25: Workshop zu Formularen</a></li>
<li><a href="../de446210/index.html">ADAM-3600 - eine multifunktionale industrielle Steuerung</a></li>
<li><a href="../de446212/index.html">SIEM-Tiefen: Out-of-Box-Korrelationen. Teil 5. Methodik zur Entwicklung von Korrelationsregeln</a></li>
<li><a href="../de446218/index.html">Game Designer unterscheidet sich nicht viel von einem Psycho. Wie wir das CMAN-Spiel gemacht haben</a></li>
<li><a href="../de446222/index.html">Nutzung thermischer Potentiale f√ºr die Gebietsanalyse</a></li>
<li><a href="../de446228/index.html">Verbesserung der Qualit√§t der Textklassifizierung durch Verbindung von Wikipedia</a></li>
<li><a href="../de446230/index.html">Die Fern√ºberwachung und -verwaltung von Linux / OpenWrt / Lede-basierten Ger√§ten √ºber Port 80 wurde fortgesetzt</a></li>
<li><a href="../de446234/index.html">Wie Freiwillige aus aller Welt Live-√úbertragungen von ICPC-2019 erstellen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>