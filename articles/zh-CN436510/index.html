<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👘 👨🏿‍⚕️ 🤹🏿 核心数据详细 ☎️ 🧑🏾‍🤝‍🧑🏽 ↔️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="最近，我开始使用Core Data进行大型项目。 通常的事情是项目人员会改变，经验会丢失，而细微之处会被遗忘。 不可能使每个人都深入研究特定的框架-每个人都有自己的工作问题。 因此，我准备了一个简短的演讲，从我认为很重要或在教程中没有涵盖的观点出发。 我与所有人共享，希望这将有助于编写有效的代码而不...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>核心数据详细</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436510/">最近，我开始使用Core Data进行大型项目。 通常的事情是项目人员会改变，经验会丢失，而细微之处会被遗忘。 不可能使每个人都深入研究特定的框架-每个人都有自己的工作问题。 因此，我准备了一个简短的演讲，从我认为很重要或在教程中没有涵盖的观点出发。 我与所有人共享，希望这将有助于编写有效的代码而不犯错误。 假设您已经对这个主题有些了解。 <br><br> 我将从平庸开始。 <br><br> 核心数据是在应用程序中管理和存储数据的框架。 您可以将Core Data视为物理关系存储的包装，该物理关系存储以对象的形式表示数据，而Core Data本身不是数据库。 <br><br><h2> 核心数据对象 </h2><br><img src="https://habrastorage.org/webt/aq/ka/bk/aqkabk_js9w9knvyat6xp_u4u5a.png" alt="图片"><br><a name="habracut"></a><br> 为了创建存储，应用程序使用<b>NSPersistentStoreCoordinator</b>或<b>NSPersistentContainer类</b> 。  NSPersistentStoreCoordinator基于模型创建指定类型的存储，您可以指定位置和其他选项。  NSPersistentContainer可以与iOS10一起使用，提供以最少的代码创建的能力。 <br><br> 它的工作方式如下：如果指定路径上存在数据库，则协调器检查其版本，并在必要时进行迁移。 如果数据库不存在，则会根据NSManagedObjectModel模型创建数据库。 为了使所有这些正常工作，在更改模型之前，请通过菜单编辑器-&gt;添加模型版本在Xcode中创建新版本。 如果您获得路径，则可以在仿真器中找到并打开基础。 <br><br><div class="spoiler">  <b class="spoiler_title">NSPersistentStoreCoordinator的示例</b> <div class="spoiler_text"><pre><code class="objectivec hljs">var persistentCoordinator: <span class="hljs-built_in"><span class="hljs-built_in">NSPersistentStoreCoordinator</span></span> = { let modelURL = Bundle.main.url(forResource: <span class="hljs-string"><span class="hljs-string">"Test"</span></span>, withExtension: <span class="hljs-string"><span class="hljs-string">"momd"</span></span>) let managedObjectModel = <span class="hljs-built_in"><span class="hljs-built_in">NSManagedObjectModel</span></span>(contentsOf: modelURL!) let persistentCoordinator = <span class="hljs-built_in"><span class="hljs-built_in">NSPersistentStoreCoordinator</span></span>(managedObjectModel: managedObjectModel!) let documentsPath = <span class="hljs-built_in"><span class="hljs-built_in">NSSearchPathForDirectoriesInDomains</span></span>(.documentDirectory, .userDomainMask, <span class="hljs-literal"><span class="hljs-literal">true</span></span>)[<span class="hljs-number"><span class="hljs-number">0</span></span>] let storeURL = URL(fileURLWithPath: documentsPath.appending(<span class="hljs-string"><span class="hljs-string">"/Test.sqlite"</span></span>)) print(<span class="hljs-string"><span class="hljs-string">"storeUrl = \(storeURL)"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { try persistentCoordinator.addPersistentStore(ofType: <span class="hljs-built_in"><span class="hljs-built_in">NSSQLiteStoreType</span></span>, configurationName: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, at: storeURL, options: [<span class="hljs-built_in"><span class="hljs-built_in">NSSQLitePragmasOption</span></span>: [<span class="hljs-string"><span class="hljs-string">"journal_mode"</span></span>:<span class="hljs-string"><span class="hljs-string">"MEMORY"</span></span>]]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> persistentCoordinator } catch { abort() } } ()</code> </pre> <br></div></div><div class="spoiler">  <b class="spoiler_title">NSPersistentContainer示例</b> <div class="spoiler_text"><pre> <code class="objectivec hljs">var persistentContainer: <span class="hljs-built_in"><span class="hljs-built_in">NSPersistentContainer</span></span> = { let container = <span class="hljs-built_in"><span class="hljs-built_in">NSPersistentContainer</span></span>(name: <span class="hljs-string"><span class="hljs-string">"CoreDataTest"</span></span>) container.loadPersistentStores(completionHandler: { (storeDescription, error) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> print(<span class="hljs-string"><span class="hljs-string">"storeDescription = \(storeDescription)"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> let error = error as <span class="hljs-built_in"><span class="hljs-built_in">NSError</span></span>? { fatalError(<span class="hljs-string"><span class="hljs-string">"Unresolved error \(error), \(error.userInfo)"</span></span>) } }) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> container } ()</code> </pre><br></div></div><br> 核心数据使用4种类型的存储： <br><br>  -SQLite <br>  -二进制 <br>  -内存中 <br>  -XML（仅Mac OS） <br><br> 例如，出于安全原因，如果您不想以文件形式存储数据，但同时又希望在会话期间使用缓存并且以对象形式使用数据，则“内存中”类型的存储非常适合。 实际上，在一个应用程序中禁止具有几种不同类型的存储。 <br><br> 我想谈谈<b>NSManagedObjectContext</b>对象。 通常，Apple为NSManagedObjectContext（用于处理Core Data对象的环境）提供了非常模糊的措辞。 所有这些都是出于将自己从与关系数据库的关联中分离出来，以及将核心数据呈现为一种易于使用的工具的需求，该工具不需要了解键，事务和其他Bazdan属性。 但是在关系数据库的语言中，NSManagedObjectContext在某种意义上可以称为事务管理器。 您可能已经注意到它具有保存和回滚方法，尽管很可能仅使用第一个方法。 <br><br> 对这个简单事实的误解导致使用单上下文模型，即使在这种情况下，这仍然是不够的。 例如，您正在编辑一个大文档，而同时您必须下载几个目录。 您什么时候叫保存？ 如果我们使用的是关系数据库，那么毫无疑问，因为每个操作都将在其自己的事务中执行。 核心数据还有一个非常方便的方法来解决此问题-这是子上下文的一个分支。 但不幸的是，由于某种原因，这种方式很少使用。 这里有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">一篇</a>关于该主题的好<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文章</a> 。 <br><br><h2> 传承 </h2><br> 由于某种原因，我不明白，有大量的手册和示例都没有使用Entity / NSManagedObject（表）的继承。 同时，这是一个非常方便的工具。 如果不使用继承，则只能通过KVC机制为属性（字段）分配值，该机制不检查属性的名称和类型，这很容易导致运行时错误。 <br><br>  NSManagedObject的类重新定义在Core Data设计器中完成： <br><br><img src="https://habrastorage.org/webt/ce/52/_p/ce52_pz39mzguhyiotm5rvhh00k.png" alt="图片"><br><br><h2> 继承和代码生成 </h2><br> 在为Entity指定类名之后，您可以使用代码生成并使用现成的代码获取一个类： <br><br><img src="https://habrastorage.org/webt/al/dn/7a/aldn7aozwsnv-l7sjv8vau4iwmi.png" alt="图片"><br><br><img src="https://habrastorage.org/webt/kj/ra/kh/kjrakhjgijvth5obsls22g6vtjk.png" alt="图片"><br><br> 如果要查看自动生成的代码，但不想将文件添加到项目中，则可以使用另一种方法：为Entity设置“ Codegen”选项。 在这种情况下，必须在../ DerivedData / ...中搜索代码。 <br><br><img src="https://habrastorage.org/webt/zg/vw/9e/zgvw9e3sulaf6g7qici-uitdsei.png" alt="图片"><br><br> 使用代码生成来创建类，变量名称中的拼写错误可能导致运行时错误。 <br><br> 这是一些这样的代码： <br><br><pre> <code class="objectivec hljs">@objc public <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Company: <span class="hljs-built_in"><span class="hljs-built_in">NSManagedObject</span></span> {    @<span class="hljs-built_in"><span class="hljs-built_in">NSManaged</span></span> public var inn: String?  @<span class="hljs-built_in"><span class="hljs-built_in">NSManaged</span></span> public var name: String?  @<span class="hljs-built_in"><span class="hljs-built_in">NSManaged</span></span> public var uid: String?  @<span class="hljs-built_in"><span class="hljs-built_in">NSManaged</span></span> public var employee: <span class="hljs-built_in"><span class="hljs-built_in">NSSet</span></span>? }</code> </pre><br> 快速地，@ NSManaged与Objective C中的dynamic具有相同的含义。 <br> 核心数据本身负责接收其类属性的数据（具有内部访问器）。 如果您有运输字段，则需要添加函数来计算它们。 <br><br> 与其他类不同，从IOS10之前继承自NSManagedObject（表）的类没有“常规”构造函数。 为了创建Company类型的对象，有必要使用NSEntityDescription编写一个笨拙的构造。 现在，有了通过上下文初始化的更方便的方法（NSManagedObjectContext）。 代码如下。 注意在通过KVC机制分配属性时继承的优点： <br><br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">// 1 -    NSEntityDescription,    KVO let company1 = NSEntityDescription.insertNewObject(forEntityName: "Company", into: moc) company1.setValue("077456789111", forKey: "inn") company1.setValue(" ", forKey: "name") // 2 -    NSEntityDescription,     let company2 = NSEntityDescription.insertNewObject(forEntityName: "Company", into: moc) as! Company company2.inn = "077456789222" company2.name = " " // 3 -     (IOS10+),     let company3 = Company(context: moc) company3.inn = "077456789222" company3.name = " "</span></span></code> </pre><br><h2>  NSManagedObject的命名空间 </h2><br> 值得一提的另一件事是名称空间。 <br><br><img src="https://habrastorage.org/webt/fk/a7/wl/fka7wlfqlf4cvi1ezcqst4kiiyi.png" alt="图片"><br><br> 如果您在ObjectiveC或Swift上工作，您将没有任何困难。 通常，默认情况下正确填写此字段。 但是在混合项目中，对于swift和ObjectiveC的类，您需要放下不同的选项，这可能会让您感到惊讶。 在Swift中，必须填写“模块”。 如果此字段未完成，则将带有项目名称的前缀添加到类名称，这将导致运行时错误。 在Objetive C中，将“模块”留空，否则在通过类名称访问它时将找不到NSManagedObject。 <br><br><h2> 对象之间的链接 </h2><br> 原则上，关系的主题涵盖了很多，但我想重点介绍如何将子实体添加到父实体。 因此，首先，快速提醒一下创建链接的机制。 考虑一个传统的例子，公司是员工，联系是一对多的： <br><br><ul><li> 在每侧（表）上创建连接 </li><li> 之后，“反向”字段变为可用，必须在每个表中将其填充。 </li></ul><br><img src="https://habrastorage.org/webt/_m/fx/si/_mfxsi_lcnxt8t3zlhh0vbrbsus.png" alt="图片"><br><br><img src="https://habrastorage.org/webt/kb/uo/my/kbuomy1etksutabvijrvxlztiyy.png" alt="图片"><br><br> 苹果公司坚持规定逆关系。 同时，反转并不能增强一致性，但是可以帮助Core Data跟踪连接两侧的变化，这对于缓存和更新信息非常重要。 <br><br> 正确指定删除规则也很重要。 删除规则是在删除父对象时将对此对象执行的操作。 <br><br><ul><li> 级联-删除所有父对象时删除所有子对象。 </li><li> 拒绝-禁止删除有孩子的父母 </li><li>  Nullify-使父引用无效 </li><li> 无动作-未指定任何动作，编译时会发出警告 </li></ul><br> 在此示例中，删除公司后，所有员工都将被删除（级联）。 删除员工后，公司中与该员工的链接将重置（预屏） <br><br><h2> 将子实体添加到父实体的方法 </h2><br>  <b>1）</b>第一种方法是通过NSSet添加。 例如，向公司添加2名员工： <br><br><pre> <code class="objectivec hljs">let set = <span class="hljs-built_in"><span class="hljs-built_in">NSMutableSet</span></span>();    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> let employee1 = <span class="hljs-built_in"><span class="hljs-built_in">NSEntityDescription</span></span>.insertNewObject(forEntityName: <span class="hljs-string"><span class="hljs-string">"Employee"</span></span>, into: moc) as? Employee { employee1.firstName = <span class="hljs-string"><span class="hljs-string">""</span></span> employee1.secondName = <span class="hljs-string"><span class="hljs-string">""</span></span> set.add(employee1) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> let emploee2 = <span class="hljs-built_in"><span class="hljs-built_in">NSEntityDescription</span></span>.insertNewObject(forEntityName: <span class="hljs-string"><span class="hljs-string">"Employee"</span></span>, into: moc) as? Employee { employee2.firstName = <span class="hljs-string"><span class="hljs-string">""</span></span> employee2.secondName = <span class="hljs-string"><span class="hljs-string">""</span></span> set.add(employee2) }    company.employee = set</code> </pre><br> 此方法便于初始化对象或填充数据库。 有细微差别。 如果公司已经有员工，并且您分配了新的员工，则以前的员工将重置与公司的链接，但不会删除它们。 或者，您可以获取员工列表，并已使用此集合进行工作。 <br><br><pre> <code class="objectivec hljs">let set = company.mutableSetValue(forKey: <span class="hljs-string"><span class="hljs-string">"employee"</span></span>)</code> </pre> <br>  <b>2）</b>通过父ID添加子对象 <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> let employee = <span class="hljs-built_in"><span class="hljs-built_in">NSEntityDescription</span></span>.insertNewObject(forEntityName: <span class="hljs-string"><span class="hljs-string">"Employee"</span></span>, into: moc) as? Employee { employee.firstName = <span class="hljs-string"><span class="hljs-string">""</span></span> employee.secondName = <span class="hljs-string"><span class="hljs-string">""</span></span> employee.company = company }</code> </pre><br> 第二种方法在添加或编辑子对象时很方便 <br> 单独的形式。 <br><br>  <b>3）</b>通过自动生成的方法添加子对象 <br><br><pre> <code class="objectivec hljs">extension Company {    @objc(addEmployeeObject:)  @<span class="hljs-built_in"><span class="hljs-built_in">NSManaged</span></span> public func addEmployee(_ value: Employee)    @objc(removeEmployeeObject:)  @<span class="hljs-built_in"><span class="hljs-built_in">NSManaged</span></span> public func removeFromEmployee(_ value: Employee)    @objc(addEmployee:)  @<span class="hljs-built_in"><span class="hljs-built_in">NSManaged</span></span> public func addEmployee(_ values: <span class="hljs-built_in"><span class="hljs-built_in">NSSet</span></span>)    @objc(removeEmployee:)  @<span class="hljs-built_in"><span class="hljs-built_in">NSManaged</span></span> public func removeFromEmployee(_ values: <span class="hljs-built_in"><span class="hljs-built_in">NSSet</span></span>) }</code> </pre><br> 为了完整起见，了解此方法很有用，但是以某种方式它对我没有用，因此我删除了多余的代码，以免使项目混乱。 <br><br><h2> 子句查询 </h2><br> 在核心数据中，您不能像在SQL中那样在任何数据之间进行任意查询。 但是在相关对象之间，使用标准谓词很容易进行跟踪。 下面是一个查询示例，该查询选择了所有拥有指定名称雇员的公司： <br><br><pre> <code class="objectivec hljs">public <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> func getCompanyWithEmployee(name: String) -&gt; [Company] { let request = <span class="hljs-built_in"><span class="hljs-built_in">NSFetchRequest</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">NSFetchRequestResult</span></span>&gt;(entityName: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.className()) request.predicate = <span class="hljs-built_in"><span class="hljs-built_in">NSPredicate</span></span>(format: <span class="hljs-string"><span class="hljs-string">"ANY employee.firstName = %@"</span></span>, name) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> let result = try moc.fetch(request) as? [Company] { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result } } catch { } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [Company]() }</code> </pre><br> 代码中的方法调用将如下所示： <br><br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">//  ,    let companies = Company.getCompanyWithEmployee(name: "")</span></span></code> </pre><br> 不要在查询中使用过渡字段；执行查询时未定义它们的值。 不会发生任何错误，但结果将不正确。 <br><br><h2> 设置属性（字段） </h2><br> 您可能已经注意到Entity属性具有多个选项。 <br> 通过可选，名称中的所有内容均清晰可见。 <br><br>  swif中显示了使用标量类型的选项。  Objective-C不会将标量类型用于属性，因为它们不能为nil。 尝试通过KVC为属性分配标量值将导致运行时错误。 这清楚地说明了为什么Core Data中的属性类型与语言类型没有严格的对应关系。 在快速项目和混合项目中，可以使用标量类型属性。 <br><br> 运输属性是<b>未</b>存储在数据库中的计算字段。 它们可以用于加密。 这些属性通过重写的访问器或根据需要分配基元来接收值（例如，重写的willSave和awakeFromFetch）。 <br><br><h2> 属性访问器： </h2><br> 例如，如果您不需要使用计算所得的字段进行加密或其他操作，则无需考虑附件的属性。 同时，获取和分配属性值的操作不是“原子的”。 要了解我的意思，请参见下面的代码： <br><br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">//  let name = company.name //  company.willAccessValue(forKey: "name") let name = company.primitiveValue(forKey: "name") company.didAccessValue(forKey: "name") //  company.name = " " //  company.willChangeValue(forKey: "name") company.setPrimitiveValue(" ", forKey: "name") company.didChangeValue(forKey: "name")</span></span></code> </pre><br> 在NSManagedObject事件中使用原语，而不是通常的分配，以避免循环。 一个例子： <br><br><pre> <code class="objectivec hljs">override func willSave() {   let nameP = encrypt(field: primitiveValue(forKey: <span class="hljs-string"><span class="hljs-string">"name"</span></span>), password: password)   setPrimitiveValue(nameP, forKey: <span class="hljs-string"><span class="hljs-string">"nameC"</span></span>)   <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.willSave() }  override func awakeFromFetch() {   let nameP = decrypt(field: primitiveValue(forKey: <span class="hljs-string"><span class="hljs-string">"nameC"</span></span>), password: password)   setPrimitiveValue(nameP, forKey: <span class="hljs-string"><span class="hljs-string">"name"</span></span>)   <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.awakeFromFetch() }</code> </pre><br> 如果突然某个时候您必须将awakeFromFetch函数拧入项目中，那么您会惊讶于它的工作原理很奇怪，但是实际上在执行请求时根本没有调用它。 这是由于Core Data具有非常智能的缓存机制，并且如果选择已经在内存中（例如，因为您刚刚填充了此表），则不会调用该方法。 但是，我的实验表明，就计算值而言，可以安全地依靠awakeFromFetch的使用，如Apple的文档所述。 如果要进行测试和开发，则需要强制awakeFromFetch，请在请求之前添加managedObjectContext.refreshAllObjects（）。 <br><br> 仅此而已。 <br><br> 感谢所有读完本书的人。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN436510/">https://habr.com/ru/post/zh-CN436510/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN436500/index.html">古墓丽影：崛起的框架如何呈现</a></li>
<li><a href="../zh-CN436502/index.html">订阅纵容或如何向相同的客户销售更多商品</a></li>
<li><a href="../zh-CN436504/index.html">系统级封装还是芯片封装下的封装？</a></li>
<li><a href="../zh-CN436506/index.html">如何轻松创建AI种族主义者</a></li>
<li><a href="../zh-CN436508/index.html">1000万美元的投资和沃兹尼亚克的赞誉-为儿童创造了一款教育计算机</a></li>
<li><a href="../zh-CN436512/index.html">我们如何找到Graphite和Moira的有问题的版本。 体验Yandex.Money</a></li>
<li><a href="../zh-CN436514/index.html">通过PHP为Instagram创建故事</a></li>
<li><a href="../zh-CN436518/index.html">Haikuβ1-使/ b / OS再次出色</a></li>
<li><a href="../zh-CN436520/index.html">泄漏个人数据时请勿使用在线验证服务</a></li>
<li><a href="../zh-CN436522/index.html">与指示相反</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>