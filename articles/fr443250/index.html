<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•í ü§± üôé Collecteur de d√©chets fait maison pour OpenJDK üë®üèª‚Äç‚öïÔ∏è üö§ ü§òüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Il s'agit d'une traduction de l'article d'Alexey Shipilev ¬´Faites-le vous-m√™me (OpenJDK) Garbage Collector¬ª , publi√© avec le consentement de l'auteur....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Collecteur de d√©chets fait maison pour OpenJDK</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/443250/"><blockquote>  Il s'agit d'une traduction de l'article d'Alexey Shipilev <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">¬´Faites-le vous-m√™me (OpenJDK) Garbage Collector¬ª</a> , publi√© avec le consentement de l'auteur.  Signalez toutes les fautes de frappe et autres bogues dans PM - nous les corrigerons. </blockquote><p>  Le processus de cr√©ation de quelque chose lors de l'ex√©cution est un exercice amusant.  Au moins la cr√©ation de la premi√®re version!  Construire un sous-syst√®me d'ex√©cution fiable, performant et √† s√©curit√© int√©gr√©e, dont le comportement peut √™tre facilement observ√© et d√©bogu√©, est une t√¢che tr√®s, tr√®s difficile. </p><br><p>  Faire un simple garbage collector est d'une simplicit√© trompeuse, et maintenant je veux le faire dans cet article.  Roman Kennke au FOSDEM 2019 a fait une pr√©sentation et une d√©mo intitul√©e <a href="">¬´√âcrire un GC en 20 minutes¬ª en</a> utilisant une version ant√©rieure de ce patch.  Malgr√© le fait que le code impl√©ment√© ici en d√©montre beaucoup et soit abondamment comment√©, il est n√©cessaire d'avoir une bonne description de haut niveau de ce qui se passe - c'est ainsi que cet article est apparu. </p><br><p>  Une compr√©hension de base du travail des ramasseurs d'ordures aidera grandement √† comprendre ce qui est √©crit ici.  L'article utilisera des d√©tails et des id√©es dans une impl√©mentation sp√©cifique de HotSpot, mais il n'y aura pas de cours d'introduction √† la conception de GC ici.  Prenez le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">manuel</a> du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GC</a> et lisez les premiers chapitres sur les bases du GC, et encore plus vite commencera <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">l'article Wikipedia</a> . </p><br><p><img src="https://habrastorage.org/webt/4v/1i/4y/4v1i4yrxpcef-vvvkknzfuhmt-w.jpeg"></p><a name="habracut"></a><br><h1 id="soderzhanie">  Table des mati√®res </h1><br><div class="spoiler">  <b class="spoiler_title">Texte masqu√©</b> <div class="spoiler_text"><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">1. En quoi consiste GC</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">1.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Epsilon gc</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">1.1.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Allocation de m√©moire</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">1.1.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Obstacles</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">1.1.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Surveillance de la connexion</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">1.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Rantime et GC</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">1.2.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">√âl√©ments racine</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">1.2.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Exploration d'objets</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">1.2.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">D√©placements</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">1.2.4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Donn√©es de marqueur</a> </li></ul></li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">2. Plan g√©n√©ral</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">3. Mise en ≈ìuvre du noyau du GC</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">3.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Prologue</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">3.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Marquage</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">3.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Calculer de nouvelles adresses</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">3.4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Correction des pointeurs</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">3.5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Nous d√©pla√ßons des objets</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">3.6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">√âpilogue</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">4. Connectez le GC √† la VM</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">4.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Travers√©e radiculaire</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">4.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Safepoints et arr√™ter le monde</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">4.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Erreurs d'allocation de m√©moire</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">5. Assembl√©e</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">6. Test</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">7. Performance</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">8. Et ensuite?</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">9. Conclusions</a> </li></ul></div></div><br><a name="1"></a><br><h1 id="1-iz-chego-sostoit-gc">  1. En quoi consiste GC </h1><br><p>  Maintenant que de nombreux GC diff√©rents ont √©t√© √©crits, il est assez simple de cr√©er les v√¥tres - de nombreux √©l√©ments d√©j√† √©crits peuvent √™tre (r√©) utilis√©s pour transf√©rer certaines des inqui√©tudes concernant les d√©tails d'impl√©mentation vers du code √©prouv√© et test√©. </p><br><a name="11"></a><br><h2 id="11-epsilon-gc">  1.1.  Epsilon gc </h2><br><p> OpenJDK 11 pr√©sente un nouveau JEP 318: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">"Epsilon: un garbage collector sans op√©ration (exp√©rimental)"</a> .  Sa t√¢che est de fournir une impl√©mentation minimale pour le cas o√π la lib√©ration de m√©moire n'est pas n√©cessaire ni m√™me interdite.  JEP explique plus en d√©tail pourquoi cela pourrait √™tre utile. </p><br><p>  Du point de vue de l'impl√©mentation, ¬´garbage collector¬ª est un mauvais nom, il serait plus correct d'utiliser le terme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">¬´gestionnaire de m√©moire automatique¬ª</a> , qui est responsable de l'allocation et de la lib√©ration de m√©moire.  Epsilon GC n'impl√©mente que ¬´l'allocation¬ª et ne traite pas du tout de la ¬´lib√©ration¬ª.  Par cons√©quent, vous pouvez prendre Epsilon GC et commencer √† impl√©menter les algorithmes de ¬´lib√©ration¬ª √† partir de z√©ro. </p><br><a name="111"></a><br><h3 id="111-vydelenie-pamyati">  1.1.1.  Allocation de m√©moire </h3><br><p>  La partie la plus d√©velopp√©e du GC Epsilon <a href="">est responsable de l'allocation de m√©moire</a> .  Il sert des demandes externes pour allouer de la m√©moire de taille arbitraire et cr√©er un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">tampon d'allocation de thread local (TLAB) de la</a> taille souhait√©e.  L'impl√©mentation elle-m√™me essaie de ne pas trop √©tendre le TLAB, car il n'y aura pas de m√©moire libre et personne ne renverra les octets perdus. </p><br><a name="112"></a><br><h3 id="112-barery">  1.1.2.  Obstacles </h3><br><p>  Certains garbage collector n√©cessitent une interaction avec l'application pour maintenir les invariants GC, for√ßant le runtime et l'application √† cr√©er des soi-disant <em>barri√®res</em> lorsqu'ils tentent d'acc√©der au tas.  Cela est vrai pour tous les collectionneurs multi-threads, ainsi que pour de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">nombreux collectionneurs de g√©n√©rations</a> et d'arr√™t du monde. </p><br><p>  Epsilon ne n√©cessite pas de barri√®res, mais le runtime et le compilateur veulent toujours <em>savoir</em> que les barri√®res ne font rien.  Le manipuler √† chaque fois partout peut √™tre fatigant.  Heureusement, √† partir d'OpenJDK 11, il existe un nouveau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">JEP-304: ¬´Interface de collecte des ordures¬ª</a> , ce qui facilite consid√©rablement l'insertion des barri√®res.  En particulier, la <a href="">barri√®re d√©finie dans Epsilon est vide</a> et tout le travail trivial - sauvegarde, chargement, CAS, copie sur tableau - peut √™tre d√©l√©gu√© aux impl√©mentations de barri√®res triviales √† partir d'une superclasse existante.  Si vous cr√©ez un GC qui n'a pas non plus besoin de barri√®res, vous pouvez simplement r√©utiliser le code d'Epsilon. </p><br><a name="113"></a><br><h3 id="113-podklyuchenie-k-monitoringu">  1.1.3.  Surveillance de la connexion </h3><br><p>  La derni√®re partie fastidieuse de la mise en ≈ìuvre du GC est li√©e √† un tas de m√©canismes de surveillance √† l'int√©rieur de la JVM: les bacs MX, les commandes de diagnostic, etc. devraient fonctionner.  Epsilon <a href="">a d√©j√† fait</a> tout cela pour vous. </p><br><a name="12"></a><br><h2 id="12-rantaym-i-gc">  1.2.  Rantime et GC </h2><br><a name="121"></a><br><h3 id="121-kornevye-elementy">  1.2.1.  √âl√©ments racine </h3><br><p>  Le garbage collector, dans le cas g√©n√©ral, a besoin de savoir exactement ce qui dans le runtime Java a des r√©f√©rences de tas.  Ces √©l√©ments racine, appel√©s <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">racines GC</a> , peuvent √™tre des emplacements sur des piles de flux et des variables locales (y compris celles trouv√©es dans le code compil√© JIT!), Des classes natives et des chargeurs de classe, des r√©f√©rences dans JNI, etc.  Les tentatives d'identification de ces √©l√©ments peuvent √™tre tr√®s complexes et fastidieuses.  Mais dans Hotspot, ils sont tous suivis √† l'aide des sous-syst√®mes VM appropri√©s, vous pouvez donc simplement apprendre comment les impl√©mentations GC existantes fonctionnent avec eux.  Plus loin dans le texte, nous le verrons. </p><br><a name="122"></a><br><h3 id="122-obhod-obektov">  1.2.2.  Exploration d'objets </h3><br><p> Le garbage collector doit contourner les liens sortants dans les objets Java.  Cette op√©ration se trouve partout, de sorte que les parties communes de l'ex√©cution fournissent des solutions de contournement toutes faites; vous n'avez pas besoin d'√©crire quoi que ce soit vous-m√™me.  Ci-dessous, il y aura une section avec une impl√©mentation sp√©cifique, et vous y trouverez, par exemple, les appels <code>obj‚Üíoop_iterate</code> . </p><br><a name="123"></a><br><h3 id="123-peremescheniya">  1.2.3.  D√©placements </h3><br><p>  Le ramasse-miettes en mouvement doit noter quelque part les nouvelles adresses des objets d√©plac√©s.  Il existe plusieurs endroits o√π vous pouvez √©crire ces <em>donn√©es de transfert</em> . </p><br><ol><li>  Vous pouvez r√©utiliser le <a href="">¬´mot marqueur¬ª dans l'objet lui-m√™me</a> (s√©rie, parall√®le, etc.).  Une fois le monde arr√™t√©, tous les acc√®s √† l'objet sont contr√¥l√©s et il est garanti qu'aucun thread Java ne peut voir les donn√©es temporaires que nous avons d√©cid√© d'entrer dans le mot marqueur.  Vous pouvez le r√©utiliser pour stocker des donn√©es de transfert. </li><li>  Vous pouvez g√©rer une table de mouvement native distincte ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ZGC</a> , C4 et autres).  Cela isole compl√®tement le GC du runtime et du reste de l'application, car seul le GC conna√Æt l'existence d'une telle table.  Les assembleurs comp√©titifs utilisent g√©n√©ralement un tel sch√©ma - ils ne veulent pas souffrir d'un tas de probl√®mes inutiles. </li><li>  Vous pouvez ajouter un autre mot √† l'objet ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Shenandoah</a> et autres).  Cette combinaison des deux approches pr√©c√©dentes permet non seulement au runtime et √† l'application de fonctionner sans probl√®me avec les en-t√™tes existants, mais enregistre √©galement les donn√©es de transfert. </li></ol><br><a name="124"></a><br><h3 id="124-markernye-dannye">  1.2.4.  Donn√©es de marqueur </h3><br><p>  Le garbage collector doit √©crire des <em>donn√©es de marquage</em> quelque part.  Et encore une fois, il existe plusieurs fa√ßons de les enregistrer: </p><br><ol><li>  Vous pouvez r√©utiliser le mot marqueur dans l'objet lui-m√™me (s√©rie, parall√®le, etc.).  Encore une fois, en mode d'arr√™t mondial, vous pouvez utiliser les bits du mot marqueur pour coder le fait d'une √©tiquette.  De plus, si vous avez besoin de faire le tour de tous les objets vivants, nous <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">suivons</a> le tas, objet apr√®s objet - cela est possible car le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">tas est analysable</a> . </li><li>  Vous pouvez g√©rer une structure distincte pour le stockage des donn√©es de marquage (G1, Shenandoah, etc.).  Cela se fait g√©n√©ralement √† l'aide d'un <a href="">bitmap distinct</a> , qui mappe tous les N octets du tas sur 1 bit de la carte.  Habituellement, les objets Java sont <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">align√©s sur 8 octets</a> , de sorte que la carte mappe tous les 64 bits du tas √† 1 bit de la carte, occupant 1/64 de la taille du tas dans la m√©moire native.  Ces frais g√©n√©raux sont payants lors de l'analyse du tas pour la pr√©sence d'objets vivants, en particulier clairsem√©s: le contournement de la carte est souvent beaucoup plus rapide que le contournement du tas d√©sassembl√© objet par objet. </li><li>  Encodez les √©tiquettes en liens eux-m√™mes (ZGC, C4 et autres).  Cela n√©cessite une coordination avec l'application, puis vous devez couper toutes ces √©tiquettes des liens ou effectuer d'autres astuces pour maintenir l'exactitude.  En d'autres termes, nous avons besoin de barri√®res ou de travaux suppl√©mentaires de la part du GC. </li></ol><br><a name="2"></a><br><h1 id="2-obschiy-plan">  2. Plan g√©n√©ral </h1><br><p>  Tr√®s probablement, le plus facile √† impl√©menter au-dessus d'Epsilon est le Mark-Compact, dans le style LISP2.  L'id√©e de base de ce GC est d√©crite √† la fois <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sur Wikipedia</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dans le Manuel du GC</a> (chapitre 3.2).  Un croquis de l'algorithme sera dans la section avec l'impl√©mentation ci-dessous, mais je recommande fortement de lire un peu Wikipedia ou le manuel du GC pour comprendre ce que nous allons faire. </p><br><p>  L'algorithme en question est le GC <em>d√©cal√©</em> : les objets en mouvement se d√©placent dans un tableau au tout d√©but du tas.  Il a ses avantages et ses inconv√©nients: </p><br><ul><li>  Il maintient l'ordre des allocations de m√©moire.  C'est tr√®s bien pour contr√¥ler la mise en page en m√©moire, si cela vous int√©resse (contr√¥lez les monstres, c'est votre temps!).  L'inconv√©nient est que vous n'obtiendrez pas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la localit√© de lien automatique de</a> cette fa√ßon. </li><li>  Sa complexit√© est O (N) du nombre d'objets.  Cependant, la lin√©arit√© a un prix: GC doit contourner un tas de 4 fois pour chaque cycle de construction. </li><li>  Il ne n√©cessite pas de m√©moire libre sur le tas!  Il n'est pas n√©cessaire de r√©server de la m√©moire sur le tas pour √©vacuer les objets vivants, vous pouvez donc m√™me travailler avec un tas d√©bord√© de 99. (9)%.  Si nous adoptons d'autres id√©es de simples collectionneurs, par exemple un charognard avec un semi-espace (charognard semi-spatial), nous devrons r√©√©crire l√©g√®rement la pr√©sentation du tas et r√©server un peu d'espace pour l'√©vacuation, mais cela d√©passe le cadre de cet exercice. </li><li>  Si vous travaillez un peu sur le probl√®me, vous pouvez atteindre z√©ro consommation de m√©moire et de temps pendant les p√©riodes o√π le CPG est inactif.  Il d√©marre sur une m√©moire dans un √©tat arbitraire et s'arr√™te, le compactant de mani√®re significative.  Cela correspond tr√®s bien au fonctionnement d'Epsilon: il ne fait que surligner juste apr√®s le dernier objet.  C'est aussi un inconv√©nient: quelques objets morts au d√©but du tas entra√Ænent un grand nombre de mouvements. </li><li>  Il ne n√©cessite tout simplement pas de nouvelles barri√®res, vous pouvez r√©utiliser <code>EpsilonBarrierSet</code> tel <code>EpsilonBarrierSet</code> . </li></ul><br><p>  Par souci de simplicit√©, l'impl√©mentation GC utilisera un arr√™t complet du monde (stop-the-world, STW), elle n'aura pas de g√©n√©rations ni de multithreading.  Dans ce cas, il est judicieux d'utiliser une image bitmap pour stocker les marques et r√©utiliser le mot marqueur pour stocker les donn√©es de mouvement. </p><br><a name="3"></a><br><h1 id="3-realizaciya-yadra-gc">  3. Mise en ≈ìuvre du noyau du GC </h1><br><p>  Lire et comprendre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">toute la mise en ≈ìuvre</a> peut √™tre trop compliqu√© pour une personne ignorante.  Dans cette section, nous allons le comprendre √©tape par √©tape. </p><br><a name="31"></a><br><h2 id="31-prolog">  3.1.  Prologue </h2><br><p>  Le ramasse-miettes doit g√©n√©ralement faire deux ou trois choses pour pr√©parer la collecte.  Lisez les commentaires, ils devraient parler d'eux-m√™mes: </p><br><pre> <code class="cpp hljs">{ GCTraceTime(Info, gc) time(<span class="hljs-string"><span class="hljs-string">"Step 0: Prologue"</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-comment"><span class="hljs-comment">//      .      //   :   ,   ,  // ¬´¬ª   ,      //   ,     . if (!os::commit_memory((char*)_bitmap_region.start(), _bitmap_region.byte_size(), false)) { log_warning(gc)("Could not commit native memory for marking bitmap, GC failed"); return; } //        ,  , //       TLAB-. ensure_parsability(true); //      ,    GC. CodeCache::gc_prologue(); BiasedLocking::preserve_marks(); //        . //       . DerivedPointerTable::clear(); }</span></span></code> </pre> <br><p>  √âtant donn√© que nous utilisons un bitmap pour suivre l'accessibilit√© des objets, nous devons l'effacer avant utilisation.  Ou dans notre cas, puisque nous visons √† ne jamais demander de ressources avant de d√©marrer le cycle GC, nous devrons <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">valider la bitmap en m√©moire √† l'</a> avance.  Cela offre plusieurs avantages int√©ressants, au moins sous Linux, o√π la plupart du bitmap pointera vers la page z√©ro, en particulier pour les tas clairsem√©s. </p><br><p>  Les threads doivent lib√©rer leurs TLAB et en demander de nouveaux au GC une fois la construction termin√©e. </p><br><blockquote>  Ne confondez pas TLAB et <code>java.lang.ThreadLocal</code> .  Du point de vue du GC, ThreadLocal sont des objets ordinaires, et ils ne seront pas compil√©s par le GC sauf indication contraire dans le code Java. </blockquote><p>  Certaines parties de l'ex√©cution, en particulier celles qui contiennent des liens vers le tas Java, se briseront lors de la r√©cup√©ration de place, vous devez donc les avertir sp√©cifiquement que le GC commencera bient√¥t √† fonctionner.  Cela permettra aux sous-syst√®mes respectifs de pr√©parer et d'enregistrer une partie de leur √©tat avant que le GC ne se d√©place. </p><br><a name="32"></a><br><h2 id="32-markirovka">  3.2.  Marquage </h2><br><p>  Marquer en mode stop du monde devient assez simple quand presque tout a d√©j√† √©t√© fait pour nous.  L'√©tiquetage est assez standard, et tr√®s probablement, dans de nombreuses impl√©mentations, GC est la premi√®re √©tape. </p><br><pre> <code class="cpp hljs">{ GCTraceTime(Info, gc) time(<span class="hljs-string"><span class="hljs-string">"Step 1: Mark"</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    ,     .  //   ,  ,    //      . EpsilonMarkStack stack; EpsilonScanOopClosure cl(&amp;stack, &amp;_bitmap); //      . process_roots(&amp;cl); stat_reachable_roots = stack.size(); //    ,    . //    ,   , //      . while (!stack.is_empty()) { oop obj = stack.pop(); obj-&gt;oop_iterate(&amp;cl); stat_reachable_heap++; } //       . DerivedPointerTable::set_active(false); }</span></span></code> </pre> <br><p>  Cela fonctionne exactement de la m√™me mani√®re que pour tout autre graphique: vous commencez la travers√©e avec l'ensemble initial de sommets accessibles, longez les bords sortants et enregistrez tous les sommets visit√©s.  La travers√©e continue jusqu'√† la fin de tous les pics non visit√©s.  Dans GC, les ¬´sommets¬ª sont des objets et les ¬´ar√™tes¬ª sont des liens entre eux. </p><br><p>  Techniquement, nous pourrions simplement parcourir r√©cursivement le graphe des objets, mais c'est une mauvaise id√©e pour les graphes arbitraires qui peuvent avoir de tr√®s grands diam√®tres.  Imaginez une liste cha√Æn√©e d'un milliard de pics!  Par cons√©quent, pour limiter la profondeur de r√©cursivit√©, nous utilisons une pile de marquage qui enregistre les objets d√©tect√©s. </p><br><p>  L'ensemble initial d'objets accessibles est les racines GC.  Maintenant, ne vous attardez pas sur ce qu'est <code>process_roots</code> , plus sur cela plus tard.  Pour l'instant, disons simplement qu'il contourne tous les liens accessibles du c√¥t√© VM. </p><br><p>  Une image bitmap avec des marques sert √† la fois d'outil pour enregistrer le <em>front d'onde de marquage</em> (beaucoup d'objets d√©j√† visit√©s) et au final - comme r√©f√©rentiel du r√©sultat souhait√©, un ensemble de tous les objets accessibles.  Le vrai travail se d√©roule dans <code>EpsilonScanOopClosure</code> , il est appliqu√© √† tous les objets int√©ressants et it√©r√© sur tous les liens de l'objet s√©lectionn√©. </p><br><blockquote>  Regardez, Java a su <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fermer (fermer)</a> avant de devenir √† la mode! </blockquote><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EpsilonScanOopClosure</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> BasicOopIterateClosure { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: EpsilonMarkStack* <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> _stack; MarkBitMap* <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> _bitmap; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">do_oop_work</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">p</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-comment"><span class="hljs-comment">// p -     ,   oop,   //      ,  : T o = RawAccess&lt;&gt;::oop_load(p); if (!CompressedOops::is_null(o)) { oop obj = CompressedOops::decode_not_null(o); //  . ,   .  , //        . //    +, //       . if (!_bitmap-&gt;is_marked(obj)) { _bitmap-&gt;mark((HeapWord*)obj); _stack-&gt;push(obj); } } } };</span></span></code> </pre> <br><p>  Une fois cette √©tape <code>_bitmap</code> , <code>_bitmap</code> contient des bits indiquant l'emplacement des objets <code>_bitmap</code> .  Gr√¢ce √† cela, il est possible de contourner tous les objets vivants, par exemple: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//           . //   ,    ( )  ,  //       1/64  . void EpsilonHeap::walk_bitmap(ObjectClosure* cl) { HeapWord* limit = _space-&gt;top(); HeapWord* addr = _bitmap.get_next_marked_addr(_space-&gt;bottom(), limit); while (addr &lt; limit) { oop obj = oop(addr); assert(_bitmap.is_marked(obj), "sanity"); cl-&gt;do_object(obj); addr += 1; if (addr &lt; limit) { addr = _bitmap.get_next_marked_addr(addr, limit); } } }</span></span></code> </pre> <br><a name="33"></a><br><h2 id="33-vychislyaem-novye-adresa">  3.3.  Calculer de nouvelles adresses </h2><br><p>  C'est √©galement une √©tape assez simple, et elle met en ≈ìuvre exactement ce que dit l'algorithme. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/ab3/406/5e6/ab34065e6397d39413057358b45247a3.jpg"></p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    forwarding data (,    ) //   .        . //          . PreservedMarks preserved_marks; //     GC. HeapWord* new_top; { GCTraceTime(Info, gc) time("Step 2: Calculate new locations", NULL); //    ,        //    . ,  - . EpsilonCalcNewLocationObjectClosure cl(_space-&gt;bottom(), &amp;preserved_marks); walk_bitmap(&amp;cl); //         . //       ,    //      ,      "" //  . new_top = cl.compact_point(); stat_preserved_marks = preserved_marks.size(); }</span></span></code> </pre> <br><p>  La seule chose qui attire votre attention, c'est que nous avons d√©cid√© de stocker de nouvelles adresses dans le mot de marquage des objets Java, et ce mot peut d√©j√† √™tre occup√© par quelque chose d'important, par exemple, des informations sur les verrous.  Heureusement, de tels mots de marquage non triviaux sont assez rares, et nous pouvons simplement les stocker s√©par√©ment, si cela est n√©cessaire: c'est pour cela que <code>PreservedMarks</code> utilis√©. </p><br><p>  Le vrai travail algorithmique est effectu√© par <code>EpsilonCalcNewLocationObjectClosure</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EpsilonCalcNewLocationObjectClosure</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ObjectClosure { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: HeapWord* _compact_point; PreservedMarks* <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> _preserved_marks; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: EpsilonCalcNewLocationObjectClosure(HeapWord* start, PreservedMarks* pm) : _compact_point(start), _preserved_marks(pm) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_object</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(oop obj)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    :    . //        (      , //    ),      , //     . if ((HeapWord*)obj != _compact_point) { markOop mark = obj-&gt;mark_raw(); if (mark-&gt;must_be_preserved(obj)) { _preserved_marks-&gt;push(obj, mark); } obj-&gt;forward_to(oop(_compact_point)); } _compact_point += obj-&gt;size(); } HeapWord* compact_point() { return _compact_point; } };</span></span></code> </pre> <br><p>  <code>forward_to</code> est la partie la plus importante car elle stocke "l'adresse de d√©placement" dans le mot marqueur de l'objet.  Cela sera n√©cessaire dans les prochaines √©tapes. </p><br><a name="34"></a><br><h2 id="34-ispravlyaem-ukazateli">  3.4.  Correction des pointeurs </h2><br><p>  Vous devez maintenant parcourir √† nouveau le tas et r√©√©crire tous les liens avec leurs nouvelles adresses selon l'algorithme suivant: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/25f/c82/1dc/25fc821dc95d2f9d50fe40653eb845ff.jpg"></p><br><pre> <code class="cpp hljs">{ GCTraceTime(Info, gc) time(<span class="hljs-string"><span class="hljs-string">"Step 3: Adjust pointers"</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-comment"><span class="hljs-comment">//     _   _,     // ¬´ ¬ª.      forwarding data, //    .      . EpsilonAdjustPointersObjectClosure cl; walk_bitmap(&amp;cl); //     ,      VM,  //     :      . EpsilonAdjustPointersOopClosure cli; process_roots(&amp;cli); //   ,      , //     . preserved_marks.adjust_during_full_gc(); }</span></span></code> </pre> <br><p>  Il existe deux types de r√©f√©rences aux objets d√©plac√©s: sortant soit des objets sur le tas lui-m√™me, soit des racines GC.  Vous devez mettre √† jour les deux classes de liens.  Certaines √©tiquettes enregistr√©es stockent √©galement des r√©f√©rences aux objets, vous devez donc leur demander de mettre √† jour.  <code>PreservedMarks</code> sait comment faire cela car il attend des ¬´donn√©es de transfert¬ª au m√™me endroit o√π nous les avons enregistr√©es, dans le mot de marquage de l'objet. </p><br><p>  Les fermetures sont divis√©es en deux types: certaines prennent des objets et contournent leur contenu, d'autres mettent √† jour ces adresses.  Ici, vous pouvez faire une petite optimisation des performances: si l'objet ne bouge pas, vous pouvez enregistrer quelques enregistrements dans un groupe: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EpsilonAdjustPointersOopClosure</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> BasicOopIterateClosure { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">do_oop_work</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">p</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-comment"><span class="hljs-comment">// p -     ,   oop. //        ,  : T o = RawAccess&lt;&gt;::oop_load(p); if (!CompressedOops::is_null(o)) { oop obj = CompressedOops::decode_not_null(o); //         . //  ,    . if (obj-&gt;is_forwarded()) { oop fwd = obj-&gt;forwardee(); assert(fwd != NULL, "just checking"); RawAccess&lt;&gt;::oop_store(p, fwd); } } } }; class EpsilonAdjustPointersObjectClosure : public ObjectClosure { private: EpsilonAdjustPointersOopClosure _cl; public: void do_object(oop obj) { //    ,    : obj-&gt;oop_iterate(&amp;_cl); } };</span></span></code> </pre> <br><p>  Apr√®s avoir termin√© cette √©tape, nous avons essentiellement cass√© le tas: les liens pointent vers les ¬´mauvaises¬ª adresses auxquelles les objets ne se trouvent pas encore.  Corrigeons-le! </p><br><a name="35"></a><br><h2 id="35-dvigaem-obekty">  3.5.  Nous d√©pla√ßons des objets </h2><br><p>  Temps pour d√©placer des objets vers de nouvelles adresses, conform√©ment √† l'algorithme: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/01c/5b8/db8/01c5b8db85781c82b89bbed730c8aecc.jpg"></p><br><p>  <code>EpsilonMoveObjectsObjectClosure</code> nouveau le tour des tas et appliquez la fermeture <code>EpsilonMoveObjectsObjectClosure</code> √† tous les objets vivants: </p><br><pre> <code class="cpp hljs">{ GCTraceTime(Info, gc) time(<span class="hljs-string"><span class="hljs-string">"Step 4: Move objects"</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-comment"><span class="hljs-comment">//       . //          . EpsilonMoveObjectsObjectClosure cl; walk_bitmap(&amp;cl); stat_moved = cl.moved(); //         ,   // ¬´¬ª      . _space-&gt;set_top(new_top); }</span></span></code> </pre> <br><p>  Imm√©diatement apr√®s cela, vous pouvez faire glisser le tas du tas de points de compactage, ce qui permet d'allouer de la m√©moire directement √† partir de cet emplacement, imm√©diatement apr√®s la fin du cycle de r√©cup√©ration de place. </p><br><p>  Notez que dans l'assemblage de d√©calage, nous pouvons √©craser le contenu des objets existants, mais comme la num√©risation va dans le m√™me sens, les objets √©cras√©s sont d√©j√† copi√©s au bon endroit. </p><br><blockquote>  L'ancien et le nouvel emplacement de la m√™me installation peuvent se croiser.  Par exemple, si vous d√©calez un objet de 100 octets de 8 octets.  La proc√©dure de copie doit fonctionner par elle-m√™me, et le contenu se croisant doit √™tre copi√© correctement, faites attention √† <code>Copy::aligned_*conjoint*_words</code> . </blockquote><p>  La fermeture elle-m√™me d√©placera simplement les objets d√©plac√©s vers les nouvelles adresses: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EpsilonMoveObjectsObjectClosure</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ObjectClosure { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_object</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(oop obj)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//     ,  .   - , //   -  mark word, //      forwarding data. if (obj-&gt;is_forwarded()) { oop fwd = obj-&gt;forwardee(); assert(fwd != NULL, "just checking"); Copy::aligned_conjoint_words((HeapWord*)obj, (HeapWord*)fwd, obj-&gt;size()); fwd-&gt;init_mark_raw(); } } };</span></span></code> </pre> <br><a name="36"></a><br><h2 id="36-epilog">  3.6.  √âpilogue </h2><br><p>  La collecte des ordures est termin√©e, le tas est √† nouveau presque coh√©rent, les derni√®res touches sont laiss√©es: </p><br><pre> <code class="cpp hljs">{ GCTraceTime(Info, gc) time(<span class="hljs-string"><span class="hljs-string">"Step 5: Epilogue"</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    . preserved_marks.restore(); //   ,    . DerivedPointerTable::update_pointers(); BiasedLocking::restore_marks(); CodeCache::gc_epilogue(); JvmtiExport::gc_epilogue(); //     . if (!os::uncommit_memory((char*)_bitmap_region.start(), _bitmap_region.byte_size())) { log_warning(gc)("Could not uncommit native memory for marking bitmap"); } //    ,  . //        . if (EpsilonUncommit) { _virtual_space.shrink_by((_space-&gt;end() - new_top) * HeapWordSize); _space-&gt;set_end((HeapWord*)_virtual_space.high()); } }</span></span></code> </pre> <br><p>  Nous informons le reste du runtime qu'ils doivent d√©marrer les proc√©dures de post-assemblage.  Nous restaurons les mots marqueurs sp√©ciaux que nous avons enregistr√©s pr√©c√©demment.  Adieu bisous √† notre carte marqueur - elle n'est plus n√©cessaire. </p><br><p>  Et, si vous le voulez vraiment, vous pouvez r√©duire la m√©moire pour les allocations √† une nouvelle taille, retournant ainsi la m√©moire au syst√®me d'exploitation! </p><br><a name="4"></a><br><h1 id="4-podklyuchaem-gc-k-vm">  4. Connectez le GC √† la VM </h1><br><a name="41"></a><br><h2 id="41-obhod-kornevyh-elementov">  4.1.  Travers√©e radiculaire </h2><br><p>  Rappelez-vous, vous devez contourner les liens sp√©ciaux accessibles de VM?  Vous pouvez demander √† chaque sous-syst√®me VM sp√©cial de contourner les liens cach√©s des autres objets Java.  Une liste exhaustive de ces √©l√©ments racine dans le Hotspot actuel ressemble √† ceci: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> EpsilonHeap::do_roots(OopClosure* cl) { <span class="hljs-comment"><span class="hljs-comment">//   ,        1 . StrongRootsScope scope(1); //         . CLDToOopClosure clds(cl, ClassLoaderData::_claim_none); MarkingCodeBlobClosure blobs(cl, CodeBlobToOopClosure::FixRelocations); //      . //        . { MutexLockerEx lock(CodeCache_lock, Mutex::_no_safepoint_check_flag); CodeCache::blobs_do(&amp;blobs); } { MutexLockerEx lock(ClassLoaderDataGraph_lock); ClassLoaderDataGraph::cld_do(&amp;clds); } Universe::oops_do(cl); Management::oops_do(cl); JvmtiExport::oops_do(cl); JNIHandles::oops_do(cl); WeakProcessor::oops_do(cl); ObjectSynchronizer::oops_do(cl); SystemDictionary::oops_do(cl); Threads::possibly_parallel_oops_do(false, cl, &amp;blobs); }</span></span></code> </pre> <br><p>  ,        .    GC    . </p><br><a name="42"></a><br><h2 id="42-seyfpointy-i-ostanovka-mira">  4.2.     </h2><br><p>   GC     ,   VM      .  Hotspot     <code>VM_Operation</code> ,     GC    VM-  : </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// VM_operation,      class VM_EpsilonCollect: public VM_Operation { private: const GCCause::Cause _cause; EpsilonHeap* const _heap; static size_t _last_used; public: VM_EpsilonCollect(GCCause::Cause cause) : VM_Operation(), _cause(cause), _heap(EpsilonHeap::heap()) {}; VM_Operation::VMOp_Type type() const { return VMOp_EpsilonCollect; } const char* name() const { return "Epsilon Collection"; } virtual bool doit_prologue() { //     ,     . //         GC, //          . //   ,         //  .     , //       1%, ,  , //     . Heap_lock-&gt;lock(); size_t used = _heap-&gt;used(); size_t capacity = _heap-&gt;capacity(); size_t allocated = used &gt; _last_used ? used - _last_used : 0; if (_cause != GCCause::_allocation_failure || allocated &gt; capacity / 100) { return true; } else { Heap_lock-&gt;unlock(); return false; } } virtual void doit() { _heap-&gt;entry_collect(_cause); } virtual void doit_epilogue() { _last_used = _heap-&gt;used(); Heap_lock-&gt;unlock(); } }; size_t VM_EpsilonCollect::_last_used = 0; void EpsilonHeap::vmentry_collect(GCCause::Cause cause) { VM_EpsilonCollect vmop(cause); VMThread::execute(&amp;vmop); }</span></span></code> </pre> <br><p>       ,       GC ‚Äî    ,     . </p><br><a name="43"></a><br><h2 id="43-oshibki-vydeleniya-pamyati">  4.3.    </h2><br><p> ,     GC  ,   ,  GC    ,     .   ,      <code>allocate_work</code>     ,   GC     : </p><br><pre> <code class="cpp hljs">HeapWord* EpsilonHeap::allocate_or_collect_work(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> size) { HeapWord* res = allocate_work(size); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (res == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> &amp;&amp; EpsilonSlidingGC) { vmentry_collect(GCCause::_allocation_failure); res = allocate_work(size); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; }</code> </pre> <br><p>   ! </p><br><a name="5"></a><br><h1 id="5-sborka"> 5.  </h1><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a>        OpenJDK. </p><br><pre> <code class="bash hljs">$ hg <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> https://hg.openjdk.java.net/jdk/jdk/ jdk-jdk $ <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> jdk-jdk $ curl https://shipilev.net/jvm/diy-gc/webrev/jdk-jdk-epsilon.changeset | patch -p1</code> </pre> <br><p>     OpenJDK  : </p><br><pre> <code class="bash hljs">$ ./configure --with-debug-level=fastdebug $ make images</code> </pre> <br><p>    : </p><br><pre> <code class="bash hljs">$ build/linux-x86_64-server-fastdebug/images/jdk/bin/java -XX:+UnlockExperimentalVMOptions -XX:+UseEpsilonGC -XX:+EpsilonSlidingGC -version openjdk version <span class="hljs-string"><span class="hljs-string">"13-internal"</span></span> 2019-09-17 OpenJDK Runtime Environment (build 13-internal+0-adhoc.shade.jdk-jdk-epsilon) OpenJDK 64-Bit Server VM (build 13-internal+0-adhoc.shade.jdk-jdk-epsilon, mixed mode, sharing</code> </pre> <br><a name="6"></a><br><h1 id="6-testirovanie"> 6.  </h1><br><p>  ,    GC  ?    : </p><br><ol><li> .  .   Hotspot    ,   JVM   <em>fastdebug</em>        ,        GC. </li><li>  .        ,          . ,        ( )   ,          . </li><li>  Tests.    ,  ,   ,   .     -   ,        . </li></ol><br><p> ,    ,       : </p><br><pre> <code class="plaintext hljs">$ CONF=linux-x86_64-server-fastdebug make images run-test TEST=gc/epsilon/ Building targets 'images run-test' in configuration 'linux-x86_64-server-fastdebug' Test selection 'gc/epsilon/', will run: * jtreg:test/hotspot/jtreg/gc/epsilon Running test 'jtreg:test/hotspot/jtreg/gc/epsilon' Passed: gc/epsilon/TestAlwaysPretouch.java Passed: gc/epsilon/TestAlignment.java Passed: gc/epsilon/TestElasticTLAB.java Passed: gc/epsilon/TestEpsilonEnabled.java Passed: gc/epsilon/TestHelloWorld.java Passed: gc/epsilon/TestLogTrace.java Passed: gc/epsilon/TestDieDefault.java Passed: gc/epsilon/TestDieWithOnError.java Passed: gc/epsilon/TestMemoryPools.java Passed: gc/epsilon/TestMaxTLAB.java Passed: gc/epsilon/TestPrintHeapSteps.java Passed: gc/epsilon/TestArraycopyCheckcast.java Passed: gc/epsilon/TestClasses.java Passed: gc/epsilon/TestUpdateCountersSteps.java Passed: gc/epsilon/TestDieWithHeapDump.java Passed: gc/epsilon/TestByteArrays.java Passed: gc/epsilon/TestManyThreads.java Passed: gc/epsilon/TestRefArrays.java Passed: gc/epsilon/TestObjects.java Passed: gc/epsilon/TestElasticTLABDecay.java Passed: gc/epsilon/TestSlidingGC.java Test results: passed: 21 TEST SUCCESS</code> </pre> <br><p> ?       <em>fastdebug</em>    .  ?    - . </p><br><a name="7"></a><br><h1 id="7-proizvoditelnost"> 7.  </h1><br><p> -  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">spring-petclinic</a> ,  Apache Bench     GC!        ,  ,     GC . </p><br><p>    : <code>-Xlog:gc -XX:+UnlockExperimentalVMOptions -XX:+UseEpsilonGC -XX:+EpsilonSlidingGC</code> : </p><br><p> : </p><br><pre> <code class="plaintext hljs">Heap: 20480M reserved, 20480M (100.00%) committed, 19497M (95.20%) used GC(2) Step 0: Prologue 2.085ms GC(2) Step 1: Mark 51.005ms GC(2) Step 2: Calculate new locations 71.207ms GC(2) Step 3: Adjust pointers 49.671ms GC(2) Step 4: Move objects 22.839ms GC(2) Step 5: Epilogue 1.008ms GC(2) GC Stats: 70561 (8.63%) reachable from roots, 746676 (91.37%) reachable from heap, 91055 (11.14%) moved, 2237 (0.27%) markwords preserved GC(2) Heap: 20480M reserved, 20480M (100.00%) committed, 37056K (0.18%) used GC(2) Lisp2-style Mark-Compact (Allocation Failure) 20479M-&gt;36M(20480M) 197.940ms</code> </pre> <br><p> 200 ?        GC!   ,         .   ,          ,   :         (      ‚Äî  ,    ).       - (                ). </p><br><p>  , GC          . ,   <code>-Xlog:gc -XX:+UseSerialGC</code> ‚Äî  ,  ,  : </p><br><pre> <code class="plaintext hljs">GC(46) Pause Young (Allocation Failure) 575M-&gt;39M(1943M) 2.603ms GC(47) Pause Young (Allocation Failure) 575M-&gt;39M(1943M) 2.606ms GC(48) Pause Young (Allocation Failure) 575M-&gt;39M(1943M) 2.747ms GC(49) Pause Young (Allocation Failure) 575M-&gt;39M(1943M) 2.578ms</code> </pre> <br><p> , 2 .  ,        ,   GC   .      <code>-Xlog:gc -XX:+UseSerialGC</code> ,       ,      : </p><br><pre> <code class="plaintext hljs">GC(3) Pause Full (Allocation Failure) 16385M-&gt;34M(18432M) 1969.694ms GC(4) Pause Full (Allocation Failure) 16385M-&gt;34M(18432M) 2261.405ms GC(5) Pause Full (Allocation Failure) 16385M-&gt;34M(18432M) 2327.577ms GC(6) Pause Full (Allocation Failure) 16385M-&gt;34M(18432M) 2328.976ms</code> </pre> <br><p>     ,    .    . </p><br><a name="8"></a><br><h1 id="8-chto-dalshe"> 8.  ? </h1><br><p>     .       ,    GC  OpenJDK ‚Äî  ,    ,          . </p><br><p>   : </p><br><ol><li><p>    .     ,   // .      .     ,       ,    ¬´ ¬ª       ,        ,   . <br></p><blockquote>    GC, <code>java.lang.ref.Reference.referent</code> ‚Äî     Java-,  ,   ,     -  .       <code>FinalReference</code> ,    . </blockquote>         <code>ReferenceProcessor</code>     /  /     . <br></li><li><p>        VM.              VM,   ,   ,       .       <em></em>  <em></em>  .  ,    <em></em>  ,  ,     -  <em></em>   ,    . </p><br></li><li><p>  .      ‚Äî    ,    GC,          .  ,    ,      ,       . <br></p><blockquote>    mark-compact GC   Full GC fallbacks  Shenandoah (  OpenJDK 8)  G1 (  OpenJDK 10,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">JEP 307: ¬´Parallel Full GC for G1¬ª</a> ). </blockquote><br></li><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">  </a> .  ,        ¬´¬ª     ,     , ,  -     .           .   ,          . </p><br></li><li><p>        .     ,  ,     ,           .   ,     ¬´¬ª ‚Äî    ¬´¬ª        ¬´¬ª ,      . </p><br></li><li><p>  -   GC Handbook     . </p><br></li></ol><br><a name="9"></a><br><h1 id="9-vyvody"> 9.  </h1><br><p>       ?   GC ‚Äî  , ,  ,        GC. </p><br><p>         ,    -  GC   . ,     ,            GC (, Serial GC  Parallel GC),         . </p><br><blockquote>  Minute de publicit√©.  , 5-6  2019,  JPoint ‚Äî    Java-.           ‚Äî OpenJDK, GraalVM, Kotlin  .        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">  </a> . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr443250/">https://habr.com/ru/post/fr443250/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr443240/index.html">Comprendre le Q-learning, le probl√®me ¬´Marcher sur un rocher¬ª</a></li>
<li><a href="../fr443242/index.html">Quarkus est un Java subatomique supersonique. Un bref aper√ßu du cadre</a></li>
<li><a href="../fr443244/index.html">T√¢ches de d√©briefing. Beanpoisk_1</a></li>
<li><a href="../fr443246/index.html">Comment nous avons r√©invent√© le PBX IP Askozia apr√®s la vente et la cl√¥ture du projet par le d√©veloppeur</a></li>
<li><a href="../fr443248/index.html">Protocoles de r√©servation transparente de PRP et HSR</a></li>
<li><a href="../fr443252/index.html">Bots de fourmis modulaires avec m√©moire</a></li>
<li><a href="../fr443254/index.html">Triton est le virus le plus mortel</a></li>
<li><a href="../fr443256/index.html">PowerShell, vidage de mon exp√©rience</a></li>
<li><a href="../fr443258/index.html">Gotify - un projet open source pour d√©livrer des notifications et envoyer des messages au serveur</a></li>
<li><a href="../fr443260/index.html">Migrez vers Zimbra sans risquer une entreprise avec un domaine commun</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>