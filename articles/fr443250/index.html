<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥒 🤱 🙎 Collecteur de déchets fait maison pour OpenJDK 👨🏻‍⚕️ 🚤 🤘🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Il s'agit d'une traduction de l'article d'Alexey Shipilev «Faites-le vous-même (OpenJDK) Garbage Collector» , publié avec le consentement de l'auteur....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Collecteur de déchets fait maison pour OpenJDK</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/443250/"><blockquote>  Il s'agit d'une traduction de l'article d'Alexey Shipilev <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">«Faites-le vous-même (OpenJDK) Garbage Collector»</a> , publié avec le consentement de l'auteur.  Signalez toutes les fautes de frappe et autres bogues dans PM - nous les corrigerons. </blockquote><p>  Le processus de création de quelque chose lors de l'exécution est un exercice amusant.  Au moins la création de la première version!  Construire un sous-système d'exécution fiable, performant et à sécurité intégrée, dont le comportement peut être facilement observé et débogué, est une tâche très, très difficile. </p><br><p>  Faire un simple garbage collector est d'une simplicité trompeuse, et maintenant je veux le faire dans cet article.  Roman Kennke au FOSDEM 2019 a fait une présentation et une démo intitulée <a href="">«Écrire un GC en 20 minutes» en</a> utilisant une version antérieure de ce patch.  Malgré le fait que le code implémenté ici en démontre beaucoup et soit abondamment commenté, il est nécessaire d'avoir une bonne description de haut niveau de ce qui se passe - c'est ainsi que cet article est apparu. </p><br><p>  Une compréhension de base du travail des ramasseurs d'ordures aidera grandement à comprendre ce qui est écrit ici.  L'article utilisera des détails et des idées dans une implémentation spécifique de HotSpot, mais il n'y aura pas de cours d'introduction à la conception de GC ici.  Prenez le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">manuel</a> du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GC</a> et lisez les premiers chapitres sur les bases du GC, et encore plus vite commencera <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">l'article Wikipedia</a> . </p><br><p><img src="https://habrastorage.org/webt/4v/1i/4y/4v1i4yrxpcef-vvvkknzfuhmt-w.jpeg"></p><a name="habracut"></a><br><h1 id="soderzhanie">  Table des matières </h1><br><div class="spoiler">  <b class="spoiler_title">Texte masqué</b> <div class="spoiler_text"><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">1. En quoi consiste GC</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">1.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Epsilon gc</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">1.1.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Allocation de mémoire</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">1.1.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Obstacles</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">1.1.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Surveillance de la connexion</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">1.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Rantime et GC</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">1.2.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Éléments racine</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">1.2.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Exploration d'objets</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">1.2.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Déplacements</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">1.2.4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Données de marqueur</a> </li></ul></li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">2. Plan général</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">3. Mise en œuvre du noyau du GC</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">3.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Prologue</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">3.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Marquage</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">3.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Calculer de nouvelles adresses</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">3.4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Correction des pointeurs</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">3.5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Nous déplaçons des objets</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">3.6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Épilogue</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">4. Connectez le GC à la VM</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">4.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Traversée radiculaire</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">4.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Safepoints et arrêter le monde</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">4.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Erreurs d'allocation de mémoire</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">5. Assemblée</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">6. Test</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">7. Performance</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">8. Et ensuite?</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">9. Conclusions</a> </li></ul></div></div><br><a name="1"></a><br><h1 id="1-iz-chego-sostoit-gc">  1. En quoi consiste GC </h1><br><p>  Maintenant que de nombreux GC différents ont été écrits, il est assez simple de créer les vôtres - de nombreux éléments déjà écrits peuvent être (ré) utilisés pour transférer certaines des inquiétudes concernant les détails d'implémentation vers du code éprouvé et testé. </p><br><a name="11"></a><br><h2 id="11-epsilon-gc">  1.1.  Epsilon gc </h2><br><p> OpenJDK 11 présente un nouveau JEP 318: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">"Epsilon: un garbage collector sans opération (expérimental)"</a> .  Sa tâche est de fournir une implémentation minimale pour le cas où la libération de mémoire n'est pas nécessaire ni même interdite.  JEP explique plus en détail pourquoi cela pourrait être utile. </p><br><p>  Du point de vue de l'implémentation, «garbage collector» est un mauvais nom, il serait plus correct d'utiliser le terme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">«gestionnaire de mémoire automatique»</a> , qui est responsable de l'allocation et de la libération de mémoire.  Epsilon GC n'implémente que «l'allocation» et ne traite pas du tout de la «libération».  Par conséquent, vous pouvez prendre Epsilon GC et commencer à implémenter les algorithmes de «libération» à partir de zéro. </p><br><a name="111"></a><br><h3 id="111-vydelenie-pamyati">  1.1.1.  Allocation de mémoire </h3><br><p>  La partie la plus développée du GC Epsilon <a href="">est responsable de l'allocation de mémoire</a> .  Il sert des demandes externes pour allouer de la mémoire de taille arbitraire et créer un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">tampon d'allocation de thread local (TLAB) de la</a> taille souhaitée.  L'implémentation elle-même essaie de ne pas trop étendre le TLAB, car il n'y aura pas de mémoire libre et personne ne renverra les octets perdus. </p><br><a name="112"></a><br><h3 id="112-barery">  1.1.2.  Obstacles </h3><br><p>  Certains garbage collector nécessitent une interaction avec l'application pour maintenir les invariants GC, forçant le runtime et l'application à créer des soi-disant <em>barrières</em> lorsqu'ils tentent d'accéder au tas.  Cela est vrai pour tous les collectionneurs multi-threads, ainsi que pour de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">nombreux collectionneurs de générations</a> et d'arrêt du monde. </p><br><p>  Epsilon ne nécessite pas de barrières, mais le runtime et le compilateur veulent toujours <em>savoir</em> que les barrières ne font rien.  Le manipuler à chaque fois partout peut être fatigant.  Heureusement, à partir d'OpenJDK 11, il existe un nouveau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">JEP-304: «Interface de collecte des ordures»</a> , ce qui facilite considérablement l'insertion des barrières.  En particulier, la <a href="">barrière définie dans Epsilon est vide</a> et tout le travail trivial - sauvegarde, chargement, CAS, copie sur tableau - peut être délégué aux implémentations de barrières triviales à partir d'une superclasse existante.  Si vous créez un GC qui n'a pas non plus besoin de barrières, vous pouvez simplement réutiliser le code d'Epsilon. </p><br><a name="113"></a><br><h3 id="113-podklyuchenie-k-monitoringu">  1.1.3.  Surveillance de la connexion </h3><br><p>  La dernière partie fastidieuse de la mise en œuvre du GC est liée à un tas de mécanismes de surveillance à l'intérieur de la JVM: les bacs MX, les commandes de diagnostic, etc. devraient fonctionner.  Epsilon <a href="">a déjà fait</a> tout cela pour vous. </p><br><a name="12"></a><br><h2 id="12-rantaym-i-gc">  1.2.  Rantime et GC </h2><br><a name="121"></a><br><h3 id="121-kornevye-elementy">  1.2.1.  Éléments racine </h3><br><p>  Le garbage collector, dans le cas général, a besoin de savoir exactement ce qui dans le runtime Java a des références de tas.  Ces éléments racine, appelés <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">racines GC</a> , peuvent être des emplacements sur des piles de flux et des variables locales (y compris celles trouvées dans le code compilé JIT!), Des classes natives et des chargeurs de classe, des références dans JNI, etc.  Les tentatives d'identification de ces éléments peuvent être très complexes et fastidieuses.  Mais dans Hotspot, ils sont tous suivis à l'aide des sous-systèmes VM appropriés, vous pouvez donc simplement apprendre comment les implémentations GC existantes fonctionnent avec eux.  Plus loin dans le texte, nous le verrons. </p><br><a name="122"></a><br><h3 id="122-obhod-obektov">  1.2.2.  Exploration d'objets </h3><br><p> Le garbage collector doit contourner les liens sortants dans les objets Java.  Cette opération se trouve partout, de sorte que les parties communes de l'exécution fournissent des solutions de contournement toutes faites; vous n'avez pas besoin d'écrire quoi que ce soit vous-même.  Ci-dessous, il y aura une section avec une implémentation spécifique, et vous y trouverez, par exemple, les appels <code>obj→oop_iterate</code> . </p><br><a name="123"></a><br><h3 id="123-peremescheniya">  1.2.3.  Déplacements </h3><br><p>  Le ramasse-miettes en mouvement doit noter quelque part les nouvelles adresses des objets déplacés.  Il existe plusieurs endroits où vous pouvez écrire ces <em>données de transfert</em> . </p><br><ol><li>  Vous pouvez réutiliser le <a href="">«mot marqueur» dans l'objet lui-même</a> (série, parallèle, etc.).  Une fois le monde arrêté, tous les accès à l'objet sont contrôlés et il est garanti qu'aucun thread Java ne peut voir les données temporaires que nous avons décidé d'entrer dans le mot marqueur.  Vous pouvez le réutiliser pour stocker des données de transfert. </li><li>  Vous pouvez gérer une table de mouvement native distincte ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ZGC</a> , C4 et autres).  Cela isole complètement le GC du runtime et du reste de l'application, car seul le GC connaît l'existence d'une telle table.  Les assembleurs compétitifs utilisent généralement un tel schéma - ils ne veulent pas souffrir d'un tas de problèmes inutiles. </li><li>  Vous pouvez ajouter un autre mot à l'objet ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Shenandoah</a> et autres).  Cette combinaison des deux approches précédentes permet non seulement au runtime et à l'application de fonctionner sans problème avec les en-têtes existants, mais enregistre également les données de transfert. </li></ol><br><a name="124"></a><br><h3 id="124-markernye-dannye">  1.2.4.  Données de marqueur </h3><br><p>  Le garbage collector doit écrire des <em>données de marquage</em> quelque part.  Et encore une fois, il existe plusieurs façons de les enregistrer: </p><br><ol><li>  Vous pouvez réutiliser le mot marqueur dans l'objet lui-même (série, parallèle, etc.).  Encore une fois, en mode d'arrêt mondial, vous pouvez utiliser les bits du mot marqueur pour coder le fait d'une étiquette.  De plus, si vous avez besoin de faire le tour de tous les objets vivants, nous <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">suivons</a> le tas, objet après objet - cela est possible car le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">tas est analysable</a> . </li><li>  Vous pouvez gérer une structure distincte pour le stockage des données de marquage (G1, Shenandoah, etc.).  Cela se fait généralement à l'aide d'un <a href="">bitmap distinct</a> , qui mappe tous les N octets du tas sur 1 bit de la carte.  Habituellement, les objets Java sont <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">alignés sur 8 octets</a> , de sorte que la carte mappe tous les 64 bits du tas à 1 bit de la carte, occupant 1/64 de la taille du tas dans la mémoire native.  Ces frais généraux sont payants lors de l'analyse du tas pour la présence d'objets vivants, en particulier clairsemés: le contournement de la carte est souvent beaucoup plus rapide que le contournement du tas désassemblé objet par objet. </li><li>  Encodez les étiquettes en liens eux-mêmes (ZGC, C4 et autres).  Cela nécessite une coordination avec l'application, puis vous devez couper toutes ces étiquettes des liens ou effectuer d'autres astuces pour maintenir l'exactitude.  En d'autres termes, nous avons besoin de barrières ou de travaux supplémentaires de la part du GC. </li></ol><br><a name="2"></a><br><h1 id="2-obschiy-plan">  2. Plan général </h1><br><p>  Très probablement, le plus facile à implémenter au-dessus d'Epsilon est le Mark-Compact, dans le style LISP2.  L'idée de base de ce GC est décrite à la fois <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sur Wikipedia</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dans le Manuel du GC</a> (chapitre 3.2).  Un croquis de l'algorithme sera dans la section avec l'implémentation ci-dessous, mais je recommande fortement de lire un peu Wikipedia ou le manuel du GC pour comprendre ce que nous allons faire. </p><br><p>  L'algorithme en question est le GC <em>décalé</em> : les objets en mouvement se déplacent dans un tableau au tout début du tas.  Il a ses avantages et ses inconvénients: </p><br><ul><li>  Il maintient l'ordre des allocations de mémoire.  C'est très bien pour contrôler la mise en page en mémoire, si cela vous intéresse (contrôlez les monstres, c'est votre temps!).  L'inconvénient est que vous n'obtiendrez pas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la localité de lien automatique de</a> cette façon. </li><li>  Sa complexité est O (N) du nombre d'objets.  Cependant, la linéarité a un prix: GC doit contourner un tas de 4 fois pour chaque cycle de construction. </li><li>  Il ne nécessite pas de mémoire libre sur le tas!  Il n'est pas nécessaire de réserver de la mémoire sur le tas pour évacuer les objets vivants, vous pouvez donc même travailler avec un tas débordé de 99. (9)%.  Si nous adoptons d'autres idées de simples collectionneurs, par exemple un charognard avec un semi-espace (charognard semi-spatial), nous devrons réécrire légèrement la présentation du tas et réserver un peu d'espace pour l'évacuation, mais cela dépasse le cadre de cet exercice. </li><li>  Si vous travaillez un peu sur le problème, vous pouvez atteindre zéro consommation de mémoire et de temps pendant les périodes où le CPG est inactif.  Il démarre sur une mémoire dans un état arbitraire et s'arrête, le compactant de manière significative.  Cela correspond très bien au fonctionnement d'Epsilon: il ne fait que surligner juste après le dernier objet.  C'est aussi un inconvénient: quelques objets morts au début du tas entraînent un grand nombre de mouvements. </li><li>  Il ne nécessite tout simplement pas de nouvelles barrières, vous pouvez réutiliser <code>EpsilonBarrierSet</code> tel <code>EpsilonBarrierSet</code> . </li></ul><br><p>  Par souci de simplicité, l'implémentation GC utilisera un arrêt complet du monde (stop-the-world, STW), elle n'aura pas de générations ni de multithreading.  Dans ce cas, il est judicieux d'utiliser une image bitmap pour stocker les marques et réutiliser le mot marqueur pour stocker les données de mouvement. </p><br><a name="3"></a><br><h1 id="3-realizaciya-yadra-gc">  3. Mise en œuvre du noyau du GC </h1><br><p>  Lire et comprendre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">toute la mise en œuvre</a> peut être trop compliqué pour une personne ignorante.  Dans cette section, nous allons le comprendre étape par étape. </p><br><a name="31"></a><br><h2 id="31-prolog">  3.1.  Prologue </h2><br><p>  Le ramasse-miettes doit généralement faire deux ou trois choses pour préparer la collecte.  Lisez les commentaires, ils devraient parler d'eux-mêmes: </p><br><pre> <code class="cpp hljs">{ GCTraceTime(Info, gc) time(<span class="hljs-string"><span class="hljs-string">"Step 0: Prologue"</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-comment"><span class="hljs-comment">//      .      //   :   ,   ,  // «»   ,      //   ,     . if (!os::commit_memory((char*)_bitmap_region.start(), _bitmap_region.byte_size(), false)) { log_warning(gc)("Could not commit native memory for marking bitmap, GC failed"); return; } //        ,  , //       TLAB-. ensure_parsability(true); //      ,    GC. CodeCache::gc_prologue(); BiasedLocking::preserve_marks(); //        . //       . DerivedPointerTable::clear(); }</span></span></code> </pre> <br><p>  Étant donné que nous utilisons un bitmap pour suivre l'accessibilité des objets, nous devons l'effacer avant utilisation.  Ou dans notre cas, puisque nous visons à ne jamais demander de ressources avant de démarrer le cycle GC, nous devrons <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">valider la bitmap en mémoire à l'</a> avance.  Cela offre plusieurs avantages intéressants, au moins sous Linux, où la plupart du bitmap pointera vers la page zéro, en particulier pour les tas clairsemés. </p><br><p>  Les threads doivent libérer leurs TLAB et en demander de nouveaux au GC une fois la construction terminée. </p><br><blockquote>  Ne confondez pas TLAB et <code>java.lang.ThreadLocal</code> .  Du point de vue du GC, ThreadLocal sont des objets ordinaires, et ils ne seront pas compilés par le GC sauf indication contraire dans le code Java. </blockquote><p>  Certaines parties de l'exécution, en particulier celles qui contiennent des liens vers le tas Java, se briseront lors de la récupération de place, vous devez donc les avertir spécifiquement que le GC commencera bientôt à fonctionner.  Cela permettra aux sous-systèmes respectifs de préparer et d'enregistrer une partie de leur état avant que le GC ne se déplace. </p><br><a name="32"></a><br><h2 id="32-markirovka">  3.2.  Marquage </h2><br><p>  Marquer en mode stop du monde devient assez simple quand presque tout a déjà été fait pour nous.  L'étiquetage est assez standard, et très probablement, dans de nombreuses implémentations, GC est la première étape. </p><br><pre> <code class="cpp hljs">{ GCTraceTime(Info, gc) time(<span class="hljs-string"><span class="hljs-string">"Step 1: Mark"</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    ,     .  //   ,  ,    //      . EpsilonMarkStack stack; EpsilonScanOopClosure cl(&amp;stack, &amp;_bitmap); //      . process_roots(&amp;cl); stat_reachable_roots = stack.size(); //    ,    . //    ,   , //      . while (!stack.is_empty()) { oop obj = stack.pop(); obj-&gt;oop_iterate(&amp;cl); stat_reachable_heap++; } //       . DerivedPointerTable::set_active(false); }</span></span></code> </pre> <br><p>  Cela fonctionne exactement de la même manière que pour tout autre graphique: vous commencez la traversée avec l'ensemble initial de sommets accessibles, longez les bords sortants et enregistrez tous les sommets visités.  La traversée continue jusqu'à la fin de tous les pics non visités.  Dans GC, les «sommets» sont des objets et les «arêtes» sont des liens entre eux. </p><br><p>  Techniquement, nous pourrions simplement parcourir récursivement le graphe des objets, mais c'est une mauvaise idée pour les graphes arbitraires qui peuvent avoir de très grands diamètres.  Imaginez une liste chaînée d'un milliard de pics!  Par conséquent, pour limiter la profondeur de récursivité, nous utilisons une pile de marquage qui enregistre les objets détectés. </p><br><p>  L'ensemble initial d'objets accessibles est les racines GC.  Maintenant, ne vous attardez pas sur ce qu'est <code>process_roots</code> , plus sur cela plus tard.  Pour l'instant, disons simplement qu'il contourne tous les liens accessibles du côté VM. </p><br><p>  Une image bitmap avec des marques sert à la fois d'outil pour enregistrer le <em>front d'onde de marquage</em> (beaucoup d'objets déjà visités) et au final - comme référentiel du résultat souhaité, un ensemble de tous les objets accessibles.  Le vrai travail se déroule dans <code>EpsilonScanOopClosure</code> , il est appliqué à tous les objets intéressants et itéré sur tous les liens de l'objet sélectionné. </p><br><blockquote>  Regardez, Java a su <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fermer (fermer)</a> avant de devenir à la mode! </blockquote><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EpsilonScanOopClosure</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> BasicOopIterateClosure { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: EpsilonMarkStack* <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> _stack; MarkBitMap* <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> _bitmap; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">do_oop_work</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">p</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-comment"><span class="hljs-comment">// p -     ,   oop,   //      ,  : T o = RawAccess&lt;&gt;::oop_load(p); if (!CompressedOops::is_null(o)) { oop obj = CompressedOops::decode_not_null(o); //  . ,   .  , //        . //    +, //       . if (!_bitmap-&gt;is_marked(obj)) { _bitmap-&gt;mark((HeapWord*)obj); _stack-&gt;push(obj); } } } };</span></span></code> </pre> <br><p>  Une fois cette étape <code>_bitmap</code> , <code>_bitmap</code> contient des bits indiquant l'emplacement des objets <code>_bitmap</code> .  Grâce à cela, il est possible de contourner tous les objets vivants, par exemple: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//           . //   ,    ( )  ,  //       1/64  . void EpsilonHeap::walk_bitmap(ObjectClosure* cl) { HeapWord* limit = _space-&gt;top(); HeapWord* addr = _bitmap.get_next_marked_addr(_space-&gt;bottom(), limit); while (addr &lt; limit) { oop obj = oop(addr); assert(_bitmap.is_marked(obj), "sanity"); cl-&gt;do_object(obj); addr += 1; if (addr &lt; limit) { addr = _bitmap.get_next_marked_addr(addr, limit); } } }</span></span></code> </pre> <br><a name="33"></a><br><h2 id="33-vychislyaem-novye-adresa">  3.3.  Calculer de nouvelles adresses </h2><br><p>  C'est également une étape assez simple, et elle met en œuvre exactement ce que dit l'algorithme. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/ab3/406/5e6/ab34065e6397d39413057358b45247a3.jpg"></p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    forwarding data (,    ) //   .        . //          . PreservedMarks preserved_marks; //     GC. HeapWord* new_top; { GCTraceTime(Info, gc) time("Step 2: Calculate new locations", NULL); //    ,        //    . ,  - . EpsilonCalcNewLocationObjectClosure cl(_space-&gt;bottom(), &amp;preserved_marks); walk_bitmap(&amp;cl); //         . //       ,    //      ,      "" //  . new_top = cl.compact_point(); stat_preserved_marks = preserved_marks.size(); }</span></span></code> </pre> <br><p>  La seule chose qui attire votre attention, c'est que nous avons décidé de stocker de nouvelles adresses dans le mot de marquage des objets Java, et ce mot peut déjà être occupé par quelque chose d'important, par exemple, des informations sur les verrous.  Heureusement, de tels mots de marquage non triviaux sont assez rares, et nous pouvons simplement les stocker séparément, si cela est nécessaire: c'est pour cela que <code>PreservedMarks</code> utilisé. </p><br><p>  Le vrai travail algorithmique est effectué par <code>EpsilonCalcNewLocationObjectClosure</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EpsilonCalcNewLocationObjectClosure</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ObjectClosure { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: HeapWord* _compact_point; PreservedMarks* <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> _preserved_marks; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: EpsilonCalcNewLocationObjectClosure(HeapWord* start, PreservedMarks* pm) : _compact_point(start), _preserved_marks(pm) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_object</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(oop obj)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    :    . //        (      , //    ),      , //     . if ((HeapWord*)obj != _compact_point) { markOop mark = obj-&gt;mark_raw(); if (mark-&gt;must_be_preserved(obj)) { _preserved_marks-&gt;push(obj, mark); } obj-&gt;forward_to(oop(_compact_point)); } _compact_point += obj-&gt;size(); } HeapWord* compact_point() { return _compact_point; } };</span></span></code> </pre> <br><p>  <code>forward_to</code> est la partie la plus importante car elle stocke "l'adresse de déplacement" dans le mot marqueur de l'objet.  Cela sera nécessaire dans les prochaines étapes. </p><br><a name="34"></a><br><h2 id="34-ispravlyaem-ukazateli">  3.4.  Correction des pointeurs </h2><br><p>  Vous devez maintenant parcourir à nouveau le tas et réécrire tous les liens avec leurs nouvelles adresses selon l'algorithme suivant: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/25f/c82/1dc/25fc821dc95d2f9d50fe40653eb845ff.jpg"></p><br><pre> <code class="cpp hljs">{ GCTraceTime(Info, gc) time(<span class="hljs-string"><span class="hljs-string">"Step 3: Adjust pointers"</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-comment"><span class="hljs-comment">//     _   _,     // « ».      forwarding data, //    .      . EpsilonAdjustPointersObjectClosure cl; walk_bitmap(&amp;cl); //     ,      VM,  //     :      . EpsilonAdjustPointersOopClosure cli; process_roots(&amp;cli); //   ,      , //     . preserved_marks.adjust_during_full_gc(); }</span></span></code> </pre> <br><p>  Il existe deux types de références aux objets déplacés: sortant soit des objets sur le tas lui-même, soit des racines GC.  Vous devez mettre à jour les deux classes de liens.  Certaines étiquettes enregistrées stockent également des références aux objets, vous devez donc leur demander de mettre à jour.  <code>PreservedMarks</code> sait comment faire cela car il attend des «données de transfert» au même endroit où nous les avons enregistrées, dans le mot de marquage de l'objet. </p><br><p>  Les fermetures sont divisées en deux types: certaines prennent des objets et contournent leur contenu, d'autres mettent à jour ces adresses.  Ici, vous pouvez faire une petite optimisation des performances: si l'objet ne bouge pas, vous pouvez enregistrer quelques enregistrements dans un groupe: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EpsilonAdjustPointersOopClosure</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> BasicOopIterateClosure { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">do_oop_work</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">p</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-comment"><span class="hljs-comment">// p -     ,   oop. //        ,  : T o = RawAccess&lt;&gt;::oop_load(p); if (!CompressedOops::is_null(o)) { oop obj = CompressedOops::decode_not_null(o); //         . //  ,    . if (obj-&gt;is_forwarded()) { oop fwd = obj-&gt;forwardee(); assert(fwd != NULL, "just checking"); RawAccess&lt;&gt;::oop_store(p, fwd); } } } }; class EpsilonAdjustPointersObjectClosure : public ObjectClosure { private: EpsilonAdjustPointersOopClosure _cl; public: void do_object(oop obj) { //    ,    : obj-&gt;oop_iterate(&amp;_cl); } };</span></span></code> </pre> <br><p>  Après avoir terminé cette étape, nous avons essentiellement cassé le tas: les liens pointent vers les «mauvaises» adresses auxquelles les objets ne se trouvent pas encore.  Corrigeons-le! </p><br><a name="35"></a><br><h2 id="35-dvigaem-obekty">  3.5.  Nous déplaçons des objets </h2><br><p>  Temps pour déplacer des objets vers de nouvelles adresses, conformément à l'algorithme: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/01c/5b8/db8/01c5b8db85781c82b89bbed730c8aecc.jpg"></p><br><p>  <code>EpsilonMoveObjectsObjectClosure</code> nouveau le tour des tas et appliquez la fermeture <code>EpsilonMoveObjectsObjectClosure</code> à tous les objets vivants: </p><br><pre> <code class="cpp hljs">{ GCTraceTime(Info, gc) time(<span class="hljs-string"><span class="hljs-string">"Step 4: Move objects"</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-comment"><span class="hljs-comment">//       . //          . EpsilonMoveObjectsObjectClosure cl; walk_bitmap(&amp;cl); stat_moved = cl.moved(); //         ,   // «»      . _space-&gt;set_top(new_top); }</span></span></code> </pre> <br><p>  Immédiatement après cela, vous pouvez faire glisser le tas du tas de points de compactage, ce qui permet d'allouer de la mémoire directement à partir de cet emplacement, immédiatement après la fin du cycle de récupération de place. </p><br><p>  Notez que dans l'assemblage de décalage, nous pouvons écraser le contenu des objets existants, mais comme la numérisation va dans le même sens, les objets écrasés sont déjà copiés au bon endroit. </p><br><blockquote>  L'ancien et le nouvel emplacement de la même installation peuvent se croiser.  Par exemple, si vous décalez un objet de 100 octets de 8 octets.  La procédure de copie doit fonctionner par elle-même, et le contenu se croisant doit être copié correctement, faites attention à <code>Copy::aligned_*conjoint*_words</code> . </blockquote><p>  La fermeture elle-même déplacera simplement les objets déplacés vers les nouvelles adresses: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EpsilonMoveObjectsObjectClosure</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ObjectClosure { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_object</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(oop obj)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//     ,  .   - , //   -  mark word, //      forwarding data. if (obj-&gt;is_forwarded()) { oop fwd = obj-&gt;forwardee(); assert(fwd != NULL, "just checking"); Copy::aligned_conjoint_words((HeapWord*)obj, (HeapWord*)fwd, obj-&gt;size()); fwd-&gt;init_mark_raw(); } } };</span></span></code> </pre> <br><a name="36"></a><br><h2 id="36-epilog">  3.6.  Épilogue </h2><br><p>  La collecte des ordures est terminée, le tas est à nouveau presque cohérent, les dernières touches sont laissées: </p><br><pre> <code class="cpp hljs">{ GCTraceTime(Info, gc) time(<span class="hljs-string"><span class="hljs-string">"Step 5: Epilogue"</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    . preserved_marks.restore(); //   ,    . DerivedPointerTable::update_pointers(); BiasedLocking::restore_marks(); CodeCache::gc_epilogue(); JvmtiExport::gc_epilogue(); //     . if (!os::uncommit_memory((char*)_bitmap_region.start(), _bitmap_region.byte_size())) { log_warning(gc)("Could not uncommit native memory for marking bitmap"); } //    ,  . //        . if (EpsilonUncommit) { _virtual_space.shrink_by((_space-&gt;end() - new_top) * HeapWordSize); _space-&gt;set_end((HeapWord*)_virtual_space.high()); } }</span></span></code> </pre> <br><p>  Nous informons le reste du runtime qu'ils doivent démarrer les procédures de post-assemblage.  Nous restaurons les mots marqueurs spéciaux que nous avons enregistrés précédemment.  Adieu bisous à notre carte marqueur - elle n'est plus nécessaire. </p><br><p>  Et, si vous le voulez vraiment, vous pouvez réduire la mémoire pour les allocations à une nouvelle taille, retournant ainsi la mémoire au système d'exploitation! </p><br><a name="4"></a><br><h1 id="4-podklyuchaem-gc-k-vm">  4. Connectez le GC à la VM </h1><br><a name="41"></a><br><h2 id="41-obhod-kornevyh-elementov">  4.1.  Traversée radiculaire </h2><br><p>  Rappelez-vous, vous devez contourner les liens spéciaux accessibles de VM?  Vous pouvez demander à chaque sous-système VM spécial de contourner les liens cachés des autres objets Java.  Une liste exhaustive de ces éléments racine dans le Hotspot actuel ressemble à ceci: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> EpsilonHeap::do_roots(OopClosure* cl) { <span class="hljs-comment"><span class="hljs-comment">//   ,        1 . StrongRootsScope scope(1); //         . CLDToOopClosure clds(cl, ClassLoaderData::_claim_none); MarkingCodeBlobClosure blobs(cl, CodeBlobToOopClosure::FixRelocations); //      . //        . { MutexLockerEx lock(CodeCache_lock, Mutex::_no_safepoint_check_flag); CodeCache::blobs_do(&amp;blobs); } { MutexLockerEx lock(ClassLoaderDataGraph_lock); ClassLoaderDataGraph::cld_do(&amp;clds); } Universe::oops_do(cl); Management::oops_do(cl); JvmtiExport::oops_do(cl); JNIHandles::oops_do(cl); WeakProcessor::oops_do(cl); ObjectSynchronizer::oops_do(cl); SystemDictionary::oops_do(cl); Threads::possibly_parallel_oops_do(false, cl, &amp;blobs); }</span></span></code> </pre> <br><p>  ,        .    GC    . </p><br><a name="42"></a><br><h2 id="42-seyfpointy-i-ostanovka-mira">  4.2.     </h2><br><p>   GC     ,   VM      .  Hotspot     <code>VM_Operation</code> ,     GC    VM-  : </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// VM_operation,      class VM_EpsilonCollect: public VM_Operation { private: const GCCause::Cause _cause; EpsilonHeap* const _heap; static size_t _last_used; public: VM_EpsilonCollect(GCCause::Cause cause) : VM_Operation(), _cause(cause), _heap(EpsilonHeap::heap()) {}; VM_Operation::VMOp_Type type() const { return VMOp_EpsilonCollect; } const char* name() const { return "Epsilon Collection"; } virtual bool doit_prologue() { //     ,     . //         GC, //          . //   ,         //  .     , //       1%, ,  , //     . Heap_lock-&gt;lock(); size_t used = _heap-&gt;used(); size_t capacity = _heap-&gt;capacity(); size_t allocated = used &gt; _last_used ? used - _last_used : 0; if (_cause != GCCause::_allocation_failure || allocated &gt; capacity / 100) { return true; } else { Heap_lock-&gt;unlock(); return false; } } virtual void doit() { _heap-&gt;entry_collect(_cause); } virtual void doit_epilogue() { _last_used = _heap-&gt;used(); Heap_lock-&gt;unlock(); } }; size_t VM_EpsilonCollect::_last_used = 0; void EpsilonHeap::vmentry_collect(GCCause::Cause cause) { VM_EpsilonCollect vmop(cause); VMThread::execute(&amp;vmop); }</span></span></code> </pre> <br><p>       ,       GC —    ,     . </p><br><a name="43"></a><br><h2 id="43-oshibki-vydeleniya-pamyati">  4.3.    </h2><br><p> ,     GC  ,   ,  GC    ,     .   ,      <code>allocate_work</code>     ,   GC     : </p><br><pre> <code class="cpp hljs">HeapWord* EpsilonHeap::allocate_or_collect_work(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> size) { HeapWord* res = allocate_work(size); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (res == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> &amp;&amp; EpsilonSlidingGC) { vmentry_collect(GCCause::_allocation_failure); res = allocate_work(size); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; }</code> </pre> <br><p>   ! </p><br><a name="5"></a><br><h1 id="5-sborka"> 5.  </h1><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a>        OpenJDK. </p><br><pre> <code class="bash hljs">$ hg <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> https://hg.openjdk.java.net/jdk/jdk/ jdk-jdk $ <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> jdk-jdk $ curl https://shipilev.net/jvm/diy-gc/webrev/jdk-jdk-epsilon.changeset | patch -p1</code> </pre> <br><p>     OpenJDK  : </p><br><pre> <code class="bash hljs">$ ./configure --with-debug-level=fastdebug $ make images</code> </pre> <br><p>    : </p><br><pre> <code class="bash hljs">$ build/linux-x86_64-server-fastdebug/images/jdk/bin/java -XX:+UnlockExperimentalVMOptions -XX:+UseEpsilonGC -XX:+EpsilonSlidingGC -version openjdk version <span class="hljs-string"><span class="hljs-string">"13-internal"</span></span> 2019-09-17 OpenJDK Runtime Environment (build 13-internal+0-adhoc.shade.jdk-jdk-epsilon) OpenJDK 64-Bit Server VM (build 13-internal+0-adhoc.shade.jdk-jdk-epsilon, mixed mode, sharing</code> </pre> <br><a name="6"></a><br><h1 id="6-testirovanie"> 6.  </h1><br><p>  ,    GC  ?    : </p><br><ol><li> .  .   Hotspot    ,   JVM   <em>fastdebug</em>        ,        GC. </li><li>  .        ,          . ,        ( )   ,          . </li><li>  Tests.    ,  ,   ,   .     -   ,        . </li></ol><br><p> ,    ,       : </p><br><pre> <code class="plaintext hljs">$ CONF=linux-x86_64-server-fastdebug make images run-test TEST=gc/epsilon/ Building targets 'images run-test' in configuration 'linux-x86_64-server-fastdebug' Test selection 'gc/epsilon/', will run: * jtreg:test/hotspot/jtreg/gc/epsilon Running test 'jtreg:test/hotspot/jtreg/gc/epsilon' Passed: gc/epsilon/TestAlwaysPretouch.java Passed: gc/epsilon/TestAlignment.java Passed: gc/epsilon/TestElasticTLAB.java Passed: gc/epsilon/TestEpsilonEnabled.java Passed: gc/epsilon/TestHelloWorld.java Passed: gc/epsilon/TestLogTrace.java Passed: gc/epsilon/TestDieDefault.java Passed: gc/epsilon/TestDieWithOnError.java Passed: gc/epsilon/TestMemoryPools.java Passed: gc/epsilon/TestMaxTLAB.java Passed: gc/epsilon/TestPrintHeapSteps.java Passed: gc/epsilon/TestArraycopyCheckcast.java Passed: gc/epsilon/TestClasses.java Passed: gc/epsilon/TestUpdateCountersSteps.java Passed: gc/epsilon/TestDieWithHeapDump.java Passed: gc/epsilon/TestByteArrays.java Passed: gc/epsilon/TestManyThreads.java Passed: gc/epsilon/TestRefArrays.java Passed: gc/epsilon/TestObjects.java Passed: gc/epsilon/TestElasticTLABDecay.java Passed: gc/epsilon/TestSlidingGC.java Test results: passed: 21 TEST SUCCESS</code> </pre> <br><p> ?       <em>fastdebug</em>    .  ?    - . </p><br><a name="7"></a><br><h1 id="7-proizvoditelnost"> 7.  </h1><br><p> -  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">spring-petclinic</a> ,  Apache Bench     GC!        ,  ,     GC . </p><br><p>    : <code>-Xlog:gc -XX:+UnlockExperimentalVMOptions -XX:+UseEpsilonGC -XX:+EpsilonSlidingGC</code> : </p><br><p> : </p><br><pre> <code class="plaintext hljs">Heap: 20480M reserved, 20480M (100.00%) committed, 19497M (95.20%) used GC(2) Step 0: Prologue 2.085ms GC(2) Step 1: Mark 51.005ms GC(2) Step 2: Calculate new locations 71.207ms GC(2) Step 3: Adjust pointers 49.671ms GC(2) Step 4: Move objects 22.839ms GC(2) Step 5: Epilogue 1.008ms GC(2) GC Stats: 70561 (8.63%) reachable from roots, 746676 (91.37%) reachable from heap, 91055 (11.14%) moved, 2237 (0.27%) markwords preserved GC(2) Heap: 20480M reserved, 20480M (100.00%) committed, 37056K (0.18%) used GC(2) Lisp2-style Mark-Compact (Allocation Failure) 20479M-&gt;36M(20480M) 197.940ms</code> </pre> <br><p> 200 ?        GC!   ,         .   ,          ,   :         (      —  ,    ).       - (                ). </p><br><p>  , GC          . ,   <code>-Xlog:gc -XX:+UseSerialGC</code> —  ,  ,  : </p><br><pre> <code class="plaintext hljs">GC(46) Pause Young (Allocation Failure) 575M-&gt;39M(1943M) 2.603ms GC(47) Pause Young (Allocation Failure) 575M-&gt;39M(1943M) 2.606ms GC(48) Pause Young (Allocation Failure) 575M-&gt;39M(1943M) 2.747ms GC(49) Pause Young (Allocation Failure) 575M-&gt;39M(1943M) 2.578ms</code> </pre> <br><p> , 2 .  ,        ,   GC   .      <code>-Xlog:gc -XX:+UseSerialGC</code> ,       ,      : </p><br><pre> <code class="plaintext hljs">GC(3) Pause Full (Allocation Failure) 16385M-&gt;34M(18432M) 1969.694ms GC(4) Pause Full (Allocation Failure) 16385M-&gt;34M(18432M) 2261.405ms GC(5) Pause Full (Allocation Failure) 16385M-&gt;34M(18432M) 2327.577ms GC(6) Pause Full (Allocation Failure) 16385M-&gt;34M(18432M) 2328.976ms</code> </pre> <br><p>     ,    .    . </p><br><a name="8"></a><br><h1 id="8-chto-dalshe"> 8.  ? </h1><br><p>     .       ,    GC  OpenJDK —  ,    ,          . </p><br><p>   : </p><br><ol><li><p>    .     ,   // .      .     ,       ,    « »       ,        ,   . <br></p><blockquote>    GC, <code>java.lang.ref.Reference.referent</code> —     Java-,  ,   ,     -  .       <code>FinalReference</code> ,    . </blockquote>         <code>ReferenceProcessor</code>     /  /     . <br></li><li><p>        VM.              VM,   ,   ,       .       <em></em>  <em></em>  .  ,    <em></em>  ,  ,     -  <em></em>   ,    . </p><br></li><li><p>  .      —    ,    GC,          .  ,    ,      ,       . <br></p><blockquote>    mark-compact GC   Full GC fallbacks  Shenandoah (  OpenJDK 8)  G1 (  OpenJDK 10,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">JEP 307: «Parallel Full GC for G1»</a> ). </blockquote><br></li><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">  </a> .  ,        «»     ,     , ,  -     .           .   ,          . </p><br></li><li><p>        .     ,  ,     ,           .   ,     «» —    «»        «» ,      . </p><br></li><li><p>  -   GC Handbook     . </p><br></li></ol><br><a name="9"></a><br><h1 id="9-vyvody"> 9.  </h1><br><p>       ?   GC —  , ,  ,        GC. </p><br><p>         ,    -  GC   . ,     ,            GC (, Serial GC  Parallel GC),         . </p><br><blockquote>  Minute de publicité.  , 5-6  2019,  JPoint —    Java-.           — OpenJDK, GraalVM, Kotlin  .        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">  </a> . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr443250/">https://habr.com/ru/post/fr443250/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr443240/index.html">Comprendre le Q-learning, le problème «Marcher sur un rocher»</a></li>
<li><a href="../fr443242/index.html">Quarkus est un Java subatomique supersonique. Un bref aperçu du cadre</a></li>
<li><a href="../fr443244/index.html">Tâches de débriefing. Beanpoisk_1</a></li>
<li><a href="../fr443246/index.html">Comment nous avons réinventé le PBX IP Askozia après la vente et la clôture du projet par le développeur</a></li>
<li><a href="../fr443248/index.html">Protocoles de réservation transparente de PRP et HSR</a></li>
<li><a href="../fr443252/index.html">Bots de fourmis modulaires avec mémoire</a></li>
<li><a href="../fr443254/index.html">Triton est le virus le plus mortel</a></li>
<li><a href="../fr443256/index.html">PowerShell, vidage de mon expérience</a></li>
<li><a href="../fr443258/index.html">Gotify - un projet open source pour délivrer des notifications et envoyer des messages au serveur</a></li>
<li><a href="../fr443260/index.html">Migrez vers Zimbra sans risquer une entreprise avec un domaine commun</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>