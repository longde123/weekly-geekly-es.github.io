<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏟️ 🏞️ 🧤 Rust 2018 keluar ... tapi apa itu? 🎎 👟 🤞🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Artikel ini ditulis oleh Lin Clarke bekerja sama dengan tim pengembangan Rust ("kami" dalam teks). Anda juga dapat membaca posting di blog Rust resmi....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Rust 2018 keluar ... tapi apa itu?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/432564/"> Artikel ini ditulis oleh Lin Clarke bekerja sama dengan tim pengembangan Rust ("kami" dalam teks).  Anda juga dapat membaca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">posting</a> di blog Rust resmi. <br><br>  Versi pertama Rust 2018 dirilis pada 6 Desember 2018. Dalam rilis ini, kami fokus pada produktivitas sehingga pengembang Rust mulai bekerja seefisien mungkin. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/6de/ed2/a70/6deed2a70423878dfc8d33f655e7a2b1.png"></a> <br>  <i><font color="gray">Timeline menunjukkan transisi dari beta ke Rust 2018 dan Rust 2015. Ini dikelilingi oleh ikon untuk alat dan empat bidang: WebAssembly, tertanam, jaringan dan CLI.</font></i>  <i><font color="gray">Lingkaran merah - produktivitas pengembang - mengelilingi segalanya kecuali Rust 2015</font></i> <br><br>  Tetapi secara umum tidak mudah untuk menjelaskan apa itu Rust 2018. <br><br>  Beberapa menyajikannya sebagai versi baru dari bahasa ... sesuatu seperti itu, tetapi tidak juga.  Saya katakan “tidak juga,” karena di sini “versi baru” tidak berarti versi baru dari bahasa lain. <br><a name="habracut"></a><br>  Di sebagian besar bahasa lain, semua fitur baru menambahkan versi baru.  Versi sebelumnya tidak diperbarui. <br><br>  Sistem Rust beroperasi secara berbeda.  Ini karena bagaimana bahasa berkembang.  Hampir semua fitur baru 100% kompatibel dengan Rust.  Mereka tidak membutuhkan perubahan apa pun.  Ini berarti bahwa tidak ada alasan untuk membatasi kode Rust 2018. Versi yang lebih baru dari kompiler akan terus mendukung "mode Rust 2015" secara default. <br><br>  Namun terkadang pengembangan bahasa membutuhkan inovasi, misalnya sintaksis baru.  Dan sintaks baru ini dapat memecah basis kode yang ada. <br><br>  Misalnya, fungsi <code>async/await</code> .  Awalnya, tidak ada konsep seperti itu di Rust.  Tetapi ternyata primitif ini sangat berguna, mereka menyederhanakan penulisan kode asinkron. <br><br>  Untuk fungsi ini, kata kunci <code>async</code> dan <code>await</code> harus ditambahkan.  Tetapi Anda harus berhati-hati untuk tidak merusak kode lama di mana <code>async</code> atau <code>await</code> dapat digunakan sebagai nama variabel. <br><br>  Dengan demikian, kami menambahkan kata kunci di Rust 2018. Meskipun fungsi belum dirilis, kata kunci sekarang dicadangkan.  Semua perubahan yang tidak kompatibel untuk tiga tahun ke depan pengembangan (misalnya, menambahkan kata kunci baru) dilakukan sekaligus pada Rust 1.31. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/3e5/668/f56/3e5668f562d297179b8d4068b7c9be9b.png"></a> <br><br>  Meskipun ada perubahan yang tidak kompatibel di Rust 2018, ini tidak berarti bahwa kode Anda akan rusak.  Bahkan dengan variabel <code>async</code> dan <code>await</code> , kode akan dikompilasi.  Secara default, kompiler berfungsi seperti sebelumnya. <br><br>  Tetapi jika Anda ingin menggunakan salah satu fungsi baru, Anda dapat memilih mode kompilasi baru Rust 2018. Perintah <code>cargo fix</code> akan memberi tahu Anda jika Anda perlu memperbarui kode untuk menggunakan fungsi baru dan mengotomatiskan proses membuat perubahan.  Kemudian Anda dapat menambahkan <code>edition=2018</code> ke Cargo.toml Anda jika Anda setuju dengan penggunaan fungsi baru. <br><br>  Penentu versi ini di Cargo.toml tidak berlaku untuk seluruh proyek dan tidak berlaku untuk dependensi Anda.  Ini terbatas pada satu rak tertentu.  Artinya, Anda bisa menggunakan peti Rust 2015 dan Rust 2018 secara bersamaan. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/1bf/3d5/2ee/1bf3d52ee511feea588c85160bd85cf3.png"></a> <br><br>  Oleh karena itu, bahkan ketika menggunakan Rust 2018, semuanya terlihat hampir sama dengan Rust 2015. Sebagian besar perubahan diimplementasikan secara bersamaan di Rust 2018 dan Rust 2015. Hanya beberapa fungsi yang membutuhkan perubahan yang tidak kompatibel. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/7fe/b6e/f3e/7feb6ef3ece5c67c5b2aec3810ae6d74.png"></a> <br><br>  Karat 2018 tidak hanya perubahan dalam bahasa utama.  Jauh bukan hanya mereka. <br><br>  Rust 2018, pertama-tama, merupakan dorongan untuk meningkatkan produktivitas pengembang Rust, sebagian besar berkat alat yang berada di luar bahasa, serta melalui pengembangan aplikasi spesifik dan pemahaman tentang bagaimana menjadikan Rust bahasa pemrograman yang paling efektif untuk kasus-kasus ini. <br><br>  Dengan demikian, Anda dapat mewakili Rust 2018 sebagai specifier di Cargo.toml, yang digunakan untuk menyertakan beberapa fungsi yang memerlukan perubahan yang tidak kompatibel ... <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/b68/747/e52/b68747e52d57489b7f194e245b40a17a.png"></a> <br><br>  Atau Anda dapat membayangkannya pada suatu saat ketika Rust menjadi salah satu bahasa yang paling efisien untuk banyak aplikasi - ketika Anda membutuhkan kinerja, penggunaan sumber daya yang efisien, atau keandalan yang tinggi. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/ca0/1d3/29c/ca01d329c8350531ee936706fa95828f.png"></a> <br><br>  Kami lebih suka versi definisi kedua.  Jadi, mari kita lihat semua perbaikan yang dilakukan di luar bahasa, dan kemudian terjun ke bahasa itu sendiri. <br><br><h1>  Karat untuk aplikasi spesifik </h1><br>  Bahasa pemrograman tidak dapat efektif dengan sendirinya, secara abstrak.  Ini efektif dalam aplikasi tertentu.  Oleh karena itu, kami memahami bahwa tidak hanya perlu meningkatkan Karat sebagai bahasa atau alat.  Penting juga untuk menyederhanakan penggunaan Karat di area tertentu. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/16f/bde/bbf/16fbdebbf44451fdb8f6c75b78794a2a.png"></a> <br><br>  Dalam beberapa kasus, ini berarti menciptakan seperangkat alat yang sama sekali baru untuk ekosistem yang sama sekali baru.  Dalam kasus lain, memoles fungsi yang ada dan dokumentasi yang baik untuk membuatnya lebih mudah untuk menaikkan dan menjalankan sistem kerja. <br><br>  Tim pengembangan Rust telah membentuk kelompok kerja di empat bidang: <br><br><ul><li>  Perakitan web </li><li>  Aplikasi Tertanam </li><li>  Tugas jaringan </li><li>  Alat baris perintah </li></ul><br><h2>  Perakitan web </h2><br>  WebAssembly harus membuat seperangkat alat yang sama sekali baru. <br><br>  Hanya tahun lalu apakah WebAssembly memungkinkan untuk mengkompilasi bahasa seperti Rust untuk dijalankan di Internet.  Sejak itu, Rust dengan cepat menjadi bahasa terbaik untuk berintegrasi dengan aplikasi web yang ada. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/22c/92f/083/22c92f0837c668948edbf0dccc193428.png"><br><br>  Rust sangat cocok untuk pengembangan web karena dua alasan: <br><br><ol><li>  Cargo Crash Ecosystem bekerja seperti kebanyakan pengembang aplikasi web.  Gabungkan banyak modul kecil untuk membentuk aplikasi yang lebih besar.  Ini berarti bahwa Rust mudah digunakan tepat di mana Anda membutuhkannya. </li><li>  Karat memiliki sumber daya yang rendah dan tidak memerlukan runtime.  Anda tidak perlu banyak kode.  Jika Anda memiliki modul kecil yang melakukan banyak pekerjaan komputasi keras, terapkan beberapa jalur Rust untuk mempercepatnya. </li></ol><br>  Menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">web-sys dan js-sys</a> dari kode Rust, mudah untuk memanggil API web seperti <code>fetch</code> atau <code>appendChild</code> .  Dan <code>wasm-bindgen</code> membuatnya mudah untuk mendukung tipe data tingkat tinggi yang tidak didukung WebAssembly secara asli. <br><br>  Setelah menulis modul Rust WebAssembly, ada alat untuk menghubungkannya dengan mudah ke aplikasi web lainnya.  Anda dapat menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">paket-wm</a> untuk meluncurkan alat-alat ini secara otomatis, dan menjalankan modul di npm jika Anda mau. <br><br>  Lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">buku Karat dan WebAssembly untuk informasi lebih lanjut</a> . <br><br><h4>  Apa selanjutnya </h4><br>  Setelah rilis Rust 2018, pengembang berencana untuk berdiskusi dengan komunitas di mana arah untuk bekerja lebih jauh. <br><br><h2>  Aplikasi Tertanam </h2><br>  Untuk pengembangan yang disematkan, perlu untuk meningkatkan stabilitas fungsi yang ada. <br><br>  Secara teoritis, Rust selalu menjadi bahasa yang baik untuk aplikasi yang disematkan.  Ini adalah toolkit modern, yang sangat kurang untuk pengembang, dan fungsi bahasa tingkat tinggi yang sangat nyaman.  Semua ini tanpa memuat yang tidak perlu pada CPU dan memori.  Karenanya, Rust sangat bagus untuk disematkan. <br><br>  Namun dalam praktiknya ternyata berbeda.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Saluran stabil</a> tidak memiliki fungsi yang diperlukan.  Selain itu, untuk digunakan pada perangkat yang disematkan, perlu untuk mengubah perpustakaan standar.  Ini berarti bahwa orang harus mengkompilasi versi mereka sendiri dari kotak inti Rust (kotak yang digunakan dalam setiap aplikasi Karat untuk menyediakan blok bangunan dasar Rust - fungsi bawaan dan primitif). <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/162/8b8/701/1628b8701eeffba2db1c7abe75f5a018.png"></a> <br><br>  Akibatnya, pengembang bergantung pada versi eksperimental Rust.  Dan dengan tidak adanya tes otomatis, majelis eksperimental sering tidak bekerja pada mikrokontroler. <br><br>  Untuk memperbaikinya, pengembang mencoba untuk mentransfer semua fungsi yang diperlukan ke saluran yang stabil, menambahkan tes ke sistem CI untuk mikrokontroler.  Ini berarti bahwa mengubah komponen desktop tidak akan merusak versi bawaan. <br><br>  Dengan perubahan seperti itu, pengembangan sistem embedded pada Rust bergerak dari bidang eksperimen lanjutan ke bidang efisiensi normal. <br><br>  Untuk informasi lebih lanjut, lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">buku Rust for Embedded Systems</a> . <br><br><h4>  Apa selanjutnya </h4><br>  Tahun ini, Rust mendapat dukungan yang sangat baik untuk keluarga ARM Cortex-M yang populer.  Namun, banyak arsitektur yang belum didukung dengan baik.  Karat perlu diperluas untuk memberikan dukungan serupa untuk arsitektur lain. <br><br><h2>  Tugas jaringan </h2><br>  Untuk bekerja di jaringan, perlu memasukkan abstraksi kunci ke dalam bahasa: <code>async/await</code> .  Dengan demikian, pengembang dapat menggunakan idiom standar Rust bahkan dalam kode asinkron. <br><br>  Dalam tugas-tugas jaringan, Anda sering harus menunggu.  Misalnya, respons terhadap permintaan.  Jika kode disinkronkan, maka pekerjaan akan dihentikan: inti prosesor tempat kode dieksekusi tidak dapat melakukan apa-apa sampai permintaan tiba.  Tetapi dalam kode asinkron, fungsi seperti itu dapat dimasukkan ke mode siaga, sedangkan inti CPU akan melakukan sisanya. <br><br>  Pemrograman asinkron juga dimungkinkan di Rust 2015, dan ada banyak keuntungan untuk ini.  Dalam aplikasi berkinerja tinggi, aplikasi server akan menangani lebih banyak koneksi ke setiap server.  Aplikasi tertanam pada CPU single-threaded kecil mengoptimalkan penggunaan utas tunggal. <br><br>  Tetapi kelebihan ini disertai dengan kelemahan utama: untuk kode seperti itu, verifikasi pinjaman tidak berfungsi dan Anda harus menggunakan idiom Rust yang tidak standar (dan sedikit bingung).  Ini adalah manfaat dari <code>async/await</code> .  Ini memberikan kompiler informasi yang diperlukan untuk menguji pinjaman dari panggilan fungsi tidak sinkron. <br><br>  Kata kunci untuk <code>async/await</code> diimplementasikan dalam versi 1.31, meskipun saat ini tidak didukung oleh implementasi.  Sebagian besar pekerjaan selesai, dan fitur tersebut harus tersedia dalam rilis berikutnya. <br><br><h4>  Apa selanjutnya </h4><br>  Selain pengembangan tingkat rendah yang efektif, Rust dapat memberikan pengembangan aplikasi jaringan yang lebih efisien di tingkat yang lebih tinggi. <br><br>  Banyak server melakukan tugas rutin: parse URL atau bekerja dengan HTTP.  Jika Anda mengubahnya menjadi komponen - abstraksi umum yang dibagikan sebagai krat - maka akan mudah untuk menghubungkannya satu sama lain, membentuk semua jenis konfigurasi server dan kerangka kerja. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kerangka Tide</a> eksperimental <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">telah</a> dibuat untuk mengembangkan dan menguji komponen. <br><br><h2>  Alat baris perintah </h2><br>  Untuk alat-alat baris perintah, perlu untuk menggabungkan perpustakaan tingkat rendah kecil ke abstraksi tingkat tinggi dan memoles beberapa alat yang ada. <br><br>  Untuk beberapa skrip, bash sangat ideal.  Misalnya, untuk memanggil alat-alat shell lainnya dan meneruskan data di antara mereka. <br><br>  Tetapi Rust adalah pilihan bagus untuk banyak alat lainnya.  Misalnya, jika Anda membuat alat yang kompleks seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ripgrep</a> atau alat CLI di atas fungsi perpustakaan yang ada. <br><br>  Rust tidak memerlukan runtime dan mengkompilasi ke dalam biner statis tunggal, yang menyederhanakan distribusi program.  Dan Anda mendapatkan abstraksi tingkat tinggi yang tidak ada dalam bahasa lain, seperti C dan C ++. <br><br>  Apa lagi yang bisa meningkatkan Karat?  Tentu saja, abstraksi dari level yang lebih tinggi lagi. <br><br>  Dengan abstraksi tingkat yang lebih tinggi, CLI yang sudah jadi dibuat dengan cepat dan mudah. <br><br>  Contoh abstraksi semacam itu adalah perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kepanikan manusia</a> .  Dengan tidak adanya perpustakaan seperti itu, dalam hal terjadi kegagalan, kode CLI mungkin akan mengembalikan semua backtracking.  Tetapi itu tidak terlalu menarik bagi pengguna.  Anda dapat menambahkan penanganan kesalahan khusus, tetapi sulit. <br><br>  Dengan perpustakaan kepanikan manusia, output akan secara otomatis pergi ke file dump kesalahan.  Pengguna akan melihat penawaran pesan informatif untuk melaporkan masalah dan mengunduh file dump. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ecb/f4a/908/ecbf4a90823e7b1d83ce1688b5d7383a.png"><br><br>  Mulai mengembangkan alat-alat CLI juga menjadi lebih mudah.  Sebagai contoh, perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">confy</a> mengotomatiskan konfigurasinya.  Dia hanya bertanya dua hal: <br><br><ul><li>  Apa nama aplikasi itu? </li><li>  Parameter konfigurasi apa yang ingin Anda berikan (yang Anda tetapkan sebagai struktur yang dapat diserialisasi dan diurai-kan)? </li></ul><br>  Confy akan menentukan segalanya dengan sendirinya. <br><br><h4>  Apa selanjutnya </h4><br>  Kami mengabstraksikan banyak tugas untuk CLI.  Tetapi ada sesuatu yang lain untuk abstrak.  Kami akan merilis lebih banyak perpustakaan tingkat tinggi tersebut. <br><br><h1>  Alat Karat </h1><br><img src="https://habrastorage.org/getpro/habr/post_images/e6e/2cf/090/e6e2cf09085886f3c044fcec3ce86ed7.png"><br><br>  Ketika Anda menulis dalam bahasa apa pun, Anda bekerja dengan alat-alatnya: mulai dengan editor dan melanjutkan dengan alat-alat lain di semua tahap pengembangan dan dukungan. <br><br>  Ini berarti bahwa bahasa yang efektif tergantung pada alat yang efektif. <br><br>  Berikut adalah beberapa alat baru (dan perbaikan yang ada) di Rust 2018. <br><br><h2>  Dukungan IDE </h2><br>  Tentu saja, kinerja tergantung pada transfer kode yang cepat dan lancar dari pikiran pengembang ke layar komputer.  Di sinilah dukungan IDE sangat penting.  Untuk melakukan ini, kita memerlukan alat yang dapat "menjelaskan" IDE dengan arti kode Rust: misalnya, menyarankan opsi yang bermakna untuk pelengkapan string secara otomatis. <br><br>  Di Rust 2018, komunitas fokus pada fitur yang dibutuhkan oleh IDE.  Dengan munculnya Server Bahasa Rust dan IntelliJ Rust, banyak IDE sekarang sepenuhnya mendukung Rust. <br><br><h2>  Kompilasi lebih cepat </h2><br>  Meningkatkan kinerja kompiler berarti mempercepatnya.  Inilah yang kami lakukan. <br><br>  Sebelumnya, ketika Anda mengkompilasi peti Rust, kompiler mengkompilasi ulang setiap file dalam peti tersebut.  Kompilasi tambahan sekarang diterapkan: kompilasi hanya bagian-bagian yang telah berubah.  Bersama dengan optimasi lainnya, ini membuat kompiler Rust jauh lebih cepat. <br><br><h2>  rustfmt </h2><br>  Efisiensi juga mengharuskan kami tidak pernah berdebat tentang aturan pemformatan kode atau memperbaiki gaya orang lain secara manual. <br><br>  Alat rustfmt membantu dengan ini: ia akan memformat ulang kode secara otomatis sesuai dengan gaya default (yang olehnya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">komunitas telah mencapai konsensus</a> ).  Rustfmt memastikan bahwa semua kode Rust cocok dengan gaya yang sama, seperti format dentang untuk C ++ atau Lebih cantik untuk JavaScript. <br><br><h2>  Clippy </h2><br>  Terkadang senang memiliki konsultan berpengalaman di dekat Anda memberikan saran tentang praktik terbaik untuk menulis kode.  Inilah yang dilakukan Clippy: memeriksa kode sambil melihatnya dan menyarankan idiom standar. <br><br><h2>  perbaikan karat </h2><br>  Tetapi jika Anda memiliki basis kode lama dengan idiom yang sudah usang, maka verifikasi dan perbaiki kode secara mandiri dapat melelahkan.  Anda hanya ingin seseorang membuat koreksi ke seluruh basis kode. <br><br>  Dalam kasus ini, perbaikan karat mengotomatiskan proses.  Secara bersamaan berlaku aturan dari alat-alat seperti Clippy, dan memperbarui kode lama sesuai dengan idiom Rust 2018. <br><br><h1>  Perubahan ke Rust sendiri </h1><br>  Perubahan ekosistem telah secara signifikan meningkatkan efisiensi pemrograman.  Tetapi beberapa masalah hanya bisa diselesaikan dengan perubahan dalam bahasa itu sendiri. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e54/ec4/993/e54ec49930ed33cb1eac85814f10e7b5.png"><br><br>  Seperti yang kami katakan dalam pendahuluan, sebagian besar perubahan bahasa sepenuhnya kompatibel dengan kode Rust yang ada.  Semua perubahan ini adalah bagian dari Rust 2018. Tetapi karena mereka tidak merusak apa pun, mereka bekerja dalam kode Rust apa pun ... bahkan dalam yang lama. <br><br>  Mari kita lihat fitur-fitur penting yang ditambahkan ke semua versi.  Kemudian lihat daftar singkat fitur Rust 2018. <br><br><h2>  Fitur baru untuk semua versi </h2><br>  Berikut adalah contoh kecil dari fitur-fitur baru yang (atau akan) ada di semua versi bahasa. <br><br><h4>  Verifikasi pinjaman yang lebih akurat </h4><br>  Satu keuntungan besar dari Rust adalah verifikasi pinjamannya.  Ini memastikan bahwa kode tersebut aman memori.  Tapi ini juga fitur yang cukup rumit bagi pemula untuk Rust. <br><br>  Bagian dari kesulitannya terletak pada mempelajari konsep-konsep baru.  Tetapi ada bagian lain ... Pengujian pinjaman terkadang menolak kode yang tampaknya bekerja dari sudut pandang seorang programmer yang sepenuhnya memahami konsep keamanan memori. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/d5c/84e/629/d5c84e629b289c9fa88ef9316a4c59a3.png"></a> <br>  <i><font color="gray">Anda tidak dapat meminjam variabel karena sudah dipinjam</font></i> <br><br>  Ini terjadi karena masa pinjaman seharusnya meluas ke akhir bidangnya - misalnya, ke akhir fungsi di mana variabel berada. <br><br>  Ini berarti bahwa bahkan jika variabel selesai bekerja dengan nilai dan tidak lagi mencoba mengakses, variabel lain masih ditolak akses ke nilai ini hingga akhir fungsi. <br><br>  Untuk memperbaiki situasi, kami membuat pemeriksaan menjadi lebih cerdas.  Sekarang dia melihat ketika variabel <i>benar</i> - <i>benar</i> selesai menggunakan nilai.  Setelah itu, itu tidak menghalangi penggunaan data. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/0cb/a0c/805/0cba0c80529d7132ffea917007f9e08b.png"></a> <br><br>  Meskipun ini hanya tersedia di Rust 2018, tetapi dalam waktu dekat fungsi akan ditambahkan ke semua versi lainnya.  Kami akan segera menulis lebih banyak tentang topik ini. <br><br><h4>  Makro Prosedural dalam Karat Stabil </h4><br>  Rust memiliki makro sebelum Rust 1.0.  Tetapi dalam Rust 2018, perbaikan serius dilakukan, misalnya, macro prosedural muncul.  Mereka memungkinkan Anda untuk menambahkan sintaks Anda sendiri ke Rust. <br><br>  Rust 2018 menawarkan dua jenis makro prosedural: <br><br><h4>  Makro fungsi </h4><br>  Makro mirip fungsi memungkinkan Anda untuk membuat objek yang terlihat seperti panggilan fungsi normal, tetapi sebenarnya dieksekusi pada waktu kompilasi.  Mereka mengambil satu kode dan memberikan yang lain, yang kemudian dimasukkan oleh kompiler ke dalam biner. <br><br>  Mereka ada sebelumnya, tetapi dengan terbatas.  Makro hanya bisa menjalankan pernyataan pertandingan.  Dia tidak memiliki akses untuk melihat semua token dalam kode yang masuk. <br><br>  Tetapi dengan macro prosedural, Anda mendapatkan input yang sama dengan parser: aliran token yang sama.  Ini berarti Anda dapat membuat fungsi makro yang jauh lebih kuat. <br><br><h4>  Makro seperti atribut </h4><br>  Jika Anda terbiasa dengan dekorator dalam bahasa seperti JavaScript, atribut makro sangat mirip.  Mereka memungkinkan Anda untuk membubuhi keterangan fragmen kode Rust yang harus diproses sebelumnya dan berubah menjadi sesuatu yang lain. <br><br>  <code>derive</code> makro tidak hanya itu.  Ketika Anda meletakkannya di atas suatu struktur, kompiler mengambil struktur itu (setelah diuraikan sebagai daftar token) dan memprosesnya.  Secara khusus, ini menambahkan implementasi fungsi dasar dari sifat. <br><br><h4>  Perbandingan pinjaman yang lebih ergonomis </h4><br>  Ada perubahan sederhana. <br><br>  Sebelumnya, jika Anda ingin meminjam sesuatu dan mencoba mencocokkan, Anda harus menambahkan beberapa sintaks aneh: <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/91c/a80/cc5/91ca80cc5221b9bfd18473567eac6d87.png"></a> <br><br>  Sekarang, alih-alih <code>&amp;Some(ref s)</code> kita cukup menulis <code>Some(s)</code> . <br><br><h1>  Fitur Baru Rust 2018 </h1><br>  Bagian terkecil dari Rust 2018 adalah fitur khusus untuk versi ini.  Berikut adalah sejumlah kecil perubahan di Rust 2018. <br><br><h3>  Kata kunci </h3><br>  Rust 2018 menambahkan beberapa kata kunci: <br><br><ul><li> <code>try</code> </li> <li> <code>async/await</code> </li> </ul><br>  Fitur-fitur ini belum sepenuhnya diimplementasikan, tetapi kata kunci ditambahkan di Rust 1.31.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Karenanya, di masa mendatang kami tidak perlu memperkenalkan kata kunci baru (yang akan menjadi perubahan yang tidak kompatibel) ketika kami menerapkan fungsi-fungsi ini. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sistem modular </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Satu rasa sakit besar bagi pemula untuk Rust adalah sistem modular. </font><font style="vertical-align: inherit;">Dan jelas mengapa. </font><font style="vertical-align: inherit;">Sulit dimengerti mengapa Rust memilih modul tertentu. </font><font style="vertical-align: inherit;">Untuk memperbaiki ini, kami membuat beberapa perubahan pada mekanisme jalur. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Misalnya, jika Anda mengimpor rak, Anda dapat menggunakannya di jalur di tingkat atas. </font><font style="vertical-align: inherit;">Tetapi jika Anda memindahkan kode apa pun ke submodule, itu tidak akan berfungsi lagi.</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// top level module extern crate serde; // this works fine at the top level impl serde::Serialize for MyType { ... } mod foo { // but it does *not* work in a sub-module impl serde::Serialize for OtherType { ... } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contoh lain adalah awalan </font></font><code>::</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, yang digunakan untuk root peti dan peti eksternal. </font><font style="vertical-align: inherit;">Sulit untuk memahami apa yang ada di hadapan kita. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami membuatnya lebih eksplisit. </font><font style="vertical-align: inherit;">Sekarang jika Anda ingin merujuk ke kotak root, kemudian gunakan awalan </font></font><code>crate::</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ini hanyalah salah satu perbaikan untuk kejelasan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika Anda ingin kode saat ini menggunakan kemampuan Rust 2018, kemungkinan besar, Anda perlu memperbarui kode untuk mempertimbangkan jalur baru akun. </font><font style="vertical-align: inherit;">Tetapi tidak perlu melakukan ini secara manual. </font><font style="vertical-align: inherit;">Sebelum menambahkan specifier versi ke Cargo.toml, jalankan saja </font></font><code>cargo fix</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>rustfix</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">buat perubahan yang diperlukan.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Informasi tambahan </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Semua informasi tentang versi baru bahasa terdapat </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dalam Panduan Rust 2018</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id432564/">https://habr.com/ru/post/id432564/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id432554/index.html">Douglas Engelbart: Memperkuat Masyarakat "Kolektif IQ"</a></li>
<li><a href="../id432556/index.html">Teknologi yang dipatenkan Tesla untuk penentuan posisi kendaraan</a></li>
<li><a href="../id432558/index.html">Pola arsitektur "Pengunjung" di alam semesta "iOS" dan "Swift"</a></li>
<li><a href="../id432560/index.html">Tipografi di web. Kuliah Yandex di FrontTalks 2018</a></li>
<li><a href="../id432562/index.html">Techday Membuat IT Nyata - 17 Desember, Moskow</a></li>
<li><a href="../id432566/index.html">Dua dunia atau "insinyur memiliki sesuatu untuk dikatakan." Pada berbagai jenis tugas kompleks dan proses yang terkait dengannya</a></li>
<li><a href="../id432568/index.html">"Ketika Anda adalah pemimpin redaksi Rusbase": podcast baru tentang bekerja dengan konten dan berkarir di media teknologi</a></li>
<li><a href="../id432572/index.html">Transistor metal-to-air akan memperluas Hukum Moore - bagaimana teknologi bekerja</a></li>
<li><a href="../id432574/index.html">Desain canggih perangkat sederhana</a></li>
<li><a href="../id432576/index.html">Di bawah tenda JobIntentService</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>