<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍🍳 🧓🏻 🎾 使用SharedEvents进行角色管理 🤤 🥡 👨‍⚖️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="链接到项目 

 在本文中，我想展示如何使用SharedEvents来控制提供标准资产集的第三人称角色。 我在之前的文章（ this和this ）中写了有关SharedEvents的文章。 

 欢迎来到猫！ 

 您需要做的第一件事是采用一个已实现SharedState / SharedEvent...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>使用SharedEvents进行角色管理</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/439194/"><iframe width="560" height="315" src="https://www.youtube.com/embed/v3lTKkwBDyE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">链接到项目</a> <br><br> 在本文中，我想展示如何使用<b>SharedEvents</b>来控制提供标准资产集的第三人称角色。 我在之前的文章（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">this</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">this</a> ）中写了有关<b>SharedEvents</b>的文章。 <br><br> 欢迎来到猫！ <br><a name="habracut"></a><br> 您需要做的第一件事是采用一个已实现SharedState / SharedEvents的项目并添加一组标准资产 <br><br><img src="https://habrastorage.org/webt/3e/6p/if/3e6pifqmbgtgupypezxrm6lqr08.jpeg"><br><br> 我通过预制件原型制作了一个很小且非常简单的场景 <br><br><img src="https://habrastorage.org/webt/i2/gt/zu/i2gtzu4zyhrlbjdg5qahs3wti18.jpeg"><br><br> 并使用标准设置烘焙表面导航 <br><br><img src="https://habrastorage.org/webt/tl/ci/if/tlciif79oujqrvkaln_tsajxjgo.jpeg"><br><br> 之后，您需要将预制的<b>ThirdPersonCharacter</b>添加到该场景 <br><br><img src="https://habrastorage.org/webt/ut/vj/uo/utvjuofiddf4gcrwnf4rr-cfpvs.jpeg"><br><br> 然后，您可以开始并确保一切正常可用。 然后，您可以继续配置先前创建的<b>SharedState / SharedEvents基础</b>结构的使用。 为此，请从角色对象中删除<b>ThirdPersonUserController</b>组件。 <br><br><img src="https://habrastorage.org/webt/8f/gy/hu/8fgyhuqj2hafnuwss-mqebno_jw.jpeg"><br><br> 因为不需要使用键盘进行手动控制。 角色将由代理控制，指示其将移动的位置。 <br><br> 为此，您需要将<b>NavMeshAgent</b>组件添加并配置到角色对象 <br><br><img src="https://habrastorage.org/webt/sf/yq/qs/sfyqqsgrktyfnqwobzc_nkqtuxw.jpeg"><br><br> 现在您需要创建一个简单的控制器来控制角色 <br> 用鼠标<b>AgentMouseController</b> <br><br><img src="https://habrastorage.org/webt/p0/xf/nd/p0xfndfiw52su5yd7pu5mnkhlae.jpeg"><br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.AI; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityStandardAssets.Characters.ThirdPerson; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AgentMouseController</span></span></span><span class="hljs-class"> :</span></span> MonoBehaviour { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> NavMeshAgent agent; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ThirdPersonCharacter character; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Camera cam; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//      agent.updateRotation = false; } void Update() { //     if (Input.GetMouseButtonDown(0)) { Ray ray = cam.ScreenPointToRay(Input.mousePosition); RaycastHit hit; if (Physics.Raycast(ray, out hit)) { agent.SetDestination(hit.point); } } //    ,     if(agent.remainingDistance &gt; agent.stoppingDistance) { character.Move(agent.desiredVelocity, false, false); } else // ,    { character.Move(Vector3.zero, false, false); } } }</span></span></code> </pre> <br> 并将其添加到角色的对象中，为其提供到摄像机，角色的控制器和代理的链接。 舞台上都可以使用。 <br><br><img src="https://habrastorage.org/webt/6i/_a/p3/6i_ap3pgbgxkvkl9h4pl0c4mbzi.jpeg"><br><br> 仅此而已。 这足以通过使用鼠标（单击鼠标左键）告诉代理将位置移动来控制角色。 <br><br> 您可以开始并确保一切正常 <br><br><img src="https://habrastorage.org/webt/3n/n_/g-/3nn_g-peo8ivng5gop0l5-75dta.jpeg"><br><br><h2>  SharedEvents集成 </h2><br> 现在基本场景已经准备就绪，您可以继续通过<b>SharedEvents</b>集成角色控制。 为此，您将需要创建几个组件。 其中的第一个是负责接收来自鼠标的信号并通知所有在场景中跟踪鼠标单击位置的组件的组件，它们将仅对单击的坐标感兴趣。 <br><br> 该组件将被称为，例如<b>MouseHandlerComponent</b> <br><br><img src="https://habrastorage.org/webt/ib/yk/v4/ibykv4n3mal6i1lfatsrjyto-ha.jpeg"><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MouseHandlerComponent</span></span></span><span class="hljs-class"> :</span></span> SharedStateComponent { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Camera cam; <span class="hljs-meta"><span class="hljs-meta">#region MonoBehaviour protected override void OnSharedStateChanged(SharedStateChangedEventData newState) { } protected override void OnStart() { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (cam == null) throw new MissingReferenceException(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"   "</span></span></span><span class="hljs-meta">); } protected override void OnUpdate() { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//     if (Input.GetMouseButtonDown(0)) { //           var hit = GetMouseHit(); Events.PublishAsync("poittogound", new PointOnGroundEventData { Sender = this, Point = hit.point }); } } #endregion private RaycastHit GetMouseHit() { Ray ray = cam.ScreenPointToRay(Input.mousePosition); RaycastHit hit; Physics.Raycast(ray, out hit); return hit; } }</span></span></span></span></code> </pre><br> 该组件需要一个类来发送通知中的数据。 对于仅包含通知数据的此类，您可以创建一个文件并将其命名为<b>DefinedEventsData</b> <br><br><img src="https://habrastorage.org/webt/5y/bp/ar/5ybparw0g4vguy5tkbyttntdodm.jpeg"><br><br> 并添加一个类，以使用鼠标发送点击位置 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PointOnGroundEventData</span></span></span><span class="hljs-class"> :</span></span> EventData { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector3 Point { get; <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>; } }</code> </pre><br> 接下来要做的就是为<b>NavMeshAgent</b>组件添加一个包装或装饰器的组件。 由于我不会更改现有（第3方）组件，因此将使用装饰器与<b>SharedState / SharedEvents</b>集成。 <br><br><img src="https://habrastorage.org/webt/yi/1k/v5/yi1kv5s0ytqgy7folh3tygjmtky.jpeg"><br><br> 该组件将在场景中的某些点接收有关鼠标单击的通知，并告诉座席将移动到何处。 并且还监视代理位置在每个框架中的位置，并创建有关其更改的通知。 <br><br> 该组件将取决于<b>NavMeshAgent</b>组件<b>。</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.AI; [RequireComponent(typeof(NavMeshAgent))] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AgentWrapperComponent</span></span></span><span class="hljs-class"> :</span></span> SharedStateComponent { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> NavMeshAgent agent; <span class="hljs-meta"><span class="hljs-meta">#region Monobehaviour protected override void OnSharedStateChanged(SharedStateChangedEventData newState) { } protected override void OnStart() { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//  agent = GetComponent&lt;NavMeshAgent&gt;(); //      agent.updateRotation = false; Events.Subscribe&lt;PointOnGroundEventData&gt;("pointtoground", OnPointToGroundGot); } protected override void OnUpdate() { //     if (agent.remainingDistance &gt; agent.stoppingDistance) { Events.Publish("agentmoved", new AgentMoveEventData { Sender = this, DesiredVelocity = agent.desiredVelocity }); } else { Events.Publish("agentmoved", new AgentMoveEventData { Sender = this, DesiredVelocity = Vector3.zero }); } } #endregion private void OnPointToGroundGot(PointOnGroundEventData eventData) { //    agent.SetDestination(eventData.Point); } }</span></span></span></span></code> </pre> <br><br> 要发送数据，此组件需要一个类，该类需要添加到<b>DefinedEventsData</b>文件中<b>。</b> <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AgentMoveEventData</span></span></span><span class="hljs-class"> :</span></span> EventData { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector3 DesiredVelocity { get; <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>; } }</code> </pre> <br> 这足以使角色移动。 但是他会在没有动画的情况下完成此操作，因为我们还没有使用<b>ThirdPersonCharater</b> 。 为此，就像对于<b>NavMeshAgent一样，</b>您需要创建一个CharacterWrapperComponent装饰器 <br><br><img src="https://habrastorage.org/webt/j1/zz/h_/j1zzh_hp8qcyklhx3zeldtjrsn4.jpeg"><br><br> 该组件将侦听有关座席位置更改的通知，并沿从通知（事件）接收的方向移动角色。 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityStandardAssets.Characters.ThirdPerson; [RequireComponent(typeof(ThirdPersonCharacter))] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CharacterWrapperComponent</span></span></span><span class="hljs-class"> :</span></span> SharedStateComponent { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ThirdPersonCharacter character; <span class="hljs-meta"><span class="hljs-meta">#region Monobehaviour protected override void OnSharedStateChanged(SharedStateChangedEventData newState) { } protected override void OnStart() { character = GetComponent</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;ThirdPersonCharacter&gt;(); Events.Subscribe&lt;AgentMoveEventData&gt;("agentmoved", OnAgentMove); } protected override void OnUpdate() { } #endregion private void OnAgentMove(AgentMoveEventData eventData) { //       character.Move(eventData.DesiredVelocity, false, false); } }</span></span></span></span></code> </pre> <br> 仅此而已。 仍然需要将这些组件添加到角色的游戏对象中。 您需要从现有的副本创建副本，删除旧的<b>AgentMouseControl</b>组件 <br><br><img src="https://habrastorage.org/webt/az/_c/yk/az_cyk_etfyxuabjqhrbjiqxsoy.jpeg"><br><br> 并添加新的<b>MouseHandlerComponent</b> ， <b>AgentWrapperComponent</b>和<b>CharacterWrapperComponent</b> 。 <br><br> 在<b>MouseHandlerComponent中，</b>您需要从要计算点击位置的场景中转移摄像机。 <br><br><img src="https://habrastorage.org/webt/wv/fa/lm/wvfalm5obqvcach5uvnazlsuggu.jpeg"><br><br><img src="https://habrastorage.org/webt/vi/lq/b4/vilqb40pamgox4vbcmvogziuucw.jpeg"><br><br> 您可以开始并确保一切正常。 <br><br> 就像在第一个示例中一样，借助<b>SharedEvents</b>来控制字符而在组件之间没有直接连接的情况下发生了这种情况。 这将允许对组件的不同组成进行更灵活的配置，并自定义它们之间的交互。 <br><br><h2>  SharedEvents的异步行为 </h2><br> 现在实现通知机制的方式是基于信号的同步传输及其处理。 也就是说，侦听器越多，处理时间就越长。 为了避免这种情况，您需要实现异步通知处理。 首先要做的是添加<b>Publish</b>方法的异步版本 <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  data    eventName  public async Task PublishAsync&lt;T&gt;(string eventName, T data) where T : EventData { if (_subscribers.ContainsKey(eventName)) { var listOfDelegates = _subscribers[eventName]; var tasks = new List&lt;Task&gt;(); foreach (Action&lt;T&gt; callback in listOfDelegates) { tasks.Add(Task.Run(() =&gt; { callback(data); })); } await Task.WhenAll(tasks); } }</span></span></code> </pre> <br> 现在，您需要将<b>SharedStateComponent</b>基类中的抽象<b>OnUpdate</b>方法更改为异步，以便它返回在此方法的实现内部启动的任务，并将其重命名为<b>OnUpdateAsync</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> abstract Task[] OnUpdateAsync();</code> </pre> <br> 您还需要一种机制来控制当前框架之前的前一个框架的任务完成情况 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Task[] _previosFrameTasks = null; <span class="hljs-comment"><span class="hljs-comment">//   private async Task CompletePreviousTasks() { if (_previosFrameTasks != null &amp;&amp; _previosFrameTasks.Length &gt; 0) await Task.WhenAll(_previosFrameTasks); }</span></span></code> </pre> <br> 基类中的<b>Update</b>方法需要标记为<b>异步</b>并预先检查以前任务的执行情况 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">async </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-function">await </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CompletePreviousTasks</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">//     _previosFrameTasks = OnUpdateAsync(); }</span></span></code> </pre> <br> 在基类中进行了这些更改之后，您可以继续将旧的<b>OnUpdate</b>方法的实现更改为新的<b>OnUpdateAsync</b> 。 将完成此操作的第一个组件是<b>AgentWrapperComponent</b> 。 现在，此方法期望返回结果。 结果将是一系列任务。 一个数组，因为在该方法中可以并行启动多个数组，因此我们将一堆处理它们。 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> override Task[] OnUpdateAsync() { <span class="hljs-comment"><span class="hljs-comment">//     if (agent.remainingDistance &gt; agent.stoppingDistance) { return new Task[] { Events.PublishAsync("agentmoved", new AgentMoveEventData { Sender = this, DesiredVelocity = agent.desiredVelocity }) }; } else { return new Task[] { Events.PublishAsync("agentmoved", new AgentMoveEventData { Sender = this, DesiredVelocity = Vector3.zero }) }; } }</span></span></code> </pre> <br> 更改<b>OnUpdate</b>方法的下一个候选对象是<b>MouseHandlerController</b> 。 这里的原理是一样的 <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> override Task[] OnUpdateAsync() { <span class="hljs-comment"><span class="hljs-comment">//     if (Input.GetMouseButtonDown(0)) { //           var hit = GetMouseHit(); return new Task[] { Events.PublishAsync("pointtoground", new PointOnGroundEventData { Sender = this, Point = hit.point }) }; } return null; }</span></span></code> </pre><br> 在此方法为空的所有其他实现中，只需将其替换为 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> override Task[] OnUpdateAsync() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; }</code> </pre> <br> 仅此而已。 现在，您可以开始操作，并且如果异步处理通知的组件不访问应在主线程中处理的那些组件（例如Transform），那么一切都会正常。 否则，我们将在控制台中收到错误消息，通知我们不是从主线程访问这些组件 <br><br><img src="https://habrastorage.org/webt/sp/hq/it/sphqitlfyw2zspaznnsu0tec3sy.jpeg"><br><br> 要解决此问题，您需要创建一个组件，该组件将处理主线程中的代码。 为脚本创建一个单独的文件夹，并将其命名为System，然后向其中添加<b>Dispatcher</b>脚本。 <br><br><img src="https://habrastorage.org/webt/m2/gp/m2/m2gpm2tf3u8z6fn1ioov9brmhvu.jpeg"><br><br> 该组件将是一个单例，并具有一个公共抽象方法，该方法将在主线程中执行代码。 调度程序的原理很简单。 我们将把要在主线程中执行的委托传递给他，他会将他们放入队列。 并且在每个帧中，如果队列中有内容，请在主线程中执行。 我喜欢这种简单有效的方法，该组件将自己添加到单个副本中。 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Concurrent; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Dispatcher</span></span></span><span class="hljs-class"> :</span></span> MonoBehaviour { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Dispatcher _instance; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> _queued = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ConcurrentQueue&lt;Action&gt; _queue = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConcurrentQueue&lt;Action&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> readonly object _sync_ = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> object(); <span class="hljs-comment"><span class="hljs-comment">//     public static void RunOnMainThread(Action action) { _instance._queue.Enqueue(action); lock (_sync_) { _instance._queued = true; } } //       () [RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)] private static void Initialize() { if (_instance == null) { _instance = new GameObject("Dispatcher").AddComponent&lt;Dispatcher&gt;(); DontDestroyOnLoad(_instance.gameObject); } } void Update() { if (_queued) //   { while (!_queue.IsEmpty) { if (_queue.TryDequeue(out Action a)) { StartCoroutine(ActionWrapper(a)); } } lock (_sync_) { _queued = false; } } } //    IEnumerator ActionWrapper(Action a) { a(); yield return null; } }</span></span></code> </pre> <br> 接下来要做的就是应用调度程序。 有2个地方可以做到这一点。 第一个是角色的装饰工，我们问他方向。 在<b>CharacterWrapperComponent</b>组件中 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnAgentMove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AgentMoveEventData eventData)</span></span></span><span class="hljs-function"> </span></span>{ Dispatcher.RunOnMainThread(() =&gt; character.Move(eventData.DesiredVelocity, <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>)); }</code> </pre> <br> 第二个是代理的装饰器，我们在其中指示代理的位置。 在<b>AgentWrapperComponent</b>组件中 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnPointToGroundGot</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PointOnGroundEventData eventData)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    Dispatcher.RunOnMainThread(() =&gt; agent.SetDestination(eventData.Point)); }</span></span></code> </pre> <br> 现在将没有错误，代码将正常工作。 您可以开始查看。 <br><br><h2> 一点重构 </h2><br> 在一切准备就绪并且一切正常之后，您可以对代码进行一些梳理，使其更加方便和简单。 这将需要一些更改。 <br><br> 为了不创建任务数组并将其仅手动放入其中，可以创建扩展方法。 对于所有扩展方法，您可以使用同一文件将其传输到通知以及所有类。 它将位于<b>系统</b>文件夹中，称为<b>扩展</b> <br><br><img src="https://habrastorage.org/webt/8z/nv/wx/8znvwxom9bvxipj5ctvuuasveky.jpeg"><br><br> 在内部，我们将创建一个简单的通用扩展方法，该方法会将所有实例包装在数组中 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Extensions</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">//    public static T[] WrapToArray&lt;T&gt;(this T source) { return new T[] { source }; } }</span></span></code> </pre> <br> 下一步更改是将调度程序的直接使用隐藏在组件中。 而是在<b>SharedStateComponent</b>基类中创建一个方法，然后从那里使用调度程序。 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PerformInMainThread</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Action action)</span></span></span><span class="hljs-function"> </span></span>{ Dispatcher.RunOnMainThread(action); }</code> </pre><br> 现在，您需要在多个位置应用这些更改。 首先，更改我们手动创建任务数组并将其放入单个实例的方法 <br> 在<b>AgentWrapperComponent</b>组件中 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> override Task[] OnUpdateAsync() { <span class="hljs-comment"><span class="hljs-comment">//     if (agent.remainingDistance &gt; agent.stoppingDistance) { return Events.PublishAsync("agentmoved", new AgentMoveEventData { Sender = this, DesiredVelocity = agent.desiredVelocity }) .WrapToArray(); } else { return Events.PublishAsync("agentmoved", new AgentMoveEventData { Sender = this, DesiredVelocity = Vector3.zero }) .WrapToArray(); } }</span></span></code> </pre> <br> 并在组件<b>MouseHandlerComponent中</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> override Task[] OnUpdateAsync() { <span class="hljs-comment"><span class="hljs-comment">//     if (Input.GetMouseButtonDown(0)) { //           var hit = GetMouseHit(); return Events.PublishAsync("pointtoground", new PointOnGroundEventData { Sender = this, Point = hit.point }) .WrapToArray(); } return null; }</span></span></code> </pre> <br> 现在，我们摆脱了直接在组件中使用调度程序的功能，而是在基类中调用<b>PerformInMainThread</b>方法。 <br><br> 首先在<b>AgentWrapperComponent中</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnPointToGroundGot</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PointOnGroundEventData eventData)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    PerformInMainThread(() =&gt; agent.SetDestination(eventData.Point)); }</span></span></code> </pre> <br> 并在<b>CharacterWrapperComponent</b>组件中 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnAgentMove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AgentMoveEventData eventData)</span></span></span><span class="hljs-function"> </span></span>{ PerformInMainThread(() =&gt; character.Move(eventData.DesiredVelocity, <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>)); }</code> </pre> <br> 仅此而已。 仍然可以运行游戏，并确保在重构​​期间没有任何损坏，并且一切正常。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN439194/">https://habr.com/ru/post/zh-CN439194/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN439182/index.html">我们如何在Yandex.Taxi中在驱动程序之间分配订单</a></li>
<li><a href="../zh-CN439184/index.html">更改密码：测试Web服务密码策略</a></li>
<li><a href="../zh-CN439186/index.html">UX编辑器：真实的故事，真实的生活</a></li>
<li><a href="../zh-CN439190/index.html">如何使用ARCore创建增强现实应用程序</a></li>
<li><a href="../zh-CN439192/index.html">PC扬声器到十一</a></li>
<li><a href="../zh-CN439196/index.html">摩根大通分析师：苹果应收购暴雪，Netflix或Sonos以使投资者放心</a></li>
<li><a href="../zh-CN439198/index.html">屏障岛一代</a></li>
<li><a href="../zh-CN439200/index.html">小孩子的作曲家</a></li>
<li><a href="../zh-CN439202/index.html">使用Seq2Seq自动编码器的Web攻击检测</a></li>
<li><a href="../zh-CN439204/index.html">通过植物遗传修饰提高光合作用的效率</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>