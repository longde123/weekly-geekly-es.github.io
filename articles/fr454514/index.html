<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üìÖ ü§úüèæ ü§úüèº D√©veloppement d'un synth√©tiseur musical simple sur ATMEGA8 üì≤ ‚úäüèª üë©üèΩ‚Äçüåæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Il y a quelques ann√©es, j'ai r√©alis√© un r√©veil sur le microcontr√¥leur ATmega8, o√π j'ai impl√©ment√© un synth√©tiseur de m√©lodie simple √† une seule tonali...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>D√©veloppement d'un synth√©tiseur musical simple sur ATMEGA8</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/454514/">  Il y a quelques ann√©es, j'ai r√©alis√© un r√©veil sur le microcontr√¥leur ATmega8, o√π j'ai impl√©ment√© un synth√©tiseur de m√©lodie simple √† une seule tonalit√© (une seule voix).  Il existe de nombreux articles sur Internet pour les d√©butants sur ce sujet.  En r√®gle g√©n√©rale, un minuteur 16 bits est utilis√© pour g√©n√©rer la fr√©quence (notes), qui est configur√©e d'une certaine mani√®re, for√ßant au niveau mat√©riel √† √©mettre un signal sous la forme d'un m√©andre sur une broche sp√©cifique du MC.  Le deuxi√®me temporisateur (8 bits) est utilis√© pour impl√©menter la dur√©e d'une note ou d'une pause.  Les notes selon des formules bien connues sont compar√©es aux fr√©quences, et elles sont √† leur tour compar√©es √† certains nombres √† 16 bits, inversement proportionnels aux fr√©quences qui sp√©cifient les p√©riodes de comptage de la minuterie. <br><a name="habracut"></a><br>  Dans ma conception, j'ai fourni trois m√©lodies √©crites dans la m√™me tonalit√© et la m√™me √©chelle.  J'ai donc d√ª utiliser un nombre limit√© et certain de notes, ce qui a facilit√© la mod√©lisation.  De plus, les trois morceaux ont √©t√© jou√©s au m√™me rythme.  Le code de note et son code de dur√©e tiennent facilement dans un octet.  Le seul inconv√©nient de ce mod√®le √©tait le manque de polyvalence, la capacit√© √† √©diter, remplacer ou compl√©ter rapidement la m√©lodie.  Pour enregistrer une m√©lodie, je l'ai d'abord esquiss√©e dans un √©diteur de musique sur un ordinateur, puis copi√© les notes et leur dur√©e, avec la num√©rotation dont j'ai d√©cid√© √† l'avance, puis form√© les octets r√©sultants.  J'ai fait les derni√®res op√©rations en utilisant le programme Excel. <br><br>  √Ä l'avenir, je voulais √©liminer l'inconv√©nient susmentionn√©, trahir le design d'une certaine universalit√© et r√©duire le temps de mise en ≈ìuvre de la m√©lodie.  Il y avait une telle id√©e que le programme MK lisait les octets d'un des formats de musique c√©l√®bres.  Le plus populaire et le plus courant est le format MIDI.  Plus litt√©ralement, ce n'est pas tant un format que toute une ¬´science¬ª qui peut √™tre lue sur Internet.  La sp√©cification MIDI d√©finit le protocole de transmission des messages en temps r√©el sur l'interface physique correspondante et d√©crit comment les fichiers midi sont organis√©s dans lesquels ces messages peuvent √™tre stock√©s.  Le format midi √©tant orient√© musique, il trouve donc application dans le domaine concern√©.  Il s'agit d'un contr√¥le synchrone de l'√©quipement sonore, de la musique en couleur, des synth√©tiseurs musicaux et des robots, etc.  Dans le domaine domestique, le format midi a √©t√© rencontr√© √† l'√©poque du d√©but du d√©veloppement des t√©l√©phones portables.  Dans ce cas, des messages concernant l'inclusion ou la d√©sactivation d'une note particuli√®re, des informations sur un instrument de musique, le volume des notes sonores, etc. sont enregistr√©s dans le fichier midi.  Le t√©l√©phone portable qui lit un tel fichier contient un synth√©tiseur qui interpr√®te les messages midi de ce fichier en temps r√©el et joue la m√©lodie.  Au tout d√©but, les t√©l√©phones ne pouvaient jouer que des m√©lodies √† un seul ton.  Au fil du temps, la soi-disant polyphonie est apparue. <br><br>  Sur Internet, j'ai rencontr√© des articles sur l'impl√©mentation d'un synth√©tiseur polyphonique sur MK, qui lit les fichiers midi.  Dans ce cas, au moins, une ¬´table d'ondes¬ª pr√©form√©e (une liste de formes d'ondes sonores) est utilis√©e pour chaque instrument de musique stock√© dans la m√©moire de MK.  Et dans mon cas particulier, nous nous concentrerons sur la mise en ≈ìuvre d'un mod√®le plus simple: un synth√©tiseur √† un seul ton (une seule voix). <br><br>  Pour commencer, j'ai √©tudi√© attentivement la structure du fichier midi et suis arriv√© √† la conclusion qu'en plus des informations n√©cessaires sur les notes, il contient des informations redondantes suppl√©mentaires.  Par cons√©quent, il a √©t√© d√©cid√© d'√©crire un programme simple pour convertir un fichier midi dans son propre format.  Le programme, fonctionnant avec de nombreux fichiers MIDI, non seulement convertit les formats, mais les organise √©galement d'une certaine mani√®re.  √Ä l'avance, j'ai d√©cid√© d'organiser le stockage de nombreux morceaux dans la m√©moire ROM (EEPROM 24XX512).  Pour faciliter la visualisation dans l'√©diteur HEX, je me suis assur√© que chaque m√©lodie commence au d√©but du secteur.  Contrairement √† une carte SD (par exemple), le concept de secteur n'est pas applicable √† la ROM utilis√©e, je m'exprime donc conditionnellement.  La taille du secteur est de 512 octets.  Et le premier secteur du ROM est r√©serv√© aux adresses des secteurs des d√©buts de chaque m√©lodie.  On suppose que la m√©lodie peut prendre plusieurs secteurs. <br><br>  Une description compl√®te du format de fichier midi, bien s√ªr, ne vaut pas la peine d'√™tre faite ici.  Je n'aborderai que les points les plus n√©cessaires et les plus n√©cessaires.  Un fichier midi contient 16 canaux, ce qui correspond g√©n√©ralement √† l'un ou l'autre instrument de musique.  Dans notre cas, peu importe de quel type d‚Äôinstrument il s‚Äôagit et un seul canal est n√©cessaire.  Le contenu de chaque cha√Æne, ainsi que l'en-t√™te, est √©tabli dans un fichier midi selon un principe tr√®s similaire √† l'organisation du stockage des flux vid√©o et audio dans un conteneur AVI.  J'ai √©crit sur ce dernier plus t√¥t dans l'un de mes articles.  L'en-t√™te du fichier midi est un ensemble de certains param√®tres.  Un de ces param√®tres est la r√©solution temporelle.  Il est exprim√© en nombre de ¬´ticks¬ª (une sorte de pixel) par trimestre (PPQN).  Un quart est un laps de temps pendant lequel une noire est jou√©e.  Selon le tempo de la m√©lodie, la dur√©e du trimestre peut √™tre diff√©rente.  Par cons√©quent, la dur√©e d'un ¬´pixel¬ª (p√©riode d'√©chantillonnage) d√©pend du tempo et du PPQN.  Toutes les informations sur l'heure d'un √©v√©nement sont d√©termin√©es avec pr√©cision pour cette dur√©e. <br><br>  De plus, l'en-t√™te contient le type de fichier MIDI (type 0 ou type 1) et le nombre de canaux.  Sans entrer dans les d√©tails, nous travaillerons avec le type 1, le nombre de canaux 2. Un fichier midi avec une m√©lodie √† un seul ton, logiquement, contient un canal.  Mais dans le fichier midi de ¬´type 1¬ª, il y a, en plus du fichier principal, un autre canal ¬´non musical¬ª dans lequel sont enregistr√©es des informations suppl√©mentaires qui ne contiennent pas de notes.  Il s'agit des soi-disant m√©tadonn√©es.  Il n'est pas non plus n√©cessaire d'entrer dans les d√©tails.  La seule information dont nous avons besoin, c'est qu'il y a des informations sur le rythme, et dans un format inhabituel: microsecondes par trimestre.  √Ä l'avenir, il sera montr√© comment utiliser ces informations, avec PPQN, pour configurer le minuteur MK, qui est responsable du tempo. <br><br>  Dans le bloc de canal principal avec des notes, nous ne sommes int√©ress√©s que par des informations sur les √©v√©nements d'activation et de d√©sactivation des notes.  Un √©v√©nement d'activation de note a deux param√®tres: le num√©ro de note et le volume.  Au total, 128 notes et 128 niveaux de volume sont fournis.  Nous ne nous int√©ressons qu'au premier param√®tre, car peu importe le volume de la note: toutes les notes lors de la lecture de la m√©lodie MK sonneront au m√™me volume.  Et, bien s√ªr, la m√©lodie ne doit pas contenir de notes ¬´superpos√©es¬ª, c'est-√†-dire qu'√† tout moment, plus d'une note ne doit pas retentir en m√™me temps.  Le code de l'√©v√©nement de prise (d'activation) des notes est 0x90.  Le code d'√©v√©nement note off est 0x80.  Cependant, au moins l'√©diteur Cakewalk Pro Audio 9 n'utilise pas l'√©v√©nement avec le code 0x80 lors de l'exportation de la composition au format midi.  Au lieu de cela, l'√©v√©nement 0x90 a lieu dans toute la partie musicale, et la note que la note est d√©sactiv√©e est son volume z√©ro.  C'est-√†-dire que l'√©v√©nement ¬´d√©sactiver la note¬ª est √©quivalent √† l'√©v√©nement ¬´activer la note avec un volume nul¬ª.  Peut-√™tre que cela se fait pour des raisons d'√©conomie.  Selon la sp√©cification, le code d'√©v√©nement ne peut pas √™tre r√©√©crit si cet √©v√©nement est r√©p√©t√©.  Entre les √©v√©nements, les informations sur l'intervalle de temps sont enregistr√©es dans un format de longueur variable.  Ce sont les valeurs enti√®res du nombre de ¬´ticks¬ª mentionn√©s ci-dessus.  Le plus souvent, un octet suffit pour enregistrer l'intervalle de temps.  Si deux √©v√©nements se succ√®dent, alors entre eux l'intervalle de temps est √©videmment √©gal √† z√©ro.  Ceci, par exemple, d√©sactive la premi√®re et l'inclusion de la deuxi√®me note qui la suit, s'il n'y a pas de pause (espace) entre elles. <br><br>  Essayons d'√©crire une s√©quence de notes en utilisant le programme "Cakewalk Pro Audio 9".  Il y a beaucoup de r√©dacteurs, mais je me suis install√© sur le premier rencontr√©. <br><br><img src="https://habrastorage.org/webt/x2/rs/ig/x2rsigockegfkqq_xux3wgiesly.png"><br><br>  Vous devez d'abord configurer les param√®tres du projet.  Dans cet √©diteur, vous pouvez d√©finir la r√©solution dans le temps (PPQN).  Je choisis la valeur minimale √©gale √† 48. Une valeur trop grande n'a pas de sens, car vous devez travailler avec de grands nombres d√©passant 1 octet.  Mais la valeur minimale de 48 est tout √† fait satisfaisante.  Dans presque toutes les m√©lodies, les notes inf√©rieures √† 1/32 ne sont pas trouv√©es.  Et si le nombre de ¬´ticks¬ª par trimestre est de 48, alors la note ou pause 1/32 aura une dur√©e de 48 / (32/4) = 6 ¬´ticks¬ª.  Autrement dit, il existe une possibilit√© th√©orique de diviser compl√®tement la note de 1/32 par 2, et m√™me par 3. Nous laissons les param√®tres restants dans la fen√™tre des propri√©t√©s du projet par d√©faut. <br><br><img src="https://habrastorage.org/webt/q-/e8/1j/q-e81jrcz7-g-doa-oberdoezju.png"><br><br>  Ensuite, ouvrez la propri√©t√© de la premi√®re piste et attribuez-lui un num√©ro de canal √©gal √† 1. √Ä votre go√ªt, s√©lectionnez un patch qui correspond √† un instrument de musique lorsque vous jouez une m√©lodie dans l'√©diteur.  Le num√©ro de patch, bien s√ªr, n'affectera pas le r√©sultat final. <br><br><img src="https://habrastorage.org/webt/y-/2o/xn/y-2oxnmqemoxj3hwtflnanivyyk.png"><br><br>  Le tempo de la m√©lodie est d√©fini en nombre de quarts par minute dans la barre d'outils de l'√©diteur.  La valeur de tempo par d√©faut est 100 bpm. <br><br>  Le microcontr√¥leur dispose d'une minuterie 8 bits qui, comme d√©j√† mentionn√©, sera utilis√©e pour contr√¥ler la dur√©e des notes et des pauses.  Il a √©t√© d√©cid√© que l'intervalle de temps entre les op√©rations adjacentes (interruptions) d'un tel temporisateur correspondrait √† l'intervalle d'un ¬´tick¬ª.  Selon le tempo de la m√©lodie, la valeur de cet intervalle de temps sera diff√©rente.  J'ai d√©cid√© d'utiliser des interruptions de temporisation de d√©bordement.  Et selon le param√®tre initial d'initialisation du timer, il est possible d'ajuster ce m√™me intervalle de temps, qui d√©pend du tempo de la m√©lodie.  Passons maintenant aux calculs. <br><br>  En r√®gle g√©n√©rale, dans la pratique, en moyenne, le tempo des chansons se situe dans la plage de l'ordre de 50 √† 200. Il a d√©j√† √©t√© dit que le tempo du fichier midi est r√©gl√© en microsecondes d'un quart.  Pour un tempo de 50, cette valeur est de 60 000 000/50 = 1 200 000, et pour un tempo de 250, elle sera de 240 000. Puisque, selon le projet, un quart contient 48 ticks, la longueur de tick pour le tempo minimum sera de 1 200 000/48 = 25 000 Œºs.  Et pour le rythme maximum, si vous calculez de la m√™me mani√®re, - 5000 Œºs.  Pour MK avec une fr√©quence de quartz de 8 MHz et un diviseur de minuterie pr√©liminaire maximum de 1024, nous obtenons ce qui suit.  Pour le rythme minimum, le chronom√®tre doit √™tre calcul√© 25000 / (1024/8) = 195 fois.  Le r√©sultat est arrondi √† la valeur enti√®re la plus proche, l'erreur d'arrondi n'affecte pratiquement pas le r√©sultat.  Pour l'allure maximale - 5000 / (1024/8) = 39.  Ici, l'erreur d'arrondi n'affecte pas d'autant plus qu'une valeur arrondie de 39 est √©galement obtenue pour les valeurs de tempo voisines de 248 √† 253. Par cons√©quent, le temporisateur doit √™tre initialis√© avec une valeur inverse: pour le tempo minimum - (256-195) = 61, et pour le maximum - (256 -39) = 217.  Le rythme minimum auquel la minuterie sera fournie dans la configuration MK actuelle est de 39 bpm.  Avec cette valeur, le temporisateur doit √™tre compt√© 250 fois.  Et avec une valeur de 38 - d√©j√† 257, ce qui d√©passe les limites de la minuterie.  J'ai d√©cid√© de prendre la valeur de 40 bpm pour le rythme minimum et de 240 pour le maximum. <br><br>  Pour calculer le nombre de ticks, une minuterie virtuelle bas√©e sur ce qui pr√©c√®de sera utilis√©e.  C'est le nombre de ticks qui d√©finit la dur√©e d'une note ou d'une pause, comme d√©j√† mentionn√© ci-dessus. <br><br>  Pour impl√©menter la lecture des notes, un deuxi√®me minuteur 16 bits est utilis√©.  Selon la sp√©cification MIDI, un total de 128 notes sont fournies.  Mais en pratique, ils sont beaucoup moins utilis√©s.  De plus, les notes des octaves les plus basses (avec des fr√©quences d'environ 50 Hz) et les plus hautes (avec des fr√©quences d'environ 8 kHz) ne seront pas reproduites harmonieusement par le microcontr√¥leur.  Mais pour tout cela, une minuterie 16 bits avec un diviseur fixe couvre presque toute la gamme de notes fournies par midi, √† savoir, sans les 35 premiers.  Mais j'ai choisi comme d√©but la note avec le chiffre 37 (son code est 36, puisque l'encodage vient de z√©ro).  Ceci est fait par commodit√©, car ce nombre correspond √† la note ¬´C¬ª, comme la premi√®re note dans une √©chelle traditionnelle.  Il lui correspond avec une fr√©quence de 65,4 Hz, et le demi-cycle est - 1 / 65,4 / 2 = 0,00764 sec.  Cette p√©riode √† une fr√©quence MK de 8 MHz et un diviseur 1 (c'est-√†-dire sans diviseur) comptera le minuteur approximativement dans son ensemble pour 0,00764 / (1/8000000) = 61156 fois.  Pour la 35e note, si vous comptez, cette valeur sera 68645, ce qui est au-del√† de la plage du temporisateur 16 bits.  Mais, m√™me s'il √©tait n√©cessaire de jouer des notes en dessous du 36e, vous pouvez entrer le premier diviseur de minuterie disponible, √©gal √† 8. Mais cela n'est pas n√©cessaire en pratique, tout comme il n'y en a m√™me pas pour jouer les notes les plus hautes.  N√©anmoins, pour la 128e note la plus √©lev√©e, la note ¬´G¬ª avec une fr√©quence de 12 543,85 Hz, la valeur de la minuterie est, si elle est compt√©e de mani√®re similaire, 319. Les d√©tails de tous les calculs ci-dessus sont d√©termin√©s par la configuration sp√©cifique du mode minuterie, qui sera montr√©e plus loin. <br><br>  Maintenant, j'ai une question non moins importante: comment obtenir la relation entre le num√©ro de note et le code de la minuterie?  Il existe une formule bien connue pour calculer la fr√©quence d'une note par son num√©ro.  Et le code de minuterie pour une fr√©quence connue est calcul√© facilement, comme indiqu√© ci-dessus dans les exemples.  Mais la racine du 12e degr√© appara√Æt dans la formule de la d√©pendance de la fr√©quence √† la note, et en g√©n√©ral, je ne voudrais pas charger le contr√¥leur avec de telles proc√©dures de calcul.  D'un autre c√¥t√©, la cr√©ation d'un tableau de codes temporis√©s pour toutes les notes n'est pas non plus rationnelle.  Et j'ai d√©cid√© de faire ce qui suit, en choisissant un terrain d'entente.  Il suffit de cr√©er un tableau de codes de temporisation pour les 12 premi√®res notes, qui sont d'une octave.  Et les notes des octaves suivantes doivent √™tre obtenues en multipliant s√©quentiellement les fr√©quences des notes de la premi√®re octave par 2. Ou, la m√™me chose, en divisant s√©quentiellement les valeurs des codes de minuterie par 2. Une autre commodit√© est que le nombre d'octaves, par co√Øncidence, est un argument dans le fonctionnement du d√©calage binaire vers la droite ( ¬ª), Qui servira d'op√©ration de division par deux.  Je n'ai pas choisi cet op√©rateur par hasard, car son argument refl√®te l'exposant de la puissance du diviseur (le nombre de divisions par 2).  Et c'est le nombre d'octave.  Pour mon jeu de notes, un total de 8 octaves est impliqu√© (la derni√®re octave est incompl√®te).  Une note dans un fichier midi est encod√©e avec un octet, plus pr√©cis√©ment, 7 bits.  Pour jouer des notes en MK, selon l'id√©e ci-dessus, vous devez d'abord calculer le num√©ro d'octave et le num√©ro de note dans l'octave en utilisant le code de note.  Cette op√©ration est effectu√©e au stade de la conversion du fichier midi dans un format simplifi√©.  Huit octaves peuvent √™tre encod√©es en trois bits, et 12 notes dans une octave peuvent √™tre encod√©es en quatre.  Au total, il s'av√®re que la note est encod√©e dans les m√™mes sept bits que dans le fichier midi, mais uniquement dans une repr√©sentation diff√©rente convenant √† MK.  En raison du fait que 16 bits peuvent √™tre cod√©s sur 4 bits et des notes dans une octave de 12, il y a des octets inutilis√©s. <br><br>  Le dernier huiti√®me bit peut √™tre utilis√© comme marqueur pour activer ou d√©sactiver les notes.  Dans le cas de MK, en raison de l'unanimit√© de la m√©lodie, les informations sur la note en sourdine seront redondantes.  Avec un changement direct de note dans la m√©lodie, il n'y a pas un ¬´turn-on-turn-on¬ª, mais un ¬´interrupteur¬ª de la note.  Et en cas de pause, le ¬´silence est activ√©¬ª, pour lequel vous pouvez s√©lectionner un octet sp√©cial dans l'ensemble d'octets inutilis√©s et ne pas utiliser du tout les informations sur la d√©sactivation de la note.  Une telle id√©e est bonne en ce qu'elle enregistre la taille de la m√©lodie r√©sultante apr√®s la conversion, mais complique g√©n√©ralement le mod√®le.  Je n'ai pas suivi cette id√©e, car il y a d√©j√† beaucoup de m√©moire. <br><br>  Les informations sur les notes de m√©lodie dans le fichier midi sont stock√©es dans le bloc du canal correspondant dans la vue "interval-event-interval-event ...".  Dans le format converti, exactement le m√™me principe s'applique.  Pour enregistrer un √©v√©nement (activer ou d√©sactiver une note), comme mentionn√© ci-dessus, un octet est utilis√©.  Le premier bit (le bit le plus significatif 7) code le type d'√©v√©nement.  La valeur ¬´1¬ª est la note activ√©e et la valeur ¬´0¬ª est la note d√©sactiv√©e.  Les trois bits suivants codent le num√©ro d'octave et les quatre bits les plus bas codent le num√©ro de note dans l'octave.  Un octet est √©galement utilis√© pour enregistrer l'intervalle de temps.  Dans le format midi d'origine, un format de longueur variable est utilis√© pour cela.  Son petit inconv√©nient est que seuls 7 bits codent l'intervalle de temps (le nombre de ¬´ticks¬ª), et le huiti√®me bit est un signe de continuation.  Autrement dit, avec un octet, en fait, vous pouvez coder un intervalle allant jusqu'√† 128 ticks.  Mais comme les intervalles de temps entre les √©v√©nements dans des m√©lodies r√©elles et simples d√©passent parfois 128, mais ne d√©passent presque jamais 256, j'ai abandonn√© le format de longueur variable et j'ai g√©r√© avec un octet.  Il code un intervalle de temps allant jusqu'√† 256 ticks.  Comme le projet utilise 48 ticks par trimestre, ou 48 * 4 = 192 ticks par cycle, un octet peut √™tre utilis√© pour coder un intervalle de 256/192 = 1 dur√©e. (3) (un tout et un tiers) cycles, qui assez. <br><br>  Dans le format natif dans lequel le fichier midi est converti, j'ai √©galement appliqu√© un petit en-t√™te de 16 octets.  Les 14 premiers octets contiennent le nom de la m√©lodie.  Naturellement, le nom ne doit pas d√©passer 14 caract√®res.  Vient ensuite un espace nul.  Le dernier octet suivant refl√®te le tempo de la m√©lodie dans une vue pratique pour MK.  Cette valeur est calcul√©e au stade de la conversion et sert √† initialiser le temporisateur MK, qui est responsable du rythme.  Comment il est calcul√© est discut√© dans quelques paragraphes ci-dessus. <br><br>  √Ä partir du 17e octet, le contenu de la m√©lodie suit.  Chaque octet impair correspond √† un intervalle de temps et chaque octet pair correspond √† un √©v√©nement (remarque).    ,     ,    ,   .         0xFF.      .            ,    .  ,  ,        ,  ,    .       .    0x0F,      .    16-    ,   ,       12.      .  ,    ¬´ ¬ª,          ,        .              (  ). ,       36 .  ,  ( )        ,         . <br><br>     ¬´Cakewalk Pro Audio 9¬ª,   .      ,         .      :   ¬´Piano roll¬ª    .            .     . <br><br><img src="https://habrastorage.org/webt/lr/-r/hy/lr-rhyphwp5xckftmq8fbwhlchc.png"><br><br><img src="https://habrastorage.org/webt/ot/qf/d7/otqfd7db-6wj0o9dscmg60tp5d8.png"><br><br>    ,      ()        ,    .     ,   ,        . <br><br>         . <br><br><img src="https://habrastorage.org/webt/vy/gu/n1/vygun1nauiacc6-zjbq66whb7qg.png"><br><br>    ,      ,   ,          .     ,    ,  -    ,      ¬´Del¬ª. ,       ,  - ¬´¬ª.  , ,      .   ,             ,    .  ,         :    . <br><br>     ¬´ 1¬ª,    . <br><br><img src="https://habrastorage.org/webt/l6/gx/uf/l6gxufg_2kmfge81godpmmhieki.png"><br><br>     HEX .   , ,      avi  (    ),           ,    (big endian). <br><br><img src="https://habrastorage.org/webt/wj/oi/cn/wjoicnlzwx4ixajswxz3m3_jj5i.png"><br><br>        .            .  ,    (1),   (2)      (48).              .        .       6 ,       .  6      (- 0xFF)   0x51     0x03 .    ‚Äì  .             .      ,    .            .    ‚Äì     ‚Äì       . ,  ,    ,    ,      .     (    )    ,   48*3=144    128.        ,    .          144    .         .     ,   .        .   ,      () ,        :  .   , 0x90,   .         .   ‚Äì       ,    128 . <br><br>  ,   ,          ,          ,     -  EEPROM.     ,         .      HEX ,          .       . <br><br><img src="https://habrastorage.org/webt/9p/e5/h1/9pe5h1qaetdg-kjk-abaxvlk6am.png"><br><br>      ( 16 ),    ,   .    0xC1 (193)    154, 155  156.  ,       155 bpm,        .   ( 14-),    ,   .    ‚Äì ¬´Classic¬ª.     ,       HEX . ,          ,    ,    . <br><br>    ( 17- )   .        ,      ,    .  ,   ,   .  ,   ,       /.  ,   ¬´¬ª , 0xB4  0x34,          0x34,       .   0xB4 (0b10110100)    ,     ,    0x34 (0b00110100)    ,     .  0x34     :   0b011,      ‚Äì 0b0100.  ,   , 3  4 .     ,  ,               .         .  ,      Excel,     76 (0x4C)   ,    E6 ( ¬´¬ª 6-  ).    :      . <br><br>        ,         .      ,   , .   ,     .  ,                .             .          ,           .  ,  ,     -  ,   ,   ,            .        ,    ,    ,   1            .  ¬´¬ª  1   ,   . <br><br>           (0x90),   128,          ,    .              .  ,   ,      . ,   0xFF,     ,    .            ,  . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Consid√©rez le tout premier secteur du fichier image EEPROM de sortie. Comme je l'ai d√©j√† √©crit, il sert de liste d'adresses de secteurs du d√©but des m√©lodies. Le programme a r√©ussi √† num√©riser 8 morceaux sans erreur (au moment de la r√©daction, j'avais enregistr√© 8 morceaux). La valeur du nombre de m√©lodies est enregistr√©e dans le dernier 512e octet du secteur. Et d√®s le tout d√©but du secteur, des adresses sont √©crites. Pour la premi√®re m√©lodie, l'adresse est 0x01, ce qui correspond au deuxi√®me secteur (le premier, si vous comptez √† partir de z√©ro). Les troisi√®me et quatri√®me m√©lodies (deux sur huit) se sont av√©r√©es longues et ne cadraient pas dans un seul secteur. Par cons√©quent, des lacunes sont observ√©es dans la s√©quence d'adresses. Si vous comptez, 64 Ko de m√©moire, vous ne pouvez pas enregistrer plus de 127 morceaux, donc un secteur pour l'adressage suffit.</font></font><br><br><img src="https://habrastorage.org/webt/t7/fm/g-/t7fmg-97qcqphlojly3l8xcpnru.png"><br><br>     ,   ,    Excel.        (  ). <br><br><img src="https://habrastorage.org/webt/31/cb/my/31cbmycwzmmfr_noks7sifxpaps.png"><br><br><img src="https://habrastorage.org/webt/jn/tm/1f/jntm1fp2sga5erx_xmtqq3bbhcy.png"><br><br>  ,        ,        .      ,    . ,  , ,        . <br><br><div class="spoiler"> <b class="spoiler_title">  1.cpp</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;windows.h&gt; #include &lt;string.h&gt; #define SPACE 1 HANDLE openInputFile(const char * filename) { return CreateFile ( filename, // Open Two.txt. GENERIC_READ, // Open for writing 0, // Do not share NULL, // No security OPEN_ALWAYS, // Open or create FILE_ATTRIBUTE_NORMAL, // Normal file NULL); // No template file } HANDLE openOutputFile(const char * filename) { return CreateFile ( filename, // Open Two.txt. GENERIC_WRITE, // Open for writing 0, // Do not share NULL, // No security OPEN_ALWAYS, // Open or create FILE_ATTRIBUTE_NORMAL, // Normal file NULL); // No template file } void filepos(HANDLE f, unsigned int p){ LONG LPos; LPos = p; SetFilePointer (f, LPos, NULL, FILE_BEGIN); //FILE_CURRENT //https://docs.microsoft.com/en-us/windows/desktop/api/fileapi/nf-fileapi-setfilepointer } DWORD wr; DWORD ww; unsigned long int read32(HANDLE f){ unsigned char b3,b2,b1,b0; ReadFile(f, &amp;b3, 1, &amp;wr, NULL); ReadFile(f, &amp;b2, 1, &amp;wr, NULL); ReadFile(f, &amp;b1, 1, &amp;wr, NULL); ReadFile(f, &amp;b0, 1, &amp;wr, NULL); return b3&lt;&lt;24|b2&lt;&lt;16|b1&lt;&lt;8|b0; } unsigned long int read24(HANDLE f){ unsigned char b2,b1,b0; ReadFile(f, &amp;b2, 1, &amp;wr, NULL); ReadFile(f, &amp;b1, 1, &amp;wr, NULL); ReadFile(f, &amp;b0, 1, &amp;wr, NULL); return b2&lt;&lt;16|b1&lt;&lt;8|b0; } unsigned int read16(HANDLE f){ unsigned char b1,b0; ReadFile(f, &amp;b1, 1, &amp;wr, NULL); ReadFile(f, &amp;b0, 1, &amp;wr, NULL); return b1&lt;&lt;8|b0; } unsigned char read8(HANDLE f){ unsigned char b0; ReadFile(f, &amp;b0, 1, &amp;wr, NULL); return b0; } void message(unsigned char e){ printf("Error %d: ",e); switch(e){ case 1: // -   -; printf("In track0 event is not FF\n"); break; case 2: // -  127 printf("Len of FF &gt;127\n"); break; case 3: //  ; printf("Midi is incorrect\n"); break; case 4: //   ; printf("Delta&gt;255\n"); break; case 5: //    RPN  NRPN; printf("RPN or NRPN is detected\n"); break; case 6: //   ; printf("Note in 1...35 range\n"); break; case 7: //    ; printf("Long of name of midi file &gt;18\n"); break; } system("PAUSE"); } int main(){ HANDLE in; HANDLE out; unsigned int i,j; unsigned int inpos; unsigned int outpos=0; unsigned char byte; // ; unsigned char byte1; //  1  ; unsigned char byte2; //  2  ; unsigned char status; //- ( ); unsigned char sz0; // -; unsigned long int bsz0; //    -; unsigned short int format, ntrks, ppqn; //  ; unsigned long int bsz1; //    ; unsigned long int bpm; // ( .  ); unsigned long int time=0; //    ( ); unsigned char scale; //    ,  ; unsigned char oct; //    ; unsigned char nt; // ; unsigned char outnote; //      ; unsigned char prnote=0; //  ; unsigned char tdt; // ()   ; unsigned int dt; //    ( ); unsigned int outdelta=0; //    ( ); unsigned char prdelta=0; //  ; char fullname[30]; //    ; char name[16]; // ; WIN32_FIND_DATA fld; //   mid; HANDLE hf; unsigned short int csz; //  ; unsigned char nfile=0; // ; unsigned char adr[128]; //    ; out=openOutputFile("IMAGE.out"); outpos=512; //   ; filepos(out,outpos); hf=FindFirstFile(".\\midi\\*.mid",&amp;fld); do{ printf("\n***** %s *****\n",fld.cFileName); if(strlen(fld.cFileName)&gt;18){ //   ; message(7); } sprintf(name,"%s",fld.cFileName); name[strlen(fld.cFileName)-4]=0; // ; sprintf(fullname,".\\midi\\%s",fld.cFileName); //    ; WriteFile(out, name, strlen(name), &amp;ww, NULL); //    ; in=openInputFile(fullname); //    ; #include "process.cpp" //     ; outpos+=((csz/512)+1)*512; //    ; adr[nfile]=(outpos/512)-((csz/512)+1); //  ()   ; filepos(out,outpos); CloseHandle(in); nfile+=1; }while(FindNextFile(hf,&amp;fld)); //   ,    ; FindClose(hf); WriteFile(out, &amp;outnote, 1, &amp;ww, NULL); outpos=0; //   ; filepos(out,outpos); WriteFile(out, adr, nfile, &amp;ww, NULL); outpos=511; //  ; filepos(out,outpos); WriteFile(out, &amp;nfile, 1, &amp;ww, NULL); CloseHandle(out); system("PAUSE"); return 0; }</span></span></span></span></code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Pi√®ce jointe au fichier Process.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs">time=<span class="hljs-number"><span class="hljs-number">0</span></span>; inpos=<span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  ; filepos(in,inpos); format=read16(in); ntrks=read16(in); ppqn=read16(in); if(format!=1 || ntrks!=2 || ppqn!=48){ message(3); } inpos+=10; filepos(in,inpos); //    -; bsz0=read32(in); inpos+=4; while(inpos&lt;22+bsz0){ //      ; tdt=read8(in); inpos+=1; //   ; dt=(unsigned int)(tdt&amp;0x7F); while(tdt&amp;0x80){ tdt=read8(in); inpos+=1; dt=(dt&lt;&lt;7)|(tdt&amp;0x7F); } byte=read8(in); inpos+=1; if(byte==0xFF){ //  ,  -    -; byte=read8(in); //  -; sz0=read8(in); //  , ,     127 ( ); if(sz0&amp;0x80){ message(2); } inpos+=2; switch(byte){ case 0x51: //   "Set Tempo"; bpm=read24(in); scale=256-(bpm/(ppqn*128)); printf("scale=%d\n",scale); filepos(out,outpos+15); // ; WriteFile(out, &amp;scale, 1, &amp;ww, NULL); csz=16; break; default: break; } inpos+=sz0; filepos(in,inpos); // ,     0x51; }else{ message(1); } } //    ; outdelta=0; inpos+=4; filepos(in,inpos); bsz1=read32(in); inpos+=4; while(inpos&lt;30+bsz0+bsz1){ tdt=read8(in); inpos+=1; //   ; dt=(unsigned int)(tdt&amp;0x7F); while(tdt&amp;0x80){ tdt=read8(in); inpos+=1; dt=(dt&lt;&lt;7)|(tdt&amp;0x7F); } outdelta+=dt; //  ; // ,      , ; time+=dt; //  ; byte=read8(in); //    ,  ; inpos+=1; if(byte&amp;0x80){ //  ; status=byte; // ; if(byte==0xFF){ //   -; byte=read8(in); //    ,    ; sz0=read8(in); inpos+=(2+sz0); filepos(in,inpos); }else{ //    ; byte1=read8(in); inpos+=1; } }else{ //    ,        ; byte1=byte; } switch(status&amp;0xF0){ // ,      ; case 0xF0: //   ,  -; break; case 0x80: // ; byte2=read8(in); //     ( ); inpos+=1; //     ,    ; if(byte1&gt;1&amp;&amp;byte1&lt;36){ //         ; message(6); } if(byte1&gt;1){ // ; oct=((byte1-36)/12); //  ; nt=(byte1-36)%12; //    ; }else{ //   ; oct=0; nt=15; } outnote=(oct&lt;&lt;4)|nt; //  ; prnote=outnote; prdelta=outdelta; if(outdelta&gt;255){ //     255 (  ); message(4); } WriteFile(out, &amp;outdelta, 1, &amp;ww, NULL); WriteFile(out, &amp;outnote, 1, &amp;ww, NULL); csz+=2; outdelta=0; //  ; break; case 0x90: //   ; byte2=read8(in); //    ( ); inpos+=1; //     ,    ; if(byte1&gt;1&amp;&amp;byte1&lt;36){ //         ; message(6); } if(byte1&gt;1){ // ; oct=((byte1-36)/12); //  ; nt=(byte1-36)%12; //    ; }else{ //   ; oct=0; nt=15; } if(byte2){ //  ,   ; outnote=0x80|(oct&lt;&lt;4)|nt; //  = 1; //   ; if(!outdelta &amp;&amp; (outnote&amp;0x7F)==prnote){ //     ; prdelta-=SPACE; // -; filepos(out,outpos+csz-2); //    ; WriteFile(out, &amp;prdelta, 1, &amp;ww, NULL); // ; filepos(out,outpos+csz); outdelta=SPACE; //  -  ; } }else{ //  ,    ; outnote=(oct&lt;&lt;4)|nt; prnote=outnote; //  ; prdelta=outdelta; //  -; } if(outdelta&gt;255){ //   -    ; message(4); } WriteFile(out, &amp;outdelta, 1, &amp;ww, NULL); WriteFile(out, &amp;outnote, 1, &amp;ww, NULL); csz+=2; outdelta=0; // -   ; break; //   () ; case 0xA0: // ; byte2=read8(in); inpos+=1; break; case 0xB0: //   ; if(byte1&gt;=98&amp;&amp;byte1&gt;=101){ //     NRPN  RPN; message(5); //  ; } byte2=read8(in); inpos+=1; break; case 0xC0: //  (.  ); // , ,    ; break; case 0xD0: //; break; case 0xE0: // ; byte2=read8(in); inpos+=1; break; default: //  (   ); break; } } //     0xFFFF,    ; outdelta=255; outnote=255; WriteFile(out, &amp;outdelta, 1, &amp;ww, NULL); WriteFile(out, &amp;outnote, 1, &amp;ww, NULL); csz+=2; //   ,     ; printf("Length: %i (%i:%02i)\n",time,time/192,time%192);</span></span></code> </pre><br></div></div><br>  En fait, la partie de base du programme pour MK est tr√®s simple.  Consid√©rez l'une des options pour sa mise en ≈ìuvre, plus pr√©cis√©ment, sa partie principale. <br><br>  Le minuteur 1, utilis√© pour g√©n√©rer le son des notes, est configur√© comme suit.  Pour activer et d√©sactiver les notes, les substitutions suivantes sont utilis√©es, respectivement. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ENT1 TCCR1B=0x09;TCCR1A=0x40 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DIST1 TCCR1B=0x00;TCCR1A=0x00;PORTB.1=0</span></span></code> </pre><br>  Avant de d√©marrer la minuterie, vous devez attribuer au registre OCR1A une valeur de 16 bits qui correspondra √† la fr√©quence en cours de lecture.  Cela sera montr√© plus tard.  Lorsque le temporisateur est activ√©, le registre TCCR1B se voit attribuer le ¬´Mode de g√©n√©ration de forme d'onde¬ª avec un diviseur de temporisateur de 1, et le registre TCCR1A est r√©gl√© sur ¬´Basculer OC1A lors de la comparaison¬ª.  Dans ce cas, le signal est supprim√© de la sortie sp√©cialement d√©sign√©e de MK ¬´OC1A¬ª.  Dans l'ATmega8 du package SMD, il s'agit de la broche 13, qui est la m√™me que PORTB.1.  Lorsque la minuterie est d√©sactiv√©e, les deux registres sont r√©initialis√©s et la sortie de PORTB.1 est forc√©e √† z√©ro.  Cela est n√©cessaire pour √©viter, pendant le silence, la sortie d'une tension constante, ce qui serait ind√©sirable pour l'entr√©e de l'ULF.  Bien que, vous pouvez mettre un condensateur dans le circuit, mais vous pouvez √©galement d√©sactiver la sortie par programme.  Une tension constante peut se produire sur cette sortie si la note est coup√©e au moment de la phase correspondante du signal, et ce dans 50% des cas. <br><br>  Cr√©ez un tableau de valeurs de minuterie pour 12 notes de la toute premi√®re octave.  Ces valeurs ont √©t√© calcul√©es √† l'avance. <br><br><pre> <code class="cpp hljs">freq[]={<span class="hljs-number"><span class="hljs-number">61156</span></span>,<span class="hljs-number"><span class="hljs-number">57724</span></span>,<span class="hljs-number"><span class="hljs-number">54484</span></span>,<span class="hljs-number"><span class="hljs-number">51426</span></span>,<span class="hljs-number"><span class="hljs-number">48540</span></span>,<span class="hljs-number"><span class="hljs-number">45815</span></span>,<span class="hljs-number"><span class="hljs-number">43244</span></span>,<span class="hljs-number"><span class="hljs-number">40817</span></span>,<span class="hljs-number"><span class="hljs-number">38526</span></span>,<span class="hljs-number"><span class="hljs-number">36364</span></span>,<span class="hljs-number"><span class="hljs-number">34323</span></span>,<span class="hljs-number"><span class="hljs-number">32396</span></span>};</code> </pre><br>  Les notes des autres octaves, comme je l'ai dit, seront obtenues en divisant par deux degr√©s. <br><br>  La configuration du temporisateur 0 est encore plus simple.  Il fonctionne en permanence, avec une interruption de d√©bordement, chaque fois √©tant √† nouveau initialis√© avec la valeur qui correspond au tempo de la m√©lodie.  Le diviseur de minuterie est 5: TCCR0 = 0x05.  Sur la base de cette minuterie, une minuterie virtuelle est cr√©√©e qui compte les tics (temps) dans la m√©lodie.  Le traitement de la r√©ponse de ce temporisateur est plac√© dans le cycle de programme principal. <br><br>  La fonction d'interruption du temporisateur 0 est la suivante. <br><br><pre> <code class="cpp hljs">interrupt [TIM0_OVF] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">timer0_ovf_isr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(ent01){ vt01+=<span class="hljs-number"><span class="hljs-number">1</span></span>; } TCNT0=top0; }</code> </pre><br>  Ici, la variable ent01 est responsable de l'activation du temporisateur virtuel.  Par cette variable, il peut √™tre activ√© ou d√©sactiv√© si n√©cessaire.  La variable vt01 est la variable primaire d√©nombrable du temporisateur virtuel.  La ligne TCNT0 = top0 indique l'initialisation du temporisateur 0 √† la valeur souhait√©e top0, qui est lue √† partir du titre de la m√©lodie avant de la jouer. <br><br>  Le num√©ro de la m√©lodie √† jouer correspond √† la variable alm.  Il sert √©galement de drapeau du d√©but de la reproduction.  Elle doit attribuer un num√©ro de m√©lodie de l'une des mani√®res, selon la t√¢che.  Apr√®s cela, le bloc suivant du cycle principal deviendra actif. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(alm){ <span class="hljs-comment"><span class="hljs-comment">//     ; adr=eepr(alm-1)&lt;&lt;9; //     (&lt;&lt;9    512); adr+=15; //   ,      ; top0=eepr(adr); //  ; adr+=1; //     ; adr0=adr; //      (  ); top01=eepr(adr); //      " "  ; adr+=1; //   ; note=eepr(adr); // ; adr+=1; //    -; vt01=0; //    ; ent01=1; //  ; TCNT0=0; //  ; alm=0; //        ,   ; }</span></span></code> </pre><br>  Un passage suppl√©mentaire de note en note est effectu√© dans l'unit√© de traitement du temporisateur virtuel, qui est √©galement plac√© dans la boucle principale. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(vt01&gt;=top01){ <span class="hljs-comment"><span class="hljs-comment">//   ,    ; vt01=0; //  ; if(note&amp;0x80){ //     ""; nt=note&amp;15; //    ; oct=(note&amp;0x7F)&gt;&gt;4; //  ; if(nt!=15){ //       15,   ; OCR1A=freq[nt]&gt;&gt;oct; //     ; //         ; ENT1; // ; }else{ //  " "   ; DIST1; // ; } }else{ //     ""; DIST1; // ; } top01=eepr(adr); //      " "; adr+=1; //   ; note=eepr(adr); //   ; adr+=1; // ; if(note==255 &amp;&amp; top01==255){ //      ; top01=eepr(adr0); //   ,   ; note=eepr(adr0+1); //   ; adr=adr0+2; //   ; } }</span></span></code> </pre><br>  D'apr√®s les commentaires dans le texte du programme, tout devrait √™tre assez clair et compr√©hensible. <br><br>  Pour arr√™ter la m√©lodie, utilisez l'insertion suivante de la boucle principale. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(stop){ <span class="hljs-comment"><span class="hljs-comment">//  ; DIST1; //  ; ent01=0; //  ; vt01=0; //  ; }</span></span></code> </pre><br>  Il y a une petite remarque sur l'impl√©mentation de la lecture de la m√©lodie.  Avant que chaque nouvelle note ne commence √† retentir, le microcontr√¥leur passe un peu de temps √† convertir l'octet de lecture de la note en une valeur de minuterie.  Cette fois, comme il s'est av√©r√© en pratique, est relativement petite et n'affecte pas la qualit√© de la lecture.  Mais j'avais des doutes sur le fait que cette op√©ration resterait invisible.  Dans ce cas, des pauses suppl√©mentaires apparaissent avant chaque note et le rythme de la m√©lodie est rompu.  Mais ce probl√®me est √©galement r√©soluble.  Il suffit de calculer √† l'avance les valeurs de la minuterie de la note suivante pendant que la note actuelle retentit.  Cette proc√©dure doit √™tre effectu√©e s√©par√©ment du traitement du temporisateur virtuel dans la boucle de programme principale √† l'aide d'un indicateur sp√©cialement d√©sign√©.  √âtant donn√© que le temps de calcul ne d√©passera probablement pas le temps de lecture de la note la plus courte, une telle solution est appropri√©e. <br><br>  Passons maintenant √† tester le programme. <br><br>  En plus des extraits de code ci-dessus, j'ai ajout√© des fonctions de traitement des boutons au programme MK, avec lesquelles je contr√¥le l'inclusion ou la d√©sactivation d'une m√©lodie particuli√®re.  L'EEPROM est connect√©e √† MK via le bus I2C, dont le travail est impl√©ment√© au niveau logiciel.  Le projet a √©t√© r√©alis√© avec l'aide de ¬´CodeVisionAVR¬ª avec ¬´CodeWizardAVR¬ª.  Je sort MK de la broche 13 vers la carte son du PC via le diviseur et j'enregistre le son de la m√©lodie dans l'√©diteur de sons.  J'ai flash√© la m√©moire EEPROM √† l'aide du firmware, dont j'ai parl√© dans l'un des articles pr√©c√©dents.  √âtant donn√© que tous les octets du fichier image ne sont pas utiles, le micrologiciel de m√©moire ne peut √™tre impl√©ment√© que par des octets utiles (jusqu'aux marqueurs de fin des m√©lodies) afin d'√©conomiser du temps d'enregistrement et des ressources de puce.  Pour ce faire, vous pouvez cr√©er un programme distinct ou √©crire des octets sur la puce directement pendant la conversion, en les ajoutant au programme principal. <br><br>  Parmi les huit morceaux, il y en a trois de test, √† l'aide desquels j'√©valuerai la gamme de fr√©quences √† l'oreille, le son de la fusion de notes identiques, le son des notes les plus courtes, les transitions rapides, etc.  Permettez-moi de vous rappeler que la fusion des m√™mes notes sonne en fait avec une pause d'un tick, et la premi√®re note de la fusion dure un tick de moins. <br><br>  L'une des m√©lodies de test est une s√©quence de notes du premier au dernier d'une dur√©e d'une note par quart et d'un tempo de m√©lodie de 40 bpm. <br><br><img src="https://habrastorage.org/webt/d7/sr/hx/d7srhxannedgrv63owftqzeaf7k.png"><br><br>  Dans ce sc√©nario, une note sonne un peu plus d'une seconde, et vous pouvez donc √©couter en d√©tail le son de toute la gamme de notes.  Sur le spectre de fr√©quences dans l'√©diteur audio "Adobe Audition", les principales composantes de fr√©quence et leurs harmoniques sup√©rieures sont observ√©es en raison de la forme d'onde en dents de scie correspondante.  Et la relation logarithmique entre le num√©ro de note et la fr√©quence est frappante. <br><br><img src="https://habrastorage.org/webt/sn/_2/xn/sn_2xnmlyxsmmfo23beniaqvzki.png"><br><br>  En analysant les intervalles de temps, on voit clairement que la vraie pause entre des notes cons√©cutives est en moyenne d'environ 145 √©chantillons (√† une fr√©quence d'√©chantillonnage de l'enregistrement audio 44100 Hz), ce qui est d'environ 3 ms.  C'est le temps pendant lequel le MK effectue les calculs n√©cessaires.  Ces inserts sont pr√©sents r√©guli√®rement avant chaque note.  J'ai sp√©cifiquement √©crit le sens dans les √©chantillons, car ces informations sont plus originales et plus pr√©cises, bien que ce ne soit pas tr√®s important. <br><br><img src="https://habrastorage.org/webt/ue/t6/pg/uet6pgd-e0iac2m2imj3m4fa5o4.png"><br><br>  Et la dur√©e d'un tick √† un rythme moyen de la m√©lodie de 120 bpm est d'environ 10 ms.  Il s'ensuit qu'en principe, il serait possible de ne pas introduire la m√™me correction en 1 tick, lorsque deux notes identiques se succ√®dent sans pause.  Je pense qu'une insertion r√©guli√®re de 3 ms entre les notes serait bien suffisante.  Lors de l'√©coute d'une m√©lodie, ces insertions r√©guli√®res ne sont pas du tout perceptibles et les m√©lodies sonnent uniform√©ment.  Par cons√©quent, il n'est pas particuli√®rement n√©cessaire de calculer la valeur du minuteur pour la note suivante pendant la lecture de la note actuelle. <br><br>  Une autre m√©lodie de test avec un tempo de 200 bpm contient successivement les m√™mes notes 1/32 de la gamme moyenne sans pause.  Dans ce cas, apr√®s le traitement, lors de la lecture entre eux, il y a une pause de 1 tick, ce qui √† ce tempo rapide de 310 √©chantillons (environ 6 ms) du signal enregistr√©. <br><br><img src="https://habrastorage.org/webt/ms/on/m_/msonm__-e7svpb38fq22xhul7dm.png"><br><br>  La dur√©e de cette pause, en passant, est comparable √† la p√©riode du signal, ce qui indique un tempo √©lev√© de la m√©lodie.  Et son son rappelle un trille. <br><br>  En principe, cela peut √™tre termin√©.  J'√©tais satisfait du r√©sultat de l'appareil, il a d√©pass√© toutes les attentes.  La plupart du temps, je me suis consacr√© √† l'√©tude du format midi et au d√©bogage du programme de conversion.  Je consacrerai √©galement l'un des articles suivants √† un sujet li√© au MIDI, qui parlera de l'application de ce format dans d'autres applications int√©ressantes. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr454514/">https://habr.com/ru/post/fr454514/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr454498/index.html">La t√¢che avec les ast√©risques: nous collectons des aimants √©lectriques sur l'exemple de Twitter Mantis-E0</a></li>
<li><a href="../fr454500/index.html">Douglas Engelbart: ¬´Augmenter l'intellect humain: un cadre conceptuel¬ª (√©tape 2)</a></li>
<li><a href="../fr454506/index.html">Entropic - Nouveau registre de packages distribu√©s pour Node.js</a></li>
<li><a href="../fr454508/index.html">Portage d'applications de bureau vers .NET Core</a></li>
<li><a href="../fr454512/index.html">Petit d√©jeuner avec Charles Weatherly, auteur du livre culte Etudes for Programmers</a></li>
<li><a href="../fr454516/index.html">Comment obtenir un bon texte pour 200 roubles</a></li>
<li><a href="../fr454518/index.html">Wasmer: la biblioth√®que Go la plus rapide pour ex√©cuter le code WebAssembly</a></li>
<li><a href="../fr454520/index.html">Consignes pour √©crire du code JavaScript propre</a></li>
<li><a href="../fr454522/index.html">Node.js: gestion de la m√©moire disponible pour les applications s'ex√©cutant dans des conteneurs</a></li>
<li><a href="../fr454524/index.html">R√©paration de bandeau Samsung Level On Pro</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>