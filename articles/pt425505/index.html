<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üí∏ üñ§ üëÇüèΩ An√°lise do processo de inicializa√ß√£o do kernel Linux üí≥ üë©üèæ‚Äç‚öñÔ∏è üëë</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ol√° pessoal! 

 Enquanto Leonid se prepara para sua primeira li√ß√£o aberta em nosso curso Linux Administrator , continuamos a falar sobre o carregament...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>An√°lise do processo de inicializa√ß√£o do kernel Linux</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/425505/">  Ol√° pessoal! <br><br>  Enquanto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Leonid</a> se prepara para sua primeira <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">li√ß√£o aberta</a> em nosso curso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Linux Administrator</a> , continuamos a falar sobre o carregamento do kernel do Linux. <br><br>  Vamos l√°! <br><br>  Entendendo como um sistema funciona sem falhas - Preparando-se para corrigir as falhas inevit√°veis <br><br>  A piada mais antiga do campo de c√≥digo aberto √© a afirma√ß√£o de que "o c√≥digo documenta a si pr√≥prio".  A experi√™ncia mostrou que ler o c√≥digo-fonte √© como ouvir previs√µes do tempo: pessoas inteligentes ainda saem para olhar o c√©u.  Abaixo est√£o algumas dicas para verificar e examinar a inicializa√ß√£o do sistema Linux usando ferramentas familiares de depura√ß√£o.  Uma an√°lise do processo de inicializa√ß√£o de um sistema que funciona bem prepara usu√°rios e desenvolvedores para resolver falhas inevit√°veis. <br><br>  Por um lado, o processo de download √© surpreendentemente simples.  O kernel do sistema operacional (kernel) √© executado de thread √∫nico e de forma s√≠ncrona em um core (core), que pode parecer compreens√≠vel at√© para uma mente humana pat√©tica.  Mas como o kernel do sistema operacional √© iniciado?  Quais fun√ß√µes o initrd ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">um disco RAM para inicializa√ß√£o</a> ) e os gerenciadores de inicializa√ß√£o?  E espere, por que o LED na porta Ethernet est√° sempre aceso? <br><br><img src="https://habrastorage.org/webt/dl/v5/cc/dlv5cchbiput5mmnbjyzz1nloho.png"><a name="habracut"></a><br><br>  Continue lendo para obter respostas para essas e algumas outras perguntas;  O c√≥digo para as demos e exerc√≠cios descritos tamb√©m est√° dispon√≠vel no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GitHub</a> . <br><br>  <b>In√≠cio da inicializa√ß√£o: status OFF</b> <br><br>  <i><b>Wake-on-LAN</b></i> <br><br>  Um status OFF significa que o sistema n√£o tem energia, certo?  A aparente simplicidade √© enganadora.  Por exemplo, o LED Ethernet est√° aceso mesmo nesse estado, porque a ativa√ß√£o em LAN (WOL, ativa√ß√£o em [sinal da] rede local) est√° ativada em seu sistema.  Certifique-se de escrever: <br><br><pre><code class="bash hljs"><span class="hljs-variable"><span class="hljs-variable">$#</span></span> sudo ethtool &lt;interface name&gt;</code> </pre> <br>  Onde, em vez disso, pode estar, por exemplo, eth0 (ethtool est√° em pacotes Linux com o mesmo nome).  Se a op√ß√£o " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Ativar</a> " na sa√≠da mostrar g, hosts remotos poder√£o inicializar o sistema enviando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">MagicPacket</a> .  Se voc√™ n√£o deseja ligar remotamente o seu sistema e dar essa oportunidade a outras pessoas, desative o WOL no menu BIOS do sistema ou use: <br><br><pre> <code class="bash hljs"><span class="hljs-variable"><span class="hljs-variable">$#</span></span> sudo ethtool -s &lt;interface name&gt; wol d</code> </pre> <br>  Um processador que responde ao MagicPacket pode ser um BMC ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Baseboard Management Controller</a> ) ou parte de uma interface de rede. <br><br>  <i><b>Mecanismo de gerenciamento Intel, Hub do controlador de plataforma e Minix</b></i> <br><br>  O BMC n√£o √© o √∫nico microcontrolador (MCU) que pode "ouvir" um sistema desligado nominalmente.  Os sistemas X86_64 possuem o pacote de software Intel Management Engine (IME) para gerenciamento de sistemas remotos.  Uma ampla variedade de dispositivos, de servidores a laptops, possui tecnologia que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">possui recursos</a> como o KVM Remote Control ou o Intel Capability Licensing Service.  De acordo com a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pr√≥pria ferramenta de Inte</a> l, o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">IME possui vulnerabilidades sem patches.</a>  A m√° not√≠cia √© que desativar o IME √© dif√≠cil.  Trammell Hudson criou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">o projeto me_cleaner, que apaga</a> alguns dos componentes mais flagrantes do IME, como o servidor da Web incorporado, mas ao mesmo tempo h√° uma chance de que o uso do projeto torne o sistema no qual est√° sendo executado. <br><br>  O firmware IME e o programa SMM (System Management Mode) que o seguem na inicializa√ß√£o s√£o baseados no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">sistema operacional Minix</a> e executados em um processador separado do Platform Controller Hub, n√£o na CPU principal do sistema.  Em seguida, o SMM lan√ßa o programa UEFI (Universal Extensible Firmware Interface) no processador principal, que foi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">escrito mais de uma vez</a> .  O grupo Coreboot lan√ßou no Google um projeto espetacularmente ambicioso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">de firmware n√£o extens√≠vel a redu√ß√µes (NERF)</a> , que visa substituir n√£o apenas a UEFI, mas tamb√©m os primeiros componentes do espa√ßo do usu√°rio Linux, como systemd.  Enquanto isso, estamos aguardando os resultados, os usu√°rios do Linux podem comprar laptops da Purism, System76 ou Dell, nos quais o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">IME est√° desativado</a> , al√©m disso, podemos esperar laptops com um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">processador ARM de 64 bits</a> . <br><br>  <i><b>Carregadeiras</b></i> <i><b><br></b></i> <br>  O que o firmware inicializ√°vel faz al√©m do lan√ßamento do spyware suspeito?  A tarefa do carregador de inicializa√ß√£o √© fornecer ao processador que acabou de ser ativado os recursos necess√°rios para executar um sistema operacional de uso geral como o Linux.  Durante a inicializa√ß√£o, n√£o h√° apenas mem√≥ria virtual, mas tamb√©m DRAM at√© o momento de elevar seu controlador.  O carregador de inicializa√ß√£o liga as fontes de alimenta√ß√£o e varre os barramentos e interfaces para encontrar a imagem do kernel e o sistema de arquivos raiz.  Carregadores de inicializa√ß√£o populares, como U-Boot e GRUB, suportam interfaces comuns como USB, PCI e NFS, al√©m de outros dispositivos embarcados mais especializados, como NOR e NAND-flash.  Os carregadores tamb√©m interagem com dispositivos de hardware de seguran√ßa, como o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Trusted Platform Module (TPM)</a> , para estabelecer uma cadeia de confian√ßa desde o in√≠cio do download. <br><br><img src="https://habrastorage.org/webt/ur/fy/-n/urfy-neq9uuqezexjmitgdyg4aa.png"><br>  <i>Executando o carregador de inicializa√ß√£o em U na caixa de areia no servidor de compila√ß√£o.</i> <br><br>  O popular gerenciador de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">inicializa√ß√£o U-Boot de</a> c√≥digo aberto √© suportado por sistemas do Raspberry Pi a dispositivos Nintendo, placas para carros e Chromebooks.  N√£o h√° registro do sistema e, se algo der errado, pode at√© n√£o haver sa√≠da do console.  Para facilitar a depura√ß√£o, a equipe do U-Boot fornece uma caixa de prote√ß√£o para testar patches no host de compila√ß√£o ou mesmo no sistema de Integra√ß√£o Cont√≠nua.  Em um sistema com ferramentas de desenvolvimento comuns como o Git e o GNU Compiler Collection (GCC) instalado, √© f√°cil entender a sandbox do U-Boot. <br><br><pre> <code class="bash hljs"><span class="hljs-variable"><span class="hljs-variable">$#</span></span> git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> git://git.denx.de/u-boot; <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> u-boot <span class="hljs-variable"><span class="hljs-variable">$#</span></span> make ARCH=sandbox defconfig <span class="hljs-variable"><span class="hljs-variable">$#</span></span> make; ./u-boot =&gt; printenv =&gt; <span class="hljs-built_in"><span class="hljs-built_in">help</span></span></code> </pre><br>  Isso √© tudo: voc√™ lan√ßou o U-Boot no x86_64 e pode testar recursos complicados, por exemplo, reparticionamento de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">dispositivos de armazenamento fict√≠cios</a> , manipula√ß√£o de chave secreta baseada em TPM e hotplug de dispositivos USB.  A caixa de prote√ß√£o U-Boot pode ser de um est√°gio no depurador GDB.  O desenvolvimento usando a sandbox √© 10 vezes mais r√°pido que o teste, substituindo o gerenciador de inicializa√ß√£o no quadro; al√©m disso, a sandbox "brick" pode ser restaurada pressionando Ctrl + C. <br><br>  <b>Lan√ßamento do kernel</b> <br><br>  <i><b>Inicializando o fornecimento do kernel</b></i> <br><br>  Ap√≥s a conclus√£o de suas tarefas, o carregador de inicializa√ß√£o alternar√° para o c√≥digo do kernel que ele carregou na mem√≥ria principal e come√ßar√° a execut√°-lo, passando todos os par√¢metros da linha de comando especificados pelo usu√°rio.  Qual programa √© o kernel?  O arquivo / boot / vmlinuz mostra que √© o bzImage.  A √°rvore de origem do Linux possui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">uma ferramenta extract-vmlinux</a> que voc√™ pode usar para extrair o arquivo: <br><br><pre> <code class="bash hljs"><span class="hljs-variable"><span class="hljs-variable">$#</span></span> scripts/extract-vmlinux /boot/vmlinuz-$(uname -r) &gt; vmlinux <span class="hljs-variable"><span class="hljs-variable">$#</span></span> file vmlinux vmlinux: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, stripped</code> </pre><br>  O kernel √© um arquivo bin√°rio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Executable and Linking Format (ELF)</a> , como os programas de espa√ßo para usu√°rio do Linux.  Isso significa que podemos usar comandos binutils como readelf para aprend√™-lo.  Compare, por exemplo, as seguintes conclus√µes: <br><br><pre> <code class="bash hljs"><span class="hljs-variable"><span class="hljs-variable">$#</span></span> readelf -S /bin/date <span class="hljs-variable"><span class="hljs-variable">$#</span></span> readelf -S vmlinux</code> </pre><br>  A lista de parti√ß√µes em arquivos bin√°rios √© quase sempre semelhante. <br><br>  Portanto, o kernel deve lan√ßar outros bin√°rios ELF Linux ... Mas como os programas de espa√ßo do usu√°rio s√£o executados?  Na fun√ß√£o <code>main()</code> , certo?  Na verdade n√£o. <br><br>  Antes de executar a fun√ß√£o <code>main()</code> , os programas precisam de um contexto de execu√ß√£o, incluindo mem√≥ria heap- (heap) e stack- (stack), al√©m de descritores de arquivo para <code>stdio</code> , <code>stdout</code> e <code>stderr</code> .  Os programas de espa√ßo do usu√°rio obt√™m esses recursos da biblioteca padr√£o ( <code>glibc</code> para a maioria dos sistemas Linux).  Considere o seguinte: <br><br><pre> <code class="bash hljs"><span class="hljs-variable"><span class="hljs-variable">$#</span></span> file /bin/date /bin/date: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> GNU/Linux 2.6.32, BuildID[sha1]=14e8563676febeb06d701dbee35d225c5a8e565a, stripped</code> </pre> <br>  Os bin√°rios ELF t√™m um int√©rprete, assim como os scripts Bash e Python.  Mas n√£o precisa ser especificado atrav√©s de <code>#!</code>  como nos scripts, porque o ELF √© um formato nativo do Linux.  O interpretador ELF fornece ao arquivo bin√°rio todos os recursos necess√°rios, chamando <code>_start()</code> , uma fun√ß√£o dispon√≠vel no pacote de origem <code>glibc</code> , que pode ser aprendida atrav√©s do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GDB</a> .  O kernel, obviamente, n√£o possui um int√©rprete e deve se fornecer independentemente, mas como? <br><br>  Um estudo sobre como iniciar um kernel com GDB fornece uma resposta para esta pergunta.  Para come√ßar, instale o pacote de depura√ß√£o do kernel, que cont√©m a vers√£o sem cortes do <code>vmlinux</code> , por exemplo, <code>apt-get install linux-image-amd64-dbg</code> .  Ou compile e instale seu pr√≥prio kernel de alguma fonte, por exemplo, seguindo as instru√ß√µes do excelente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Debian Kernel Handbook</a> .  <code>gdb vmlinux</code> seguido pelos <code>info files</code> mostra a se√ß√£o ELF <code>init.text</code> .  Indique o in√≠cio da execu√ß√£o do programa no <code>init.text</code> com <code>l *(address)</code> , em que endere√ßo √© o in√≠cio hexadecimal do <code>init.text</code> .  O GDB indicar√° que o kernel x86_64 √© iniciado no <code><a href="">arch/x86/kernel/head_64.S</a></code> , onde encontramos a fun√ß√£o build <code>start_cpu0()</code> e o c√≥digo que cria explicitamente a pilha e descompacta o zImage antes de chamar <code>x86_64 start_kernel()</code> .  Os n√∫cleos ARM de 32 bits t√™m um <code><a href="">arch/arm/kernel/head.S. start_kernel()</a></code>  <code><a href="">arch/arm/kernel/head.S. start_kernel()</a></code> √© independente da arquitetura, portanto, a fun√ß√£o est√° localizada no kernel <code>init/main.c</code>  Podemos dizer que <code>start_kernel()</code> √© uma fun√ß√£o real <code>main()</code> Linux. <br><br>  <b>Do start_kernel () ao PID 1</b> <br>  <i><b>Manifesto de hardware do kernel: tabelas ACPI e √°rvores de dispositivos</b></i> <br><br>  Ao inicializar, o kernel precisa de informa√ß√µes sobre o hardware, al√©m do tipo de processador para o qual foi compilado.  As instru√ß√µes no c√≥digo s√£o complementadas por dados de configura√ß√£o, que s√£o armazenados separadamente.  Existem dois m√©todos principais para armazenar dados: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">√Årvores de</a> dispositivos e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tabelas ACPI</a> .  A partir desses arquivos, o kernel descobre qual equipamento precisa ser executado em cada inicializa√ß√£o. <br><br>  Para dispositivos incorporados, a √°rvore de dispositivos (DU) √© um manifesto do equipamento instalado.  DU √© um arquivo que √© compilado ao mesmo tempo que a fonte do kernel e geralmente est√° localizado em / boot junto com o <code>vmlinux</code> .  Para ver o que h√° na √°rvore de dispositivos bin√°rios no dispositivo ARM, basta usar o comando <code>strings</code> do pacote binutils no arquivo cujo nome corresponde a <code>/boot/*.dtb</code> , pois <code>dtb</code> significa o arquivo bin√°rio da √°rvore de dispositivos (Device-Tree Binary).  Voc√™ pode alterar o controle remoto editando os arquivos semelhantes a JSON nos quais ele consiste e reiniciando o compilador dtc especial fornecido com a fonte do kernel.  DU √© um arquivo est√°tico cujo caminho geralmente √© passado para o kernel por gerenciadores de inicializa√ß√£o na linha de comando, mas nos √∫ltimos anos uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">sobreposi√ß√£o de √°rvore de dispositivo</a> foi adicionada, na qual o kernel pode carregar dinamicamente fragmentos adicionais em resposta a eventos de hotplug ap√≥s o carregamento. <br><br>  A fam√≠lia x86 e muitos dispositivos no n√≠vel de neg√≥cios ARM64 usam o mecanismo alternativo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ACPI</a> (Advanced Configuration and Power Interface <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">)</a> .  Diferentemente do controle remoto, as informa√ß√µes da ACPI s√£o armazenadas no sistema de arquivos virtual <code>/sys/firmware/acpi/tables</code> , criado pelo kernel na inicializa√ß√£o, acessando a ROM interna.  Para ler tabelas ACPI, use o comando <code>acpica-tools</code> pacote <code>acpica-tools</code> .  Aqui est√° um exemplo: <br><br><img src="https://habrastorage.org/webt/gq/gw/mj/gqgwmjbpkadcvz6fbzyp7uc8gvg.png"><br>  <i>As tabelas ACPI nos laptops Lenovo est√£o prontas para o Windows 2001.</i> <br><br>  Sim, seu sistema Linux est√° pronto para o Windows 2001, se voc√™ deseja instal√°-lo.  A ACPI possui m√©todos e dados, em contraste com o controle remoto, que √© mais como uma linguagem de descri√ß√£o de hardware.  Os m√©todos ACPI continuam ativos ap√≥s a inicializa√ß√£o.  Por exemplo, se voc√™ executar o comando acpi_listen (do pacote apcid) e fechar e abrir a tampa do laptop, veremos que a funcionalidade da ACPI continuou funcionando todo esse tempo.  √â poss√≠vel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">reescrever</a> temporariamente e dinamicamente as <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tabelas ACPI</a> , mas as altera√ß√µes permanentes exigir√£o intera√ß√£o com o menu do BIOS na inicializa√ß√£o ou na atualiza√ß√£o da ROM.  Em vez de tais complexidades, talvez voc√™ deva <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">instalar o coreboot</a> , um substituto para o firmware de c√≥digo aberto. <br><br>  Do start_kernel () ao espa√ßo do usu√°rio <br><br>  O c√≥digo em <code><a href="">init/main.c</a></code> √© surpreendentemente f√°cil de ler e, curiosamente, ainda possui os direitos autorais originais de Linus Torvalds de 1991-1992.  Linhas encontradas em <code>dmesg | head</code>  <code>dmesg | head</code> sistema em execu√ß√£o se origina basicamente desse arquivo de origem.  A primeira CPU √© registrada pelo sistema, as estruturas de dados globais s√£o inicializadas, uma ap√≥s a outra, o agendador, manipuladores de interrup√ß√£o (IRQs), temporizadores e console s√£o gerados.  Todos os registros de data e hora antes de executar <code>timekeeping_init()</code> s√£o zero.  Essa parte da inicializa√ß√£o do kernel √© s√≠ncrona, ou seja, a execu√ß√£o ocorre em apenas um encadeamento.  As fun√ß√µes n√£o s√£o executadas at√© a √∫ltima delas ser conclu√≠da e retornada.  Como resultado, a sa√≠da do <code>dmesg</code> ser√° totalmente reproduz√≠vel mesmo entre os dois sistemas, desde que eles tenham as mesmas tabelas de controle remoto ou ACPI.  O Linux tamb√©m se comporta como um sistema operacional em tempo real (RTOS) em execu√ß√£o em um MCU, como QNX ou VxWorks.  Essa situa√ß√£o √© armazenada na fun√ß√£o <code>rest_init()</code> , chamada por <code>start_kernel()</code> no momento de sua conclus√£o. <br><br><img src="https://habrastorage.org/webt/dt/ge/49/dtge49gofpzdjlzk__surv1x9-o.png"><br>  <i>Uma breve descri√ß√£o do processo inicial de inicializa√ß√£o do kernel</i> <i><br></i> <br>  O nome modesto <code>rest_init()</code> cria um novo thread que executa <code>kernel_init()</code> , que por sua vez chama <code>do_initcalls()</code> .  Os usu√°rios podem monitorar a opera√ß√£o de <code>initcalls</code> adicionando <code>initcalls_debug</code> √† linha de comando do kernel.  Como resultado, voc√™ obter√° a entidade <code>dmesg</code> toda vez que executar a fun√ß√£o <code>initcall</code> .  <code>initcalls</code> passa por sete n√≠veis consecutivos: early, core, postcore, arch, subsys, fs, device e late.  A parte mais not√°vel do <code>initcalls</code> para os usu√°rios √© a identifica√ß√£o e instala√ß√£o de dispositivos perif√©ricos do processador: barramentos, rede, armazenamento, monitores e assim por diante, acompanhados pelo carregamento de seus m√≥dulos do kernel.  <code>rest_init()</code> tamb√©m cria um segundo encadeamento no processador de inicializa√ß√£o, que come√ßa executando <code>cpu_idle()</code> enquanto o planejador distribui seu trabalho. <br><br>  <code>kernel_init()</code> tamb√©m configura o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">multiprocessamento sim√©trico</a> (SMP).  Nos kernels modernos, voc√™ pode encontrar esse momento na sa√≠da dmesg na linha ‚ÄúTrazendo CPUs secund√°rias ...‚Äù.  O SMP ent√£o faz o hot plug da CPU, o que significa que ele gerencia seu ciclo de vida usando uma m√°quina de estado condicionalmente semelhante √†quelas usadas em dispositivos como cart√µes de mem√≥ria USB com detec√ß√£o autom√°tica.  O sistema de gerenciamento de energia do kernel geralmente desliga n√∫cleos individuais (n√∫cleos) e os ativa conforme necess√°rio, para que o mesmo c√≥digo da CPU de hotplug seja chamado repetidamente em uma m√°quina desocupada.  Veja como um sistema de gerenciamento de energia chama um hotplug da CPU usando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">uma ferramenta BCC</a> chamada <code>offcputime.py</code> . <br><br>  Observe que o c√≥digo em <code>init/main.c</code> quase terminou de executar quando <code>smp_init()</code> executado.  O processador de inicializa√ß√£o concluiu a maior parte da inicializa√ß√£o √∫nica, que outros kernels n√£o precisam repetir.  No entanto, os threads devem ser criados para cada n√∫cleo para controlar interrup√ß√µes (IRQs), fila de trabalho, temporizadores e eventos de energia em cada um.  Por exemplo, observe os encadeamentos do processador que atendem softirqs e linhas de trabalho com o comando <code>ps -o psr.</code> psr <code>ps -o psr.</code> <br><br><pre> <code class="bash hljs">$\<span class="hljs-comment"><span class="hljs-comment"># ps -o pid,psr,comm $(pgrep ksoftirqd) PID PSR COMMAND 7 0 ksoftirqd/0 16 1 ksoftirqd/1 22 2 ksoftirqd/2 28 3 ksoftirqd/3 $\# ps -o pid,psr,comm $(pgrep kworker) PID PSR COMMAND 4 0 kworker/0:0H 18 1 kworker/1:0H 24 2 kworker/2:0H 30 3 kworker/3:0H [ . . . ]</span></span></code> </pre> <br>  onde o campo PSR significa "processador".  Cada n√∫cleo deve ter seus pr√≥prios temporizadores e manipuladores de hotplug cpuhp. <br><br>  E, finalmente, como o espa√ßo do usu√°rio √© lan√ßado?  No final, o <code>kernel_init()</code> procurando por um <code>initrd</code> que possa iniciar o processo <code>init</code> em seu nome.  Caso contr√°rio, o kernel executa o <code>init</code> sozinho.  Por que ent√£o o <code>initrd</code> pode ser necess√°rio? <br><br>  <i><b>Espa√ßo inicial do usu√°rio: quem solicitou o initrd?</b></i> <br><br>  Al√©m da √°rvore de dispositivos, outro caminho init para o arquivo, opcionalmente fornecido pelo kernel na inicializa√ß√£o, pertence ao <code>initrd</code> .  <code>initrd</code> geralmente <code>initrd</code> localizado em / boot junto com o arquivo bzImage vmlinuz no x86, ou com uma uImage e uma √°rvore de dispositivos semelhantes para o ARM.  Uma lista do conte√∫do <code>intrd</code> pode ser visualizada usando a ferramenta <code>lsinitramfs</code> , que faz parte do pacote <code>initramfs-tools-core</code> .  A imagem de distribui√ß√£o do initrd cont√©m os diret√≥rios m√≠nimos <code>/bin</code> , <code>/sbin</code> e <code>/etc</code> , al√©m de m√≥dulos e arquivos do kernel em <code>/scripts</code> .  Tudo deve parecer mais ou menos familiar, j√° que o <code>initrd</code> em grande parte semelhante ao sistema de arquivos raiz simplificado do Linux.  Essa semelhan√ßa √© um pouco enganadora, j√° que quase todos os execut√°veis ‚Äã‚Äãem <code>/bin</code> e <code>/sbin</code> dentro do ramdisk s√£o links simb√≥licos para o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">bin√°rio BusyBox</a> , o que torna os diret√≥rios / bin e / sbin 10 vezes menores do que na <code>glibc</code> . <br><br>  Por que tentar criar um <code>initrd</code> se a √∫nica coisa que ele faz √© carregar alguns m√≥dulos e executar <code>init</code> em um sistema de arquivos raiz normal?  Considere um sistema de arquivos raiz criptografado.  A descriptografia pode depender do carregamento do m√≥dulo do kernel armazenado em <code>/lib/modules</code> sistema de arquivos raiz ... e, como esperado, no <code>initrd</code> .  O m√≥dulo de criptografia pode ser estaticamente compilado no kernel e n√£o carregado a partir de um arquivo, mas h√° v√°rios motivos para recusar isso.  Por exemplo, a compila√ß√£o est√°tica de um kernel com m√≥dulos pode torn√°-lo muito grande para caber no armazenamento dispon√≠vel ou a compila√ß√£o est√°tica pode violar os termos de licen√ßa do software.  Sem surpresa, drivers de armazenamento, redes e HIDs (dispositivos de entrada humanos) tamb√©m podem ser representados no <code>initrd</code> - essencialmente qualquer c√≥digo que n√£o seja uma parte necess√°ria do kernel necess√°ria para montar o sistema de arquivos raiz.  Tamb√©m no initrd, os usu√°rios podem armazenar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">seu pr√≥prio c√≥digo ACPI para tabelas</a> . <br><br><img src="https://habrastorage.org/webt/gx/nj/lj/gxnjljvh-gs47qpacftktsubl2e.png"><br>  <i>Divers√£o com shell de resgate e initrd personalizado.</i> <br><br>  <code>initrd</code> tamb√©m <code>initrd</code> √≥timo para testar sistemas de arquivos e dispositivos de armazenamento.  Coloque as ferramentas de teste no <code>initrd</code> e execute os testes da mem√≥ria, n√£o do objeto de teste. <br><br>  Finalmente, quando o <code>init</code> execu√ß√£o, o sistema est√° em execu√ß√£o!  Como os processadores secund√°rios j√° est√£o em execu√ß√£o, a m√°quina se tornou uma criatura ass√≠ncrona, paginada, imprevis√≠vel e de alto desempenho que todos conhecemos e amamos.  De fato, <code>ps -o pid,psr,comm -p</code> indica que o processo de <code>init</code> espa√ßo do usu√°rio n√£o est√° mais em execu√ß√£o no processador de inicializa√ß√£o. <br><br>  <b>Sum√°rio</b> <br><br>  O processo de inicializa√ß√£o do Linux parece proibido, dada a quantidade de software afetada, mesmo em um simples dispositivo incorporado.  Por outro lado, o processo de inicializa√ß√£o √© bastante simples, pois n√£o h√° complexidade excessiva causada pela exclus√£o de multitarefa, RCU e condi√ß√µes de corrida.  Prestando aten√ß√£o apenas ao kernel e ao PID 1, √© poss√≠vel ignorar o excelente trabalho realizado pelos gerenciadores de inicializa√ß√£o e processadores auxiliares para preparar a plataforma para o lan√ßamento do kernel.  O kernel certamente √© diferente de outros programas Linux, mas o uso de ferramentas para trabalhar com outros bin√°rios ELF ajudar√° a entender melhor sua estrutura.  Estudar um processo de inicializa√ß√£o vi√°vel se preparar√° para futuras falhas. <br><br>  O FIM <br><br>  Estamos aguardando seus coment√°rios e perguntas, como de costume, aqui ou na nossa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aula aberta,</a> onde Leonid ser√° surpreendido. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt425505/">https://habr.com/ru/post/pt425505/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt425493/index.html">Configurando o MikroTik hAP mini para IPTV Beeline</a></li>
<li><a href="../pt425497/index.html">Tutu PHP Meetup # 2: Transmiss√£o de eventos ao vivo</a></li>
<li><a href="../pt425499/index.html">HyperX Impact DDR4 - SO-DIMM que poderia! Ou por que, em um laptop, 64 GB de mem√≥ria com uma frequ√™ncia de 3200 MHz?</a></li>
<li><a href="../pt425501/index.html">Testes A / B no Android de A a Z</a></li>
<li><a href="../pt425503/index.html">Cassandra Sink para Spark Structured Streaming</a></li>
<li><a href="../pt425507/index.html">Wikipedia Parsim para tarefas de PNL em 4 equipes</a></li>
<li><a href="../pt425511/index.html">Recursos n√£o √≥bvios do aplicativo Rotativa para gerar PDF no aplicativo ASP.NET MVC</a></li>
<li><a href="../pt425515/index.html">Apple bloqueia reparo independente de novos modelos de MacBook</a></li>
<li><a href="../pt425517/index.html">Como o Yandex criou uma previs√£o global de precipita√ß√£o usando radares e sat√©lites</a></li>
<li><a href="../pt425521/index.html">M√©todos protegidos no JavaScript ES5</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>