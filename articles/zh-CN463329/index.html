<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔥 ☸️ 🤷🏿 使用SVG和Vue.js开发动态树图 🚂 👨🏼‍🚀 🏑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="我们今天发布的翻译材料专门用于开发动态树图可视化系统的过程。 为了绘制三次贝塞尔曲线，此处使用了SVG技术（可缩放矢量图形，可缩放矢量图形）。 数据的响应式工作由Vue.js组织。 

 这是您可以进行实验的系统的演示版本。 


 互动树形图 

 SVG强大功能与Vue.js框架的结合使我们能够...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>使用SVG和Vue.js开发动态树图</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/463329/"> 我们今天发布的翻译材料专门用于开发动态树图可视化系统的过程。 为了绘制三次贝塞尔曲线，此处使用了SVG技术（可缩放矢量图形，可缩放矢量图形）。 数据的响应式工作由Vue.js组织。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这是</a>您可以进行实验的系统<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的</a>演示版本。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/917/18f/9bb/91718f9bbe30a79beeeb537f7b49b07e.png"></div><br>  <i><font color="#999999">互动树形图</font></i> <br><a name="habracut"></a><br>  SVG强大功能与Vue.js框架的结合使我们能够创建一个用于构建基于数据，可交互且可自定义的图表的系统。 <br><br> 图表是从一个点开始的三次贝塞尔曲线的集合。 曲线终止于彼此等距的不同点。 它们的最终位置取决于用户输入的数据。 结果，该图表能够对数据变化做出反应。 <br><br> 首先，我们将讨论Bezier三次曲线的形成方式，然后我们将弄清楚如何在<code>&lt;svg&gt;</code>元素的坐标系中表示它们，并讨论为图像创建蒙版。 <br><br> 资料的作者说，她为他准备了许多插图，试图使他易于理解和有趣。 该材料的目的是帮助每个人获得开发自己的图表系统所需的知识和技能。 <br><br><h2>  <font color="#3AC1EF">SVG</font> </h2><br><h3>  <font color="#3AC1EF">cubic三次贝塞尔曲线如何形成？</font> </h3><br> 该项目中使用的曲线称为三次贝塞尔曲线。 下图显示了这些曲线的关键元素。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6f5/36f/6b1/6f536f6b1bf9ce9198e78640a17e49e6.png"></div><br>  <i><font color="#999999">贝塞尔曲线的关键元素</font></i> <br><br> 曲线由四对坐标描述。 第一对<code>(x0, y0)</code>是曲线的起始锚点。 最后一对坐标<code>(x3, y3)</code>是最终参考点。 <br><br> 在这些点之间，您可以看到所谓的控制点。 这是点<code>(x1, y1)</code>和点<code>(x2, y2)</code> 。 <br><br> 控制点相对于控制点的位置决定了曲线的形状。 如果曲线仅由起点和终点，坐标<code>(x0, y0)</code>和<code>(x3, y3)</code> ，则该曲线看起来像是对角线的直线段。 <br><br> 现在，我们将使用SVG <code>&lt;path&gt;</code>元素使用上述四个点的坐标绘制曲线。 这是<code>&lt;path&gt;</code>元素中用于构造三次贝塞尔曲线的语法： <br><br><pre> <code class="javascript hljs">&lt;path D=<span class="hljs-string"><span class="hljs-string">"M x0,y0 C x1,y1 x2,y2 x3,y3"</span></span> /&gt;</code> </pre> <br> 可以在代码中看到的字母<code></code>是三次贝塞尔曲线的缩写。 小写字母（ <code>c</code> ）表示使用相对值，大写字母（ <code>C</code> ）表示使用绝对值。 我使用绝对值来构建该图，该示例中使用的大写字母表示了这一点。 <br><br><h3>  <font color="#3AC1EF">▍创建对称图</font> </h3><br> 对称性是该项目的关键方面。 为了构建对称图，我仅使用了一个变量，并根据其接收诸如某个对象中心的高度，宽度或坐标之类的值。 <br><br> 我们将此变量命名为<code>size</code> 。 由于图表是水平放置的，因此可以将<code>size</code>变量视为图表可用的整个水平空间。 <br><br> 为该变量分配一个实际值。 我们将使用此值来计算图表元素的坐标。 <br><br><pre> <code class="javascript hljs">size = <span class="hljs-number"><span class="hljs-number">1000</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">查找图表元素的坐标</font> </h2><br> 在找到构建图表所需的坐标之前，我们需要处理SVG坐标系。 <br><br><h3>  <font color="#3AC1EF">ordinate坐标系和viewBox</font> </h3><br>  <code>&lt;svg&gt; viewBox</code>的属性在我们的项目中非常重要。 事实是它描述了SVG图像的用户坐标系。 简而言之， <code>viewBox</code>决定将在其中创建屏幕上可见的SVG图像的空间的位置和大小。 <br><br>  <code>viewBox</code>属性由四个数字组成，这些数字指定坐标系统的参数，其顺序如下： <code>min-x</code> ， <code>min-y</code> ， <code>width</code>和<code>height</code> 。  <code>min-x</code>和<code>min-y</code>参数设置用户坐标系的原点， <code>width</code>和<code>height</code>参数设置显示图像的宽度和高度。 这是<code>viewBox</code>属性的外观： <br><br><pre> <code class="javascript hljs">&lt;svg viewBox=<span class="hljs-string"><span class="hljs-string">"min-x min-y width height"</span></span>&gt;...&lt;<span class="hljs-regexp"><span class="hljs-regexp">/svg&gt;</span></span></code> </pre> <br> 我们上面描述的<code>size</code>变量将用于控制此坐标系的<code>width</code>和<code>height</code>参数。 <br><br> 稍后，在有关Vue.js的部分中，我们将把<code>viewBox</code>绑定到一个计算属性，以指定<code>width</code>和<code>height</code>值。 此外，在我们的项目中，属性<code>min-x</code>和<code>min-y</code>将始终设置为0。 <br><br> 请注意，我们不使用<code>&lt;svg&gt;</code>元素本身的<code>height</code>和<code>width</code>属性。 我们将使用CSS将它们设置为<code>width: 100%</code>和<code>height: 100%</code> 。 这将使我们能够创建可灵活调整为页面大小的SVG图像。 <br><br> 现在，用户坐标系已准备好绘制图表，让我们来谈谈使用<code>size</code>变量计算图表元素的坐标。 <br><br><h3>  <font color="#3AC1EF">▍不变和动态的坐标</font> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/efc/a82/d19/efca82d1952a08d5c3582acf7fcab49e.png"></div><br>  <i><font color="#999999">图表概念</font></i> <br><br> 显示图形的圆是该图的一部分。 因此，从一开始就将其包括在计算中很重要。 让我们根据上面的插图，找出圆和一条实验曲线的坐标。 <br><br> 图表的高度分为两部分。 它们分别是<code>topHeight</code> （ <code>size</code> 20％）和<code>bottomHeight</code> （ <code>size</code>的其余80％）。 图的总宽度分为两部分-每部分的长度为<code>size</code> 50％。 <br><br> 这样就可以得出圆弧参数的结论，无需特别说明（此处使用<code>halfSize</code>和<code>topHeight</code>指示符）。  <code>radius</code>参数设置为<code>topHeight</code>值的<code>topHeight</code> 。 因此，圆环非常适合可用空间。 <br><br> 现在让我们看一下曲线的坐标。 <br><br><ul><li> 坐标<code>(x0, y0)</code>定义曲线的起始参考点。 这些坐标始终保持不变。  <code>x0</code>坐标是图表的中心（ <code>size</code>一半），而<code>y0</code>是圆形底部结束的坐标。 因此，在用于计算该坐标的公式中，使用了圆的半径。 结果，可以通过以下公式找到该点的坐标<code>: (50% size, 20% size + radius)</code> 。 </li><li> 坐标<code>(x1, y1)</code>是曲线的第一个控制点。 所有曲线也保持不变。 如果我们不忘记曲线应该是对称的，那么<code>x1</code>和<code>y1</code>的值总是等于<code>size</code>一半。 因此，它们的计算公式为： <code>(50% size, 50% size)</code> 。 </li><li> 坐标<code>(x2, y2)</code>表示贝塞尔曲线的第二个控制点。  <code>x2</code>表示曲线应为什么形状。 该指标是为每条曲线动态计算的。 和以前一样，指标<code>y2</code>的<code>size</code>为一半。 因此，以下公式可用于计算这些坐标： <code>(x2, 50% size)</code> 。 </li><li> 坐标<code>(x3, y3)</code>是曲线的终点参考点。 该坐标指示您要在哪里完成绘制线条。 在此， <code>x3</code>的值（如<code>x2</code> ）是动态计算的。  <code>y3</code>的值等于<code>size</code> 80％。 结果，我们得到以下公式： <code>(x3, 80% size)</code> 。 </li></ul><br> 通常，我们考虑到刚得出的公式来重写<code>&lt;path&gt;</code>元素的代码。 上面使用的百分比通过将它们除以100得出。 <br><br><pre> <code class="javascript hljs">&lt;path d=<span class="hljs-string"><span class="hljs-string">"M size*0.5, (size*0.2) + radius          C size*0.5, size*0.5           x2,    size*0.5           x3,    size*0.8"</span></span> &gt;</code> </pre> <br> 请注意，乍看之下，仅根据我自己的观点，在我们的公式中使用百分比似乎是可选的。 但是，这些值并不是一时兴起的，而是因为它们的使用有助于实现对称性和正确比例的图表。 在感觉到它们在图表中的作用之后，您可以尝试自己的百分比值并检查通过应用它们获得的结果。 <br><br> 现在让我们讨论一下如何寻找坐标<code>x2</code>和<code>x3</code> 。 它们使您可以根据相应数组中元素的<code>index</code>动态创建许多曲线。 <br><br> 将图表的可用水平空间分成相等的部分是基于数组中元素的数量。 结果，每个零件沿x轴接收相同的空间。 <br><br> 我们得出的公式随后应可用于任何数量的元素。 但是这里我们将尝试一个包含5个元素的数组： <code>[0,1,2,3,4]</code> 。 这种阵列的可视化意味着必须绘制5条曲线。 <br><br><h3>  <font color="#3AC1EF">dynamic查找动态坐标（x2和x3）</font> </h3><br> 首先，我将<code>size</code>除以元素数，即除以数组的长度。 我称此为可变<code>distance</code> 。 它代表两个元素之间的距离。 <br><br><pre> <code class="javascript hljs">distance = size/arrayLength <span class="hljs-comment"><span class="hljs-comment">// distance = 1000/5 = 200</span></span></code> </pre> <br> 然后，我在数组周围走来走去，将其每个元素的<code>index</code> （ <code>index</code> ）乘以<code>distance</code> 。 为了简单起见，我只将<code>x2</code>参数和<code>x3</code>参数都称为<code>x</code> 。 <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  x2  x3 x = index * distance</span></span></code> </pre> <br> 如果在构建图表时应用获得的值，也就是说，对<code>x2</code>和<code>x3</code>使用上面计算的<code>x</code>值，将会有些奇怪。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/311/f53/1c6/311f531c60f80f01f519f0a128cfc164.png"></div><br>  <i><font color="#999999">该图是不对称的</font></i> <br><br> 如您所见，这些元素位于应放置的区域中，但是该图却是不对称的。 似乎在其左侧部分比右侧更多。 <br><br> 现在，我需要使<code>x3</code>值位于相应线段的中心，其长度是使用<code>distance</code>变量设置的。 <br><br> 为了使该图成为我需要的形式，我只是将<code>distance</code>一半添加到<code>x</code> 。 <br><br><pre> <code class="javascript hljs">x = index * distance + (distance * <span class="hljs-number"><span class="hljs-number">0.5</span></span>)</code> </pre> <br> 结果，我找到了<code>distance</code>段的中心，并在其中放置了<code>x3</code>坐标。 另外，我将表格<code>x2</code>坐标设为<code>x2</code>坐标。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e80/f69/f9d/e80f69f9d18b790c7634a9b12b2afc53.png"></div><br>  <i><font color="#999999">对称图</font></i> <br><br> 将<code>distance</code>值的一半加到<code>x2</code>和<code>x3</code>坐标上，使这些坐标的计算公式适合于可视化包含偶数和奇数元素的数组。 <br><br><h3>  <font color="#3AC1EF">▍图像遮罩</font> </h3><br> 我们需要在圆图的顶部显示一定的图像。 为了解决这个问题，我创建了一个包含圆圈的剪贴蒙版。 <br><br><pre> <code class="javascript hljs">&lt;defs&gt;  <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">mask</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"svg-mask"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">     </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">circle</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">:r</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"radius"</span></span></span></span><span class="xml"><span class="hljs-tag">             </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">:cx</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"halfSize"</span></span></span></span><span class="xml"><span class="hljs-tag">             </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">:cy</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"topHeight"</span></span></span></span><span class="xml"><span class="hljs-tag">             </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">fill</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"white"</span></span></span></span><span class="xml"><span class="hljs-tag">/&gt;</span></span></span><span class="xml">  </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">mask</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">defs</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre> <br> 然后，使用<code>&lt;image&gt;</code> <code>&lt;svg&gt;</code> <code>&lt;image&gt;</code>元素的<code>&lt;image&gt;</code>标签显示图像，我使用<code>&lt;image&gt;</code>元素的<code>mask</code>属性将图像链接到上面创建的<code>&lt;mask&gt;</code> <code>&lt;image&gt;</code>元素。 <br><br><pre> <code class="javascript hljs">&lt;image mask=<span class="hljs-string"><span class="hljs-string">"url(#svg-mask)"</span></span>      :x=<span class="hljs-string"><span class="hljs-string">"(halfSize-radius)"</span></span>      :y=<span class="hljs-string"><span class="hljs-string">"(topHeight-radius)"</span></span> ... &gt; <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">image</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre> <br> 由于我们试图将正方形图像拟合为圆形“窗口”，因此我通过从相应参数中减去<code>radius</code>参数来调整元素的位置。 结果，通过以圆形形式制成的掩模可以看到图像。 <br><br> 让我们收集我们在一张图纸中讨论的所有内容。 这将帮助我们了解工作进度的整体情况。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/38b/27e/37f/38b27e37ff2a7da017e0f67b7ac68b7e.png"></div><br>  <i><font color="#999999">用于计算图表参数的数据</font></i> <br><br><h2>  <font color="#3AC1EF">使用Vue.js创建动态SVG图像</font> </h2><br> 至此，我们找出了三次贝塞尔曲线，并进行了必要的计算以形成图表。 结果，我们现在可以创建静态SVG图。 如果我们结合SVG和Vue.js的功能，则可以创建由数据驱动的图。 静态图表将变为动态。 <br><br> 在本节中，我们修订SVG图，将其显示为一组Vue组件。 我们还将SVG属性附加到计算的属性，并使图表响应数据更改。 <br><br> 此外，在项目结束时，我们将创建一个配置面板组件。 该组件将用于输入要传输到图表的数据。 <br><br><h3>  <font color="#3AC1EF">▍将数据绑定到viewBox参数</font> </h3><br> 让我们从调整坐标系开始。 如果不这样做，我们将无法绘制SVG图像。 计算的<code>viewbox</code>属性将使用<code>size</code>变量返回我们需要的内容。 将有四个值，以空格分隔。 所有这些将成为<code>&lt;svg&gt;</code>元素的<code>viewBox</code>属性的值。 <br><br><pre> <code class="javascript hljs">viewbox() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"0 0 "</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.size + <span class="hljs-string"><span class="hljs-string">" "</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.size; }</code> </pre> <br> 在SVG中， <code>viewBox</code>属性的名称已经使用骆驼样式编写。 <br><br><pre> <code class="javascript hljs">&lt;svg viewBox=<span class="hljs-string"><span class="hljs-string">"0 0 1000 1000"</span></span>&gt; <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">svg</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre> <br> 因此，为了正确地将此属性绑定到计算出的属性，我以<code>.camel</code>样式写下了属性名称，并在<code>.camel</code>放置了<code>.camel</code>修饰符。 使用这种方法，可以“欺骗” HTML并正确实现属性绑定。 <br><br><pre> <code class="javascript hljs">&lt;svg :view-box.camel=<span class="hljs-string"><span class="hljs-string">"viewbox"</span></span>&gt;   ... &lt;<span class="hljs-regexp"><span class="hljs-regexp">/svg&gt;</span></span></code> </pre> <br> 现在，更改<code>size</code>独立重新配置图表。 我们不需要手动更改布局。 <br><br><h3>  <font color="#3AC1EF">curve曲线参数的计算</font> </h3><br> 由于构造曲线所需的大多数值都是基于单个变量（ <code>size</code> ）计算的，因此我使用计算出的属性来查找所有固定坐标。 我们所谓的“固定坐标”是根据<code>size</code>来计算的，此后它不会改变，并且不取决于图表将包含多少条曲线。 <br><br> 如果您更改<code>size</code> ，则会重新计算“固定坐标”。 在那之后，它们将不会更改，直到下一次更改<code>size</code> 。 鉴于以上所述，我们需要绘制五个值以绘制贝塞尔曲线： <br><br><ul><li> <code>topHeight — size * 0.2</code> </li> <li> <code>bottomHeight — size * 0.8</code> </li> <li> <code>width — size</code> </li> <li> <code>halfSize — size * 0.5</code> </li> <li> <code>distance — size/arrayLength</code> </li> </ul><br> 现在我们只剩下两个未知值<code>x2</code>和<code>x3</code> 。 我们已经得出了计算它们的公式： <br><br><pre> <code class="javascript hljs">x = index * distance + (distance * <span class="hljs-number"><span class="hljs-number">0.5</span></span>)</code> </pre> <br> 若要查找特定值，我们需要在此公式中替换数组元素的索引。 <br><br> 现在，让我们问问自己，计算出的属性是否适合我们找到<code>x</code> 。 简短地回答这个问题，然后-不，它不会做。 <br><br> 计算的属性不能传递参数。 事实是这是一个属性，而不是一个函数。 另外，需要使用参数来计算某些内容，这意味着在缓存方面使用计算出的属性没有明显的优势。 <br><br> 请注意，上述原则是一个例外。 关于Vuex。 如果使用返回函数的Vuex getter，则可以将参数传递给它们。 <br><br> 在这种情况下，我们不使用Vuex。 但是即使在这种情况下，我们也有两种方法可以解决此问题。 <br><br><h3>  <font color="#3AC1EF">▍选件编号1</font> </h3><br> 您可以声明一个函数，将<code>index</code>作为参数传递给该函数，并返回我们需要的结果。 如果我们要在模板的多个位置使用相似函数返回的值，则此方法看起来更干净。 <br><br><pre> <code class="javascript hljs">&lt;g v-<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>=<span class="hljs-string"><span class="hljs-string">"(item, i) in itemArray"</span></span>&gt;  <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">path</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">:d</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"'M' + halfSize + ','     + (topHeight+r) +' '+            'C' + halfSize + ','     + halfSize +' '+                     calculateXPos(i) + ',' + halfSize +' '+                  calculateXPos(i) + ',' + bottomHeight"</span></span></span></span><span class="xml"><span class="hljs-tag">  /&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">g</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre> <br> 每次调用<code>calculateXPos()</code>方法都会执行计算。 此方法将元素的索引<code>i</code>作为参数。 <br><br><pre> <code class="javascript hljs">&lt;script&gt;  methods: {    calculateXPos (i)    {      <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> distance * i + (distance * <span class="hljs-number"><span class="hljs-number">0.5</span></span>)    }  } &lt;<span class="hljs-regexp"><span class="hljs-regexp">/script&gt;</span></span></code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这是</a>使用此解决方案的CodePen上的示例。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/28e/dd6/b8c/28edd6b8cb97d3352108946cfb50a9cd.png"></div><br>  <i><font color="#999999">第一个应用程序变体的屏幕</font></i> <br><br><h3>  <font color="#3AC1EF">▍选项2</font> </h3><br> 此选项比第一个更好。 我们可以提取将曲线构建为单独的小子组件所需的小SVG标记，并将<code>index</code>作为属性之一传递给它。 <br><br> 通过这种方法，您甚至可以使用计算属性查找<code>x2</code>和<code>x3</code> 。 <br><br><pre> <code class="javascript hljs">&lt;g v-<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>=<span class="hljs-string"><span class="hljs-string">"(item, i) in items"</span></span>&gt;    <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">cubic-bezier</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">:index</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"i"</span></span></span></span><span class="xml"><span class="hljs-tag">                   </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">:half-size</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"halfSize"</span></span></span></span><span class="xml"><span class="hljs-tag">                   </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">:top-height</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"topHeight"</span></span></span></span><span class="xml"><span class="hljs-tag">                   </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">:bottom-height</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"bottomHeight"</span></span></span></span><span class="xml"><span class="hljs-tag">                   </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">:r</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"radius"</span></span></span></span><span class="xml"><span class="hljs-tag">                   </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">:d</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"distance"</span></span></span></span><span class="xml"><span class="hljs-tag">     &gt;</span></span></span><span class="xml">     </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">cubic-bezier</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">g</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre> <br> 此选项使我们有机会更好地组织代码。 例如，我们可以为遮罩创建另一个子组件： <br><br><pre> <code class="javascript hljs">&lt;clip-mask :title=<span class="hljs-string"><span class="hljs-string">"title"</span></span>           :half-size=<span class="hljs-string"><span class="hljs-string">"halfSize"</span></span>           :top-height=<span class="hljs-string"><span class="hljs-string">"topHeight"</span></span>                               :r=<span class="hljs-string"><span class="hljs-string">"radius"</span></span>&gt; <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">clip-mask</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre> <br><h3>  <font color="#3AC1EF">▍配置面板</font> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d04/7e6/54f/d047e654fc2c1cda88bb618db3668fda.png"></div><br>  <i><font color="#999999">配置面板</font></i> <br><br> 您可能已经看过配置面板，该面板由上<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">例</a>屏幕左上角的按钮调用。 通过此面板，可以轻松地向数组中添加元素并将其从数组中删除。 遵循“选项2”部分中讨论的想法，我为配置面板创建了一个子组件。 因此，顶层组件是干净且易于阅读的。 结果，我们的Vue组件树看起来有点像下面的树。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5af/fe8/172/5affe817227430e34e81425910a2b525.png"></div><br>  <i><font color="#999999">项目组件树</font></i> <br><br> 是否想看看实现此项目版本的代码？ 如果是这样，请在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这里</a>看看。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e4e/f1a/18b/e4ef1a18b00c15730adfc48077994608.png"></div><br>  <i><font color="#999999">第二个应用程序变体的屏幕</font></i> <br><br><h2>  <font color="#3AC1EF">项目资料库</font> </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这是</a>项目<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的</a> GitHub存储库（此处实现了“选项2”）。 我相信在继续下一部分之前，对它进行研究将对您很有用。 <br><br><h2>  <font color="#3AC1EF">家庭作业</font> </h2><br> 尝试创建与我们在此描述的图表相同的图表，但使其垂直定向。 利用本文概述的思想。 <br><br> 如果您认为这是一件容易的事，只要构建这样一个图就足够交换<code>x</code>和<code>y</code>坐标，那么您是对的。 考虑到此处考虑的项目并未创建为通用项目，因此在更改了所需位置的坐标后，还需要通过重命名一些变量和方法来编辑代码。 <br><br> 感谢Vue.js，我们的简单图表可以配备其他功能。 例如，以下内容： <br><br><ul><li> 您可以创建一种机制，使您可以在水平和垂直图表模式之间切换。 </li><li> 曲线可以尝试设置动画。 例如，使用GSAP。 </li><li> 您可以从配置面板调整曲线的属性（例如-颜色和线宽）。 </li><li> 您可以使用外部库来组织以任何图形格式或PDF文件格式保存的图表。 可以允许将这些材料下载到使用图表的人员。 </li></ul><br> 试试这个作业。 如果您有任何问题，请在下面找到其解决方案的链接。 <br><br><h2>  <font color="#3AC1EF">总结</font> </h2><br>  <code>&lt;path&gt;</code>元素是SVG的强大功能之一。 该元素使您可以高精度创建各种图像。 在这里，我们了解了Bezier曲线的结构，以及如何将其实践以创建自己的图。 <br><br>       ,  ,   JavaScript-.  Vue.js     .  ,   ,         , ,    DOM.        ,  —        . <br><br> ,    ,   ,  ,   ,      Vue.js  SVG.      —   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a> ,      Vue.js.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a> —   . <br><br>   ,       - ,   ,        ,   — . <br><br>  <b>亲爱的读者们！</b>      ? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN463329/">https://habr.com/ru/post/zh-CN463329/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN463313/index.html">订阅事件的一种替代方法，还是EventObject真的必要吗？</a></li>
<li><a href="../zh-CN463317/index.html">在AWS上入侵Capital One银行的技术细节</a></li>
<li><a href="../zh-CN463321/index.html">可用性查询和结帐：对俄罗斯前20家利基在线商店的分析</a></li>
<li><a href="../zh-CN463325/index.html">游戏设计师的反思：一款尚未问世的游戏角色</a></li>
<li><a href="../zh-CN463327/index.html">Vue.js：3种反模式</a></li>
<li><a href="../zh-CN463331/index.html">阿波罗客户。 现在有了React钩子</a></li>
<li><a href="../zh-CN463333/index.html">在2019年选择测试管理系统</a></li>
<li><a href="../zh-CN463335/index.html">在针对C和C ++的嵌入式系统的开发中使用PVS-Studio静态分析器</a></li>
<li><a href="../zh-CN463337/index.html">使用Immer管理React应用程序状态</a></li>
<li><a href="../zh-CN463347/index.html">开设了一组联合培训课程-IB和Belkasoft，涉及计算机取证</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>