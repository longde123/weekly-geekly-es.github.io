<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔎 🤶🏿 👏🏽 Tutoriel React, partie 19: Méthodes du cycle de vie des composants 📼 🗽 🧙🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans la partie d'aujourd'hui de la traduction du didacticiel React, vous verrez un aperçu des méthodes de cycle de vie des composants. 

  

 → Partie...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tutoriel React, partie 19: Méthodes du cycle de vie des composants</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/441578/">  Dans la partie d'aujourd'hui de la traduction du didacticiel React, vous verrez un aperçu des méthodes de cycle de vie des composants. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/kv/3m/yg/kv3mygzwigixivdzbagb80fvlvi.png" alt="image"></a> <br><br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 1: aperçu du cours, raisons de la popularité de React, ReactDOM et JSX</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 2: composants fonctionnels</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 3: fichiers composants, structure du projet</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 4: composants parent et enfant</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 5: début des travaux sur une application TODO, les bases du style</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 6: sur certaines fonctionnalités du cours, JSX et JavaScript</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 7: styles en ligne</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 8: poursuite des travaux sur l'application TODO, familiarité avec les propriétés des composants</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 9: propriétés des composants</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 10: Atelier sur l'utilisation des propriétés et du style des composants</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 11: génération de balisage dynamique et méthode des tableaux de cartes</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 12: atelier, troisième étape de travail sur une application TODO</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 13: composants basés sur les classes</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 14: atelier sur les composants basés sur les classes, état des composants</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 15: ateliers santé composante</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 16: quatrième étape de travail sur une application TODO, gestion d'événements</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 17: cinquième étape de travail sur une application TODO, modifiant l'état des composants</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 18: la sixième étape de travail sur une application TODO</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 19: méthodes du cycle de vie des composants</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 20: la première leçon de rendu conditionnel</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 21: deuxième leçon et atelier sur le rendu conditionnel</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 22: la septième étape des travaux sur une application TODO, téléchargement de données depuis des sources externes</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 23: première leçon sur l'utilisation des formulaires</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 24: Deuxième leçon sur les formulaires</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 25: Atelier sur l'utilisation des formulaires</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 26: architecture d'application, modèle de conteneur / composant</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 27: projet de cours</a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Leçon 34. Méthodes du cycle de vie des composants, partie 1</font> </h2><br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Original</a> <br><br>  L'une des caractéristiques du développement d'applications React est le fait que nous écrivons du code JavaScript assez simple qui pilote les mécanismes internes de React et nous offre ainsi de grandes opportunités pour développer des interfaces d'application et travailler avec des données.  Dans le même temps, les composants que nous utilisons au cours de leur cycle de vie passent par certaines étapes.  Souvent, ce qui arrive à un composant d'une application est comparé à la vie d'une personne.  Les gens naissent, vivent, dans leur vie des événements importants se produisent, après quoi ils meurent.  Les composants de React dans ce domaine sont similaires aux personnes, car ils sont également "nés", "vivants" et "morts".  En travaillant avec des composants, nous pouvons réagir à ce qui leur arrive, grâce aux méthodes de leur cycle de vie qui sont appelées à des moments particuliers de leur «vie». <br><br>  Récemment, l'équipe de développement React a dépassé les méthodes de cycle de vie à trois composants.  Nous considérerons néanmoins ces méthodes, puisqu'elles peuvent encore être utilisées, et puisqu'elles se trouvent dans le code existant.  De plus, deux nouvelles méthodes de cycle de vie des composants ont été ajoutées à React, dont nous discuterons dans la prochaine leçon. <br><br>  Nous ne considérerons que les méthodes les plus importantes qui sont les plus pertinentes pour ceux qui viennent de commencer à étudier React.  Lorsque vous continuez à maîtriser cette bibliothèque, vous pourrez expérimenter d'autres méthodes. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Voici</a> quelques bonnes informations sur les méthodes de cycle de vie des composants React qui étaient pertinentes avant React 16.3.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ici</a> , dans une publication du blog officiel des développeurs React, vous pouvez découvrir les changements survenus dans React 16.3. <br><br>  Maintenant, commençons la discussion sur les méthodes de cycle de vie des composants React que vous rencontrerez le plus souvent. <br><br>  Nous utiliserons, comme toujours, le projet de démonstration ici.  Dans ce cas, nous commençons avec un projet standard créé à l'aide de create- <code>App.js</code> -app, dans le fichier <code>App.js</code> qui contient le code suivant: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React, {Component} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"react"</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() {       <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>()       <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = {}   }     render() {       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (           <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">               Code goes here           </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>       )   } } <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> App</code> </pre> <br>  Pour commencer, examinons la méthode que vous avez déjà utilisée avec les composants basés sur les classes.  Il s'agit de la méthode <code>render()</code> . <br><br>  Souvent, il n'est pas mentionné lorsqu'il parle des méthodes de cycle de vie des composants.  Je pense que cette méthode, quand on compare un composant avec une personne, peut être comparée à s'habiller avant de sortir.  L'objectif de cette méthode est de déterminer ce qui sera affiché à l'écran, c'est-à-dire à quoi ressemblera le composant.  La méthode <code>render()</code> peut être appelée plusieurs fois au cours de la vie d'un composant.  Ainsi, lorsque React détermine que quelque chose lié à un composant a changé, comme un état ou des propriétés, c'est-à-dire quelque chose qui peut affecter l'apparence d'un composant, React peut appeler cette méthode.  Cela peut être comparé, si nous continuons l'analogie avec les gens, afin qu'une personne puisse décider de changer de vêtements.  Par exemple, afin de, après une journée de travail, se préparer à une sorte d'événement de vacances. <br><br>  Examinons maintenant une autre méthode de cycle de vie des <code>componentDidMount()</code> - <code>componentDidMount()</code> .  Cette méthode est déclarée, comme toute autre méthode de composant basée sur une classe, dans le corps d'une classe de composant: <br><br><pre> <code class="javascript hljs">componentDidMount() { }</code> </pre> <br>  Cette méthode est appelée au moment du cycle de vie du composant, qui peut être comparée à la «naissance» de ce composant.  Cette méthode est déclenchée une fois après que le composant est monté (inséré) dans l'arborescence DOM.  Dans le même temps, par exemple, si après avoir modifié certaines données qui affectent l'apparence du composant, elles seront à nouveau rendues, la méthode <code>componentDidMount()</code> ne sera pas appelée.  Cela se produit du fait que lors de l'exécution de telles opérations, le composant n'est pas supprimé de l'arborescence DOM, puis à nouveau inclus dans l'arborescence. <br><br>  La méthode <code>componentDidMount()</code> est généralement utilisée pour effectuer des appels à certaines API dans les cas où le développeur a besoin de données provenant de sources externes.  Supposons que le composant que nous considérons ici s'appelle en fait <code>TodoList</code> et est un composant qui forme une liste de tâches dans une application Todo.  La méthode <code>componentDidMount()</code> d'un tel composant peut charger des matériaux de la base de données du serveur qui sont nécessaires pour l'affichage correct de la liste de tâches stockée sur le serveur.  Par conséquent, une fois l'installation du composant terminée, nous pouvons, dans la méthode <code>componentDidMount()</code> , charger les données nécessaires pour que le composant s'affiche correctement sur la page.  Nous parlerons également du chargement des données nécessaires aux composants, mais pour le moment, vous vous souviendrez que c'est le cas d'utilisation le plus courant pour <code>componentDidMount()</code> . <br><br>  La prochaine méthode de cycle de vie des composants dont nous discutons est appelée <code>componentWillReceiveProps()</code> .  Cette méthode peut être comparée à ce qui se passe lorsque quelqu'un reçoit un cadeau de quelqu'un.  Ainsi, un composant peut recevoir des propriétés d'un composant parent.  Chaque fois qu'un composant prend des propriétés, cette méthode est appelée.  En même temps, cette méthode est appelée chaque fois que le composant parent transmet les propriétés au composant enfant, et pas seulement lorsque cela se produit pour la première fois.  Par exemple, si le composant parent décide de modifier les propriétés transmises au composant enfant, alors, dans la méthode <code>componentWillReceiveProps()</code> , nous pouvons, par exemple, vérifier si les nouvelles propriétés diffèrent de celles qui ont déjà été transmises au composant.  Le fait est que si les nouvelles propriétés ne diffèrent pas des anciennes, cela signifie que leur réception ne change rien, ce qui signifie qu’après avoir découvert, nous ne pouvons rien faire de plus.  Si les nouvelles propriétés sont différentes des anciennes, nous pouvons effectuer certaines actions.  En règle générale, cette méthode est déclarée dans le corps de la classe de composants comme suit: <br><br><pre> <code class="javascript hljs">componentWillReceiveProps(nextProps) { }</code> </pre> <br>  Ici, il est généralement utilisé comme nom de paramètre, <code>nextProps</code> , mais vous pouvez nommer ce paramètre comme vous le souhaitez.  Afin de comparer une propriété spécifique qui a déjà été transférée au composant avec ce qui lui a déjà été transmis plus tôt et de décider d'autres actions, vous pouvez utiliser cette construction: <br><br><pre> <code class="javascript hljs">componentWillReceiveProps(nextProps) {   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextProps.whatever !== <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.whatever) {       <span class="hljs-comment"><span class="hljs-comment">//   -    } }</span></span></code> </pre> <br>  Habituellement, cette méthode est utilisée de cette façon. <br><br>  Cependant, comme déjà mentionné, après la sortie de React 16.3, certaines méthodes du cycle de vie des composants ont été dépréciées, et <code>componentWillReceiveProps()</code> est l'une de ces méthodes. <br><br>  Jusqu'à React 17, ces méthodes héritées peuvent toujours être utilisées, mais il vaut mieux ne pas le faire.  Si vous ne pouvez pas vous passer de la méthode en question, vous devez l'appeler <code>UNSAFE_componentWillReceiveProps()</code> .  Après React 17, le nom de la méthode <code>componentWillReceiveProps()</code> ne signifie rien de spécial. <br><br>  Il est utile de connaître cette méthode afin de pouvoir comprendre du code obsolète, mais il ne sera pas utilisé dans le développement d'applications React modernes. <br><br>  Une autre méthode intéressante de cycle de vie des composants est appelée <code>shouldComponentUpdate()</code> .  Lui, si nous continuons à comparer la composante avec une personne, se souvient du moment où une personne se demande si elle doit changer de vêtements ou non.  Dans des conditions normales, si React n'est pas complètement sûr de la nécessité de restituer un composant, il le restituera juste au cas où.  Peu importe si cela est nécessaire, conformément à la logique d'application ou non. <br><br>  Cela fait que React restitue les composants, même lorsque rien lié au composant ne change.  Cela peut ralentir l'application, car selon ce principe, React traite tous les composants qui composent l'application.  La méthode <code>shouldComponentUpdate()</code> permet au développeur d'optimiser l'application.  Ici, vous pouvez implémenter une logique qui aide à comprendre la nécessité de mettre à jour le composant.  Cette méthode est généralement déclarée comme ceci: <br><br><pre> <code class="javascript hljs">shouldComponentUpdate(nextProps, nextState) {   <span class="hljs-comment"><span class="hljs-comment">//  true        //  false    }</span></span></code> </pre> <br>  De plus, à partir de cette méthode, si le composant a besoin d'un nouveau rendu, en tenant compte des nouvelles propriétés et de l'état, vous devez retourner <code>true</code> .  Sinon, <code>false</code> doit en être retourné.  En fait, renvoyer <code>false</code> partir de cette méthode conduit au fait que le composant n'est pas mis à jour et que l'application s'exécute plus rapidement, mais en faisant cela, vous devez vous assurer que le composant n'a pas vraiment besoin d'être restitué.  Si le composant doit être mis à jour et que cette méthode est retournée <code>false</code> , cela entraînera des erreurs difficiles à gérer. <br><br>  Une autre méthode de cycle de vie des composants dont nous parlerons s'appelle <code>componentWillUnmount()</code> .  Cette méthode marque la fin de la «vie» du composant - le moment où il est supprimé de l'arborescence DOM et disparaît de l'écran. <br><br>  Cette méthode est principalement utilisée pour libérer des ressources occupées par un composant et mettre les choses en ordre avant de le supprimer.  Par exemple, si quelque chose comme un écouteur d'événements a été configuré dans la méthode <code>componentDidMount()</code> , en raison duquel, lorsque l'utilisateur fait défiler la page, du code est exécuté, c'est dans <code>componentWillUnmount()</code> vous pouvez supprimer un tel écouteur d'événements.  En fait, cette méthode a de nombreuses applications qui visent à supprimer de l'application tout ce qui s'avère inutile après la disparition du composant. <br><br>  Voici le code complet de notre composant <code>App</code> , dans lequel des méthodes de cycle de vie sont ajoutées: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React, {Component} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"react"</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() {       <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>()       <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = {}   }     componentDidMount() {       <span class="hljs-comment"><span class="hljs-comment">//  ,        }     componentWillReceiveProps(nextProps) {       if (nextProps.whatever !== this.props.whatever) {           //   -        }   }     shouldComponentUpdate(nextProps, nextState) {       //  true            //  false      }     componentWillUnmount() {       //            // ( -   )   }     render() {       return (           &lt;div&gt;               Code goes here           &lt;/div&gt;       )   } } export default App</span></span></code> </pre> <br>  Ceci conclut cette leçon, même s'il convient de noter que les méthodes de cycle de vie des composants React ne sont pas limitées à celles que nous avons examinées aujourd'hui. <br><br><h2>  <font color="#3AC1EF">Leçon 35. Méthodes du cycle de vie des composants, partie 2</font> </h2><br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Original</a> <br><br>  Comme déjà mentionné dans la leçon précédente, lorsque React 16.3 est sorti, il a été signalé que les méthodes du cycle de vie à trois composants étaient dépassées.  Ces méthodes sont <code>componentWillMount()</code> , <code>componentWillReceiveProps()</code> et <code>componentWillUpdate()</code> .  Deux nouvelles méthodes ont également été signalées.  Il s'agit de la méthode <code>getDerivedStateFromProps()</code> statique et de la méthode <code>getSnapshotBeforeUpdate()</code> .  On ne peut pas dire que ces méthodes joueront un rôle important dans les futures classes de ce cours, mais malgré cela, nous les apprendrons ici. <br><br>  Nous expérimenterons le même projet que nous avons utilisé la dernière fois. <br><br>  Voici à quoi ressemble la déclaration de la méthode <code>getDerivedStateFromProps()</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> getDerivedStateFromProps(props, state) { }</code> </pre> <br>  Notez le <code>static</code> avant le nom de la méthode.  Il, sur la base des propriétés acceptées par lui, doit retourner un état mis à jour.  Il est utilisé dans les cas où un certain composant doit accepter les propriétés entrantes qu'il reçoit du composant parent et configurer son état en fonction de ces propriétés.  Des détails sur cette méthode peuvent être trouvés <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> .  Ce matériel, publié sur le blog React, dit que l'utilisation de cette méthode est loin d'être justifiée dans toutes les situations où elle semble utile.  Son utilisation incorrecte peut conduire à diverses erreurs, à une baisse des performances de l'application, alors utilisez-la avec prudence.  Vous ne devriez pas essayer de résoudre des problèmes avec son aide, pour la solution de laquelle il n'est pas prévu.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Voici la</a> documentation de cette méthode. <br><br>  Parlons maintenant de la méthode <code>getSnapshotBeforeUpdate()</code> .  Voici à quoi ressemble sa déclaration dans le corps de la classe: <br><br><pre> <code class="javascript hljs">getSnapshotBeforeUpdate() { }</code> </pre> <br>  Elle peut être considérée comme une méthode de cycle de vie qui vous permet de créer quelque chose comme une sauvegarde de ce qui est dans le composant avant de le mettre à jour.  Il ressemble à un instantané de l'état d'une application.  Il convient de noter que les développeurs de React disent que la portée de cette méthode est limitée.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Voici la</a> documentation pour cela. <br><br><h2>  <font color="#3AC1EF">Résumé</font> </h2><br>  Aujourd'hui, nous avons parlé des méthodes de cycle de vie des composants.  Lorsque vous avancerez dans le développement d'applications React, elles vous seront certainement utiles.  Dans les autres classes de ce cours, nous rencontrerons ces méthodes, en particulier, avec <code>componentDidMount()</code> .  La prochaine fois, nous parlerons du rendu conditionnel. <br><br>  <b>Chers lecteurs!</b>  Si vous développez professionnellement des applications React, veuillez nous expliquer comment vous utilisez les méthodes de cycle de vie des composants. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr441578/">https://habr.com/ru/post/fr441578/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr441568/index.html">Gestion de la mémoire Python</a></li>
<li><a href="../fr441570/index.html">Le condensé de matières fraîches du monde du front-end de la dernière semaine n ° 353 (17-24 février 2019)</a></li>
<li><a href="../fr441572/index.html">Frontend Weekly Digest (18-24 février 2019)</a></li>
<li><a href="../fr441574/index.html">Apprendre Docker Partie 6: Travailler avec des données</a></li>
<li><a href="../fr441576/index.html">Réseaux Kubernetes: Pods</a></li>
<li><a href="../fr441580/index.html">Tutoriel React, partie 20: Première leçon de rendu conditionnel</a></li>
<li><a href="../fr441582/index.html">Optimisation du système de contrôle LQR</a></li>
<li><a href="../fr441584/index.html">PHP Digest n ° 150 (11-25 février 2019)</a></li>
<li><a href="../fr441586/index.html">Comment recommander une musique que presque personne n'a écoutée. Rapport Yandex</a></li>
<li><a href="../fr441590/index.html">L'évolution de l'interaction de cluster. Comment nous avons implémenté ActiveMQ et Hazelcast</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>