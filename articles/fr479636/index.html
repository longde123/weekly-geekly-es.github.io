<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§∞üèæ ü¶í üíÖüèæ Propre pile de navigation. Mieux que ROS? üë©üèº‚Äç‚öïÔ∏è üëèüèø üßëüèø‚Äçü§ù‚ÄçüßëüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ceci est le deuxi√®me article de l'√©quipe setUP sur notre exp√©rience dans la cr√©ation de robots autonomes pour les comp√©titions Eurobot Open et l'utili...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Propre pile de navigation. Mieux que ROS?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/479636/"> Ceci est le deuxi√®me article de l'√©quipe setUP sur notre exp√©rience dans la cr√©ation de robots autonomes pour les comp√©titions Eurobot Open et l'utilisation de ROS pour cela. <br><br>  <a href="https://habr.com/ru/post/478836/">Le premier article concerne la m√©canique et l'architecture g√©n√©rale des robots.</a> <br><br>  Les robots voyagent sur un terrain plat et la plupart des obstacles sont connus √† l'avance, cependant, des adversaires insidieux peuvent essayer de voler nos ressources (et nous voulons parfois manger quelques dizaines de points suppl√©mentaires), tandis que nous voulons conduire au point souhait√© le plus rapidement possible et ne pas toucher les obstacles.  √Ä partir d'une cam√©ra externe sur le terrain, nous obtenons des donn√©es sur la position de l'ennemi et savons o√π il se trouve actuellement.  Cependant, il ne suffit pas de conna√Ætre sa position - vous devez pouvoir utiliser ces informations. <br><br>  Aujourd'hui, nous allons essayer de conduire du point A au point B sans avoir voyag√© le long de la queue d'un chat qui s'est endormi sur le terrain.  En particulier, nous expliquerons comment nous construisons un itin√©raire et contr√¥lons la vitesse du robot, ainsi que comment d√©marrer tout sur notre ordinateur. <br><br><img src="https://habrastorage.org/webt/om/x0/a6/omx0a6wfefbht9c1pialld-9vqy.png"><br><a name="habracut"></a><br><h3>  Essayer de s'en sortir avec un peu de sang </h3><br>  En r√©solvant ce probl√®me, vous pouvez prendre du mat√©riel pr√™t √† l'emploi √©crit par des professionnels, puis il n'y aura pas de tourment et d'invention du prochain ¬´v√©lo¬ª.  Nous avons utilis√© une plate-forme omnidirectionnelle, donc bien qu'il y ait eu une tentative d'utiliser une raboteuse locale pr√™te √† l'emploi de ROS, pour un certain nombre de raisons, ils ont trouv√© que cela n'√©tait pas prometteur.  Ci-dessous, vous pouvez voir combien de choses le concepteur d'un planeur standard a besoin: <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** * @class TrajectoryPlanner * @brief Computes control velocities for a robot given a costmap, a plan, and the robot's position in the world. */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TrajectoryPlanner</span></span></span><span class="hljs-class">{</span></span> <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TrajectoryPlannerTest</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">//Need this for gtest to work public: /** * @brief Constructs a trajectory controller * @param world_model The WorldModel the trajectory controller uses to check for collisions * @param costmap A reference to the Costmap the controller should use * @param footprint_spec A polygon representing the footprint of the robot. (Must be convex) * @param inscribed_radius The radius of the inscribed circle of the robot * @param circumscribed_radius The radius of the circumscribed circle of the robot * @param acc_lim_x The acceleration limit of the robot in the x direction * @param acc_lim_y The acceleration limit of the robot in the y direction * @param acc_lim_theta The acceleration limit of the robot in the theta direction * @param sim_time The number of seconds to "roll-out" each trajectory * @param sim_granularity The distance between simulation points should be small enough that the robot doesn't hit things * @param vx_samples The number of trajectories to sample in the x dimension * @param vtheta_samples The number of trajectories to sample in the theta dimension * @param pdist_scale A scaling factor for how close the robot should stay to the path * @param gdist_scale A scaling factor for how aggresively the robot should pursue a local goal * @param occdist_scale A scaling factor for how much the robot should prefer to stay away from obstacles * @param heading_lookahead How far the robot should look ahead of itself when differentiating between different rotational velocities * @param oscillation_reset_dist The distance the robot must travel before it can explore rotational velocities that were unsuccessful in the past * @param escape_reset_dist The distance the robot must travel before it can exit escape mode * @param escape_reset_theta The distance the robot must rotate before it can exit escape mode * @param holonomic_robot Set this to true if the robot being controlled can take y velocities and false otherwise * @param max_vel_x The maximum x velocity the controller will explore * @param min_vel_x The minimum x velocity the controller will explore * @param max_vel_th The maximum rotational velocity the controller will explore * @param min_vel_th The minimum rotational velocity the controller will explore * @param min_in_place_vel_th The absolute value of the minimum in-place rotational velocity the controller will explore * @param backup_vel The velocity to use while backing up * @param dwa Set this to true to use the Dynamic Window Approach, false to use acceleration limits * @param heading_scoring Set this to true to score trajectories based on the robot's heading after 1 timestep * @param heading_scoring_timestep How far to look ahead in time when we score heading based trajectories * @param meter_scoring adapt parameters to costmap resolution * @param simple_attractor Set this to true to allow simple attraction to a goal point instead of intelligent cost propagation * @param y_vels A vector of the y velocities the controller will explore * @param angular_sim_granularity The distance between simulation points for angular velocity should be small enough that the robot doesn't hit things */ TrajectoryPlanner(WorldModel&amp; world_model, const costmap_2d::Costmap2D&amp; costmap, std::vector&lt;geometry_msgs::Point&gt; footprint_spec, double acc_lim_x = 1.0, double acc_lim_y = 1.0, double acc_lim_theta = 1.0, double sim_time = 1.0, double sim_granularity = 0.025, int vx_samples = 20, int vtheta_samples = 20, double pdist_scale = 0.6, double gdist_scale = 0.8, double occdist_scale = 0.2, double heading_lookahead = 0.325, double oscillation_reset_dist = 0.05, double escape_reset_dist = 0.10, double escape_reset_theta = M_PI_2, bool holonomic_robot = true, double max_vel_x = 0.5, double min_vel_x = 0.1, double max_vel_th = 1.0, double min_vel_th = -1.0, double min_in_place_vel_th = 0.4, double backup_vel = -0.1, bool dwa = false, bool heading_scoring = false, double heading_scoring_timestep = 0.1, bool meter_scoring = true, bool simple_attractor = false, std::vector&lt;double&gt; y_vels = std::vector&lt;double&gt;(0), double stop_time_buffer = 0.2, double sim_period = 0.1, double angular_sim_granularity = 0.025);</span></span></code> </pre> <br>  <i>Il s'agit d'un exemple d'initialisation des param√®tres de r√©gulation des vitesses et de la trajectoire dans son ensemble.</i> <br><br>  Param√®tres importants pour un calcul complet: <br><br><ol><li>  Param√®tre world_model. </li><li>  Param√®tre de carte de co√ªt: un lien vers une carte contenant des obstacles, ainsi que leur "extension virtuelle", en tenant compte de la collision potentielle. </li></ol><br>  Parmi les avantages de la pile standard, vous pouvez souligner la disponibilit√© de la documentation et la possibilit√© de trouver des informations sur les forums.  <a href="https://github.com/ros-planning/navigation" rel="nofollow">Vous pouvez en savoir plus sur le site officiel avec la documentation</a> <br><br>  Il est important de mentionner que les packages ROS ont √©t√© √©crits pour les plates-formes √† deux roues et sous Omni, ils ont √©t√© optimis√©s en augmentant l'angle de rotation disponible lors d'un d√©placement jusqu'√† 360 degr√©s, ce qui est certainement une b√©quille. <br><br>  Apr√®s avoir analys√© le projet, nous avons r√©alis√© qu'il y aurait une difficult√© √† √©tudier et √† compl√©ter, ainsi que de nombreuses puces lourdes dont nous n'avons pas besoin.  Il semblerait que ce soit le cas, mais nous avons utilis√© Odroid xu4 (dont le processeur √©tait toujours sur Samsung s5), et les r√©sultats de performance √©taient d√©primants, et l'espace pour quelque chose de plus puissant (et la framboise 4 et le processeur nets jetson fument nerveusement de c√¥t√© par rapport √† avec lui) non.  J'ai d√ª abandonner la pile standard et essayer de cr√©er nous-m√™me le planificateur global, le planificateur local et le r√©gulateur de trajectoire <br><br><img src="https://habrastorage.org/webt/ij/qe/es/ijqeesrak1vuhjqfr1ij6exr4_a.jpeg"><br><br><h3>  Planificateur global, planificateur local, r√©gulateur de trajectoire et tous tous tous </h3><br>  Des planeurs mondiaux et locaux sont n√©cessaires pour obtenir les directions vers la destination.  Pourquoi la s√©paration est-elle n√©cessaire?  Pourquoi ne pouvez-vous pas simplement prendre <a href="https://ru.wikipedia.org/wiki/A*" rel="nofollow">A *</a> et le monter?  En r√®gle g√©n√©rale, un planificateur global, lors de la construction d'un itin√©raire, peut utiliser la carte enti√®re dans son travail, donc l'algorithme doit √™tre aussi rapide que possible, peut-√™tre m√™me avec quelques simplifications.  Pour lisser ces simplifications, ils utilisent √©galement le planificateur local, qui, bas√© sur le r√©sultat du planificateur global (ou juste une zone limit√©e autour du robot), essaie de prendre en compte toutes les nuances. <br><br>  Apr√®s avoir construit l'itin√©raire, nous savons o√π le robot doit aller, mais comment peut-il √™tre inform√© de cela?  Pour ce faire, il existe un r√©gulateur de trajectoire.  Il calcule √† quelle vitesse et dans quelle direction le robot doit se d√©placer en ce moment pour ne pas d√©vier de la trajectoire.  √Ä bien des √©gards, ce package est responsable de la vitesse et de la beaut√© du robot. <br><br>  En plus de ces trois entit√©s, il y en a une quatri√®me - un serveur de carte, qui vous permet de traiter facilement l'√©tat du monde.  Il d√©finit comment nous d√©crivons la carte, quelles possibilit√©s nous avons lorsque nous travaillons avec la carte et, √† bien des √©gards, d√©termine la vitesse des planeurs. <br><br>  Avant de proc√©der √† la description de la pile de navigation, il serait int√©ressant de d√©crire les raisons pour lesquelles cost_map a √©t√© choisi comme serveur de carte.  En g√©n√©ral, nous avons essay√© diff√©rentes options pour le gestionnaire de carte: <a href="https://github.com/IntelRealSense/realsense-ros/tree/occupancy-mapping" rel="nofollow">Occupancy_grid</a> , <a href="http://wiki.ros.org/grid_map" rel="nofollow">Grid_map</a> , <a href="https://github.com/stonier/cost_map" rel="nofollow">Cost_map</a> , mais nous nous sommes install√©s sur ce dernier. <br><br>  Raisons: <br><br><ol><li>  Interagissez facilement avec la carte. </li><li>  Il existe diff√©rents it√©rateurs dont nous avons besoin sous diverses formes (circulaire, lin√©aire, rectangulaire, etc.). </li><li>  Vous pouvez stocker plusieurs couches de carte avec diff√©rents param√®tres. </li><li>  Bonne gestion de la m√©moire. </li><li>  Et surtout, la vitesse.  La carte de grille fonctionne avec un type double et pour cette raison, elle est plusieurs fois plus lente que les serveurs de carte qui utilisent int8 pour fonctionner. </li></ol><br>  Malgr√© le fait que la grille d'occupation fonctionne √©galement avec int8, elle ne peut pas se vanter de la m√™me convivialit√©, j'ai donc d√ª l'abandonner. <br><br>  √Ä partir de la carte, nous devons savoir o√π se trouvent les zones libres, dangereuses et irr√©sistibles.  Pour chaque objet qui se trouve sur le terrain, nous pouvons ajuster le champ de gonflage - une valeur qui, en fonction de la distance √† l'objet, caract√©rise la perm√©abilit√© de la cellule.  L'inflation est la queue du chat, il est facile de ne pas le remarquer, mais vous le regretterez tr√®s longtemps.  Nous cartographions les robots ennemis et ajoutons une zone de danger que seul le planificateur local prend en compte.  Le planificateur global ignore tous les points, s'ils ne sont pas un obstacle. <br><br><h4>  Planificateur mondial </h4><br>  La premi√®re chose qu'ils ont √©crite dans la navigation est le planificateur global.  Il est bas√© sur l'algorithme th√™ta *.  En bref, il s'agit d'un <a href="https://ru.wikipedia.org/wiki/A*" rel="nofollow">A *</a> modifi√©, o√π l'accent est mis sur la recherche du n≈ìud parent, qui peut √™tre atteint directement, c'est-√†-dire  il n'y a aucun obstacle pour elle.  Cela nous permet de construire des chemins pratiques et lisses qui sont utilis√©s dans le planificateur local. <br><br><img src="https://habrastorage.org/webt/it/qs/e4/itqse4uuumbbzu8rxws07gapbn8.png"><br>  <i>Comparaison de A * et th√™ta *</i> <br><br>  Pour le planificateur global, nous avons un fichier avec des param√®tres (params / path_planner.yaml) qui d√©crit les sujets de la carte et les sujets avec l'emplacement de tous les robots (pour les quatre robots sur le terrain, o√π "null" est le sujet avec des donn√©es sur le robot actuel). <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta"># small robot debug param list robot_id: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"small"</span></span></span><span class="hljs-meta"> ########################### # cost_map_server params ## ########################### cost_map_server/big_robot_size: 0.45 cost_map_server/little_robot_size: 0.45 cost_map_server/cube_size: 0.11 cost_map_server/inscribed_radius: 0.3 cost_map_server/inflation_radius: 0.3 cost_map_server/inflation_exponential_rate: 0.6 cost_map_server/big_robot1: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"/aruco/big_robot"</span></span></span><span class="hljs-meta"> cost_map_server/big_robot2: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"/aruco/enemy_robot1"</span></span></span><span class="hljs-meta"> cost_map_server/small_robot1: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"null"</span></span></span><span class="hljs-meta"> cost_map_server/small_robot2: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"/aruco/enemy_robot2"</span></span></span><span class="hljs-meta"> cost_map_server/collision: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"collision"</span></span></span><span class="hljs-meta"> cost_map_server/image_resource_name: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"$(find cost_map_server)/param/image_resource.yaml"</span></span></span><span class="hljs-meta"> cost_map_server/min_diff_points: 0.01 ########################### ### path_planner params ### ########################### global_planner/path_layer: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"inflation_layer"</span></span></span><span class="hljs-meta"> global_planner/path_force_layer: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"obstacle_inflation_layer"</span></span></span><span class="hljs-meta"> global_planner/frame_id: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"map"</span></span></span><span class="hljs-meta"> global_planner/current_position: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"real_corr"</span></span></span><span class="hljs-meta"> global_planner/path_filter_epsilon: 0</span></span></code> </pre> <br>  Il indique √©galement: <br><br><ol><li>  l'un des algorithmes que vous pouvez choisir pour cr√©er un itin√©raire, </li><li>  noms des couches sur lesquelles nous allons construire l'itin√©raire lui-m√™me, </li><li>  un sujet sur notre position, o√π des donn√©es filtr√©es sont √©mises (dans notre cas, il s'agit d'une combinaison de donn√©es de localisation de la cam√©ra et de l'odom√©trie). </li></ol><br>  L'algorithme de recherche de chemin lui-m√™me - Theta Star - est mis en √©vidence dans un fichier s√©par√© (src / global_planner.cpp) pour la commodit√© d'ajouter de nouveaux algorithmes: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cost_so_far[<span class="hljs-number"><span class="hljs-number">300</span></span>][<span class="hljs-number"><span class="hljs-number">200</span></span>]; PriorityPoint neighbors[<span class="hljs-number"><span class="hljs-number">8</span></span>]; PriorityPoint current; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> come_from[<span class="hljs-number"><span class="hljs-number">300</span></span>][<span class="hljs-number"><span class="hljs-number">200</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>]; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makePath_ThetaStar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;cost_map::Index&gt; &amp;path, PriorityPoint start, PriorityPoint goal, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> layer, cost_map::CostMap &amp;cost_map, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> grid_cost, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> only_cost)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::priority_queue&lt;PriorityPoint, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;PriorityPoint&gt;, myCompare&gt; openSet; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> max_x = cost_map.getSize()[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> max_y = cost_map.getSize()[<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::fill_n(*cost_so_far, max_x * max_y, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::numeric_limits&lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt;::max()); cost_so_far[start.x][start.y] = <span class="hljs-number"><span class="hljs-number">0</span></span>; come_from[start.x][start.y][<span class="hljs-number"><span class="hljs-number">0</span></span>] = start.x; come_from[start.x][start.y][<span class="hljs-number"><span class="hljs-number">1</span></span>] = start.y; openSet.push(start); grid_cost=<span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!openSet.empty()) { current = openSet.top(); openSet.pop(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current == goal) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } current.GetNeighbors(neighbors); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> current_cost = cost_so_far[current.x][current.y]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> parent_carent[<span class="hljs-number"><span class="hljs-number">2</span></span>] ={come_from[current.x][current.y][<span class="hljs-number"><span class="hljs-number">0</span></span>], come_from[current.x][current.y][<span class="hljs-number"><span class="hljs-number">1</span></span>]}; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">8</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!neighbors[i].OnMap(max_x, max_y)) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> onLine = lineOfSight(parent_carent[<span class="hljs-number"><span class="hljs-number">0</span></span>], parent_carent[<span class="hljs-number"><span class="hljs-number">1</span></span>], neighbors[i].x, neighbors[i].y, cost_map, layer, grid_cost + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (onLine) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> new_cost = cost_so_far[parent_carent[<span class="hljs-number"><span class="hljs-number">0</span></span>]][parent_carent[<span class="hljs-number"><span class="hljs-number">1</span></span>]] + HeuristicEvclid(parent_carent, neighbors[i], grid_cost*<span class="hljs-number"><span class="hljs-number">10</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (new_cost &lt; cost_so_far[neighbors[i].x][neighbors[i].y]) { cost_so_far[neighbors[i].x][neighbors[i].y] = new_cost; neighbors[i].priority = HeuristicEvclid(neighbors[i], goal, grid_cost*<span class="hljs-number"><span class="hljs-number">10</span></span>) + new_cost; openSet.push(neighbors[i]); come_from[neighbors[i].x][neighbors[i].y][<span class="hljs-number"><span class="hljs-number">0</span></span>] = parent_carent[<span class="hljs-number"><span class="hljs-number">0</span></span>]; come_from[neighbors[i].x][neighbors[i].y][<span class="hljs-number"><span class="hljs-number">1</span></span>] = parent_carent[<span class="hljs-number"><span class="hljs-number">1</span></span>]; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> neighbor_price = cost_map.at(layer, cost_map::Index({neighbors[i].x, neighbors[i].y})) + neighbors[i].priority; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> new_cost = current_cost + neighbor_price; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (new_cost &lt; cost_so_far[neighbors[i].x][neighbors[i].y]) { cost_so_far[neighbors[i].x][neighbors[i].y] = new_cost; neighbors[i].priority =HeuristicEvclid(neighbors[i], goal, grid_cost*<span class="hljs-number"><span class="hljs-number">10</span></span>) + new_cost; openSet.push(neighbors[i]); come_from[neighbors[i].x][neighbors[i].y][<span class="hljs-number"><span class="hljs-number">0</span></span>] = current.x; come_from[neighbors[i].x][neighbors[i].y][<span class="hljs-number"><span class="hljs-number">1</span></span>] = current.y; } } } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (only_cost) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cost_so_far[current.x][current.y]; } path.clear(); PriorityPoint temp_point; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (current != start) { path.push_back({current.x, current.y}); temp_point.x = come_from[current.x][current.y][<span class="hljs-number"><span class="hljs-number">0</span></span>]; temp_point.y = come_from[current.x][current.y][<span class="hljs-number"><span class="hljs-number">1</span></span>]; current = temp_point; } path.push_back({current.x, current.y}); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  Un algorithme pour supprimer des points suppl√©mentaires sur le chemin RamerDouglasPeucker est √©galement allou√© √† un fichier distinct. <br>  Il supprime des points du chemin s'il est au-del√† d'une distance donn√©e de la ligne qui relie deux points voisins. <br><br><img src="https://habrastorage.org/webt/en/_9/dw/en_9dw6khdarxbyf7gvrhpqg7b4.jpeg"><br><br><h4>  Planificateur local </h4><br>  Il travaille pour nous sur la base d'une descente de gradient dans un champ potentiel.  En entr√©e, le chemin du planificateur global.  Mais ce n'est pas tout ce dont il est capable.  Dans local_planner, il existe des services internes pour choisir le mode de construction du chemin.  Il existe deux modes de fonctionnement au total: le mode de d√©placement des points le long du gradient, en utilisant plusieurs passes sur la carte, ainsi que le mode de d√©calage, dans lequel nous calculons imm√©diatement l'incr√©ment en deux coordonn√©es et d√©pla√ßons le point au bord de la zone de s√©curit√©.  Si le point tombe dans plusieurs de ces zones, alors nous nous d√©pla√ßons vers les lieux de leur intersection, car l√†, il est le plus s√ªr. <br><br>  Le mode de fonctionnement est le suivant: s'il n'y a pas d'obstacle sur le chemin depuis l'it√©ration pr√©c√©dente, alors nous cassons le chemin tous les 2 cm, puis le d√©calons le long du gradient, sinon nous utilisons le deuxi√®me mode de fonctionnement du planificateur local. <br><br>  La deuxi√®me option est assez l√©g√®re et, comme le planificateur global, ne charge pas beaucoup le processeur.  Nous avons utilis√© plusieurs versions de cet algorithme et diverses manipulations avec la carte.  Par exemple, nous avons essay√© d'√©crire un graphique dans lequel les sommets se trouvent tous les 10 cm et sont d√©cal√©s d'un maximum de 4 cm, apr√®s quoi l'algorithme de Dijkstra a √©t√© utilis√© sur le graphique obtenu pour trouver la plus petite distance.  Dans ce cas, le point d'extr√©mit√© utilise le point de d√©calage le plus proche.  Mais un tel algorithme √©tait plus adapt√© au planificateur global et nous avons d√©cid√© d'abandonner cette impl√©mentation. <br><br>  Nous avons √©galement essay√© d'utiliser la construction de chemin √† partir de z√©ro en utilisant la m√©thode de descente en gradient.  Cette m√©thode a √©t√© la premi√®re que nous avons d√©cid√© d'√©crire.  Il s'est av√©r√© ne pas √™tre efficace en m√©moire (il occupait plus de 400 Mo de RAM pure, car il utilisait une carte de co√ªt √† chaque passage) et lent.  Le contr√¥le de fr√©quence a √©t√© d√©sactiv√© en raison d'une mauvaise optimisation et la vitesse √©tait inf√©rieure √† 30 fois par seconde, ce qui ne nous convenait pas. <br><br>  En cons√©quence, nous avons d√©cid√© d'utiliser la descente de gradient dans un champ potentiel bas√© sur la trajectoire du planificateur global.  Il s'est av√©r√© √™tre un algorithme l√©ger et relativement simple, qui nous convient parfaitement en termes de qualit√© de chemin, de temps de travail et de quantit√© de RAM utilis√©e dans la r√©gion de 100-150 Mo, ce qui est plusieurs fois moins que dans les premi√®res it√©rations de d√©veloppement. <br><br><img src="https://habrastorage.org/webt/sg/oq/mo/sgoqmogivjs8elhylt74oqjqrdw.png"><br>  <i>Un exemple de d√©calage de trajectoire de rabotage local</i> <br><br>  Contrairement √† global_planner, les param√®tres de local_planner sont extr√™mement petits, ce qui est d√ª √† sa simplicit√©, car toutes les t√¢ches les plus importantes incombent √† global_planner: <br><br><pre> <code class="cpp hljs">grid_map_server/big_robot1 : <span class="hljs-number"><span class="hljs-number">0.4</span></span> grid_map_server/big_robot2 : <span class="hljs-number"><span class="hljs-number">0.4</span></span> grid_map_server/small_robot1 : <span class="hljs-number"><span class="hljs-number">0.4</span></span> grid_map_server/small_robot2 : <span class="hljs-number"><span class="hljs-number">0.4</span></span> local_planner/radius : <span class="hljs-number"><span class="hljs-number">0.15</span></span> global_planner/frame_id : <span class="hljs-string"><span class="hljs-string">"map"</span></span></code> </pre> <br>  Dans ce cas, nous configurons: <br><br><ul><li>  Rayons de zones de s√©curit√© pour chacun des robots. </li><li>  D√©port maximal d√©cal√© par la raboteuse locale. </li><li>  Le nom de la couche de carte avec laquelle nous travaillons. </li></ul><br>  Dans une classe s√©par√©e, toutes les fonctions les plus importantes ont √©t√© attribu√©es.  Dans ce cas, il s'agit d'une rupture r√©cursive du chemin, de la cr√©ation d'un planeur et de constructeurs et destructeurs virtuels. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Planner</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Planner(<span class="hljs-keyword"><span class="hljs-keyword">double</span></span> inflation_radius_, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> frame_id_) { inflation_radius = inflation_radius_; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">300</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; <span class="hljs-number"><span class="hljs-number">200</span></span>; j++) our_map[i][j] = <span class="hljs-number"><span class="hljs-number">3000.0</span></span>; } OurPath-&gt;poses.resize(<span class="hljs-number"><span class="hljs-number">50</span></span>); geometry_msgs::Pose pose; pose.position.x = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; pose.position.y = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">50</span></span>; i++) { OurPath-&gt;poses[i].pose = pose; } frame_id = frame_id_; } <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~Planner() { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdatePath</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; ros::Publisher move_pub; ros::Publisher BigEnemyPub; ros::Publisher LittleEnemyPub; ros::Publisher local_path_publisher; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-comment"><span class="hljs-comment">// virtual double Calculate_Path_Len(); nav_msgs::Path* recursive_path(nav_msgs::Path *path, std::pair&lt;double, double&gt; start, std::pair&lt;double, double&gt; end, double epsilon, int &amp;index) { if (CalcDistance(start, end) &lt; (epsilon) || path-&gt;poses.size() &gt; 200) return path; double start_x = (start.first + end.first) / 2.0; double start_y = (start.second + end.second) / 2.0; index = find_out(path, start); geometry_msgs::PoseStamped pose; pose.pose.position.x = start_x; pose.pose.position.y = start_y; path-&gt;poses.insert(path-&gt;poses.begin() + index, pose); recursive_path(path, start, std::pair&lt;double, double&gt;{start_x, start_y}, epsilon, index); recursive_path(path, std::pair&lt;double, double&gt;{start_x, start_y}, end, epsilon, index); } int find_out(nav_msgs::Path *path, pair_double point) { int index = 0; for (int i = 0; i &lt; path-&gt;poses.size(); i++) if (path-&gt;poses[i].pose.position.x == point.first &amp;&amp; path-&gt;poses[i].pose.position.y == point.second) return ++i; return index; } void add_in_path(nav_msgs::Path* Path, geometry_msgs::PoseStamped pose, int&amp; Index) { Path-&gt;poses[Index % max_size] = pose; Index++; } double inflation_radius; double our_map[300][200]; int max_size = 49; std::string frame_id; nav_msgs::Path *path = new nav_msgs::Path; nav_msgs::Path *OurPath = new nav_msgs::Path; };</span></span></code> </pre> <br>  La classe LocalPlanning en a √©t√© h√©rit√©e, o√π se trouve tout le noyau du planeur, c'est-√†-dire d√©placer les points vers le bord de la zone de s√©curit√© et d√©cider quoi faire du chemin en particulier. <br><br>  Toutes les autres fonctions sont mises en √©vidence dans un fichier s√©par√© fichi.hpp et la descente de gradient dans potential_field.hpp.  Ci-dessous est un instantan√© de ce fichier, qui montre les fonctions pour cr√©er un champ potentiel sur la carte cost_map: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CalcAttractivePotential</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(grid_map::Index index, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> goalx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> goaly)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(index[<span class="hljs-number"><span class="hljs-number">0</span></span>] - goalx, <span class="hljs-number"><span class="hljs-number">2</span></span>) + <span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(index[<span class="hljs-number"><span class="hljs-number">1</span></span>] - goaly, <span class="hljs-number"><span class="hljs-number">2</span></span>)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CalcPotential</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> startx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> starty, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> goalx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> goaly, cost_map::CostMap &amp;cost_map, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (&amp;our_map)[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">300</span></span></span></span><span class="hljs-function"><span class="hljs-params">][</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">200</span></span></span></span><span class="hljs-function"><span class="hljs-params">])</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Use some magic for normalisation of Field double max_distance = (CalcAttractivePotential(grid_map::Index(startx, starty), goalx, goaly) + 15); if (max_distance == 0.0) { max_distance = 0.01; } for (cost_map::CircleIterator iterator(cost_map, grid_map::Position(startx / 100.0, starty / 100.0), max_distance / 100.); !iterator.isPastEnd(); ++iterator) { try { grid_map::Index index(*iterator); double uf; uf = cost_map.at("obstacle_inflation_layer", *iterator); // if we on free podouble - field is more less then if it not free podouble if ( uf &gt;= 10) { uf = 3000.0; // CP - is const variable } else uf += CalcAttractivePotential(index, goalx, goaly)/max_distance * 256; our_map[299-index(0)][199-index(1)] = uf; } catch(std::exception&amp; e) { ROS_INFO("Exception! %s", e.what() ); } } }</span></span></code> </pre> <br><h4>  R√©gulateur de trajectoire </h4><br>  Le dernier mais non le moindre est le r√©gulateur de trajectoire.  Il est responsable de la conversion du chemin du planificateur local en chemin et donne la vitesse de l'√©tape en cours. <br><br>  Sa premi√®re version, que nous avons utilis√©e lors de la finale de l'Eurobot 2018, est un m√©lange du contr√¥leur PID d'acc√©l√©ration et de freinage, o√π le vecteur est normalis√© au point suivant sur la trajectoire, par rapport √† la distance jusqu'au point final. <br><br>  Le contr√¥leur PID, en bref, est la somme des trois √©tats du syst√®me qui aident √† corriger le syst√®me et les erreurs al√©atoires qui se produisent parfois. <br><br>  Ces fonctions ont √©t√© choisies empiriquement et d√©pendent de la distance jusqu'au point final du chemin (elle peut √™tre quadratique, cubique, inverse, mais ensuite nous nous sommes install√©s sur le quadratique).  Cela a fonctionn√©, mais la seule chose qui ne nous convenait pas √©tait que le robot ne pouvait pas freiner √† temps √† des vitesses sup√©rieures √† 0,7 m√®tre par seconde.  Par cons√©quent, le moment venu, nous avons d√©cid√© de reconstruire l'ensemble de l'algorithme. <br><br>  La premi√®re it√©ration sur le chemin de la nouvelle trajectoire a √©t√© le remplacement du vecteur vers lequel nous allions.  Maintenant, c'√©tait la somme des vecteurs pour les trois suivants avec des coefficients diff√©rents.  La deuxi√®me it√©ration √©crivait Minimum Jerk.  En bref, il s'agit d'une construction d'un polyn√¥me du 5e degr√©, o√π les coordonn√©es x et y d√©pendent de l'heure d'arriv√©e √† chaque point. <br><br><img src="https://habrastorage.org/webt/ho/mw/hd/homwhdagbnkgdlrigettcc6yook.png"><br>  <i>La figure montre un graphique de l'une des coordonn√©es en fonction du temps, ainsi que la vitesse le long de cette coordonn√©e</i> <br><br>  Ce type de contr√¥leur de trajectoire nous convenait mieux, car il n√©cessitait moins de manipulation avec la s√©lection de diff√©rents coefficients, car tous les coefficients sont les valeurs du polyn√¥me, qui ont √©t√© calcul√©es en fonction du temps pour y arriver, de la vitesse et de l'acc√©l√©ration actuelles, de la vitesse de sortie et de l'acc√©l√©ration. <br><br>  Le r√©sultat de la r√©√©criture de la trajectoire a √©t√© que nous avons r√©ussi √† doubler la vitesse moyenne du robot. <br><br>  Comme dans les deux cas pr√©c√©dents, toutes les fonctions principales sont mises en √©vidence dans un fichier s√©par√© pour une interaction facile.  Cette fois, la classe PlannerTrajectory est responsable de la construction d'une trajectoire bas√©e sur MinimumJerk <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> velocity; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> acceleration; State(<span class="hljs-keyword"><span class="hljs-keyword">double</span></span> v_, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> a_) : velocity(v_), acceleration(a_) {} State() { velocity = <span class="hljs-number"><span class="hljs-number">0</span></span>; acceleration = <span class="hljs-number"><span class="hljs-number">0</span></span>; } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PlannerTrajectory</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: nav_msgs::Path global_path; cost_map::CostMap *costmap_ptr; geometry_msgs::PoseStamped Goal_pred; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt; trajectory_x; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt; trajectory_y; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> average_velocity = <span class="hljs-number"><span class="hljs-number">80</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Defualt or get from param // double max_velocity = 100; double coef_x[6]; double coef_y[6]; int frequency = 30; // Defualt or get from param // int index; public: PlannerTrajectory(cost_map::CostMap *costmap_, const int &amp;frequency_, const double &amp;max_velocity_, const double &amp;average_velocity_) { average_velocity = average_velocity;; max_velocity = max_velocity_; costmap_ptr = costmap_; frequency = frequency_; Goal_pred.pose.position.x = 0.0; Goal_pred.pose.position.y = 0.0; }</span></span></code> </pre> <br>  <i>La photo montre toutes les variables d√©clar√©es que nous utilisons.</i> <br><br>  Tout le reste est mis en √©vidence dans un autre fichier (include / trajectory_regulator.h): recevoir des points des sujets, d√©cider d'aller au point suivant (s'il est dans un obstacle, alors nous n'y allons pas) et bien plus encore. <br><br><h3>  Migration vers ROS Melodic </h3><br>  Jusqu'√† l'ann√©e derni√®re, nous utilisions la version lte de ROS - ROS Kinetic.  Il nous convenait g√©n√©ralement, mais son soutien prend fin l'ann√©e prochaine, et bon nombre des packages dont nous avons besoin ont commenc√© √† sortir exclusivement pour ROS Melodic.  Et puis il s'est av√©r√© que le costmap_server que nous avons utilis√© n'est pas sous Melodic. <br><br>  Un probl√®me est survenu lors du traitement des donn√©es des cartes. <br><br>  Nous avons choisi la carte Grid, car la pile est similaire, mais le d√©but de la carte est √† un endroit diff√©rent, et les valeurs de la carte elle-m√™me varient de 0 √† 1. Cela est devenu un gros probl√®me dans toute la pile de navigation.  Si auparavant le planificateur global √©tait lanc√© 50 fois par seconde (il y avait des restrictions de fr√©quence, et donc le processeur n'√©tait pas trop utilis√©, m√™me dans la moiti√© d'un thread), maintenant il ouvrait la voie toutes les deux secondes et le consid√©rait comme mauvais: il chargeait compl√®tement un c≈ìur.  En 2 secondes, le robot a pu traverser toute la carte.  Cela ne nous convenait pas et les tentatives de parall√©lisation de ce processus se sont sold√©es par un √©chec, car il n'y avait alors plus de performances pour les autres projets (en tenant compte des co√ªts de la parall√©lisation). <br><br>  Nous avons d√©cid√© de changer √† nouveau la pile, d'abandonner la carte de la grille au profit de la grille d'occupation.  Un nouveau probl√®me est apparu - l'incapacit√© de stocker plusieurs versions de cartes en m√™me temps (par exemple, une carte compl√®te avec tous les obstacles et une carte statique avec uniquement des obstacles dynamiques).  Je devrais changer la moiti√© du code, ce qui n'√©tait pas particuli√®rement fiable.  Par cons√©quent, nous avons d√©cid√© de rechercher des solutions alternatives √† ce probl√®me. <br><br><h4>  Serveur de cartographie des co√ªts </h4><br>  Apr√®s une longue recherche, nous avons trouv√© des cartes de fourches costmap_serverr: <a href="" rel="nofollow">https://github.com/lelongg/cost_map.git</a> - extr√™mement utiles pour notre syst√®me de fourches. <br><br><img src="https://habrastorage.org/webt/27/rb/oh/27rbohj3kefxprwtjqrg4mwtqjc.png"><br><br>  Et maintenant, au lieu de ne desservir que la carte de la grille, pour la livraison, nous parvenons √† calculer l'emplacement probable de l'ennemi en fonction de la pr√©diction du filtre de Kalman. <br><br><img src="https://habrastorage.org/webt/ni/pm/nz/nipmnzvhcrqdje1cu8glf9quude.png"><br><br>  Un des √©l√©ments les plus importants pour un serveur de carte est un fichier de carte, qui est utilis√© pour la cr√©ation initiale de toutes les couches, qui sont ensuite uniquement mises √† jour.  C'est une image binaire png, o√π le noir est un obstacle et le blanc est une zone libre. <br><br><img src="https://habrastorage.org/webt/2b/l5/rg/2bl5rgpuecb7he51heslqpvcazm.png"><br><br>  Il existe √©galement un fichier de param√®tres pour la configuration cost_map_server.  Il contient des sujets avec des points ennemis, une zone de gonflage et la taille du carr√©, qui peuvent √©galement √™tre utilis√©s pour mettre la zone dangereuse de l'ennemi sur la carte. <br><br><pre> <code class="cpp hljs">########################### # cost_map_server params ## ########################### cost_map_server/big_robot_size: <span class="hljs-number"><span class="hljs-number">0.4</span></span> cost_map_server/little_robot_size: <span class="hljs-number"><span class="hljs-number">0.4</span></span> cost_map_server/cube_size: <span class="hljs-number"><span class="hljs-number">0.11</span></span> cost_map_server/inscribed_radius: <span class="hljs-number"><span class="hljs-number">0.25</span></span> cost_map_server/inflation_radius: <span class="hljs-number"><span class="hljs-number">0.25</span></span> cost_map_server/inflation_exponential_rate: <span class="hljs-number"><span class="hljs-number">0.6</span></span> cost_map_server/big_robot1: <span class="hljs-string"><span class="hljs-string">"/aruco/robot1"</span></span> cost_map_server/big_robot2: <span class="hljs-string"><span class="hljs-string">"/aruco/robot2"</span></span> cost_map_server/small_robot1: <span class="hljs-string"><span class="hljs-string">"/aruco/robot3"</span></span> cost_map_server/small_robot2: <span class="hljs-string"><span class="hljs-string">"/aruco/robot4"</span></span> cost_map_server/collision: <span class="hljs-string"><span class="hljs-string">"collision"</span></span> cost_map_server/image_resource_name: <span class="hljs-string"><span class="hljs-string">"$(find cost_map_server)/param/image_resource.yaml"</span></span> cost_map_server/min_diff_points: <span class="hljs-number"><span class="hljs-number">0.01</span></span></code> </pre> <br>  Toutes les couches sont publi√©es uniquement si quelqu'un s'y abonne: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PublishChanges</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ nav_msgs::OccupancyGrid msg; cost_map_msgs::CostMap cost_map_msg; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obstacle_inflation_publisher.getNumSubscribers() &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { cost_map::toOccupancyGrid(costmap, <span class="hljs-string"><span class="hljs-string">"obstacle_layer"</span></span>, msg); obstacle_inflation_publisher.publish(msg); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (inflation_publisher.getNumSubscribers() &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { cost_map::toOccupancyGrid(costmap, <span class="hljs-string"><span class="hljs-string">"inflation_layer"</span></span>, msg); inflation_publisher.publish(msg); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cost_map_publisher.getNumSubscribers() &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { cost_map::toMessage(costmap, cost_map_msg); cost_map_publisher.publish(cost_map_msg); } }</code> </pre> <br><h3>  Ex√©cutez sur votre ordinateur </h3><br>  Pour d√©marrer la pile enti√®re, vous devez: <br><br><ul><li>  Mettez ROS </li><li>  roslaunch cost_map_server cost_map_server_alone.launch - pour d√©marrer la carte </li><li>  roslaunch global_planner global_planner.launch - lancer un planificateur global avec des param√®tres </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> rosparam charger $ (trouver local_planner) /param/param.yaml </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> rosrun local_planner local_planning </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> rosrun trajectory_regulator trajectory_regulator </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> rosrun global_planner mover </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> rosrun rviz </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ajouter inflation_layer </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Maintenant, en envoyant un message au sujet / gp / objectif, nous envoyons le robot au point souhait√© </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Ä la suite du lancement de tous les √©l√©ments, vous aurez une simulation pr√™te √† lancer notre pile sur votre ordinateur. </font></font><a href="https://github.com/lelongg/cost_map" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fourche n√©cessaire</font></font></a> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/iRY5WHgAFns" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Au d√©part, nous avions besoin d'une navigation qui aiderait notre robot √† rouler magnifiquement, rapidement et avec pr√©cision sur des roues omnidirectionnelles. </font><font style="vertical-align: inherit;">Pendant la pr√©paration de la comp√©tition, pas un chat n'a √©t√© bless√© et le robot est beau. </font><font style="vertical-align: inherit;">En cons√©quence, nous avons une pile de navigation l√©g√®re pour les concours similaires √† eurobot, dont nous sommes tr√®s satisfaits. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour nous, cette pile est meilleure que la pile standard, mais ... </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Notre t√©l√©gramme: t.me/SetUpSber </font></font><br> <a href="https://github.com/ristle/EUrobotNavigation" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le r√©f√©rentiel de toute notre cr√©ativit√©</font></font></a> <br><br><img src="https://habrastorage.org/webt/98/gl/4m/98gl4mdibk20qgavmhzkbdppu4w.jpeg"></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr479636/">https://habr.com/ru/post/fr479636/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr479620/index.html">Logique inverse</a></li>
<li><a href="../fr479622/index.html">Fonctionnement du prototype de transactions anonymes sur la blockchain Waves</a></li>
<li><a href="../fr479624/index.html">Le gendar professionnel de Postgres, Oleg Bartunov, explique √† Faride Roslovets √† propos de PostgreSQL et des affaires en Russie</a></li>
<li><a href="../fr479626/index.html">R√©sonateur avec une torsion que les physiciens ne connaissent pas</a></li>
<li><a href="../fr479630/index.html">Battez-vous pour attirer l'attention</a></li>
<li><a href="../fr479642/index.html">Comment des d√©cisions stupides lors de la conception d'un avion de la Seconde Guerre mondiale ont conduit √† la cr√©ation du Macintosh</a></li>
<li><a href="../fr479644/index.html">Mots simples sur le programmatique</a></li>
<li><a href="../fr479650/index.html">Top 12 des infographies dynamiques dynamiques informatiques les plus int√©ressantes</a></li>
<li><a href="../fr479654/index.html">G√©n√©rateur de vue Django</a></li>
<li><a href="../fr479656/index.html">PostgreSQL Antipatterns: statistiques autour de la t√™te</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>