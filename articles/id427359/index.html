<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ’ ğŸ¤›ğŸ¼ ğŸ”‘ Bagaimana ECS, Sistem Pekerjaan C #, dan Arsitektur Ubah SRP â˜¸ï¸ ğŸŒ ğŸ‘—</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kami telah bekerja dengan Unity untuk waktu yang lama dan mau tidak mau mengundang orang-orang mereka ke Pixonic DevGAMM Talks, yang diadakan pada bul...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana ECS, Sistem Pekerjaan C #, dan Arsitektur Ubah SRP</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pixonic/blog/427359/">  Kami telah bekerja dengan Unity untuk waktu yang lama dan mau tidak mau mengundang orang-orang mereka ke Pixonic DevGAMM Talks, yang diadakan pada bulan September.  Insinyur Lapangan Valentin Simonov mengatakan bagaimana merencanakan arsitektur game dengan mempertimbangkan keunggulan teknologi baru.  Unity telah mengusahakannya selama beberapa tahun untuk mencapai tingkat kinerja yang sebelumnya tidak dapat dicapai.  Anda dapat mendengarkan presentasi di YouTube, dan membaca transkrip dengan slide tepat di bawah potongan. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/w4DkVpXLu2c" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe> <a name="habracut"></a><br>  Bagaimana jika saya mengatakan bahwa Anda dapat meningkatkan produktivitas game Anda hingga 10 kali lipat?  Sebenarnya, ini tidak sepenuhnya benar, tetapi ada beberapa kebenaran dalam setiap lelucon.  Saya ingin berbicara tentang apa yang sedang kami kerjakan sekarang, apa yang akan menjadi masa depan Persatuan dan apa yang dapat Anda gunakan sekarang. <br><br>  Unity membuat game yang sama sekali berbeda.  Berikut adalah beberapa contoh yang saya mainkan sendiri.  Mereka menggunakan fitur yang berbeda dan mereka membutuhkan kinerja yang berbeda, pendekatan pengembangan yang berbeda. <br><br><img src="https://habrastorage.org/webt/ln/vm/4k/lnvm4ktwudkqejfeve_v5vkk50m.png"><br><br>  Dan kami sedang mengerjakan proyek yang kami sebut Kinerja secara Default.  Ini adalah beberapa fitur khusus yang, jika digunakan dengan benar, akan mencapai peningkatan kinerja yang signifikan.  Dalam beberapa tugas, kami mengukur x10 dan bahkan x11.  Terutama dalam masalah mensimulasikan sejumlah besar objek yang saling berinteraksi. <br><br>  Tetapi ketika kita berbicara tentang Perfomance secara Default, kami berarti bahwa Anda harus mengubah pendekatan untuk pengembangan, sangat mengubah pendekatan untuk arsitektur permainan.  Dan, pada kenyataannya, tidak semua orang membutuhkan ini. <br><br>  Sebuah pertanyaan populer: "Apa yang Anda lakukan di ECS Anda?  Anda menghapus semua GameObject, menghapus semua Transform, hierarki dan komponen? "  Tidak, kita semua meninggalkannya.  Anda dapat bekerja dengan Unity persis sama seperti sekarang, tetapi jika Anda ingin lebih banyak kinerja, Anda perlu tahu tentang teknologi yang ingin saya bicarakan secara singkat. <br><br>  Dan saya ingin menyebutkan teknologi lain yang disebut Scriptable Render Pipelines (SRP) - memungkinkan Anda untuk secara lebih efisien menulis saluran render untuk gim Anda.  Anda mungkin melihat demo yang kami perlihatkan di salah satu Unite.  Di sini, di PC secara real time, sejumlah besar unit disimulasikan, sekitar 60 ribu (mencapai 100 ribu dan mulai sedikit melambat): <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/0969LalB7vw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Dan fitur-fitur baru yang ingin saya bicarakan adalah: Entity Component System (ECS), Sistem Kerja C #, superkompiler Burst baru kami, dan Scriptable Render Pipelines (SRP). <br><br><img src="https://habrastorage.org/webt/vl/eh/vq/vlehvq_jnr-zg_vrr6wpluip2ui.png"><br><br>  Saya ulangi: terserah Anda untuk memilih apakah Anda ingin melanjutkan bersama kami, mempelajari teknologi baru, atau Anda OK untuk mengembangkan game yang menghasilkan uang dengan baik dan hanya dibuat. <br><br>  Untuk memahami apa yang kami coba selesaikan, penting untuk memahami keadaan besi pada tahun 2018. <br><br><img src="https://habrastorage.org/webt/b0/rp/fl/b0rpflxbgvksdmbp-s9mw2pvgwq.png"><br><br>  Perhatikan bagaimana kinerja dan jumlah core CPU meningkat.  Dari satu titik, Kinerja Single-thread bahkan turun.  Artinya, kita sekarang memiliki banyak inti, tetapi produktivitas mereka tidak tumbuh begitu cepat.  Karena itu, kami ingin menggunakan kekuatan semua inti. <br><br><img src="https://habrastorage.org/webt/p7/a2/ri/p7a2rir7c_2icejklwngmijjxso.png"><br><br>  Ponsel saya memiliki 8 core: 4 kuat dan 4 lemah.  Dan telepon modern dapat bekerja secepat komputer modern (tetapi tidak terlalu lama karena terlalu panas).  Anda juga perlu memahami bahwa peningkatan kinerja tidak hanya menggunakan semua inti, tetapi juga mengoptimalkan kinerja inti tunggal. <br><br>  Dan gambar terakhir, yang selalu kami berikan sebagai contoh bagaimana kinerja proses naik dan kecepatan akses memori tidak meningkat banyak: <br><br><img src="https://habrastorage.org/webt/gm/sw/dw/gmswdwp-tar5zfybjn02xq00e_g.png"><br><br>  Dapat dilihat bahwa sekarang akses ke memori sangat lambat.  Pabrik prosesor melakukan banyak hal untuk meratakan perbedaan ini - tambahkan cache, CPU terlibat dalam perhitungan spekulatif, mencoba memprediksi kode mana yang akan dieksekusi selanjutnya.  Dan jika Anda tidak memikirkannya saat membuat game (atau saat kami membuat mesin untuk Anda), maka kami tidak dapat memanfaatkan sepenuhnya prosesor modern. <br><br>  Banyak dari Anda cenderung menghabiskan waktu berjam-jam untuk melihat gambar yang sama di Unity: <br><br><img src="https://habrastorage.org/webt/u3/li/ab/u3liabzolenmypdfmbax3udkwgy.png"><br><br>  Di sini Anda dapat melihat bahwa ada multithreading, tetapi inti dan utas yang tersisa sebagian besar tidak sibuk.  Sesuatu sedang dilakukan, tetapi saya ingin menempati mereka sepenuhnya. <br><br>  Sekarang kita punya rendering, ini kotak hitam.  Anda punya pilihan: Maju atau Ditangguhkan, ditambah berbagai pengaturan untuk material, shader, Command Buffers, dan sebagainya.  Anda dapat membuat gambar yang indah, tetapi banyak algoritma yang sangat sulit diimplementasikan. <br><br><img src="https://habrastorage.org/webt/vf/oy/uw/vfoyuw4vl7ga1z3aht8uzmd1iwi.png"><br><br>  Dan kita semua tahu tentang arsitektur di Unity: komponen, GameObjects, hierarki Transforms, semua kode, semua data di MonoBehaviour dan setiap komponen memproses datanya. <br><br><img src="https://habrastorage.org/webt/0u/zm/bn/0uzmbnnpvak4sbanz01fruudnpu.png"><br><br>  Tetapi ada masalah dengan keadaan saat ini.  Cepat atau lambat Anda menemukan ini dan memahami bagaimana Anda perlu dan tidak perlu melakukannya.  Hirarki objek itu sendiri memiliki overhead tertentu, dan beberapa entitas tidak harus menjadi GameObjects sama sekali.  Dan jika Anda memiliki sejumlah besar komponen dan pembaruan dari mereka, maka semuanya menjadi jauh lebih lambat.  Saya pernah menulis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel ini</a> , yang masih relevan jika Anda ingin tahu bagaimana tidak melakukannya. <br><br><img src="https://habrastorage.org/webt/mo/wp/ph/mowpphiwnugvj62nvi0cng6d9wc.png"><br><br>  Dan yang paling penting dalam konteks prosesor adalah bahwa semua komponen, semua data tersebar di memori, yang memecah penggunaan cache prosesor. <br><br>  Sekarang saya ingin cepat melalui fitur baru. <br><br><img src="https://habrastorage.org/webt/gz/7m/pe/gz7mpecj1dov6grvyikove3neyg.png"><br><br>  Saya tidak akan terlalu fokus pada apa itu ECS dan bagaimana cara kerjanya.  Intinya adalah bahwa kita memiliki Entitas, yang hanya merupakan ID entitas tertentu dalam game - mereka menyimpan data dalam bentuk komponen, mis.  hanya data, tidak ada kode.  Dan sistem memproses Entity dengan komponen tertentu dan entah bagaimana mengubah data ini. <br><br>  Mengapa kita melakukan ECS kita dan bagaimana hal itu lebih baik daripada pesaing?  Ada beberapa poin.  Pertama, tidak cukup resmi, tetapi kami berpikir bahwa kami akan melakukan mesin sekarang.  Jelas bahwa kita tidak ingin menyingkirkan GameObjects, komponen Unity saat ini, sepenuhnya membuang semuanya dan menginstal ECS.  Tapi kami ingin pindah ke mesin yang lebih baik. <br><br><img src="https://habrastorage.org/webt/ty/3a/c6/ty3ac6irgsqt6d88mn-6v6pbuki.png"><br><br>  Kami mengandalkan kinerja tinggi.  Belum lama ini, Mike Acton bergabung dengan kami (jika Anda berada dalam pengembangan C ++, Anda tahu bahwa dia adalah salah satu penginjil Pemrograman Berorientasi Data).  Dan kami ingin seluruh sistem bekerja secepat mungkin - lebih cepat dari C ++. <br><br>  Kami juga memikirkan bagaimana mengintegrasikan berbagai hal secara berbeda ke dalam ECS.  Beberapa waktu yang lalu, kami mengumumkan bahwa kami membuat jaringan baru dan juga berdasarkan ECS - dimungkinkan untuk membuat game multipemain pada ECS dan membagikan kode antara klien dan server. <br><br>  Bekerja pada alat debugging di Unity.  Yaitu  sementara ECS ada, seolah-olah, terpisah dari GameObjects dan komponen, dan ini sangat merepotkan.  Kami ingin menyederhanakan banyak hal. <br><br>  Sekarang ada DebugView yang terlihat seperti ini: <br><br><img src="https://habrastorage.org/webt/pv/dg/qe/pvdgqexi8tewv1l5gsgrrrxzeg4.png"><br><br>  Di sini Anda dapat melihat Entitas seperti apa yang Anda miliki, sistem apa berapa banyak waktu yang diperlukan untuk memproses, sistem mana yang bekerja dengan komponen mana dan untuk setiap komponen yang dapat Anda lihat di inspektur, data apa yang dimiliki masing-masing Entitas dalam komponen (Saya perhatikan bahwa API sering berubah dan banyak Tutorial mungkin sudah usang). <br><br>  Juga, jika Anda mendengar tentang pengembangan baru Unity for Small Things (ini adalah runtime yang sangat kecil yang memungkinkan Anda membuat game untuk pengirim pesan instan) - semuanya juga dibangun di atas ECS di sana. <br><br>  Baru-baru ini, ledakan perkembangan dan transisi ke ECS adalah teknologi yang sangat populer dan semua orang perlu mengetahuinya. <br><br>  Kami memiliki konferensi untuk pemrogram, sehingga sulit dilakukan tanpa slide kode.  Ada banyak kode di sana, jadi sulit untuk mengeluarkan beberapa jenis yang dapat dipahami untuk membuat sesuatu menjadi jelas. <br><br><img src="https://habrastorage.org/webt/3s/d1/rb/3sd1rbsazp2tciwbfuax8xzmupe.png"><br><br>  Bahkan, saya mengambil satu sistem dari contoh yang bekerja dengan C # Job System (lebih lanjut tentang itu nanti), dan kami melakukan banyak hal untuk mengurangi jumlah kode, menambahkan sintaks shugar. <br><br>  Ada sistem yang bekerja dengan komponen RotationData dan juga membutuhkan transformasi GameObject, yang diwakili oleh TransformAccessArray khusus.  Dan setiap pembaruan dari sistem yang kita buat Pekerjaan, jalankan Pekerjaan ini, pembaruan di suatu tempat, dapat dibagi menjadi beberapa kelompok dan dieksekusi di utas yang berbeda. <br><br>  Bagaimana cara menggunakannya dalam proyek?  Sama seperti implementasi ECS lainnya, Anda perlu memahami bahwa Anda harus berpikir dengan cara yang sama sekali berbeda (tidak seperti GameObjects dan Transforms).  Dan biasakanlah ide ini.  Jelas bahwa Anda harus mulai dari awal proyek, karena saya sangat sering mendapatkan pertanyaan seperti "kami membuat game dan ingin beralih ke ECS - bagaimana?".  Dalam permainan yang sudah selesai, ini sangat sulit dilakukan. <br><br><img src="https://habrastorage.org/webt/kw/ow/r9/kwowr9ar6zht1xoprdmg37v6sms.png"><br><br>  Kita perlu memikirkan interaksi dengan Unity, karena ECS hidup secara terpisah, di dunianya yang kecil.  Kami memberikan beberapa peluang untuk berinteraksi dengan GameObjects dan Transforms, tetapi fisika, rendering, dll., Ini semakin rumit.  Dan sementara Anda perlu memasang dengan fakta bahwa banyak antarmuka yang akrab tidak akan tersedia, tetapi kami juga sedang mengerjakan ini. <br><br>  Dan segera Anda perlu memikirkan fakta bahwa Anda akan menulis sistem dalam Sistem Pekerjaan, yang jauh lebih efisien. <br><br><img src="https://habrastorage.org/webt/c8/bw/po/c8bwpoy0xq2pngb3w9ayxv78gtk.png"><br><br>  Beberapa kata tentang Sistem Kerja.  Kami ingin membuat cara yang sangat sederhana untuk menulis kode multi-utas.  Pada saat yang sama, tulis dalam C #, periksa semuanya untuk Anda, jangan berikan kesempatan untuk membuat kesalahan atau tunjukkan mengapa, di mana dan bagaimana Anda membuatnya.  Kami membatasi fitur bahasa yang dapat Anda gunakan dalam Pekerjaan dan memanggil subset ini C # Kinerja Tinggi C #.  Anda tidak memiliki referensi dalam kode Pekerjaan Anda, tidak ada garis, semua data perlu disalin - Anda tidak dapat menggunakan sejumlah besar fitur bahasa, membuatnya jauh lebih sulit untuk memotret multi-threading di kaki Anda. <br><br>  Kami juga menghadirkan koleksi dan integrasi yang sangat cepat dengan ECS.  Struktur ECS dan Sistem Sistem Pekerjaan ini memungkinkan untuk eksekusi kode yang sangat cepat. <br><br>  Pada saat yang sama, kami tidak hanya memberi Anda kesempatan untuk menggunakan teknologi ini - kami bekerja dengan sistem ini sendiri dan membuat API baru sehingga dapat digunakan di Jobs. <br><br><img src="https://habrastorage.org/webt/x-/e4/x7/x-e4x7xnicynebmtj7cbbye4b90.png"><br><br>  Kami membuat Async Raycasts untuk fisika, dengan mana Anda dapat mengatakan, "Saya ingin 600 rakecast, lakukan kepada saya suatu hari nanti, tolong."  Kami berupaya memastikan bahwa, dengan menggunakan teknologi ini, dimungkinkan untuk memperluas sistem saat ini, misalnya, animasi melalui Playbles API.  Dan kami berpikir untuk membuat sistem baru di Unity yang tidak akan ditutup di C ++, dan yang kodenya akan berada di C # dan tersedia untuk Anda. <br><br><img src="https://habrastorage.org/webt/q_/lk/da/q_lkdawzdu72-jn_kmaapysa3ym.png"><br><br>  Jika Anda mengambil kode Ayub, itu sangat sederhana.  Pekerjaan adalah struktur di mana ada metode Jalankan, di mana kita melakukan pekerjaan dengan menjalankan Pekerjaan ini.  Dengan demikian, Penjadwal internal kita suatu hari nanti akan mengerti di mana lebih baik untuk menjalankannya, akan menyelesaikan semua dependensi.  Di sini kita mendapatkan JobHandle, yang dapat kita gunakan sebagai ketergantungan untuk beberapa Pekerjaan lain. <br><br>  Bagaimana cara menggunakannya dalam proyek?  Baik jika Anda akan menggunakan Pekerjaan sejak awal, tetapi ini tidak perlu di sini.  Jika Anda memiliki beberapa jenis sistem yang kritis Performa, misalnya, simulasi, pathfinding, jaringan atau yang lainnya - Anda dapat mengetahui cara mengoptimalkannya dengan alat ini. <br><br><img src="https://habrastorage.org/webt/_p/ez/de/_pezdeftr_wilpohozdzt-bjzcc.png"><br><br>  Tetapi untuk ini, Anda perlu mengambil beberapa langkah besar, pahami cara menyimpan data dengan benar.  ECS, pada kenyataannya, memungkinkan kita untuk menyimpan data dengan benar, karena kita memisahkan data dari kode dan implementasi ECS kita menyimpan data komponen secara linear dalam memori, dan, berjalan melalui komponen-komponen ini oleh beberapa sistem, Anda menggunakan semua kemampuan prosesor, semuanya disimpan dalam cache dan dll.  Kami berusaha melakukannya dengan sangat cepat. <br><br>  Kemudian Anda memecah pekerjaan ini menjadi tugas paralel, menulis kode Pekerjaan dan menjalankannya.  Dan (mungkin) semuanya bekerja untuk Anda.  Tentu saja, Anda perlu menguji dan, yang paling penting, uji pada platform target, tergantung pada jumlah core, dll.  Tetapi penggunaan Sistem Pekerjaan dan ECS, seperti yang saya katakan, juga sangat mempengaruhi bagaimana Anda merencanakan arsitektur game Anda. <br><br>  Maka semuanya jauh lebih sederhana.  Burst Compiler adalah teknologi unik kami, kompiler khusus dari subnet C # (Kinerja Tinggi C #) ini ke dalam kode mesin platform saat ini, yang akan Anda terbitkan ke proyek Anda. <br><br><img src="https://habrastorage.org/webt/2s/ag/qg/2sagqggfsgpjvfjuqsd1tcy_e5g.png"><br><br>  Orang-orang melakukan sihir yang mungkin tidak ada yang mengerti kecuali mereka, tetapi hal ini mempercepat kode Pekerjaan 10 kali, yang sangat keren.  Dan yang paling keren adalah itu tidak memerlukan tindakan apa pun dari Anda - jika Anda memiliki kode Pekerjaan, Anda cukup menambahkan atribut [BurstCompile], Burst mengkompilasi kode Anda, dan Anda mendapatkan kinerja "bebas".  Ini adalah teknologi baru kami dan Anda dapat mencobanya sekarang. <br><br><img src="https://habrastorage.org/webt/lb/-2/2o/lb-22ophaiyv_c9vwtehvj48iqk.png"><br><br>  Dan hal terakhir yang ingin saya sebutkan secara singkat adalah Scriptable Render Pipeline (SRP), yang telah kami kerjakan untuk waktu yang sangat lama dan yang dirancang untuk memberi Anda kesempatan untuk menulis rendering yang sangat khusus untuk game spesifik Anda. <br><br><img src="https://habrastorage.org/webt/ng/vh/32/ngvh32ztmpxvgkqzhfyujehhwoe.png"><br><br>  Render Pipeline adalah beberapa algoritma yang melakukan Culling (objek mana yang akan digambar), Rendering dan Post-processing.  Sekarang kami memiliki kotak hitam, yang Teruskan atau Ditangguhkan - mereka sudah bagus, kami mendapatkan grafik yang sangat keren di ponsel, di PC, di konsol.  Tetapi mereka memiliki banyak batasan, karena mereka tidak dapat diperluas.  Menggunakan fitur baru ini, SRP, Anda dapat menulis Pipeline Anda, Anda dapat menghapus sesuatu dari sana, menambahkan, melakukan apa pun yang Anda inginkan. <br><br><img src="https://habrastorage.org/webt/gj/gj/0b/gjgj0bdrlc_7nahtzi5tkx6ccu0.png"><br><br>  Kami saat ini sedang mengerjakan dua contoh jaringan pipa.  Satu LWRP, yang kami targetkan pada ponsel dan perangkat yang lemah, dan HDRP, yang kami targetkan pada PC, konsol, dan di mana orang-orang yang sangat terkenal di dunia industri bekerja.  Sebelum itu, mereka membuat game AAA.  Tentunya, Anda melihat demo kami Book of the Dead. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/NoemmTLnK6k" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Di sini kami menggunakan HDRP untuk menunjukkan kekuatan penuh dari teknologi ini. <br><br>  Untuk menggunakan ini, Anda juga perlu mengambil langkah heroik yang cukup besar, karena dengan Pipeline baru, hampir tidak ada yang kompatibel dengan apa yang kita miliki sekarang.  Yaitu  jika Anda memutakhirkan dengan Legacy, maka kami memberikan utilitas yang akan memutakhirkan sebagian besar materi untuk Anda, tetapi Anda harus menulis ulang shaders Anda, mis.  tekstur kemungkinan besar akan terlihat berbeda. <br><br><img src="https://habrastorage.org/webt/0l/mu/h2/0lmuh2hegzr_croq8bi_jfnhl68.png"><br><br>  Sangat keren jika Anda bisa mulai dari awal dan bereksperimen dengan Pipeline Anda.  Jika Anda ingin melakukan sesuatu di Pipeline Anda, silakan hubungi kami. <br><br>  Sekali lagi, pahami apa yang Anda butuhkan, karena sekarang Anda memiliki lebih banyak peluang untuk melakukan sesuatu, tetapi Anda akan membutuhkan orang-orang yang dapat melakukannya atau Anda perlu belajar bagaimana melakukannya. <br><br><img src="https://habrastorage.org/webt/bc/bm/ff/bcbmffmyzfoguauzz3na8ese_xg.png"><br><br>  Menurut saya, ini keren, karena mereka yang maju bersama kami dengan teknologi baru ini akan lebih laris di pasar.  Itu saja, saya harap seseorang akan pergi dan melihat teknologi ini, membuat game yang indah dan keren. <br><br><h3>  Pertanyaan dari audiens </h3><br>  <b>- Kapan saya bisa mendapatkan ECS dan mengembangkannya?</b> <br><br>  - Anda dapat menggunakan ECS, masalahnya adalah bahwa dalam bentuk saat ini lebih ditargetkan untuk orang yang berfokus pada kinerja, mis.  semacam proyek AAA.  Dan tugas Unity adalah membuat Performance by Default tersedia untuk semua orang.  Oleh karena itu, kita memerlukan sistem tertentu, tambahan untuk ECS, yang akan memungkinkan kita untuk menggunakan ECS dengan kemudahan yang sama seperti kita menggunakan MonoBehavior sekarang.  Meskipun tidak ada add-on seperti itu, saya tidak berpikir bahwa ECS akan dirilis dalam rilis penuh.  Dan ternyata kami membuat fitur yang akan digunakan 1% dari pengguna kami.  Dan ini bukan tugas Persatuan.  Saya tahu orang-orang yang sudah menggunakan ECS dalam produksi, hanya perlu diingat bahwa fitur ini masih dalam pengembangan dan sekarang kami sedang memecahkan pertanyaan tentang bagaimana membuat antarmuka yang paling nyaman.  Dan tugas selanjutnya (yang tidak kalah sulit) adalah bagaimana membuat semacam API yang hidup di atas ECS ini dan memungkinkan Anda untuk menggunakannya dengan kemudahan yang sama seperti MonoBehaviour.  Yaitu  tidak ada jawaban untuk pertanyaan "kapan tepatnya". <br><br>  <b>- ECS dan item lainnya difokuskan untuk mengambil satu GameObject dasar dan membuat 150 ribu klonnya dan mengelolanya.</b>  <b>Tetapi bagaimana jika saya memiliki beberapa objek, tetapi mereka memiliki entitas yang berbeda?</b> <br><br>  - Anda dapat, pada prinsipnya, tidak melakukan apa-apa, teknologi ini tidak mengharuskan Anda untuk menggunakannya.  Jika Anda bisa mendapatkan peningkatan kinerja menggunakan teknologi ini, Anda harus menggunakannya.  Jika ini tidak relevan untuk Anda, maka Anda terus menggunakan Unity apa adanya.  Karena itu, tolong jangan panik. <br><br>  <b>- Kami memiliki klien di Unity, server di .NET, kami mencoba server di Unity, tidak ada hasilnya.</b>  <b>Tetapi pada saat yang sama, saya ingin menggunakan teknologi yang ada di Unity di server juga.</b> <b><br></b> <br>  - Kami sedang mengerjakan ini dan memahami bahwa sekarang kami tidak dapat memberikan solusi server yang efektif.  Kami membeli perusahaan Multiplay beberapa waktu lalu untuk membuat hosting berkualitas tinggi untuk game Unity.  Kami melakukan jejaring secara terpisah dan secara terpisah berkomitmen untuk mengoptimalkan mesin sehingga lebih banyak hal yang dapat dibuang.  Oleh karena itu, ketika semuanya datang bersama, kami akan memiliki solusi multipemain yang sangat baik. <br><br><h3>  Lebih banyak pembicaraan dengan Pixonic DevGAMM Talks </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Menggunakan Konsul untuk meningkatkan layanan yang</a> sah (Ivan Bubnov, DevOps di BIT.GAMES); </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CICD: penyebaran mulus ke sistem cluster terdistribusi tanpa downtime</a> (Egor Panov, administrator sistem Pixonic); </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Praktek menggunakan model aktor di platform backend dari game Quake Champions</a> (Roman Rogozin, pengembang backend Saber Interactive); </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Arsitektur server meta penembak online seluler Tacticool</a> (Pavel Platto, Insinyur Perangkat Lunak Utama di PanzerDog); </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Prinsip KISS dalam pengembangan</a> (Konstantin Gladyshev, Lead Game Programmer di 1C Game Studios); </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Logika permainan umum pada klien dan server</a> (Anton Grigoriev, Wakil Petugas Teknis di Pixonic). </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mentimun di Awan: Menggunakan Skrip BDD untuk Pengujian Stres Produk</a> (Anton Kosyakin, Manajer Produk Teknis pada Platform ALICE). </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id427359/">https://habr.com/ru/post/id427359/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id427349/index.html">Programmer untuk keluarga tinyAVR baru berdasarkan konverter CH340 Cina yang murah</a></li>
<li><a href="../id427351/index.html">Security Week 40: Kerentanan dalam CMS Drupal dan Lainnya</a></li>
<li><a href="../id427353/index.html">Drone menunjukkan: bagaimana kita mengoordinasikan sekelompok penari menari</a></li>
<li><a href="../id427355/index.html">Kompilasi CJM, keterampilan art director utama dan pemahaman pengguna</a></li>
<li><a href="../id427357/index.html">Menulis shader di Unity. GrabPass, PerRendererData</a></li>
<li><a href="../id427361/index.html">Fitur pemfilteran jendela pada FPGA</a></li>
<li><a href="../id427363/index.html">Implementasi LoRaWAN di perusahaan pertanian. Segala sesuatu tentang konstruksi, peluncuran, dan solusi</a></li>
<li><a href="../id427365/index.html">Laporan dari RedSlerm tentang pemantauan (Monit, Zabbix)</a></li>
<li><a href="../id427367/index.html">Konferensi BLACK HAT USA. Bagaimana seorang hacker Hollywood menggunakan kamera pengintai. Bagian 1</a></li>
<li><a href="../id427369/index.html">Konferensi BLACK HAT USA. Bagaimana seorang hacker Hollywood menggunakan kamera pengintai. Bagian 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>