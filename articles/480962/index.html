<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ôèÔ∏è ü¶â üë©üèæ‚Äçüåæ Desarrollo del compilador C para el nuevo neuroprocesador multiclet ‚öôÔ∏è üíü üîÖ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En una conferencia de desarrolladores de software de sistemas y herramientas, OS DAY 2016, que se celebr√≥ en Innopolis del 9 al 10 de junio de 2016 (K...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Desarrollo del compilador C para el nuevo neuroprocesador multiclet</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/480962/"><img src="https://habrastorage.org/webt/nm/q_/3x/nmq_3x1b_eccqomclbciqkb5go8.jpeg"><br><br>  En una conferencia de desarrolladores de software de sistemas y herramientas, OS DAY 2016, que se celebr√≥ en Innopolis del 9 al 10 de junio de 2016 (Kazan) al analizar un informe sobre arquitectura multicelular, se expres√≥ la idea de que ser√≠a m√°s eficaz para resolver problemas de inteligencia artificial.  Las condiciones para el desarrollo de un nuevo procesador de prop√≥sito general centrado en tareas de IA se han desarrollado este a√±o. <br><br>  El neuroprocesador S2 Multiclet, cuyo proyecto se present√≥ por primera vez en el Huawei Innovation Forum 2019, es un desarrollo adicional de la arquitectura multicelda.  Se diferencia de las multiceldas creadas anteriormente con un sistema de comandos, a saber, la introducci√≥n de nuevos tipos de datos de peque√±o tama√±o (con punto fijo y flotante) y las operaciones con ellos.  El n√∫mero de c√©lulas aument√≥ - 256 y la frecuencia - 2.5 GHz, lo que deber√≠a proporcionar un rendimiento m√°ximo de 81.9 TFlops a 16F y, en consecuencia, hacerlo comparable, en t√©rminos de c√°lculos neuronales, con las capacidades de TPU ASIC especializados modernos (TPU-3: 90 TFlops a 16F). <br><br>  Dado que la eficiencia del uso de procesadores depende en gran medida de la optimizaci√≥n del compilador, se ha desarrollado un esquema de optimizaci√≥n de c√≥digo desarrollado. <br>  Consideremos con m√°s detalle. <br><a name="habracut"></a><br>  El <a href="https://habr.com/ru/post/434982/">art√≠culo anterior</a> mencionaba las optimizaciones del compilador que vale la pena implementar.  All√≠ puede encontrar materiales sobre arquitectura multicelular si a√∫n no est√° familiarizado con ella. <br><br><h4>  Generando comandos de dos argumentos con dos constantes </h4><br>  Se ha introducido un nuevo formato de instrucci√≥n con el procesador S1, que permite que ambos argumentos se especifiquen como un valor constante.  Esto le permite reducir la cantidad de comandos en el c√≥digo, eliminando comandos innecesarios como cargar para cargar constantes en el conmutador. <br><br>  Por ejemplo: <br><br><pre><code class="plaintext hljs">load_l func wr_l @1, #SP</code> </pre> <br>  puede ser reemplazado por: <br><br><pre> <code class="plaintext hljs">wr_l func, #SP</code> </pre> <br>  O incluso dos equipos a la vez: <br><br><pre> <code class="plaintext hljs">load_l [foo] load_l [bar] add_l @1, @2</code> </pre> <br>  Hay dos direcciones constantes, y leerlas tambi√©n puede sustituirse directamente en los argumentos del comando: <br><br><pre> <code class="plaintext hljs">add_l [foo], [bar]</code> </pre><br>  Esta optimizaci√≥n se implement√≥ para todos los que admiten este formato.  Desafortunadamente, result√≥ ser muy ineficaz, por dos razones: <br><br><ul><li>  El n√∫mero de situaciones en las que se puede llevar a cabo dicha optimizaci√≥n es muy peque√±o.  En el c√≥digo de arbitraje, las situaciones rara vez surgen cuando necesita procesar de alguna manera dos valores que se conocen de antemano.  Muy a menudo, tales cosas se deciden en la etapa de compilaci√≥n, y solo queda un poco por hacer en tiempo de ejecuci√≥n.  Por lo general, estas son algunas operaciones en direcciones, nuevamente, constantes. </li><li>  Eliminar el comando de carga no libera al procesador del proceso de generaci√≥n de la constante, sino solo de buscar un comando de carga por separado, que solo proporciona una aceleraci√≥n d√©bil, e incluso entonces no siempre. </li></ul><br><h4>  Optimizaci√≥n de la transferencia de registros virtuales entre unidades base </h4><br>  En LLVM, los bloques b√°sicos son secciones lineales en las que el c√≥digo se ejecuta sin ramificaci√≥n.  Los p√°rrafos en una arquitectura multicelular realizan exactamente la misma funci√≥n, por lo tanto, la mayor√≠a de las veces al generar un c√≥digo, un p√°rrafo refleja un bloque b√°sico.  En el procesador R1, cualquier transferencia de registros virtuales entre p√°rrafos se realiz√≥ a trav√©s de la memoria escribiendo el valor del registro deseado en la pila y volvi√©ndolo a leer en el p√°rrafo que necesita este registro.  Este mecanismo se divide en 2 partes: transferencia del registro virtual a otro p√°rrafo para uso directo y transferencia del registro virtual como par√°metro para el nodo phi. <br><br>  Los nodos Phi son una consecuencia de la forma <a href="https://ru.wikipedia.org/wiki/SSA" rel="nofollow">SSA (asignaci√≥n √∫nica est√°tica)</a> en la que se representa el lenguaje de presentaci√≥n LLVM.  De esta forma, una variable (o, como en el caso de LLVM IR - registros virtuales) solo se puede escribir una vez.  Por ejemplo, este pseudoc√≥digo: <br><br><pre> <code class="cpp hljs">a = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (v &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>) a = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> a = <span class="hljs-number"><span class="hljs-number">3</span></span>; b = a;</code> </pre> <br>  no se presenta en forma SSA, porque el valor de la variable <b>a</b> se puede sobrescribir.  El c√≥digo puede reescribirse en este formulario, si usa el nodo phi: <br><br><pre> <code class="cpp hljs">a1 = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (v &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>) a2 = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> a3 = <span class="hljs-number"><span class="hljs-number">3</span></span>; b = phi(a2, a3);</code> </pre> <br>  El nodo phi selecciona a2 o a3, seg√∫n el origen del flujo de control: <br><img src="https://habrastorage.org/webt/ug/rw/-b/ugrw-brljdidipmpwg-iobfvjkm.png"><br>  En LLVM IR phi, los nodos se implementan como una instrucci√≥n separada, que selecciona diferentes registros virtuales dependiendo de la unidad base de la que proviene el control.  La implementaci√≥n en el procesador de esta instrucci√≥n a trav√©s de la memoria es bastante simple: diferentes bloques base escriben datos diferentes en la misma celda de memoria, y en el nodo phi del sitio se lee esta celda de memoria, y los datos ser√°n diferentes dependiendo del bloque base anterior. <br><br>  El formulario SSA implica que cuando se inicializa el registro, el valor siempre ser√° el mismo.  Cuando se realiza la transferencia directa de registros virtuales, cuando el valor de cada registro virtual se escribe en su propia celda de memoria separada, la condici√≥n SSA se cumple sin problemas: los datos est√°n en la memoria hasta que se sobrescriben.  Sin embargo, si queremos transferir el registro a trav√©s del interruptor, debemos recordar: su tama√±o es de solo 63 celdas, y cualquier valor desaparece cuando se ejecutan 63 comandos.  Por lo tanto, si el registro virtual se escribe en alg√∫n primer p√°rrafo y se usa despu√©s de que cientos de otros se hayan completado, entonces es imposible transferirlo a trav√©s del conmutador;  solo queda memoria. <br>  La implementaci√≥n de esta optimizaci√≥n se inici√≥ precisamente con la optimizaci√≥n de los nodos phi, ya que, en contraste con la transferencia directa de registros virtuales, los valores de los par√°metros para el nodo phi siempre se inicializan directamente en los p√°rrafos anteriores (bloques base), lo que le permite no pensar mucho sobre si el interruptor es lo suficientemente grande. si queremos pasar estos par√°metros a trav√©s de √©l. <br><br>  El ensamblador multicelular le permite asignar nombres a los resultados de los comandos y usar sus resultados con este nombre.  En lugar de que cada programador tenga que calcular cu√°ntos comandos se obtuvo este resultado, el ensamblador calcula esto por su cuenta: <br><br><pre> <code class="plaintext hljs">result := add_l [A], [B] ; ;    ; wr_l @result, C</code> </pre> <br>  Este mecanismo funciona perfectamente dentro del p√°rrafo actual, porque es una secci√≥n lineal y el orden de los comandos se conoce all√≠.  Esto se usa activamente cuando el compilador genera c√≥digo: todos los comandos tienen nombres asignados y el compilador no necesita preocuparse por numerar los comandos.  M√°s precisamente, no era necesario, porque si queremos obtener el resultado de un comando ejecutado en otro p√°rrafo, entonces el mecanismo no funciona: en la etapa de ensamblaje es imposible descubrir qu√© p√°rrafo fue ejecutado realmente por el anterior si hay varias entradas en el actual.  Por lo tanto, la √∫nica opci√≥n es acceder a los resultados de los equipos a trav√©s del n√∫mero.  Por esta raz√≥n, no puede simplemente arrojar registros / lecturas adicionales de la memoria en p√°rrafos vecinos y reemplazar las referencias de registro del comando de lectura con el comando en el p√°rrafo anterior. <br><br>  Aqu√≠ vale la pena prestar atenci√≥n a una consecuencia muy importante: si un p√°rrafo tiene varias entradas, entonces <b>@ 1</b> en el primer comando de esta secci√≥n puede referirse a resultados completamente diferentes, dependiendo de qu√© p√°rrafo fue el anterior.  El nodo Phi es solo una situaci√≥n as√≠.  Anteriormente, en todos los bloques b√°sicos que inicializaban el nodo phi, los datos se escrib√≠an en la misma celda de memoria, y en lugar del nodo phi hab√≠a una lectura de esta celda.  Por lo tanto, no era absolutamente importante el lugar en el que hab√≠a un registro en esta celda en los p√°rrafos anteriores, al igual que el lugar en el que se ley√≥ esta celda.  Si se deshace del uso de la memoria, cambia. <br><br>  Para permitir que los hosts phi usen un conmutador en lugar de memoria, se realiz√≥ lo siguiente: <br><br><ol><li>  Todos los nodos phi en la unidad base actual se cuentan (y puede haber varios), se marcan con un n√∫mero de serie y se ordenan en este orden </li><li>  Para cada nodo phi, se <b>omiten</b> los bloques iniciales que lo inicializan; se agregan comandos para cargar los valores en el conmutador ( <b>loadu_q</b> ), marcados con el n√∫mero de serie del nodo phi correspondiente. </li><li>  La instrucci√≥n phi del nodo en s√≠ tambi√©n se reemplaza por <b>loadu_q</b> con su n√∫mero de serie </li><li>  Todos los comandos agregados se reorganizan en el orden dado </li></ol><br>  El cuarto punto es necesario por la raz√≥n ya indicada: si queremos que el <b>comando loadu_q @ 3</b> acceda al resultado espec√≠ficamente para su nodo phi, entonces todos los p√°rrafos de inicializaci√≥n del comando que carga los datos en el conmutador deben estar exactamente en el mismo orden.  Pongamos un ejemplo del resultado real de compilar c√≥digo en el que hay dos nodos phi en una unidad base. <br><br>  P√°rrafos con inicializadores nodos phi: <br><br><pre> <code class="plaintext hljs">LBB1_27: LBB1_30: SR4 := loadu_q @1 setjf_l @0, LBB1_31 setjf_l @0, LBB1_31 SR4 := loadu_q [#SP + 8] SR5 := loadu_q [#SP + 16] SR5 := loadu_q [#SP] SR6 := loadu_l 0x1 SR6 := add_l @SR4, 0xffffffff SR7 := add_l @SR6, [@SR4] loadu_q @SR5 wr_l @SR7, @SR4 loadu_q @SR6 loadu_q @SR6 complete loadu_q @SR5 complete</code> </pre><br>  Un p√°rrafo con dos nodos phi: <br><br><pre> <code class="plaintext hljs">LBB1_31: SR4 := loadu_q @2 SR5 := loadu_q @2 SR6 := loadu_l [#SP + 124] SR7 := loadu_l [#SP + 120] setjf_l @0, @SR7 setrg_q #RETV, @SR4 wr_l @SR5, @SR6 setrg_q #SP, #SP + 120 complete</code> </pre> <br>  Anteriormente, en lugar de los comandos <b>loadu_q,</b> habr√≠a escrituras en la memoria y lecturas de la misma. <br>  En el proceso de implementaci√≥n de esta optimizaci√≥n, tambi√©n hubo algunos problemas que no se hab√≠an previsto de antemano: <br><br><ul><li>  Algunas optimizaciones de c√≥digo existentes reorganizan los comandos en lugares, por ejemplo, colocando la direcci√≥n del siguiente p√°rrafo al comienzo del actual, o la ubicaci√≥n de los comandos de lectura / escritura de memoria al principio / final del p√°rrafo, respectivamente.  Estas optimizaciones ocurren despu√©s de las operaciones con nodos phi (las llamadas instrucciones LLVM de reducci√≥n antes de las instrucciones del procesador), por lo que a menudo interrumpen el orden incorporado de los comandos <b>loadu_q</b> .  Para no interrumpir el trabajo de estas optimizaciones, tuve que crear un pase LLVM separado, que organiza los comandos para los nodos phi en el orden correcto despu√©s de todas las otras manipulaciones con los comandos. </li><li>  Result√≥ que puede surgir una situaci√≥n en la que una unidad base inicializa nodos phi para dos unidades base diferentes.  Es decir, siguiendo el algoritmo indicado, estos bloques base se agregar√°n al comando de inicializaci√≥n <b>loadu_q</b> para cada nodo phi.  En este caso, incluso si tienen un solo nodo phi, en la secci√≥n de inicializaci√≥n habr√° 2 <b>comandos loadu_q</b> , que, l√≥gicamente, ambos deber√≠an estar en el √∫ltimo lugar, lo que, por supuesto, es imposible.  Afortunadamente, tales situaciones son bastante raras, por lo que si hay una unidad base en la que los nodos phi se inicializan para m√°s de otra unidad base, solo el primero usa el interruptor de acuerdo con el algoritmo, para el resto, como antes, a trav√©s de la memoria. </li></ul><br>  Toda esta optimizaci√≥n de los nodos phi se puede complementar un poco m√°s.  Por ejemplo, si mira el p√°rrafo <b>LBB1_30</b> anterior, puede ver que <b>loadu_q ordena</b> valores de carga que no se usan en ning√∫n otro lugar.  Es decir, si elimina <b>loadu_q</b> y establece los comandos que crean estos valores en el mismo orden, los comandos <b>loadu_q @ 2</b> en la siguiente secci√≥n tambi√©n cargar√°n los valores correctos. <br><br><h4>  Puntos de referencia </h4><br>  Los resultados de optimizaci√≥n actuales se probaron en los puntos de referencia de CoreMark y WhetStone, cuya descripci√≥n se puede encontrar en el <a href="https://habr.com/ru/post/434982/">art√≠culo anterior</a> .  Comencemos con los resultados de CoreMark en el n√∫cleo S2 en comparaci√≥n con los resultados anteriores (versi√≥n anterior del compilador en el n√∫cleo S1). <br><div class="scrollable-table"><table><tbody><tr><th>  CPU </th><th>  <b>Multiclet s2</b> </th><th>  Multiclet s1 </th><th>  Elbrus-4C (E2S) </th><th>  Texas Inst.  BRAZO AM5728 Cortex-A15 </th><th>  Baikal-t1 </th><th>  Intel Core i7 7700K </th></tr><tr><td>  Frecuencia de reloj, MHz </td><td>  <b>2500</b> </td><td>  1600 </td><td>  800 </td><td>  1500 </td><td>  1200 </td><td>  4500 </td></tr><tr><td>  Puntuaci√≥n general de CoreMark </td><td>  <b>122425</b> </td><td>  18356 </td><td>  8850 </td><td>  15789 </td><td>  13142 </td><td>  182128 </td></tr></tbody></table></div><br>  Los valores relativos de CoreMark / MHz se muestran en el histograma: <br><br><img src="https://habrastorage.org/webt/nw/c6/kw/nwc6kwtqwiejo48poskzc0zrzky.png"><br><br>  Para obtener una estimaci√≥n de la aceleraci√≥n solo debido a la optimizaci√≥n de los nodos phi, puede volver a calcular el indicador CoreMark en un multicelda en n√∫cleos S1 y S2 para una frecuencia de 1600 MHz: son 1147 y 1224, respectivamente, lo que significa un aumento del 6,7%. <br><br>  Con WhetStone, la situaci√≥n es algo diferente.  Los cambios en el n√∫cleo aqu√≠ influyeron en el resultado, adem√°s, este punto de referencia se ejecuta en un n√∫cleo (multicelda) y se calcula en t√©rminos de megahercios, por lo que la frecuencia del procesador no juega ning√∫n papel. <br><br>  Tarjeta de puntuaci√≥n de piedra de afilar: <br><div class="scrollable-table"><table><tbody><tr><th>  CPU </th><th>  <b>MultiClet S2</b> </th><th>  MultiClet S1 </th><th>  Core i7 4820K </th><th>  BRAZO v8-A53 </th></tr><tr><td>  MWIPS / MHz </td><td>  <b>0.326</b> </td><td>  0,342 </td><td>  0,887 </td><td>  0,642 </td></tr><tr><td>  MFLOPS1 / MHz </td><td>  <b>0.141</b> </td><td>  0,156 </td><td>  0,341 </td><td>  0,268 </td></tr><tr><td>  MFLOPS2 / MHz </td><td>  <b>0,094</b> </td><td>  0.111 </td><td>  0,308 </td><td>  0.241 </td></tr><tr><td>  MFLOPS3 / MHz </td><td>  <b>0,108</b> </td><td>  0,124 </td><td>  0,167 </td><td>  0,239 </td></tr><tr><td>  COS MOPS / MHz </td><td>  <b>0.007</b> </td><td>  0.008 </td><td>  0,023 </td><td>  0,028 </td></tr><tr><td>  EXP MOPS / MHz </td><td>  <b>0.005</b> </td><td>  0.005 </td><td>  0,014 </td><td>  0.004 </td></tr><tr><td>  FIXPT MOPS / MHz </td><td>  <b>0,115</b> </td><td>  0.116 </td><td>  0,998 </td><td>  1.197 </td></tr><tr><td>  SI MOPS / MHz </td><td>  <b>0,196</b> </td><td>  0,196 </td><td>  1.504 </td><td>  1.436 </td></tr><tr><td>  MOPS IGUALES / MHz </td><td>  <b>0,156</b> </td><td>  0,149 </td><td>  0.251 </td><td>  0.439 </td></tr></tbody></table></div><br>  Ahora est√° claro que incluso cuando se usa la versi√≥n anterior del compilador en el n√∫cleo S1, el √≠ndice general es m√°s alto, principalmente debido a las pruebas de punto flotante MFLOPS1-3.  Este inconveniente se not√≥ durante las pruebas y se debe al hecho de que el transportador interno del bloque de coma flotante en S2, en comparaci√≥n con S1, es un paso m√°s.  Como resultado, las sucesivas cadenas de comandos relacionados con datos perdieron una medida en cada comando.  La necesidad de este paso fue causada por una reducci√≥n en la duraci√≥n del ciclo del reloj (un aumento en la frecuencia del procesador de 1.6 GHz a 2.5 GHz y un aumento en la nomenclatura de comandos, por ejemplo, la aparici√≥n del comando de multiplicaci√≥n con la acumulaci√≥n de MAC).  Esta decisi√≥n es temporal.  Se est√° trabajando para reducir la longitud de la tuber√≠a, y en el futuro esto se solucionar√°, pero se realizaron pruebas en la versi√≥n actual de S2. <br><br>  Para evaluar la aceleraci√≥n de la optimizaci√≥n del compilador, WhetStone tambi√©n se compil√≥ en una versi√≥n anterior y se lanz√≥ en la versi√≥n actual de S2.  El indicador total fue 0.3068 MWIPS / MHz versus 0.3267 MWIPS / MHz en el nuevo compilador, es decir.  que muestra una aceleraci√≥n del 6.5% debido a las optimizaciones anteriores. <br><br>  El sistema de optimizaci√≥n desarrollado y probado le permite implementar en el futuro el siguiente esquema de optimizaci√≥n, a saber, la transferencia directa de registros virtuales a trav√©s del conmutador.  Como ya se mencion√≥, no todas las copias del registro virtual se pueden hacer a trav√©s del conmutador.  Debido al tama√±o limitado del interruptor y la imposibilidad de acceder correctamente a los resultados de los p√°rrafos anteriores si hay varios puntos de entrada al actual (esto se resuelve parcialmente mediante nodos phi), la √∫nica opci√≥n posible es copiar registros virtuales de un p√°rrafo directamente al siguiente, pero solo hay uno anterior .  Tales casos, de hecho, no son tan pocos, a menudo es necesario transferir datos de manera tan directa, aunque la aceleraci√≥n del c√≥digo que dar√° para decir por adelantado es, por supuesto, dif√≠cil. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/480962/">https://habr.com/ru/post/480962/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../480950/index.html">An√°lisis del cuestionario de Android desde el stand hh.ru en Mobius 2019 Mosc√∫</a></li>
<li><a href="../480954/index.html">Tarea n√∫mero 1. Descubre g√©nero y grado de relaci√≥n</a></li>
<li><a href="../480956/index.html">C√≥mo encontr√© una manera de rastrear a todos los conductores de Citimobil</a></li>
<li><a href="../480958/index.html">Conexi√≥n satelital. Descripci√≥n general de las compa√±√≠as operadoras y un poco sobre la calificaci√≥n</a></li>
<li><a href="../480960/index.html">Encuentra archivos perdidos en m√∫ltiples objetivos Xcode</a></li>
<li><a href="../480964/index.html">¬øQu√© es la zona de Fresnel y CCQ (calidad de conexi√≥n del cliente) o los factores fundamentales de un puente inal√°mbrico de alta calidad?</a></li>
<li><a href="../480970/index.html">10 mejores pr√°cticas para asegurar las im√°genes de Docker. Parte 1</a></li>
<li><a href="../480974/index.html">Desarrollo de aplicaciones en mini aplicaciones VK</a></li>
<li><a href="../480976/index.html">Biblioteca de pruebas de API JSON-RPC</a></li>
<li><a href="../480978/index.html">¬øHay vida despu√©s de la signora?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>