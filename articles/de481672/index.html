<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤓 🌑 🚬 Mobilfunkautomaten im Browser ⏱️ 🧑🏾 🌃</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ein zellularer Automat ist ein System, das aus Zellen mit numerischen Werten in einem Raster sowie Regeln besteht, die das Verhalten dieser Zellen bes...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mobilfunkautomaten im Browser</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/481672/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/028/8da/3c1/0288da3c139cf936f21eccce5342a6d6.jpg" alt="Bild"></div><br>  Ein zellularer Automat ist ein System, das aus Zellen mit numerischen Werten in einem Raster sowie Regeln besteht, die das Verhalten dieser Zellen bestimmen.  Wenn man die Regel wiederholt parallel zur Visualisierung des Gitters auf jede Gitterzelle anwendet, kann man häufig die Wirkung eines bestimmten sich entwickelnden Organismus mit komplexem und komplexem Verhalten erzielen, selbst wenn die Regeln relativ einfach sind. <br><br>  Zelluläre Automaten haben verschiedene Formen, Typen und Abmessungen.  Der wohl bekannteste zellulare Automat ist das Conway's Game of Life (GOL).  Es besteht aus einem zweidimensionalen Gitter, in dem jede Zelle einen Binärwert enthält (lebend oder tot).  Die begleitenden Regeln, basierend auf dem Zustand benachbarter Zellen, bestimmen, ob die Zelle tot oder lebendig sein soll.  Die Regeln besagen, dass eine lebende Zelle an Einsamkeit stirbt, wenn sich weniger als 2 lebende Zellen um sie herum befinden.  Wenn mehr als drei benachbarte Zellen am Leben sind, stirbt sie an Überbevölkerung.  Mit anderen Worten, eine Zelle "überlebt", wenn genau zwei oder drei benachbarte Zellen um sie herum leben.  Damit eine <em>tote</em> Zelle zum Leben erweckt wird, müssen genau drei benachbarte Zellen leben, ansonsten bleibt sie tot.  Ein Beispiel für eine GoL-Maschine, die mehrere Status durchläuft, ist unten dargestellt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/562/8d3/d06/5628d3d06c87bcf93b7949f8ea5eec7a.gif" alt="Spiel des Lebens"></div><br>  Eine andere berühmte Version des zellularen Automaten ist eindimensional;  Es heißt Elementary Cellular Automaton (ECA).  Dies setzen wir in diesem Beitrag um. <br><a name="habracut"></a><br>  Jeder Zustand dieses Automaten wird als eindimensionales Array von Booleschen Werten gespeichert, und während zur Visualisierung des GOL-Zustands zwei Dimensionen erforderlich sind, reicht für diesen Automaten ein Werteautomat aus.  Aus diesem Grund können wir die gesamte Geschichte der Zustände dieses Automaten zweidimensional (anstatt animiert) darstellen.  Wie im Fall von GOL ist der Status der Zelle in dieser Maschine 0 oder 1, aber im Gegensatz zu der GOL-Zelle, die abhängig von ihren 8 Nachbarn aktualisiert wird, wird die ECA-Zelle basierend auf dem Status des linken Nachbarn, des rechten Nachbarn und sich selbst aktualisiert! <br><br>  Beispiele für Regeln sind im Folgenden aufgeführt: Die oberen drei Zellen sind die Eingabe der Regel, und die untere ist die Ausgabe, wobei Schwarz 1 und Weiß 0 ist. Außerdem können wir die von jedem von ihnen erzeugten Muster sehen, wenn der Anfangszustand alle 0 außer 1 ist in der mittleren Zelle. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7ad/c6d/69a/7adc6d69a6e6f302850bc9227ea8bdb1.jpg"></div><br>  Sie fragen sich vielleicht: Warum werden die oben aufgeführten Regeln durch Zahlen angezeigt?  Da jede Zahl im Bereich von 0 bis 255 direkt der ECA-Regel entspricht, werden diese Zahlen als Namen der Regeln verwendet.  Diese Entsprechung wird unten gezeigt: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a41/65e/13b/a4165e13bf83463bbf66a155ba8441fd.png"></div><br>  <i>Von der Zahl zur Regel</i> <br><br>  Jede Zahl im Bereich von 0 bis 255 kann binär mit nur 8 Stellen dargestellt werden (erster Pfeil oben).  Darüber hinaus können wir jeder dieser Zahlen einen Index geben, der auf ihrer Position basiert (zweiter Pfeil).  Selbstverständlich liegen diese Indizes im Bereich von 0 bis 7, dh sie können mit nur 3 Stellen binär dargestellt werden (dritter Pfeil).  Wenn wir diese 3 Ziffern als Eingabe interpretieren und die entsprechende Ziffer der ursprünglichen Zahl als Ausgabe, erhalten wir die benötigte ternäre Funktion (vierter Pfeil). <br><br><h2>  Regelerstellung </h2><br>  Implementieren wir die obige Interpretation als übergeordnete Funktion <code>get_rule</code> , die eine Zahl von 0 bis 255 als Eingabe empfängt und eine dieser Zahl entsprechende ECA-Regel zurückgibt. <br><br>  Wir müssen so etwas erstellen: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rule30 = get_rule(<span class="hljs-number"><span class="hljs-number">30</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> output110 = rule30(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br>  In dem obigen Beispiel kombiniert das Starten von <code>rule30(1,1,0)</code> alle drei Binärwerte zu einer Zahl (110 = 6) und gibt an dieser Stelle (6) in der Binärdarstellung 30 ein Bit zurück. Die Zahl 30 in der Binärdarstellung ist 00011110. Daher gibt die Funktion 0 zurück (wir zählen rechts und beginnen die Zählung bei 0). <br><br>  Da wir wissen, dass die drei binären Eingangsvariablen zu einer Zahl zusammengefasst werden, implementieren wir zunächst eine solche <code>combine</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> combine = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">b1, b2, b3</span></span></span><span class="hljs-function">) =&gt;</span></span> (b1 &lt;&lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) + (b2 &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span>) + (b3 &lt;&lt; <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br>  Nachdem wir die Argumente nach links verschoben und dann die drei verschobenen Zahlen addiert haben, erhalten wir die gewünschte Kombination. <br><br>  Der zweite wichtige Teil der Funktion <code>get_rule</code> besteht darin, den <code>get_rule</code> an einer bestimmten Position in einer Zahl zu bestimmen.  Erstellen <code>get_bit(num, pos)</code> daher eine Funktion <code>get_bit(num, pos)</code> , die einen <code>get_bit(num, pos)</code> an einer bestimmten Position <code>pos</code> an einer bestimmten Nummer <code>num</code> .  Die Zahl 141 in binärer Form lautet beispielsweise 10001101, daher sollte <code>get_bit(2, 141)</code> <code>1</code> und <code>get_bit(5, 141)</code> <code>0</code> . <br><br>  Die Funktion <code>get_bit(num,pos)</code> kann implementiert werden, indem zuerst eine Bitverschiebung der Zahl um <code>pos</code> nach rechts durchgeführt wird und dann die bitweise Operation „AND“ mit der Zahl 1 ausgeführt wird. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> get_bit = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">num, pos</span></span></span><span class="hljs-function">) =&gt;</span></span> (num &gt;&gt; pos) &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br>  Jetzt müssen wir nur noch diese beiden Funktionen kombinieren: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> get_rule = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">num</span></span></span><span class="hljs-function"> =&gt;</span></span> (b1, b2, b3) =&gt; get_bit(num, combine(b1, b2, b3));</code> </pre> <br>  Großartig!  Wir haben also eine Funktion, die uns für jede Zahl innerhalb unseres Intervalls eine eindeutige ECA-Regel gibt, mit der wir alles tun können.  Der nächste Schritt ist das Rendern im Browser. <br><br><h2>  Regelvisualisierung </h2><br>  Zum Rendern von Automaten im Browser verwenden wir das <code>canvas</code> Element.  Das <code>canvas</code> kann wie folgt erstellt und dem HTML-Körper hinzugefügt werden: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.onload = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> canvas = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'canvas'</span></span>); canvas.width = <span class="hljs-number"><span class="hljs-number">800</span></span>; canvas.height = <span class="hljs-number"><span class="hljs-number">800</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.body.appendChild(canvas); };</code> </pre> <br>  Um mit <code>canvas</code> interagieren zu können, brauchen wir <em>Kontext</em> .  Der Kontext ermöglicht es uns, Formen und Linien zu zeichnen, Objekte einzufärben und allgemein auf der <code>canvas</code> navigieren.  Sie wird uns über die <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/getContext" rel="nofollow"><code>getContext</code></a> Methode unserer <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/getContext" rel="nofollow"><code>getContext</code></a> bereitgestellt. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> context = canvas.getContext(<span class="hljs-string"><span class="hljs-string">'2d'</span></span>);</code> </pre> <br>  Der Parameter <code>'2d'</code> bezieht sich auf den Kontexttyp, den wir in diesem Beispiel verwenden werden. <br><br>  Als Nächstes erstellen wir eine Funktion, die den Kontext, die ECA-Regel sowie einige Informationen über den Maßstab und die Anzahl der Zellen enthält und die Regel auf <code>canvas</code> zeichnet.  Die Idee ist, ein Gitter Linie für Linie zu erzeugen und zu zeichnen.  Der Hauptteil des Codes sieht ungefähr so ​​aus: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw_rule</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ctx, rule, scale, width, height</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> row = initial_row(width); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; height; i++) { draw_row(ctx, row, scale); row = next_row(row, rule); } }</code> </pre> <br>  Wir beginnen mit einer Art anfänglichem Satz von Zellen, der aktuellen Zeile.  Diese Zeile enthält, wie in den obigen Beispielen, normalerweise alle Nullen, mit Ausnahme einer Einheit in der mittleren Zelle. Sie kann jedoch auch eine vollständig zufällige Reihe von 1 und 0 enthalten. Wir zeichnen diese Reihe von Zellen und verwenden dann die Regel, um die nächste Wertereihe basierend auf zu berechnen aktuelle Zeile.  Dann wiederholen wir einfach die Zeichnung und berechnen die neuen Schritte, bis wir feststellen, dass das Gitter hoch genug ist. <br><br>  Für das obige Code-Snippet müssen drei Funktionen implementiert werden: <code>initial_row</code> , <code>draw_row</code> und <code>next_row</code> . <br><br>  <code>initial_row</code> ist eine einfache Funktion.  Es erstellt ein Array von Nullen und ändert das Element in der Mitte des Arrays um eins. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initial_row</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">length</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> initial_row = <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(length).fill(<span class="hljs-number"><span class="hljs-number">0</span></span>); initial_row[<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor(length / <span class="hljs-number"><span class="hljs-number">2</span></span>)] = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> initial_row; }</code> </pre> <br>  Da wir bereits eine Regelfunktion haben, kann die <code>next_row</code> Funktion aus einer Zeile bestehen.  Der Wert jeder Zelle in einer neuen Zeile ergibt sich aus der Anwendung der Regel mit den Werten der nächsten Zellen, und die alte Zeile wird als Eingabe verwendet. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> next_row = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">row, rule</span></span></span><span class="hljs-function">) =&gt;</span></span> row.map(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">_, i</span></span></span><span class="hljs-function">) =&gt;</span></span> rule(row[i - <span class="hljs-number"><span class="hljs-number">1</span></span>], row[i], row[i + <span class="hljs-number"><span class="hljs-number">1</span></span>]));</code> </pre> <br>  Haben Sie bemerkt, dass wir diese Linie betrogen haben?  Jede Zelle in einer neuen Zeile erfordert die Eingabe von drei anderen Zellen, aber zwei Zellen an den Rändern der Zeile empfangen Daten von nur zwei.  Beispielsweise versucht <code>next_row[0]</code> , den <code>next_row[0]</code> aus <code>row[-1]</code> <code>next_row[0]</code> .  Dies funktioniert immer noch, da beim Versuch, auf Werte über Indizes zuzugreifen, die nicht im Array enthalten sind, Javascript <code>undefined</code> zurückgibt, und es daher vorkommt, dass <code>(undefined &gt;&gt; [ ])</code> (aus der <code>combine</code> ) immer 0 zurückgibt. Dies bedeutet dass wir in Wirklichkeit jeden Wert außerhalb des Arrays als 0 verarbeiten. <br><br>  Ich weiß, dass das hässlich ist, aber bald werden wir etwas Schönes auf dem Bildschirm erschaffen, damit uns vergeben werden kann. <br><br>  Als nächstes kommt die <code>draw_row</code> Funktion;  Sie ist es, die das Rendering durchführt! <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw_row</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ctx, row, scale</span></span></span><span class="hljs-function">) </span></span>{ ctx.save(); row.forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">cell</span></span></span><span class="hljs-function"> =&gt;</span></span> { ctx.fillStyle = cell === <span class="hljs-number"><span class="hljs-number">1</span></span> ? <span class="hljs-string"><span class="hljs-string">'#000'</span></span> : <span class="hljs-string"><span class="hljs-string">'#fff'</span></span>; ctx.fillRect(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, scale, scale); ctx.translate(scale, <span class="hljs-number"><span class="hljs-number">0</span></span>); }); ctx.restore(); ctx.translate(<span class="hljs-number"><span class="hljs-number">0</span></span>, scale); }</code> </pre> <br>  Hier sind wir sehr abhängig von dem Kontextobjekt und verwenden mindestens 5 davon verschiedene Methoden.  Hier ist eine kurze Auflistung und wie man sie benutzt. <br><br><ul><li>  <code>fillStyle</code> gibt an, wie die Formen gefüllt werden sollen.  <code>"#f55"</code> kann eine Farbe sein, zum Beispiel <code>"#f55"</code> , sowie ein Farbverlauf oder ein Muster.  Wir verwenden diese Methode, um Zellen 0 visuell von Zellen 1 zu trennen. </li><li>  <code>fillRect(x, y, w, h)</code> zeichnet ein Rechteck aus einem Punkt (x, y) mit der Breite w und Höhe h, gefüllt gemäß <code>fillStyle</code> .  Unsere Rechtecke sind einfache Quadrate, aber Sie werden überrascht sein, dass der Ausgangspunkt aller Rechtecke am Ursprung liegt.  Es ist passiert, weil wir diese Methode in Kombination mit <code>translate</code> . </li><li>  <code>translate(x, y)</code> können Sie das gesamte Koordinatensystem verschieben.  Die Position wird gespeichert, daher ist die Methode eine hervorragende Alternative zum Verfolgen verschiedener Positionen von Elementen.  Anstatt zum Beispiel die Position jeder einzelnen Gitterzelle zu berechnen, können wir einfach eine Zelle zeichnen, nach rechts gehen, eine neue Zelle zeichnen und so weiter. </li><li>  <code>save()</code> und <code>restore()</code> werden in Verbindung mit <code>translate</code> und anderen Koordinatenkonvertierungsmethoden verwendet.  Wir verwenden sie, <em>um das</em> aktuelle Koordinatensystem an einem bestimmten Punkt zu <em>speichern</em> , damit wir später darauf zurückgreifen können (mithilfe von <em>Wiederherstellen</em> ).  In diesem Fall speichern wir das Koordinatensystem vor dem Rendern der Linie und verschieben es nach rechts.  Wenn wir mit dem Zeichnen der Linie fertig sind und ganz nach rechts gegangen sind, werden die Koordinaten wiederhergestellt und wir kehren zum ursprünglichen Zustand zurück.  Dann gehen wir nach unten, um uns darauf vorzubereiten, die nächste Linie zu zeichnen. </li></ul><br>  Jetzt haben wir alle Teile, die für die Funktion <code>draw_rule</code> erforderlich sind.  Wir verwenden diese Funktion in <code>window.onload</code> nachdem wir den <code>canvas</code> vorbereitet haben.  Wir werden auch die Parameter bestimmen, die wir brauchen. <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.onload = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> width = <span class="hljs-number"><span class="hljs-number">1000</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Width of the canvas const height = 500; // Height of the canvas const cells_across = 200; // Number of cells horizontally in the grid const cell_scale = width / cells_across; // Size of each cell const cells_down = height / cell_scale; // Number of cells vertically in the grid const rule = get_rule(30); // The rule to display const canvas = document.createElement('canvas'); canvas.width = width; canvas.height = height; document.body.appendChild(canvas); const context = canvas.getContext('2d'); draw_rule(context, rule, cell_scale, cells_across, cells_down); };</span></span></code> </pre> <br>  Wir extrahieren die <code>canvas</code> als separate Variablen zusammen mit der Anzahl der Zellen horizontal.  Dann berechnen wir <code>cell_scale</code> und 'cells_down' so, dass das Raster die gesamte Zeichenfläche ausfüllt, während die Zellen quadratisch bleiben.  Dank dessen können wir leicht die "Auflösung" des Gitters ändern, die innerhalb der <code>canvas</code> verbleibt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d98/566/33e/d9856633e69f731e69a8ae40a79591c2.png"></div><br>  Das ist alles!  Das vollständige Codebeispiel ist auf <a href="" rel="nofollow">Github</a> und auf <a href="https://codepen.io/kgolid/pen/oNgZKqV" rel="nofollow">Codepen</a> : <br><br><h2>  Weitermachen </h2><br>  Dank dieses Systems können wir nacheinander alle 256 Regeln überprüfen, entweder iterativ, indem wir den Code ändern oder bei jedem Seitenaufruf eine zufällige Regelnummer auswählen.  Wie dem auch sei, es ist sehr aufregend, all diese unvorhersehbaren Ergebnisse in unserer kontrollierten Umgebung zu untersuchen. <br><br>  Sie können auch den Anfangszustand der Zellen des Automaten zufällig bestimmen, anstatt der statischen „durchgezogenen Nullen und einer Einheit“.  So erhalten wir noch unvorhersehbarere Ergebnisse.  Diese Version der Funktion <code>initial_row</code> kann folgendermaßen geschrieben werden: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">random_initial_row</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">width</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.from(<span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(width), _ =&gt; <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor(<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random() * <span class="hljs-number"><span class="hljs-number">2</span></span>)); }</code> </pre> <br>  Unten sehen Sie, wie sehr diese Änderung der Ausgabezeile einen großen Einfluss auf die Ausgabe hat. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6a6/023/75e/6a602375ecbe522ad75829547ee92b5f.png"></div><br>  <i>Zufällige Quellzeichenfolge</i> <br><br>  Und dies ist nur ein Aspekt, den Sie ändern können!  Warum beschränken Sie sich nur auf zwei Bedingungen?  (Der Übergang von 2 zu 3 Staaten erhöht die Anzahl der Regeln von 256 auf 7 625 597 484 987!) Warum auf Quadrate beschränken?  Warum nur 2 Dimensionen?  Warum immer nur eine Regel? <br><br>  Beispiele für Visualisierungen, die auf ECA basieren, sind unten aufgeführt, jedoch mit einer alternativen Funktion <code>draw_rule</code> , <code>draw_rule</code> Linien nicht mit Quadraten, sondern mit einem isometrischen Muster zeichnet und anschließend die durch diese Linien definierten Bereiche mit Farben füllt.  Sie müssen nicht einmal Trennlinien anzeigen und nur Farben anzeigen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/028/8da/3c1/0288da3c139cf936f21eccce5342a6d6.jpg"></div><br>  Wenn Sie noch weiter gehen, können Sie Symmetrien hinzufügen, sowohl axial (mittlere Reihe) als auch gespiegelt (untere Reihe). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f71/cad/adc/f71cadadc23b156366f5bb93669d8b06.jpg"></div><br>  Wenn Ihnen diese Visualisierungen interessant erschienen, studieren Sie <a href="https://generated.space/sketch/hatch-automata-full/" rel="nofollow">diese interaktive Sandbox</a> , oder noch besser, beginnen Sie mit dem Code, den wir erstellt haben, und versuchen Sie, Ihre eigenen zellularen Automaten zu entwickeln! <br><br>  Viel glück </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de481672/">https://habr.com/ru/post/de481672/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de481662/index.html">Erprobung neuer Tools zum Erstellen und Automatisieren der Bereitstellung in Kubernetes</a></li>
<li><a href="../de481664/index.html">Serverlose Preise und Kosten: AWS Lambda</a></li>
<li><a href="../de481666/index.html">Benutzerdefinierte SwiftLint-Regeln</a></li>
<li><a href="../de481668/index.html">Das erste Problem mit dem Viewer oder die Schwierigkeiten beim Konvertieren von WebRTC-Videostreams in HLS</a></li>
<li><a href="../de481670/index.html">Erstellen Sie einen Aktionsplan mit dem AWS Cloud Adoption Framework</a></li>
<li><a href="../de481674/index.html">Autoverkaufstrichter oder wie man Kunden nicht zusammenführt und sogar mit denen zusammenarbeitet, die Ihre Dienste verweigert haben?</a></li>
<li><a href="../de481676/index.html">Sicherheitswoche 52: Sicherheit für intelligente Lautsprecher und IP-Kameras</a></li>
<li><a href="../de481678/index.html">Pre-Holiday Review: N6IIT01 Player und YB04 Armature Headphones - Hi-Fi aus Südchina</a></li>
<li><a href="../de481680/index.html">TodoMVC auf dap schreiben. Teil 2</a></li>
<li><a href="../de481684/index.html">Ein Laptop von Powerbank?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>