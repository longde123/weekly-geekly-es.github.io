<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§ì üåë üö¨ Mobilfunkautomaten im Browser ‚è±Ô∏è üßëüèæ üåÉ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ein zellularer Automat ist ein System, das aus Zellen mit numerischen Werten in einem Raster sowie Regeln besteht, die das Verhalten dieser Zellen bes...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mobilfunkautomaten im Browser</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/481672/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/028/8da/3c1/0288da3c139cf936f21eccce5342a6d6.jpg" alt="Bild"></div><br>  Ein zellularer Automat ist ein System, das aus Zellen mit numerischen Werten in einem Raster sowie Regeln besteht, die das Verhalten dieser Zellen bestimmen.  Wenn man die Regel wiederholt parallel zur Visualisierung des Gitters auf jede Gitterzelle anwendet, kann man h√§ufig die Wirkung eines bestimmten sich entwickelnden Organismus mit komplexem und komplexem Verhalten erzielen, selbst wenn die Regeln relativ einfach sind. <br><br>  Zellul√§re Automaten haben verschiedene Formen, Typen und Abmessungen.  Der wohl bekannteste zellulare Automat ist das Conway's Game of Life (GOL).  Es besteht aus einem zweidimensionalen Gitter, in dem jede Zelle einen Bin√§rwert enth√§lt (lebend oder tot).  Die begleitenden Regeln, basierend auf dem Zustand benachbarter Zellen, bestimmen, ob die Zelle tot oder lebendig sein soll.  Die Regeln besagen, dass eine lebende Zelle an Einsamkeit stirbt, wenn sich weniger als 2 lebende Zellen um sie herum befinden.  Wenn mehr als drei benachbarte Zellen am Leben sind, stirbt sie an √úberbev√∂lkerung.  Mit anderen Worten, eine Zelle "√ºberlebt", wenn genau zwei oder drei benachbarte Zellen um sie herum leben.  Damit eine <em>tote</em> Zelle zum Leben erweckt wird, m√ºssen genau drei benachbarte Zellen leben, ansonsten bleibt sie tot.  Ein Beispiel f√ºr eine GoL-Maschine, die mehrere Status durchl√§uft, ist unten dargestellt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/562/8d3/d06/5628d3d06c87bcf93b7949f8ea5eec7a.gif" alt="Spiel des Lebens"></div><br>  Eine andere ber√ºhmte Version des zellularen Automaten ist eindimensional;  Es hei√üt Elementary Cellular Automaton (ECA).  Dies setzen wir in diesem Beitrag um. <br><a name="habracut"></a><br>  Jeder Zustand dieses Automaten wird als eindimensionales Array von Booleschen Werten gespeichert, und w√§hrend zur Visualisierung des GOL-Zustands zwei Dimensionen erforderlich sind, reicht f√ºr diesen Automaten ein Werteautomat aus.  Aus diesem Grund k√∂nnen wir die gesamte Geschichte der Zust√§nde dieses Automaten zweidimensional (anstatt animiert) darstellen.  Wie im Fall von GOL ist der Status der Zelle in dieser Maschine 0 oder 1, aber im Gegensatz zu der GOL-Zelle, die abh√§ngig von ihren 8 Nachbarn aktualisiert wird, wird die ECA-Zelle basierend auf dem Status des linken Nachbarn, des rechten Nachbarn und sich selbst aktualisiert! <br><br>  Beispiele f√ºr Regeln sind im Folgenden aufgef√ºhrt: Die oberen drei Zellen sind die Eingabe der Regel, und die untere ist die Ausgabe, wobei Schwarz 1 und Wei√ü 0 ist. Au√üerdem k√∂nnen wir die von jedem von ihnen erzeugten Muster sehen, wenn der Anfangszustand alle 0 au√üer 1 ist in der mittleren Zelle. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7ad/c6d/69a/7adc6d69a6e6f302850bc9227ea8bdb1.jpg"></div><br>  Sie fragen sich vielleicht: Warum werden die oben aufgef√ºhrten Regeln durch Zahlen angezeigt?  Da jede Zahl im Bereich von 0 bis 255 direkt der ECA-Regel entspricht, werden diese Zahlen als Namen der Regeln verwendet.  Diese Entsprechung wird unten gezeigt: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a41/65e/13b/a4165e13bf83463bbf66a155ba8441fd.png"></div><br>  <i>Von der Zahl zur Regel</i> <br><br>  Jede Zahl im Bereich von 0 bis 255 kann bin√§r mit nur 8 Stellen dargestellt werden (erster Pfeil oben).  Dar√ºber hinaus k√∂nnen wir jeder dieser Zahlen einen Index geben, der auf ihrer Position basiert (zweiter Pfeil).  Selbstverst√§ndlich liegen diese Indizes im Bereich von 0 bis 7, dh sie k√∂nnen mit nur 3 Stellen bin√§r dargestellt werden (dritter Pfeil).  Wenn wir diese 3 Ziffern als Eingabe interpretieren und die entsprechende Ziffer der urspr√ºnglichen Zahl als Ausgabe, erhalten wir die ben√∂tigte tern√§re Funktion (vierter Pfeil). <br><br><h2>  Regelerstellung </h2><br>  Implementieren wir die obige Interpretation als √ºbergeordnete Funktion <code>get_rule</code> , die eine Zahl von 0 bis 255 als Eingabe empf√§ngt und eine dieser Zahl entsprechende ECA-Regel zur√ºckgibt. <br><br>  Wir m√ºssen so etwas erstellen: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rule30 = get_rule(<span class="hljs-number"><span class="hljs-number">30</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> output110 = rule30(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br>  In dem obigen Beispiel kombiniert das Starten von <code>rule30(1,1,0)</code> alle drei Bin√§rwerte zu einer Zahl (110 = 6) und gibt an dieser Stelle (6) in der Bin√§rdarstellung 30 ein Bit zur√ºck. Die Zahl 30 in der Bin√§rdarstellung ist 00011110. Daher gibt die Funktion 0 zur√ºck (wir z√§hlen rechts und beginnen die Z√§hlung bei 0). <br><br>  Da wir wissen, dass die drei bin√§ren Eingangsvariablen zu einer Zahl zusammengefasst werden, implementieren wir zun√§chst eine solche <code>combine</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> combine = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">b1, b2, b3</span></span></span><span class="hljs-function">) =&gt;</span></span> (b1 &lt;&lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) + (b2 &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span>) + (b3 &lt;&lt; <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br>  Nachdem wir die Argumente nach links verschoben und dann die drei verschobenen Zahlen addiert haben, erhalten wir die gew√ºnschte Kombination. <br><br>  Der zweite wichtige Teil der Funktion <code>get_rule</code> besteht darin, den <code>get_rule</code> an einer bestimmten Position in einer Zahl zu bestimmen.  Erstellen <code>get_bit(num, pos)</code> daher eine Funktion <code>get_bit(num, pos)</code> , die einen <code>get_bit(num, pos)</code> an einer bestimmten Position <code>pos</code> an einer bestimmten Nummer <code>num</code> .  Die Zahl 141 in bin√§rer Form lautet beispielsweise 10001101, daher sollte <code>get_bit(2, 141)</code> <code>1</code> und <code>get_bit(5, 141)</code> <code>0</code> . <br><br>  Die Funktion <code>get_bit(num,pos)</code> kann implementiert werden, indem zuerst eine Bitverschiebung der Zahl um <code>pos</code> nach rechts durchgef√ºhrt wird und dann die bitweise Operation ‚ÄûAND‚Äú mit der Zahl 1 ausgef√ºhrt wird. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> get_bit = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">num, pos</span></span></span><span class="hljs-function">) =&gt;</span></span> (num &gt;&gt; pos) &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br>  Jetzt m√ºssen wir nur noch diese beiden Funktionen kombinieren: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> get_rule = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">num</span></span></span><span class="hljs-function"> =&gt;</span></span> (b1, b2, b3) =&gt; get_bit(num, combine(b1, b2, b3));</code> </pre> <br>  Gro√üartig!  Wir haben also eine Funktion, die uns f√ºr jede Zahl innerhalb unseres Intervalls eine eindeutige ECA-Regel gibt, mit der wir alles tun k√∂nnen.  Der n√§chste Schritt ist das Rendern im Browser. <br><br><h2>  Regelvisualisierung </h2><br>  Zum Rendern von Automaten im Browser verwenden wir das <code>canvas</code> Element.  Das <code>canvas</code> kann wie folgt erstellt und dem HTML-K√∂rper hinzugef√ºgt werden: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.onload = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> canvas = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'canvas'</span></span>); canvas.width = <span class="hljs-number"><span class="hljs-number">800</span></span>; canvas.height = <span class="hljs-number"><span class="hljs-number">800</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.body.appendChild(canvas); };</code> </pre> <br>  Um mit <code>canvas</code> interagieren zu k√∂nnen, brauchen wir <em>Kontext</em> .  Der Kontext erm√∂glicht es uns, Formen und Linien zu zeichnen, Objekte einzuf√§rben und allgemein auf der <code>canvas</code> navigieren.  Sie wird uns √ºber die <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/getContext" rel="nofollow"><code>getContext</code></a> Methode unserer <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/getContext" rel="nofollow"><code>getContext</code></a> bereitgestellt. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> context = canvas.getContext(<span class="hljs-string"><span class="hljs-string">'2d'</span></span>);</code> </pre> <br>  Der Parameter <code>'2d'</code> bezieht sich auf den Kontexttyp, den wir in diesem Beispiel verwenden werden. <br><br>  Als N√§chstes erstellen wir eine Funktion, die den Kontext, die ECA-Regel sowie einige Informationen √ºber den Ma√üstab und die Anzahl der Zellen enth√§lt und die Regel auf <code>canvas</code> zeichnet.  Die Idee ist, ein Gitter Linie f√ºr Linie zu erzeugen und zu zeichnen.  Der Hauptteil des Codes sieht ungef√§hr so ‚Äã‚Äãaus: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw_rule</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ctx, rule, scale, width, height</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> row = initial_row(width); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; height; i++) { draw_row(ctx, row, scale); row = next_row(row, rule); } }</code> </pre> <br>  Wir beginnen mit einer Art anf√§nglichem Satz von Zellen, der aktuellen Zeile.  Diese Zeile enth√§lt, wie in den obigen Beispielen, normalerweise alle Nullen, mit Ausnahme einer Einheit in der mittleren Zelle. Sie kann jedoch auch eine vollst√§ndig zuf√§llige Reihe von 1 und 0 enthalten. Wir zeichnen diese Reihe von Zellen und verwenden dann die Regel, um die n√§chste Wertereihe basierend auf zu berechnen aktuelle Zeile.  Dann wiederholen wir einfach die Zeichnung und berechnen die neuen Schritte, bis wir feststellen, dass das Gitter hoch genug ist. <br><br>  F√ºr das obige Code-Snippet m√ºssen drei Funktionen implementiert werden: <code>initial_row</code> , <code>draw_row</code> und <code>next_row</code> . <br><br>  <code>initial_row</code> ist eine einfache Funktion.  Es erstellt ein Array von Nullen und √§ndert das Element in der Mitte des Arrays um eins. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initial_row</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">length</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> initial_row = <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(length).fill(<span class="hljs-number"><span class="hljs-number">0</span></span>); initial_row[<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor(length / <span class="hljs-number"><span class="hljs-number">2</span></span>)] = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> initial_row; }</code> </pre> <br>  Da wir bereits eine Regelfunktion haben, kann die <code>next_row</code> Funktion aus einer Zeile bestehen.  Der Wert jeder Zelle in einer neuen Zeile ergibt sich aus der Anwendung der Regel mit den Werten der n√§chsten Zellen, und die alte Zeile wird als Eingabe verwendet. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> next_row = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">row, rule</span></span></span><span class="hljs-function">) =&gt;</span></span> row.map(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">_, i</span></span></span><span class="hljs-function">) =&gt;</span></span> rule(row[i - <span class="hljs-number"><span class="hljs-number">1</span></span>], row[i], row[i + <span class="hljs-number"><span class="hljs-number">1</span></span>]));</code> </pre> <br>  Haben Sie bemerkt, dass wir diese Linie betrogen haben?  Jede Zelle in einer neuen Zeile erfordert die Eingabe von drei anderen Zellen, aber zwei Zellen an den R√§ndern der Zeile empfangen Daten von nur zwei.  Beispielsweise versucht <code>next_row[0]</code> , den <code>next_row[0]</code> aus <code>row[-1]</code> <code>next_row[0]</code> .  Dies funktioniert immer noch, da beim Versuch, auf Werte √ºber Indizes zuzugreifen, die nicht im Array enthalten sind, Javascript <code>undefined</code> zur√ºckgibt, und es daher vorkommt, dass <code>(undefined &gt;&gt; [ ])</code> (aus der <code>combine</code> ) immer 0 zur√ºckgibt. Dies bedeutet dass wir in Wirklichkeit jeden Wert au√üerhalb des Arrays als 0 verarbeiten. <br><br>  Ich wei√ü, dass das h√§sslich ist, aber bald werden wir etwas Sch√∂nes auf dem Bildschirm erschaffen, damit uns vergeben werden kann. <br><br>  Als n√§chstes kommt die <code>draw_row</code> Funktion;  Sie ist es, die das Rendering durchf√ºhrt! <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw_row</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ctx, row, scale</span></span></span><span class="hljs-function">) </span></span>{ ctx.save(); row.forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">cell</span></span></span><span class="hljs-function"> =&gt;</span></span> { ctx.fillStyle = cell === <span class="hljs-number"><span class="hljs-number">1</span></span> ? <span class="hljs-string"><span class="hljs-string">'#000'</span></span> : <span class="hljs-string"><span class="hljs-string">'#fff'</span></span>; ctx.fillRect(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, scale, scale); ctx.translate(scale, <span class="hljs-number"><span class="hljs-number">0</span></span>); }); ctx.restore(); ctx.translate(<span class="hljs-number"><span class="hljs-number">0</span></span>, scale); }</code> </pre> <br>  Hier sind wir sehr abh√§ngig von dem Kontextobjekt und verwenden mindestens 5 davon verschiedene Methoden.  Hier ist eine kurze Auflistung und wie man sie benutzt. <br><br><ul><li>  <code>fillStyle</code> gibt an, wie die Formen gef√ºllt werden sollen.  <code>"#f55"</code> kann eine Farbe sein, zum Beispiel <code>"#f55"</code> , sowie ein Farbverlauf oder ein Muster.  Wir verwenden diese Methode, um Zellen 0 visuell von Zellen 1 zu trennen. </li><li>  <code>fillRect(x, y, w, h)</code> zeichnet ein Rechteck aus einem Punkt (x, y) mit der Breite w und H√∂he h, gef√ºllt gem√§√ü <code>fillStyle</code> .  Unsere Rechtecke sind einfache Quadrate, aber Sie werden √ºberrascht sein, dass der Ausgangspunkt aller Rechtecke am Ursprung liegt.  Es ist passiert, weil wir diese Methode in Kombination mit <code>translate</code> . </li><li>  <code>translate(x, y)</code> k√∂nnen Sie das gesamte Koordinatensystem verschieben.  Die Position wird gespeichert, daher ist die Methode eine hervorragende Alternative zum Verfolgen verschiedener Positionen von Elementen.  Anstatt zum Beispiel die Position jeder einzelnen Gitterzelle zu berechnen, k√∂nnen wir einfach eine Zelle zeichnen, nach rechts gehen, eine neue Zelle zeichnen und so weiter. </li><li>  <code>save()</code> und <code>restore()</code> werden in Verbindung mit <code>translate</code> und anderen Koordinatenkonvertierungsmethoden verwendet.  Wir verwenden sie, <em>um das</em> aktuelle Koordinatensystem an einem bestimmten Punkt zu <em>speichern</em> , damit wir sp√§ter darauf zur√ºckgreifen k√∂nnen (mithilfe von <em>Wiederherstellen</em> ).  In diesem Fall speichern wir das Koordinatensystem vor dem Rendern der Linie und verschieben es nach rechts.  Wenn wir mit dem Zeichnen der Linie fertig sind und ganz nach rechts gegangen sind, werden die Koordinaten wiederhergestellt und wir kehren zum urspr√ºnglichen Zustand zur√ºck.  Dann gehen wir nach unten, um uns darauf vorzubereiten, die n√§chste Linie zu zeichnen. </li></ul><br>  Jetzt haben wir alle Teile, die f√ºr die Funktion <code>draw_rule</code> erforderlich sind.  Wir verwenden diese Funktion in <code>window.onload</code> nachdem wir den <code>canvas</code> vorbereitet haben.  Wir werden auch die Parameter bestimmen, die wir brauchen. <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.onload = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> width = <span class="hljs-number"><span class="hljs-number">1000</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Width of the canvas const height = 500; // Height of the canvas const cells_across = 200; // Number of cells horizontally in the grid const cell_scale = width / cells_across; // Size of each cell const cells_down = height / cell_scale; // Number of cells vertically in the grid const rule = get_rule(30); // The rule to display const canvas = document.createElement('canvas'); canvas.width = width; canvas.height = height; document.body.appendChild(canvas); const context = canvas.getContext('2d'); draw_rule(context, rule, cell_scale, cells_across, cells_down); };</span></span></code> </pre> <br>  Wir extrahieren die <code>canvas</code> als separate Variablen zusammen mit der Anzahl der Zellen horizontal.  Dann berechnen wir <code>cell_scale</code> und 'cells_down' so, dass das Raster die gesamte Zeichenfl√§che ausf√ºllt, w√§hrend die Zellen quadratisch bleiben.  Dank dessen k√∂nnen wir leicht die "Aufl√∂sung" des Gitters √§ndern, die innerhalb der <code>canvas</code> verbleibt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d98/566/33e/d9856633e69f731e69a8ae40a79591c2.png"></div><br>  Das ist alles!  Das vollst√§ndige Codebeispiel ist auf <a href="" rel="nofollow">Github</a> und auf <a href="https://codepen.io/kgolid/pen/oNgZKqV" rel="nofollow">Codepen</a> : <br><br><h2>  Weitermachen </h2><br>  Dank dieses Systems k√∂nnen wir nacheinander alle 256 Regeln √ºberpr√ºfen, entweder iterativ, indem wir den Code √§ndern oder bei jedem Seitenaufruf eine zuf√§llige Regelnummer ausw√§hlen.  Wie dem auch sei, es ist sehr aufregend, all diese unvorhersehbaren Ergebnisse in unserer kontrollierten Umgebung zu untersuchen. <br><br>  Sie k√∂nnen auch den Anfangszustand der Zellen des Automaten zuf√§llig bestimmen, anstatt der statischen ‚Äûdurchgezogenen Nullen und einer Einheit‚Äú.  So erhalten wir noch unvorhersehbarere Ergebnisse.  Diese Version der Funktion <code>initial_row</code> kann folgenderma√üen geschrieben werden: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">random_initial_row</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">width</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.from(<span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(width), _ =&gt; <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor(<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random() * <span class="hljs-number"><span class="hljs-number">2</span></span>)); }</code> </pre> <br>  Unten sehen Sie, wie sehr diese √Ñnderung der Ausgabezeile einen gro√üen Einfluss auf die Ausgabe hat. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6a6/023/75e/6a602375ecbe522ad75829547ee92b5f.png"></div><br>  <i>Zuf√§llige Quellzeichenfolge</i> <br><br>  Und dies ist nur ein Aspekt, den Sie √§ndern k√∂nnen!  Warum beschr√§nken Sie sich nur auf zwei Bedingungen?  (Der √úbergang von 2 zu 3 Staaten erh√∂ht die Anzahl der Regeln von 256 auf 7 625 597 484 987!) Warum auf Quadrate beschr√§nken?  Warum nur 2 Dimensionen?  Warum immer nur eine Regel? <br><br>  Beispiele f√ºr Visualisierungen, die auf ECA basieren, sind unten aufgef√ºhrt, jedoch mit einer alternativen Funktion <code>draw_rule</code> , <code>draw_rule</code> Linien nicht mit Quadraten, sondern mit einem isometrischen Muster zeichnet und anschlie√üend die durch diese Linien definierten Bereiche mit Farben f√ºllt.  Sie m√ºssen nicht einmal Trennlinien anzeigen und nur Farben anzeigen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/028/8da/3c1/0288da3c139cf936f21eccce5342a6d6.jpg"></div><br>  Wenn Sie noch weiter gehen, k√∂nnen Sie Symmetrien hinzuf√ºgen, sowohl axial (mittlere Reihe) als auch gespiegelt (untere Reihe). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f71/cad/adc/f71cadadc23b156366f5bb93669d8b06.jpg"></div><br>  Wenn Ihnen diese Visualisierungen interessant erschienen, studieren Sie <a href="https://generated.space/sketch/hatch-automata-full/" rel="nofollow">diese interaktive Sandbox</a> , oder noch besser, beginnen Sie mit dem Code, den wir erstellt haben, und versuchen Sie, Ihre eigenen zellularen Automaten zu entwickeln! <br><br>  Viel gl√ºck </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de481672/">https://habr.com/ru/post/de481672/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de481662/index.html">Erprobung neuer Tools zum Erstellen und Automatisieren der Bereitstellung in Kubernetes</a></li>
<li><a href="../de481664/index.html">Serverlose Preise und Kosten: AWS Lambda</a></li>
<li><a href="../de481666/index.html">Benutzerdefinierte SwiftLint-Regeln</a></li>
<li><a href="../de481668/index.html">Das erste Problem mit dem Viewer oder die Schwierigkeiten beim Konvertieren von WebRTC-Videostreams in HLS</a></li>
<li><a href="../de481670/index.html">Erstellen Sie einen Aktionsplan mit dem AWS Cloud Adoption Framework</a></li>
<li><a href="../de481674/index.html">Autoverkaufstrichter oder wie man Kunden nicht zusammenf√ºhrt und sogar mit denen zusammenarbeitet, die Ihre Dienste verweigert haben?</a></li>
<li><a href="../de481676/index.html">Sicherheitswoche 52: Sicherheit f√ºr intelligente Lautsprecher und IP-Kameras</a></li>
<li><a href="../de481678/index.html">Pre-Holiday Review: N6IIT01 Player und YB04 Armature Headphones - Hi-Fi aus S√ºdchina</a></li>
<li><a href="../de481680/index.html">TodoMVC auf dap schreiben. Teil 2</a></li>
<li><a href="../de481684/index.html">Ein Laptop von Powerbank?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>