<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🗨️ 🧕🏻 🖕🏿 Terikat GPU. Cara mentransfer semuanya ke kartu video dan sedikit lagi. Animasi 👩🏿‍🤝‍👨🏽 💬 👩‍💻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sekali waktu, itu adalah peristiwa besar ketika unit multitekstur atau transformasi & pencahayaan perangkat keras (T&L) muncul di GPU. Pengaturan Pipe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Terikat GPU. Cara mentransfer semuanya ke kartu video dan sedikit lagi. Animasi</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/468549/">  Sekali waktu, itu adalah peristiwa besar ketika unit multitekstur atau transformasi &amp; pencahayaan perangkat keras (T&amp;L) muncul di GPU.  Pengaturan Pipeline Fixed Function adalah sihir perdukunan.  Dan mereka yang tahu cara mengaktifkan dan menggunakan fitur canggih dari chip tertentu melalui peretasan API D3D9, menganggap diri mereka telah mempelajari Zen.  Tetapi waktu berlalu, shader muncul.  Pada awalnya, sangat terbatas baik dalam fungsi maupun panjangnya.  Lebih jauh, semakin banyak fitur, lebih banyak instruksi, lebih banyak kecepatan.  Compute (CUDA, OpenCL, DirectCompute) muncul, dan ruang lingkup kapasitas kartu video mulai berkembang dengan cepat. <br><br>  Dalam seri artikel (semoga) ini, saya akan mencoba menjelaskan dan menunjukkan bagaimana "luar biasa" Anda dapat menerapkan kemampuan GPU modern saat mengembangkan game, selain efek grafis.  Bagian pertama akan dikhususkan untuk sistem animasi.  Segala sesuatu yang dijelaskan didasarkan pada pengalaman praktis, diimplementasikan dan bekerja dalam proyek game nyata. <br><a name="habracut"></a><br>  Oooo, sekali lagi animasinya.  Tentang ini seratus kali sudah ditulis dan dijelaskan.  Apa yang rumit?  Kami mengemas matriks tulang dalam buffer / tekstur, dan menggunakannya untuk menguliti vertex shader.  Ini dijelaskan kembali dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GPU Permata 3 (Bab 2. Animated Crowd Rendering)</a> .  Dan diimplementasikan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Unite Tech Presentation</a> baru-baru ini.  Apakah mungkin dengan cara lain? <br><br><h4>  Technodemka dari Unity </h4><br>  Banyak hype, tetapi apakah itu benar-benar keren?  Ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sebuah artikel</a> di hub yang menjelaskan secara rinci bagaimana animasi kerangka dibuat dan bekerja di techno-demo ini.  Pekerjaan paralel semuanya bagus, kami tidak menganggapnya.  Tetapi kita perlu mencari tahu apa dan bagaimana di sana, dalam hal rendering. <br><br>  Dalam pertempuran skala besar, dua pasukan bertempur, masing-masing terdiri dari satu jenis unit.  Tengkorak di sebelah kiri, ksatria di sebelah kanan.  Keragaman begitu-begitu.  Setiap unit terdiri dari 3 LOD (masing-masing ~ 300, ~ 1000, ~ 4000 simpul), dan hanya 2 tulang yang memengaruhi verteks.  Sistem animasi hanya terdiri dari 7 animasi untuk setiap jenis unit (saya ingat sudah ada 2 dari mereka).  Animasi tidak berbaur, tetapi beralih secara terpisah dari kode sederhana yang dieksekusi di job'ax, yang ditekankan dalam presentasi.  Tidak ada mesin negara.  Saat kami memiliki dua jenis mesh, Anda dapat menarik seluruh kerumunan dalam dua panggilan draw yang dilakukan secara instan.  Animasi kerangka, seperti yang sudah saya tulis, didasarkan pada teknologi yang dijelaskan pada tahun 2009. <br>  Inovatif?  Hmm ... sebuah terobosan?  Mm ... Cocok untuk gim modern?  Yah, mungkin, rasio FPS dengan jumlah unit membanggakan. <br><br>  Kerugian utama dari pendekatan ini (pra-matriks dalam tekstur): <br><br><ol><li>  Tingkat frame tergantung.  Ingin dua kali lebih banyak bingkai animasi - beri memori dua kali lebih banyak. </li><li>  Kurangnya animasi campuran.  Anda dapat membuatnya, tentu saja, tetapi di skin shader akan muncul kekacauan yang kompleks dari logika campuran. </li><li>  Kurang mengikat ke mesin negara Unity Animator.  Alat yang mudah digunakan untuk menyesuaikan perilaku karakter, yang dapat dihubungkan ke sistem skinning, tetapi dalam kasus kami, karena poin 2, semuanya menjadi sangat sulit (bayangkan bagaimana cara memadukan BlendTree yang bersarang). </li></ol><br><h4>  GPAS </h4><br>  Sistem Animasi yang Didukung GPU.  Nama itu baru saja muncul. <br>  Sistem animasi baru memiliki beberapa persyaratan: <br><br><ol><li>  Bekerja cepat (well, dapat dimengerti).  Anda perlu menghidupkan puluhan ribu unit yang berbeda. </li><li>  Jadilah analog yang lengkap (atau hampir) dari sistem animasi Unity.  Jika ada animasi yang terlihat seperti ini, maka dalam sistem baru itu harus terlihat persis sama.  Kemampuan untuk beralih antara sistem CPU dan GPU bawaan.  Ini sering diperlukan untuk debugging.  Ketika animasi "buggy", dengan beralih ke animator klasik, Anda dapat mengerti: ini adalah gangguan dari sistem baru, atau mesin negara / animasi itu sendiri. </li><li>  Semua animasi dapat disesuaikan di Unity Animator.  Alat yang siap digunakan, nyaman, dan paling penting.  Kami akan membuat sepeda di tempat lain. </li></ol><br>  Mari kita pikirkan kembali persiapan dan pembuatan animasi.  Kami tidak akan menggunakan matriks.  Kartu video modern bekerja dengan baik dengan loop, secara native mendukung int selain float, jadi kami akan bekerja dengan keyframe seperti pada CPU. <br><br>  Mari kita lihat contoh animasi di Penampil Animasi: <br><br><img src="https://habrastorage.org/webt/_4/yw/bg/_4ywbgkzw8frqb3pjng98db5zwm.jpeg"><br><br>  Dapat dilihat bahwa keyframe diatur secara terpisah untuk posisi, skala dan rotasi.  Untuk beberapa tulang, Anda membutuhkan banyak dari mereka, untuk beberapa hanya beberapa, dan untuk tulang-tulang yang tidak dianimasikan secara terpisah, hanya kerangka kunci awal dan akhir yang ditetapkan. <br><br>  Posisi - Vector3, angka empat - Vector4, skala - Vector3.  Struktur keyframe akan memiliki satu kesamaan (untuk penyederhanaan), jadi kita perlu 4 float agar sesuai dengan salah satu tipe di atas.  Kami juga membutuhkan InTangent dan OutTangent untuk interpolasi yang benar antara keyframe sesuai dengan kelengkungan.  Oh ya, dan waktu yang dinormalkan tidak lupa: <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">KeyFrame</span></span></span><span class="hljs-class"> {</span></span> float4 v; float4 inTan, outTan; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> time; };</code> </pre> <br>  Untuk mendapatkan semua kerangka kunci, gunakan AnimationUtility.GetEditorCurve (). <br>  Juga, kita harus mengingat nama-nama tulang, karena akan perlu untuk memetakan kembali tulang animasi di tulang kerangka (dan mereka mungkin tidak bertepatan) pada tahap mempersiapkan data GPU. <br><br>  Mengisi buffer linear dengan array keyframe, kita akan mengingat offset di dalamnya untuk menemukan yang berhubungan dengan animasi yang kita butuhkan. <br><br>  Sekarang menarik.  Animasi kerangka GPU. <br><br>  Kami menyiapkan besar ("jumlah kerangka animasi" X "jumlah tulang dalam kerangka" X "koefisien empiris dari jumlah maksimum campuran animasi").  Di dalamnya kita akan menyimpan posisi, rotasi dan skala tulang pada saat animasi.  Dan untuk semua tulang animasi yang direncanakan dalam bingkai ini, jalankan compute shader.  Setiap utas menjiwai tulangnya. <br><br>  Setiap kerangka kunci, terlepas dari ukurannya (Translate, Rotation, Scale), diinterpolasi dengan cara yang persis sama (cari dengan pencarian linear, maafkan saya Knuth): <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InterpolateKeyFrame</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(inout float4 rv, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> startIdx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> endIdx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> t)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = startIdx; i &lt; endIdx; ++i) { KeyFrame k0 = keyFrames[i + <span class="hljs-number"><span class="hljs-number">0</span></span>]; KeyFrame k1 = keyFrames[i + <span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> lerpFactor = (t - k0.time) / (k1.time - k0.time); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (lerpFactor &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> || lerpFactor &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; rv = CurveInterpoate(k0, k1, lerpFactor); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } }</code> </pre><br>  Kurva adalah kurva Bezier kubik, sehingga fungsi interpolasi adalah sebagai berikut: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">float4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CurveInterpoate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(KeyFrame v0, KeyFrame v1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> t)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> dt = v1.time - v0.time; float4 m0 = v0.outTan * dt; float4 m1 = v1.inTan * dt; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t2 = t * t; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t3 = t2 * t; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> a = <span class="hljs-number"><span class="hljs-number">2</span></span> * t3 - <span class="hljs-number"><span class="hljs-number">3</span></span> * t2 + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> b = t3 - <span class="hljs-number"><span class="hljs-number">2</span></span> * t2 + t; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> c = t3 - t2; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> d = <span class="hljs-number"><span class="hljs-number">-2</span></span> * t3 + <span class="hljs-number"><span class="hljs-number">3</span></span> * t2; float4 rv = a * v0.v + b * m0 + c * m1 + d * v1.v; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rv; }</code> </pre><br>  Postur lokal (TRS) dari tulang dihitung.  Selanjutnya, dengan penghitung komputasi terpisah, kami memadukan semua animasi yang diperlukan untuk tulang ini.  Untuk melakukan ini, kami memiliki buffer dengan indeks animasi dan bobot masing-masing animasi dalam campuran terakhir.  Kami mendapatkan informasi ini dari mesin negara.  Situasi BlendTree di dalam BlendTree diselesaikan sebagai berikut.  Misalnya, ada pohon: <br><br><img src="https://habrastorage.org/webt/yg/n6/_4/ygn6_4arygdkgbnigucbv0tz0fe.jpeg"><br><br>  BlendTree Walk akan memiliki berat 0,35, Jalankan - 0,65.  Dengan demikian, posisi akhir dari tulang harus ditentukan oleh 4 animasi: Walk1, Walk2, Run1 dan Run2.  Bobot mereka akan memiliki nilai (0,35 * 0,92, 0,35 * 0,08, 0,65 * 0,92, 0,65 * 0,08) = (0,322, 0,028, 0,598, 0,052), masing-masing.  Perlu dicatat bahwa jumlah bobot harus selalu sama dengan satu, atau bug sihir disediakan. <br><br>  "Jantung" dari fungsi blending: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> bw = animDef.blendWeight; BoneXForm boneToBlend = animatedBones[srcBoneIndex]; float4 q = boneToBlend.quat; float3 t = boneToBlend.translate; float3 s = boneToBlend.scale; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dot(resultBone.quat, q) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) q = -q; resultBone.translate += t * bw; resultBone.quat += q * bw; resultBone.scale += s * bw;</code> </pre><br>  Sekarang Anda dapat menerjemahkannya ke dalam matriks transformasi.  Berhenti  Tentang hierarki tulang benar-benar dilupakan. <br>  Berdasarkan data dari kerangka, kami membangun array indeks, di mana sel dengan indeks tulang berisi indeks induknya.  Di root, tulis -1. <br><br>  Contoh: <br><br><img src="https://habrastorage.org/webt/c0/8v/tl/c08vtlrw1w80dsczyczusebox34.jpeg"><br><br><pre> <code class="cpp hljs">float4x4 animMat = IdentityMatrix(); float4x4 mat = initialPoses[boneId]; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (boneId &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { BoneXForm b = blendedBones[boneId]; float4x4 xform = MakeTransformMatrix(b.translate, b.quat, b.scale); animMat = mul(animMat, xform); boneId = bonesHierarchyIndices[boneId]; } mat = mul(mat, animMat); resultSkeletons[id] = mat;</code> </pre><br>  Di sini, pada prinsipnya, semua poin utama rendering dan campuran animasi. <br><br><h4>  GPSM </h4><br>  Mesin yang Didukung GPU (Anda menebaknya dengan benar).  Sistem animasi yang dijelaskan di atas akan bekerja dengan sempurna dengan Unity Animation State Machine, tetapi semua upaya akan sia-sia.  Dengan kemungkinan menghitung puluhan (jika bukan ratusan) ribuan animasi per bingkai, UnityAnimator tidak akan menarik ribuan mesin negara yang bekerja secara bersamaan.  Hmm ... <br>  Apa itu mesin negara di Unity?  Ini adalah sistem tertutup keadaan dan transisi, yang dikendalikan oleh sifat numerik sederhana.  Setiap mesin keadaan beroperasi secara independen satu sama lain, dan untuk set input data yang sama.  Tunggu sebentar.  Ini adalah tugas yang ideal untuk GPU dan menghitung shader! <br><br>  <u>Fase pembakaran</u> <br><br>  Pertama, kita perlu mengumpulkan dan menempatkan semua data mesin negara dalam struktur ramah GPU.  Dan ini: status (status), transisi (transisi) dan parameter (parameter). <br>  Semua data ini ditempatkan dalam buffer linear, dan ditangani oleh indeks. <br>  Setiap utas komputasi mempertimbangkan mesin negaranya.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">AnimatorController</a> menyediakan antarmuka untuk semua struktur mesin keadaan internal yang diperlukan. <br><br>  Struktur utama mesin negara: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> speed; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> firstTransition; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> numTransitions; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> animDefId; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Transition</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> exitTime; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> duration; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sourceStateId; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> targetStateId; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> firstCondition; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> endCondition; uint properties; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StateData</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> timeInState; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> animationLoop; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TransitionData</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> timeInTransition; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CurrentState</span></span></span><span class="hljs-class"> {</span></span> StateData srcState, dstState; TransitionData transition; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AnimationDef</span></span></span><span class="hljs-class"> {</span></span> uint animId; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nextAnimInTree; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> parameterIdx; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> lengthInSec; uint numBones; uint loop; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ParameterDef</span></span></span><span class="hljs-class"> {</span></span> float2 line0ab, line1ab; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> runtimeParamId; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nextParameterId; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Condition</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> checkMode; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> runtimeParamIndex; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> referenceValue; };</code> </pre><br><ul><li>  Negara berisi kecepatan di mana negara dimainkan, dan indeks kondisi untuk transisi ke orang lain sesuai dengan mesin negara. </li><li>  Transisi berisi indeks status "dari" dan "ke".  Waktu transisi, waktu keluar, dan tautan ke berbagai kondisi untuk memasuki kondisi ini. </li><li>  CurrentState adalah blok data runtime dengan data pada keadaan saat ini dari mesin negara. </li><li>  AnimationDef berisi deskripsi animasi dengan tautan ke orang lain yang terkait dengannya oleh BlendTree. </li><li>  ParameterDef adalah deskripsi dari parameter yang mengontrol perilaku mesin negara.  Line0ab dan Line1ab adalah koefisien dari persamaan garis untuk menentukan berat animasi dengan nilai parameter.  Dari sini: <br><br><img src="https://habrastorage.org/webt/ge/dl/wd/gedlwdz-u4iiyqciuy-lewx8xnm.jpeg"><br></li><li>  Kondisi - spesifikasi kondisi untuk membandingkan nilai runtime dari parameter dan nilai referensi. </li></ul><br>  <u>Fase runtime</u> <br><br>  Siklus utama setiap mesin negara dapat ditampilkan menggunakan algoritma berikut: <br><br><img src="https://habrastorage.org/webt/q_/cu/gc/q_cugcb1tr2krdkztmuxbr1yds8.jpeg"><br><br>  Ada 4 jenis parameter di Unity animator: float, int, bool dan trigger (yang bool).  Kami akan menyajikan semuanya sebagai pelampung.  Saat mengatur kondisi, dimungkinkan untuk memilih satu dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">enam</a> jenis perbandingan.  Jika == Setara.  IfNot == NotEqual.  Jadi kita hanya akan menggunakan 4. Indeks operator dilewatkan ke bidang checkMode dari struktur Condition. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = t.firstCondition; i &lt; t.endCondition; ++i) { Condition c = allConditions[i]; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> paramValue = runtimeParameters[c.runtimeParamIndex]; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (c.checkMode) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (paramValue &lt; c.referenceValue) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (paramValue &gt; c.referenceValue) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(paramValue - c.referenceValue) &gt; <span class="hljs-number"><span class="hljs-number">0.001f</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(paramValue - c.referenceValue) &lt; <span class="hljs-number"><span class="hljs-number">0.001f</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>;</code> </pre><br>  Untuk memulai transisi, semua kondisi harus benar.  Label case aneh hanya (int) AnimatorConditionMode.  Logika interupsi adalah logika yang rumit untuk mengganggu dan mengembalikan transisi. <br><br>  Setelah kami memperbarui keadaan mesin keadaan dan menggulir perangko waktu pada bingkai delta, saatnya untuk menyiapkan data tentang animasi apa yang harus dibaca dalam bingkai ini, dan bobot yang sesuai.  Langkah ini dilewati jika model unit tidak ada dalam bingkai (Frustum culled).  Mengapa kita harus mempertimbangkan animasi yang tidak terlihat?  Kami pergi ke negara sumber pohon campuran, sesuai dengan negara tujuan pohon campuran, menambahkan semua animasi dari mereka, dan kami menghitung bobot dengan waktu transisi normal dari sumber ke tujuan (waktu yang dihabiskan dalam transisi).  Dengan data yang disiapkan, GPAS ikut bermain, dan menghitung animasi untuk setiap entitas animasi dalam game. <br><br>  Parameter kontrol unit berasal dari logika kontrol unit.  Misalnya, Anda perlu mengaktifkan running, mengatur parameter CharSpeed, dan mesin state yang dikonfigurasikan dengan benar memadukan animasi transisi dari "berjalan" ke "berlari". <br><br>  Secara alami, analogi lengkap dengan Unity Animator tidak berhasil.  Prinsip kerja internal, jika tidak dijelaskan dalam dokumentasi, harus dibalik dan dibuat analog.  Beberapa fungsionalitas belum selesai (mungkin tidak).  Misalnya, BlendType di BlendTree hanya mendukung 1D.  Untuk membuat jenis lain, pada prinsipnya, tidak sulit, hanya saja sekarang tidak perlu.  Tidak ada acara animasi, karena itu perlu untuk melakukan pembacaan kembali dengan GPU, dan pembacaan yang "benar" akan ada beberapa frame di belakang, yang tidak selalu dapat diterima.  Tetapi itu juga mungkin. <br><br><h4>  Render </h4><br>  Render unit dilakukan melalui instancing.  Menurut SV_InstanceID, dalam vertex shader, kita mendapatkan matriks dari semua tulang yang memengaruhi vertex, dan mengubahnya.  Sama sekali tidak ada yang aneh: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">float4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ApplySkin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float3 v, uint vertexID, uint instanceID)</span></span></span><span class="hljs-function"> </span></span>{ BoneInfoPacked bip = boneInfos[vertexID]; BoneInfo bi = UnpackBoneInfo(bip); SkeletonInstance skelInst = skeletonInstances[instanceID]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bonesOffset = skelInst.boneOffset; float4x4 animMat = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> bw = bi.boneWeights[i]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bw &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { uint boneId = bi.boneIDs[i]; float4x4 boneMat = boneMatrices[boneId + bonesOffset]; animMat += boneMat * bw; } } float4 rv = float4(v, <span class="hljs-number"><span class="hljs-number">1</span></span>); rv = mul(rv, animMat); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rv; }</code> </pre><br><h4>  Ringkasan </h4><br>  Apakah peternakan ini bekerja cepat?  Jelas lebih lambat daripada mencicipi tekstur dengan matriks, tapi tetap saja, saya bisa menunjukkan beberapa angka (GTX 970). <br><br>  Berikut adalah 50.000 mesin negara: <br><br><img src="https://habrastorage.org/webt/cw/bv/4o/cwbv4oww0dles0lwgt-xlsqxg5m.jpeg"><br><br>  Berikut adalah 280.000 tulang animasi: <br><br><img src="https://habrastorage.org/webt/pe/lt/pv/peltpvbyztjsutrkxmhxyjbimbs.jpeg"><br><br>  Merancang dan men-debug semua ini adalah hal yang sangat menyakitkan.  Sekelompok buffer dan offset.  Banyak komponen dan interaksinya.  Ada saat-saat ketika tangan jatuh ketika Anda memukul kepala Anda tentang suatu masalah selama beberapa hari, tetapi Anda tidak dapat menemukan apa masalahnya.  Terutama "bagus" ketika semuanya berfungsi sebagaimana mestinya pada data uji, tetapi dalam situasi "pertarungan" nyata tidak ada kesalahan animasi apa pun.  Perbedaan antara pengoperasian mesin status Persatuan dan miliknya juga tidak segera terlihat.  Secara umum, jika Anda memutuskan untuk membuat analog untuk diri sendiri, maka saya tidak iri dengan Anda.  Sebenarnya, seluruh pengembangan di bawah GPU adalah hal yang patut dikeluhkan. <br><br>  <b>NB</b> Saya ingin melempar batu di taman pengembang Unite TechDemo.  Mereka memiliki sejumlah besar model identik reruntuhan dan jembatan di atas panggung, dan mereka tidak mengoptimalkan rendering mereka dengan cara apa pun.  Sebaliknya, mereka mencoba dengan mencentang "statis".  Hanya sekarang, dalam indeks 16-bit Anda tidak dapat menjejalkan banyak geometri (tiga kali haha, 2017) dan tidak ada yang datang bersamaan, karena modelnya sangat poligonal.  Saya menempatkan "Aktifkan Instancing" untuk semua shader, dan "Statis" tidak dicentang.  Tidak ada dorongan nyata, tapi, sial, Anda melakukan demo teknologi, berjuang untuk setiap FPS.  Anda tidak bisa omong kosong seperti itu. <br><br><div class="spoiler">  <b class="spoiler_title">Apakah</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">*** Summary *** Draw calls: 2553 Dispatch calls: 0 API calls: 8378 Index/vertex bind calls: 2992 Constant bind calls: 648 Sampler bind calls: 395 Resource bind calls: 805 Shader set calls: 682 Blend set calls: 230 Depth/stencil set calls: 92 Rasterization set calls: 238 Resource update calls: 1017 Output set calls: 74 API:Draw/Dispatch call ratio: 3.28163 298 Textures - 1041.01 MB (1039.95 MB over 32x32), 42 RTs - 306.94 MB. Avg. tex dimension: 1811.77x1810.21 (2016.63x2038.98 over 32x32) 216 Buffers - 180.11 MB total 17.54 MB IBs 159.81 MB VBs. 1528.06 MB - Grand total GPU buffer + texture load. *** Draw Statistics *** Total calls: 2553, instanced: 2, indirect: 2 Instance counts: 1: 2: 3: 4: 5: 6: 7: 8: 9: 10: 11: 12: 13: 14: &gt;=15: ******************************************************************************************************************************** (2)</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Telah menjadi</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">*** Summary *** Draw calls: 1474 Dispatch calls: 0 API calls: 11106 Index/vertex bind calls: 3647 Constant bind calls: 1039 Sampler bind calls: 348 Resource bind calls: 718 Shader set calls: 686 Blend set calls: 230 Depth/stencil set calls: 110 Rasterization set calls: 258 Resource update calls: 1904 Output set calls: 74 API:Draw/Dispatch call ratio: 7.5346 298 Textures - 1041.01 MB (1039.95 MB over 32x32), 42 RTs - 306.94 MB. Avg. tex dimension: 1811.77x1810.21 (2016.63x2038.98 over 32x32) 427 Buffers - 93.30 MB total 9.81 MB IBs 80.51 MB VBs. 1441.25 MB - Grand total GPU buffer + texture load. *** Draw Statistics *** Total calls: 1474, instanced: 391, indirect: 2 Instance counts: 1: 2: ******************************************************************************************************************************** (104) 3: ************************************************* (40) 4: ********************** (18) 5: ****************************** (25) 6: ********************************************************************************************* (76) 7: *********************************** (29) 8: ************************************************** (41) 9: ********* (8) 10: ************** (12) 11: 12: ****** (5) 13: ******* (6) 14: ** (2) &gt;=15: ****************************** (25)</code> </pre><br></div></div><br>  <b>PPS</b> Di sepanjang waktu, game terutama terikat dengan CPU, mis.  CPU tidak mengikuti GPU.  Terlalu banyak logika dan fisika.  Mentransfer bagian dari logika game dari CPU ke GPU, kami membongkar yang pertama dan memuat yang kedua, mis.  membuat situasi GPU terikat lebih mungkin.  Karenanya judul artikel. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id468549/">https://habr.com/ru/post/id468549/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id468537/index.html">Dasar-dasar DevOps. Masuk ke proyek dari awal</a></li>
<li><a href="../id468541/index.html">Seret - & - Jatuhkan komponen untuk pengguna tunanetra? Apakah kamu bercanda?</a></li>
<li><a href="../id468543/index.html">FrontendConf Komite Program Hari Kerja. Wawancara dengan Sergey Popov</a></li>
<li><a href="../id468545/index.html">"Alice, ayo pergi ke frontend!"</a></li>
<li><a href="../id468547/index.html">Berbicara Bahasa Inggris, CSS, Kisi dan Aksesibilitas di FrontendConf</a></li>
<li><a href="../id468553/index.html">Manajemen parameter dalam aplikasi bisnis mirip dengan sistem kontrol versi</a></li>
<li><a href="../id468555/index.html">Pengantar majelis deterministik dalam C / C ++. Bagian 2</a></li>
<li><a href="../id468557/index.html">WEB 3.0 - pendekatan kedua ke proyektil</a></li>
<li><a href="../id468559/index.html">Cadangkan cloud, teman-teman</a></li>
<li><a href="../id468561/index.html">Minggu Keamanan 39: kesalahan keamanan dan biasa</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>