<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëèüèº ü§¶üèº üë®‚Äçüë©‚Äçüëß Prueba de c√≥digo multiproceso y as√≠ncrono üë®‚Äçüé§ üôÉ üíî</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola Esta semana, la tarea consist√≠a en escribir una prueba de integraci√≥n para una aplicaci√≥n Spring Boot utilizando la interacci√≥n asincr√≥nica con s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Prueba de c√≥digo multiproceso y as√≠ncrono</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/472152/"> Hola  Esta semana, la tarea consist√≠a en escribir una prueba de integraci√≥n para una aplicaci√≥n Spring Boot utilizando la interacci√≥n asincr√≥nica con sistemas externos.  Se actualiz√≥ mucho material sobre la depuraci√≥n de c√≥digo multiproceso.  El art√≠culo "Prueba de c√≥digo multiproceso y asincr√≥nico" por Jonathan Halterman, cuya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">traducci√≥n</a> se da a continuaci√≥n, atrajo la atenci√≥n. <br><a name="habracut"></a><br>  Gracias a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">shalomman</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">schroeder</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">FTOH</a> por los comentarios de c√≥digo m√°s importantes del art√≠culo original. <br><br>  Si escribe c√≥digo el tiempo suficiente o tal vez no, entonces probablemente se encontr√≥ con un script en el que necesita probar el c√≥digo multiproceso.  Generalmente se cree que los hilos y las pruebas no deben mezclarse.  Esto generalmente sucede porque  lo que se debe probar solo comienza dentro de un sistema de subprocesos m√∫ltiples y se puede probar individualmente sin usar hilos.  Pero, ¬øqu√© sucede si no puede separarlos, o m√°s, si el subproceso m√∫ltiple es ese aspecto del c√≥digo que est√° probando? <br><br>  Estoy aqu√≠ para decirles que aunque los hilos en las pruebas no son muy comunes, son bastante utilizados.  La polic√≠a de software no lo arrestar√° por comenzar un subproceso en una prueba de unidad, aunque la forma de probar el c√≥digo multiproceso es otra cuesti√≥n.  Algunas excelentes tecnolog√≠as asincr√≥nicas, como Akka y Vert.x, proporcionan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">kits de prueba</a> para aliviar esta carga.  Pero m√°s all√° de eso, probar c√≥digo de subprocesos m√∫ltiples generalmente requiere un enfoque diferente al de una prueba de unidad s√≠ncrona t√≠pica. <br><br><h2>  Vamos paralelos </h2><br>  El primer paso es iniciar cualquier acci√≥n multiproceso para la que desee verificar el resultado.  Por ejemplo, usemos una API hipot√©tica para registrar un controlador de mensajes en un bus de mensajes y publicar un mensaje en el bus, que se entregar√° a nuestro controlador de forma asincr√≥nica en un hilo separado: <br><br><pre><code class="java hljs">messageBus.registerHandler(message - &gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"Received "</span></span> + message); }); messageBus.publish(<span class="hljs-string"><span class="hljs-string">"test"</span></span>);</code> </pre> <br>  Se ve bien  Cuando comienza la prueba, el bus debe entregar nuestro mensaje al controlador en otro hilo, pero esto no es muy √∫til, ya que no verificamos nada.  Actualicemos nuestra prueba para confirmar que el bus de mensajes entrega nuestro mensaje como se esperaba: <br><br><pre> <code class="java hljs">String msg = <span class="hljs-string"><span class="hljs-string">"test"</span></span>; messageBus.registerHandler(message -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"Received "</span></span> + message); assertEquals(message, msg); }; messageBus.publish(msg);</code> </pre> <br>  Se ve mejor.  Ejecutamos nuestra prueba y es verde.  Genial!  Pero el mensaje Recibido no se imprimi√≥ en ninguna parte, algo estaba mal en alguna parte. <br><br><h2>  Espera un segundo </h2><br>  En la prueba anterior, cuando se publica un mensaje en el bus de mensajes, el bus lo entrega al controlador en otro hilo.  Pero cuando una herramienta de prueba de unidades como JUnit ejecuta una prueba, no sabe nada sobre los flujos del bus de mensajes.  JUnit solo conoce el hilo principal en el que ejecuta la prueba.  Por lo tanto, mientras el bus de mensajes est√° ocupado tratando de entregar el mensaje, la prueba completa la ejecuci√≥n en el hilo de prueba principal y JUnit informa de √©xito.  ¬øC√≥mo resolver esto?  Necesitamos el hilo de prueba principal para esperar a que el bus de mensajes entregue nuestro mensaje.  As√≠ que agreguemos una declaraci√≥n de suspensi√≥n: <br><br><pre> <code class="java hljs">String msg = <span class="hljs-string"><span class="hljs-string">"test"</span></span>; messageBus.registerHandler(message -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"Received "</span></span> + message); assertEquals(message, msg); }; messageBus.publish(msg); Thread.sleep(<span class="hljs-number"><span class="hljs-number">1000</span></span>);</code> </pre> <br>  Nuestra prueba es verde y la expresi√≥n Recibido se imprime como se esperaba.  Genial!  Pero un segundo de sue√±o significa que nuestra prueba se realiza durante al menos un segundo, y no tiene nada de bueno.  Podr√≠amos reducir el tiempo de sue√±o, pero luego corremos el riesgo de completar la prueba antes de recibir un mensaje.  Necesitamos una forma de coordinar entre el hilo de prueba principal y el hilo del controlador de mensajes.  Mirando el paquete <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">java.util.concurrent</a> , estamos seguros de encontrar lo que podemos usar.  ¬øQu√© pasa con <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CountDownLatch</a> ? <br><br><pre> <code class="java hljs">String msg = <span class="hljs-string"><span class="hljs-string">"test"</span></span>; CountDownLatch latch = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CountDownLatch(<span class="hljs-number"><span class="hljs-number">1</span></span>); messageBus.registerHandler(message -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"Received "</span></span> + message); assertEquals(message, msg); latch.countDown(); }; messageBus.publish(msg); latch.await();</code> </pre> <br>  En este enfoque, compartimos CountDownLatch entre el hilo de prueba principal y el hilo del controlador de mensajes.  El hilo principal se ve obligado a esperar en el bloqueador.  El hilo de prueba libera el hilo principal pendiente llamando a countDown () en el bloqueador despu√©s de recibir el mensaje.  Ya no necesitamos dormir por un segundo.  Nuestra prueba lleva exactamente tanto tiempo como sea necesario. <br><br><h2>  Tan feliz? </h2><br>  Con nuestro nuevo encanto, CountDownLatch, comenzamos a escribir pruebas de subprocesos m√∫ltiples, como las √∫ltimas fashionistas.  Pero bastante r√°pido, notamos que uno de nuestros casos de prueba est√° bloqueado para siempre y no termina.  Que esta pasando  Considere el escenario del bus de mensajes: el bloqueador lo hace esperar, pero se libera solo despu√©s de recibir el mensaje.  Si el bus no funciona y el mensaje nunca se entrega, la prueba nunca terminar√°.  Entonces agreguemos un tiempo de espera al bloqueador: <br><br><pre> <code class="java hljs">latch.await(<span class="hljs-number"><span class="hljs-number">1</span></span>, TimeUnit.SECONDS);</code> </pre> <br>  Una prueba que est√° bloqueada falla despu√©s de 1 segundo con una excepci√≥n TimeoutException.  Al final, encontraremos el problema y solucionaremos la prueba, pero decidiremos dejar los tiempos de espera en su lugar.  Si esto vuelve a ocurrir, preferir√≠amos que nuestra prueba se bloquee por un segundo y se bloquee, que bloquear para siempre y no completarla en absoluto. <br>  Otro problema que notamos cuando escribimos ex√°menes es que todos parecen pasar incluso cuando probablemente no deber√≠an.  ¬øC√≥mo es esto posible?  Considere la prueba de procesamiento de mensajes nuevamente: <br><br><pre> <code class="java hljs">messageBus.registerHandler(message -&gt; { assertEquals(message, msg); latch.countDown(); };</code> </pre> <br>  Deber√≠amos haber usado CountDownLatch para coordinar la finalizaci√≥n de nuestra prueba con el hilo de prueba principal, pero ¬øqu√© pasa con las afirmaciones?  Si la validaci√≥n falla, ¬øJUnit lo sabr√°?  Resulta que, dado que no realizamos la validaci√≥n en el subproceso de prueba principal, JUnit permanece completamente desapercibido.  Probemos un peque√±o script para probar esto: <br><br><pre> <code class="java hljs">CountDownLatch latch = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CountDownLatch(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(() -&gt; { assertTrue(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); latch.countDown(); }).start(); latch.await();</code> </pre> <br>  ¬°La prueba es verde!  Entonces, ¬øqu√© hacemos ahora?  Necesitamos una forma de enviar cualquier error de prueba desde la secuencia del controlador de mensajes a la secuencia de prueba principal.  Si ocurre una falla en el hilo del manejador de mensajes, necesitamos que vuelva a aparecer en el hilo principal para que la prueba se voltee, como se esperaba.  Intentemos hacer esto: <br><br><pre> <code class="java hljs">CountDownLatch latch = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CountDownLatch(<span class="hljs-number"><span class="hljs-number">1</span></span>); AtomicReference&lt;AssertionError&gt; failure = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AtomicReference&lt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(() -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { assertTrue(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (AssertionError e) { failure.set(e); } latch.countDown(); }).start(); latch.await(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (failure.get() != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> failure.get();</code> </pre> <br>  Inicio r√°pido y s√≠, la prueba falla, ¬°como deber√≠a!  Ahora podemos regresar y agregar bloques CountDownLatches, try / catch y AtomicReference a todos nuestros casos de prueba.  Genial!  En realidad, no es genial, parece una repetitiva. <br><br><h2>  Cortar la basura </h2><br>  Idealmente, necesitamos una API que nos permita coordinar la espera, la verificaci√≥n y la reanudaci√≥n de la ejecuci√≥n entre subprocesos, para que las pruebas unitarias puedan pasar o fallar como se esperaba, sin importar d√≥nde falle la validaci√≥n.  Afortunadamente, ConcurrentUnit proporciona un marco ligero que hace exactamente eso: Waiter.  Adaptemos la prueba de procesamiento de mensajes anterior por √∫ltima vez y veamos qu√© puede hacer Waiter de ConcurrentUnit por nosotros: <br><br><pre> <code class="java hljs">String msg = <span class="hljs-string"><span class="hljs-string">"test"</span></span>; Waiter waiter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Waiter(); messageBus.registerHandler(message -&gt; { waiter.assertEquals(message, msg); waiter.resume(); }; messageBus.publish(msg); waiter.await(<span class="hljs-number"><span class="hljs-number">1</span></span>, TimeUnit.SECONDS);</code> </pre> <br>  En esta prueba, vemos que Waiter ha tomado el lugar de nuestro CountDownLatch y AtomicReference.  Con Waiter, bloqueamos el hilo de prueba principal, realizamos la prueba, luego reanudamos el hilo de prueba principal para que la prueba pueda completarse.  Si la verificaci√≥n falla, entonces llamar a waiter.await liberar√° autom√°ticamente el bloqueo y lanzar√° una falla, lo que har√° que la prueba pase o falle, como deber√≠a ser, incluso si la verificaci√≥n se realiz√≥ desde otro hilo. <br><br><h2>  A√∫n m√°s paralelo </h2><br>  Ahora que nos hemos convertido en probadores de subprocesos m√∫ltiples certificados, es posible que deseemos confirmar que se est√°n produciendo varias acciones asincr√≥nicas.  ConcurrentUnit's Waiter hace esto simple: <br><br><pre> <code class="java hljs">Waiter waiter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Waiter(); messageBus.registerHandler(message -&gt; { waiter.resume(); }; messageBus.publish(<span class="hljs-string"><span class="hljs-string">"one"</span></span>); messageBus.publish(<span class="hljs-string"><span class="hljs-string">"two"</span></span>); waiter.await(<span class="hljs-number"><span class="hljs-number">1</span></span>, TimeUnit.SECONDS, <span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre> <br>  Aqu√≠ publicamos dos mensajes en el bus y verificamos que ambos se entreguen, haciendo que Waiter espere a que se llame a resume () 2 veces.  Si no se entregan mensajes y no se llama a reanudar dos veces en 1 segundo, la prueba fallar√° con un error de TimeoutException. <br>  Un consejo general con este enfoque es asegurarse de que sus tiempos de espera sean lo suficientemente largos para completar cualquier acci√≥n concurrente.  En condiciones normales, cuando el sistema bajo prueba funciona como se esperaba, el tiempo de espera no importa y solo tiene efecto en caso de falla del sistema por cualquier motivo. <br><br><h2>  Resumen </h2><br>  En este art√≠culo, aprendimos que las pruebas unitarias multiproceso no son malas y son bastante f√°ciles de hacer.  Aprendimos sobre el enfoque general cuando bloqueamos el hilo de prueba principal, realizamos comprobaciones de otros hilos y luego reanudamos el hilo principal.  Y aprendimos sobre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ConcurrentUnit</a> , que puede facilitar esta tarea. <br>  ¬°Feliz prueba! <br><br>  <b>Traducido por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">@middle_java</a></b> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/472152/">https://habr.com/ru/post/472152/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../472128/index.html">¬øPor qu√© me gusta PHP?</a></li>
<li><a href="../472130/index.html">¬øC√≥mo prevenir el alboroto de la compa√±√≠a?</a></li>
<li><a href="../472138/index.html">Digitalizaci√≥n de la educaci√≥n.</a></li>
<li><a href="../472144/index.html">Silbar a todos en Linux, truenos y rel√°mpagos</a></li>
<li><a href="../472148/index.html">Retrogaming: PAL vs NTSC. O por qu√© no se necesita PAL</a></li>
<li><a href="../472154/index.html">C√≥mo no perderse el presupuesto para la producci√≥n en serie de edificios-2: precios de moldeo de pl√°stico a peque√±a escala</a></li>
<li><a href="../472156/index.html">Implementaci√≥n del patr√≥n de objeto de p√°gina en Python + pytest</a></li>
<li><a href="../472158/index.html">"El proceso educativo en TI y no solo": concursos y eventos tecnol√≥gicos de la Universidad ITMO</a></li>
<li><a href="../472160/index.html">Phantom OS: subsistema de ventana - hacer controles</a></li>
<li><a href="../472162/index.html">Marketing por correo electr√≥nico subcontratado: c√≥mo construir y qu√© esperar</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>